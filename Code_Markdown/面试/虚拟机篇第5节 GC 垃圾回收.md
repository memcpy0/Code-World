加油，走向你想成为的自己！
# 一、面试题
谢飞机，小记！，中午吃饱了开始发呆，怎么就学不来这些知识呢，它也不进脑子！
谢飞机：喂，面试官大哥，我想问个问题。
面试官：什么？
谢飞机：就是这知识它不进脑子呀！
面试官：这....
谢飞机：就是看了忘，忘了看的！
面试官：是不是没有实践？只是看了就觉得会了，收藏了就表示懂了？哪哪都不
深入！？
谢飞机：好像是！那有什么办法？
面试官：也没有太好的办法，学习本身就是一件枯燥的事情。减少碎片化的时间浪费，多用在系统化的学习上会更好一些。哪怕你写写博客记录下，验证下也是好的。
# 二、动手验证垃圾回收
**说是垃圾回收，我不引用了它就回收了？什么时候回收的？咋回收的？**

没有看到实际的例子，往往就很难让理科生接受这类知识。我自己也一样，最好是让我看得见。代码是对数学逻辑的具体实现，没有实现过程只看答案是没有意义的。

## 测试代码
```java
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
    * 这个成员属性的唯一意义就是占点内存， 以便能在 GC 日志中看清楚是否有回收过
    */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void main(String[] args) {
        testGC();
    }
    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        // 假设在这行发生 GC， objA 和 objB 是否能被回收？
        System.gc();
    }
}
```
例子来自于《深入理解 Java 虚拟机》中引用计数算法章节。

例子要说明的结果是，**相互引用下却已经置为 null 的两个对象，是否会被 GC 回收**。如果只是按照引用计数器算法来看，那么这两个对象的计数标识不会为 0，也就不能被回收。但到底有没有被回收呢？

这里我们先采用 jvm 工具指令，jstat 来监控。因为监控的过程需要我手敲代码，比较耗时，所以我们在调用 testGC()前，睡眠会 Thread.sleep(55000);。
启动代码后执行如下指令。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305292307117.png)
- S0C、S1C，第一个和第二个幸存区大小
- S0U、S1U，第一个和第二个幸存区使用大小
- EC、EU，伊甸园的大小和使用
- OC、OU，老年代的大小和使用
- MC、MU，方法区的大小和使用
- CCSC、CCSU，压缩类空间大小和使用
- YGC、YGCT，年轻代垃圾回收次数和耗时
- FGC、FGCT，老年代垃圾回收次数和耗时
- GCT，垃圾回收总耗时

注意：观察后面三行，S1U = 1288.0、GCT = 0.003，说明已经在执行垃圾回收。接下来，我们再换种方式测试。在启动的程序中，加入 GC 打印参数，观察 GC 变化结果。
```bash
-XX:+PrintGCDetails 打印每次 gc 的回收情况 程序运行结束后打印堆空间内存信息(包含内存溢出
的情况)
-XX:+PrintHeapAtGC 打印每次 gc 前后的内存情况
-XX:+PrintGCTimeStamps 打印每次 gc 的间隔的时间戳 full gc 为每次对新生代老年代以及整个空间
做统一的回收 系统中应该尽量避免
-XX:+TraceClassLoading 打印类加载情况
-XX:+PrintClassHistogram 打印每个类的实例的内存占用情况
-Xloggc:/Users/xiaofuge/Desktop/logs/log.log 配合上面的使用将上面的日志打印到指定文件
-XX:HeapDumpOnOutOfMemoryError 发生内存溢出将堆信息转存起来 以便分析
```
从 `Java 9` 开始，一部分jvm 参数被废弃了
- 从运行结果可以看出内存回收日志，Full GC 进行了回收。
- 也可以看出 JVM 并不是依赖引用计数器的方式，判断对象是否存活。否则他们就不会被回收啦
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305292334375.png)
# 三、JVM 垃圾回收知识框架
垃圾收集（Garbage Collection，简称 GC），最早于 1960 年诞生于麻省理工学院的， **Lisp 是第一门开始使用内存动态分配和垃圾收集技术的语言**。

垃圾收集器主要做的三件事：哪些内存需要回收、什么时候回收、怎么回收。

而从垃圾收集器的诞生到现在有半个世纪的发展，现在的内存动态分配和内存回收技术已经非常成熟，一切看起来都进入了“自动化”。但在某些时候，还是需要我们去监测在高并发的场景下，是否有内存溢出、泄漏、GC 时间过程等问题。所以在了解和知晓垃圾收集的相关知识，对于高级程序员的成长就非常重要。

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305292335435.png)
## 1. 判断对象已死
### 1.1 引用计数器
1. 为每一个对象添加一个引用计数器，统计指向该对象的引用次数。
2. 当一个对象有相应的引用更新操作时，则对目标对象的引用计数器进行增减。
3. 一旦当某个对象的引用计数器为 0 时，则表示此对象已经死亡，可以被垃圾回收。

从实现来看，**引用计数器法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但是它的实现方案简单，判断效率高，是一个不错的算法**。

也有一些比较出名的引用案例，比如：微软 COM（Component Object Model） 技术、使用 ActionScript 3 的 FlashPlayer、 Python 语言等。但是，在主流的 Java 虚拟机中并没有选用引用技术算法来管理内存，主要是**因为这个简单的计数方式在处理一些相互依赖、循环引用等就会非常复杂**。可能会存在不再使用但又不能回收的内存，造成内存泄漏

## 1.2 可达性分析法
Java、C#等主流语言的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。

它的算法思路是通过**定义一系列称为 GC Roots 根对象作为起始节点集**，从这些节点出发，穷举该集合引用到的全部对象填充到该集合中（live set）。**这个过程标记，只标记那些存活的对象** 好，那么现在未被标记的对象就是可以被回收的对象了。

GC Roots 包括；
1. **全局性引用**，对**方法区的静态对象、常量对象**的引用
2. **执行上下文**，对 Java 方法**栈帧中的局部对象引用**、对 JNI handles 对象引用
3. **已启动且未停止的 Java 线程**

两大问题
1. 误报：已死亡对象被标记为存活，垃圾收集不到。多占用一会内存，影响较小。
2. 漏报：引用的对象（正在使用的）没有被标记为存活，被垃圾回收了。那么直接导致的就是 JVM 奔溃。（STW 可以确保可达性分析法的准确性，避免漏报）

## 2. 垃圾回收算法
### 2.1 标记-清除算法(mark-sweep) )
**标记无引用的死亡对象所占据的空闲内存，并记录到空闲列表中**（free list）。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305292348933.png)

当需要创建新对象时，内存管理模块会从 free list 中寻找空闲内存，分配给新建的对象。
- 这种清理方式其实非常简单高效，但是也有一个问题**内存碎片化太严重了**。
- Java 虚拟机的堆中对象，必须是连续分布的，所以**极端的情况下可能即使总剩余内存充足，但寻找连续内存分配效率低，或者严重到无法分配内存**。重启汤姆猫！
- 在 CMS 中有此类算法的使用，GC 暂停时间短，但存在算法缺陷。

### 2.2 标记-复制算法(mark-copy)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305292350714.png)
- 从图上看这回做完垃圾清理后连续的内存空间就大了。
- 这种方式是把内存区域分成两份，分别用两个指针 from 和 to 维护，并且只使用 from 指针指向的内存区域分配内存。
- 当发生垃圾回收时，则**把存活对象复制到 to 指针指向的内存区域，并交换 from与 to 指针**。
- 它的好处很明显，就是**解决内存碎片化问题**。但也带来了其他问题，**堆空间浪费了一半**。

### 2.3 标记-压缩算法(mark-compact)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305292352924.png)
- 1974 年，Edward Lueders 提出了**标记-压缩算法**，标记的过程和标记清除算法一样，但**在后续对象清理步骤中，先把存活对象都向内存空间一端移动，然后在清理掉其他内存空间**。
- 这种算法能够**解决内存碎片化问题**，但**压缩算法的性能开销也不小**。

## 3. 垃圾回收器
### 3.1 新生代(都是标记复制mark-copy，因为是eden from to survivor)
#### 1. Serial 
1. 算法：标记-复制算法
2. 说明：简单高效的单核机器，**Client 模式下默认新生代收集器**；
#### 2. Parallel ParNew
1. 算法： 标记-复制算法
2. 说明：**GC 线程并行版本**，在单 CPU 场景效果不突出。常用于 Client 模式下的 JVM
#### 3. Parallel Scavenge
1. 算法：标记-复制算法
2. 说明：目标在于达到可控吞吐量（吞吐量=用户代码运行时间/(用户代码运行时间+垃圾回收时间)）；

### 3.2 老年代
#### 1. Serial Old
1. 算法：**标记-压缩算法**
2. 说明：性能一般，**单线程版本**。1.5 之前与 Parallel Scavenge 配合使用；作为 CMS 的后备预案。
#### 2. Parallel Old
1. 算法：**标记-压缩算法**
2. 说明：**GC 多线程并行**，为了替代 Serial Old 与 Parallel Scavenge 配合使用。
#### 3. CMS
1. 算法：**标记-清除算法**
2. 说明：对 CPU 资源敏感、停顿时间长。标记-清除算法，**会产生内存碎片**，可以通过参数开启碎片的合并整理。**基本已被 G1 取代**

### 3.3 G1
1. 算法：**标记-压缩算法**
2. 说明：适用于**多核大内存机器、GC 多线程并行执行**，低停顿、高回收效率。