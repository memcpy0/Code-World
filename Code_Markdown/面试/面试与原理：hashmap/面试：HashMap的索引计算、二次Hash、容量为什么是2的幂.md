**要求**：
* 理解**索引计算方法**、**二次 hash** 的意义、**容量**对索引计算的影响

>索引如何计算？**hashCode都有了，为何还要提供hash()方法**？数组容量为何是2的n次幂？
>① 计算对象的hashCode()，再进行调用HashMap的hash()方法进行二次哈希，最后& (capacity -1)得到索引
>② 二次hash()是为了综合高位数据，让哈希分布更为均匀
>③ 计算索引时，如果是2的n次幂可以使用位与运算代替取模，效率更高；扩容时hash & oldCap == 0的元素留在原来位置，则新位置=旧位置+oldCap
>①、②、③都是为了配合容量为2的n次幂时的优化手段，例如Hashtable的容量就不是2的n次幂，并不能说明哪种更优，应该是设计者综合了各种因素，最终选择了使用2的n次幂作为容量

**索引计算方法**
* 首先，计算对象的 hashCode()
* 再进行调用 HashMap 的 hash() 方法进行二次哈希
  * ==**二次 hash() 是为了综合高位数据，让哈希分布更为均匀**==
* 最后 **& (capacity – 1) 得到索引** 97 % 16 = 97 % (16-1)

1.8中的hash()实现：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202303232124219.png)
1.7中的hash()实现：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202303232125342.png)

**数组容量为何是 2 的 n 次幂**
1. ==计算索引时效率更高==：**如果是 2 的 n 次幂可以使用位与运算代替取模**
2. ==扩容时（原容量<<1）重新计算索引效率更高==：二次hash值 & 原始容量oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + 原始容量oldCap

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202303232134750.png)
原始容量=16，扩容后容量16x2=32
10(1010) & 10000{2} = 0
26(11010) & 10000{2} = 10000 不为零

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202303232135203.png)

该解法是因为扩容后，16不再是capacity的整数倍，会被作为余数。若该位为1，则取模值发生变化，于是桶下标变化
因为高位多了个1相当于需要右移动16位

**注意**
* ==二次 hash 是为了配合 **容量是 2 的 n 次幂** 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash==
* **容量是 2 的 n 次幂** 这一设计**计算索引效率更好**，但 **hash 的分布性就不好，需要二次 hash 来作为补偿、让链表更短**，没有采用这一设计的典型例子是 Hashtable
* ==要追求Hash分布的均匀，就要选择质数作为容量，而且这时就不用二次hash（使用扰动函数了）==


比较规则：先按哈希码比，哈希码相等在比较字符串（其实面试题常见：为何重写equals方法就得重写hashCode方法
这样做才能保证不违背hashCode方法中“**相同对象必须有相同哈希值**”的约定
hashCode方法实际上必须要完成的一件事情就是，**为该equals方法认定为相同的对象返回相同的哈希值**。