* 掌握**树化**
> 为什么要用红黑树，为何一开始不树化，树化阈值为何是8，何时会树化，何时会退化为链表？
① 为何用红黑树？防止链表超长时性能下降，树化应当是偶然情况，是保底策略
② 为何一开始不树化？把短链表树化不一定能提升性能，还会占用更多空间
③ 树化阈值为何是8：hash值如足够随机，在负载因子0.75的情况下，长度超过8的链表出现概率很低，**树化阈值选择 8 就是为了让树化几率足够小**
④ 何时树化：链表长度超过8，此时先尝试扩容（重新计算索引）来减少链表长度，如果数组容量已经 >=64，才会进行树化
⑤ 何时退化：
一，扩容时如果拆分树，树节点个数<=6，就退化成链表；
二，remove节点时，如果root，root.left, root.right, root.left.left有一个为null就退化

**树化意义**
* ==红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略==
* hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，**如非必要，尽量还是使用链表**
* hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，**树化阈值选择 8 就是为了让树化几率足够小**
**树化规则**
* ==当链表长度超过树化阈值 8 时，先尝试扩容（重新计算索引）来减少链表长度==，==如果数组容量已经 >=64，才会进行树化==

**退化规则**
* 情况1：**在扩容时如果拆分树时，树元素个数 <= 6 则会退化链表**
* 情况2：**remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表**

注意，树化的第一种是在扩容时，不是remove树节点，不要搞混了