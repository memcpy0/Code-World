# 1. TCP/IP模型的认识

TCP/IP 分层模型被称作因特网分层模型、因特网参考模型。

TCP/IP 协议被组织成四个概念层，其中有三层对应于 ISO 参考模型中的相应层。ICP/IP 协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。

TCP/IP 分层模型的四个协议层分别完成以下的功能：
- 第一层 网络接口层。网络接口层包括用于协作IP数据在已有网络介质上传输的协议。协议：ARP,RARP
- 第二层 网间层：网间层对应于 OSI 七层参考模型的网络层。负责数据的包装、寻址和路由。同时还包含网间控制报文协议 (Internet Control Message Protocol,ICMP)用来提供网络诊断信息。
	协议：本层包含 IP 协议、RIP 协议，ICMP 协议。
- 第三层 传输层。传输层对应于 OSI 七层参考模型的传输层，它提供两种端到端的通信服务。
	其中 TCP 协议提供可靠的数据流运输服务，UDP 协议提供不可靠的用户数据报服务。
- 第四层 应用层。应用层对应于 OSI 七层参考模型的应用层和表达层。
 因特网的应用层协议包括Finger、Whois、FTP、Gopher、HTTP、Telent、SMTP、IRC、NNTP等。
 
# 2. TCP和UDP的区别

| 区别 | UDP | TCP |
|:---|:---|-----|
| 是否连接 | 无连接 | 面向连接
| 是否可靠 | 不可靠传输，不使用流量控制和拥塞控制 | 可靠传输，使用流量控制和拥塞控制 |
| 是否有序 | 消息在传输过程中可能会乱序 | 会重新排序
| 传输速度 |快 | 慢
| 连接对象个数 |支持一对一，一对多，多对一和多对多通信 | 只能是一对一通信
| 传输方式 | 面向报文  | 面向字节流
|  首部开销 | 首部开销小，仅8字节 | 首部最小20字节，最大60字节
| 适用场景 | 适用于实时应用（IP电话、视频会议、直播等） |适用于要求可靠传输的应用（例如文件传输）

# 3. TCP 保证可靠性的方式

1.  检验和
2.  序列号
3.  **确认-应答**机制
4.  **超时重传**机制
5.  连接管理机制
6.  流量控制
7.  拥塞控制

# 4. TCP中有一个TIME_WAIT状态有了解吗
TIME_WAIT 是在 TCP 中，主动调用 close() 发起断开连接请求的一方，在发送了最后一个 ACK 包之后所进入的状态，在这个状态下，主动方会保持一个 2MSL 的等待时间后才断开连接回到起始 CLOSED 状态。其中的 MSL 是 Maximum Segment Lifetime，最大报文生存寿命，指一个数据包在网络中的最大生存时间。之前要保持 2MSL 的等待时间，有以下两方面原因：
1. 实现 TCP 全双工连接的可靠释放
假如主动发起关闭的一方(通常来说是客户端)在最后一次挥手过程中发送的 ACK 包丢失了，那么由于 TCP 的重传机制，被动关闭一方(通常是服务端)会再次发送 FIN 包，以提醒客户端。如果没有这个 2MSL 时间，那么就算客户端最后的 ACK 包丢失，它也无法收到服务端的重传消息，也就不能实现 TCP 的可靠性传输了，同时，由于客户端在发完 ACK 之后就早早地断开了，这时服务端重发 FIN 包之后，会收到客户端传来的 RST 包响应，服务端会认为出现了异常。因此，客户端在发送完最后一个 ACK 包后，要有一个 2MSL 的等待时间，当发生丢包后，能够在这个时间段内重新收到服务端的 FIC 包，然后再给服务端重发一次 ACK 包，再次经过 2MSL 时间，如果没有收到服务端的 FIN，就认为此次断开连接成功，回到 CLOSED 状态。
2. 使旧数据包在网络中因过期而消失
我们知道，**TCP 连接由一个四元组(local_ip, local_port, remote_ip, remote_port)唯一标识**，假如此时因为某些原因，TCP 连接断开了，接着又很快以相同的四元组建立了连接，这时因为出现过终端，**两次的四元组实际上已经属于两个不同的连接了**，但是对于 TCP 协议栈来说，它无法感知这样的中断，就会认为第二次的四元组依然是上一次的连接，倘或此时上一次连接中的旧数据包没有在网络中消失，而由客户端再次发送给了服务端，这时服务端的 TCP 传输层会把它当成是正常的数据来接收并向上传送到应用层，从而引起数据混乱。因此为了避免这种情况的发生，需要在一次连接结束时设置这样一个大于 MSL 的时间，来让本次连接过程中的所有数据包失效。

但是，在高并发短连接的 TCP 服务器上，当服务器处理完请求后立刻主动正常关闭连接，这种情况下会出现大量 socket 处于 TIME_WAIT 状态，如果客户端的并发量持续很高，此时又没有空闲的端口可供 TCP 连接，部分客户端就会显示连接不上，从而影响服务器的响应请求。因此，如果我们想避免 TIME_WAIT 状态，可以设置 SO_REUSERADDR 套接字选项来通知内核，告知它，如果端口忙但 TCP 连接又位于 TIME_WAIT 状态的话，可以重用端口。

 