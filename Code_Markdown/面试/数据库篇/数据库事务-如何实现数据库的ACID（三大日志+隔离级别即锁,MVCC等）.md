## 总结
DBMS 采用 **日志** 来保证事务的 原子性、一致性 和 持久性。
-   原子性：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undo log ——**由undo log日志保证**，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
-   持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要**基于redo log日志**——由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，**事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复**
-   一致性：==事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的==
-   隔离性：保证事务执行尽可能不受其他事务影响；**InnoDB默认的隔离级别是RR**，RR的实现主要基于**锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）**

> DBMS 采用 锁机制 来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许 **持有锁的事务** 能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。
 
## 原子性
-   原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。

### 实现原理
-   原子性说明==事务执行失败，必须要进行回滚操作==
-   undo log： **InnoDB实现回滚，靠的是undo log**：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以**利用undo log中的信息将数据回滚到修改之前的样子**。

## 持久性
-   持久性是指事务一旦提交，**它对数据库的改变就应该是永久性的**。接下来的其他操作或故障不应该对其有任何影响。
### 实现原理
-   持久性说明==需要写入到磁盘中==，这里用的是 **redolog 和 binlog** 的两阶段提交实现

## 隔离性
-   ==**与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响**==。
-   隔离性是指，**事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰**。严格的隔离性，**对应了事务隔离级别中的Serializable** (可串行化)，但==实际应用中出于性能方面的考虑很少会使用可串行化==。

### 实现原理
-   (一个事务)写操作对(另一个事务)写操作的影响：**锁机制**保证隔离性
-   (一个事务)写操作对(另一个事务)读操作的影响：**[[数据库事务-MVCC和MVCC机制具体是怎么样的]]保证隔离性**

## 一致性
-   一致性是指事务执行结束后，**数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态**。数据库的完整性约束包括但不限于： **实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。**
### 实现原理
-   首先：==一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性==
-   其次：在mysql层面也需要对于一致性进行保证，比如说例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等
-   最后： **应用层进行一致性的保护**， 例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致

## 三大日志
三大日志都仅记录写入性操作，不包括查询操作（因为查询不更改数据库，也就没必要记录了）
### 1. 回滚日志undo log
原子性：undo log记录SQL操作，当发生回滚时，逆序执行逆操作来完成回滚

### 2. 归档日志bin log

### 3. 重做日志redo log
持久性：bin log & redo log
redo log: 为了避免每次读取数据都进行磁盘IO，MySQL的InnoDB引擎采用缓存Buffer方式。

==redo log分为两个部分：缓冲区的redo log buffer和磁盘上的redo log file==。磁盘上的redo log file不受宕机影响，每次真正执行DML操作之前先更新redo log（预写式日志），也就是WAL, Write-Ahead logging技术——在真正把数据写入到磁盘前，先记录日志。

redo log（undo log和redo log的机制一样，都经历一次写、一次刷）
- 写过程将引擎用户层buffer记录的数据写入核心层buffer
- 刷过程将核心层buffer真正写入磁盘
- 由此可以分为三种写刷时机，同样由参数控制：延迟写 / 实时写，实时刷 / 实时写，延迟刷
- bin log有类似的刷盘时机机制，同样由参数控制，不强制要求 / 每次提交都刷盘（默认） / 集齐N次提交后刷盘

由于redo log采用循环写的方式记录下最近的操作，但要用到更久之前的操作来完成恢复时，就需要另一种日志对更久之前的操作归档，这就是bin log。二者要配合使用才能保证当数据库发生宕机重启时，数据不会丢失。

MySQL提交时，分为两阶段提交。第一阶段提交时，执行器先写redo log(prepare)，再写bin log，第二阶段提交时正式更新redo log(commit)，保证两个日志数据的安全与同步。


bin log与redo log区别：
- **redo log循环写，大小固定，会丢失**；bin log追加写，大小通过配置参数决定，追加写到超过文件大小后会**将后续日志记录到新的bin log不丢失**
- redo log 适用于**崩溃恢复**，只有redo log是crush-safe的；**binlog 除了配合崩溃恢复保证持久性之外，还适用于主从复制（也是重点）**
- bin log所有引擎都支持，server层实现，redo log仅InnoDB支持，引擎层实现
- bin log支持三种记录方式（Statement / Row / Mixed），日志类型为逻辑日志；redo log日志类型为物理日志（物理日志用于恢复速度会快很多）

一致性：
	bin log 也有类似的缓冲区，binlog刷盘时机同样是靠配置参数来控制
	可以选择不实时更新，牺牲一定的一致性来换取更好的性能，默认每次提交都刷盘（保证一致性）
隔离性：
	事务隔离级别：     	   防脏读  防不可重复读  防幻读
		read uncommitted     X          X          X
		read committed       √          X          X
		repeatable read      √          √          X
		serializable         √          √          √
		脏读：读未提交
		不可重复读：**同一事务两次读的结果不同**（针对update）
		幻读：**前后多次读取**，数据总量不一致（针对insert、delete）
	MVCC：多版本并发控制，**不同事务的读–写、写–读操作并发执行**，从而提升系统性能
		读未提交：就全读最新的就是读未提交，不加任何判断
		读已提交和可重复读的实现：
			核心处理逻辑就是判断所有版本中哪个版本是当前事务可见的，称为 ReadView
			这个过程通过事务IDtrx_id来判断，这个ID严格递增
			读已提交：仅判断trx_id，在本次事务之前的都有效修改，可查
			可重复读：利用undo log，配合ReadView，当该事务执行相同读操作的时候，依据undo log恢复到开始时的数据，保证永远是第一次查询时的结果	
	串行化的实现：锁实现串行化，牺牲并发，保证ACID
 