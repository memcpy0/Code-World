
### 1. MYSQL的四个隔离级别
为了尽可能的避免事务之间的相互影响，从而达到事务的四大特性，SQL 标准定义了 4 种不同的事务隔离级别（TRANSACTION ISOLATION LEVEL），即 **并发事务对同一资源的读取深度层次**，由低到高依次是 读取未提交（READ-UNCOMMITTED）、读取已提交（READ-COMMITTED）、可重复读（REPEATABLE-READ）、可串行化（SERIALIZABLE），这 4 个级别与事务相互间影响问题对应如下：
 - Read Uncommitted（读取未提交内容）: 最低的隔离级别，一个事务可以读到另一个事务未提交的结果，**所有的并发事务问题都会发生**。
- Read Committed（读取提交内容）**语句级**：只有在事务提交后，其更新结果才会被其他事务看见，可以解决 **脏读问题**，但是不可重复读或幻读仍有可能发生。Oracle 默认采用的是该隔离级别。
- Repeatable Read（可重读）**事务级** ：==在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交，除非数据是被本身事务自己所修改==。可以解决 脏读、不可重复读。**MySQL 默认采用可重复读隔离级别**。——由于MVCC和Next-Key Lock的存在，MySQL在可重复读级别就可以避免幻读？
- Serializable（可串行化）**最高级别**：事务 **串行化执行**，隔离级别最高，完全服从 ACID，牺牲了系统的并发性，也就是说，所有事务依次逐个执行，所以可以解决并发事务的所有问题。

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304081636915.png)

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304141455849.png)

```sql
select @@transaction_isolation, @@global.transaction_isolation;
+-------------------------+--------------------------------+
| @@transaction_isolation | @@global.transaction_isolation |
+-------------------------+--------------------------------+
| REPEATABLE-READ | REPEATABLE-READ |
+-------------------------+--------------------------------+
```

### 常见的并发异常
- 第一类丢失更新、第二类丢失更新
	![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304141449609.png)
	![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304141449079.png)
- 脏读、不可重复读、幻读
	![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304141451095.png)
	![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304141451771.png)
	不可重复读是查询一条数据发现不一致；幻读是查询多条数据不一致，针对insert和delete。
	![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304141453767.png)

https://www.imooc.com/article/17291
https://www.imooc.com/article/17290
https://www.imooc.com/article/17289
MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) 加上间隙锁（next-key locking）策略在Repeatable Read (RR)隔离级别下不存在幻读。如果测试幻读，在MyISAM下实验。

在聚集索引（主键索引）中，如果有唯一性约束，InnoDB会将默认的next-key lock降级为record lock。
### MySQL中不同事务隔离级别分别会加哪些锁？
- （一级封锁协议）在 Read Uncommitted 级别，在修改数据前加X锁~~防止丢失更改~~。但**读取数据不需要共享锁，这样它们就不会与修改数据上的排他锁发生冲突**
- （二级封锁协议）在 Read Committed 级别，在一级的基础上，**为读操作添加共享锁**，执行完后释放共享锁，防止脏读。
- 在 Repeatable Read 级别下，==共享锁需要添加到读操作中，但直到事务提交后才释放，即必须等待事务执行完毕==。**与二级的S锁读完后立即释放不同**，直到事务结束才释放，这样就可以重复读到相同的数据了。
- SERIALIZABL E是最严格的隔离级别，**因为该级别锁定整个键范围，并持有锁，直到事务完成**。所有事务串行执行

读未提交：**如果一个事务已经开始写数据，其他事务不允许同时进行写操作，但是允许读此行数据**。我读的时候大家想干嘛干嘛，我写的时候你只能看。（解决了更新丢失、不允许同时写！，但还是可能会出现脏读） ==脏读，别人读了我正在写但没有提交的的数据==

读提交：如果一个事务是读事务，则允许其他事务读~~写~~；如果是写事务，则禁止其他事务访问改数据。我读的时候大家~~想干嘛干嘛~~，我写的时候你们离我远点！（解决了更新丢失和脏读问题，但是可能出现不可重复读）

可重复读：**在一个事务内，多次读同一个数据，这个事务还没结束时，其他事务不能访问该数据（包括~~读~~写）**，这样可以在同一个事务内两次读到的数据都是一样的。读取数据的事务会禁止其他事务写（但可以读），写事务完全禁止其他事务访问（包括读写）。我读的时候你们也能看，我写的时候闪开！（解决了更新丢失、脏读、不可重复读、但是还会出现幻读）

串行化：要求事务串行化执行，提供严格的事务隔离。事务只能一个接一个执行，不能并发执行。性能低代价高，一般很少使用。一个个来！（解决了更新丢失、脏读、不可重复读、幻读(虚读)）


(读未提交修改数据有排他锁？)
在符合原子性的情况下，还有的问题：？？
- 更新丢失(Update lose)：两个事务**同时操作相同数据**，后提交的事务会覆盖先提交的事务处理结果。
	解决办法：把数据库的事务隔高级别调整到READ_UNCOMMITTED ——~~我写的时候你不可以写（但可以读），我读的时候、你可以读、可以写~~
- 脏读(Dirty read)：在一个事务中读取到另一个事务**已经修改但没有提交**的数据。
	事务A对数据进行了修改，但是还没有提交，这时事务B读取这个数据，然后事务A回滚，那么事务B取的数据无效。==不符合一致性==。
	解决办法：把数据库的事务隔高级别调整到READ_COMMITTED —— 我写的时候你不可以写、不可以读，我读的时候、你可以读
- 不可重复读(NonRepeatable Read)：不能读到相同的数据内容，事务A读取到了事务B已经提交的修改数据(**即一个事务范围内两个相同的查询却返回了不同数据**)。
	例如事务A先读取数据，然后事务B对该同一数据修改并提交，那么事务A再次读取该数据时，由于事务B对该数据的修改，事务A两次读到的的数据可能是不一样的。==不符合隔离性==。
	解决办法：把数据库的事务隔离级别调整到REPEATABLE_READ —— 我写的时候你不可以写（排他）、不可以读（共享），我读完一次后-不可写-再读-还不可以写-直到事务提交-你才可以写（共享锁持有到事务结束）
- 幻读(Phantom Read)：事务在插入「已经检查过不存在的记录」时，发现这些数据已经存在了(针对的insert操作)。
	在事务A查询结束后，事务B往User表中插入了一条id为1的数据。此时，由于事务A查询到id为1的用户不存在，因此插入1条id为1的数据，报错：主键冲突，**不符合隔离性**。
	解决办法：把数据库的事务隔离级别调整到SERIALIZABLE

多版本并发控制(Multiversion concurrency control， MCC 或 MVCC)，是**数据库管理系统常用的一种并发控制**，也用于程序设计语言实现事务内存。[1]

**MVCC意图解决读写锁造成的多个、长时间的读操作饿死写操作问题**。==每个事务读到的数据项都是一个历史快照，并依赖于实现的隔离级别==。**写操作不覆盖已有数据项，而是创建一个新的版本，直至所在操作提交时才变为可见**。快照隔离使得事务看到它启动时的数据状态。
 