**索引（index）是在存储引擎（storage engine）层面实现的**，而不是server层面。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别

根据**结构**分类，主要有 **B 树索引**、**Hash 索引** 和 **位图索引** 三种。

# 1. B 树索引
B 树索引，又称 平衡树索引，是 MySQL 数据库中**使用最频繁的索引类型**，MySQL、Oracle 和 SQL Server 数据库默认的都是 B 树索引（**实际是用 B+ 树实现的**，因为==在查看表索引时，MySQL 一律打印 BTREE，所以简称为 B 树索引==）。

B 树索引以 **树结构** 组织，它有一个或者多个分支结点，分支结点又指向**单级的叶结点**。其中，分支结点用于遍历树，**叶结点则保存真正的值和位置信息**。B+ 树是在 B 树基础上的一种优化，使其更适合实现外存储索引结构。
## 1.1 B树与B+树
一棵 m 阶 B-Tree 的特性如下：
- 每个结点**最多 m 个子结点**；
- 除了根结点和叶子结点外，每个结点**最少有 m/2（向上取整）个子结点**；
- **所有的叶子结点都位于同一层**；
- 每个结点**都包含 k 个元素（关键字），这里 m/2≤k<m**，这里 m/2 向下取整；
- 每个节点中的元素（关键字）**从小到大排列**；
- 每个元素子左结点的值，都小于或等于该元素，右结点的值都大于或等于该元素。

数据库以 B-Tree 的数据结构存储数据的图示如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304102255191.png)

B+ Tree 与 B-Tree 的结构很像，但是也有自己的特性：
- **所有的非叶子结点只存储 关键字信息**；
- **所有具体数据都存在叶子结点中**；
- 所有的叶子结点中**包含了全部元素的信息**；
- **所有叶子节点之间都有一个链指针**。(==通过链表将叶子结点串联在一起、成为一个从小到大有序的双向链表，可以方便按区间查找==)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304102258590.png)

一般情况下，==根结点会被存储在内存中，其他节点存储在磁盘中==。

m 如何确定？理论上越大，树的高度越小，访问I/O次数越少。操作系统访问磁盘一般按照页读取：**一页通常为4KB**，因此读取一次，最大为4KB，这样就可以算出m的范围。设一个结点16字节，一次可读取4000/16=250个节点，则m最大值为250.
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304110000214.png)
如果将1亿数据进行索引，按照m=250叉树来构造，树的高度为4，因此访问4次I/O即可完成查找；按照查询范围，实际每层只需要访问一个节点：比如id<60，会在<99的节点里查找，依次类推。

查找：查找一个数据区间时，首先通过索引定位到**区间起点叶子节点**，然后往后遍历链表，直到叶子节点值大于区间终点。


# 2. Hash 索引
哈希索引采用一定的 **哈希算法**（常见哈希算法有 直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成**定长的 Hash 值**，与**这条数据的行指针**一并存入 Hash 表的对应位置，如果发生 Hash 碰撞（两个不同关键字的 Hash 值相同），则**在对应 Hash 键下以 链表形式 存储**。

**检索时不需要类似 B+ 树那样从根节点到叶子节点逐级查找**，只需一次哈希算法即可立刻定位到相应的位置，**速度非常快**，平均检索时间为 O(1)。

Hash索引查询效率非常高，但是**只适用于等值查询**，==不能用于范围查询或者模糊查询==.
# 3. 位图索引
==B 树索引擅长于处理包含许多不同值的列，但是在处理基数较小的列时会变得很难使用==。如果用户查询的列的基数非常的小， 即只有几个固定值，如性别、婚姻状况、行政区等等，**要么不使用索引**，查询时一行行扫描所有记录，**要么考虑建立位图索引**。

**位图索引为存储在某列中的每个值生成一个位图**。例如针对表中婚姻状况这一列，生成的位图索引大致如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304102301092.png)
对于婚姻状况这一列，索引包含 3 个位图，即生成有 3 个向量，分别属于每一个取值，每个位图为每一个人（行）都分配了 0/1 值（每一行有且仅有一个 1 ），未婚为 110000……，已婚为 000111……，离婚为 001000……。

当进行数据查找时，只要查找相关位图中的所有 1 值即可（可根据查询需求进行与、或运算）。

例如， Oracle 用户可以通过为 `create index` 语句简单地添加关键词 bitmap 生成位图：
```java
CREATE BITMAP INDEX acc_marital_idx ON account (marital_cd);
```
除了上述提及的，**位图索引适合只有几个固定值的列**，还需注意 ，**位图索引适合静态数据，而不适合索引频繁更新的列**。

---
# 4. 具体
 `InnoDB`数据页的7个组成部分，知道了**各个数据页可以组成一个`双向链表`** ，而**每个数据页中的记录会按照主键值从小到大的顺序组成一个`单向链表`**，每个数据页都会为存储在它里边的记录生成一个`页目录`，在通过主键查找某条记录时，可以**在`页目录`中使用二分法快速定位到对应的槽**，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd6b2721492418a8c77eb9c97192911~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
其中页a、页b、页c ... 页n 这些页可以不在物理结构上相连，只要通过双向链表相关联即可。
## 4.1 索引
-   先建一个表：
```sql
mysql> CREATE TABLE index_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 CHAR(1),
    ->     PRIMARY KEY(c1)
    -> ) ROW_FORMAT = Compact;
Query OK, 0 rows affected (0.03 sec)
复制代码
```
这个新建的`index_demo`表中有2个`INT`类型的列，1个`CHAR(1)`类型的列，而且我们规定了`c1`列为主键，这个表使用`Compact`行格式来实际存储记录的。为了我们理解上的方便，我们简化了一下`index_demo`表的行格式示意图：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c27cf721eca4254b2ba141eb5f87502~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

我们只在示意图里展示记录的这几个部分：
-   `record_type`：记录头信息的一项属性，表示记录的类型，`0`表示普通记录、`2`表示最小记录、`3`表示最大记录、`1`我们还没用过，等会再说～
-   `next_record`：记录头信息的一项属性，表示下一条地址相对于本条记录的**地址偏移量**，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。
-   `各个列的值`：这里只记录在`index_demo`表中的三个列，分别是`c1`、`c2`和`c3`。
-   `其他信息`：除了上述3种信息以外的所有信息，包括**其他隐藏列的值以及记录的额外信息**。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71e0b649ee2e4dc997036b75c57217df~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 1、一个简单的索引方案
假设我们的每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之后我们向 `index_demo` 表插入3条记录：
```sql
mysql> INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0
复制代码
```
-  那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/037f9b14f8a04169bbe5aa6efb6581d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
从图中可以看出来，`index_demo`表中的3条记录都被插入到了编号为`10`的数据页中了。此时我们再来插入一条记录：
```sql
mysql> INSERT INTO index_demo VALUES(4, 4, 'a');
Query OK, 1 row affected (0.00 sec)
复制代码
```
-   因为`页10`最多只能放3条记录，所以我们不得不再分配一个新页：
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6645543867fd43998d89126ed37f3725~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
-   怎么分配的页号是`28`呀，不应该是`11`么？再次强调一遍，**新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着**。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系。
- 另外，`页10`中用户记录最大的主键值是`5`，而`页28`中有一条记录的主键值是`4`，因为`5 > 4`，所以**这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求**，所以在插入主键值为`4`的记录时需要伴随着一次**记录移动**，也就是把主键值为`5`的记录移动到`页28`中，然后再把主键值为`4`的记录插入到`页10`中，这个过程的示意图如下：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7c87cfafe804b218ae61959420532ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

-   **下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为`页分裂`**。
-   在向`index_demo`表中插入许多条记录后，可能是这样的效果：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a611db8c38b465b8d46e1c07395dad1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

-   **因为这些`16KB`的页在物理存储上可能并不挨着**，所以如果想从这么多页中**根据主键值快速定位某些记录所在的页**，我们需要给它们做个目录，**每个页对应一个目录项**，每个目录项包括下边两个部分：
    -   页的用户记录中**最小的主键值**，我们用`key`来表示。
    -   页号，我们用`page_no`表示。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0590212c45e847599f7e1656befec42c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

以`页28`为例，它对应`目录项2`，这个目录项中包含着该页的页号`28`以及该页中用户记录的最小主键值`5`。==我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了==。比方说我们想找主键值为`20`的记录，具体查找过程分两步：
1.  先从目录项中根据**二分法**快速确定出主键值为`20`的记录在`目录项3`中（因为 `12 < 20 < 209`），它对应的页是`页9`。
2.  再根据前边说的**在页中查找记录的方式**去`页9`中定位具体的记录。
    -   在通过页内的 **二分+顺序查找**，找到最终的 主键是20的

### 2、InnoDB中的索引方案
那`InnoDB`怎么区分一条记录是普通的`用户记录`还是`目录项记录`呢？别忘了记录头信息里的`record_type`属性，它的各个取值代表的意思如下：    
-   `0`：普通的用户记录
-   `1`：目录项记录
-   `2`：最小记录
-   `3`：最大记录
-   原来这个值为`1`的`record_type`是这个意思呀，我们把前边使用到的目录项放到数据页中的样子就是这样： ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80e3cb8943b241f8b1894c794441e4b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
    
-   从图中可以看出来，我们**新分配了一个编号为`30`的页来专门存储`目录项记录`**。这里再次强调一遍`目录项记录`和普通的`用户记录`的不同点：
-   `目录项记录`的`record_type`值是1，而普通用户记录的`record_type`值是0。
-   **`目录项记录`只有主键值和页的编号两个列**，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有`InnoDB`自己添加的隐藏列。  
-   还记得我们之前在唠叨记录头信息时，说过一个叫`min_rec_mask`的属性么，只有在存储 `目录项记录` 的页中的主键值最小的`目录项记录`的`min_rec_mask`值为`1`，其他别的记录的`min_rec_mask`值都是`0`。
    
-   如果此时我们再向上图中插入一条主键值为`320`的用户记录的话，那就需要**分配一个新的存储`目录项记录`的页**喽：
    

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee901adbcfdd44f0987d48c50d9aeb04~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

-   **这些存储`目录项记录`的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据**，所以现在各个页的示意图就是这样子： ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a2d0831bc044073851439eb28eff7c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 3、单表存放上限
-   假设所有**存放用户记录的叶子节点**代表的数据页可以存放100条用户记录，所有**存放目录项记录的内节点**代表的数据页可以存放1000条目录项记录，那么：    
    -   如果`B+`树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放`100`条记录。
    -   如果`B+`树有2层，最多能存放`1000×100=100000`条记录。
    -   如果`B+`树有3层，最多能存放`1000×1000×100=100000000`条记录。
    -   如果`B+`树有4层，最多能存放`1000×1000×1000×100=100000000000`条记录
-   一般情况下，**我们用到的`B+`树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页）**，又因为在每个页面内有所谓的`Page Directory`（页目录），所以在页面内也可以通过二分法实现快速定位记录，这不是很牛么，哈哈！

#### 聚簇索引
-   **`聚簇索引`就是数据的存储方式**（所有的用户记录都存储在了`叶子节点`）

#### 二级索引
-   **我们用`c2`列的大小作为数据页、页中记录的排序规则，再建一棵`B+`树**，效果如下图所示：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e07e2c1e5d047d1b09b83bbd6538b3d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

这个`B+`树与上边介绍的聚簇索引有几处不同：    
-   使用**记录`c2`列的大小**进行记录和页的排序，这包括三个方面的含义：    
    -   **页内的记录**是按照`c2`列的大小**顺序排成一个单向链表**。
    -   **各个存放用户记录的页**也是根据页中记录的`c2`列大小**顺序排成一个双向链表**。
    -   **存放目录项记录的页**分为不同的层次，在同一层次中的页也是根据**页中目录项记录的`c2`列大小顺序排成一个双向链表**。
-   目录项记录中不再是`主键+页号`的搭配，而**变成了`c2列+页号`的搭配**。
-   **`B+`树的叶子节点存储的并不是完整的用户记录，而只是`c2列+主键`这两个列的值**。
-   记住需要回表

##### 联合索引
-   方说我们想让`B+`树按照`c2`和`c3`列的大小进行排序，这个包含两层含义：
-   先把各个记录和页按照`c2`列进行排序。    
-   **在记录的`c2`列相同的情况下，采用`c3`列进行排序**

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fa8396bde61490e9f4de54e9c80610a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 4、InnoDB的B+树索引的注意事项
#### （1）根节点页面不会移动
-   B+ 树的形成过程
    -   每当为某个表创建一个`B+`树索引（**聚簇索引不是人为创建的，默认就有**）时，都会**为这个索引创建一个`根节点`页面**。最开始表中没有数据时，**每个`B+`树索引对应的`根节点`中既没有用户记录，也没有目录项记录**。
    -   随后向表中插入用户记录时，先把用户记录存储到这个`根节点`中。
    -   当`根节点`中的可用空间用完时继续插入记录，此时会将`根节点`中的所有记录复制到一个新分配的页，比如`页a`中，然后对这个新页进行`页分裂`的操作，得到另一个新页，比如`页b`。这时**新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小** 就会被分配到`页a`或者`页b`中，而 **`根节点`便升级为存储目录项记录的页**。

**一个B+树索引的根节点自诞生之日起，便不会再移动。** 这样==只要我们对某个表建立一个索引，那么它的`根节点`的页号便会被记录到某个地方==，然后凡是`InnoDB`存储引擎需要用到这个索引时，==都会从那个固定的地方取出`根节点`的页号，从而来访问这个索引==。
#### （2）内节点中目录项记录的唯一性
-   知道`B+`树索引的内节点中**目录项记录的内容是`索引列 + 页号`的搭配**，但是这个搭配对于二级索引来说有点儿不严谨。还拿 `index_demo` 表为例，假设这个表中的数据是这样的：
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7606437386744dee9208bac694431e24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
-   如果二级索引中目录项记录的内容只是`索引列 + 页号`的搭配的话，那么为`c2`列建立索引后的`B+`树应该长这样：
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a468ccc337204ef08aa958b8c8cfc73c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

-   如果我们想新插入一行记录，其中`c1`、`c2`、`c3`的值分别是：`9`、`1`、`'c'`，那么**在修改这个为`c2`列建立的二级索引对应的`B+`树时便碰到了个大问题**：由于`页3`中存储的目录项记录是由`c2列 + 页号`的值构成的，`页3`中的两条目录项记录对应的`c2`列的值都是`1`，而我们新插入的这条记录的`c2`列的值也是`1`，那我们这条新插入的记录到底应该放到`页4`中，还是应该放到`页5`中啊？
-   为了让新插入记录能找到自己在那个页里，**我们需要保证在B+树的同一层内节点的目录项记录除 `页号` 这个字段以外是唯一的**。所以对于**二级索引的内节点的目录项记录**的内容实际上是由三个部分构成的：
-  也就是我们把`主键值`也添加到二级索引内节点中的目录项记录了，这样就能保证 **`B+`树每一层节点中各条目录项记录除`页号`这个字段外是唯一的** ，所以我们为`c2`列建立二级索引后的示意图实际上应该是这样子的： 

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c0f126dd374ad1811f33422bea977e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

-   这样我们再插入记录`(9, 1, 'c')`时，由于`页3`中存储的目录项记录是由`c2列 + 主键 + 页号`的值构成的，可以**先把新记录的`c2`列的值和`页3`中各目录项记录的`c2`列的值作比较**，如果`c2`列的值相同的话，可以接着**比较主键值**，因为`B+`树同一层中不同目录项记录的`c2列 + 主键`的值肯定是不一样的，所以**最后肯定能定位唯一的一条目录项记录**，在本例中最后确定新记录应该被插入到`页5`中。
-   **会先比较索引值，再去比较主键值，最后选出最后的页号**

#### （3）一个页面最少存储2条记录
`InnoDB`的一个数据页至少可以存放两条记录，这也是我们之前唠叨记录行格式时说过一个结论（我们当时依据这个结论推导了表中只有一个列时该列在不发生行溢出的情况下最多能存储多少字节，忘了的话回去看看吧）。
