从范围来看：
- 表级锁：**开销小、加锁快**，发生锁冲突的概率高，并发度低，**不会出现死锁**
- 行级锁：开销大、加锁慢，发生锁冲突的概率低，并发度高，会出现死锁

从数据库系统的角度，锁模式可分为以下6 种类型：共享锁别的事务可以读(别的事务可以对数据继续加共享锁)，但不能增删改。排它锁别的事务不能读也不能增删改
- **共享锁**（S）——行级，读取一行：又叫 **读锁**。==可以并发读取数据，但不能修改数据==。也就是说当数据资源上存在共享锁时，所有的事务都不能对该数据进行修改，直到数据读取完成，共享锁释放。
- **排它锁**（X）——行级，更新一行：又叫 独占锁、**写锁**。==对数据资源进行增删改操作时，不允许其它事务操作这块资源==，直到排它锁被释放，从而防止同时对同一资源进行多重操作。
- **意向锁**——表级，准备加共享锁/排他锁：表示 SQL Server **需要在 层次结构中的某些底层资源上 获取共享锁或排它锁**。例如，放置在 表级 的 共享意向锁 表示事务打算在表中的页或行上放置共享锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它锁。
  **意向锁可以提高性能**，因为 SQL Server ==仅在 表级 检查意向锁来确定事务是否可以安全地获取该表上的锁==，而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。
  意向锁包括**意向共享** (IS)、**意向排它** (IX) 以及与**意向排它共享** (SIX)。
  ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304201647932.png)
- 间隙锁NK：行级，使用范围条件时，对范围内不存在的记录加锁。**一是为了防止幻读**，二为了满足恢复和复制的需要

加锁：
- 增加行级锁之前，InnoDB会自动给表加意向锁；
- 执行DML语句时，InnoDB会自动给数据加排他锁。
- 执行DQL语句时：
	- 共享锁S：select from where ... lock in share mode;
	- 排他锁X： selec from where ... for update;
	- 间隙锁：上述SQL采用范围条件时，InnoDB对不存在的记录自动增加间隙锁。

- **更新锁**（U）：**防止出现 死锁 的锁模式**，**两个事务对一个数据资源进行先读取再修改的情况下，使用共享锁和排它锁有时会出现死锁现象**，而使用更新锁就可以避免死锁的出现。
  ==资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排它锁，否则变为共享锁==。
- 架构锁：在执行 依赖于表架构的操作 时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)，执行表的数据定义语言 （DDL）操作（例如添加列或除去表）时使用架构修改锁，当编译查询时，使用架构稳定性锁。
- 大容量更新锁（BU）：向表中大容量复制数据并指定了 TABLOCK 提示时使用。 大容量更新锁允许进程将数据并发地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表。

