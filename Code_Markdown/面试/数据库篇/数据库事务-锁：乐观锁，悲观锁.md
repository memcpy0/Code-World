DBMS 中的 并发控制 的任务是确保在 多个事务同时存取数据库中同一数据 时**不破坏事务的隔离性和一致性**以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

- 悲观锁：**假定会发生并发冲突**，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，**直到提交事务**。这对于长事务来讲，**可能会严重影响系统的并发处理能力**。实现方式：使用数据库中的锁机制。
- 乐观锁：==假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁适用于 **读多写少** 的应用场景，这样可以提高吞吐量==。实现方式：一般会使用**版本号机制**或 **CAS** 算法实现

悲观锁：假设数据会发生冲突，**先取锁再访问，使用S锁和X锁实现**，即前面提到的一级到三级封锁协议。
乐观锁：假设数据不会造成冲突，所以**在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测**，如果冲突，则返回给用户异常信息，让用户决定如何去做。**乐观锁适用于读多写少的场景**，这样可以提高程序的吞吐量。通过版本号机制和CAS算法实现。
- 版本号机制：update ... set ... , version=#{version+1} where ... and version=${version}
- CAS算法 compare and swap ：一种无锁的算法，该算法涉及3个操作数
	对于共享变量V，每个线程都会有三个值：Vn,En,Nn，**当线程想要对V进行修改时，会先将V的值拷贝到En中**，然后==竞争地将V的值拷贝到Vn中，比较Vn和En的值是否相等，如果相等，则将Nn拷贝到V中==。
	这里有点怪，但如果放到多线程并发地对V进行更新的环境下就不怪了，==因为每次竞争，都只会有一个线程满足Vn=En的条件，进而修改V，此时其他线程再将V拷贝到Vn中然后比较Vn与En，便会得到二者不相等的结果，进而更新失败==，但不会挂起，而是**继续竞争**，因此若只有两个线程，则其中一个竞争胜利后，另一个马上也会竞争成功。通俗理解：更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。
- CAS缺点：
	- ABA问题：某线程将A改为B，再改为A，则CAS会误认为A没被修改过
	- 自旋操作采用循环的方式实现，若加锁时间长，则会给CPU带来巨大开销
	- CAS只能保证一个共享变量的原子操作。

在实现乐观锁的时候一般是“版本号”和“CAS”一起用的的吧。
cas本身有“ABA”问题，compare的时候有可能表单已经被修改两次以上了，所以加上版本号解决“ABA”问题。

MongoDB乐观锁，对读不加锁，采用版本号防止数据不一致。MySQL使用悲观锁，对数据读操作也要加共享锁。



