死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。
### 死锁
场景：
事务1：update t set ... where id = 1; update t set ... where id = 2;
事务2：update t set ... where id = 2; update t set ... where id = 1;

死锁的必要条件 * 4：**互斥、不可抢占、等待时不释放已有资源（请求和保持）、等待关系成环**

解决方案：
1. 一般InnoDB会自动检测到，并让一个事务回滚，另一个事务继续
2. 设置超时等待参数 innodb_lock_wait_timeout
3. 避免死锁：
	==不同的业务并发访问多个表时，应约定以相同的顺序来访问这些表；
	以批量的方式处理数据时，应事先对数据排序，保证线程按固定的顺序来处理这些数据==
	在事务中，如果要更新记录，应直接申请足够级别的锁

常见的解决死锁的方法（鸵鸟、死锁检测与恢复、死锁预防、死锁避免）
- 如果不同程序并发存取多个表，尽量约定 **以相同的顺序**访问表，可以大大降低死锁机会；
- **在同一个事务中，尽可能做到 一次锁定所需要的所有资源**，减少死锁产生概率——？顺序请求所有资源，一旦无法获取所有资源就放弃前面的资源……
- 对于非常容易产生死锁的业务部分，可以尝试使用 **升级锁定颗粒度**，通过 **表级锁** 定来减少死锁产生的概率。

死锁预防：在资源的动态分配中，用某种方法（如银行家算法）防止系统进入不安全状态

死锁避免：（避免与预防的区别：预防是从必要条件的角度预防死锁的发生，但是即使四个必要条件都满足，也不一定发生死锁（不是充分条件），死锁避免相当于实际情况的模拟，是充分必要）
