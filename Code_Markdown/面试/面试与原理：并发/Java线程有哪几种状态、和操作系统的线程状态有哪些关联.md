## 1. 线程状态
**要求**
* 掌握 Java 线程六种状态
* 掌握 Java 线程状态转换
* 能理解五种状态与六种状态两种说法的区别

# 2. Java线程六种状态及转换
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202303241110070.png)
都是枚举类对象：
- NEW：新建。当一个线程对象被创建，但没有调用start方法时处于新建状态。此时未与操作系统底层线程关联
- RUNNABLE：可运行。调用start方法，就会由**新建**进入**可运行**。此时**与底层线程关联**，由操作系统调度执行
- TERMINATED：线程内代码执行完毕，由**可运行**进入**终结**。此时**取消与底层线程关联**。
- BLOCKED：阻塞。当获取锁失败后，由可运行进入Monitor的阻塞队列阻塞，不占用CPU。当持锁线程释放锁时，按照一定规则唤醒阻塞队列中的**阻塞**线程，唤醒后的线程进入**可运行**状态。
- WAITING：等待。一个线程如果成功获取锁，但发现自身有条件不满足，就调用wait方法，从**可运行状态**释放锁进入Monitor等待集合等待，同样不占用CPU时间。当其他持锁线程调用 notify或notifyAll方法，会按照一定规则唤醒等待集合中的等待线程，恢复为**可运行状态**。
- TIMED_WAITING：有时限等待。一个线程如果成功获取锁，但发现自身有条件不满足，就调用wait(long)方法，等待一段时间，此时从可运行状态释放锁进入Monitor等待集合进行有时限等待。
	- 如果等待超时，也会从有时限等待状态恢复为可运行状态，重新竞争锁。
	- 还有一种情况是，**==调用sleep(long)方法，也会从可运行状态进入有时限等待状态，但与Monitor无关==**，不需要主动唤醒，超时时间到了就自然恢复为可运行状态。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304141203087.png)
> *其他情况*：
> 可以用interrupt()方法打断**等待、有时限等待**的线程，让它们恢复为**可运行状态**。
> park, unpark等方法也可以让线程等待和唤醒。

# 3. Java线程和操作系统五种状态对应
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202303241116799.png)
五种状态说法来自于操作系统层面的划分。
- 新建与终结态：与Java中同名状态类似。不再说明。
- 就绪态：线程有资格分到CPU时间，但没有轮到它
- 运行态：线程分到CPU时间，真正开始执行线程内代码。
- 阻塞态：没资格分到CPU时间。==涵盖了Java状态中提到的**阻塞、等待、有时限等待**==
	- 多出了阻塞IO，指线程在调用阻塞IO时，实际活由IO设备完成，此时线程无事可做，只能干等