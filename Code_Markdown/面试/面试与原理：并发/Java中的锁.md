# 1. Java锁一览
| 锁名称 | 应用 |
|:----|:----|
| 乐观锁 | CAS|
| 悲观锁 | synchronized, vector, hashtable
| 自旋锁 | CAS |
| 可重入锁 | synchronized, Reentrantlock, Lock|
|  读写锁 |  ReentrantReadWriteLock, CopyOnWriteArrayList, CopyOnWriteArraySet
| 公平锁 | ReentrantLock(true)
|  非公平锁 | synchronized, ReentrantLock(false)
| 共享锁 | ReentrantReadWriteLock中读锁
| 独占锁 | synchronized, vector, hashtable, ReentrantReadWriteLock中写锁
| 重量级锁 | synchronized
| 轻量级锁 | 锁优化技术
| 分段锁 | concurrentHashMap
| 偏向锁 | 锁优化技术
| 锁粗化 | 锁优化技术
| 锁消除 | 锁优化技术
| 互斥锁 | synchronized
| 同步锁 | synchronized
| 死锁 | 互相请求对方的资源

# 2. 乐观锁
乐观锁：**在操作数据时非常的乐观，认为别人不会修改数据，因此不加锁**。在执行数据更新时采用比较判断的方式进行操作，如果当前数据被修改过，则放弃操作，否则就执行操作。**乐观锁默认不会上锁**。典型的乐观锁包括 CAS 机制和版本号机制。
- CAS 机制操作过程包括 compare 和 set，通过内存位置、预期值和拟写入的新值三个数据，==先去比较待修改对象是否为它自身所持有的对象，然后比较该对象的数据是否等于期望数据，如果都为是，那就将该对象数据修改为新的数据==。
- 版本号机制： 在表中增加一个 version 字段，每更新一次数据时将此值加一。当读取数据时，连同 version 字段一起读取。当提交更新时，会将数据库表中对应记录的当前版本号与之前取出来的版本号比较，如果一致则执行更新，如果不一致则表示是过期数据放弃操作。

悲观锁：**在操作数据时非常悲观，总是认为别人会修改数据，因此需要加锁**，在更新数据时直到操作执行完毕才释放资源。**悲观锁默认直接上锁**。典型的悲观锁实现方式为 synchronized 关键字、ReentrantLock 独占锁和 MySQL 中的排他锁。

synchronized 关键字在多线程访问共享数据时，同一时刻只能由单个线程抢到资源去执行。且**在线程切换时，涉及到操作系统内核态与用户态的切换**，这些操作会消耗额外的资源，因此效率较低。

# 3. 怎么理解自旋锁？为什么还会有自旋锁？
- 自旋锁
==线程的阻塞和唤醒需要 CPU 从用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说负担较大，会给系统的并发性能带来很大的压力==。 且对象锁的锁状态的持续时间很短，**为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的**，因此引入了自旋锁。

自旋锁让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。==为了达成这个等待，自旋锁会执行一段无意义的循环，这个过程称为自旋==。

**自旋等待不能替代阻塞，虽然自旋可以避免线程切换带来的开销，但却占用了处理器的时间**。 如果持有锁的线程很快就释放了锁，那么**自旋的价值就非常高**。否则，自旋的线程就会白白占用处理的资源，不会做任何有意义的工作，反而浪费了性能。 因此，==自旋必须要有一个限度，如果自旋超过了设定的时长仍然没有获取到锁，则需要被挂起==。

自旋锁在 JDK 1.4.2 中引入，默认关闭，可以使用 -XX:+UseSpinning 开启，**在 JDK1.6 中改为默认开启**。同时**自旋的默认次数为 10 次**，可以通过修改参数 -XX:PreBlockSpin 来调整。但通过调整 -XX:preBlockSpin 来调整自旋次数，会导致很多意外情况。比如刚退出线程锁就被释放。因此 JDK1.6 引入了**自适应的自旋锁**。

适应自旋锁：自适应自旋锁的自旋的次数不再是固定的，它由「前一次在同一个锁上的自旋时间」及状况锁的拥有者的状态」来决定。==线程如果自旋成功了，那么下次自旋的次数会更多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多==。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后这个锁自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。

# 4. 间隙锁是什么(buqingchu)
间隙是对于**键值在条件范围内但并不存在的记录**。间隙锁是指在索引数据时，使用的是范围条件而不是相等条件，并请求共享或排他锁时， InnoDB 会给符合条件的已有数据记录的索引项进行加锁。

间隙锁是开区间，间隙锁 + 行锁合称 next-key lock，每个 next-key lock 是左开右闭区间。间隙锁和 next-key lock 的引入可以解决幻读问题。
