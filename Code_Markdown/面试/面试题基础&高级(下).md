##### 给你一个项目怎么去开发

> 先进行可行性分析，看看这个项目是否可行
>
> 再业务分析和需求分析  尽量分析到业务的细节 
>
> 编写需求文档
>
> 系统设计 编写接口文档
>
> 程序开发 
>
> 测试

##### 如何应对高并发

> 搭建集群部署
>
> 从数据库方面  
>
> 设置主从库  主库主写操作 为innodb存储引擎  从库为myisam存储引擎
>
> innodb和myisam对比
>
> innodb 支持事务  有安全日志文件 可以做数据恢复  默认为行级锁 并发能力强 容易产生死锁问题  支持外键  增删改性能比较好   因为innodb中的b+数据结构 叶子接点为双向链表  自然排序 增删能力强
>
> myisam 不支持事务  默认为表级锁  对查询性能好 并发能力低
>
> 构建索引 
>
> 设计索引原则
>
> where经常查询的字段设计索引  
>
> 经常做增删改的字段不适合建立索引
>
> 字段数据重复像性别不适合建立索引 走全表扫描比建立索引更快
>
> 两表关联建立索引
>
> 排序建立索引  分组建立索引
>
> 索引尽量短小
>
> 不能建立太多索引 建立索引占用空间  维护索引需要时间
>
> 大文本不适合建立索引
>
> redis存储热点数据   直接从redis中获取数据  怎么保证redis和数据的一致性
>
> 写操作的话  同步双写 定时刷新   修改操作的话   通过延迟双删  第一次删除  修改完数据库等一段时间再删除 
>
> 延时双删的话是如果事务1修改数据库信息  此时redis中的数据已经被删除 那么只能从数据中读取  但是数据中的数据为旧数据  事务2再去更新redis中数据  这时候事务1也修改完redis中的数据 那么之后其他线程从redis中读取的数据只能为脏数据  事务2读取的就是脏数据  这时候如果采用延时双删第二次删除的时间  为事务2修改redis的时间  如果等事务2修改完redis中的数据 再去删除redis中的数据  那么事务2当前读取到的数据为脏数据但是之后再读取redis中数据  就是新数据  
>
> 通过监控binlog通过异步消息通知去删除redis中的数据 再加上消息重试机制  直到删除成功为止
>
> 通过es作为全文检索   mongo存储数据  像存储搜索记录这样的  数据量大但是不是那么重要的数据
>
> redis高可用  搭建redis集群  哨兵集群 分片集群 
>
> 分片集群是通过搭建多个主从集群   主节点 相互连接  分片集群类似于哨兵集群  都是有监控机制  可以在主节点停机 能把从节点选举成主节点   通过一个pingpong机制  检测主节点是否存活  分片集群有一个插槽机制  数据存储在插槽上  
>
> 为什么使用mongo
>
> mongo相较于rabbitmq的话 消息吞吐量百万级别的   但是消息可靠性可能不如rabbitmq好  因为mongo的一个偏移量机制  会造成重复消费 和 消费没被消费   可以加分布式锁 和 设置mongo 的偏移量大小
>
> mongo重复消费怎么解决
>
> 通过消费者手动提交偏移量  可以同步提交但是会阻塞  异步提交
>
> 设置更小的偏移量周期  
>
> 搭建集群  多起几个实例
>
> 
>
> 

##### 在项目遇到的难题是什么 举例说一说

> 其中当时有个比较头疼的问题就有一次 延迟任务发布报异常  没有发生事务回滚 ，当时方法上都是加着事务注解的 但是就是没有回滚 研究了挺长时间的  后来查spring事务才发现是 spring的事务这能 在为捕捉的运行时异常发生的时候回滚  之后就在方法上加参数 rollbackfor   异常  就没事了

#### Java基础

##### 1.单例模式的分类

> 某个类的实例在单例模式只能创建一次
>
> 饿汉模式
>
> 开始就会创建调用直接有
>
> 懒汉模式
>
> 调用指定方法才会创建 多线程情况下不安全  线程sleep可能会创建多个对象
>
> 双检锁
>
> 线程安全通过sy锁双重判断加 if判断  
>
> 但是效率低

##### 2.什么是泛型擦除

> 泛型擦除是指比如ArrayList指定泛型是string  和integer  创建出来两个ArrayList  等等两个对象的class文件是相等的
>
> 是指java在编译之后会把类型泛型擦除  只留下 List
>
> 但是通过反射能在String泛型中存入int
>
> 类型擦除
>
> Java中通过对制定泛型进行类型擦除  不是指定类型 直接编译报错

##### 3.说说syn中的锁转换

> syn中有四种锁状态  无锁  偏向锁  轻量锁  重量锁
>
> 锁升级过程
>
> 如果没有线程去竞争  只有一个线程去抢锁 那么 同步代码块中会存入当前线程的唯一标识那么当 这个线程再来执行同步代码块后 就不会去抢锁 和释放锁 
>
> 当有两个线程来竞争获取锁的话  锁从偏向锁升级为轻量锁 那么 如果有线程在代码块中执行 那么线程2 抢锁发现有人拿到了 会把锁升级为轻量锁  会自旋或者锁  如果自锁10次获取不到锁 那么锁升级为重入锁   
>
> 重入锁的话 其他线程再来获取锁只能阻塞  只能执行线程执行完唤醒所有线程

##### 4.list去重

> 通过stream流去重
>
> 通过set集合去重  添加到set集合中

##### 5.面向对象编程的优点

> 易拓展 低耦合  有面向对象的三大特征 封装 继承 多态  系统灵活 易维护 易复用

##### 6.常用的设计模式

> 单例模式  模板方法模式  观察者模式  代理模式  抽象工厂模式

##### 7.简单介绍一下NIO

> NIO是基于通道和缓存操作的  
>
> 通过从通道读取到数据到缓存  然后线程就可以去干别的操作

##### 8.jvm内存空间了解嘛 简单介绍一下

> jvm内存空间有 堆  存放new出来的对象  还有运行常量池也在堆中
>
> 方法区  加载好的类在方法区  栈  局部变量存放在栈中  还有程序计数器  存放程序下一步需要操作的指令的位置

##### 9.类加载的过程

> 加载 验证  准备 解析 初始化

#### 数据库

##### 1.数据库三大范式

> 原子性   字段列表不可分割 ，字段属性不可分割
>
> 直接性   每个属性和主键有直接关系 而不是间接关系
>
> 唯一性  一张表只说一件事，对记录有唯一标识

##### 2.数据库的隔离级别

> 读未提交  
>
> 一个事务可以读取别的事务未提交的数据   会产生脏读问题
>
> 读已提交
>
> 一个事务只能读取到别的事务已提交的数据  但是会产生不可重复读，虚读  绝大多数数据的隔离级别  避免了脏读问题
>
> 可重复读
>
> mysql默认隔离级别 避免了脏读问题  一个事务的多个实例在并发情况下可以读取到相同的数据，但是会产生幻读  MVCC机制解决了这个问题
>
> 可串行化
>
> 就是给读取数据加锁   影响性能 高并发情况不考虑

##### 3.为什么string不加双引号会使索引失效

> 创建索引的时候索引为varchar类型，string不加双引号会被mysql转换为int类型，发生隐式转换

##### 4.数据库设计

> 先通过和前端开会讨论需求，进行需求分析
>
> 先画出需求中数据表的ER图，分析表和表之间的关联关系
>
> 通过powed工具设计出数据库

##### 5.like使用%开头一定会使索引失效嘛

> 不一定会 
>
> 如果查询的字段只有当前字段和id  会走索引覆盖 不会回表 就会使用索引

##### 6.mysql的多表查询怎么实现

> 多表查询是通过内连接和外连接实现
>
> 内连接分为隐式内连接 和 显示内连接
>
> 隐式内连接是通过两个表的id进行where条件连接
>
> 显示内连接是通过inner join 表2  on where关联id条件
>
> 外连接是通过 左外连接 和右外连接实现
>
> 左外连接是通过left join 表2 on  where  关联字段  左外连接是以左表为主表 查询出来所有左表的字段 右表和左表匹配的字段数据显示  不匹配的直接为null
>
> 右外连接是通过regih join 表2 on where 关联字段   右外连接是以右表为主表 查询出右表所有的字段  左表不匹配的显示为null

#### Spring

##### 1.Spring中bean的多例模式怎么设置

> 加注解scope（“prototype”）

##### 2.spring中单例模式的好处

> 提高性能  不能每次都去new对象

##### 3.谈谈你对spring中IOC的理解

> IOC控制反转   之前是自己通过手动new对象  现在spring通过@bean自动创建对象 放入ioc容器中  需要的话就通过依赖注入就可以   有三种注入方式  构造器  setter   注解注入

##### 4.谈谈你对spring中AOP的理解

> AOP面向切面编程   
>
> AOP中通过把对多个对象影响的共同行为和逻辑 抽取成一个模块进行增强 称为切面
>
> springAOP通过动态代理 不会去修改原有的对象  但是会在模块中进行功能增强然后再回调原有对象方法

##### 5.spring中bean的五大作用域都有哪几个

> 第一个是默认的单例模式  全局只有一个bean实例对象   
>
> 第二个是  多例模式   每次调用都会创建一个bean实例对象
>
> 第三个是  request请求就会创建一个bean实例对象  请求完就会回收
>
> 第四个是  同一个session域创建一个bean对象  
>
> 第五个是 全局作用域  针对全局session公用一个bean对象
>
> 怎么修改
>
> 加上注解  scope 加上对象作用域就可以了

#####  6.spring中的设计模式

> 工厂模式 工厂bean
>
> 单例模式  bean默认只有一个实例
>
> 代理模式  springAOP动态代理功能增强
>
> 模板方法   
>
> 观察者模式

##### 7.spring中事务的理解

> spring中的事务本质上是数据库的事务，spring本身是没有事务功能的
>
> 数据库事务是通过binlog和redolog实现事务提交和回滚的
>
> 通过Transactional注解  和AOP配置

##### 8.spring中bean单例模式对于多线程是否存在安全性问题

> 存在  
>
> 如果bean对象中存在可变成员变量，并且有线程需要去改变的情况下会出现数据混淆
>
> 多线程情况下 其他线程是无法访问当前线程的bean对象的  
>
> 解决
>
> 尽量不去定义有可变变量的对象
>
> 如果非要去存入ioc容器中的话  可以设置ThreadLocal把需要的改变的成员变量放入Threadlocal中就可以

##### 9.spring的优点

> spring是低污染设计框架
>
> spring中的ioc控制反装 通过spring同一管理对象的创建销毁
>
> spring中的aop切面编程可以进行功能的增强
>
> spring中对主流的框架进行了集成

##### 10.微服务中session怎么在各个服务中共享数据

> 结合redis  
>
> session域通过yml配置为redis
>
> 把登陆信息设置在redis中  这样微服务中的其他服务配置当前redis  就能从redis中获取登陆用户信息

##### 11.spring中的事务管理类型有哪些

> 有编程式事务类型  通过代码显示开区事务 提交事务  回滚事务  不容易管理
>
> 声明式事务类型  通过注解直接声明事务  

##### 12.spring事务的隔离级别

> spring的事务本质上是数据库事务  如果数据库不支持事务spring也不支持事务
>
> 和数据库的隔离级别一样  
>
> 读已提交  只能读取事务已经提交的事务  会产生不可重复读 幻读  MVCC解决
>
> 读未提交  读取事务没有提交的数据  会产生脏读  
>
> 可重复读  mysql的默认隔离机制  并发情况下保证一个事务读取到的是相同的数据
>
> 可串行读  给数据行加锁  最安全 但是效率最低

##### 13.spring中事务失效的场景

> spring中事务1调用事务2 事务1带事务注解 事务2不带 会生效嘛
>
> spring中事务的调用是通过aop切面增强 这时候spring生成代理类去调用事务2  在同一类中不管事务2带不带事务都会生效  如果不在同一类中事务也会生效
>
> 事务1不带事务调用 事务2带事务 事务1不会生效
>
> mysql数据库的存储引擎不支持事务
>
> spring中的事务传播行为不支持事务
>
> 类没被spring事务管理
>
> 

##### 14.spring中的事务传播行为

> spring中的事务分为三大类  
>
> 支持事务  不支持事务  嵌套事务
>
> 如果当前事务存在事务那么就加入 如果不存在就创建一个
>
> 如果当前事务存在就加入 不存在则以非事务运行
>
> 如果当前事务存在就加入  不存在就报异常
>
> 新建一个事务运行 如果事务调用者存在事务就把事务调用者的事务挂起
>
> 以非事务运行 如果调用者存在事务就挂起
>
> 以非事务运行 如果调用者存在事务就报异常
>
> 如果调用者存在事务 就在调用者事务中再新建一个事务  如果事务不存在  则新建一个事务

##### 15.spring的三级缓存了解嘛  说一说

> spring 的三级缓存的话  
>
> 一级缓存是 初始化 注入 实例化完成的bean 
>
> 二级缓存是 实例化完成的bean
>
> 三级缓存是  bean的实例化工厂  
>
> 三级缓存解决的是 spring中的依赖循环问题
>
> spring中构造器注入bean 循环依赖是会报异常的

##### 16.springMvc中的工作流程 和 springmvc中的核心控制器

> 用户通过浏览器发送http请求 到前端控制器
>
> 前端控制器通过处理器映射器解析url 中的handler返回给前端控制器
>
> 前端控制器把解析好的handler 发送给处理器适配器进行处理
>
> 处理器适配器调用具体的处理器进行对handler的业务处理
>
> 返回给处理器适配器模型和视图对象  
>
> 处理器适配器把模型和视图对象返回给前端控制器  
>
> 前端控制器调用视图解析器 解析为视图 
>
> 返回给前端控制器 
>
> 前端控制器经过渲染成页面返回给用户
>
> springmvc中的三大核心控制器为
>
> 处理器映射器 处理器适配器  视图解析器

##### 17.springaop的应用场景

> spring事务
>
> 日志打打印
>
> 缓存
>
> 调试
>
> 持久化
>
> 懒加载

#### Redis

##### 1.redis雪崩 击穿  穿透

> 

#### 面试题

##### 1.java的特性？

##### 2.Linux的常用命令

> cd 进入文件  cd .. 回退
>
> cp  拷贝文件
>
> mkdir  创建文件夹
>
> ls 查看当前文件目录下的文件
>
> chmod  修改文件权限
>
> tar 解压文件

##### 3.Linux有哪些版本

##### 4.SpringBoot配置文件的加载顺序

> 先加载jar包之外的配置文件再加载jar包内的配置文件
>
> 先加载config目录内的配置文件再加载config目录外的配置文件
>
> 先加载config子目录下的配置文件再加载config目录下的配置文件
>
> 先加载application-profile pro / yml 在加载 application pro  / yml
>
> 先加载pro 再加载yml

##### 5.Reids常见数据类型

> 答案：String  List  Hash  Set  ZSet

##### 6.SpringBoot启动时会加载哪些配置文件

> 答案：SpringBoot启动时默认加载bootstrap.properties或bootstrap.yml（这两个优先级最高）、application.properties或application.yml

##### 7.简述SpringMVC

> 答案：Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。Spring MVC的特点：

> 1. 轻量
> 2. 高效
> 3. 与Spring兼容性好
> 4. 功能强大。

##### 8.SSM是什么

> 是spring+springMVC+mybatis框架的简称

##### 9.Mybatis的xml文件中常见标签

> 答案： select  insert  update  delete
>
> 动态sql ：if  and  where   set   foreach

##### 10.Redis 的五大数据类型是什么?  

> 答案：String  List  Hash  Set  ZSet

##### 11.ES可以实现那些功能.  ES怎么快速查询

> 答案：快速查询  自动补全  聚合查询   高亮显示   距离显示  附近数据显示
>
> 通过倒排索引  把字段分为 词条  每个词条绑定数据id  每个词条通过es自动创建id   通过词条的id索引查询  快速 高效

##### 12.Mysql多表联查语句怎么写 group on是什么意思 sql函数有哪些 if语句怎么写 你在项目中负责哪几个模块，实现了什么功能？遇到过什么难题？

> 多表联查 有内连接 外连接 
>
> 内连接分为 隐式内连接  where关联字段之间对比  
>
> 显示内连接  inner join 表2  只显示两表关联字段
>
> 外连接分为 左外连接  右外连接  
>
> 左外连接 left join 以左表为准  不一样为null
>
> 右外连接 regiht join 以右表为准 不一样为null
>
> group by 为分组 
>
> sql函数 分为  字符串函数  聚合函数  数字函数  日期函数

##### 13.你们项目中用到了哪些技术栈？项目有多少用户使用？

##### 14.mysql数据库优化？遇到过mysql索引失效吗怎么解决的？项目如何部署？使用了哪些服务器？对消息队列了解吗？spring的事务，Transaction注解底层有哪些参数，事务不生效有哪些情况？如何并行开发？

> 1、不使用 * 使用准确字段名  、为表起别名查询   、使用between and  代替 in 、  选择合适的索引引擎  、  where中不使用！ ><  不使用函数表达式  使用精确的数值 、大语句拆分小语句  大语句占用数据库锁 性能低
>
> 2、使用覆盖索引，避免回表 、多个条件查询的时候使用联合索引替换单列索引 、 实现主主复制  读写分类  主从复制  、使用redis缓存  、垂直分表 水平分表
>
> 使用is null is not null 会使索引失效
>
> 字符串不使用单引号  会使索引失效
>
> 尽量不要再索引列上做操作  会使索引失效
>
> 使用or  连接 会使索引失效
>
> like %号开头会使索引失效
>
> mysql中使用！= <>会使索引失效
>
> 不使用 select *  使用覆盖索引精确字段名  
>
> 事务不生效的情况
>
> 数据库引擎不支持事务
>
> 方法不被spring事务管理
>
> 方法不是public修饰
>
> 同一类中方法的调动  方法A调用方法B 方法A被事务管理 但是方法B没有  事务失效
>
> 未配置spring事务管理器
>
> 事务传播类型不会支持事务
>
> 不正常的捕捉异常信息
>
> 错误标注异常
>
> 4、RabbitMQ消息队列
>
> 5、[(11条消息) @Transactional注解中常用参数说明_林卓呀的博客-CSDN博客](https://blog.csdn.net/qq_39893596/article/details/81872856)

##### 15.hashmap  hashable的区别

> hashmap线程不安全  效率高   可以存储 null
>
> hashable线程安全  效率不高  

##### 16.并发 并行的区别

> 并发 同一时间端有两个或者两以上的进程
>
> 并行  同一时间有两个或者两个以上的进程
>
> 并发在不管是在单线程还是多线程中都可以存在  并发 相当于交替进行   可以高并发   
>
> 并行是只能在多线程中存在 因为并行要求至少有两个线程
>
> 相同点 都是为了压榨cpu的性能

##### 17.创建线程的方式

> 继承Thread  重写 run方法 
>
> 实现 Runable类  重写run方法
>
> 实现Callable类  重写call方法
>
> 创建线程池   核心线程数   最大线程数   空闲线程时间  时间单位   阻塞队列   线程工厂  拒绝策略

##### 18.什么是工作流

> 

##### 19.hashmap怎么获取数据

>  get方法  java每个对象都有hasecode  通过哈希算法计算哈希值 确定数组下标   在数组中查找   确认 数组中当前下标中是否有值  有值的话   对比eqauls方法 如果一样则取出 不一样则返回null

##### 20.redis是单线程还是多线程

> 单线程

##### 21.redis怎么实现多线程

> redis.conf中开启多线程 然后设置线程数量  
>
> redis6.0之后  有多线程
>
> redis的多线程只是 用于针对网络请求IO的  redis的性能瓶颈不在CPU 而是网路和内存   
>
> 对于请求的读写操作  redis还是单线程进行操作

##### 22.redis怎么保证与数据库的一致性

> 高并发情况线程1更新数据库操作，会有线程2来访问redis 这时候就出现了redis和mysql数据不一致
>
> 先更新数据库，再更新缓存
>
> 先删除缓存，再更新数据库
>
> 实现最终一致性  
>
> 延时双删
>
> 删除redis 更新数据库 延时一段时间再删除redis
>
> 如果事务1在更新数据库期间  事务2读取信息 因为redis已经删除  所以从数据库中读取  读取的是旧数据
>
> 然后 事务1 更新完数据库  立刻删除redis   这时候事务2 已经拿到数据库中的旧数据  事务1立刻删redis  
>
> 事务2立马更新redis   这之后redis中一直是之前的脏数据
>
> 延时的话  延时时间要大于事务2更新redis 的请求时间  在事务2更新之后 进行删除  然后事务1更新redis  
>
> 事务2就能正常获取到正常数据
>
> 利用mysql中的cannl  伪装成mysql的从机  监听二进制文件  数据库发生变化会主动给MQ发送文件  利用MQ的重试机制删除redis的缓存

##### 23.redis持久化的几种方式， 你们使用的哪种方式

> RDB  和AOF  
>
> RDB是数据快照  数据丢失大  恢复快 
>
> AOF记录redis的每一行命令  数据完整性比RDB好  恢复慢
>
> 两种一起使用  

##### 24.#{}预编译,是谁的功能，${}如何在JDBC实现预编译

> mybatis预编译  功能
>
> 传入参数相当于占位符 ？  自动加“”双引号
>
> 可以防止SQL注入
>
> ${} 传入参数不加双引号  有sql注入的风险
>
> 

##### 25.说一下你对Springboot的理解

> 实现了自动配置  加载项目自动加载框架需要的默认配置
>
> 解决了版本冲突，解决了maven项目依赖之间的版本冲突问题 ，springboot给出了最优的maven版本
>
> 内置Tomcat
>
> 实现了起步依赖，加载项目自动装配初始的框架

##### 26.如何解决redis内存溢出

> redis内存淘汰策略
>
> 默认内存redis内存淘汰策略是不淘汰，报错
>
> redis淘汰策略分为两大类 设置过期时间得键值对  所有键值对
>
> 设置过期时间键值对淘汰策略分为  淘汰随机  淘汰最少使用次数  淘汰最长时间未使用  淘汰快到过期时间的
>
> 所有键值对  淘汰随机  淘汰最长时间未使用的  淘汰最少使用次数的

##### 27.Java数据类型

> 数组   栈   链表  红黑树   队列   散列   

##### 28.什么是深拷贝/深克隆

> 相对应的有浅克隆 深拷贝  两者区别在于是否拷贝了Java对象   浅拷贝只是复制了指针还是指向同一内存空间，深克隆是复制了一模一样的内存空间两个对象不同内存空间 改变另一个对象 不会影响拷贝对象

##### 29.线程池的创建，他是哪个包的

> 

##### 30.Tcp/ip的七层模型

> 从低到高分别为
>
> 物理层   网关
>
> 数据链路层  以太网
>
> 网络层 ip之类的
>
> 传输层   端口对端口
>
> 会话层
>
> 表现层
>
> 应用层  http协议之类的

##### 31.项目中哪块用到了多线程

> 

##### 32.多线程相关问题

> 

##### 33.Kafka和mq的区别

> kafka的高吞吐量 在普通商用机上都可以
>
> kafka是顺序写磁盘 效率高
>
> kafka支持离线数据处理  实时数据处理
>
> kafka支持在线扩展
>
> mq  有消息确认机制  消息安全性高
>
> 处理大数据方面 kafka也能保持O1的复杂度  mq就会有点性能下降

##### 34.Linux chomd是干嘛用的

##### 35.Spring常用注解

> 

##### 36.nginx反向代理

> 就是请求通过nginx被拦截，通过nginx反向代理服务器把请求分发给后端处理业务的服务器
>
> 隐藏了源服务器的存在和特性，可以作为互联网和web服务器之间的中间件

##### 37.Arraylist是否是线程安全

> 线程不安全  效率高

##### 38.如何遍历hasymap

> 迭代器遍历 entrySet  
>
> 迭代器遍历 keySet
>
> for-each
>
> Lambda表达式
>
> Steam流遍历

##### 39.Spring中如何实现数据回滚

##### 40.如何解决死锁

> 产生死锁是因为两个或两个以上的线程抢夺对方占用资源，并对占有资源不释放 引发死锁问题
>
> 破坏死锁产生的条件
>
> 死锁产生的条件有四个
>
> 一个是互斥条件  一个资源同一时刻只能由一个线程拥有
>
> 一个是请求和保持条件 线程请求被占用资源，但是对已有的持有资源不释放
>
> 一个是循环条件 线程请求不到占用资源会一直处于循环状态
>
> 一个是不剥夺条件  资源只能由当前线程使用释放完，线程不使用完发生阻塞就会一直占用 除非线程主动释放
>
> 破坏请求和保持条件 一次性申请所有资源
>
> 破坏循环条件 线程要按照顺序申请资源
>
> 破坏不剥夺条件 线程请求被占用资源阻塞了 要主动释放自己占用资源

##### 41.mio是怎么保证数据安全的

##### 42.前端传来一个? 后端用什么注解去接

##### 43.怎么解决token失效的问题

> 登陆的时候在token中设置一个时间戳A
>
> 如果再次通过网页操作的话 ajax请求中携带一个时间戳 B
>
> 通过时间戳B减去时间戳A获取到的时间差  和token的时效性对比 
>
> 如果过期了就退回登陆页面重新登录

##### 44.spring常用的注解

##### 45.创建线程池的七个核心参数

> 核心线程大小
>
> 线程总数
>
> 空闲线程存活时间
>
> 空闲线程时间单位
>
> 阻塞队列
>
> 线程工厂
>
> 拒绝策略

##### 46.创建线程的四种方式

> 

##### 47.@Resource和 @Atowared区别

> @Resource是通过byName注入  @Autowared 是通过byType按照类型注入
>
> resource如果不指定name则按照字段名去查找注入  也是bytype
>
> autowared也可以通过Qualifer按照name注入

##### 48.怎样用多线程快速处理一个50g的大文件

##### 49.雪崩击穿穿透

> 缓存雪崩  
>
> 同一时间大量key过期，直接访问数据  
>
> 设置key随机过期时间，避免同一时间大量key过期
>
> 双缓存，缓存A设置有效时间  缓存B不设置过期时间  需要缓存预热操作
>
> 访问缓存A没数据访问缓存B，如果都没有数据就才访问数据库，同时异步调用线程去更新缓存A和B
>
> 缓存穿透
>
> 同一时间大量不存在的key直接访问数据库
>
> 设置互斥锁   缓存失效获取锁 ，才能访问数据库，未获取锁重试
>
> 设置布隆过滤器，如果访问不合法的key则直接驳回

##### 50.Redis瓶颈

> redis的瓶颈是内存和网络  不是cpu

##### 51.Docker优点

##### 52.数据库中删除表的三条命令，drop，delete，truncate的区别

> drop 是删除整个表的结构和数据  不可回滚
>
> delete是删除指定数据  对表结构没有影响  可回滚
>
> truncate是删除整个表的数据  不可回滚

##### 53.B树和B+树的区别

> B树 每个节点都存储的是索引加数据  一个节点数据很多
>
> B+树 
>
>  非叶子节点 存储的是索引数据   叶子节点存储的是索引对应的数据信息 
>
> 层数更低   减少磁盘的IO 提高性能
>
> 叶子节点维护的双向链表  范围查询更方便
>
> 因为索引和 数据存储是相互分离的  如果做全表查询  就能分开查询  只查询叶子节点的数据   提高查询性能	

##### 54.数据库创建索引规则

> 经常进行where条件查询的字段可以创建索引
>
> 排序查询可以建立索引  B+树天然排序
>
> 分组查询也可以建立索引  分组也是需要排序的
>
> 关联表信息建立索引  不用全表扫描  
>
> 
>
> 经常更新的字段数据 不建立索引
>
> where条件查询用不到的字段不建立索引
>
> 计算字段不建立建立索引
>
> 数据重复并且均匀的不建议建立索引  相反这类数据索引还不如全表扫描快

##### 55.SpringCloud常见组件跟作用

> 服务注册  nacos
>
> 网关  gatway
>
> 远程调用  feign
>
> 负载均衡器  ribbon

##### 56.jwt底层是怎么实现的

##### 57.hashmap 为什么是8的时候链表变成红黑树

##### 58.springboot在启动的时候可以修改什么参数

##### 59.Hash1.7前头插法 1.8的尾插法原理 死循环问题

##### 60.reids的雪崩用布隆过滤器的原理 什么二进制实现的

> 布隆过滤器就是一个很大的数组和几个无偏的哈希函数
>
> 通过几个哈希函数计算出整数索引值，再通过数组长度的一个取模运算出一个位置，几个哈希函数计算的值都是不一样的，但是把值都设置成1存入数组，  如果要取数据的话再通过几个哈希函数计算数组下标  计算的数组下标必须都为1  如果有一个不为1则说明元素不存在  直接返回

##### 61.数据库的底层原理

> 从数据库的存储引擎来说有两种一个是
>
> MyIsAm 
>
> 这种不支持事务，默认锁的粒度是表级锁 查询效率比较快   并发能力低  
>
> 还有一个是InnoDB
>
> 这种是目前Mysql中的存储引擎  支持事务  默认锁的粒度是行级锁  锁得粒度小 并发能力强但是会产生死锁的问题 影响性能  有安全日志文件  对数据宕机恢复能力能好
>
> 数据库索引方面  建立索引就是为了避免全表扫描 提高数据检索效率   从无序 IO变为有序IO 
>
> 因为建立索引会构建B+树结构  B+树的叶子节点天然有序  维护一个双向链表  因为B+树  层数低 磁盘IO性能影响比较小  非叶子节点存放索引信息  叶子节点存放数据行信息   通过B+树做全表扫描 要效率更快
>
> 什么字段建立索引
>
> where条件经常查找的字段建立索引
>
> 关联表的话主键建立索引
>
> 经常更新的字段不适合建立索引 
>
> 做数据计算的字段不适合建立索引
>
> 数据均匀的字段 像性别 不适合建立索引 
>
> 索引优化方面
>
> like模糊查询用%开头 会使索引失效
>
> 字符串不使用单引号 会使索引失效
>
> 使用字符！= <>  会使索引失效
>
> 使用select * 会使索引失效
>
> 使用is null  和is not null  会使索引失效 

##### 62.处理hashtable还有那些安全 concurrenthashmap是怎么保证安全的

##### 63.sy锁和lock锁是公平锁还是非公平锁 sy锁的四种形态 轻量级锁啥情况转重量级锁

##### 64.voltaile是什么

##### 65.缓存一致性

> 无论先更新数据库删除redis  还是先删除redis更新数据库 在高并发情况下都会产生脏读的问题  数据不一致的情况   
>
> 可以采用延时双删  和 监控mysql的binlog日志文件  来实现数据的最终一致性
>
> 延时双删先删除redis  更新数据库 再延时删除redis   延时删除redis是因为 如果在事务1更新数据库期间 如果事务2来读取数据会从数据库中读旧数据  再更新redis  这时候如果事务1更新完数据库  直接删除redis  这时候事务2正好把redis更新了  这之后读取的都是旧数据  如果延时删除  延时时间大于事务2更新redis时间  就可以在保证redis数据是新数据的情况下  事务2再来读取就是新数据
>
> 监控mysql中的binlog日志文件是通过异步重试机制  监控binlog文件如果更新数据库异步发送消息队列通过ribbtMQ异步实时进行删除redis  通过重试机制 直到消息队列删除成功  保证读取的数据最终一致性

##### 66.操作数栈是干嘛用的

##### 67.堆的大小栈对不对

##### 68.JDK1.8常用的接口。

##### 69.异常的分类有哪些？有哪些运行时异常？

##### 70.lambda表达式的应用场景。

##### 71.list和map的区别。

> 

72.list的遍历方式，arraylist的底层数组是怎么实现的，如何拷贝数组

73.如何将arraylist中偶数位置的元素删除，增强for能否实现？该如何实现？

##### 74.arraylist的元素能否为null？

> list底层是数组  允许值为null

75.map的遍历方式？map可不可以用for循环遍历？

76.hashmap是线程安全的嘛？concurrenthashmap是如何实现线程安全的？

77.线程创建几种方式？

78.线程池的原理。如果线程满了怎么办？

79.如果有两个线程，一个线程执行打印1 2 3，另一个线程执行打印a b c ，如何保证最后的打印结果是1a2b3c

80.用过哪些关于操作文件的类，api

81.泛型的使用场景，泛型可以用基本数据类型嘛？泛型可擦除嘛？

82.springboot的常用注解有哪些？

##### 83.@Autowired和@Resource的区别？如何@Autowired注入含有多个实现类的接口。

> @Autowired是根据byType类型注入的  @Resource是根据byName注入的  如果resource没有标注注入名字，会根据标注注解的字段名称去搜索是否有同名的Bean
>
> @Autowired是根据类型注入  如果一个接口有多个实例  那么根据@Qualifier  标注指定实例注入

##### 84.@Controller和@Service注解可以被其他注解代替嘛？

> @controller是springMVC的注解
>
> @Service是spring的注解  两者都是spring的注解可以互换 但是为了明确层级关系controller是标注的控制层
>
> service是业务层

85.@PostConstruct的作用

86.Linux中如何查找一个文件中指定的关键字？如何创建多级文件夹？

##### 90.前端传文件后端怎么接受

91.ajxs底层

92.本地读取文件

93.百万数据的批量插入带来的问题

94.Arraylist如何去重

95.minio数据结构

96.登录认证怎么做的

97.权限这一块，有涉及吗，怎么做的

98.Redis怎么实现延时队列

99.实时刷新可控吗

100.了解其他的定时器吗  

101.消息队列用的是啥

102.项目做多久，几个人

103.抽象类应用场景

104.怎么理解接口

105.怎么实例化接口

106.接口有构造方法吗

107.Springbean生命周期

##### 108.Bean在spring中是单例还是多例

> 单例

109.Java会内存溢出么

110.什么是内存溢出

##### 111.常用什么集合

> ArrayList   hashMap   数组   

##### 112.介绍ArrayList

##### 113.数据和集合的区别 

> 集合相比于数组是可以自动扩容   

##### 114.ArrayList扩容机制

> ArrayList数组储存满的话，会自动扩容到之前的1.5倍，再把之前的数据拷贝到扩容之后的数据中，默认存储长度为10

##### 115.mybatis动态标签

> 动态sql  其中有  if  and   where    foreach   set  

##### 116.有个需求，dao层实现if else逻辑，用mybatis动态标签实现

> Mybatis中不支持if else的动态sql  
>
> 可以使用choose  动态标签代替  相当于Java中的switch  
>
> choose  中用when  作为条件判断  如果都不符合 使用 otherwise   实现if  else的动态sql

##### 117.mybatis一级缓存和二级缓存

> mybatis一级缓存针对的是sqlSession 二级缓存针对的mapper  
>
> 一级缓存默认开区  sql通过数据库查询出的数据 存储在mapper中的一级缓存  如果相同的sql  参数一样再来查询就会通过一级缓存直接返回结果不同通过mqsql数据库查询
>
> 二级缓存是多个sqlsession查询mapper中的sql 如果mappernamescope相同 也会共享数据 
>
> 二级缓存开启的话需要把存储的pojo类实现反序列化接口  因为二级缓存随机存储在内存或者磁盘

##### 118.springboot和spring比较提升在哪 

> 自动配置  避免了spring中的繁琐的起步配置  springboot一键加载 

##### 119.广播的特点

> 一对所有的网络通讯  不管是否需要  都会传输到  有线电视就是通过广播
>
> 优点就是网路设备简单 维护简单 成本低
>
> 缺点也比较明显 不能定制化 

##### 120.分布式锁，怎么实现

> 利用数据唯一索引  排他性  只允许一个执行者操作数据库，操作成功记录用业务id记录数据 ，当其他执行者来操作的话因为唯一索引的排他性  会抛出异常，如果抛出异常则说明获取锁失败
>
> redis  因为redis是通过内存操作  避免了磁盘IO的写入 比数据库效率高，通过redis中的setNX来进行操作   如果key存在则报错插入不成功
>
> key不存在 则进行插入

##### 121.了解分布式缓存吗

##### 122.分布式事务怎么实现

> 通过seata 来配置分布式事务 
>
> seata中分为四种事务模式 
>
> XA   强一致性  必须等到所有分支事务执行完再向事务协调者提交事务   占用数据库资源
>
> AT   最终一致性   数据快照    如果单个事务执行报错  按照数据快照进行回滚 不会占用数据库资源   全局锁  脏写  写完之后的数据快照对比
>
> TCC    自定义事务 有业务入侵   定义  提交   回滚  资源锁定   其中要考虑 空回滚  和业务悬挂   分支事务阻塞  需要判断 防止   确保幂等性
>
> SAGA

##### 133.简单介绍一下xa  tcc  

##### 134.用的什么数据库，用的哪个数据引擎

> Mysql   InnoDB数据引擎

##### 135.Innodb特点

> mysql5.5之后的搜索引擎  增删比较快  默认是行锁  锁的粒度小   有安全日志文件 可以数据恢复  支持事务操作  满足 ACID

##### 136.面向对象的特征

> 封装
>
> 继承 
>
> 多态
>
> 五大原理
>
> 单一职责原理
>
> 开放封闭原理
>
> 依赖倒置原理
>
> 里氏替代原理
>
> 接口封闭原理

##### 137.多态的应用场景

> 

##### 138.java中有哪些容器

##### 139.多线程中并发和并行的区别

##### 140.多个线程操作同一个数据，如何保证数据的原子性

> 首先想到的应该是加锁
>
> synchronized锁
>
> lock锁

##### 145.加锁如何保证变量的修改可见性

> 通过volatile关键词修饰变量 可以在保障在  线程获取锁中变量的同时  获取到的是最新的数据  保证了变量的可见性

##### 146.jsp的作用域

>   application  整个应用
>
> session 同一个浏览器的多次请求
>
> request  一个http请求
>
> page  当前页面

##### 147.spring boot和spring cloud的区别

##### 148.redis如何实现延迟任务

> 利用redis中sorted Set  把执行任务的时间戳放进去  通过 score  执行任务描述为set的value  Zset是有序的集合  通过开启一个定时线程  定时扫描zset中的时间戳  等于当前时间  执行任务 然后去移除  多线程情况下会出现多个线程消费同一个任务  可以加分布式锁  只能一个线程取出

##### 149.string a = "1" string b = "2" 他们在不加新空间的基础上能换吗

##### 150.hashmap 是线程安全吗，线程安全用什么，除了hashtable还有什么

##### 151.jdk8的新特性

> 函数式接口 
>
> 方法引用
>
> Lambda表达式
>
> Stream 流
>
> 新的时间日期类
>
> 接口支持 默认方法  静态方法

##### 152.int a = 1,Integer b = 1 他俩等等相等吗

> 比较的话java中会把包装类拆成基本类型  所以是相等的
>
> 字符串常量池 -128  127

##### 153.基本数据类型 ， 封装类

> 四类八种  
>
> char  short   int  byte   long   float   double   boolean
>
> 封装类
>
> intege  

##### 154.sql优化 最左查询应用的底层

> 最左查询的底层原理
>
> 假如有a，b，c  三个作为联合索引
>
> 最左查询的基础是在联合查询上的
>
> 如果a,b,c作为条件进行查询  a和b 都是相等的判断那么c 可以走联合索引
>
> 因为联合索引是从左到右排序的  B+树中  a的索引排列有序  那么再按照第二个b的索引排也是有序的  相对于a 有序   再接着排c     如果索引查询中  a 没做查询条件或者是范围查询 那么后面跟的 b  和c  是走不了联合索引的
>
> 没有a作为第一个条件判断  后面都是走不了联合索引的  和  like使用  %作为开头索引匹配是一样的  如果like是%在后面  那么 就是按照正常字段排序然后匹配最后一位   如果在前面就只能全表扫描  对比

##### 155.redis持久化 redis常见的问题

> redis中的缓存雪崩
>
> 同一时间大量key过期  直接访问数据库   
>
> key过期时间设置随机值  避免同一时间过期
>
> 双缓存  一个缓存设置过期时间  一个缓存不设置过期时间  
>
> 如果一个缓存时间过期 访问未设置过期时间得缓存，没有再去访问数据库  再异步更新缓存  
>
> redis中的缓存穿透
>
> 大量不存在的key访问数据库  
>
> 设置布隆过滤器，把存在key放入bitmap中  如果不存在key访问直接拒绝  
>
> 在redis中 和数据库中都找不到的数据  在redis中缓存  空  过期时间设置5分钟
>
> redis中的缓存击穿
>
> 热点数据在redis中过期  并发情况下大量访问数据库
>
> 热点数据不设置过期时间
>
> 加锁  redis中加SetNX  
>
> 持久化   AOF +  RDB
>
> 

##### 156.String为什么不能修改

> 出于安全性考虑  string为java中最基本的引用数据类型  会存储一些密码之类的 安全性考虑string是不能修改的
>
> 线程安全  如果要修改当前string线程只能去创建新的string  对原有的string是不能修改的
>
> 性能   hasemap这种集合需要计算hasecode计算数据下标  string不可修改可以只是
>
> 计算一次  
>
> 节省空间  字符串常量  改变的话 引用的string还需要做改变

##### 157.StringBuffer、StringBuilder 的区别

> String是通过final修饰加priva不能修改  
>
> stringbuffer是加sy锁的线程安全  stringbuildre是线程不安全
>
> 但是stringbuilder效率高  适合操作多个string   stringbuffer适合多线程

##### 158.replace底层

##### 159.redis为什么这么快

> redis采用单线程 避免了多线程的CPU消耗  不会产生锁的资源占用  也不会产生死锁
>
> 写入内存  避免了磁盘IO的限制
>
> 采用多路复用IO  多个请求 经过一条线程处理   可以高效的处理请求 

##### 160.redis为什么是单线程

> 单线程实施维护成本低，redis是基于内存存储的  cpu不是redis的瓶颈  何况单线程效率已经非常高  没必要采用多线程   
>
> 单线程只是在处理网路请求的时候   持久化的时候redis还会fork子线程进行持久化

##### 161.谈谈你对数据库索引的理解

> 创建索引会生成B+数结构  索引的话是避免了数据库进行全表扫描  性能更高
>
> 因为B+树的结构是叶子节点存储的是数据 非叶子节点存储的索引信息  
>
> 通过索引准确定位到数据   B+树的层数更少  减少的磁盘的IO消耗  
>
> 叶子节点维护了一个双向链表  天然有序  可以更快的查询到数据
>
> 如果要进行全表扫描只需要  查询叶子节点上的信息就可以  
>
> 索引的话 对经常进行where条件查询的字段 能更快定位到数据 不要再做全表扫描
>
> 关联表  排序都可以使用到索引  尤其是排序  B+树天然有序  
>
> 索引的缺点的话
>
> 就是需要占用物理空间
>
> 维护索引需要时间

##### 162.mysql中索引失效的场景

> 索引失效的话  是一种情况是like查询%在前会导致索引失效
>
>  类型转换 计算排序 会导致索引失效  
>
> mysql认为全表扫描比索引要快的话 会全表扫描  索引失效
>
> 使用is not  null  isnull  会使索引失效
>
> 使用or 连接会使索引失效
>
> 使用！= <>  会使 索引失效
>
> select * 会使索引失效
>
> like % 开头会使索引失效
>
> 字符串不使用单引号  会使索引失效

##### 163.索引的优化手段有哪些

> 尽量使用复合索引而不是索引组合
>
> 不要使用select会导致回表
>
> 使用主键自增  避免页分裂
>
> 主键索引使用辅助索引尽量走覆盖索引 而不是回表
>
> 字符串使用单引号
>
> like不以%开头
>
> 不使用符号！= 或者<>
>
> where条件后面不加or
>
> 不使用is null  is not null

##### 164.redis的过期策略

> redis是采用定期删除 + 惰性删除
>
> 定期删除是没100ms随机检查key是否过期  不是全部key检查  会卡死  
>
> 惰性删除是使用key的时候就检查一下  过期了就删除 
>
> 定期删除 和惰性删除都过期的情况下  redis会有内存淘汰策略  

##### 165.mysql中四种存储引擎

> myisam
>
> mysql5.5之前的存储引擎  不支持事务操作  默认表锁 锁的粒度大  但是针对大量查询效率比较好
>
> innoDB
>
> mysql5.5之后的当前使用的储存引擎，支持事务  默认是行锁 锁的粒度小 并发能力强但是也容易产生死锁情况  会有安全日志文件数据恢复  
>
> momrry
>
> 数据是储存在内存中的  重启就会消失  默认存储引擎是哈希表  
>
> archive
>
> 针对大量插入操作效率高  查询效率低

##### 166.GC如何判断对象需要回收  怎么回收

> 如何发现需要回收的对象
>
> 节点计数法  被引用则加1  未被引用则-1  节点技术为0的时候则为需要回收的对象  
>
> 根节点寻找法   通过一个根节点去需要引用的对象再寻找这个节点的引用对象 多条路查找  剩下的没有连接的节点对象就是需要回收的对象 
>
> 如何回收垃圾
>
> 标记清除法  通过标计  直接进行清除   会产生大量内存碎片
>
> 标记整理法  标记 然后进行整理  把标记的垃圾对象向一端移动 移动过程中进行清除  
>
> 分代清理法

##### 167.Nginx中是怎么接受HTTP请求的

> Nginx通过多进程和非阻塞异步请求，通过主进程fork一个子进程去接受传递过来的请求，知道请求完成，
>
> 非阻塞异步请求，每个工作进程通过异步非阻塞方式，可以处理多个客户端请求，调用IO处理，不影响进程接受其他请求

##### 168.Nginx相较于tomcat的优势在什么地方

> Nginx更加轻量级  相较于tomacat占用更小的内存资源
>
> Nginx抗并发 Nginx是异步非阻塞式的 tomcat是阻塞式的 在高并发情况下，Nginx处理请求更高效
>
> Nginx 是异步非阻塞  tomcat是阻塞式的  Nginx多进程单线程    tomcat是多进程
>
> Nginx负载均衡  反向代理服务器