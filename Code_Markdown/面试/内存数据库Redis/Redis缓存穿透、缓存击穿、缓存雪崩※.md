### 缓存穿透
场景是：
- **查询根本不存在的数据**，使得请求直接抵达存储层
- 导致其负载过大，甚至宕机

解决方案：
1. **缓存空对象**。存储层未命中后，仍然将空值存入缓存层。再次访问该数据时，缓存层会直接返回空值。
2. **布隆过滤器**：将所有存在的key提前存入布隆过滤器，并将过滤器部署在缓存层前。请求访问缓存层之前，先通过过滤器拦截，请求的是不存在的key，则直接返回空值。

### 缓存击穿
**一份热点数据，它的访问量非常大**，在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。

解决方案：
1. **永不过期**。不设置过期时间，就不会出现上述问题了，即“物理”上的不过期。还可为每个value设置逻辑过期时间，当发现该值逻辑过期时，则使用单独线程重建缓存。
2. **加互斥锁**。对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据就被重建，其他线程就可以直接从缓存中取值。

### 缓存雪崩
场景：
- **由于某些原因，缓存层不能提供服务**，导致所有的请求直达存储层，造成存储层宕机。

解决方案：
1. **避免设置同时过期**：设置过期时间时，附加一个随机数，避免大量的key同时过期
2. **构建高可用的Redis缓存**：部署多个Redis实例，个别结点宕机，依然可以保持服务的整体可用
3. **构建多级缓存**：增加本地缓存，在存储层前面多加一级屏障，降低请求直达存储层的几率。
4. **启动限流和降级措施**：对存储层增加限流措施，当请求超过限制时，对其提供降级服务。