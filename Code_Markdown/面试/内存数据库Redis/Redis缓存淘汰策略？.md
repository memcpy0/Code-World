从高并发上来说：
直接操作缓存能够承受的请求是远远大于直接访问数据库的，因此可以考虑把数据库中的部分数据转移到缓存中去，**将用户的一部分请求会直接存储到缓存而不用经过数据库**。

从高性能上来说：
**用户第一次访问数据库中的某些数据，从硬盘上读取的过程比较慢**。将该用户访问的数据存在缓存中，**下一次再访问这些数据的时候就可以直接从缓存中获取了，速度很快**。如果数据库中的对应数据改变的之后，则会同步改变缓存中相应的数据。

---
当Redis占用内存超过最大限制（maxmemory）时，可采用如下策略（maxmemory-policy），淘汰一些数据，腾出空间继续提供读写服务：
- noeviction：对可能导致增大内存的命令返回错误（多数写命令，DEL除外）
- volatile-ttl：设置了过期时间的key中，选择剩余寿命TTL最短的key，将其淘汰
- volatile-lru：设置了过期时间的key中，选择最少使用的key（LRU），将其淘汰
- volatile-random：设置了过期时间的key中，随机选择一些key，将其淘汰
- allkeys-lru：在所有key中，选择最少使用的key，将其淘汰
- allkeys-random：在所有的key中，随机选择一些key，将其淘汰

LRU算法：
- 维护一个链表，用于顺序存储被访问过的key，在访问数据时，最新访问过的key将被移动到表头，最近访问的key在表头，最少访问的key在表尾。

Redis使用近似LRU算法：
- ==给每个key维护一个时间戳，淘汰时随机采样5个key，从中淘汰最旧的key==，如果还是超出内存限制，则继续随机采样来淘汰。
- 优点：比LRU算法节省内存，却可以取得非常近似的效果。
