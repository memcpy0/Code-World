场景：
修改时，经常需要先将数据读取到内存，在内存中修改后再存回去。在分布式应用中，可能多个经常同时执行上述操作，而读取和修改非原子操作，所以会产生冲突。增加分布式锁，可以解决此类问题。

分布式锁基本原理：类似同步锁，在多个线程能访问到的地方（这里是内存中），做一个标记，标识该数据的访问权限。
- 分布式锁：**在多个进程都能访问到的地方，做一个标记，标识该数据的访问权限**。

实现方式：
1. 把数据存到数据库中，基于数据库实现分布式锁。
2. **把数据放到Redis中**，基于Redis实现分布式锁。（用的比较多）
3. 把数据放到ZooKeeper中，基于ZooKeeper实现分布式锁。

Redis实现分布式锁的原则：
1. 安全属性：独享，任一时刻只有一个客户端持有锁。
2. 活性A：无死锁。即使持有锁的客户端崩溃或网络断了，锁仍然可以被获取。
3. 活性B：容错。只要大部分Redis节点都活着，客户端就可以获取和释放锁。

单个Redis实例实现分布式锁：
1. 获取锁使用命令：NX，仅在key不存在时才执行成功，存在则说明有人获取了锁；PX：设置锁的自动过期时间
```bash
SET resource_name my_random_value NX PX 30000
```
2. 通过lua脚本释放锁：
```lua
if redis.call("get", KEYS[1]) == ARGV[1] then
	return redis.call("del", KEYS[1])
else return 0 end
```
这样做（而非走Redis客户端命令）可以避免删除别的客户端获取成功的锁：A客户端加锁 -> A阻塞 -> 因超时释放锁 -> B加锁 -> A恢复 -> A释放锁，把B的锁释放了
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202304201854417.png)
