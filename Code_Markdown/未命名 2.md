MongoDB bin文件夹下没有mongo.exe解决方案
mongoDB 6.0版本之后。安装目录的bin目录下是没有mongo.exe文件的

在一些版本中，MongoDB中自带了MongoDB shell（也就是mongo.exe）。在之前的教程中也有使用到该功能。但是在某些版本中MongoDB shell已经不是自带的内容，需要另外下载安装MongoDB shell，本篇文章就是解决没有mongo的问题。
初始情况
这里小编安装的是mongoDB 6.0版本。可以看到安装目录的bin目录下没有mongo.exe文件。


下载
下载链接：https://www.mongodb.com/try/download/shell
MongoDB会自动检测你应下载的版本


操作
如果是下载到Windows（MSI）版本，即下载之后得到一个msi安装文件，根据这篇文章操作https://www.w3cschool.cn/mongodb/mongodb_shell_install.html

如果下载的是压缩包，则解压了放到与bin文件同级的地方



启动这个文件即可执行MongoDB ，如果是默认使用本地的，则直接回车即可
如果是需要使用非本地的则根据相应的IP端口号进行填写

可将该文件配置到系统变量Path中，下次打开直接输入mongosh.exe即可运行


mongod和mongos之间的确切区别是什么
MongoDB包中的核心组件是：mongod - 核心数据库进程; mongos - 分片群集的控制器和查询路由器;和mongo交互式的MongoDB Shell。
————————————————
版权声明：本文为CSDN博主「代码匪徒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/munangs/article/details/129613276
,图灵课堂Fox老师聚合操作示例1统计每个分类的book文档数量标签的热度排行，标签的热度则按其关联book文档的收藏数（favCount）来计算1.$match阶段：用于过滤favCount=0的文档。2.$unwind阶段：用于将标签数组进行展开，这样一个包含3个标签的文档会被拆解为3个条目。3.$group阶段：对拆解后的文档进行分组计算，$sum："$favCount"表示按favCount字段进行累加。4.$sort阶段：接收分组计算的输出，按total得分进行排序。统计book文档收藏数[0,10),[10,60),[60,80),[80,100),[100,+∞）https://docs.mongodb.com/manual/reference/operator/aggregation/bucket/localField:"customerCode",foreignField:"customerCode",as:"curstomer"}},{$lookup:{from:"orderItem",localField:"orderId",foreignField:"orderId",as:"orderItem"}}])db.books.aggregate([{$group:{_id:"$type",total:{$sum:1}}},{$sort:{total:-1}}])db.books.aggregate([{$match:{favCount:{$gt:0}}},{$unwind:"$tag"},{$group:{_id:"$tag",total:{$sum:"$favCount"}}},{$sort:{total:-1}}])db.books.aggregate([{$bucket:{groupBy:"$favCount",boundaries:[0,10,60,80,100],default:"other",output:{"count":{$sum:1}}}}])图灵课堂Fox老师聚合操作示例2导入邮政编码数据集:https://media.mongodb.org/zips.json使用mongoimport工具导入数据（https://www.mongodb.com/try/download/database-tools）mongoimport-h192.168.65.204-daggdemo-ufox-pfox--authenticationDatabase=admin-czips--fileD:\ProgramData\mongodb\import\zips.jsonh,--host：代表远程连接的数据库地址，默认连接本地Mongo数据库；--port：代表远程连接的数据库的端口，默认连接的远程端口27017；-u,--username：代表连接远程数据库的账号，如果设置数据库的认证，需要指定用户账号；-p,--password：代表连接数据库的账号对应的密码；-d,--db：代表连接的数据库；-c,--collection：代表连接数据库中的集合；-f,--fields：代表导入集合中的字段；--type：代表导入的文件类型，包括csv和json,tsv文件，默认json格式；--file：导入的文件名称--headerline：导入csv文件时，指明第一行是列名，不需要导入；返回人口超过1000万的州db.zips.aggregate([{$group:{_id:"$state",totalPop:{$sum:"$pop"}}},{$match:{totalPop:{$gt:10*1000*1000}}}])这个聚合操作的等价SQL是：SELECTstate,SUM(pop)AStotalPopFROMzipsGROUPBYstateHAVINGtotalPop>=(10*1000*1000)返回各州平均城市人口db.zips.aggregate([{$group:{_id:{state:"$state",city:"$city"},cityPop:{$sum:"$pop"}}},{$group:{_id:"$_id.state",avgCityPop:{$avg:"$cityPop"}}},{$sort:{avgCityPop:-1}}])按州返回最大和最小的城市db.zips.aggregate([{$group:{图灵课堂Fox老师_id:{state:"$state",city:"$city"},pop:{$sum:"$pop"}}},{$sort:{pop:1}},{$group:{_id:"$_id.state",biggestCity:{$last:"$_id.city"},biggestPop:{$last:"$pop"},smallestCity:{$first:"$_id.city"},smallestPop:{$first:"$pop"}}},{$project:{_id:0,state:"$_id",biggestCity:{name:"$biggestCity",pop:"$biggestPop"},smallestCity:{name:"$smallestCity",pop:"$smallestPop"}}},{$sort:{state:1}}])5.3MapReduceMapReduce操作将大量的数据处理工作拆分成多个线程并行处理，然后将结果合并在一起。MongoDB提供的Map-Reduce非常灵活，对于大规模数据分析也相当实用。MapReduce具有两个阶段：1.将具有相同Key的文档数据整合在一起的map阶段2.组合map操作的结果进行统计输出的reduce阶段MapReduce的基本语法db.collection.mapReduce(function(){emit(key,value);},//map函数function(key,values){returnreduceFunction},//reduce函数{out:,query:,sort:,limit:,finalize:,scope:,jsMode:,verbose:,bypassDocumentValidation:})map，将数据拆分成键值对，交给reduce函数reduce，根据键将值做统计运算out，可选，将结果汇入指定表quey，可选筛选数据的条件，筛选的数据送入mapsort，排序完后，送入map图灵课堂Fox老师limit，限制送入map的文档数finalize，可选，修改reduce的结果后进行输出scope，可选，指定map、reduce、finalize的全局变量jsMode，可选，默认false。在mapreduce过程中是否将数据转换成bson格式。verbose，可选，是否在结果中显示时间，默认falsebypassDocmentValidation，可选，是否略过数据校验统计type为travel的不同作者的book文档收藏数db.books.mapReduce(function(){emit(this.author.name,this.favCount)},function(key,values){returnArray.sum(values)},{query:{type:"travel"},out:"books_favCount"})5.4Springboot中整合MongoDB进行聚合操作MongoTemplate提供了aggregate方法来实现对数据的聚合操作。图灵课堂Fox老师基于聚合管道mongodb提供的可操作的内容：基于聚合操作Aggregation.group，mongodb提供可选的表达式示例：以聚合管道示例2为例实体结构@Document("zips")@Data@AllArgsConstructor@NoArgsConstructorpublicclassZips{@Id//映射文档中的_idprivateStringid;@FieldprivateStringcity;@FieldprivateDouble[]loc;@Field图灵课堂Fox老师}privateIntegerpop;@FieldprivateStringstate;返回人口超过1000万的州db.zips.aggregate([{$group:{_id:"$state",totalPop:{$sum:"$pop"}}},{$match:{totalPop:{$gt:10*1000*1000}}}])java实现@Testpublicvoidtest(){//$groupGroupOperationgroupOperation=Aggregation.group("state").sum("pop").as("totalPop");//$matchMatchOperationmatchOperation=Aggregation.match(Criteria.where("totalPop").gte(10*1000*1000));//按顺序组合每一个聚合步骤TypedAggregationtypedAggregation=Aggregation.newAggregation(Zips.class,groupOperation,matchOperation);}//执行聚合操作,如果不使用Map，也可以使用自定义的实体类来接收数据AggregationResultsaggregationResults=mongoTemplate.aggregate(typedAggregation,Map.class);//取出最终结果ListmappedResults=aggregationResults.getMappedResults();for(Mapmap:mappedResults){System.out.println(map);}返回各州平均城市人口db.zips.aggregate([{$group:{_id:{state:"$state",city:"$city"},cityPop:{$sum:"$pop"}}},{$group:{_id:"$_id.state",avgCityPop:{$avg:"$cityPop"}}},{$sort:{avgCityPop:-1}}])java实现@Testpublicvoidtest2(){//$group图灵课堂Fox老师按州返回最大和最小的城市java实现GroupOperationgroupOperation=Aggregation.group("state","city").sum("pop").as("cityPop");//$groupGroupOperationgroupOperation2=Aggregation.group("_id.state").avg("cityPop").as("avgCityPop");//$sortSortOperationsortOperation=Aggregation.sort(Sort.Direction.DESC,"avgCityPop");//按顺序组合每一个聚合步骤TypedAggregationtypedAggregation=Aggregation.newAggregation(Zips.class,groupOperation,groupOperation2,sortOperation);//执行聚合操作,如果不使用Map，也可以使用自定义的实体类来接收数据AggregationResultsaggregationResults=mongoTemplate.aggregate(typedAggregation,Map.class);//取出最终结果ListmappedResults=aggregationResults.getMappedResults();for(Mapmap:mappedResults){System.out.println(map);}}db.zips.aggregate([{$group:{_id:{state:"$state",city:"$city"},pop:{$sum:"$pop"}}},{$sort:{pop:1}},{$group:{_id:"$_id.state",biggestCity:{$last:"$_id.city"},biggestPop:{$last:"$pop"},smallestCity:{$first:"$_id.city"},smallestPop:{$first:"$pop"}}},{$project:{_id:0,state:"$_id",biggestCity:{name:"$biggestCity",pop:"$biggestPop"},smallestCity:{name:"$smallestCity",pop:"$smallestPop"}}},{$sort:{state:1}}])@Test图灵课堂Fox老师6.视图MongoDB视图是一个可查询的对象，它的内容由其他集合或视图上的聚合管道定义。MongoDB不会将视图内容持久化到磁盘。当客户端查询视图时，视图的内容按需计算。MongoDB可以要求客户端具有查询视图的权限。MongoDB不支持对视图进行写操作。publicvoidtest3(){//$groupGroupOperationgroupOperation=Aggregation.group("state","city").sum("pop").as("pop");//$sortSortOperationsortOperation=Aggregation.sort(Sort.Direction.ASC,"pop");//$groupGroupOperationgroupOperation2=Aggregation.group("_id.state").last("_id.city").as("biggestCity").last("pop").as("biggestPop").first("_id.city").as("smallestCity").first("pop").as("smallestPop");//$projectProjectionOperationprojectionOperation=Aggregation.project("state","biggestCity","smallestCity").and("_id").as("state").andExpression("{name:\"$biggestCity\",pop:\"$biggestPop\"}").as("biggestCity").andExpression("{name:\"$smallestCity\",pop:\"$smallestPop\"}").as("smallestCity").andExclude("_id");//$sortSortOperationsortOperation2=Aggregation.sort(Sort.Direction.ASC,"state");//按顺序组合每一个聚合步骤TypedAggregationtypedAggregation=Aggregation.newAggregation(Zips.class,groupOperation,sortOperation,groupOperation2,projectionOperation,sortOperation2);//执行聚合操作,如果不使用Map，也可以使用自定义的实体类来接收数据AggregationResultsaggregationResults=mongoTemplate.aggregate(typedAggregation,Map.class);//取出最终结果ListmappedResults=aggregationResults.getMappedResults();for(Mapmap:mappedResults){System.out.println(map);}}图灵课堂Fox老师作用：数据抽象保护敏感数据的一种方法将敏感数据投影到视图之外只读结合基于角色的授权，可按角色访问信息数据准备varorders=newArray();varshipping=newArray();varaddresses=["广西省玉林市","湖南省岳阳市","湖北省荆州市","甘肃省兰州市","吉林省松原市","江西省景德镇","辽宁省沈阳市","福建省厦门市","广东省广州市","北京市朝阳区"];for(vari=10000;i<20000;i++){varorderNo=i+Math.random().toString().substr(2,5);orders[i]={orderNo:orderNo,userId:i,price:Math.round(Math.random()*10000)/100,qty:Math.floor(Math.random()*10)+1,orderTime:newDate(newDate().setSeconds(Math.floor(Math.random()*10000)))};varaddress=addresses[Math.floor(Math.random()*10)];shipping[i]={orderNo:orderNo,address:address,recipienter:"Wilson",province:address.substr(0,3),city:address.substr(3,3)}}db.order.insert(orders);db.shipping.insert(shipping);6.1创建视图基本语法格式db.createView("","",[],{"collation":{}})viewName:必须，视图名称source:必须，数据源，集合/视图[]:可选，一组管道collation可选，排序规则单个集合创建视图假设现在查看当天最高的10笔订单视图，例如需要实时显示金额最高的订单db.createView("orderInfo","order",[//视图名称//数据源//筛选符合条件的订单，大于当天，这里要注意时区{$match:{"orderTime":{$gte:ISODate("2022-01-26T00:00:00.000Z")}}图灵课堂Fox老师},])//按金额倒序{$sort:{"price":-1}},//限制10个文档{$limit:10},//选择要显示的字段//0:排除字段，若字段上使用（_id除外），就不能有其他包含字段//1:包含字段{$project:{_id:0,orderNo:1,price:1,orderTime:1}}视图创建成功后可以直接使用视图查询数据多个集合创建视图跟单个是集合是一样，只是多了$lookup连接操作符，视图根据管道最终结果显示，所以可以关联多个集合db.orderDetail.drop()db.createView("orderDetail","order",[{$lookup:{from:"shipping",localField:"orderNo",foreignField:"orderNo",as:"shipping"}},{$project:{"orderNo":1,"price":1,"shipping.address":1}}])图灵课堂Fox老师6.2修改视图db.runCommand({collMod:"orderInfo",viewOn:"order",pipeline:[{$match:{"orderTime":{$gte:ISODate("2020-04-13T16:00:00.000Z")}}},{$sort:{"price":-1}},{$limit:10},//增加qty{$project:{_id:0,orderNo:1,price:1,qty:1,orderTime:1}}]})6.3删除视图db.orderInfo.drop();7.MongoDB索引图灵课堂Fox老师7.1索引介绍索引是一种用来快速查询数据的数据结构。B+Tree就是一种常用的数据库索引数据结构，MongoDB采用B+Tree做索引，索引创建在colletions上。MongoDB不使用索引的查询，先扫描所有的文档，再匹配符合条件的文档。使用索引的查询，通过索引找到文档，使用索引能够极大的提升查询效率。MongoDB索引数据结构思考：MongoDB索引数据结构是B-Tree还是B+Tree?B-Tree说法来源于官方文档，然后就导致了分歧：有人说MongoDB索引数据结构使用的是B-Tree,有的人又说是B+Tree。MongoDB官方文档：https://docs.mongodb.com/manual/indexes/MongoDBindexesuseaB-treedatastructure.WiredTiger官方文档：https://source.wiredtiger.com/3.0.0/tune_page_size_and_comp.htmlWiredTigermaintainsatable'sdatainmemoryusingadatastructurecalledaB+Treetobespecific),referringtothenodesofaB-Treeaspages.Internalpagescarryonlykeys.Theleafpagesstorebothkeysandvalues.B-Tree(参考数据结构网站：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html索引的分类按照索引包含的字段数量，可以分为单键索引和组合索引（或复合索引）。按照索引字段的类型，可以分为主键索引和非主键索引。图灵课堂Fox老师按照索引节点与物理记录的对应方式来分，可以分为聚簇索引和非聚簇索引，其中聚簇索引是指索引节点上直接包含了数据记录，而后者则仅仅包含一个指向数据记录的指针。按照索引的特性不同，又可以分为唯一索引、稀疏索引、文本索引、地理空间索引等与大多数数据库一样，MongoDB支持各种丰富的索引类型，包括单键索引、复合索引，唯一索引等一些常用的结构。由于采用了灵活可变的文档类型，因此它也同样支持对嵌套字段、数组进行索引。通过建立合适的索引，我们可以极大地提升数据的检索速度。在一些特殊应用场景，MongoDB还支持地理空间索引、文本检索索引、TTL索引等不同的特性。7.2索引操作创建索引创建索引语法格式Key值为你要创建的索引字段，1按升序创建索引，-1按降序创建索引ParameterTypeDescriptionbackgroundBoolean建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加"background"可选参数。"background"默认值为false。uniqueBoolean建立的索引是否唯一。指定为true创建唯一索引。默认值为false.namestring索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。dropDupsBoolean3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定true创建唯一索引。默认值为false.sparseBoolean对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为false.expireAfterSecondsinteger指定一个以秒为单位的数值，完成TTL设定，设定集合的生存时间。vindexversion索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。weightsdocument索引权重值，数值在1到99,999之间，表示该索引相对于其他索引字段的得分权重。default_languagestring对于文本索引，该参数决定了停用词及词干和词器的规则的列表。默认为英语language_overridestring对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为language.可选参数列表如下：注意：3.0.0版本前创建索引方法为db.collection.ensureIndex()db.collection.createIndex(keys,options)图灵课堂Fox老师#创建索引后台执行db.values.createIndex({open:1,close:1},{background:true})#创建唯一索引db.values.createIndex({title:1},{unique:true})查看索引#查看索引信息db.books.getIndexes()#查看索引键db.books.getIndexKeys()查看索引占用空间db.collection.totalIndexSize([is_detail])is_detail：可选参数，传入除0或false外的任意数据，都会显示该集合中每个索引的大小及总大小。如果传入0或false则只显示该集合中所有索引的总大小。默认值为false。删除索引#删除集合指定索引db.col.dropIndex("索引名称")#删除集合所有索引db.col.dropIndexes()7.3索引类型单键索引（SingleFieldIndexes）在某一个特定的字段上建立索引mongoDB在ID上建立了唯一的单键索引,所以经常会使用id来进行查询；在索引字段上进行精确匹配、排序以及范围查找都会使用此索引图灵课堂Fox老师db.books.createIndex({title:1})对内嵌文档字段创建索引：复合索引（CompoundIndex）复合索引是多个字段组合而成的索引，其性质和单字段索引类似。但不同的是，复合索引中字段的顺序、字段的升降序对查询性能有直接的影响，因此在设计复合索引时则需要考虑不同的查询场景。图灵课堂Fox老师db.books.createIndex({type:1,favCount:1})多键索引（MultikeyIndex）在数组的属性上建立索引。针对这个数组的任意值的查询都会定位到这个文档,既多个索引入口或者键值引用同一个文档准备inventory集合：db.inventory.insertMany([{_id:5,type:"food",item:"aaa",ratings:[5,8,9]},{_id:6,type:"food",item:"bbb",ratings:[5,9]},{_id:7,type:"food",item:"ccc",ratings:[9,5,8]},{_id:8,type:"food",item:"ddd",ratings:[9,5]},{_id:9,type:"food",item:"eee",ratings:[5,9,5]}])创建多键索引db.inventory.createIndex({ratings:1})多键索引很容易与复合索引产生混淆，复合索引是多个字段的组合，而多键索引则仅仅是在一个字段上出现了多键（multikey）。而实质上，多键索引也可以出现在复合字段上#创建复合多键索引db.inventory.createIndex({item:1,ratings:1})图灵课堂Fox老师注意：MongoDB并不支持一个复合索引中同时出现多个数组字段嵌入文档的索引数组db.inventory.insertMany([{_id:1,item:"abc",stock:[{size:"S",color:"red",quantity:25},{size:"S",color:"blue",quantity:10},{size:"M",color:"blue",quantity:50}]},{_id:2,item:"def",stock:[{size:"S",color:"blue",quantity:20},{size:"M",color:"blue",quantity:5},{size:"M",color:"black",quantity:10},{size:"L",color:"red",quantity:2}]},{_id:3,item:"ijk",stock:[{size:"M",color:"blue",quantity:15},{size:"L",color:"blue",quantity:100},{size:"L",color:"red",quantity:25}]}])在包含嵌套对象的数组字段上创建多键索引db.inventory.createIndex({"stock.size":1,"stock.quantity":1})地理空间索引（GeospatialIndex）在移动互联网时代，基于地理位置的检索（LBS）功能几乎是所有应用系统的标配。MongoDB为地理空间检索提供了非常方便的功能。地理空间索引（2dsphereindex）就是专门用于实现位置检索的一种特殊索引。图灵课堂Fox老师案例：MongoDB如何实现“查询附近商家"？假设商家的数据模型如下：db.restaurant.insert({restaurantId:0,restaurantName:"兰州牛肉面",location:{type:"Point",coordinates:[-73.97,40.77]}})创建一个2dsphere索引db.restaurant.createIndex({location:"2dsphere"})查询附近10000米商家信息db.restaurant.find({location:{$near:{$geometry:{type:"Point",coordinates:[-73.88,40.78]},$maxDistance:10000}}})$near查询操作符，用于实现附近商家的检索，返回数据结果会按距离排序。$geometry操作符用于指定一个GeoJSON格式的地理空间对象，type=Point表示地理坐标点，coordinates则是用户当前所在的经纬度位置；$maxDistance限定了最大距离，单位是米。全文索引（TextIndexes）MongoDB支持全文检索功能，可通过建立文本索引来实现简易的分词检索。db.reviews.createIndex({comments:"text"})$text操作符可以在有textindex的集合上执行文本检索。$text将会使用空格和标点符号作为分隔符对检索字符串进行分词，并且对检索字符串中所有的分词结果进行一个逻辑上的OR操作。全文索引能解决快速文本查找的需求，比如有一个博客文章集合，需要根据博客的内容来快速查找，则可以针对博客内容建立文本索引。案例数据准备图灵课堂Fox老师db.stores.insert([{_id:1,name:"JavaHut",description:"Coffeeandcakes"},{_id:2,name:"BurgerBuns",description:"Gourmethamburgers"},{_id:3,name:"CoffeeShop",description:"Justcoffee"},{_id:4,name:"ClothesClothesClothes",description:"Discountclothing"},{_id:5,name:"JavaShopping",description:"Indonesiangoods"}])创建name和description的全文索引db.stores.createIndex({name:"text",description:"text"})测试通过$text操作符来查寻数据中所有包含“coffee”,”shop”，“java”列表中任何词语的商店db.stores.find({$text:{$search:"javacoffeeshop"}})MongoDB的文本索引功能存在诸多限制，而官方并未提供中文分词的功能，这使得该功能的应用场景十分受限。Hash索引（HashedIndexes）不同于传统的B-Tree索引,哈希索引使用hash函数来创建索引。在索引字段上进行精确匹配,但不支持范围查询,不支持多键hash；Hash索引上的入口是均匀分布的,在分片集合中非常有用；db.users.createIndex({username:'hashed'})通配符索引（WildcardIndexes）MongoDB的文档模式是动态变化的，而通配符索引可以建立在一些不可预知的字段上，以此实现查询的加速。MongoDB4.2引入了通配符索引来支持对未知或任意字段的查询。案例准备商品数据，不同商品属性不一样db.products.insert([{"product_name":"SpyCoat","product_attributes":{"material":["Tweed","Wool","Leather"],"size":{"length":72,"units":"inches"}}},{"product_name":"SpyPen","product_attributes":{"colors":["Blue","Black"],图灵课堂Fox老师"secret_feature":{"name":"laser","power":"1000","units":"watts",}}},{"product_name":"SpyBook"}])创建通配符索引db.products.createIndex({"product_attributes.$**":1})测试通配符索引可以支持任意单字段查询product_attributes或其嵌入字段：db.products.find({"product_attributes.size.length":{$gt:60}})db.products.find({"product_attributes.material":"Leather"})db.products.find({"product_attributes.secret_feature.name":"laser"})注意事项通配符索引不兼容的索引类型或属性通配符索引是稀疏的，不索引空字段。因此，通配符索引不能支持查询字段不存在的文档。图灵课堂Fox老师#通配符索引不能支持以下查询db.products.find({"product_attributes":{$exists:false}})db.products.aggregate([{$match:{"product_attributes":{$exists:false}}}])通配符索引为文档或数组的内容生成条目，而不是文档/数组本身。因此通配符索引不能支持精确的文档/数组相等匹配。通配符索引可以支持查询字段等于空文档{}的情况。#通配符索引不能支持以下查询:db.products.find({"product_attributes.colors":["Blue","Black"]})db.products.aggregate([{$match:{"product_attributes.colors":["Blue","Black"]}}])7.4索引属性唯一索引（UniqueIndexes）在现实场景中，唯一性是很常见的一种索引约束需求，重复的数据记录会带来许多处理上的麻烦，比如订单的编号、用户的登录名等。通过建立唯一性索引，可以保证集合中文档的指定字段拥有唯一值。#创建唯一索引db.values.createIndex({title:1},{unique:true})#复合索引支持唯一性约束db.values.createIndex({title:1，type:1},{unique:true})#多键索引支持唯一性约束db.inventory.createIndex({ratings:1},{unique:true})唯一性索引对于文档中缺失的字段，会使用null值代替，因此不允许存在多个文档缺失索引字段的情况。对于分片的集合，唯一性约束必须匹配分片规则。换句话说，为了保证全局的唯一性，分片键必须作为唯一性索引的前缀字段。部分索引（PartialIndexes）部分索引仅对满足指定过滤器表达式的文档进行索引。通过在一个集合中为文档的一个子集建立索引，部分索引具有更低的存储需求和更低的索引创建和维护的性能成本。3.2新版功能。部分索引提供了稀疏索引功能的超集，应该优先于稀疏索引。db.restaurants.createIndex({cuisine:1,name:1},{partialFilterExpression:{rating:{$gt:5}}})partialFilterExpression选项接受指定过滤条件的文档:等式表达式(例如:field:value或使用$eq操作符)$exists:true$gt，$gte，$lt，$lte$type图灵课堂Fox老师顶层的$and#符合条件，使用索引db.restaurants.find({cuisine:"Italian",rating:{$gte:8}})#不符合条件，不能使用索引db.restaurants.find({cuisine:"Italian"})案例1restaurants集合数据db.restaurants.insert({"_id":ObjectId("5641f6a7522545bc535b5dc9"),"address":{"building":"1007","coord":[-73.856077,40.848447],"street":"MorrisParkAve","zipcode":"10462"},"borough":"Bronx","cuisine":"Bakery","rating":{"date":ISODate("2014-03-03T00:00:00Z"),"grade":"A","score":2},"name":"MorrisParkBakeShop","restaurant_id":"30075445"})创建索引db.restaurants.createIndex({borough:1,cuisine:1},{partialFilterExpression:{'rating.grade':{$eq:"A"}}})测试db.restaurants.find({borough:"Bronx",'rating.grade':"A"})db.restaurants.find({borough:"Bronx",cuisine:"Bakery"})唯一约束结合部分索引使用导致唯一约束失效的问题注意：如果同时指定了partialFilterExpression和唯一约束，那么唯一约束只适用于满足筛选器表达式的文档。如果文档不满足筛选条件，那么带有惟一约束的部分索引不会阻止插入不满足惟一约束的文档。案例2users集合数据准备图灵课堂Fox老师db.users.insertMany([{username:"david",age:29},{username:"amanda",age:35},{username:"rajiv",age:57}])创建索引，指定username字段和部分过滤器表达式age:{$gte:21}的唯一约束。db.users.createIndex({username:1},{unique:true,partialFilterExpression:{age:{$gte:21}}})测试索引防止了以下文档的插入，因为文档已经存在，且指定的用户名和年龄字段大于21:db.users.insertMany([{username:"david",age:27},{username:"amanda",age:25},{username:"rajiv",age:32}])但是，以下具有重复用户名的文档是允许的，因为唯一约束只适用于年龄大于或等于21岁的文档。db.users.insertMany([{username:"david",age:20},{username:"amanda"},{username:"rajiv",age:null}])稀疏索引（SparseIndexes）索引的稀疏属性确保索引只包含具有索引字段的文档的条目，索引将跳过没有索引字段的文档。特性：只对存在字段的文档进行索引（包括字段值为null的文档）#不索引不包含xmpp_id字段的文档db.addresses.createIndex({"xmpp_id":1},{sparse:true})如果稀疏索引会导致查询和排序操作的结果集不完整，MongoDB将不会使用该索引，除非hint()明确指定索引。案例1数据准备db.scores.insertMany([{"userid":"newbie"},{"userid":"abby","score":82},{"userid":"nina","score":90}])图灵课堂Fox老师创建稀疏索引db.scores.createIndex({score:1},{sparse:true})测试#使用稀疏索引db.scores.find({score:{$lt:90}})#即使排序是通过索引字段，MongoDB也不会选择稀疏索引来完成查询，以返回完整的结果db.scores.find().sort({score:-1})#要使用稀疏索引，使用hint()显式指定索引db.scores.find().sort({score:-1}).hint({score:1})同时具有稀疏性和唯一性的索引可以防止集合中存在字段值重复的文档，但允许不包含此索引字段的文档插入。案例2#创建具有唯一约束的稀疏索引db.scores.createIndex({score:1},{sparse:true,unique:true})测试这个索引将允许插入具有唯一的分数字段值或不包含分数字段的文档。因此，给定scores集合中的现有文档，索引允许以下插入操作:db.scores.insertMany([{"userid":"AAAAAAA","score":43},{"userid":"BBBBBBB","score":34},{"userid":"CCCCCCC"},{"userid":"CCCCCCC"}])索引不允许添加下列文件，因为已经存在评分为82和90的文件：db.scores.insertMany([{"userid":"AAAAAAA","score":82},{"userid":"BBBBBBB","score":90}])TTL索引（TTLIndexes）在一般的应用系统中，并非所有的数据都需要永久存储。例如一些系统事件、用户消息等，这些数据随着时间的推移，其重要程度逐渐降低。更重要的是，存储这些大量的历史数据需要花费较高的成本，因此项目中通常会对过期且不再使用的数据进行老化处理。通常的做法如下：方案一：为每个数据记录一个时间戳，应用侧开启一个定时器，按时间戳定期删除过期的数据。图灵课堂Fox老师方案二：数据按日期进行分表，同一天的数据归档到同一张表，同样使用定时器删除过期的表。对于数据老化，MongoDB提供了一种更加便捷的做法：TTL（TimeToLive）索引。TTL索引需要声明在一个日期类型的字段中，TTL索引是特殊的单字段索引，MongoDB可以使用它在一定时间或特定时钟时间后自动从集合中删除文档。#创建TTL索引，TTL值为3600秒db.eventlog.createIndex({"lastModifiedDate":1},{expireAfterSeconds:3600})对集合创建TTL索引之后，MongoDB会在周期性运行的后台线程中对该集合进行检查及数据清理工作。除了数据老化功能，TTL索引具有普通索引的功能，同样可以用于加速数据的查询。TTL索引不保证过期数据会在过期后立即被删除。文档过期和MongoDB从数据库中删除文档的时间之间可能存在延迟。删除过期文档的后台任务每60秒运行一次。因此，在文档到期和后台任务运行之间的时间段内，文档可能会保留在集合中。案例数据准备db.log_events.insertOne({"createdAt":newDate(),"logEvent":2,"logMessage":"Success!"})创建TTL索引db.log_events.createIndex({"createdAt":1},{expireAfterSeconds:20})可变的过期时间TTL索引在创建之后，仍然可以对过期时间进行修改。这需要使用collMod命令对索引的定义进行变更db.runCommand({collMod:"log_events",index:{keyPattern:{createdAt:1},expireAfterSeconds:600}})图灵课堂Fox老师使用约束TTL索引的确可以减少开发的工作量，而且通过数据库自动清理的方式会更加高效、可靠，但是在使用TTL索引时需要注意以下的限制：TTL索引只能支持单个字段，并且必须是非_id字段。TTL索引不能用于固定集合。TTL索引无法保证及时的数据老化，MongoDB会通过后台的TTLMonitor定时器来清理老化数据，默认的间隔时间是1分钟。当然如果在数据库负载过高的情况下，TTL的行为则会进一步受到影响。TTL索引对于数据的清理仅仅使用了remove命令，这种方式并不是很高效。因此TTLMonitor在运行期间对系统CPU、磁盘都会造成一定的压力。相比之下，按日期分表的方式操作会更加高效。隐藏索引（HiddenIndexes）隐藏索引对查询规划器不可见，不能用于支持查询。通过对规划器隐藏索引，用户可以在不实际删除索引的情况下评估删除索引的潜在影响。如果影响是负面的，用户可以取消隐藏索引，而不必重新创建已删除的索引。4.4新版功能。创建隐藏索引db.restaurants.createIndex({borough:1},{hidden:true});#隐藏现有索引db.restaurants.hideIndex({borough:1});db.restaurants.hideIndex("索引名称")#取消隐藏索引db.restaurants.unhideIndex({borough:1});db.restaurants.unhideIndex("索引名称");案例db.scores.insertMany([{"userid":"newbie"},{"userid":"abby","score":82},{"userid":"nina","score":90}])创建隐藏索引db.scores.createIndex({userid:1},{hidden:true});查看索引信息db.scores.getIndexes()索引属性hidden只在值为true时返回图灵课堂Fox老师测试#不使用索引db.scores.find({userid:"abby"}).explain()#取消隐藏索引db.scores.unhideIndex({userid:1});#使用索引db.scores.find({userid:"abby"}).explain()7.5索引使用建议1.为每一个查询建立合适的索引这个是针对于数据量较大比如说超过几十上百万（文档数目）数量级的集合。如果没有索引MongoDB需要把所有的Document从盘上读到内存，这会对MongoDB服务器造成较大的压力并影响到其他请求的执行。2.创建合适的复合索引，不要依赖于交叉索引如果你的查询会使用到多个字段，MongoDB有两个索引技术可以使用：交叉索引和复合索引。交叉索引就是针对每个字段单独建立一个单字段索引，然后在查询执行时候使用相应的单字段索引进行索引交叉而得到查询结果。交叉索引目前触发率较低，所以如果你有一个多字段查询的时候，建议使用复合索引能够保证索引正常的使用。#查找所有年龄小于30岁的深圳市马拉松运动员db.athelets.find({sport:"marathon",location:"sz",age:{$lt:30}}})#创建复合索引db.athelets.createIndex({sport:1,location:1,age:1})3.复合索引字段顺序：匹配条件在前，范围条件在后（EqualityFirst,RangeAfter）图灵课堂Fox老师前面的例子，在创建复合索引时如果条件有匹配和范围之分，那么匹配条件（sport:“marathon”)应该在复合索引的前面。范围条件(age:<30)字段应该放在复合索引的后面。4.尽可能使用覆盖索引（CoveredIndex）5.建索引要在后台运行在对一个集合创建索引时，该集合所在的数据库将不接受其他读写操作。对大数据量的集合建索引，建议使用后台运行选项{background:true}7.6explain执行计划详解通常我们需要关心的问题：查询是否使用了索引索引是否减少了扫描的记录数量是否存在低效的内存排序MongoDB提供了explain命令，它可以帮助我们评估指定查询模型（querymodel）的执行计划，根据实际情况进行调整，然后提高查询效率。explain()方法的形式如下:db.collection.find().explain()verbose可选参数，表示执行计划的输出模式，默认queryPlanner模式名字描述queryPlannerexectionStatsallPlansExecutionqueryPlanner执行计划的详细信息，包括查询计划、集合信息、查询条件、最佳执行计划、查询方式和MongoDB服务信息等最佳执行计划的执行情况和被拒绝的计划等信息选择并执行最佳执行计划，并返回最佳执行计划和其他执行计划的执行情况#未创建title的索引db.books.find({title:"book-1"}).explain("queryPlanner")图灵课堂Fox老师字段名称描述plannerVersionnamespace执行计划的版本查询的集合indexFilterSetparsedQuery是否使用索引查询条件winningPlanstage最佳执行计划查询方式filterdirection过滤条件查询顺序rejectedPlansserverInfoexecutionStats拒绝的执行计划mongodb服务器信息executionStats模式的返回信息中包含了queryPlanner模式的所有字段，并且还包含了最佳执行计划的执行情况图灵课堂Fox老师#创建索引db.books.createIndex({title:1})db.books.find({title:"book-1"}).explain("executionStats")图灵课堂Fox老师图灵课堂Fox老师图灵课堂Fox老师字段名称描述winningPlan.inputStage用来描述子stage，并且为其父stage提供文档和索引关键字winningPlan.inputStage.stage子查询方式winningPlan.inputStage.keyPattern所扫描的index内容winningPlan.inputStage.indexName索引名winningPlan.inputStage.isMultiKey是否是Multikey。如果索引建立在array上，将是trueexecutionStats.executionSuccess是否执行成功executionStats.nReturned返回的个数executionStats.executionTimeMillis这条语句执行时间executionStats.executionStages.executionTimeMillisEstimate检索文档获取数据的时间executionStats.executionStages.inputStage.executionTimeMillisEstimate扫描获取数据的时间executionStats.totalKeysExamined索引扫描次数executionStats.totalDocsExamined文档扫描次数executionStats.executionStages.isEOF是否到达steam结尾，1或者true代表已到达结尾executionStats.executionStages.works工作单元数，一个查询会分解成小的工作单元executionStats.executionStages.advanced优先返回的结果数executionStats.executionStages.docsExamined文档检查数allPlansExecutionallPlansExecution返回的信息包含executionStats模式的内容，且包含allPlansExecution:[]块"allPlansExecution":[{"nReturned":,"executionTimeMillisEstimate":,"totalKeysExamined":,"totalDocsExamined":,"executionStages":{"stage":,"nReturned":,"executionTimeMillisEstimate":,...}}图灵课堂Fox老师状态描述COLLSCAN全表扫描IXSCAN索引扫描FETCH根据索引检索指定文档SHARD_MERGE将各个分片返回数据进行合并SORT在内存中进行了排序LIMIT使用limit限制返回数SKIP使用skip进行跳过IDHACK对_id进行查询SHARDING_FILTER通过mongos对分片数据进行查询COUNTSCANcount不使用Index进行count时的stage返回COUNT_SCANcount使用了Index进行count时的stage返回SUBPLA未使用到索引的$or查询的stage返回TEXT使用全文索引进行查询时候的stage返回PROJECTION限定返回字段时候stage的返回stage状态执行计划的返回结果中尽量不要出现以下stage:COLLSCAN(全表扫描)SORT(使用sort但是无index)不合理的SKIPSUBPLA(未用到index的$or)COUNTSCAN(不使用index进行count)