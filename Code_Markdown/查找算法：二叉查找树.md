在线性表中进行顺序查找在最坏情况和平均情况下都需要O(n)时间，二分查找需要O(logn)时间，但是二分查找的前提是线性表必须是有序的，如果无序，则二分查找是没有意义的。顺序查找和二分查找适合静态查找，如果在查找过程中有插入、删除等修改操作，则在最坏情况和平均情况下都需要O(n)时间。是否存在一种数据结构和算法，既可以高效地查找，又可以高效地动态修改？将二分查找策略与二叉树结合起来，实现二叉查找树结构，可以达到单次修改和查找均在O(logn)时间内完成。原理　二叉查找树详解二叉查找树（Binary Search Tree，BST），又叫作二叉搜索树、二叉排序树，是一种对查找和排序都有用的特殊二叉树。二叉查找树或是空树，或是满足如下性质的二叉树：（1）若其左子树非空，则左子树上所有节点的值均小于根节点的值；（2）若其右子树非空，则右子树上所有节点的值均大于根节点的值；（3）其左右子树本身各是一棵二叉查找树。二叉查找树的特性：左子树<根<右子树，即二叉查找树的中序遍历是一个递增序列。例如，一棵二叉查找树，其中序遍历投影序列如下图所示。[插图]1. 二叉查找树的查找因为二叉查找树的中序遍历有序性，

所以查找与二分查找类似，每次都缩小查找范围，查找效率较高。算法步骤：（1）若二叉查找树为空，查找失败，则返回空指针。（2）若二叉查找树非空，则将待查找关键字x与根节点的关键字T->data进行比较。若x==T->data，查找成功，则返回T。若x<T->data，则递归查找左子树。若x>T->data，则递归查找右子树。完美图解：例如，一棵二叉查找树如下图所示，查找关键字32。[插图]（1）将32与二叉查找树的树根25进行比较，32>25，在右子树中查找，如下图所示。[插图]（2）将32与右子树的树根69进行比较，32<69，在左子树中查找，如下图所示。[插图]（3）将32与左子树的树根32进行比较，相等，查找成功，返回该节点指针，如下图所示。[插图]算法实现：[插图]算法分析：（1）二叉查找树的查找时间复杂度和树的形态有关，可分为最好情况、最坏情况和平均情况进行分析。• 在最好情况下，二叉查找树的形态和二分查找的判定树相似，如下图所示。每次查找都可以缩小一半的搜索范围，查找路径最多从根到叶子，比较次数最多为树的高度logn，在最好情况下查找的时间复杂度为O(logn)。[插图]• 在最坏情况下，二叉查找树的形态为单支树  

，即只有左子树或只有右子树，如下图所示。每次查找的搜索范围都缩小为n-1，退化为顺序查找，在最坏情况下查找的时间复杂度为O(n)。[插图]• n个节点的二叉查找树有n！棵（有的形态相同），可以证明，二叉查找树在平均情况下查找的时间复杂度也为O(logn)。（2）空间复杂度为O(1)。2. 二叉查找树的插入因为二叉查找树的中序遍历存在有序性，所以首先要查找待插入关键字的插入位置，当查找不成功时，再将待插入关键字作为新的叶子节点成为最后一个查找节点的左孩子或右孩子。算法步骤：（1）若二叉查找树为空，则创建一个新的节点s，将待插入关键字放入新节点的数据域，将s节点作为根节点，左右子树均为空    
，即只有左子树或只有右子树，如下图所示。每次查找的搜索范围都缩小为n-1，退化为顺序查找，在最坏情况下查找的时间复杂度为O(n)。[插图]• n个节点的二叉查找树有n！棵（有的形态相同），可以证明，二叉查找树在平均情况下查找的时间复杂度也为O(logn)。（2）空间复杂度为O(1)。2. 二叉查找树的插入因为二叉查找树的中序遍历存在有序性，所以首先要查找待插入关键字的插入位置，当查找不成功时，再将待插入关键字作为新的叶子节点成为最后一个查找节点的左孩子或右孩子。算法步骤：（1）若二叉查找树为空，则创建一个新的节点s，将待插入关键字放入新节点的数据域，将s节点作为根节点，左右子树均为空  
（2）若二叉查找树非空，则将待查找关键字x与根节点的关键字T->data进行比较。• 若x<T->data，则将x插入左子树中。• 若x>T->data，则将x插入右子树中。完美图解：一棵二叉查找树如下图所示，向其中插入关键字30。[插图]（1）将30与树根25进行比较，30>25，在25的右子树中查找，如下图所示。[插图]（2）将30与右子树的树根69进行比较，30<69，在69的左子树中查找，如下图所示。[插图]（3）将30与左子树的树根32进行比较，30<32，在32的左子树中查找，如下图所示。[插图]（4）将32的左子树为空，将30作为新的叶子节点插入32的左子树中，如下图所示。[插图]算法实现：
算法分析：在二叉查找树中进行插入操作时需要先查找插入位置，插入本身只需要常数时间，但查找插入位置的时间复杂度为O(logn)。3. 二叉查找树的创建二叉查找树的创建可以从空树开始，按照输入关键字的顺序依次进行插入操作，最终得到一棵二叉查找树。算法步骤：（1）初始化二叉查找树为空树，T=NULL；（2）输入一个关键字x，将x插入二叉查找树T中；（3）重复步骤2，直到关键字输入完毕。完美图解：依次输入关键字(25,69,18,5,32,45,20)，创建一棵二叉查找树。（1）输入25，二叉查找树初始化为空，所以将25作为树根，左右子树为空，如下图所示。[插图]（2）输入69，将其插入二叉查找树中。与树根25进行比较，比25大，到右子树中查找，右子树为空，将其插入25的右子树中，如下图所示。[插图]（3）输入18，将其插入二叉查找树中。与树根25进行比较，比25小，到左子树中查找，左子树为空，将其插入25的左子树中，如下图所示。[插图]（4）输入5，将其插入二叉查找树中。与树根25进行比较，比25小，到左子树中查找，与树根18进行比较，比18小，到左子树中查找，左子树为空，将其插入18的左子树中，如下图所示。

（5）输入32，将其插入二叉查找树中。与树根25进行比较，比25大，到右子树中查找，与树根69进行比较，比69小，到左子树中查找，左子树为空，将其插入69的左子树中，如下图所示。[插图]（6）输入45，将其插入二叉查找树中。与树根25进行比较，比25大，到右子树中查找，与树根69进行比较，比69小，到左子树中查找，与树根32进行比较，比32大，到右子树中查找，右子树为空，将其插入32的右子树中，如下图所示。[插图]（7）输入20，将其插入二叉查找树中。与树根25进行比较，比25小，到左子树中查找，与树根18进行比较，比18大，到右子树中查找，右子树为空，将其插入18的右子树中，如下图所示。[插图]算法实现：[插图]算法分析：二叉查找树的创建需要n次插入，每次插入在最好情况和平均情况下都需要O(logn)时间，在最坏情况下需要O(n)时间。因此在最好情况和平均情况下的时间复杂度为O(nlogn)，在最坏情况下的时间复杂度为O(n2)，相当于把一个无序序列转换为一个有序序列的排序过程。实质上，创建二叉查找树的过程和快速排序一样，根节点相当于快速排序中的基准元素，左右两部分划分的情况取决于基准元素。创建二叉查找树时
，输入序列的次序不同，创建的二叉查找树也是不同的。4. 二叉查找树的删除首先要在二叉查找树中找到待删除节点，然后执行删除操作。假设指针p指向待删除节点，指针f指向p的双亲节点。根据待删除节点所在位置的不同，删除操作的处理方法也不同，可分为下面三种情况。（1）被删除节点的左子树为空。如果被删除节点的左子树为空，则令其右子树子承父业代替其位置即可。例如，在二叉查找树中删除P节点，如下图所示。[插图]（2）被删除节点的右子树为空。如果被删除节点的右子树为空，则令其左子树子承父业代替其位置即可，如下图所示。[插图]（3）被删除节点的左右子树均不为空。如果被删除节点的左子树和右子树均不为空，则无法再使用子承父业的方法了。根据二叉查找树的中序有序性，删除该节点时，可以用其直接前驱（或直接后继）代替其位置，然后删除其直接前驱（或直接后继）即可。那么在中序遍历序列中，一个节点的直接前驱（或直接后继）是哪个节点呢？直接前驱：在中序遍历中，节点P的直接前驱为其左子树的最右节点。即沿着P的左子树一直访问其右子树，直到没有右子树，就找到了最右节点，如下图（a）所示。直接后继：在中序遍历中，节点P的直接后继为其右子树的最左
节点。如图（b）所示，s指向p的直接后继，q指向s的双亲。f、p、q、s为指向节点的指针，也可以代指该节点。[插图]以p的直接前驱s代替p为例，相当于把s的数据赋值给p，即s代替p，然后删除s即可，因为s为最右节点，它没有右子树，删除后，左子树子承父业代替s，如下图所示。[插图]例如，在二叉查找树中删除24。首先查找到24的位置p，然后找到p的直接前驱s（22），把22赋值给p的数据域，删除s，删除过程如下图所示。[插图]删除节点之后是不是仍然满足二叉查找树的中序遍历有序性？需要注意的是，有一种特殊情况，即p的左孩子没有右子树，s就是其左子树的最右节点（直接前驱），即s代替p，然后删除s即可，因为s为最右节点且没有右子树，删除后，左子树子承父业代替s。如下图所示。[插图]例如，在二叉查找树中删除20，删除过程如下图所示。[插图]算法步骤：（1）在二叉查找树中查找待删除关键字的位置，p指向待删除节点，f指向p的双亲节点，如果查找失败，则返回。（2）如果查找成功，则分三种情况进行删除操作。• 如果被删除节点的左子树为空，则令其右子树子承父业代替其位置即可。• 如果被删除节点的右子树为空，则令其左子树子承父业代替其位置即
可。• 如果被删除节点的左右子树均不为空，则令其直接前驱（或直接后继）代替它，再删除其直接前驱（或直接后继）。完美图解：（1）左子树为空。在二叉查找树中删除32，首先查找到32所在的位置，判断其左子树为空，则令其右子树子承父业代替其位置。删除过程如下图所示。[插图]（2）右子树为空。在二叉查找树中删除69，首先查找到69所在的位置，判断其右子树为空，则令其左子树子承父业代替其位置。删除过程如下图所示。[插图]（3）左右子树为不空。在二叉查找树中删除25，首先查找到25所在的位置，判断其左右子树均不为空，则令其其直接前驱（左子树最右节点20）代替它，再删除其直接前驱20即可。删除20时，其左子树代替其位置。删除过程如下图所示。[插图]算法实现：[插图][插图]算法分析：二叉查找树的删除主要是查找的过程，需要O(logn)时间。在删除过程中，如果需要查找被删除节点的前驱，则也需要O(logn)时间。所以，在二叉查找树中进行删除操作的时间复杂度为O(logn)。训练1　落叶题目描述（POJ1577/UVA1525）：一棵字母二叉树如下图所示。熟悉二叉树的读者可以跳过字母二叉树、二叉树树叶和字母二叉搜索树的定义，直接看问题

描述。[插图]一棵字母二叉树可以是两者之一：①空树；②有一个根节点，每个节点都以一个字母作为数据，并且有指向左子树和右子树的指针，左右子树也是字母二叉树。二叉树的树叶是一个左右子树都为空的节点。在上图的实例中有5个树叶节点，分别为B、D、H、P和Y。字母二叉搜索树是每个节点满足下述条件的字母二叉树：（1）按字母序，根节点的数据在左子树的所有节点的数据之后；（2）根节点的数据在右子树的所有节点的数据之前。在一棵字母二叉搜索树上删除树叶，并将被删除的树叶列出；重复这一过程，直到树为空。例如，从左边的树开始，产生树的序列如下图所示，最后产生空树。[插图]删除的树叶序列如下：[插图]给定一个字母二叉搜索树的树叶删除序列，输出树的先序遍历。输入：输入包含多个测试用例。每个测试用例都是一行或多行大写字母序列，每行都给出按上述描述步骤从二叉搜索树中删除的树叶，每行给出的字母都按字母升序排列。在测试用例之间以一行分隔，该行仅包含一个星号“*”。在最后一个测试用例后给出一行，该行仅给出一个符号“$”。在输入中没有空格或空行。输出：对于每个测试用例，都有唯一的二叉搜索树，单行输出该树的先序遍历。[插图]1. 算法设计由题目可知，

最后一个字母一定为树根，先输入的字母在树的深层，可以逆序建树。读入字母序列后用字符串存储，然后逆序创建二叉搜索树，将小的字母插入左子树中，将大的字母插入右子树中。输出该树的先序遍历序列：根、左子树、右子树。2. 算法实现[插图][插图]训练2　完全二叉搜索树题目描述（POJ2309）：有一棵无限的完全二叉搜索树，节点中的数字是1,2,3,……如下图所示。在根节点为X的子树中，可以从左侧节点向下，直到最后一级获得该子树中的最小数，也可以从右侧节点向下找到该子树中的最大数。求解X的子树中的最小数和最大数是多少。[插图]输入：第1行包含一个整数N，表示查询的数量。在接下来的N行中，每行都包含一个数字，表示根号为X的子树（1≤X≤231-1）。输出：共N行，其中第i行包含第i个查询的答案。[插图]题解：本题有规律可循，若n是奇数，那么必然是叶子节点，最大数和最小数都是它自己，否则求n所在的层数（倒数的层数，底层为0层），它的层数就是n的二进制表示中从低位开始第1个1所处的位置i（最后一个非0位）。例如，6=(110)2，“110”从低位开始第1个“1”的位置为1，因此6在第1层；12=(1100)2，“1100”从低

位开始第1个“1”的位置为2，因此12在第2层，如下图所示。[插图]i的值即层数，可得n的左右子树各有k=2i-1个节点，那么最小数是n-k，最大数是n+k，怎么求2i呢？实际上，想得到最后一个非0位，只需先将原数取反后加1，此时除了最后一个非0位，其他位均与原数相反，直接与原数按位与运算即可得到最后一个非0位。例如，n=44=(101100)2，-n=(101100)2取反加1，两者进行与运算：[插图]得到2i=n&(-n)=4，i=2。因此44在第2层，44的左右子树各有num=2i-1=3个节点，那么最小数是n-num=41，最大数是n+num=47。1. 算法设计（1）求解lowbit(n)=n&(-n)。（2）令k=lowbit(n)-1，输出最小数n-k，最大数n+k。2. 算法实现[插图]训练3　硬木种类题目描述（POJ2418）：见2.4.9节训练1。1. 算法设计本题采用两种方法解决均可。（1）使用二叉搜索树，先将每个单词都存入二叉树中，每出现一次，就修改该单词所在节点cnt++；最后通过中序遍历输出结果。（2）排序后统计，并输出结果。2. 算法实现[插图][插图]训练4　二叉搜索树题目描述（HDU3

791）：判断两个序列是否为同一个二叉搜索树序列。输入：第1行包含一个数n（1≤n≤20），表示有n个序列需要判断，在n=0时输入结束。接下来的一行是一个序列，序列长度小于10，包含0～9的数字，没有重复的数字，根据这个序列可以构造出一棵二叉搜索树。再接下来的n行有n个序列，每个序列的格式都跟第1个序列一样，请判断这两个序列能否组成同一棵二叉搜索树。输出：如果序列相同，则输出“YES”，否则输出“NO”。[插图]题解：本题可以通过判断二叉搜索树的先序遍历序列是否相同来输出结果。因为根据二叉搜索树的中序有序性，先序遍历序列相同，中序遍历序列也一定相同。通过先序遍历序列和中序遍历序列可以唯一确定一棵二叉树。1. 算法设计（1）使用二叉搜索树，先将每个数字都存进二叉搜索树中，得到先序遍历；（2）将后面每一行的每个数字都存进二叉搜索树中，得到先序遍历，比较其是否相等，如果相等，则输出“YES”，否则输出“NO”。2. 算法实现[插图][插图]
