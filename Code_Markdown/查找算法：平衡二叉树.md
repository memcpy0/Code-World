
1. 树高与性能的关系二叉查找树的查找、插入、删除的时间复杂度均为O(logn)，但这是在期望的情况下，在最好情况和最坏情况下差别较大。在最好情况下，二叉查找树的形态和二分查找的判定树相似，如下图中的左图所示。每次查找都可以缩小一半的搜索范围，查找最多从根到叶子，比较次数为树的高度logn。在最坏情况下，二叉查找树的形态为单支树，即只有左子树或只有右子树，如下图中的右图所示。每次查找的搜索范围都缩小为n-1，退化为顺序查找，查找最多从根到叶子，比较次数为树的高度n。[插图]二叉查找树的查找、插入、删除的时间复杂度均线性正比于二叉查找树的高度，高度越小，效率越高。也就是说，二叉查找树的性能主要取决于二叉查找树的高度。那么如何降低树的高度呢？2. 理想平衡与适度平衡在最好情况下，每次都一分为二，左右子树的节点数均为n/2，左右子树的高度也一样。也就是说，如果把左右子树放到天平上，则是平衡的，如下图所示。[插图]在理想状态下，树的高度为logn，左右子树的高度一样，称之为理想平衡。但是理想平衡需要大量时间调整平衡以维护其严格的平衡性，可以适度放松平衡的标准，调整为大致平衡就可以了，称之为适度平衡。原理　


AVL树详解平衡二叉查找树，简称平衡二叉树，由苏联数学家Adelson-Velskii和Landis提出，所以又被称为AVL树。平衡二叉树或为空树，或为具有以下性质的平衡二叉树：①左右子树高度差的绝对值不超过1；②左右子树也是平衡二叉树。节点左右子树的高度之差被称为平衡因子。在二叉查找树中，每个节点的平衡因子的绝对值不超过1即平衡二叉树。例如，一棵平衡二叉树及其平衡因子如下图所示。[插图]那么在这棵平衡二叉树中插入20，结果会怎样？如下图所示，插入20之后，从该叶子到树根路径上的所有节点，平衡因子都有可能改变，出现不平衡，有可能有多个节点的平衡因子的绝对值超过1。从新插入的节点向上，找离新插入节点最近的不平衡节点，以该节点为根的子树被称为最小不平衡子树。只需将最小不平衡子树调整为平衡二叉树即可，其他节点不变。[插图]平衡二叉树除了具有适度平衡性，还具有局部性：①在单次插入、删除后，至多有O(1)处出现不平衡；②总可以在O(logn)时间内，使这O(1)处不平衡重新调整为平衡。对平衡二叉树在动态修改后出现的不平衡，只需局部（最小不平衡子树）调整平衡即可，不需要对整棵树进行调整。那么如何局部调整平衡呢？

1. 调整平衡的方法以插入操作为例，调整平衡可以分为4种情况：LL型、RR型、LR型、RL型。1）LL型插入新节点x后，从该节点向上找到最近的不平衡节点A，如果最近不平衡节点到新节点的路径前两个都是左子树L，就是LL型。也就是说，将节点x插入A的左子树的左子树中，A的左子树因插入新节点而高度增加，造成A的平衡因子由1增加为2，失去平衡。需要进行LL旋转（顺时针）调整平衡。LL旋转：A顺时针旋转到B的右子树，B原来的右子树T3被抛弃，A旋转后正好左子树空闲，将这个被抛弃的子树T3放到A的左子树中即可，如下图所示。[插图]进行每一次旋转时，总有一个子树被抛弃，一个指针空闲，它们正好配对。旋转之后，是否平衡呢？旋转之后，A、B两个节点的左右子树高度之差均为0，满足平衡条件，C的左右子树未变，仍然平衡。[插图]2）RR型插入新节点x后，从该节点向上找到最近不平衡节点A，如果最近不平衡节点到新节点的路径前两个都是右子树R，就是RR型。需要进行RR旋转（逆时针）调整平衡。RR旋转：A逆时针旋转到B的左子树，B原来的左子树T2被抛弃，A旋转后正好右子树空闲，将这个被抛弃的子树T2放到A右子树中即可，如下图所示。

旋转后，A、B的左右子树高度之差均为0，满足平衡条件，C的左右子树未变，仍然平衡。[插图]3）LR型插入新节点x后，从该节点向上找到最近不平衡节点A，如果最近不平衡节点到新节点的路径前两个依次是左子树L、右子树R，就是LR型。LR旋转：分两次旋转。C逆时针旋转到A、B之间，C原来的左子树T2被抛弃，B正好右子树空闲，将这个被抛弃的子树T2放到B右子树中；这时已经转变为LL型，进行LL旋转即可，如下图所示。实际上，也可以看作C固定不动，B进行RR旋转，然后进行LL旋转。[插图]旋转后，A、C的左右子树高度之差均为0，满足平衡条件，B的左右子树未变，仍然平衡。[插图]4）RL型插入新节点x后，从该节点向上找到最近不平衡节点A，如果最近不平衡节点到新节点的路径前两个依次是右子树R、左子树L，就是RL型。RL旋转：分两次旋转。C顺时针旋转到A、B之间，C原来的右子树T3被抛弃，B正好左子树空闲，这个被抛弃的子树T3放到B左子树；这时已经转变为RR型，做RR旋转即可，如下图所示。实际上，也可以看作C固定不动，B进行LL旋转，然后进行RR旋转。[插图]旋转后，A、C的左右子树高度之差均为0，满足平衡条件，B的左右子树未变



仍然平衡。[插图]2. 平衡二叉树的插入在平衡二叉树中插入新的数据元素x，首先要查找其插入的位置，在查找过程中，用p指针记录当前节点，用f指针记录p的双亲。算法步骤：（1）在平衡二叉树中查找x，如果查找成功，则什么也不做，返回p；如果查找失败，则执行插入操作。（2）创建一个新节点p存储x，该节点的双亲为f，高度为1。（3）从新节点之父f出发，向上查找最近的不平衡节点。逐层检查各代祖先节点，如果平衡，则更新其高度，继续向上查找；如果不平衡，则判断失衡类型（沿着高度大的子树判断，刚插入新节点的子树必然高度大），并做相应的调整，返回p。完美图解：例如，一棵平衡二叉树如下图所示，在该树中插入元素20（在节点旁标记以该节点为根的子树的高度）。[插图]（1）查找20在树中的位置，初始化，p指向树根，其双亲f为空。[插图]（2）将20和25做比较，20<25，在左子树中查找，f指向p，p指向p的左孩子。[插图]（3）将20和16做比较，20>16，在右子树中查找，f指向p，p指向p的右孩子。[插图]（4）将20和24做比较，20<24，在左子树中查找，f指向p，p指向p的左孩子。[插图]（5）将20和19做比较，20>19，在右子树中

查找，f指向p，p指向p的右孩子。[插图]（6）此时p为空，查找失败，可以将新节点20插入此处，新节点的高度为1，双亲为f。[插图]（7）从新节点之父f开始，逐层向上检查祖先是否失衡，若未失衡，则更新其高度；若失衡，则判断其失衡类型，调整平衡。初始化g指向f，检查g的左右子树之差为-1，g未失衡，更新其高度2（左右子树的高度最大值加1）。[插图]（8）继续向上检查，g指向g的双亲，g的左右子树高度之差为2，失衡。用g、u、v三个指针记录三代节点（从失衡节点沿着高度大的方向向下找三代）。[插图]（9）将以g为根的最小不平衡子树调整平衡即可。判断失衡类型为LR型，先令20顺时针旋转到19、24之间，然后24顺时针旋转即可，更新19、20、24节点的高度。[插图]（10）调整平衡后，将该子树接入g的双亲，平衡二叉树如下图所示。[插图]算法实现：[插图]3. 平衡二叉树的创建平衡二叉树的创建和二叉查找树的创建类似，只是插入操作多了调整平衡而已。可以从空树开始，按照输入关键字的顺序依次进行插入操作，最终得到一棵平衡二叉树。算法步骤：（1）初始化平衡二叉树为空树，T=NULL。（2）输入一个关键字x，将x插入平衡二叉树T中。（3）重复步骤

2，直到关键字输入完毕。完美图解：例如，依次输入关键字(25,18,5,10,15,17)，创建一棵平衡二叉树。（1）输入25，将平衡二叉树初始化为空，所以将25作为树根，左右子树为空，如下图所示。[插图]（2）输入18，插入平衡二叉树。与树根25做比较，比25小，到左子树中查找，左子树为空，插入此位置，检查祖先未发现失衡，如下图所示。[插图]（3）输入5，将其插入平衡二叉树中。与树根25做比较，比25小，到左子树中查找，比18小，到左子树中查找，左子树为空，插入此位置。25节点失衡，从不平衡节点到新节点路径前两个是LL，做LL型旋转调整平衡，如下图所示。[插图]（4）输入10，将其插入平衡二叉树中。与树根18做比较，比18小，到左子树中查找，与树根5做比较，比5大，到右子树中查找，右子树为空，插入此位置，检查祖先未发现失衡。如下图所示。[插图]（5）输入15，将其插入平衡二叉树中。与树根18做比较，比18小，到左子树中查找，与树根5做比较，比5大，到右子树中查找，与树根10做比较，比10大，到右子树中查找，右子树为空，插入此位置。5节点失衡，从不平衡节点到新节点路径前两个是RR，做RR型旋转调整平衡，如下图

所示。[插图]（6）输入17，将其插入平衡二叉树中。经查找之后（过程省略），将其插入15的右子树位置。18节点失衡，从不平衡节点到新节点路径前两个是LR，做LR型旋转，如下图所示。[插图]算法实现：[插图]4. 平衡二叉树的删除在平衡二叉树中进行插入操作时只需从插入节点之父向上检查，发现不平衡便立即调整，调整一次平衡即可；而进行删除操作时需要一直从删除节点之父向上检查，发现不平衡便立即调整，然后继续向上检查，直到树根。算法步骤：（1）在平衡二叉树中查找x，如果查找失败，则返回；如果查找成功，则执行删除操作（同二叉查找树的删除操作）。（2）从实际被删除节点之父g出发（当被删除节点有左右子树时，令其直接前驱（或直接后继）代替其位置，删除其直接前驱，实际被删除节点为其直接前驱（或直接后继）），向上寻找最近的不平衡节点。逐层检查各代祖先节点，如果平衡，则更新其高度，继续向上寻找；如果不平衡，则判断失衡类型（沿着高度大的子树判断），并做相应的调整。（3）继续向上检查，一直到树根。完美图解：例如，一棵二叉平衡树如下图所示，删除16。[插图]（1）16为叶子，将其直接删除即可，如下图所示。[插图]（2）指针g指向实际被删除节点1

6之父25，检查是否失衡，25节点失衡，用g、u、v记录失衡三代节点（从失衡节点沿着高度大的子树向下找三代），判断为RL型，进行RL旋转调整平衡，如下图所示。[插图]（3）继续向上检查，指针g指向g的双亲69，检查是否失衡，69节点失衡，用g、u、v记录失衡三代节点，判断为RR型，进行RR旋转调整平衡，如下图所示。[插图]（4）已检查到根，结束。又如，一棵平衡二叉树如下图所示，删除80。[插图]（1）80的左右子树均非空，令其直接前驱78代替它，删除其直接前驱78，如下图所示。[插图]（2）指针g指向实际被删除节点78之父75，检查是否失衡，75节点失衡，用g、u、v记录失衡三代节点，判断为LL型，进行LL旋转调整平衡，如下图所示。[插图]（3）指针g指向g的双亲80，检查是否失衡，一直检查到根，结束。注意：从实际被删除节点之父开始检查是否失衡，一直检查到根。算法实现：[插图][插图]训练1　平衡二叉树题目描述（TOJ3374）：根据给定的序列建立一棵平衡二叉树，求平衡二叉树的树根。输入：输入包含一组测试数据。数据的第1行是一个正整数n（n≤20），表示输入序列的元素个数；第2行给出n个正整数，按数据输入顺序建立平衡二叉树。输
出：输出平衡二叉树的树根。[插图]1. 算法设计（1）按照数据输入顺序创建平衡二叉树。（2）输出平衡二叉树的树根。2. 算法实现[插图][插图][插图]训练2　双重队列题目描述（POJ3481）：见2.4.9节训练2。题解：可以使用平衡二叉树AVL解决。1. 算法设计（1）读入指令n，判断类型。（2）如果n=1，则读入客户num及优先级val，将其插入平衡二叉树中。（3）如果n=2，此时平衡二叉树为空，则输出0，否则输出最大值并删除。（4）如果n=3，此时平衡二叉树为空，则输出0，否则输出最小值并删除。2. 算法实现[插图][插图][插图][插图]训练3　黑盒子题目描述（POJ1442）：见2.4.6节训练。题解：可以建立一棵平衡二叉树，查找第k小。算法实现：

训练4　硬木种类题目描述（POJ2418）：见2.4.9节训练1。题解：使用以下三种方法均可。• 排序后统计，输出结果。• 使用二叉搜索树，先将每个单词都存入二叉树中，每出现一次，则修改该单词所在节点cnt++；最后通过中序遍历输出结果。• 使用平衡二叉搜索树，先将每个单词都插入平衡二叉树中，每出现一次，则修改该单词所在节点cnt++；最后通过中序遍历输出结果。效率高于二叉搜索树。