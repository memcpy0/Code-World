原理　哈夫曼编码通常的编码方法有固定长度编码和不等长编码两种。这是一个设计最优编码方案的问题，目的是使总码长度最短。这个问题是利用字符的使用频率来编码，是不等长编码方法，使得经常使用的字符编码较短，不常使用的字符编码较长。如果采用等长的编码方案，假设所有字符的编码都等长，则表示n个不同的字符需要⌈logn⌉位。例如3个不同的字符a、b、c，至少需要两位二进制数表示，即a:00、b:01、c:10。**如果每个字符的使用频率都相等，则固定长度编码是空间效率最高的方法**。

不等长编码方法需要解决两个关键问题：
①编码尽可能短，我们可以让使用频率高的字符编码较短，使用频率低的字符编码较长，这种方法可以提高压缩率，节省空间，也能提高运算和通信速度，即**频率越高，编码越短**；

②不能有二义性。例如：ABCD四个字符如果这样编码：
A：0, B: 1, C: 01 D: 10
那么现在有一列数0110，该怎样翻译呢？是翻译为ABBA、ABD、CBA还是CD？这种混乱的译码如果用在军事情报中后果会很严重！那么如何消除二义性呢？解决的办法是：**任何一个字符的编码都不能是另一个字符编码的前缀，即前缀码特性**。（即把所有字符都作为叶子节点）。

1952年，数学家D.A.Huffman提出了一种最佳编码方式，被称为哈夫曼（Huffman）编码。哈夫曼编码很好地解决了上述两个关键问题，被广泛地应用于数据压缩，尤其是远距离通信和大容量数据存储。**常用的JPEG图片就是采用哈夫曼编码压缩的**。

哈夫曼编码的基本思想是，以字符的使用频率作为权值构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。构造一棵哈夫曼树，是**将所要编码的字符作为叶子节点**，将该字符在文件中的使用频率作为叶子节点的权值，以自底向上的方式，通过n-1次的“合并”运算后构造出的树。

其核心思想是**让权值大的叶子离根最近**。哈夫曼算法采取的贪心策略是，每次都从树的集合中取出没有双亲且权值最小的两棵树作为左、右子树，构造一棵新树，新树根节点的权值为其左、右孩子节点权值之和，将新树插入树的集合中。
### 1. 算法步骤
（1）确定合适的数据结构。编写程序前需要考虑的情况如下。
- 在哈夫曼树中，如果没有度为1的节点，则一棵有n个叶子节点的哈夫曼树共有2n-1个节点（n-1次的“合并”，每次都产生一个新节点）。
- 构成哈夫曼树后，**编码需要从叶子节点出发走一条从叶子到根的路径**。译码需要从根出发走一条从根到叶子的路径。那么对于每个节点而言，需要知道每个节点的权值、双亲、左孩子、右孩子和节点的信息。

（2）初始化。构造n棵节点为n个字符的单节点树集合T={t1,t2,t3,…,tn}，每棵树只有一个带权的根节点，权值为该字符的使用频率。

（3）如果在T中只剩下一棵树，则哈夫曼树构造成功，跳到第6步。否则，从集合T中取出没有双亲且权值最小的两棵树ti和tj，将它们合并成一棵新树zk，新树的左孩子为ti，右孩子为tj，zk的权值为ti和tj的权值之和。

（4）从集合T中删去ti、tj，加入zk。

（5）重复第（3）～（4）步。

（6）约定左分支上的编码为“0”，右分支上的编码为“1”。**从叶子节点到根节点逆向求出每个字符的哈夫曼编码**。那么从根节点到叶子节点路径上的字符组成的字符串，为该叶子节点的哈夫曼编码，算法结束。

### 2. 完美图解
假设一些字符及它们的使用频率如下表所示，那么如何得到它们的哈夫曼编码呢？
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111059117.png)
可以把每一个字符都作为叶子，将它们对应的频率作为其权值，因为只是比较大小，所以为了比较方便，可以对其同时扩大一百倍，得到a:5、b:32、c:18、d:7、e:25、f:13。

（1）初始化。构造n棵节点为n个字符的单节点树集合T={a,b,c,d,e,f}，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111059836.png)
（2）从集合T中取出没有双亲且权值最小的两棵树a和d，将它们合并成一棵新树t1，新树的左孩子为a（约定**最小在左，次小在右**），右孩子为d，新树的权值为a和d的权值之和12。将新树的树根t1加入集合T，将a、d从集合T中删除，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111103382.png)

（3）从集合T中取出没有双亲且权值最小的两棵树t1和f，将它们合并成一棵新树t2，新树的左孩子为t1，右孩子为f，新树的权值为t1和f的权值之和25。将新树的树根t2加入集合T，将t1和f从集合T中删除，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111103582.png)

（4）从集合T中取出没有双亲且权值最小的两棵树c和e，将它们合并成一棵新树t3，新树的左孩子为c，右孩子为e，新树的权值为c和e的权值之和43。将新树的树根t3加入集合T，将c和e从集合T中删除，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111103476.png)
（5）从集合T中取出没有双亲且权值最小的两棵树t2和b，将它们合并成一棵新树t4，新树的左孩子为t2，右孩子为b，新树的权值为t2和b的权值之和57。新树的树根t4加入集合T，将t2和b从集合T中删除，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111106091.png)

（6）从集合T中取出没有双亲且权值最小的两棵树t3和t4，将它们合并成一棵新树t5，新树的左孩子为t4，右孩子为t3，新树的权值为t3和t4的权值之和100。将新树的树根t5加入集合T，将t3和t4从集合T中删除，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111108091.png)

（7）在集合T中只剩下一棵树，哈夫曼树构造成功。
（8）约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子节点到根节点逆向求出每个字符的哈夫曼编码。那么从根节点到叶子节点路径上的字符组成的字符串为该叶子节点的哈夫曼编码，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111108366.png)

### 3. 算法实现
在构造哈夫曼树的过程中，首先将每个节点的双亲、左孩子、右孩子都初始化为-1，找出所有节点中双亲为-1且权值最小的两个节点t1、t2，并合并为一棵二叉树，更新信息（双亲节点的权值为t1、t2权值之和，其左孩子为权值最小的节点t1，右孩子为次小的节点t2，t1、t2的双亲为双亲节点的编号）。重复此过程，建成一棵哈夫曼树。


（1）数据结构。每个节点的结构都包括权值、双亲、左孩子、右孩子、节点字符信息五个域，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111108813.png)
将其定义为结构体形式，定义节点结构体HNodeType。
```cpp
typedef struct {
    double weight;
    int parent;
    int lchild, rchild;
    char value;
} HNodeType;
```
在结构体的编码过程中，bit[]存放节点的编码，start记录编码开始时的下标，在逆向编码（从叶子到根，想一想为什么不从根到叶子呢？）存储时，**start从n-1开始依次递减，从后向前存储；当读取时，从start+1开始到n-1，从前向后输出，即该字符的编码**，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111111003.png)
编码结构体HcodeType代码如下。
```cpp
typedef struct {
    int bit[MAXBIT]; // 存储编码的数组
    int start; // 编码开始下标
} HCodeType;
```
（2）初始化。初始化哈夫曼树数组 `HuffNode[]` 中的**节点权值**为0，**双亲和左、右孩子**均为-1，然后读入叶子节点的权值，如下表所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111116483.png)

（3）循环构造哈夫曼树。从集合T中取出双亲为-1且权值最小的两棵树ti和tj，将它们合并成一棵新树zk，新树的左孩子为ti，右孩子为tj，zk的权值为ti和tj的权值之和。
```cpp
int i, j;
int x1, x2; // x1, x2为两个最小权值节点的序号
double m1, m2; // m1, m2为两个最小权值节点的权值
for (int i = 0; i < n - 1; ++i) { // 用优先队列优化
    m1 = m2 = MAXVALUE; // 初始化为最大值
    x1 = x2 = -1; // 初始化为-1
    // 找出所有节点中权值最小、无双亲节点的两个节点
    for (int j = 0; j < n + i; ++j) { 
        if (HuffNode[j].weight < m1 && HuffNode[j].parent == -1) { // 没有合并过的节点
            m2 = m1;
            x2 = x1;
            m1 = HuffNode[j].weight;
            x1 = j;
        } else if (HuffNOde[j].weight < m2 && HuffNode[j].parent == -1) {
            m2 = HuffNode[j].weight;
            x2 = j;
        }
    }
    // 更新新树信息
    HuffNode[x1].parent = n + i; // x1的父亲为新节点编号n+i
    HuffNode[x2].parent = n + i; // x2的父亲为新节点编号n+i
    HuffNode[n + i].weight = m1 + m2; // 新节点权值为两个最小权值之和m1+m2
    HuffNode[n + i].lchild = x1; // 新节点n+i的左孩子为x1
    HuffNode[n + i].rchild = x2; // 新节点n+i的右孩子为x2
}
```

完美图解：第1步，i=0时：j=0; j<6；找双亲为-1且权值最小的两个数。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111129882.png)
数据更新后如下表所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111129032.png)
对应的哈夫曼树如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111129158.png)
第2步，i=1时：j=0; j<7；找双亲为-1且权值最小的两个数。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111130240.png)

数据更新后如下表所示。 
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111130220.png)
对应的哈夫曼树如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111130253.png)
第3步，i=2时：j=0; j<8；找双亲为-1且权值最小的两个数。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111130221.png)

数据更新后如下表所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111131595.png)

对应的哈夫曼树如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111132378.png)
第4步，i=3时：j=0; j<9；找双亲为-1且权值最小的两个数。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111135713.png)

数据更新后如下表所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111138260.png)

对应的哈夫曼树如下图所示。
![200](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111139334.png)

第5步，i=4时：j=0; j<10；找双亲为-1且权值最小的两个数。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111140031.png)
数据更新后如下表所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111140789.png)
对应的哈夫曼树如下图所示。
![300](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111141677.png)
（4）输出哈夫曼编码（**读表的过程**，**填表的过程**）。
```cpp
void HuffmanCode(HCodeType HuffCode[MAXLEAF], int n) {
    HCodeType cd; // 定义一个临时变量来存放求解编码时的信息
    int c, p;
    for (int i = 0; i < n; ++i) { // 从叶子往上，因为父亲只有1个
        cd.start = n - 1;
        c = i; // i为叶子节点编号
        p = HuffNode[c].parent;
        while (p != -1) { 
            if (HuffCode[p].lchild == c) { // 该节点是父的左节点
                cd.bit[cd.start] = 0;
            } else {
                cd.bit[cd.start] = 1;    
            }
            cd.start--; // start向前移动一位
            c = p; // c, p变量上移,准备下一循环
            p = HuffNode[c].parent;
        }  
        // 把叶子节点的编码信息从临时编码cd中复制出来，放入编码结构体数组
        for (int j = cd.start + 1; j < n; ++j)
            HuffCode[i].bit[j] = cd.bit[j];
        HuffCode[i].start = cd.start; 
    }
}
```
哈夫曼编码数组如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111150450.png)

第1步，i=0时：c=0。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111151963.png)

构造好的哈夫曼树数组如下表所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111151304.png)
如果p!=-1，那么从表HuffNode[]中读出节点6的左孩子和右孩子，判断节点0是它的左孩子还是右孩子；如果是左孩子，则编码为0；如果是右孩子，则编码为1。

从上表中可以看出：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111151589.png)

哈夫曼树和哈夫曼编码数组如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111152271.png)

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111152182.png)
c、p变量上移后如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111153801.png)

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111154941.png)

哈夫曼树和哈夫曼编码数组如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111154656.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111154947.png)
哈夫曼树和哈夫曼编码数组如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111155558.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111157955.png)
哈夫曼树和哈夫曼编码数组如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111158664.png)
HuffCode[]数组如下图所示（图中的箭头不表示指针）。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111159807.png)
### 4. 算法分析
时间复杂度：由程序可以看出，在函数HuffmanTree()中， `if(HuffNode[j].weight<m1&&HuffNode[j].parent==−1)` 为基本语句，外层i与j组成双层循环。
- i=0时，该语句执行n次。
- i=1时，该语句执行n+1次。
- i=2时，该语句执行n+2次。
- ……
- i=n−2时，该语句执行n+(n−2)次。
- 基本语句共执行n+(n+1)+(n+2)+…+(n+(n−2))=(n−1)×(3n−2)/2次。

在函数HuffmanCode()中，编码和输出编码的时间复杂度都接近 $n^2$ ，则该算法时间复杂度为 $O(n^2)$ 。

空间复杂度：所需存储空间为节点结构体数组与编码结构体数组，哈夫曼树数组HuffNode[]中的节点为n个，每个节点都包含bit[MAXBIT]和start两个域，则该算法的空间复杂度为 $O(n×\texttt{MAXBIT})$ 。
### 5. 算法优化
该算法可以从以下两个方面进行优化。
（1）在函数HuffmanTree()中找两个权值最小节点时，使用优先队列，时间复杂度为logn，执行n−1次，总时间复杂度为$O(n\log n)$ 。
（2）在函数HuffmanCode()中，在哈夫曼编码数组HuffNode[]中可以定义一个动态分配空间的线性表来存储编码，每个线性表的长度都为实际的编码长度，这样可以大大节省空间。

### 6. 哈夫曼树带权路径长度
WPL=每个叶子的权值 * 该叶子到根的路径长度之和
也等于 各个新生成节点的权值之和。

因为新生成节点的值是叶子节点的和，新生成节点的父亲的值则是新生成节点值之和，就将叶子节点的值加了多次。

## 训练1　围栏修复
题目描述（POJ3253）：约翰想修牧场周围的篱笆，需要N块（1≤N≤20000）木板，每块木板都具有整数长度Li（1≤Li≤50000）米。他购买了一块足够长的木板（长度为Li的总和，i=1,2,…, N），以便得到N块木板。切割时木屑损失的长度不计。

农夫唐向约翰收取切割费用。切割一块木板的费用与其长度相同。切割长度为21米的木板需要21美分。唐让约翰决定切割木板的顺序和位置。约翰知道以不同的顺序切割木板，将会产生不同的费用。帮助约翰确定他得到N块木板的最低金额。

输入：第1行包含一个整数N，表示木板的数量。第2～N+1行，每行都包含一个所需木板的长度Li。输出：一个整数，即进行N-1次切割的最低花费。

题解：本题类似哈夫曼树的构造方法，每次都选择两个最小的合并，直到合并为一棵树。每次合并的结果就是切割的费用。使用优先队列（最小值优先）时，每次都弹出两个最小值t1、t2，t = t1+t2，sum+=t，将t入队，继续，直到队空。sum为所需花费。
### 训练2　信息熵
题目描述（POJ1521）：熵编码是一种数据编码方法，通过对去除“冗余”或“额外”信息的消息进行编码来实现无损数据压缩。为了能够恢复信息，编码字形的位模式不允许作为任何其他编码位模式的前缀，称之为“无前缀可变长度”编码。只允许逐位读取编码的比特流，并且每当遇到表示字形的一组比特时，都可以解码该字形。如果不强制使用无前缀约束，则不可能进行这种解码。第1个例子，考虑文本“AAAAABCD”，对其使用8位ASCII编码需要64位。如果用“00”对“A”编码，用“01”对“B”编码，用“10”对“C”编码，用“11”对“D”编码，那么只需16位编码，得到的位模式将是“0000000000011011”。不过，这仍然是固定长度的编码；使用的是每个字形两位，而不是八位。既然字形“A”出现的频率更高，那么能用更少的位来编码它吗？实际上可以，但为了保持无前缀编码，其他一些位模式将变得比两位长。最佳编码是将“A”编码为“0”，将“B”编码为“10”，将“C”编码为“110”，将“D”编码为“111”（这显然不是唯一的最佳编码，因为B、C和D的编码可以在不增加最终编码消息大小的情况下自由地交换给任何给定的编码）。使用此编码，消息仅以13位编码到“0000010110111”，压缩比为4.9:1（即最终编码消息中的每一位表示的信息与原始编码中的4.9位表示的信息相同）。从左到右阅读这个位模式，将看到无前缀编码使得将其解码为原始文本变得简单，即使代码的位长度不同。第2个例子，考虑文本“THE CAT IN THE HAT”。字母“T”和空格字符都以最高频率出现，因此它们在最佳编码中显然具有最短的编码位模式。字母“C”、“I”和“N”只出现一次，因此它们的代码最长。有许多可能的无前缀可变长度位模式集可以产生最佳编码，也就是说，允许文本以最少的位进行编码。其中一种最佳编码是：空格:00、A:100、C:1110、E:1111、H:110、I:1010、N:1011、T:01。因此，这种最佳编码只需51位，与用8位ASCII编码对消息进行编码所需的144位相比，压缩比为2.8:1。输入：输入文件包含一个字符串列表，每行一个。字符串将只包含大写字母、数字字符和下画线（用于代替空格）。以字符串“END” 结尾，不应处理此行。输出：对于每个字符串，都输出8位ASCII编码的位长度、最佳无无前缀可变长度编码的位长度及精确到一个小数点的压缩比。[插图]题解：本题非常简单，最佳无前缀可变长度编码就是哈夫曼编码。首先根据字符串统计每个字符出现的频率，然后按照频率构造哈夫曼树，计算总的编码长度。算法代码：[插图]
## 训练3　转换哈夫曼编码
题目描述（UVA12676）：静态哈夫曼编码是一种主要用于文本压缩的编码算法。给定一个由N个不同字符组成的特定长度的文本，算法选择N个编码，每个不同的字符都对应一个编码。使用这些编码压缩文本，当选择编码算法构建一个具有N个叶子的二叉树时，对于N≥2，树的构建流程如下。（1）对文本中的每个不同字符，都构建一个仅包含单个节点的树，其权值为该字符在文本中的出现次数。（2）构建一个包含上述N棵树的集合S。（3）当S包含多于一棵树时：①选择最小的权值t1∈S，并将其从S中删除；②选择最小的权值t2∈S，并将其从S中删除；③构建一棵新树t，t1为其左子树，t2为其右子树，t的权值为t1、t2权值之和；④将t加入S集合。（4）返回保留在S中的唯一一棵树。对于文本“abracadabra”，由上述过程生成的树，可以像下面左图，其中每个叶子节点内都是该字符在文本中出现的次数（权值）。请注意获得的树不是唯一的，也可以像下面右图或其他，因为可能包含几个权值最小的树。[插图]对文本中的每个不同字符，其编码都取决于最终树中从根到对应字符的叶子之间的路径，编码的长度是这条路径中的边数。假设该算法构建的是左侧的树，“r”的代码长度为3，“d”的代码长度为4。根据算法选择的N个代码的长度，找所有字符总数的最小值。输入：输入包含多个测试用例，每个测试用例的第1行都包含一个整数N（2≤N≤50），表示在文本中出现的不同字符数。第2行包含N个整数Li（1≤Li≤50，i=1,2,…,N），表示由哈夫曼算法生成的不同字符的编码长度。假设至少存在一棵由上述算法构建的树，那么可以生成具有给定长度的编码。输出：对每个测试用例都输出一行，表示所有字符总数的最小值。[插图]题解：本题不是简单的哈夫曼编码问题，而是反其道而行之，根据编码长度，推测最小字符数。例如：[插图]其最长编码为3，即最大深度为3。底层节点的权值至少为1，每一层节点的权值至少是下一层节点权值的最大值。如果当前节点的权值比下一层节点的权值小，就会出现在下一层了，因为权值越小，出现的层次越大，如下图所示。[插图]根据编码长度推测，该文本至少有5个字符：1个a、1个d、1个c、2个b。1. 算法设计（1）在每一层都用一个深度数组deep[]记录该层节点的权值，将该层每个节点的权值都初始化为0，等待推测权值。（2）根据输入的编码长度算出最大长度，即哈夫曼树的最大深度maxd。（3）从最大深度maxd向上计算并推测，直到树根。开始时temp=1。• i=maxd：第i层的节点权值如果为0，则被初始化为temp。对第i层从小到大排序，然后将第i层每两个合并，将权值放入上一层（i-1层）。更新temp为第i层排序后的最后一个元素（最大元素）。• i=maxd-1：重复上述操作。• i=0：结束，输出第0层第1个元素。2. 算法实现[插图][插图]训练4　可变基哈夫曼编码题目描述（UVA240）：哈夫曼编码是一种最优编码方法。根据已知源字母表中字符的出现频率，将源字母表中的字符编码为目标字母表中的字符，最优的意思是编码信息的平均长度最小。在该问题中，需要将N个大写字母（源字母S1…SN、频率f1…fN）转换成R进制数字（目标字母T1…TR）。当R=2时，编码过程分几个步骤。在每个步骤中都有两个最低频率的源字母S1和S2，合并成一个新的“组合字母”，频率为S1和S2的频率之和。如果最低频率和次低频率相等，则字母表中最早出现的字母被选中。经过一系列步骤后，最后只剩两个字母合并，将每次合并的字母都分配一个目标字符，将较低频率的分配0，将另一个分配1。如果在一次合并中，每个字母都有相同的频率，则将最早出现的分配0。出于比较的目的，组合字母的值为合并中最早出现的字母的值。源字母的最终编码由每次形成的目标字符组成。目标字符以相反的顺序连接，最终编码序列中的第1个字符为分配给组合字母的最后一个目标字符。下面的两个图展示了R=2的过程。[插图]当R>2时，对每一个步骤都分配R个字母。由于每个步骤都将R个字母或组合字母合并为一个组合字母，并且最后一次合并必须合并R个字母或组合字母，源字母必须包含k×(R-1)+R个字母，k为整数。由于N可能不是很大，因此必须包括适当数量具有0频率的虚拟字母。这些虚拟字母不包含在输出中。进行比较时，虚拟字母晚于字母表中的任何字母。哈夫曼编码的基本过程与R=2的过程相同。在每次合并中都将具有最低频率的R个字母合并，形成新的组合字母，其频率等于在组合字母中包括的字母频率的总和。被合并的字母被分配目标字母符号0～R-1。0被分配给

具有最低频率的组合中的字母，1被分配给下一个最低频率，等等。如果字母组合中的几个字母具有相同的频率，则字母表中最早出现的字母被分配较小的目标符号，以此类推。下图说明了R=3的过程。[插图]输入：输入将包含一个或多个数据集，每行一个。每个数据集都包含整数值R（2≤R≤10）、整数值N（2≤N≤26）和整数频率f1…fN，每个都为1～999。整个输入数据都以R为0结束，它不被认为是单独的数据集。输出：对每个数据集都在单行上显示其编号（编号从1开始按顺序排列）和平均目标符号长度（四舍五入到小数点后两位）。然后显示N个源字母和相应的哈夫曼代码，每行都有一个字母和代码。在每个测试用例后都打印一个空行。[插图]题解：本题为可变基哈夫曼编码，普通的哈夫曼编码为二叉树，即R=2。例如，输入3 4 5 7 8 15，表示基数R=3，字符个数N=4，每个字符的频率为A: 5、B: 7、C: 8、D: 15，构建的哈夫曼树如下图所示。[插图]需要补充一些虚拟字符，使总数满足k×(R-1)+R，k为整数，这样可以保证每个分支节点都有R个叉。虚拟字符的频率为0，其优先值排在所有字母之后。生成一个组合时，组合节点的频率为所有子节点频率之和，组合节点的优先值为所有子节点中的最小优先值。1. 算法设计（1）先补充虚拟字符，使N=k×(R-1)+R，k为整数，即(N-R)%(R-1)=0。（2）每个节点都包含frequency、va、id这3个域，分别表示频率、优先值、序号。（3）定义优先级。频率越小越优先，如果频率相等，则值越小越优先。（4）将所有节点都加入优先队列。（5）构建可变基哈夫曼树。（6）进行可变基哈夫曼编码。2. 算法实现[插图][插图][插图]
