# 1. 树
树（Tree）是n（n≥0）个节点的有限集合，当n=0时，为空树；当n>0时，为非空树。任意一棵非空树，都满足：①有且仅有一个被称为根的节点；②除根节点外的其余节点可分为m（m＞0）个互不相交的有限集T1, T2, …, Tm，其中每一个集合本身又是一棵树，被称为根的子树（SubTree）。

一棵树如下图所示。该树除了树根，还有3棵互不相交的子树：T1、T2、T3。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101900270.png)
该定义是从集合论的角度给出的对树的递归定义，即把树的节点看作一个集合，除了树根，其余节点被分为m个互不相交的集合，每一个集合又都是一棵树。

树的相关术语较多，在此一一进行介绍。
- 节点：节点包含数据元素及若干指向子树的分支信息。
- 节点的度：节点拥有的子树个数。
- 树的度：树中节点的最大度数。
- 终端节点：度为0的节点，又被称为叶子。
- 分支节点：度大于0的节点。除了叶子，都是分支节点。
- 内部节点：除了树根和叶子，都是内部节点。

一棵树如下图所示，该树的度为3，其内部节点和终端节点均用虚线圈起来。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101901489.png)

- 节点的层次：从根到该节点的层数（根节点为第1层）。
- 树的深度（或高度）：所有节点中最大的层数。

一棵树如下图所示，根为第1层，根的子节点为第2层……该树的最大层次为4，因此树的深度为4。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101902107.png)
- 路径：树中两个节点之间所经过的节点序列。
- 路径长度：两个节点之间路径上经过的边数。一棵树如下图所示，D到A的路径为D-B-A，D到A的路径长度为2。由于树中没有环，因此**树中任意两个节点之间的路径都是唯一的**。

如果把树看作一个族谱，就成了一棵家族树，如下图所示。
- 双亲、孩子：节点的子树的根被称为该节点的孩子，反之，该节点为其孩子的双亲。
- 兄弟：双亲相同的节点互称兄弟。
- 堂兄弟：双亲是兄弟的节点互称堂兄弟。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101903127.png)

- 祖先：即从该节点到树根经过的所有节点，被称为该节点的祖先。
- 子孙：节点的子树中的所有节点都被称为该节点的子孙。

    祖先和子孙的关系。如下图所示，D的祖先为B、A，A的子孙为B、C、D、E、F、G。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101903730.png)

- 有序树：节点的各子树从左至右有序，不能互换位置，如下图所示。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101903453.png)

- 无序树：节点的各子树可互换位置。

- 森林：由m（m≥0）棵不相交的树组成的集合。上图中的树，删除树根A后，余下的3棵子树构成一个森林，如下图所示。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101904839.png)

# 5.2 树的存储
树形结构是一对多的关系，除了树根，每个节点都有一个唯一的直接前驱（双亲）；除了叶子，每个节点都有一个或多个直接后继（孩子）。那么如何将数据及它们之间的逻辑关系存储起来呢？仍然可以采用顺序存储和链式存储。
## 1. 顺序存储
顺序存储采用一段连续的存储空间，因为树中节点的数据关系是一对多的逻辑关系，所以**不仅要存储数据元素，还要存储它们之间的逻辑关系**。

顺序存储分为双亲表示法、孩子表示法和双亲孩子表示法。以下图为例，分别讲述三种存储方法。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101905620.png)

（1）**双亲表示法**。除了存储数据元素，还存储其双亲节点的存储位置下标，其中“-1”表示不存在。每个节点都有两个域：数据域data和双亲域parent，如下图（a）所示。树根A没有双亲，双亲被记为-1。B、C、D的双亲为A，而A的存储位置下标为0，因此B、C、D的双亲被记为0。同样，E、F的双亲为B，而B的存储位置下标为1，因此E、F的双亲被记为1。同理，其他节点也这样存储。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101905513.png)

（2）**孩子表示法**。除了存储数据元素，还存储其所有孩子的存储位置下标，如下图（b）所示。A有3个孩子B、C、D，而B、C、D的存储位置下标为1、2、3，因此将1、2、3存入A的孩子域。同样，B有两个孩子E、F，而E、F的存储位置下标为4、5，因此将4、5存入B的孩子域。在本题中，每个节点都被分配了3个孩子域（想一想为什么？），B只有两个孩子，另一个孩子域记为-1，表示不存在。同理，其他节点也这样存储。

（3）**双亲孩子表示法**。除了存储数据元素，还存储其双亲、所有孩子的存储位置下标，如下图（c）所示。其实**就是在孩子表示法的基础上增加了一个双亲域，其他的都和孩子表示法相同，是双亲表示法和孩子表示法的结合体**。


三种表示法的优缺点：
①双亲表示法只记录了每个节点的双亲，无法直接得到该节点的孩子；
②孩子表示法可以得到该节点的孩子，但是由于不知道每个节点到底有多少个孩子，因此==只能按照树的度（树中节点的最大度）分配孩子空间，这样做可能会浪费很多空间==；
③双亲孩子表示法是在孩子表示法的基础上增加了一个双亲域，可以快速得到节点的双亲和孩子，缺点和孩子表示法一样，可能浪费很多空间。
## 2. 链式存储
由于树中每个节点的孩子数量无法确定，因此**在使用链式存储时，孩子指针域不确定分配多少个合适**。如果采用“异构型”数据结构，将每个节点的指针域个数都按照节点的孩子数分配，则数据结构描述困难；如果采用每个节点都分配固定个数的指针域（例如树的度），则浪费很多空间。

可以考虑通过两种方法存储：一种采用邻接表的思路，**将节点的所有孩子（邻接点）都存储在一个单链表中，称之为孩子链表表示法**；另一种采用二叉链表的思路，左指针存储第1个孩子，右指针存储右兄弟，称之为**孩子兄弟表示法**。

1）孩子链表表示法
孩子链表表示法类似于邻接表，表头包含数据元素和指向第1个孩子指针，将所有孩子都放入一个单链表中。在表头中，data存储数据元素，first为指向第1个孩子的指针。单链表中的节点记录该节点的下标和下一个节点的地址。上图中的树，其孩子链表表示法如下图所示。

A有3个孩子B、C、D，而B、C、D的存储位置下标为1、2、3，因此将1、2、3放入单链表中，链接在A的first指针域。同样，B有2个孩子E、F，而E、F的存储位置下标为4、5，因此，将4、5放入单链表中，链接在B的first指针域。同理，其他节点也这样存储。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101910914.png)
在孩子链表表示法的基础上，如果在表头中再增加一个双亲域parent，则为**双亲孩子链表表示法**。

2）**孩子兄弟表示法**
节点除了存储数据元素，还存储两个指针域：lchild和rchild，称之为二叉链表。lchild存储第1个孩子的地址，rchild存储其右兄弟的地址。其节点的数据结构如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101911699.png)

- A有3个孩子B、C、D，其长子（第1个孩子）B作为A的左孩子，B的右指针存储其右兄弟C，C的右指针存储其右兄弟D。
- B有两个孩子E、F，其长子E作为B的左孩子，E的右指针存储其右兄弟F。
- C有1个孩子G，其长子G作为C的左孩子。
- D有两个孩子H、I，其长子H作为D的左孩子，H的右指针存储其右兄弟I。
- G有1个孩子J，其长子J作为G的左孩子。孩子兄弟表示法的秘籍：将长子当作左孩子，将兄弟关系向右斜。

# 5.3　树、森林与二叉树的转换
根据树的孩子兄弟表示法，任何一棵树都可转换为二叉链表存储形式。在二叉链表存储法中，每个节点都有两个指针域，也被称为二叉树表示法。这样，**任何树和森林都可以被转换为二叉树**，其存储方式就简单多了，这完美解决了树中孩子数量无法确定且难以分配空间的问题。

树转换为二叉树的秘籍：**将长子当作左孩子，将兄弟关系向右斜**。
## 1）树和二叉树的转换
根据树转换为二叉树的秘籍，可以把任何一棵树转换为二叉树，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101912417.png)
- A有3个孩子B、C、D，其长子B作为A的左孩子，三兄弟B、C、D在右斜线上。
- B有两个孩子E、F，其长子E作为B的左孩子，两兄弟E、F在右斜线上。
- D有两个孩子G、H，其长子G作为D的左孩子，两兄弟G、H在右斜线上。
- G有1个孩子I，其长子I作为G的左孩子。

那么怎么将二叉树还原为树呢？仍然根据树转换二叉树的秘籍，反操作即可，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101913039.png)

- B是A的左孩子，说明B是A的长子，B、C、D在右斜线上，说明B、C、D是兄弟，它们的父亲都是A。
- E是B的左孩子，说明E是B的长子，E、F在右斜线上，说明E、F是兄弟，它们的父亲都是B。
- G是D的左孩子，说明G是D的长子，G、H在右斜线上，说明G、H是兄弟，它们的父亲都是D。
- I是G的左孩子，说明I是G的长子。

## 2）森林和二叉树的转换
森林是由m（m≥0）棵不相交的树组成的集合。**可以把森林中的每棵树的树根都看作兄弟**，因此三棵树的树根B、C、D是兄弟，**兄弟关系在右斜线上**，其他的转换和树转二叉树一样，将长子当作左孩子，将兄弟关系向右斜。或者把森林中的每一棵树都转换成二叉树，然后把每棵树的根节点都连接在右斜线上即可。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101914672.png)

同理，二叉树也可以被还原为森林，如下图所示。**B、C、D在右斜线上，说明它们是兄弟，将其断开**，那么B和其子孙是第1棵二叉树；C是第2棵二叉树，那么D和其子孙是第3棵二叉树，再按照二叉树还原树的规则，将这3个二叉树分别还原为树即可。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306101916308.png)
由于在普通的树中，每个节点的子树个数不同，存储和运算都比较困难，因此==在实际应用中可以将树或森林转换为二叉树，然后进行存储和运算。二者存在唯一的对应关系，因此不影响其结果==。