二叉树（Binary Tree）是n（n≥0）个节点构成的集合，或为空树（n=0），或为非空树。对于非空树T，要满足：①有且仅有一个被称为根的节点；②除了根节点，其余节点分为两个互不相交的子集T1和T2，分别被称为T的左子树和右子树，且T1和T2本身都是二叉树。

二叉树是种特殊的树，它最多有两个子树，分别为左子树和右子树，二者是有序的，不可以互换。也就是说，在二叉树中不存在度大于2的节点。二叉树共有5种形态，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102139437.png)

二叉树的结构最简单，规律性最强，因此通常被重点讲解。
## 5.2.1 二叉树的性质性质
1：在二叉树的第i层上至多有 $2^{i-1}$ 个节点。一棵二叉树如下图所示。由于二叉树的每个节点最多有2个孩子，第1层树根为1个节点，第2层最多为2个节点，第3层最多有4个节点，因为上一层的每个节点最多有2个孩子，因此当前层最多是上一层节点数的两倍。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102140282.png)

下面使用数学归纳法证明。
- $i=1$ 时：只有一个根节点，$2^{i-1}=2^0=1$ 。
- $i>1$ 时：假设第 $i-1$ 层有 $2^{i-2}$ 个节点，而第 $i$层节点数最多是第 $i-1$层的两倍，即第i层节点数最多有 $2×2^{i-2}=2^{i-1}$ 。

性质2：深度为 $k$ 的二叉树至多有 $2^{k}-1$ 个节点。
证明：如果深度为k的二叉树，每一层都达到最大节点数，如下图所示，则把每一层的节点数加起来就是整棵二叉树的最大节点数。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102146600.png)

性质3：对于任何一棵二叉树，若叶子数为n0，度为2的节点数为n2，则n0=n2+1。

证明：二叉树中的节点度数不超过2，因此共有3种节点：度为0、度为1、度为2。设二叉树总的节点数为n，度为0的节点数为n0，度为1的节点数为n1，度为2的节点数为n2，总节点数等于三种节点数之和，即n=n0+n1+n2。

而总节点数又等于分支数b+1，即n=b+1。为什么呢？如下图所示，从下向上看，每一个节点都对应一个分支，只有树根没有对应的分支，因此总的节点数为分支数b+1。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102147910.png)
而分支数b怎么计算呢？从上向下看，如下图所示，每个度为2的节点都产生2个分支，度为1的节点产生1个分支，度为0的节点没有分支，因此分支数b=n1+2n2，则n=b+1=n1+2n2+1。而前面已经得到n=n0+n1+n2，两式联合得：n0=n2+1。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102155471.png)

有两种比较特殊的二叉树：满二叉树和完全二叉树。
- 满二叉树：一棵深度为k且有2k-1个节点的二叉树。满二叉树的每一层都“充满”了节点，达到最大节点数，如下图所示。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102156891.png)
- 完全二叉树：除了最后一层，每一层都是满的（达到最大节点数），最后一层节点是从左向右出现的。深度为k的完全二叉树，当且仅当其每一个节点都与深度为k的满二叉树中编号为1～n的节点一一对应。例如，完全二叉树如下图所示，它和上图中的满二叉树编号一一对应。完全二叉树除了最后一层，前面每一层都是满的，最后一层必须从左向右排列。也就是说，如果2没有左孩子，就不可以有右孩子，如果2没有右孩子，则3不可以有左孩子。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102156348.png)
     
性质4：具有n个节点的完全二叉树的深度必为 $⌊\log_2n⌋ + 1$ 。证明：假设完全二叉树的深度为k，那么除了最后一层，前k-1层都是满的，最后一层最少有一个节点，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102157583.png)

最后一层最多也可以充满节点，即 $2^{k-1}$ 个节点，如下图所示。

因此，$2^{k-1}≤n≤2^k-1$ ，右边放大后，$2^{k-1}≤n<2^k$ ，同时取对数，$k-1≤ \log_2n<k$ ，所以 $k=⌊ \log_2n⌋ +1$ 。其中，$⌊⌋$ 表示取下限，$⌊x⌋$ 表示小于x的最大整数，如 $⌊3.6⌋=3$ 。

例如，一棵完全二叉树有10个节点，那么该完全二叉树的深度为 $k=⌊\log_2 10⌋+1=4$ 。

性质5：对于完全二叉树，若从上至下、从左至右编号，则编号为 $i$ 的节点，其左孩子编号必为 $2i$ ，其右孩子编号必为 $2i＋1$ ；其双亲编号必为 $i/2$。

完全二叉树的编号如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102201366.png)
例如，一棵完全二叉树如下图所示。节点2的双亲节点为1，左孩子为4，右孩子为5；节点3的双亲节点为1，左孩子为6，右孩子为7。

例题1：一棵完全二叉树有1001个节点，其中叶子节点的个数是多少？首先找到最后一个节点1001的双亲节点，其双亲节点编号为1001/2=500，该节点是最后一个拥有孩子的节点，其后面全是叶子，即1001-500=501个叶子。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102202457.png)

例题2：一棵完全二叉树第6层有8个叶子，则该完全二叉树最少有多少个节点，最多有多少个节点？完全二叉树的叶子分布在最后一层或倒数第二层。因此该树有可能为6层或7层。节点最少的情况（6层）：8个叶子在最后一层（即第6层），前5层是满的，如下图所示。最少有25-1+8=39个节点。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102202771.png)

节点最多的情况（7层）：8个叶子在倒数第2层（即第6层），前6层是满的，第7层最少缺失了8×2个节点，因为第6层的8个叶子如果生成孩子的话，会有16个节点。如下图所示，最多有27-1-16=111个节点。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102203751.png)
## 5.2.2　二叉树的存储结构
二叉树的存储结构分为两种：顺序存储结构和链式存储结构，下面一一进行讲解。
### 1. 顺序存储结构
二叉树可以采用顺序存储结构，按完全二叉树的节点层次编号，依次存放二叉树中的数据元素。完全二叉树很适合顺序存储结构，下面左图中的完全二叉树的顺序存储结构如右图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102204971.png)

普通二叉树进行顺序存储时需要被补充为完全二叉树，在对应的完全二叉树没有孩子的位置补0，其顺序存储结构如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102206178.png)
显然，普通二叉树不适合采用顺序存储结构，因为有可能在补充为完全二叉树的过程中，补充了太多的0，而浪费了大量的空间。因此普通二叉树可以使用链式存储结构。

**用 `l[]` 和 `r[]` 分别说明左右子树是谁**，还要指明树根。不用定义结构体和指针。
### 2. 链式存储结构
二叉树最多有两个“叉”，即最多有两棵子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102206588.png)

二叉树采用链式存储结构时，每个节点都包含一个数据域，存储节点信息；还包含两个指针域，指向左右两个孩子。这种存储方式被称为二叉链表，结构如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102206199.png)
二叉链表节点的结构体定义如下图所示。 
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102207667.png)

那么下面左图中的二叉树可被存储为二叉链表形式，如下面右图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102207863.png)

一般情况下，二叉树采用二叉链表存储即可，但是在实际问题中，如果经常需要访问双亲节点，**二叉链表存储则必须从根节点出发查找其双亲节点，这样做非常麻烦**。例如在上图中，如果想找F的双亲，就必须从根节点A出发，访问C，再访问F，此时才能返回F的双亲为C。**为了解决该问题，可以增加一个指向双亲节点的指针域**，这样每个节点就包含三个指针域，分别指向两个孩子节点和双亲节点，还包含一个数据域，存储节点信息。这种存储方式被称为三叉链表，结构如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102208458.png)

三叉链表节点的结构体定义如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102209138.png)

那么下面左图中的二叉树也可以被存储为三叉链表形式，如下面右图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102210888.png)
## 5.2.3　二叉树的创建
如果对二叉树进行操作，必须先创建一棵二叉树。如何创建一棵二叉树呢？从二叉树的定义就可以看出，它是递归定义的（除了根，左、右子树也各是一棵二叉树），因此也可以用递归程序来创建二叉树。递归创建二叉树有两种方法：询问法和补空法。
### 1. 询问法
**按照先序遍历的顺序**，每次输入节点信息后，都询问是否创建该节点的左子树，如果是，则递归创建其左子树，否则其左子树为空；询问是否创建该节点的右子树，如果是，则递归创建其右子树，否则其右子树为空。算法步骤：
（1）输入节点信息，创建一个节点T。
（2）询问是否创建T的左子树，如果是，则递归创建其左子树，否则其左子树为NULL。
（3）询问是否创建T的右子树，如果是，则递归创建其右子树，否则其右子树为NULL。

完美图解：一棵二叉树如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102210419.png)
该二叉树的创建过程如下。
（1）请输入节点信息：A。创建节点A，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102211079.png)
（2）是否添加A的左孩子? (Y/N)：Y。
（3）请输入节点信息：B。创建节点B，作为A的左孩子，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102212765.png)
（4）是否添加B的左孩子? (Y/N)：Y。
（5）请输入节点信息：D。创建节点D，作为B的左孩子，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102212690.png)

（6）是否添加D的左孩子? (Y/N)：N。
（7）是否添加D的右孩子? (Y/N)：N。D左右孩子均为空，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102213376.png)

（8）是否添加B的右孩子? (Y/N)：Y。
（9）请输入节点信息：E。创建节点E，作为B的右孩子，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102213415.png)

（10）是否添加E的左孩子? (Y/N)：N。
（11）是否添加E的右孩子? (Y/N)：N。E左右孩子均为空，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102214931.png)

（12）是否添加A的右孩子? (Y/N)：Y。
（13）请输入节点信息：C。创建节点C，作为A的右孩子，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102215325.png)

（14）是否添加C的左孩子? (Y/N)：Y。
（15）请输入节点信息：F。创建节点F，作为C的左孩子，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102215111.png)
（16）是否添加F的左孩子? (Y/N)：N。F的左孩子为空。
（17）是否添加F的右孩子? (Y/N)：Y。
（18）请输入节点信息：G。创建节点G，作为F的右孩子，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102215572.png)
（19）是否添加G的左孩子? (Y/N)：N。
（20）是否添加G的右孩子? (Y/N)：N。G左右孩子均为空，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102216329.png)
（21）是否添加C的右孩子? (Y/N)：N。C右孩子为空，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102216756.png)
（22）二叉树创建完毕。算法代码：
```cpp
void createTree(Btree &T) { // 创建二叉树函数（询问法）
    char check; // 判断是否创建左右孩子
    T = new Bnode;
    cout << "输入节点信息：" << endl; // 输入根节点数据
    cin >> T->data;
    cout << "是否添加" << T->data << "的左孩子？(Y/N)" << endl; // 询问创建T的左子树
    cin >> check;
    if (check == 'Y') createTree(T->lchild);
    else T->lchild = NULL;
    
    cout << "是否添加" << T->data << "的右孩子？(Y/N)" << endl; // 询问创建T的右子树
    cin >> check;
    if (check == 'Y') createTree(T->rchild);
    else T->rchild = NULL;
}
```
### 2. 补空法
补空法指如果左子树或右子树为空，则用特殊字符补空，例如“#”。然后按照先序遍历的顺序，得到先序遍历序列，根据该序列递归创建二叉树。

算法步骤：
（1）输入补空后的二叉树先序遍历序列。
（2）如果 `ch=='#'` ，则 `T=NULL` ；否则创建一个新节点T，令T->data=ch；递归创建T的左子树；递归创建T的右子树。

完美图解：一棵二叉树，将该二叉树补空，在孩子为空时补上特殊符号“#”，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102220966.png)
二叉树补空后的先序遍历结果为 `ABD##E##CF#G###` 。该二叉树的创建过程如下。
（1）读取先序序列的第1个字符“A”，创建一个新节点，如下图所示。然后递归创建A的左子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102221911.png)
（2）读取先序序列的第2个字符“B”，创建一个新节点，作为A的左子树，如下图所示。然后递归创建B的左子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102222434.png)

（3）读取先序序列的第3个字符“D”，创建一个新节点，作为B的左子树，如下图所示。然后递归创建D的左子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102222451.png)

（4）读取先序序列的第4个字符“#”，说明D的左子树为空，如下图所示。然后递归创建D的右子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102222729.png)
（5）读取先序序列的第5个字符“#”，说明D的右子树为空，如下图所示。然后递归创建B的右子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102222709.png)
（6）读取先序序列的第6个字符“E”，创建一个新节点，作为B的右子树，如下图所示。然后递归创建E的左子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102222273.png)
（7）读取先序序列的第7个字符“#”，说明E的左子树为空，如下图所示。然后递归创建E的右子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102223502.png)
（8）读取先序序列的第8个字符“#”，说明E的右子树为空，如下图所示。然后递归创建A的右子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102223933.png)
（9）读取先序序列的第9个字符“C”，创建一个新节点，作为A的右子树，如下图所示。然后递归创建C的左子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102223361.png)

（10）读取先序序列的第10个字符“F”，创建一个新节点，作为C的左子树，如下图所示。然后递归创建F的左子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102225319.png)
（11）读取先序序列的第11个字符“#”，说明F的左子树为空，如下图所示。然后递归创建F的右子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102226267.png)
（12）读取先序序列的第12个字符“G”，创建一个新节点，作为F的右子树，如下图所示。然后递归创建G的左子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102226712.png)
（13）读取先序序列的第13个字符“#”，说明G的左子树为空，如下图所示。然后递归创建G的右子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102226363.png)
（14）读取先序序列的第14个字符“#”，说明G的右子树为空，如下图所示。然后递归创建C的右子树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102227045.png)
（15）读取先序序列的第15个字符“#”，说明C的右子树为空，如下图所示。序列读取完毕，二叉树创建成功。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306102227825.png)
算法代码：
```cpp
void createTree(Btree &T) { // 创建二叉树函数（补空法）
    char ch;
    cin >> ch; // 二叉树补空后，按先序遍历序列输入字符
    if (ch == '#') T = NULL; // 空树
    else {
        T = new Bnode;
        T->data = ch;
        createTree(T->lchild); // 递归创建左子树
        createTree(T->rchild); // 递归创建右子树
    }
}
```