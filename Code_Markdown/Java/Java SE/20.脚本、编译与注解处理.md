▲Java平台的脚本机制
▲编译器API
▲注解语法
▲标准注解
▲使用注解
▲源码级注解处理
▲字节码工程

这里介绍**三种用于处理代码的技术**：
- **脚本API**使你可以调用诸如JavaScript和Groovy这样的脚本语言代码；
- 当你希望在你的应用程序内部编译Java代码时，可以使用**编译器API**；
- **注解处理器**可以在**包含注解 *annotations* 的Java源代码和类文件**上进行操作（包括向Java程序中添加注解、设计自己的注解接口、实现处理注解的工具）。
  如你所见，有许多应用程序都可以用来处理注解，从简单的诊断到==“字节码工程”，后者可以将字节码插入到类文件中，甚至可以插入到运行程序中== *"bytecode engineering"—the insertion of bytecodes into class files or even running programs* 。

编写脚本、编译Java程序和处理注解中，前两种技术十分简单，另一方面，构建注解工具可能会很复杂，但这并非是大多数开发者都需要解决的问题。这里介绍一些背景知识，有助于去理解可能会碰到的注解工具内部工作机制。

---
# 20.1 Java平台的脚本机制
==脚本语言是一种「通过在运行时解释程序文本、从而避免使用通常的编辑/编译/链接/运行循环」的语言==。脚本语言有许多优势：
- 便于快速变更，鼓励不断试验。
- 可以修改运行着的程序的行为。
- 支持程序用户来定制化。

另一方面，大多数脚本语言都缺乏使编写复杂应用受益的特性，例如强类型、封装和模块化。

因此，人们在**尝试将脚本语言和传统语言的优势相结合**。脚本API使你可以在Java平台上实现这个目的，==它支持在Java程序中对用JavaScript、Groovy、Ruby，甚至是更奇异的诸如Scheme和Haskell等语言编写的脚本进行调用==。例如，[Renjin项目](http://www.renjin.org)提供了一个R编程语言的Java实现和相应的脚本API的“引擎”。至于另一个方向，即从脚本语言中访问Java则属于脚本语言提供商的职责。大多数运行在Java虚拟机上的脚本语言都具有这种能力。

下面展示如何为某种特定的语言**选择一个引擎**，如何**执行脚本**，以及如何**利用某些脚本引擎提供的先进特性**。

## 20.1.1 获取脚本引擎
==脚本引擎是一个「可执行用某种特定语言编写的脚本」的类库==。当虚拟机启动时，它会发现可用的脚本引擎。为了枚举这些引擎，需要构造一个 `ScriptEngineManager` ，并调用 `getEngineFactories` 方法。可以向每个引擎工厂去询问它们所支持的引擎名、MIME类型和文件扩展名。表20-1显示了这些内容的典型值。
![表20-1 脚本引擎工厂的属性](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211270316229.png)
通常，你知道所需要的引擎，因此**可以直接通过名字、MIME类型或文件扩展来请求它**，例如：
```java
ScriptEngine engine = manager.getEngineByName("nashorn");
```

Java 7包含Rhino的一个版本，这是由Mozilla基金开发的一个JavaScript解释器。Java 8引入了Nashorn，这是由Oracle开发的一个JavaScript解释器。都可**通过在类路径中提供必要的JAR文件、来添加对更多语言的支持**。这时，==一般需要两个JAR文件集合，脚本语言自身是由「单个的JAR文件或一个JAR集合」实现的，而将这种语言适配到脚本API的引擎通常还需要一个额外的JAR==。http://java.net/projects/scripting站点提供的引擎可以适用于大量的脚本语言，例如，为了添加对Groovy的支持，类路径必须包含 `groovy/lib/*`（来自http://groovy.codehaus.org）和 `groovy-engine.jar`（来自http://java.net/projects/scripting）。

> [API] `javax.script.ScriptEngineManager` 6
> - `List<ScriptEngineFactory> getEngineFactories()`
> 获取所有发现的引擎工厂的列表。
> - `ScriptEngine getEngineByName(String name)`
> - `ScriptEngine getEngineByExtension(String extension)
> - `ScriptEngine getEngineByMimeType(String mimeType)
> 获取给定名字、脚本文件扩展名或MIME类型的脚本引擎。

> [API] `javax.script.ScriptEngineFactory` 6
> - `List<String> getNames()`
> - `List<String> getExtensions()`
> - `List<String> getMimeTypes()`
> 获取该工厂所了解的名字、脚本文件扩展名和MIME类型。

## 20.1.2 脚本赋值与绑定
一旦拥有了引擎，就可以**通过下面的调用来直接调用脚本**：
```java
Object result = engine.eval(scriptString);
```
如果脚本存储在文件中，那么需要先打开一个 `Reader` ，然后调用：
```java
Object result = engine.eval(reader);
```
**可以在同一个引擎上调用多个脚本**。如果一个脚本定义了变量、函数或类，那么大多数引擎都会保留这些定义，以供将来使用。例如下面将返回1729：
```java
engine.eval("n = 1728");
Object result = engine.eval("n + 1");
```

要想知道在多个线程中并发执行脚本是否安全，可以调用
```java
Object param = factory.getParameter("THREADING");
```
其返回的是下列值之一：
- `null` ：并发执行不安全。
- `"MULTITHREADED"` ：并发执行安全。一个线程的执行效果对另外的线程有可能是可视的。
- `"THREAD-ISOLATED"` ：除了 `"MULTITHREADED"` 之外，会为每个线程维护不同的变量绑定 *different variable bindings are maintained for each thread*。
- `"STATELESS"` ：除了 `"THREAD-ISOLATED"` 之外，脚本不会改变变量绑定。

经常希望能**向引擎中添加新的变量绑定**。绑定由名字及其关联的Java对象构成。例如，考虑下面的语句：
```java
engine.put("k", 1728);
Object result = engine.eval("k + 1");
```
脚本代码从“**引擎作用域** *engine scope*”中的绑定里、读取 `k` 的定义。这一点非常重要，因为大多数脚本语言都可以**访问Java对象**，通常使用的是比Java语法更简单的语法。例如，
```java
engine.put("b", new JButton());
engine.eval("b.text = 'Ok'");
```
反过来，也可以**获取由脚本语句绑定的变量**：
```java
engine.eval("n = 1728");
Object result = engine.get("n");
```
除了引擎作用域之外，还有**全局作用域**。**任何添加到 `ScriptEngineManager` 中的绑定对所有引擎都是可视的**。

**除了向引擎或全局作用域添加绑定之外，还可以将绑定收集到一个类型为 `Bindings` 的对象中**，然后将其传递给 `eval` 方法：
```java
Bindings scope = engine.createBindings();
scope.put("b", new JButton());
engine.eval(scriptString, scope);
```
如果一个绑定集 *set of bindings* 不应为了将来对 `eval` 方法的调用而进行持久化 *persist for future calls to the eval method*，那么这么做就很有用（？）。

注意：可能希望除了引擎作用域和全局作用域之外，还有其他的作用域。例如，Web容器可能需要请求作用域或会话作用域。但这需要你自己去解决——**需要实现一个类，它实现了 `ScriptContext` 接口，并管理着一个作用域集合**。每个作用域都是由一个整数标识的，而且越小的数字应越先被搜索。标准类库提供了 `SimpleScriptContext` 类，但它只能持有全局作用域和引擎作用域。
> [API] `javax.script.ScriptEngine` 6
> - `Object eval(String script)`
> - `Object eval(Reader reader)`
> - `Object eval(String script, Bindings bindings)`
> - `Object eval(Reader reader, Bindings bindings)`
> 对由字符串或读取器给定的脚本赋值，并服从给定的绑定 *subject to the given bindings* 。
> - `Object get(String key)`
> - `void put(String key, Object value)`
> 在引擎作用域内获取或放置一个绑定。
> - `Bindings createBindings()`
> 创建一个适合该引擎的空 `Bindings` 对象。

> [API] `javax.script.ScriptEngineManager` 6
> - `Object get(String key)`
> - `void put(String key, Object value)`
> 在全局作用域内获取或放置一个绑定。

> [API] `javax.script.Bindings` 6
> - `Object get(String key)`
> - `void put(String key, Object value)`
> 在由该 `Bindings` 对象表示的作用域内，获取或放置一个绑定。

## 20.1.3 重定向输入和输出
可以通过调用脚本上下文 *context* 的 `setReader` 和 `setWriter` 方法，来重定向脚本的标准输入和输出。例如，
```java
var writer = new StringWriter();
engine.getContext().setWriter(new PrintWriter(writer, true));
```
在上例中，任何用JavaScript的 `print` 和 `println` 函数产生的输出都会被发送到 `writer` 。
> 警告：可以向 `setWriter` 方法传递任何 `Writer` ，但是如果传递的不是 `PrintWriter` ，Rhino引擎会抛出异常。

**`setReader` 和 `setWriter` 方法，只会影响脚本引擎的标准输入和输出源**。例如，如果执行下面的JavaScript代码，则只有第一个输出会被重定向：
```java
println("Hello");
java.lang.System.out.println("World");
```
Rhino和Nashorn引擎没有标准输入源的概念，因此调用 `setReader` 没有任何效果。

> [API] `javax.script.ScriptEngine` 6
> - `ScriptContext getContext()`
> 获得该引擎的默认的脚本上下文。
> [API] `javax.script.ScriptContext` 6
> - `Reader getReader()`
> - `void setReader(Reader reader)`
> - `Writer getWriter()`
> - `void setWriter(Writer writer)`
> - `Writer getErrorWriter()`
> - `void setErrorWriter(Writer writer)`
> 获取或设置用于输入的读入器、或用于正常与错误输出的写出器。
## 20.1.4 调用脚本的函数和方法
在使用许多脚本引擎时，都可以调用脚本语言的函数 *invoke a function in the scripting language* ，而不必求值实际的脚本代码 *evaluate the actual script code* 。如果允许用户用他们所选择的脚本语言来实现服务，那么这种机制就很有用了。

提供这种功能的脚本引擎实现了 `Invocable` 接口。特别是，Rhino和Nashorn引擎就实现了 `Invocable` 接口。

**要调用一个函数，需要用函数名来调用 `invokeFunction` 方法**，函数名后面是函数的参数：
```java
// Define greet function in JavaScript
engine.eval("function greet(how, whom) { return how + ', ' + whom + '!' }");
```
如果脚本语言是面向对象的，那就可以像下面这样调用方法：
```java
// Call the function with arguments "Hello", "World"
result = ((Invocable) engine).invokeFunction("greet", "Hello", "World");
```
如果脚本语言是面向对象的，就可以调用 `invokeMethod` ：
```java
// Define Greeter class in JavaScript
engine.eval("function Greeter(how) { this.how = how }");
engine.eval("Greeter.prototype.welcome = " 
	+ " function(whom) { return this.how + ', ' + whom + '!' }");

// Construct an instance
Object yo = engine.eval("new Greeter('Yo')");

// Call the welcome method on the instance
result = ((Invocable) engine).invokeMethod(yo, "welcome", "World");
```
> 注释：关于如何用JavaScript定义类的更多细节，参阅 *JavaScript—The Good Parts by Douglas Crockford* 或 *JavaScript—The Definitive Guide, David Flanagan* 。

> 注释：即使脚本引擎没有实现 `Invocable` 接口，你也可能仍旧能以一种独立于语言的方式来调用某个方法。`ScriptEngineFactory` 类的 `getMethodCallSyntax` 方法可以产生一个字符串，你可以将其传递给 `eval` 方法。但，所有的方法参数都必须与名字绑定，而 `invokeMethod` 方法是可以用任意值调用的。

可以==更进一步，让脚本引擎去实现一个**Java接口**，然后就可以用Java方法调用的语法来调用**脚本函数**==。其细节依赖于脚本引擎，但典型情况是**我们需要为该接口中的每个方法都提供一个函数**。例如，考虑下面的Java接口：
```java
public interface Greeter {
	String welcome(String whom);
}
```
如果在Nashorn中定义了具有相同名字的函数，那么可通过这个接口来调用它：
```java
// Define welcome function in JavaScript
engine.eval("function welcome(whom) { return 'Hello, ' + whom + '!' }");

// Get a Java object and call a Java method
Greeter g = ((Invocable) engine).getInterface(Greeter.class);
result = g.welcome("World");
```
> 在幕后，JavaScript的 `greet` 方法将被调用。这种方式与后面讨论的产生远程方法调用类似。

==在面向对象的脚本语言中，可以通过相匹配的**Java接口**来访问一个**脚本类**==。例如，考虑下面的JavaScript代码，它展示了如何使用Java语法、来调用JavaScript的 `Greeter` 类：
```java
Greeter g = ((Invocable) engine).getInterface(yo, Greeter.class);
result = g.welcome("World");
```

总之，如果你希望从Java中调用脚本代码，同时又不想因这种脚本语言的语法而受到困扰，那么 `Invocable` 接口就很有用。
> [API] `javax.script.Invocable` 6
> - `Object invokeFunction(String name, Object... parameters)`
> - `Object invokeMethod(Object implicitParameter, String name, Object... explicitParameters)`
> 用给定的名字调用函数或方法，并传递给定的参数。
> - `<T> T getInterface(Class<T> iface)`
> 返回给定接口的实现，该实现用脚本引擎中的函数实现了接口中的方法。
> - `<T> T getInterface(Object implicitParameter, Class<T> iface)
> 返回给定接口的实现，该实现用给定对象的方法实现了接口中的方法。

## 20.1.5 编译脚本
**某些脚本引擎出于对执行效率的考虑，可将脚本代码编译为某种中间格式。这些引擎实现了 `Compilable` 接口**。下面的示例展示了、如何编译和计算包含在脚本文件中的代码：
```java
var reader = new FileReader("myscript.js");
CompiledScript script = null;

if (engine implements Compilable)
	script = ((Compilable) engine).compile(reader);
```
一旦该脚本被编译，就可以执行它。下面代码将会在编译成功的情况下，执行编译后的脚本，如果引擎不支持编译，则执行原始的脚本。
```java
if (script != null)
	script.eval();
else
	engine.eval(reader);
```
当然，**只有需要重复执行时，我们才希望编译脚本**。
> [API] `javax.script.Compilable` 6
> - `CompiledScript compile(String script)`
> - `CompiledScript compile(Reader reader)`
> 编译由字符串或读入器给定的脚本。
> [API] `javax.script.CompiledScript` 6
> - `Object eval()`
> - `Object eval(Bindings bindings)`
> 对该脚本计算。
 
## 20.1.6 一个示例：用脚本处理GUI事件
为了演示脚本API，开发一个样例程序，它允许用户指定使用「他们所选择的脚本语言」编写的事件处理器。

看看下面的程序，它可以将脚本添加到任意的框体类中。默认情况下，它会读取下面的 `ButtonFrame` 类，`ButtonFrame` 类与卷I中介绍的事件处理演示程序类似，但有两个差异：
- 每个构件都有其自己的 `name` 属性集。
- 没有任何事件处理器。
```java
// script/ScriptTest.java
package script;

import java.awt.*;
import java.beans.*;

import java.io.*;
import java.lang.reflect.*;
import java.util.*;

import javax.script.*;
import javax.swing.*;

public class ScriptTest {
	public static void main(String[] args) {
		EventQueue.invokeLater(() -> {
			try {
				var manager = new ScriptEngineManager();
				String language;
				if (args.length == 0) {
					System.out.println("Available factories: ");
					for (ScriptEngineFactory factory : manager.getEngineFactories()) 
						System.out.println(factory.getEngineName());
					language = "nashorn";
				} else language = args[0];

				final ScriptEngine = engine = manager.getEngineByName(language);
				if (engine == null) {
					System.err.println("No engine for " + language);
					System.exit(1);
				}

				final String frameClassName = 
					args.length < 2 ? "buttons1.ButtonFrame" : args[1];
				var frame = 
					(JFrame) Class.forName(frameClassName).getConstructor().newInstance();
				InputStream in = frame.getClass().getResourceAsStream("init." + language);
				if (in != null) engine.eval(new InputStreamReader(in));
				
				var components = new HashMap<String, Component>();
				getComponentBindings(frame, components);
				components.forEach((name, c) -> engine.put(name, c));

				var evenets = new Properties();
				in = frame.getClass().getResourceAsStream(language + ".properties");
				events.load(in);

				for (Object e : events.keySet()) {
					String[] s = ((String) e).split("\\.");
					addListener(s[0], s[1], (String) events.get(e), engine, compoents);
				}
				frame.setTitle("ScriptTest");
				frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				frame.setVisible(true);
			} catch (ReflectiveOperationException | IOException | ScriptException | IntrospectionException ex) {
				ex.printStackTrace();
			}
		})
	}
	
    /**
	 * Gathers all named components in a container
	 * @param c the component
	 * @param namedComponents a map into which to enter the component names and componets
	 */
	private static void getComponentsBindings(Component c, Map<String, Component> namedComponents) {
		String name = c.getName();
		if (name != null) { namedComponents.put(name, c); }
		if (c instanceof Container) {
			for (Component child : ((Container) c).getComponents())
				getComponentsBindings(child, namedComponents);
		}
	}

	/**
	 * Adds a listener to an object whose listener method executes a script.
	 * @param beanName the name of the bean to which the listener should be added
	 * @param eventName the name of the listener type, such as "action" or "change"
	 * @param scriptCode the script code to be executed
	 * @param engine the engine that executes the code
	 * @param bindings the bindings for the execution
	 * @throws IntrospectionException
	 */
	private static void addListener(String beanName, String eventName, final String scriptCode, 
		ScriptEngine engine, Map<String, Component> components)
		throws ReflectiveOperationException, IntrospectionException {
		Object bean = components.get(beanName);
		EventSetDescriptor descriptor = getEventSetDescriptor(bean, eventName);
		if (descriptor == null) return;
		descriptor.getAddListenerMethod().invoke(bean,
			Proxy.newProxyInstance(null, new Class[] { descriptor.getListenerType() },
			(proxy, method, args) -> {
				engine.eval(scriptCode);
				return null;
			})
		);
	}

	private static EventSetDescriptor getEventSetDescriptor(Object bean, String eventName) 
		throws IntrospectionException {
		for (EventSetDescriptor descriptor : Introspector.getBeanInfo(bean.getClass())
			.getEventSetDescriptors())
			if (descriptor.getName().equals(eventName))
				return descriptor;
		return null;	
	}
}
```
```java
// buttons/ButtonFrame.java
package buttons1;
import javax.swing.*;

/**
 * A frame with a button panel.
 */
public class ButtonFrame extends JFrame {
	private static final int DEFAULT_WIDTH = 300;
	private static final int DEFAULT_HEIGHT = 200;
	private JPanel panel;
	private JButton yellowButton;
	private JButton blueButton;
	private JButton redButton;

	public ButtonFrame() {
		setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);
		panel = new JPanel();
		panel.setName("panel");
		add(panel);

		yellowButton = new JButton("Yellow");
		yellowButton.setName("yellowButton");
		blueButton = new JButton("Blue");
		blueButton.setName("blueButton");
		redButton = new JButton("Red");
		redButton.setName("redButton");

		panel.add(yellowButton);
		panel.add(blueButton);
		panel.add(redButton);
	}
}
```
事件处理器是在属性文件中定义的。每个属性定义都具有下面的形式：
```java
componentName.eventName = scriptCode
```
例如，如果选择使用JavaScript，那就要在 `js.properties` 文件中提供事件处理器：
```java
yellowButton.action=panel.background = java.awt.Color.YELLOW
blueButton.action=panel.background = java.awt.Color.BLUE
redButton.action=panel.background = java.awt.Color.RED
```
附带代码还包括用于Groovy和SISC Scheme的文件。

该程序以「加载在命令行中指定的语言所需的引擎」开始，如果未指定语言，则使用JavaScript。然后处理 `init.language` 脚本，如果有该文件的话。这对R和Scheme语言很有用，因为这些语言需要某些麻烦的初始化工作，我们不希望在每个事件处理器的脚本中都包括这部分工作。

接下来，递归地遍历所有的子构件，并在构件映射表中添加(名字，对象)绑定，然后将它们添加到引擎作用域中。

然后读入 `language.properties` 文件。对于每一个属性，都**合成其事件处理器代理**，使脚本代码可执行。其细节有些技术性，如果希望了解实现的细节，阅卷I章6代理，和卷II章8有关JavaBean事件。但其精髓部分还是**每个事件处理器都会调用下面的方法**：
```java
engine.eval(scriptCode);
```

详细看看 `yellowButton` 。当下面一行被处理时，
```java
yellowButton.action=panel.background = java.awt.Color.YELLOW
```
我们找到了具有"yellowButton"名字的 `JButton` 构件，然后附着一个 `ActionListener` ，它拥有 `actionPerformed` 方法，该方法将执行下面的脚本。
```java
panel.background = java.awt.Color.YELLOW
```
引擎包含一个将名字 `panel` 与这个 `JPanel` 对象绑定在一起的绑定。当事件发生时，该面板的 `setBackground` 方法就会执行，并且其颜色也会改变。

只需要执行下面的调用，就可以用JavaScript事件处理器运行这个程序：
```bash
$ java ScriptTest
```
对于Groovy处理器，需要使用：
```bash
$ java -classpath .:groovy/lib/\* ScriptTest groovy
```
这里，`groovy` 是Groovy的安装目录。

对于R的Renjin实现，要在类路径中包含Renjin Studio的JAR文件、以及Renjin脚本引擎，它们都可在www.renjin.org/downloads.html处获得。

这个应用演示了如何在Java GUI编程中使用脚本机制。可以更进一步，==用XML文件来描述GUI==，像在第3章看到的那样。==然后我们的程序将成为GUI的解释器，这些GUI具有由XML定义的可视化表示和由脚本语言定义的行为==。注意，这与动态HTML页面、或动态服务器端脚本环境之间的相似性。

--- 
# 20.2 编译器API
前面看到了如何与「用脚本语言编写的代码」进行交互。现在转向不同的场景：有许多工具都需要调用Java编译器、编译Java代码。例如：
- Java编程的开发环境、教学和辅导程序。
- 测试和自动化构建工具。
- 处理Java代码段的模板工具，例如JavaServer Pages, JSP（一种嵌入了Java语句的网页）。

过去，应用程序是通过在 `jdk/lib/tools.jar` 类库中未归档的类调用Java编译器的。==从Java 6开始，用于编译的一个公共API成为Java平台的一部分==，并且它再也不需要使用 `tools.jar` 了。本节解释这个编译器API。
## 20.2.1 调用编译器
调用编译器非常简单，下面是一个示范调用，返回值为0表示编译成功：
```java
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
OutputStream outStream = ...;
OutputStream errStream = ...;
int result = compiler.run(null, outStream, errStream,
"-sourcepath", "src", "Test.java");
```
编译器会向提供给它的流发送输出和错误消息。如果将这些参数设置为 `null` ，就会使用 `System.out, System.err` 。`run` 方法的第一个参数是输入流，**由于编译器不会接受任何控制台输入，因此总是应该让其保持为 `null`**（ `run` 方法是从泛化的 `Tool` 接口继承而来的，它考虑到某些工具需要读取输入，才有这个参数）。

如果在命令行调用 `javac` ，那么 `run` 方法其余的参数就会作为变量传递给 `javac` 。这些变量是一些选项或文件名。

## 20.2.2 使用编译工具、发起编译任务、捕获诊断信息
**可通过使用 `CompilationTask` 对象、来对编译过程进行更多的控制**。特别是，你可以：
- **控制程序代码的来源**，例如，在字符串构建器 *string builder* 而不是文件中提供代码。
- **控制类文件的位置**，例如，存储在数据库中。
- 监听在编译过程中产生的错误和警告信息。
- 在后台运行编译器。

**源代码和类文件的位置是由 `JavaFileManager` 控制的**，它负责确定**源代码和类文件的 `JavaFileObject` 实例**——`JavaFileObject` 可以**对应于磁盘文件，或可以提供读写其内容的其他机制**。

想获取 `CompilationTask` 对象，就要以前一节描述的 `Compiler` 对象开始，然后按照下面的方式调用 `JavaCompiler` 类的 `getTask` 方法，这时需要指定（要为最后三个参数提供 `Iterable` 对象）：
- 一个用于所有编译器输出的 `Writer` ，它不会将输出作为 `Diagnostic` 报告。如果是 `null` ，则使用 `System.err` 。
- 一个 `JavaFileManager` ，如果为 `null` ，则使用编译器的标准文件管理器。
- 一个 `DiagnosticListener` 。
- 选项字符串，如果没有选项，则为 `null` 。
- 用于注解处理的类名字，如果没有指定类名字，则为 `null` 。
- 用于源文件的 `JavaFileObject` 实例。
```java
JavaCompiler.CompilationTask task = compiler.getTask(
	errorWriter, // Uses System.err if null
	fileManager, // Uses the standard file manager if null
	diagnostics, // Uses System.err if null
	options, // null if no options
	classes, // For annotation processing; null if none
	sources
);
```
由于最后三个参数是 `Iterable` 的实例，选项序列可以如下指定：
```java
Iterable<String> options = List.of("-d", "bin");
```
`classes` 参数只用于注解处理，这种情况下，还需要用一个 `Processor` 对象的列表、来调用 `task.processors(annotationProcessors)` 。见20.6节注解处理的示例。
**`sources` 参数是可以迭代 `JavaFileObject` 实例的 `Iterable`** *an Iterable of JavaFileObject instances* 。如果想要编译一个磁盘文件，需要先获取一个 `StandardJavaFileManager` 对象，并调用其 `getJavaFileObjects` 方法：
```java
StandardJavaFileManager fileManager =
compiler.getStandardFileManager(null, null, null);

Iterable<JavaFileObject> sources =
fileManager.getJavaFileObjectsFromStrings(List.of("File1.java", "File2.java"));

JavaCompiler.CompilationTask task = compiler.getTask(
null, null, null, options, null, sources);
```

**`getTask` 方法会返回 `task` 对象，但不会启动编译过程**。`CompilationTask` 类扩展了 `Callable<Boolean>` 接口，我们可将其对象传递给 `ExecutionService` 以并行执行，或只是做出如下的同步调用——返回值如果是 `Boolean.FALSE` 则表示调用失败：
```java
Boolean success = task.call();
```

为了监听错误消息，还需要安装一个 `DiagnosticListener` 。**在编译器报告警告或错误消息时，这个监听器会收到一个 `Diagnostic` 对象**。`Diagnostic` 对象包含有关问题位置的信息（包括文件名、行号和列号）以及人类可阅读的描述。`DiagnosticCollector` 类实现了这个 `DiagnosticListener` 接口，它将收集所有的诊断信息，使你可以在编译完成之后遍历这些信息。
```java
DiagnosticCollector<JavaFileObject> collector = new DiagnosticCollector<>();

compiler.getTask(null, fileManager,
	collector, null, null, sources).call();

for (Diagnostic<? extends JavaFileObject> d : collector.getDiagnostics()) {
	System.out.println(d);
}
```

还可在标准文件管理器上、安装一个 `DiagnosticListener` 对象，这样就可以捕获到有关文件缺失的信息：
```java
StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnostics, null, null);
```

## 20.2.3 从内存中读取源代码
如果希望编译器从磁盘读取源文件，那么可像上面、让 `StandardJavaFileManager` 将文件名字符串（或 `File` 对象）转译成 `JavaFileObject` 实例。

但**如果希望编译器从磁盘文件之外的其他地方读取源代码，那可以提供自己的 `JavaFileObject` 的子类**，或者**扩展自 `S impleJavaFileObject` 便利类，并覆盖 `getCharContent` 方法**。比如，动态地生成了源代码，那就可从内存中获取它来进行编译，而无须在保存文件到磁盘上。可用下面的类来持有代码 *hold the code* ：
```java
public class StringSource extends SimpleJavaFileObject {
	private String code;
	
	StringSource(String name, String code) {
		super(URI.create("string:///" + name.replace('.','/') + ".java"), Kind.SOURCE);
		this.code = code;
	}
	public CharSequence getCharContent(boolean ignoreEncodingErrors) {
		return code;
	}
}
```
然后生成你的类的代码，并提交给编译器一个 `StringSource` 对象的列表，从而返回一个任务对象：
```java
List<StringSource> sources = List.of(new StringSource(className1, class1CodeString), ...);

task = compiler.getTask(null, fileManager, diagnostics, null, null, sources);
```

## 20.2.4 将字节码写出到内存中
**如果只是想让编译器在磁盘上生成类文件（字节码），则不需要定制 `JavaFileManager`** 。反之，==如果动态地编译类（上面那样），那就无须将类文件写到硬盘上，可将它们存储在内存中、将类文件生成在字节数组中，并（使用特殊的类加载器）立即加载它们==。

为了完成存储+加载，首先要有一个类来持有这些字节 *hold the bytes* ，下面定义了一个实现了 `JavaFileObject` 接口的类，其 `openOutputStream` 方法将返回编译器将要在其中放置字节码的 `ByteArrayOutputStream` ：
```java
public class ByteArrayClass extends SimpleJavaFileObject {
	private ByteArrayOutputStream out;
	
	ByteArrayClass(String name) {
		super(URI.create("bytes:///" + name.replace('.', '/') + ".class"), Kind.CLASS);
	}
	public byte[] getCode() {
		return out.toByteArray();
	}
	
	public OutputStream openOutputStream() throws IOException {
		out = new ByteArrayOutputStream();
		return out;
	}
}
```

接下来要**将文件管理器配置为「使用这些类（文件）作为输出」**。事实证明，要告知编译器的文件管理器去使用这些文件对象还是比较棘手的，因为**类库没有提供实现了 `StandardJavaFileManager` 接口的类**。因此，我们需要子类化 `ForwardingJavaFileManager` 类，该类将所有的调用都代理给了给定的文件管理器。在我们所处的情况中，我们只想修改 `getJavaFileForOutput` 方法，我们通过下面的代码框架达到了这个目的：
```java
List<ByteArrayClass> classes = new ArrayList<>();

StandardJavaFileManager stdFileManager = compiler.getStandardFileManager(null, null, null);

JavaFileManager fileManager = new ForwardingJavaFileManager<JavaFileManager>(stdFileManager) {
	public JavaFileObject getJavaFileForOutput(Location location, String className, Kind kind, FileObject sibling)
		throws IOException {
		if (kind == Kind.CLASS) {
			ByteArrayClass outfile = new ByteArrayClass(className);
			classes.add(outfile);
			return outfile;
		} else
			return super.getJavaFileForOutput(location, className, kind, sibling);
	}
};
```

为了加载这些类，需要使用类加载器（章22）：
```java
public class ByteArrayClassLoader extends ClassLoader {
	private Iterable<ByteArrayClass> classes;
	public ByteArrayClassLoader(Iterable<ByteArrayClass> classes) {
		this.classes = classes;
	}
	public Class<?> findClass(String name) throws ClassNotFoundException {
		for (ByteArrayClass cl : classes) {
			if (cl.getName().equals("/" + name.replace('.', '/') + ".class")) {
				byte[] bytes = cl.getCode();
				return defineClass(name, bytes, 0, bytes.length);
			}
		}
		throw new ClassNotFoundException(name);
	}
}
```
**编译完成后，用上面的类加载器、调用 `Class.forName` 方法**：
```java
ByteArrayClassLoader loader = new ByteArrayClassLoader(classes);
Class<?> cl = Class.forName(className, true, loader);
```

## 20.2.5 示例：动态Java代码生成
在用于动态Web页面的JSP技术中，可以在HTML中混杂Java代码。例如：
```java
<p>The current date and time is <b><%= new java.util.Date() %></b>.</p>
```
JSP引擎动态地将Java代码编译到Servlet中。示例应用中，我们使用了一个更简单的示例，它可以动态生成Swing代码。其基本思想是==使用GUI构建器在窗体中放置构件 *GUI builder to lay out the components in a frame*== 并在一个外部文件中指定构件的行为。

`buttons2/ButtonFrame.java` 中展示了一个非常简单的窗体类实例，而 `buttons2/action.properties` 展示了按钮动作的代码。注意，窗体类的构造器调用了抽象方法 `addEventHandlers` 。

我们的代码生成器，将产生一个实现了 `addEventHandlers` 方法的子类，并且对 `actioin.properties` 文件中的每一行、都添加了动作监听器（==留下一个典型练习，即扩展代码的生成功能，使其支持其他的事件类型==）。我们将这个子类置于名为 `x` 的包中，因为不希望在程序的其他地方用到它，所以生成的代码形式如下：
```java
package x;
public class Frame extends SuperclassName {
	protected void addEventHandlers() {
		componentName .addActionListener(event -> {
			code for event handler
		});
	// repeat for the other event handlers . . .
	}
}
```
`compiler/CompilerTest.java` 中的 `builder` 方法构建了这些代码，并把它放到 `StringSource` 对象中，该对象会传递给Java编译器。

如前一节所述，我们使用了一个 `ForwardingJavaFileManager` 对象，**它会为每个编译过的类都构造一个 `ByteArrayClass` 对象，这些对象会捕获 `x.Frame` 类被编译时生成的类文件**。该方法将每个文件对象、都添加到了一个列表中，然后将其返回，以使得我们稍后可以定位这些字节码。

编译完成后，我们**使用前一节描述的类加载器来加载「存储在这个列表中的所有类」**。然后，构造并显示应用程序的窗体类。
```java
var loader = new ByteArrayClassLoader(classFileObjects);
var frame = (JFrame) loader.loadClass("x.Frame").getConstructor().newInstance();
frame.setVisible(true);
```
当点击按钮时，背景色会按照常规方式进行修改。为了查看这些动作是动态编译的，可以更改 `action.properties` 文件中一行，例如修改成下面这样：
```java
yellowButton=panel.setBackground(java.awt.Color.YELLOW); yellowButton.setEnabled(false);
```
再次运行这个程序。现在，黄色按钮在点击之后就变得禁用了。再看看代码目录，你不会发现 `x` 包中的类的任何源文件和类文件。这个示例向你演示了==**如何通过内存中的源文件和类文件使用动态编译**==。
```java
// compiler/CompilerTest.java
package compiler;

import java.awt.*;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.List;

import javax.swing.*;
import javax.tools.*;
import javax.tools.JavaFileObject.*;

public class CompilerTest {
	public static void main(final String[] args) 
		throws IOException, ReflectiveOperationException {
		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();

		var classFileObjects = new ArrayList<ByteArrayClass>();
		var diagnostics = new DiagnosticCollector<JavaFileObject>();

		JavaFileManager fileManager = compiler.getStandardFileManager(diagnostics, null, null);
		fileManager = new ForwardingJavaFileManager<JavaFileManager>(fileManager) {
			public JavaFileObject getJavaFileForOutput(Location location,
				String className, Kind kind, FileObject sibling) throws IOException {
				if (kind == Kind.CLASS) {
					var fileObject = new ByteArrayClass(className);
					classFileObjects.add(fileObject);
					return fileObject;
				} else return super.getJavaFileForOutput(location, className, kind, sibling);
			}
		};

		String frameClassName = args.length == 0 ? "button2.ButtonFrame" : args[0];
		// compiler.run(null, null, null, frameClassName.replace(".", "/") + ".java");

		StandardJavaFileManager fileManager2 = compiler.getStandardFileManager(null, null, null);
		var sources = nwe ArrayList<JavaFileObject>();
		for (JavaFileObject o : fileManager2.getJavaFileObjectsFromStrings(
			List.of(frameClassName.replace(".", "/")))
			sources.add(o);

		JavaFileObject source = buildSource(frameCLassName);
		JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnostics,
			null, null, List.of(source));
		Boolean result = task.call();

		for (Diagnostic<? extends JavaFileObject> d : diagnostics.getDiagnostics())
			System.out.println(d.getKind() + ": " + d.getMessage(null));
		fileManager.close();
		if (!result) {
			System.out.println("Compilation failed.");
			System.exit(1);
		}

		var loader = new ByteArrayClassLoader(classFileObjects);
		var frame = (JFrame) loader.loadClass("x.Frame").getConstructor().newInstance();

		EventQueue.invokeLater(() -> {
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setTitle("CompilerTest");
			frame.setVisible(true);
		});
	}

	/*
	 * Builds the source for the subclass that implements the addEventHandlers method,
	 * @return a file object containing the source in a string builder
	 */
	static JavaFileObject buildSource(String superclassName) throws IOException, ClassNotFoundException {
		var builder = new StringBuilder();
		builder.append("package x;\n\n");
		builder.append("public class Frame extends ") + superclassName + " {\n"};
		builder.append("protected void addEventHandlers() {\n");
		var props = new Properties();
		props.load(Files.newInputStream(Paths.get(
			superclassName.replace(".", "/")).getParent().resolve("action.properties")));
		for (Map.Entry<Object, Object> e : props.entrySet()) {
			var beanName = (String) e.getKey();
			var eventCode = (String) e.getValue();
			builder.append(beanName + ".addActionListener(event -> {\n");
			builder.append(eventCode);
			builder.append("\n} );\n");
		}
		builder.append("} }\n");
		return new StringSource("x.Frame", builder.toString());
	}
}
```
```java
// buttons2/ButtonFrame.java
package buttons2;
import javax.swing.*;

/**
 * A frame with a button panel.
 */
public class ButtonFrame extends JFrame {
	private static final int DEFAULT_WIDTH = 300;
	private static final int DEFAULT_HEIGHT = 200;
	private JPanel panel;
	private JButton yellowButton;
	private JButton blueButton;
	private JButton redButton;

	public ButtonFrame() {
		setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);
		panel = new JPanel();
		panel.setName("panel");
		add(panel);

		yellowButton = new JButton("Yellow");
		yellowButton.setName("yellowButton");
		blueButton = new JButton("Blue");
		blueButton.setName("blueButton");
		redButton = new JButton("Red");
		redButton.setName("redButton");

		panel.add(yellowButton);
		panel.add(blueButton);
		panel.add(redButton);

		addEventHandlers();
	}
}
```
```java
// buttons2/action.properties
yellowButton=panel.setBackground(java.awt.Color.YELLOW);
blueButton=panel.setBackground(java.awt.Color.BLUE);
```

> [API] `javax.tools.Tool` 6
> - `int run(InputStream in, OutputStream out, OutputStream err, String... arguments)`
> 用给定的输入、输出、错误流，以及给定的参数来运行该工具。返回值为0表示成功，非0值表示失败。

> [API] `javax.tools.JavaCompiler` 6
> - `StandardJavaFileManager getStandardFileManager(DiagnosticListener<? super JavaFileObject> diagnosticListener, Locale locale, Charset charset)`
> 获取该编译器的标准文件管理器。如果要使用默认的错误报告机制、locale和字符集等参数，则可以提供 `null` 。
> - `JavaCompiler.CompilationTask getTask(Writer out, JavaFileManager fileManager, DiagnosticListener<? super JavaFileObject> diagnosticListener, Iterable<String> options, Iterable<String> classesForAnnotationProcessing, Iterable<? extends JavaFileObject> sourceFiles)`
> **获取编译任务，在被调用时，该任务将编译给定的源文件**。参见前一节中这部分内容的讨论。

> [API] `javax.tools.StandardJavaFileManager` 6
> - `Iterable<? extends JavaFileObject> getJavaFileObjectsFromStrings(Iterable<String> fileNames)`
> - `Iterable<? extends JavaFileObject> getJavaFileObjectsFromFiles(Iterable<? extends File> files)`
> 将文件名或文件序列转译成一个 `JavaFileObject` 实例序列。

> [API] `javax.tools.JavaCompiler.CompilationTask` 6
> - `Boolean call()`
> 执行编译任务。

> [API] `javax.tools.DiagnosticCollector<S>` 6
> - `DiagnosticCollector()`
> 构造一个空收集器。
> - `List<Diagnostic<? extends S>> getDiagnostics()`
> 获取收集到的诊断信息。

> [API] `javax.tools.Diagnostic<S>` 6
> - `S getSource()`
> 获取与该诊断信息相关联的**源对象**。
> - `Diagnostic.Kind getKind()`
> 获取该诊断信息的类型，返回值为 `ERROR, WARNING, MANDATORY_WARNING, NOTE, OTHER` 之一。
> - `String getMessage(Locale locale)`
> 获取一条消息，这条消息描述了由该诊断信息所揭示的问题。如果要使用默认的 `Locale` ，则传递 `null` 。
> - `long getLineNumber()`
> - `long getColumnNumber()`
> 获取由该诊断信息所揭示的问题的位置。

> [API] `javax.tools.SimpleJavaFileObject` 6
> - `CharSequence getCharContent(boolean ignoreEncodingErrors)`
> ==对于**表示源文件并产生源代码的文件对象**，需覆盖该方法==。
> - `OutputStream openOutputStream()`
> ==对于**表示类文件并产生字节码可写入其中的流的文件对象** *a class file and produces a stream to which the bytecodes can be written*，需覆盖该方法==。

> [API] `javax.tools.ForwardingJavaFileManager<M extends JavaFileManager>` 6
> - `protected ForwardingJavaFileManager(M fileManager)`
> 构造一个 `JavaFileManager` ，它**将所有的调用都代理给指定的文件管理器**。
> - `FileObject getFileForOutput(JavaFileManager.Location location, String className, JavaFileObject.Kind kind，FileObject sibling)`
> 如果希望**替换用于写出类文件的文件对象**，则需要拦截该调用。`kind` 的值是 `SOURCE, CLASS, HTML, OTHER` 之一。

---
# 20.3 使用注解
注释是那些插入到源代码中的标签、使用其他工具可以对其进行处理 *Annotations are tags that you insert into your source code so that some tool can process them* 。这些工具可以在**源码层次**上进行操作，或可以处理「编译器在其中放置了注解的类文件」。
 
==注解不会改变程序的编译方式。Java编译器对于包含注解和不包含注解的代码，会生成相同的虚拟机指令==。

为了能受益于注解，你需要选择一个处理工具，并使用处理工具理解的注释，然后运用该处理工具处理代码 *Use annotations that your processing tool understands, then apply the processing tool to your code* 。

注解的使用范围还是很广泛的，且这种广泛性让人乍一看会觉得有些杂乱无章。下面是关于注解的一些可能的用法：
- 附属文件的自动生成，例如**部署描述符**或者 `bean` 信息类。
- 测试、日志、事务语义等代码的自动生成。

首先介绍基本概念，然后将这些概念运用到一个具体示例中：我们将某些方法标记为AWT构件的事件监听器 *event listeners* ，然后向你展示一个能分析注解和连接监听器 *analyzes the annotations and hooks up the listeners* 的注解处理器。然后，对其语法规则进行详细讨论。最后，以两个注解处理的高级示例结束，一个可以处理源代码级别的注解。另一个使用了Apache的字节码工程类库，**可以向注解过的方法中添加额外的字节码**。
## 20.3.1 注解简介
下面是一个简单注解的示例，注解 `@Test` 用于注解 `checkRandomInsertions` 方法：
```java
public class MyClass {
	...
	@Test public void checkRandomInsertions()
}
```

==在Java中，注解是当作一个**修饰符** *modifier* 来使用的，它被置于被注解项之前，中间没有分号==（修饰符是诸如 `public` 和 `static` 之类的关键词）。每一个注解的名称前，都加上了 `@` 符号，这有点类似于Javadoc注释。然而，**Javadoc注释出现在 `/**...*/` 定界符的内部，而注解是代码的一部分**。

**`@Test` 注解自身并不会做任何事情，它需要工具支持才会有用**。例如，当测试一个类的时候，[JUnit4测试工具](http://junit.org)可能会调用所有标识为 `@Test` 的方法。另一个工具可能会删除一个类文件中的所有测试方法，以便在对这个类测试完毕后，不会将这些测试方法与程序装载在一起。

注解可以定义成包含**元素** *elements* 的形式，例如：
```java
@Test(timeout="10000")
```
**这些元素可以被「读取这些注解的工具」去处理**。其他形式的元素也是有可能的；随后部分进行讨论。

除了**方法**外，还可以**注解类、成员以及局部变量**，这些**注解可以存在于任何可以放置一个像 `public` 或 `static` 这样的修饰符的地方**。

==每个注解都必须通过一个注解接口 *annotation interface* 进行定义，这些「接口中的方法」与「注解中的元素」相对应==。例如，JUnit的注解 `Test` 可以用下面这个接口进行定义：
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {
	long timeout() default 0L;
	...
}
```
**`@interface` 声明创建了一个真正的Java接口**。**处理注解的工具将接收那些「实现了这个注解接口的对象」**。这类工具可以调用 `timeout` 方法、来检索某个特定 `Test` 注解的 `timeout` 元素。

**注解 `Target` 和 `Retention` 是元注解**。它们注解了 `Test` 注解，即将 `Test` 注解标识成一个**只能运用到方法上的注解**，并且**当类文件载入到虚拟机的时候，仍可以保留下来**。在20.5.3详细讨论这些元注解。

现在，已经清楚了程序的元数据和注解这两个概念。接下来深入到一个注解处理的具体示例中，继续探讨。
> 注释：对于注解引人入胜的用法，可查看[JCommander](http://jcommander.org)和[picocli](http://picocli.info)。这些类库将注解用于命令行参数的处理。

## 20.3.2 一个示例：注解事件处理器
在用户界面编程中，一件更令人讨厌的事情就是组装事件源上的监听器 *the wiring of listeners to event sources*。很多监听器是下面这种形式的：
```java
myButton.addActionListener(() -> doSomething());
```
本节设计了一个注解、来免除这种苦差事。该注解是在 `runtimeAnnotations/ActionListenerInstaller.java` 中定义的，其使用方式如下：
```java
@ActionListenerFor(source="myButton") void doSomething() { ... } 
```
程序员不再需要去调用 `addActionListener` 了。相反地，**每个方法直接用一个注解标记起来**。`buttons3/ButtonFrame.java` 展示了卷I章8的 `ButtonFrame` 程序，但使用上述这类注解重新实现了一遍。

还需要定义一个注解接口，代码在 `runtimeAnnotations/ActionListenerFor.java` 中。
```java
// runtimeAnnotations/ActionListenerInstaller.java
package runtimeAnnotations;

import java.awt.event.*;
import java.lang.reflect.*;

public class ActionListenerInstaller {
	/**
	 * Processes all ActionListenerFor annotations in the given object.
	 * @param obj an object whose methods may have ActionListenerFor annotations
	 */
	public static void processAnnotations(Object obj) {
		try {
			Class<?> cl = obj.getClass();
			/** -- use reflection -- **/
			for (Method m : cl.getDeclaredMethods()) {
				ActionListenerFor a = m.getAnnotation(ActionListenerFor.class);
				if (a != null) {
					Field f = cl.getDeclaredField(a.source);
					f.setAccessible(true);
					addListener(f.get(obj), obj, m);
				}
			}
		} catch (ReflectiveOperationException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Adds an action listener that calls a given method.
	 * @param source the event source to which an action listener is added
	 * @param param the implicit parameter of the method that the listener calls
	 * @param m the method that the listener calls
	 */
	public static void addListener(Object source, final Object param, final Method m)
		throws ReflectiveOperationException {
		var handler = new InvocationHandler() {
			public Object invoke(Object proxy, Method mm, Object[] args) throws Throwable {
				return m.invoke(param);
			}
		};

		Object listener = Proxy.newProxyInstance(null,
			new Class[] { java.awt.event.ActioinListener.class }, handler);
		Method adder = source.getClass().getMethod("addActionlistener", ActionListener.class);
		adder.invoke(source, listener);
	}
}
```
```java
// buttons3/ButtonFrame.java
package buttons3;

import java.awt.*;
import javax.swing.*;

import runtimeAnnotations;

/**
 * A frame with a button panel.
 */
public class ButtonFrame extends JFrame {
	private static final int DEFAULT_WIDTH = 300;
	private static final int DEFAULT_HEIGHT = 200;
	
	private JPanel panel;
	private JButton yellowButton;
	private JButton blueButton;
	private JButton redButton;

	public ButtonFrame() {
		setSize(DEFAULT_WIDHT, DEFAULT_HEIGHT);

		panel = new JPanel();
		add(panel);

		yellowButton = new JButton("Yellow");
		blueButton = new JButton("Blue");
		redButton = new JButton("Red");

		panel.add(yellowButton);
		panel.add(blueButton);
		panel.add(redButton);
		ActionListenerInstaller.processAnnotations(this);
	}

	@ActionListenerFor(source = "yellowButton");
	public void yellowBackground() {
		panel.setBackground(Color.YELLOW);
	}

	@ActionListenerFor(source = "blueButton")
	public void blueBackground() {
		panel.setBackground(Color.BLUE);
	}

	@ActioinListenerFor(source = "redButton") 
	public void redBackground() {
		panel.setBackground(Color.RED);
	}
}
```
```java
// runtimeAnnotations/ActionListenerFor.java
package runtimeAnnotations;

import java.lang.annotation.*;
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ActionListenerFor {
	String source();
}
```
当然，**这些注解本身不会做任何事情，它们只是存在于源文件中**。编译器将它们置于类文件中，并且虚拟机会将它们载入。我们现在需要的是一个分析注解以及安装行为监听器的机制。这也是类 `ActionListenerInstaller`的职责所在。

`ButtonFrame` 构造器将调用下面的方法——静态的 `processAnnotations` 方法可以枚举出「某个对象接收到的所有方法」：
```java
ActionListenerInstaller.processAnnotations(this);
```
对于每一个方法，它先获取 `ActionListenerFor` 注解对象，然后再对它进行处理——这里，我们使用了定义在 **`AnnotatedElement` 接口中的 `getAnnotation` 方法，`Method, Constructor, Field, Class, Package` 这些类都实现了这个接口**。
```java
Class<?> cl = obj.getClass();
for (Method m : cl.getDeclaredMethods()) {
	ActionListenerFor a = m.getAnnotation(ActionListenerFor.class);
	if (a != null) .。.
}
```
源成员域 *the source field* 是存储在注解对象中的，我们可以通过调用 `source` 方法对它进行检索，然后查找匹配的成员域：
```java
String fieldName = a.source();
Field f = cl.getDeclaredField(fieldName);
```
这表明我们的注解有点局限 *shows a limitation of our annotation* —— `source` 元素必须是一个成员域的名字 *the name of a field*，而不能是局部变量。

代码的剩余部分相当具有技术性。对于每一个被注解的方法，我们构造了一个实现了 `ActionListener` 接口的代理对象，其 `actionPerformed` 方法将调用这个被注解过的方法。（关于代理的更多信息见卷I章6）。细节并不重要，关键要知道，**注解的功能是通过 `processAnnotations` 方法建立起来的**。图20-1展示了本例中注解是如何被处理的。
图10-1　在运行时处理注解
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211292015872.png)

==这个示例中，注解是**在运行时进行处理**的；另外也可以**在源码级别上对它们进行处理**，这样，源代码生成器将产生用于添加监听器的代码==。注解**也可以在字节码级别上进行处理**，字节码编辑器可以将「对 `addActionListener` 的调用」注入 `frame` 构造器中。听起来似乎很复杂，不过可以利用一些类库相对直截了当地实现这项任务。

我们的示例并不是作为用户界面程序员的严肃工具。对于程序员来说，一个添加监听器的实用方法，可能仅和注解一样方便（实际上，`java.beans.EventHandler` 类试图实现的就是这样。通过在这个类中提供一个可以添加事件处理器的方法 *supplying a method that adds the event handler* 、而不仅仅只是构建它 *instead of just constructing it* ，你可以使其真正可用 *make the class truly useful* ）。

不过，这个示例展示了**对一个程序进行注解**、以及**对这些注解进行分析**的机制。既然已经领会了这个具体示例，那么现在，可能已为后续小节详述注解语法、做好了更充分的准备（这也是我们所希望的）。

> [API] `java.lang.reflect.AnnotatedElement` 5.0
> - `boolean isAnnotationPresent(Class<? extends Annotation>annotationType)`
> 如果该项具有给定类型的注解，则返回 `true` 。
> - `<T extends Annotation> T getAnnotation(Class<T> annotationType)`
> 获得给定类型的注解，如果该项不具有这样的注解，则返回 `null` 。
> - `<T extends Annotation> T[] getAnnotationsByType(Class<T> annotationType)` 8
> 获得某个**可重复注解类型** *a repeatable annotation type* 的所有注解（20.5.3节 *Meta-Annotations* ），或返回长度为0的数组。
> - `Annotation[] getAnnotations()`
> 获得作用于该项的所有注解，包括继承而来的注解。如果没有出现任何注解，那么将返回一个长度为0的数组。
> - `Annotation[] getDeclaredAnnotations()`
> 获得为该项声明的所有注解，不包含继承而来的注解。如果没有出现任何注解，那么将返回一个长度为0的数组。

---
# 20.4　注解语法
在本小节，介绍必须了解的每一个注解语法。
## 20.4.1 注解接口
**注解是由注解接口来定义的**：
```java
modifiers @interface AnnotationName {
	elementDeclaration
	elementDeclaration
	...
}
```
**每个元素声明 *elementDeclaration* 都具有下面这种形式**：
```java
type elementName();
```
或者：
```java
type elementName() default value;
```
举例来说，下面这个注解具有两个元素：`assignedTo` 和 `severity` ：
```java
public @interface BugReport {
	String assignedTo() default "[none]";
	int severity();
}
```

**所有的注解接口都隐式地扩展自 `java.lang.annotation.Annotation` 接口**。这个接口是一个**常规接口**，不是一个注解接口。查看本节最后为该接口提供的一些方法做的API notes。**你无法扩展注解接口**。换句话说，所有的注解接口都直接扩展自 `java.lang.annotation.Annotation` 。**也从来不用为注解接口提供实现类**。

**注解接口中的元素声明实际上是方法声明**。一个注解接口的方法没有参数和 `throws` 语句，并且它们不能是 *default, or static* 的，也不能具有类型参数。

注解元素的类型为下列之一：
- 基本类型 `int, short, long, byte, char, double, float, boolean` 。
- `String` 。
- `Class`（具有一个可选的类型参数，例如 `Class<? extends MyClass` ）。
- `enum` 类型。
- **注解类型**。
- 由前面所述类型组成的数组（**由数组组成的数组不是合法的元素类型**）。

下面是一些合法的元素声明的例子：
```java
public @interface BugReport {
	enum Status { UNCONFIRMED, CONFIRMED, FIXED, NOTABUG };
	boolean showStopper() default false;
	String assignedTo() default "[none]";
	Class<?> testCase() default Void.class;
	Status status() default Status.UNCONFIRMED;
	Reference ref() default @Reference(); // an annotation type
	String[] reportedBy();
}
```
> [API] `java.lang.annotation.Annotation` 5.0
> - `Class<? extends Annotation> annotationType()`
> 返回 `Class` 对象，它用于描述该注解对象的注解接口。注意：**调用注解对象上的 `getClass` 方法可以返回真正的类，而不是接口**。
> - `boolean equals(Object other)
> 如果 `other` 是一个「实现了与该注解对象相同的注解接口」的对象，并且如果该对象和 `other` 的所有元素彼此相等。那么返回 `True` 。
> - `int hashCode()`
> 返回一个与 `equals` 方法兼容、由注解接口名以及元素值衍生而来的散列码。
> - `String toString()`
> 返回一个包含注解接口名以及元素值的字符串表示，例如，`@BugReport(assignedTo=[none], severity=0)` 。

---
# 20.5 标准注解
## 20.4.2 注解
每个注解都具有下面这种格式：
```java
@AnnotationName(elementName=value, elementName=value, ...)
```
举例来说，
```java
@BugReport(assignedTo="Harry", severity=10)
```
**元素的顺序无关紧要**。下面这个注解和前面那个一样。
```java
@BugReport(severity=10, assignedTo="Harry")
```

**如果某个元素的值并未指定，那么就使用声明的默认值**。例如，考虑下面这个注解，元素 `assignedTo` 的值是字符串 `"[none]"` ：
```java
@BugReport(severity=10)
```
> 警告：==默认值并不是和注解存储在一起的；相反地，它们是动态计算而来的==。例如，如果你将元素 `assignedTo` 的默认值更改为 `"[]"` ，然后重新编译 `BugReport` 注解接口，那么注解 `@BugReport(severity=10)` 将使用这个新的默认值，甚至在那些「在默认值修改之前就已编译过的类文件」中也是如此。
>
> 因为注解是由编译器计算而来的，因此，**所有元素值必须是编译期常量**。例如：
> ```java
> @BugReport(showStopper=true, assignedTo="Harry", testCase=MyTestCase.class, status=BugReport.Status.CONFIRMED, ...)
> ```

> 警告：**一个注解元素永远不能设置为 `null` ，甚至不允许其默认值为 `null`** 。这样在实际应用中会相当不方便。你必须使用其他的默认值，例如 `""` 或者 `Void.class` 。

有两个特殊的快捷方式可以用来简化注解。==如果没有指定元素，要么是因为注解中没有任何元素，要么是因为所有元素都使用默认值，那么你就不需要使用圆括号了==。例如，
```java
@BugReport
```
和下面这个注解是一样的：
```java
@BugReport(assignedTo="[none]", severity=0)
```
这样的注解又称为**标记注解** *marker annotation* 。

另外一种快捷方式是**单值注解** *single value annotation* 。如果一个元素具有特殊的名字 `value` ，并且没有其他元素被指定，那么你就**可以忽略掉这个元素名以及等号**。例如，既然我们已经在前面将 `ActionListenerFor` 注解接口定义为如下形式：
```java
public @interface ActionListenerFor {
	String value();
}
```
那么，我们可以将这个注解书写成如下形式：
```java
@ActionListenerFor("yellowButton")
```
而不是：
```java
@ActionListenerFor(value="yellowButton")
```

一个项可以具有多个注解，只要它们属于不同的类型即可。
```java
@Test
@BugReport(showStopper=true, reportedBy="Joe")
public void checkRandomInsertions()
```
当注解一个特定项的时候，不能多次使用同一个注解类型。==除非注解的作者将其声明为**可重复的**，那么就可以多次重复使用同一个注解==。例如：
```java
@BugReport(showStopper=true, reportedBy="Joe")
@BugReport(reportedBy={"Harry", "Carl"})
public void checkRandomInsertions()
```

如果元素值是一个数组，那么要将它的值用括号括起来，像下面这样：
```java
@BugReport(..., reportedBy={"Harry", "Carl"})
```
如果该元素具有单值，那么可以忽略这些括号：
```java
@BugReport(..., reportedBy="Joe") // OK, same as {"Joe"}
```
既然一个注解元素可以是另一个注解，那么就可以创建出任意复杂的注解。例如：
```java
@BugReport(ref=@Reference(id="3352627"), ...)
```
> 注意：**在注解中引入循环依赖是一种错误**。例如，因为 `BugReport` 具有一个注解类型为 `Reference` 的元素，所以 `Reference` 就不能再拥有一个类型为 `BugReport` 的元素。

## 20.4.3 注解声明 *Annotating Declarations*
==注解可以出现在许多地方，这些地方分为两类：声明和类型用法 *declarations and type uses* 。**声明注解** *Declaration annotations* 可以出现在以下声明处==：
- 包
- 类（包括 `enum` ）
- 接口（包括注解接口）
- 方法
- 构造器
- 实例域（包含 `enum` 常量）
- 局部变量
- **参数变量** *Parameter variables* 
- 类型参数 *Type parameters*

对于类和接口，需要将注解放置在 `class/interface` 关键字的前面：
```java
@Entity public class User { ... }
```
对于变量，需要将它们放置在类型的前面：
```java
@SuppressWarnings("unchecked") List<User> users = ...;
public User getUser(@Param("id") String userId)
```
泛型类或方法中的类型参数，可以像下面这样被注解：
```java
public class Cache<@Immutable V> { ... }
```
**包是在文件 `package-info.java` 中注解的**，该文件只包含以注解先导的包语句：
```java
/**
 * Package-level Javadoc
 */
@GPL(version="3")
package com.horstmann.corejava;
import org.gnu.GPL;
```
> 注意：==对局部变量的注解，只能在源码级别上进行处理==。类文件并不描述局部变量。因此，==所有的局部变量注解在编译完一个类时就会被遗弃掉==。同样地，==对包的注解不能在源码级别之外存在== *annotations for packages are not retained beyond the source level* 。

## 20.4.4 注解类型用法 *Annotating Type Uses*
**一个声明注解提供了正在被声明的项 *the item being declared* 的相关信息**。例如，下面的声明中，就断言 `userId` 参数不为空：
```java
public User getUser(@NonNull String userId)
```
> 注释：`@NonNull` 注解是 *Checker Framework* 的一部分（http://types.cs.washington.edu/checker-framework)。通过使用这个框架，可以在程序中包含断言，例如某个参数不为空，或某个 `String` 包含一个正则表达式。然后，静态分析工具将检查在给定的源代码段中这些断言是否有效。

现在，假设我们有一个类型为 `List<String>` 的参数，并且想要表示其中所有的字符串都不为 `null` 。这就是**类型用法注解的大显身手之处**，可以将该注解放置到类型参数之前：`List<@NonNull String>` 。

类型用法注解，可以出现在下面的位置：
- **与泛化类型参数一起使用**：`List<@NonNull String>, Comparator.<@NonNull String> reverseOrder()`
- **数组中的任何位置**：`@NonNull String[][] words`（ `words[i][j]` 不为 `null` ，`String @NonNull [][] words`（ `words` 不为 `null` ），`String[] @NonNull []`（ `words[i]` 不为 `null` ）。
- **与超类和实现接口一起使用**：`class Warning extends @Localized Message`
- **与构造器调用一起使用**：`new @Localized String(...)`
- 与强制转型和 `instanceof` 检查一起使用：`(@Localized String) text, if (text instanceof @Localized String)`（这些注解只供外部工具使用，它们对强制转型和 `instanceof` 检查不会产生任何影响）
- **与异常规约一起使用**：`public String read() throws @Localized IOException` 
- **与通配符和类型边界一起使用** *wildcards and type bounds* ：`List<@Localized ? extends Message>, List<? extends @Localized Message>` 
- **与方法和构造器引用一起使用**：`@Localized Message::getText` 。

有多种类型位置是不能被注解的：
```java
@NonNull String.class // ERROR: Cannot annotate class literal
import java.lang.@NonNull String; // ERROR: Cannot annotate import
```

可以将注解放置到诸如 `private, static` 这样的其他修饰符的前面或后面。==习惯（但不是必须）的做法，是将类型用法注解放置到其他修饰符的后面、和将声明注解放置到其他修饰符的前面==。例如：
```java
private @NonNull String text; // Annotates the type use
@Id private String userId; // Annotates the variable
```
> 注释：注解的作者需要指定特定的注解、可以出现在哪里。==如果一个注解可以同时应用于变量和类型用法，并且它确实被应用到了某个变量声明上，那么该变量和类型用法就都被注解了== *If an annotation is permissible both for a variable and a type use, and it is used in a variable declaration, then both the variable and the type use are annotated* 。例如，请考虑：
> ```java
> public User getUser(@NonNull String userId)
> ```
> 如果 `@NonNull` 可以同时应用于参数和类型用法，那么 `userId` 参数就被注解了，而其参数类型是 `@NonNull String` 。

## 20.4.5 注解 `this`
假设想要将参数注解为在方法中不会被修改：
```java
public class Point {
	public boolean equals(@ReadOnly Object other) {
		... 
	}
}
```
那么，处理这个注解的工具在看到下面的调用时，就会推理出 `q` 没有被修改过：
```java
p.equals(q)
```
但是 `p` 呢？当该方法被调用时，`this` 变量是被绑定到 `p` 的。但 `this` 从来都没有被声明过 *never declared* ，因此你无法注解它。

实际上，可以用一种很少使用的语法变体来声明它，这样你就可以添加注解了——第一个参数被称为**接收器参数** *receiver parameter* ，它必须被命名为 `this` ，而它的类型就是要构建的类：
```java
public class Point {
	public boolean equals(@ReadOnly Point this, @ReadOnly Object other) { ... }
}
```
> 注释：**你只能为方法、而不能为构造器提供接收器参数**。从概念上讲，构造器中的 `this` 引用，在构造器没有执行完之前，还不是给定类型的对象。相反，放置在构造器上的注解描述的是被构建的对象的属性 *an annotation placed on the constructor describes a property of the constructed object* 。

传递给内部类构造器的是**另一个不同的隐藏参数（那自己对象的引用呢？），即对其外围类对象的引用**。你也可以让这个参数显式化，这个参数的名字，必须像引用它时那样，叫做 `EnclosingClass.this` ，其类型为外围类：
```java
public class Sequence {
	private int from;
	private int to;
	class Iterator implements java.util.Iterator<Integer> {
		private int current;
		public Iterator(@ReadOnly Sequence Sequence.this) {
			this.current = Sequence.this.from;
		}
		...
	}
	...
}
```

---
# 20.5 标准注解
Java SE在 `java.lang, java.lang.annotation, javax.annotation` 包中定义了大量的注解接口。其中四个是元注解 *meta-annotations*，用于描述注解接口的行为，其他三个是规则接口 *regular annotations* ，可用它们来注解你的源代码中的项。表20-2列出了这些注解。在随后两小节给予详细介绍。
![表20-2 标准注解](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211301102792.png)

## 20.5.1 用于编译的注解
`@Deprecated` 注解可被添加到「任何不再鼓励使用的项」上。所以，当你使用一个已过时的项时，编译器将会发出警告。这个注解与Java文档标签 `@deprecated` 具有同等功效。但是，该注解（指 `@Deprecated` ）会一直持久化到运行时。
> 注释：`jdeprscan` 工具可以扫描一个JAR文件集中的过时元素，该工具是JDK的组成部分。

`@SuppressWarnings` 注解会告知编译器阻止特殊类型的警告信息，例如：
```java
@SuppressWarnings("unchecked")
```

**`@Override` 这种注解只能应用到方法上**。编译器会检查「具有这种注解的方法」是否真正覆盖了「一个来自于超类的方法」。例如，如果你声明下列方法，那么编译器会报告一个错误。毕竟，`equals` 方法不能覆盖 `Object` 类的 `equals` 方法。因为那个方法有一个类型为 `Object` 而不是 `MyClass` 的参数：
```java
public MyClass {
	@Override public boolean equals(MyClass other);
	...
}
```

`@Generated` 注解的目的是**供代码生成工具来使用**。任何生成的源代码都可以被注解，从而与程序员提供的代码区分开。例如，一个代码编辑器可以隐藏生成的代码，或代码生成器可以移除生成代码的旧版本。每个 `@Generated` 注解都必须包含一个表示代码生成器的惟一标识符，而一个日期字符串（ISO8601格式）和一个注释字符串是可选的。例如，
```java
@Generated("com.horstmann.beanproperty", "2008-01-04T12:08:56.235-0700");
```

## 20.5.2 用于管理资源的注解
**`@PostConstruct` 和 `@PreDestroy` 注解用在控制对象生命周期的环境中**，例如Web容器和应用服务器。==标记了这些注解的方法应在对象被构建之后，或者在对象被移除之前，紧接着调用==。

**`@Resource` 注解用于资源注入**。例如，考虑一下访问数据库的Web应用。当然，数据库访问信息不应被硬编码到Web应用中，而是==应该让Web容器提供某种用户接口，以便设置连接参数和一个用于数据库源的JNDI名字==。在这个Web应用中，可以像下面这样引用数据源：
```java
@Resource(name="jdbc/mydb")
private DataSource source;
```
当包含这个域的对象被构造时，容器会“注入”一个对该数据源的引用。
## 20.5.3 元注解
**`@Target` 元注解可以应用于一个注解，以限制该注解可以应用到哪些项上**。例如，
```java
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface BugReport
```
表20-3显示了所有可能的取值情况，它们属于枚举类型 `ElementType` 。可以指定任意数量的元素类型，用括号括起来。
![表20-3 @Target注解的元素类型](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211301140852.png)
一条没有 `@Target` 限制的注解可以应用于任何项上。编译器将检查你是否将一条注解只应用到了某个允许的项上。例如，如果将 `@BugReport` 应用于一个成员域上，则会导致一个编译器错误。

**`@Retention` 元注解用于指定一条注解应该保留多长时间**。只能将其指定为表10-4中的任意值，其默认值是`RetentionPolicy.CLASS` 。
![表20-4 用于@Retention注解的保留策略](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211301151987.png)

在 `runtimeAnnotations/ActionListenerFor.java` 中，`@ActionListenerFor` 注解**声明为具有 `RetentionPolicy.RUNTIME`** ，因为我们是**使用反射机制进行注解处理的**。随后两个小节里，会看到一些**在源码级别和类文件级别上**怎样对注解进行处理的示例。

`@Documented` 元注解为像Javadoc这样的归档工具提供了一些提示。应像处理其他用于归档目的的修饰符（如 `protected` 或 `static` ）一样、来处理归档注解 *documented annotations* 。其他注解的使用不属于归档范畴 *The use of other annotations is not included in the documentation* 。例如，假定我们将 `@ActionListenerFor` 作为一个归档注解来声明：
```java
@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ActionListenerFor
```
现在每一个「被该注解标注过的方法」的归档，都会含有这条注解，如图20-2所示。
![图20-2 文档化注解](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211301217505.png)

如果某个注解是暂时的（例如 `@BugReport` ），那么就不应对它的用法进行归档 *document its use* 。
> 注意：**将一个注解应用到它自身上是合法的**。例如， `@Documented` 注解被它自身注解为 `@Documented` 。因此，针对注解的Javadoc文档 *the Javadoc documentation for annotations* 显示了它们是否被记录。
 
 **`@Inherited` 元注解只能应用于对类的注解**。如果一个类具有继承注解 *inherited annotation* ，那么它的所有子类都自动具有同样的注解。这使得创建「运行方式和标记接口（例如 `Serializable` ）相同的注解」变得很容易 *create annotations that work as marker interfaces, such as Serializable* 。

实际上，`@Serializable` 注解应比没有任何方法的 `Serializable` 标记接口更适用。一个类之所以可序列化，是因为存在着对它的成员域进行读写的运行期支持，而不是因为任何面向对象的设计。注解比接口继承更擅长描述这一事实。当然了，可序列化接口是在JDK1.1中产生的，远比注解出现得早。

假设定义了一个继承注解 `@Persistent` 来指明一个类的对象可以存储到数据库中，那么该持久类的子类就会自动被注解为是持久性的。
```java
@Inherited @interface Persistent { }

@Persistent class Employee { ... }
class Manager extends Employee { ... } // also @Persistent
```
在持久化机制去查找存储在数据库中的对象的时候，它就会同时探测 `Employee` 对象以及 `Manager` 对象。

对于Java 8来说，将同种类型的注解多次应用于某一项是合法的。==为了向后兼容，可重复注解的实现者需要提供一个容器注解，它可以将这些重复性注解存储到一个数组中==。下面是如何定义 `@TestCase` 注解、以及它的容器的代码：
```java
@Repeatable(TestCases.class)
@interface TestCase {
	String params();
	String expected();
}
@interface TestCases {
	TestCase[] value();
}
```
无论何时，只要用户提供了两个或更多个 `@TestCase` 注解，那么它们就会自动地、被包装到一个 `@TestCases` 注解中。
> 警告：在处理可重复注解时，必须非常仔细。如果调用 `getAnnotation` 来查找某个可重复注解，而该注解又确实重复了，那么就会得到 `null` 。这是因为**重复注解被包装到了容器注解中**。这种情况下，应该调用 `getAnnotationsByType` ，这个调用会遍历容器，并给出一个重复注解的数组。如果只有一条注解，那么该数组的长度为1。通过使用这个方法，就不用操心如何处理容器注解了。

---
# 20.6 源码级注解处理
上一节中看到了如何分析正在运行的程序中的注解。==注解的另一种用法是，自动处理源代码、以产生更多的源代码==。
> 在过去，Java的“企业版本”由于让程序员过多地陷入了类似八股文的样板代码中而变得声名不佳。Java EE的现代版本使用注解极大地简化了编程模型。
## 20.6.1 注解处理器
注解处理已经被集成到了Java编译器中。**在编译过程中**，可以通过运行下面的命令，调用注解处理器：
```bash
$ javac -processor ProcessorClassName1, ProcessorClassName2, ... sourceFiles
```
编译器会定位源文件中的注解。每个注解处理器会依次执行，并得到它表示感兴趣的注解。如果某个注解处理器创建了一个新的源文件，那么上述过程将重复执行。如果某次处理循环、没有再产生任何新的源文件，那么就编译所有的源文件。
> 注释：==注解处理器只能产生新的源文件，它无法修改已有的源文件==。

注解处理器通常通过**扩展 `AbstractProcessor` 类、而实现 `Processor` 接口**，你需要**指定你的处理器支持的注解**。我们的案例如下：
```java
@SupportedAnnotationTypes("com.horstmann.annotations.ToString")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class ToStringAnnotationProcessor extends AbstractProcessor {
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment currentRound) {
		...
	}
}
```
**处理器可以声明具体支持的注解类型**、或诸如 `"com.horstmann*"` 这样的通配符（`com.horstmann` 包及其所有子包中的注解），甚至是 `"*"`（所有注解）。

**在每一轮中，`process` 方法都会被调用一次**、用的参数是「由这一轮在所有文件中发现的所有注解」构成的集，以及包含了有关当前处理轮次的信息的 `RoundEnvironment` 引用。
## 20.6.2 语言模型API
**应使用语言模型API来分析源码级的注解**。与用来呈现 *presents* 类和方法的虚拟机表示形式的反射API不同，语言模型 *language mode* API让我们可以根据Java语言的规则、去分析Java程序。

编译器会产生一棵树，其节点是实现了 `javax.lang.model.element.Element` 接口、及其 `TypeElement, VariableElement, ExecutableElement` 等子接口的类的实例。这些节点可以类比于编译时的 `Class, Field/Parament` 和 `Method/Constructor` 反射类。

这里不会详细讨论该API，但要强调的是，需要知道它是如何处理注解的：
- `RoundEnvironment` 通过调用下面的方法，交给你一个由特定注解标注过的所有元素构成的集。
	```java
	Set<? extends Element> getElementsAnnotatedWith(Class<? extends Annotation> a)
	```
- 在源码级别上，等价于 `AnnotatedElement` 接口的是 `AnnotatedConstruct` 。使用下面的方法，来获得属于给定注解类的单条注解、或重复注解：
	```java
	A getAnnotation(Class<A> annotationType)
	A[] getAnnotationsByType(Class<A> annotationType)
	```
- `TypeElement` 表示 *represents* 一个类或接口，而 `getEnclosedElements` 方法会产生一个由它的域和方法构成的列表。
 - 在 `Element` 上调用 `getSimpleName` 或在 `TypeElement` 上调用 `getQualifiedName` ，会产生一个 `Name` 对象，它可以用 `toString` 方法转换为一个字符串。
## 20.6.3 使用注解来生成源码
作为示例，我们将使用注解、来减少实现 `toString` 方法时枯燥的编程工作量。**我们不能将这些方法放到原来的类中，因为注解处理器只能产生新的类，而不能修改已有的类**。因此，我们将所有方法添加到工具类 `sourceAnnotations/ToStrings.java` 中：
```java
// sourceAnnotations/ToStrings.java
// Automatically generated by sourceAnnotations.ToStringAnnotationProcessor
package sourceAnnotations;

public class ToStrings {
	public static String toString(rect.Point obj) {
		// Generated code
		// 见下面的生成代码
		var result = new StringBuilder();
		result.append("[");
		result.append(toString(obj.getX()));
		result.append(",");
		result.append(toString(obj.getY()));
		result.append("]");
		return result.toString();
	}
	public static String toString(rect.Rectangle obj) {
		// Generated code
		/** -- **/
		var result = new StringBuilder();
		result.append("Rectangle");
		result.append("[");
		result.append(toString(obj.getTopLeft()));
		result.append(",");
		result.append("width=");
		result.append(toString(obj.getWidth()));
		result.append(",");
		result.append("height=");
		result.append(toString(obj.getHeight()));
		result.append("]");
		return result.toString();
		/** -- **/
	}
	public static String toString(Object obj) {
		return java.util.Objects.toString(obj);
	}
}
```
我们不想使用反射，因此对访问器方法、而不是域进行注解：
```java
// rect/Rectangle.java
package rect;

import sourceAnnotations.ToString;

@ToString
public class Rectangle {
    private Point topLeft;
    private int width;
    private int height;
    public Rectangle(Point topLeft, int width, int height) 
    {
        this.topLeft = topLeft;
        this.width = width;
        this.height = height;
    }
    @ToString(includeName=false) 
    public Point getTopLeft() { return topLeft; }
    @ToString 
    public int getWidth() { return width; }
    @ToString
    public int getHeight() { return height; }
```
然后，注解处理器应生成下面的源代码（其中，不涉及方法名如 `getTopLeft` 等的是“模板”代码）：
```java
public static String toString(Rectangle obj) {
	var result = new StringBuilder();
	result.append("Rectangle");
	result.append("[");
	result.append(toString(obj.getTopLeft()));
	result.append(",");
	result.append("width=");
	result.append(toString(obj.getWidth()));
	result.append(",");
	result.append("height=");
	result.append(toString(obj.getHeight()));
	result.append("]");
	return result.toString();
}
```

下面方法的概略 *an outline of the method* 可以**为「具有给定的 `TypeElement` 的一个类」产生 `toString` 方法**：
```java
private void writeToStringMethod(PrintWriter out, TypeElement te) {
	String className = te.getQualifiedName().toString();
	// Print method header and declaration of string builder
	ToString ann = te.getAnnotation(ToString.class);
	if (ann.includeName())
		// Print code to add class name

	for (Element c : te.getEnclosedElements()) {
		ann = c.getAnnotation(ToString.class);
		if (ann != null) {
			if (ann.includeName()) 
				// Print code to add field name
			// Print code to append toString(obj.methodName())
		}
	}
	// Print code to return string
}
```
而下面给出的是**注解处理器的 `process` 方法的框架**（注释需实现）。它会创建助手类的源文件，并**为每个被注解标注的类编写类头和一个 `toString` 方法**：
```java
public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment currentRound) {
	if (annotations.size() == 0) return true;
	try {
		JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("com.horstmann.annotations.ToStrings");
		try (var out = new PrintWriter(sourceFile.openWriter())) {
			// Print code for package and class
			
			for (Element e : currentRound.getElementsAnnotatedWith(ToString.class)) {
				if (e instanceof TypeElement) {
					TypeElement te = (TypeElement) e;
					writeToStringMethod(out, te);
				}
			}
			// Print code for toString(Object)
			
		} catch (IOException ex) {
			processingEnv.getMessager().printMessage(
				Kind.ERROR, ex.getMessage());
		}
	}
	return true;
}
```
注意，`process` 方法在后续轮次中是用空的注解列表调用的，然后它会立即返回，因此它并不会多次创建源文件。

这个示例展示了工具如何获取源文件注解、以产生其他文件。生成的文件并非一定要是源文件。==注解处理器可以生成XML描述符、属性文件、Shell脚本、HTML文档等==。
```java
package sourceAnnotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.SOURCE)
public @interface ToString {
	boolean includeName() default true;
}
```
```java
// rect/Point.java
package rect;

import sourceAnnotations.ToString;

@ToString(includeName=false)
public class Point {
	private int x;
	private int y;
	public Point(int x, int y) {
		this.x = x;
		this.y = y;
	}
}
```
```java
// sourceAnnotations/ToStringAnnotationProcessor.java
package sourceAnnotations;

import java.beans.*;
import java.io.*;
import java.util.*;

import javax.annotation.processing.*;
import javax.lang.model.*;
import javax.lang.model.element.*
import javax.tools.*;
import javax.tools.Diagnostic.Kind;

@SupportedAnnotationTypes("sourceAnnotations.ToString")
@SupportedAnnotationsTypes(SourceVersion.RELEASE_8)
public class ToStringAnnotationProcessor extends AbstractProcessor {
	public boolean process(Set<? extends TypeElement> annotations, 
		RoundEnvironment currentRound) {
		if (annotations.size() == 0) return true;
		try {
			JavaFileObject sourceFile
				= processingEnv.getFiler().createSourceFile("sourceAnnotations.ToStrings");
			try (var out = new PrintWriter(sourceFile.openWriter())) {
				out.println("// Automatically generated by" 
               + " sourceAnnotations.ToStringAnnotationProcessor");
	            out.println("package sourceAnnotations;");
	            out.println("public class ToStrings {");
	            
				for (Element e : currentRound.getElementsAnnotatedWith(ToString.class)) {
					if (e instanceof TypeElement) {
						var te = (TypeElement) e;
						writeToStringMethod(out, te);
					}
				}
				out.println("    public static String toString(Object obj) {");
	            out.println("        return java.util.Objects.toString(obj);");
	            out.println("    }");
	            out.println("}");
	        }
	    } catch (IOException ex) {
			processingEnv.getMessager().printMessage(Kind.ERROR, ex.getMessage());
	    }        
	    return true;
	}

	private void writeToStringMethod(PrintWriter out, TypeElement te) {
		String className = te.getQualifiedName().toString();
		out.println("    public static String toString(" + className + " obj) {");
		ToString ann = te.getAnnotation(ToString.class);
		out.println("        var result = new StringBuilder();");
		if (ann.includeName()) // whether or not to include class name
			out.println("        result.append(\"" + className + "\");"); 
			
		out.println("        result.append(\"[\");");
		var first = true;
		for (Element c : te.getEnclosedElements()) {
			String methodName = c.getSimpleName().toString();
	        ann = c.getAnnotation(ToString.class);
	        if (ann != null) {
		        if (first) first = false;
		        else out.println("        result.append(\",\");");
		        if (ann.includeName()) {
			        String fieldName = Introspector.decapitalize(methodName.replaceAll("^(get|is)", ""));
	                // Turn getWidth into width, isDone into done, getURL into URL
		            out.println("        result.append(\"" + fieldName + "=" + "\");");
		        }
		        out.println("       result.append(toString(obj." + methodName + "()));");
         }
      }
      out.println("        result.append(\"]\");");
      out.println("        return result.toString();");
      out.println("    }");
	}
}
```

首先，编译注解处理器，然后编译并运行测试程序，就像下面这样：
```bash
$ javac sourceAnnotations/ToStringAnnotationProcessor.java
$ javac -processor sourceAnnotations.ToStringAnnotationProcessor rect/*.java
$ java rect.SourceLevelAnnotationDemo
```
想查看轮次 *rounds* ，可以用 `-XprintRounds` 标记运行 `javac` 命令：
```java
Round 1:
	input files: {rect.Point, rect.Rectangle,
		rect.SourceLevelAnnotationDemo}
	annotations: [sourceAnnotations.ToString]
	last round: false
Round 2:
	input files: {sourceAnnotations.ToStrings}
	annotations: []
	last round: false
Round 3:
	input files: {}
	annotations: []
    last round: true
```

>  注意：一些人建议使用注解去免除更大的繁碎任务。如果琐碎的获取器和设置器可以自动生成，岂不是更好吗？举例来说，下面这个注解：
>  ```java
>  @Property private String title;
>  ```
>  可以产生下面这些方法：
>  ```java
>  public String getTitle() { return title; }
>  public void setTitle(String title) { this.title = title; }
>  ```
>  不过，这些方法需要被添加到同一个类中。这样就要编辑源文件，而不仅是生成另一个文件，而这超出了注解处理器的能力。
>  
>  我们可以构建其他工具实现此目的，但这样的工具可能超越了注解的职责所在。==注解之所以存在，是因为它被设计为对代码项的一种描述 *description about a code item* ，而不是一种添加或修改代码的指示==。

---
# 20.7 字节码工程
已看到了我们怎样**在运行期或在源码级别上对注解进行处理**。还有第三种可能：**在字节码级别上进行处理**。除非将注解在源码级别上删除，否则它们会一直存在于类文件中。类文件格式是[被归档的](http://docs.oracle.com/javase/specs/jvms/se7/html)，这种格式相当复杂，并且在没有特殊类库的情况下，处理类文件具有很大的挑战性。

[BCEL](http://jakarta.apache.org/bcel)（即字节码工程类库）和[ASM](http://asm.ow2.org)，就是这样的特殊类库之一。
## 20.7.1 修改类文件
在本小节，我们使用ASM向已注解方法中添加日志信息。如果一个方法这样注解过：
```java
@LogEntry(logger=loggerName)
```
那么，在方法的开始部分，我们将添加下面这条语句的字节码：
```java
Logger.getLogger(loggerName).entering(className, methodName);
```
举例来说，如果对 `Item` 类的 `hashCode` 方法做了如下注解：
```java
@LogEntry(logger="global") public int hashCode()
```
那么，在任何时候调用该方法，都会报告一条与下面打印出来的消息相似的消息：
```java
May 17, 2016 10:57:59 AM Item hashCode
FINER: ENTRY
```

为了实现这项任务，我们需要遵循下面几点：
1. 加载类文件中的字节码。
2. **定位所有的方法**。
3. 对于每个方法，**检查它是不是有一个 `LogEntry` 注解**。
4. 如果有，在方法开始部分添加下面所列指令的字节码：
	```java
	ldc loggerName
	invokestatic 
		java/util/logging/Logger.getLogger(Ljava/lang/String;)Ljava/util/logging/Logger;
	ldc className
	ldc methodName
	invokevirtual 
		java/util/logging/Logger.entering:(Ljava/lang/String;)V
	```

插入这些字节码看起来相当棘手，不过ASM却使它变得简单。不会详细描述和分析插入字节码的过程。关键之处是 `bytecodeAnnotations/EntryLogger.java` 可以编辑一个类文件，并且在「已经用 `LogEntry` 注解标注过的方法」的开头部分插入日志调用。
> 注意：如果对字节码工程的具体细节感兴趣，建议你通篇阅读一下[网站](http://jakarta.apache.org/bcel/manual.html)上提供的BCEL手册。需要用6.0或以上版本的BCEL类库来编译和运行 `EntryLogger` 程序（以前的提醒）。

例如，下面展示了应怎样向 `set/Item.java` 文件添加记录日志指令，其中 `asm` 是安装ASM库的目录：
```java
javac set/Item.java
javac -classpath .:asm/lib/\* bytecodeAnnotations/EntryLogger.java
java -classpath .:asm/lib/\* bytecodeAnnotations.EntryLogger set.Item
```

在对 `Item` 类文件被修改之前和之后分别试运行一下（`javap` 是Java Class文件分解器，可以反编译、查看Java编译器生成的字节码）：
```java
javap -c set.Item
```
可以看到在 `hashCode, equals, compareTo` 方法开始部分插入的那些指令。
```java
public int hashCode();
	Code:
	0: ldc #85; // String global
	2: invokestatic #80;
		// Method java/util/logging/Logger.getLogger:(Ljava/lang/String;)Ljava/util/logging/Logger;
	5: ldc #86; //String Item
	7: ldc #88; //String hashCode
	9: invokevirtual #84;
		// Method java/util/logging/Logger.entering:(Ljava/lang/String;Ljava/lang/String;)V
	12: bipush 13
	14: aload_0
	15: getfield #2; // Field description:Ljava/lang/String;
	18: invokevirtual #15; // Method java/lang/String.hashCode:()I
	21: imul
	22: bipush 17
	24: aload_0
	25: getfield #3; // Field partNumber:I
	28: imul
	29: iadd
	30: ireturn
```

`set/SetTest.java` 程序会将 `Item` 对象插入到一个散列集中。当你用修改过的类文件来运行该程序的时候，会看到下面的日志记录信息：
```java
May 17, 2016 10:57:59 AM Item hashCode
FINER: ENTRY
May 17, 2016 10:57:59 AM Item hashCode
FINER: ENTRY
May 17, 2016 10:57:59 AM Item hashCode
FINER: ENTRY
May 17, 2016 10:57:59 AM Item equals
FINER: ENTRY
[[description=Toaster, partNumber=1729], [description=Microwave,  partNumber=4104]]
```
**当将同一项插入两次的时候，请注意一下对 `equals` 的调用**。

这个示例显示了字节码工程的强大之处：==注解可以用来向程序中添加一些指示 *directives* ，而一个字节码编辑工具 *bytecode editing tool* 则可以提取这些指示，然后修改虚拟机指令==。
```java
// bytecodeAnnotations/LogEntry.java
package bytecodeAnnotations;

import java.lang.annotations.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogEntry {
	String logger();
}
```
```java
// bytecodeAnnotations/EntryLogger.java

import java.io.*;
import java.nio.file.*;

import org.objectweb.asm.*;
import org.objectweb.asm.commons.*;

/**
 * Adds "entering" logs to all methods of a class that have the LogEntry annotation.
 */
public class EntryLogger extends ClassVisitor {
	private String className;

	/**
	 * Constructs an EntryLogger that inserts logging into annotated methods of a given class
	 * @param cg the class
	 */
	public EntryLogger(ClassWriter writer, String className) {
		super(Opcodes.ASM5, writer);
		this.className = className;
	}

	public MethodVisitor visitMethod(int access, String methodName, String desc, String signature, String[] exceptions) {
		MethodVisitor mv = cv.visitMethod(access, methodName, desc, signature, exceptions);
		return new AdviceAdapter(Opcodes.ASM5, mv, access, methodName, desc) {
			private String loggerName;

			public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
				return new AnnotationVisitor(Opcodes.ASM5) {
					public void visit(String name, Object value) {
						if (desc.equals("LbytecodeAnnotations/LogEntry;") 
                           && name.equals("logger")) 
                        loggerName = value.toString(); 
					}
				}
			}

			public void onMethodEnter() {
				if (loggerName != null) {
					visitLdcInsn(loggerName);
					visitMethodInsn(INVOKESTATIC, "java/util/logging/Logger", "getLogger", 
                  "(Ljava/lang/String;)Ljava/util/logging/Logger;", false);
	                visitLdcInsn(className);
	                visitLdcInsn(methodName);
		            visitMethodInsn(INVOKEVIRTUAL, "java/util/logging/Logger", "entering", 
                  "(Ljava/lang/String;Ljava/lang/String;)V", false);
	                loggerName = null;
				}
			}
		};
	}

	/** 
	 * Adds entry logging code to the given class.
	 * @param args the name of the class file to path
	 */
	public static void main(String[] args) throws IOException {
		if (args.length == 0) {
	        System.out.println("USAGE: java bytecodeAnnotations.EntryLogger classfile");
	        System.exit(1);			
		}
		Path path = Paths.get(args[0]);
		var reader = new ClassReader(Files.newInputStream(path));
		var writer = new ClassWriter(
         ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);
		var entryLogger = new EntryLogger(writer, 
		path.toString().replace(".class", "").replaceAll("[/\\\\]", "."));
		reader.accept(entryLogger, ClassReader.EXPAND_FRAMES);
		Files.write(Paths.get(args[0]), writer.toByteArray());
	}
}
```
```java
// set/Item.java
package set;

import java.util.*;
import bytecodeAnnotations.*;

/**
 * An item with a description and a part number.
 */
public class Item {
	private String description;
	private int partNumber;

	/**
     * Constructs an item.
     * @param aDescription the item's description
     * @param aPartNumber the item's part number
     */
	public Item(String aDescription, int aPartNumber) {
		description = aDescription;
		partNumber = aPartNumber;
	}

	/** 
	 * Gets the description of this item.
	 * @return the description
	 */
	public String getDescription() {
		return description;
	}

	public String toString() {
		return "[description=" + description + ", partNumber=" + partNumber + "]";
	}

	@LogEntry(logger = "com.horstmann")
	public boolean equals(Object otherObject) {
		if (this == otherObject) return true;
		if (otherObject == null) return false;
		if (getClass() != otherObject.getClass()) return false;
		var other = (Item) otherObject;
		return Objects.equals(description, other.description)
			&& partNumber == other.partNumber;
	}

	@LogEntry(logger = "com.horstmann")
	public int hashCode() {
		return Objects.hash(description, partNumber);
	}
}
```
```java
// set/SetTest.java
package set;

import java.util.*;
import java.util.logging.*;

public class SetTest {
	public static void main(String[] args) {
		Logger.getLogger("com.horstmann").setLevel(Level.FINEST);
		var handler = new ConsoleHandler();
		handler.setLevel(Level.FINEST);
		Logger.getLogger("com.horstmann").addHandler(handler);

		var parts = new HashSet<Item>();
		parts.add(new Item("Toaster", 1279));
		parts.add(new Item("Microwave", 4104));
		parts.add(new Item("Toaster", 1279));
		System.out.println(parts);
	}
}
```
## 20.7.2 在加载时修改字节码
在前一节中，已经看到了一个用于编辑类文件的工具。然而，在把这另一个工具添加到程序的构建过程中，会显得笨重不堪。==更吸引人的做法是将字节码工程延迟到载入时，即类加载器加载类的时候==。

在Java 5.0之前，必须编写定制的类加载器才能实现这项任务。现在，**设备** `instrumentation` API提供了一个安装字节码转换器的挂钩 *has a hook for installing a bytecode transformer* 。不过，必须在程序的 `main` 方法调用之前安装这个转换器。

**通过定义一个代理** *agent* ——被加载用来按照某种方式监视程序的一个类库 *a library that is loaded to monitor a program in some way* ，**你可以处理这个需求**。代理代码可以在 `premain` 方法中执行初始化。

下面是构建一个代理所需的步骤：
1. 实现一个具有下面这个方法的类：
	```java
	public static void premain(String arg, Instrumentation instr)	
	```
	**当加载代理时，此方法会被调用**。代理可以获取一个命令行参数，该参数是通过 `arg` 参数传递进来的。`instr` 参数可以用来安装各种各样的挂钩。
2. 制作一个清单文件 `EntryLoggingAgent.mf` 来设置 `Premain-Class` 属性。例如：
	```java
	Premain-Class: bytecodeAnnotations.EntryLoggingAgent
	```
3. 将代理代码打包，并生成一个JAR文件，例如：
	```bash
	$ javac -classpath .:asm/lib/\* bytecodeAnnotations/EntryLoggingAgent.java
	$ jar cvfm EntryLoggingAgent.jar bytecodeAnnotations/EntryLoggingAgent.mf \ bytecodeAnnotations/Entry*.class
	```

为了运行一个具有该代理的Java程序，使用下面这个命令行选项：
```bash
$ java -javaagent:AgentJARFile=agentArgument ...
```
举例来说，运行具有日志代理的 `SetTest` 程序，需调用（`Item` 参数是代理应该修改的类的名称）：
```bash
$ javac set/SetTest.java
$ java -javaagent:EntryLoggingAgent.jar=set.Item -classpath .:asm/lib/\* set.SetTest
```

`bytecodeAnnotations/EntryLoggingAgent.java` 展示了这个代理的代码。该代理安装了一个类文件转换器，这个转换器首先检验类名是否与代理参数相匹配。如果匹配，那么它会利用上一节的 `EntryLogger` 类修改字节码。不过，**修改过的字节码并不保存成文件。相反地，转换器只是将它们返回，以加载到虚拟机中**（参见图20-3）。换句话说，这项技术实现的是“即时 *just in time*”字节码修改。
```java
// bytecodeAnnotations/EntryLoggingAgent.java
package bytecodeAnnotations;
import java.lang.instrument.*;
import org.objectweb.asm.*;

public class EntryLoggingAgent {
	public static void premain(final String arg, Instrumentation instr) {
		instr.addTransformer((loader, className, cl, pd, data) -> {
			if (!className.replace("/", ".").equals(arg)) 
				return null;
			var reader = new ClassReader(data);
			var writer = new ClassWriter(
				ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES
			);
			var el = new EntryLogger(writer, className);
			reader.accept(el, ClassReader.EXPAND_FRAMES);
			return writer.toByteArray();
		})
	}
}
```
![图20-3 在加载时刻修改类](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212011533543.png)


