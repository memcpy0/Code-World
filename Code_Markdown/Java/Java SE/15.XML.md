
*Don Box* 等人在其合著的 *Essential XML* （ `Addison-Wesley` 出版社2000年出版）的前言中开玩笑：“可扩展标记语言 `Extensible Markup Language, XML` 已经取代了Java、设计模式、对象技术，成为软件行业解决世界饥荒的方案。”正如将看到的，**XML是一个非常有用的描述结构化信息的技术** `describing structured information` ，**XML工具使处理和转化信息十分容易**（现在有YAML和JSON了，尤其是JSON）。但是，`XML is not a silver bullet` 。我们需要领域相关的标准和代码库才能有效地使用XML。此外，XML非但没有使Java技术过时，还与Java配合得很好。从20世纪90年代末以来，IBM、Apache和许多公司一直在帮助开发用于XML处理的高质量Java库，其中大部分重要的代码库都整合到了Java平台中。

这里将介绍XML，并涵盖了Java库的XML特性。一如既往地，将指出何时大量地使用XML是正确的；何时必须有保留地 `take it with a grain of salt` 使用XML，试着用传统的方式解决问题：通过良好的设计和代码。

---
# 1.1 XML概述
~~在第Ⅰ卷第13章中~~已经看见过用**属性文件** `property file` 来描述程序配置。属性文件包含了一组名/值对，例如：
```java
fontname=Times Roman
fontsize=12
windowsize=400 200
color=0 50 100
```
**可以使用 `Properties` 类，通过单个方法调用来读入这样的属性文件**。这是一个很好的特性，但这还不够。在许多情况下，想要描述的信息的结构比较复杂，属性文件不能很方便地处理它。例如，对于下面例子中的 `fontname/fontsize` 项，使用以下的单一项将更符合面向对象的要求；但这时对字体描述的解析 `parse` 就变得很讨厌了，必须确定字体名在何处结束，字体大小在何处开始。
```jva
font=Times Roman 12
```
==属性文件采用的是一种单一的平面层次结构==。常常会看到程序员用如下的键名来努力解决这种局限性：
```java
title.fontname=Helvetica
title.fontsize=36
body.fontname=Times Roman
body.fontsize=12
```
==属性文件格式的另一个缺点是要求键是惟一的==。如果要存放一个值序列，则需要另一个变通方法 `workaround` ，例如：
```java
menu.item.1=Times Roman
menu.item.2=Helvetica
menu.item.3=Goudy Old Style
```
==XML格式解决了这些问题，因为它能够表示层次结构，这比属性文件的平面表结构更灵活，并且重复的元素不会被曲解==。描述程序配置的XML文件可能会像这样：
```xml
<config>
	<entry id="title">
		<font>
			<name>Helvetica</name>
			<size>36</size>
		</font>
	</entry>
	<entry id="body">
		<font>
			<name>Times Roman</name>
			<size>12</size>
		</font>
	</entry>
	<entry id="background">
		<color>
			<red>0</red>
			<green>50</green>
			<blue>100</blue>
		</color>
	</entry>
</config>
```
如上所示，XML文件的格式非常直观，它与HTML文件非常相似。这完全是有理由的，因为**XML和HTML格式是古老的标准通用标记语言 `Standard Generalized Markup Language, SGML` 的衍生语言**。
> 从20世纪70年代开始，SGML就用于描述复杂文件的结构。在一些要求对海量文献进行持续维护的产业中，它的使用取得了成功，特别是在飞机制造业中。但是，**SGML相当复杂**，所以它从未风行。
> 
> **造成SGML如此复杂的主要原因是，SGML有两个相互矛盾的目标**。它既想要确保文档能根据其文档类型的规则来形成，又想通过允许「减少键入的快捷方式」来简化数据项 `make data entry easy by allowing shortcuts that reduce typing` 。
>
> **XML设计成了「用于因特网的SGML」的一个简化版本**。和通常情况一样，越简单的东西越好，XML立即得到了长期以来一直躲避SGML的用户的热情追捧。注意，在[这个网址](http://www.xml.com/axml/axml.html)可以找到一个由 *Tim Bray* 注释的XML标准的极佳版本。

尽管HTML和XML同宗同源，但是两者之间存在着重要的区别：
1. 与HTML不同，**XML是大小写敏感的** `case-sensitive` 。例如，`<H1>` 和 `<h1>` 是不同的XML标签。
2. 在HTML中，如果从上下文可以分清哪里是 `paragraph` 或 `list item` 的结尾，那么结束标签（如 `</p>` 或 `</li>` ）就可以省略，而**在XML中结束标签绝对不能省略**。
3. **在XML中，只有单个标签、而没有相对应的结束标签的元素必须以 `/` 结尾**，比如 `<img src="coffeecup.png"/>` 。这样，解析器就知道不需要查找 `</img>` 标签了。
4. **在XML中，属性值必须用引号括起来**。在HTML中，引号是可有可无的。例如，`<applet code="MyApplet.class" width=300 height=300>` 对HTML来说是合法的，但是对XML来说则是不合法的。在XML中，必须使用引号，比如，`width="300"` 。
5. 在HTML中，属性名可以没有值。例如，`<input type="radio" name="language" value="Java" checked>` 。**在XML中，所有属性必须都有属性值**。比如，`checked="true"` 或 `checked="checked"` 。

---
# 1.2 XML文档的结构
**XML文档应当以一个文档头开始**，例如：
```xml
<?xml version="1.0"?>
<?xml version="1.0" encoding="UTF-8"?>
```
严格来说，**文档头是可选的，但强烈推荐使用文档头**。
> 注意：因为建立SGML是为了处理真正的文档，因此XML文件叫做**文档**，尽管许多XML文件是用来描述「人们通常不会称之为文档的数据集」的。

文档头之后通常是**文档类型定义** `Document Type Definition, DTD` ，例如：
```xml
<!DOCTYPE web-app PUBLIC
"-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN"
"http://java.sun.com/j2ee/dtds/web-app_2_2.dtd">
```
**文档类型定义是确保文档正确的一个重要机制，但是它不是必需的**。在后面讨论这个问题。

最后，**XML文档的正文包含根元素，根元素包含其他元素，元素可以有子元素 `child element` 、文本或两者皆有**。下列例子中， `font` 元素有两个子元素，它们是 `name` 和 `size` 。`name` 元素包含文本 `"Helvetica"` 。
```xml
<?xml version="1.0"?>
<!DOCTYPE config ...>
<config>
	<entry id="title">
		<font>
			<name>Helvetica</name>
			<size>36</size>
		</font>
	</entry>
	...
</config>
```
> 注意：**在设计XML文档结构时，最好使元素要么包含子元素，要么包含文本**。换句话说，应该避免以下情况：
> ```java
> <font>
>     Helvetica
>     <size>36</size>
> </font>
> ```
在XML规范中，这叫做**混合式内容** `mixed content` 。稍后将会看到，如果避免了混合式内容，就可以简化解析过程。

XML元素可以包含属性，例如：
```xml
<size unit="pt">36</size>
```
何时用元素，何时用属性，在XML设计人员中存在一些分歧。例如，将 `font` 做如下描述：
```xml
<font name="Helvetica" size="36"/>
```
似乎比下面更简单一些：
```xml
<font>
	<name>Helvetica</name>
	<size>36</size>
</font>
```
但是，**属性的灵活性要差很多** `attributes are much less flexible` 。假设想把单位添加到 `size` 的值中去，如果使用属性，那么必须把单位添加到属性值中去：
```xml
<font name="Helvetica" size="36 pt"/>
```
现在必须对字符串 `"36 pt"` 进行解析，而**这正是XML设计用来避免的那种麻烦**。把属性加到 `size` 元素中则简单多了：
```xml
<font>
	<name>Helvetica</name>
	<size unit="pt">36</size>
</font>
```
一个常用的经验法则是，**属性只应该用来修改值的解释，而不是用来指定值** `attributes should be used only to modify the interpretation of a value, not to specify values` 。==如果发现自己陷入了争论，在纠结于某个设置是否是对「某个值的解释」所作的修改，那么就应该对属性说“不”，转而使用元素，许多有用的文档根本就不使用属性==。
> 注意：在HTML中属性的使用规则很简单：**凡是不显示在网页上的都是属性** `If it isn’t displayed on the web page, it’s an attribute` 。例如以下的超链接，字符串 `Java Technology` 要在网页上显示，但这个链接的URL并不是显示页面的一部分：
> ```html
> <a href="http://java.sun.com">Java Technology</a>
> ```
> 然而，这个规则对于大多数XML并不那么管用，因为**XML文件中的数据并非像通常意义那样是让人浏览查看的**。

**元素和文本是XML文档“主要的支撑要素”** `bread and butter` ，可能还会遇到的其他一些标记，说明如下：
- **字符引用** `character reference` 的形式是 `&#十进制值;` 或 `&#x十六进制值;` 。例如，字符 `é` 可以用下面两种形式表示：
  ```xml
  &#233; &#xE9;
  ```
- **实体引用** `entity reference` 的形式是 `&name;` 。下面这些实体引用都有预定义的含义：小于、大于、`&` 、引号、省略号等字符。还可以在DTD中定义其他的实体引用。
  ```xml
  &lt; &gt; &amp; &quot; &apos;
  ```
- **CDATA部分** `CDATA Section` 用 `<![CDATA[` 和 `]]>` 来限定其界限。它们是字符数据的一种特殊形式。可以使用它们来囊括那些含有 `<, >, &` 之类字符的字符串，而不必将它们解释为标记，例如：
  ```xml
  <![CDATA[< & > are my favorite delimiters]]>
  ```
CDATA部分不能包含字符串 `]]>` 。**使用这一特性时要特别小心**。它常用来当作将遗留数据偷偷纳入XML文档的一个后门 `a back door for smuggling legacy data into XML documents` 。
- **处理指令** `processing instruction` 是那些专门处理XML文档的应用程序使用的指令，它们将用 `<?` 和 `?>` 来限定其界限，例如：
  ```xml
  <?xml-stylesheet href="mystyle.css" type="text/css"?>
  ```
每个XML都以一个处理指令开头：
  ```xml
  <?xml version="1.0"?>
  ```
- **注释** `comment` 用 `<!-` 和 `-->` 限定其界限，例如：
  ```xml
  <!-- This is a comment. -->
  ```
注释不能含有字符串 `--` 。注释只能是给文档的读者提供的信息，其中绝不应该含有隐藏的命令；命令应该用处理指令来实现 `use processing instructions for commands` 。

---
# 1.3　解析XML文档
要处理XML文档，就要先解析 `parse` 它。解析器是这样一个程序：它读入一个文件，确认这个文件具有正确的格式，然后将其分解成各种组成元素，使得程序员能够访问这些元素。Java库提供了两种XML解析器：
- **树型解析器** `tree parser` ，比如文档对象模型 `Document Object Model, DOM` 解析器，它们将读入的XML文档转换成树结构。
- **流机制解析器** `streaming parser` ，比如XML简单API `Simple API for XML, SAX` 解析器，它们在读入XML文档时生成相应的事件。

对于实现我们的大多数目的来说，DOM解析器都更容易一些，所以我们首先介绍它。==如果要处理很长的文档，用它生成树结构将会消耗大量内存，或者如果只是对于某些元素感兴趣、而不关心它们的上下文，那么在这些情况下就应该考虑使用流机制解析器==。

**DOM解析器的接口已经被W3C标准化了**。`org.w3c.dom` 包包含了这些接口类型的定义，比如 `Document` 和 `Element` 等。不同的提供者，比如Apache Organization和IBM，都编写了DOM解析器，其类实现了这些接口。Java XML处理API `Java API for XML Processing, JAXP` 库使我们实际上可以以插件形式、使用这些解析器中的任意一个。但JDK中也包含了自己的DOM解析器。在这里使用的就是这个解析器。

要读入一个XML文档，首先需要一个 `DocumentBuilder` 对象，可以从 `DocumentBuilderFactory` 中得到这个对象，例如：
```java
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
```
现在，可以从文件中读入某个文档：
```java
File f = ...;
Document doc = builder.parse(f);
```
或者，可以用一个URL：
```java
URL u = ...;
Document doc = builder.parse(u);
```
甚至可以指定一个任意的输入流：
```java
InputStream in = ...;
Document doc = builder.parse(in);
```
> 注意：如果使用输入流作为输入源，解析器将无法定位「相对于该文档位置而被引用的其他文件」，比如在同一个目录中的DTD。但可以通过安装一个“实体解析器” `entity resolver` 来解决这个问题。更多信息见[这个网址](http://www.xml.com/pub/a/2004/03/03/catalogs.html)或[IBM网址](http://www.ibm.com/developerworks/xml/library/x-mxd3.html)。

**`Document` 对象是XML文档的树型结构在内存中的表现** `an in-memory representation of the tree structure of the XML document` ，它由实现了 `Node` 接口及其各种子接口的类的对象构成。下图显示了各个子接口的层次结构。
![图2-1 Node接口及其子接口](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207092205846.png)

**通过调用 `getDocumentElement` 方法来启动对文档内容的分析**，它将返回根元素。
```java
Element root = doc.getDocumentElement();
```
例如，如果处理下面的文档，调用 `getDocumentElement` 方法可以返回 `font` 元素。`getTagName` 方法可以返回元素的标签名。在前面这个例子中， `root.getTagName()` 返回字符串 `"font"` 。
```java
<?xml version="1.0"?>
<font>
	...
</font>
```
如果要得到该元素的子元素（可能是子元素、文本、注释或其他节点），使用 `getChildNodes` 方法，这个方法返回一个类型为 `NodeList` 的集合。这个类型在标准的Java集合类创建之前就存在了，它有一个不同的访问协议；**`item` 方法将得到指定索引值的项；`getLength` 方法则提供了项的总数**。可以像这样枚举所有子元素：
```java
NodeList children = root.getChildNodes();
for (int i = 0; i < children.getLength(); i++) {
	Node child = children.item(i);
	...
}
```
分析子元素时要很仔细。例如假设正在处理以下文档：
```java
<font>
	<name>Helvetica</name>
	<size>36</size>
</font>
```
预期 `font` 有两个子元素，但是解析器却报告说有 $5$ 个：
- `<font>` 和 `<name>` 之间的空白字符
- `name` 元素
- `</name>` 和 `<size>` 之间的空白字符
- `size` 元素
- `</size>` 和 `</font>` 之间的空白字符

下图显示了其DOM树。
![图2-2 一棵简单的DOM树](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207092226085.png)

如果只希望得到子元素，那么可以忽略空白字符，现在只会看到两个元素，它们的标签名是 `name` 和 `size` 。
```java
for (int i = 0; i < children.getLength(); i++) {
	Node child = children.item(i);
	if (child instanceof Element) {
		var childElement = (Element) child;
		...
	}
}
```
如在下节中看到的那样，如果文档有DTD，那么就可以做得更好。这时，解析器知道哪些元素没有文本节点作为子元素 `the parser knows which elements don't have text nodes as children` ，而且它会帮助剔除空白字符。

在分析 `name` 和 `size` 元素时，肯定想获取它们包含的文本字符串。这些文本字符串本身都包含在 `Text` 类型的子节点中。既然知道了这些 `Text` 节点是惟一的子元素，就可以用 `getFirst-Child` 方法而不用再遍历一个 `NodeList` 。然后可以用 `getData` 方法获取存储在 `Text` 节点中的字符串。
```java
for (int i = 0; i < children.getLength(); i++) {
	Node child = children.item(i);
	if (child instanceof Element) {
		var childElement = (Element) child;
		var textNode = (Text) childElement.getFirstChild();
		String text = textNode.getData().trim();
		if (childElement.getTagName().equals("name"))
			name = text;
		else if (childElement.getTagName().equals("size"))
			size = Integer.parseInt(text);
	}
}
```
> 提示：对 `getData` 的返回值调用 `trim` 方法是个好主意。如果XML文件的作者将起始和结束的标签放在不同的行上，例如：
> ```xml
> <size>
>     36
> </size>
> ```
> 那么，解析器将会把所有的换行符和空格都包含到文本节点中去。调用 `trim` 方法可以把实际数据前后的空白字符删掉。

也可以用 `getLastChild` 方法得到最后一项子元素，用 `getNextSibling` 得到下一个兄弟节点。这样，另一种遍历子节点集的方法就是：
```java
for (Node childNode = element.getFirstChild(); childNode != null;
	childNode = childNode.getNextSibling()) {
	...
}
```
如果要枚举节点的属性，可以调用 `getAttributes` 方法。它返回一个 `NamedNodeMap` 对象，其中包含了「描述属性的 `Node` 对象」。可以用和遍历 `NodeList` 一样的办法在 `NamedNodeMap` 中遍历各子节点。调用 `getNodeName` 和 `getNodeValue` 方法可以得到属性名和属性值。
```java
NamedNodeMap attributes = element.getAttributes();
for (int i = 0; i < attributes.getLength(); i++) {
	Node attribute = attributes.item(i);
	String name = attribute.getNodeName();
	String value = attribute.getNodeValue();
	...
}
```
或者，如果知道属性名，则可以直接获取相应的属性值：
```java
String unit = element.getAttribute("unit");
```
现在已经知道怎么分析DOM树了。`dom/JSONConverter.java`（第11版程序）将这些技术都运用了一遍，**将一个XML文档转换成了JSON格式**。无须熟悉JSON，就可以理解这个程序是如何操作DOM树的，只需观察一下几点：
- 使用了一个 `DocumentBuilder` 来从文件中读取一个 `Document` 。
- 对于每一个元素，我们打印了标签名、属性和元素。
- 对于字符数据，我们用这些数据产生一个字符串。如果数据来自于注释，我们就会添加 `"Comment: "` 前缀。
```java
package dom;

import java.io.*;
import java.util.*;

import javax.xml.parsers.*;

import org.w3c.dom.*;
import org.w3c.dom.CharacterData;
import org.xml.sax.*;

/*
 * This program displays an XML document as a tree in JSON format.
 */
public class JSONConverter {
	public static void main(String[] args) 
		throws SAXException, IOException, ParserConfigurationException {
		String filename;
		if (args.length == 0) {
			try (var in = new Scanner(System.in)) {
				System.out.print("Input file: ");
				filename = in.nextLine();
			}
		} else
			filename = args[0]; // 解析的目标XML文件
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		
		Document doc = builder.parse(filename);
		Element root = doc.getDocumentElement(); // 启动对文档内容的分析
		System.out.println(convert(root, 0)); // 将XML文档转换为JSON格式的字符串并打印
	}
	
	public static StringBuilder convert(Node node, int level) { // 每次打印第level层
		if (node instanceof Element) { // 是Element
			return elementObject((Element) node, level); // 强制转型为Element,并转换为字符串
		} else if (node instanceof CharacterData) {
			return characterString((CharacterData) node, level); // 强制转型为CharacterData,并转换为字符串
		} else {
			return pad(new StringBuilder(), level).append( // 否则,在字符串前添加level个空格,并附加转义后的类名?
				jsonEscape(node.getClass().getName()));
		}
	}
	
	private static Map<Character, String> replacements = Map.of('\b', "\\b", '\f', "\\f", 
		'\n', "\\n", '\r', "\\r", '\t', "\\t", '"', "\\\"", '\\', "\\\\");
	
	private static StringBuilder jsonEscape(String str) { // 完成转义字符的打印
		var result = new StringBuilder("\"");
		for (int i = 0; i < str.length(); ++i) {
			char ch = str.charAt(i);
			String replacement = replacements.get(ch);
			if (replacement == null) result.append(ch);
			else result.append(replacement); // 对转义字符进行打印
		}
		result.append("\""); // 不用"\\\""是因为不用打印(print)出\",这里只是插入一个双引号"
		return result;
	}
	
	private static StringBuilder characterString(CharacterData node, int level) {
		var result = new StringBuilder();
		StringBuilder data = jsonEscape(node.getData());
		if (node instanceof Comment) data.insert(1,  "Comment: "); // 如果是Commennt注释类型,则添加前缀(JSON格式),在1的位置是因为有个双引号
		// 否则是Text或CDATASection类型
		pad(result, level).append(data); // 添加空格
		return result;
	}
	
	private static StringBuilder elementObject(Element elem, int level) {
		var result = new StringBuilder();
		pad(result, level).append("{\n"); // 每个元素转换为JSON的一个{}
		pad(result, level + 1).append("\"name\": "); // 再添加一个"name":的前缀(JSON格式)
		result.append(jsonEscape(elem.getTagName())); // 添加标签名
		NamedNodeMap attrs = elem.getAttributes(); // 得到属性结点映射表
		if (attrs.getLength() > 0) {
			pad(result.append(",\n"), level + 1).append("\"attributes\": "); // 再添加一个"attributes":的前缀(JSON格式)
			result.append(attributeObject(attrs)); // 将属性结点映射表转为字符串
		}
		NodeList children = elem.getChildNodes(); // 得到子元素结点
		if (children.getLength() > 0) {
			pad(result.append(",\n"), level + 1).append("\"children\": [\n"); // 再添加一个"children":的前缀(JSON格式),对应一个数组[
			for (int i = 0; i < children.getLength(); ++i) {
				if (i > 0) result.append(",\n"); 
				result.append(convert(children.item(i), level + 2)); // 对每个子元素依次转换,注意层数+2
			}
			result.append("\n");
			pad(result, level + 1).append("]\n"); // 数组结束
		}
		pad(result, level).append("}"); // 该元素转换结束
		return result;
	}
	
	private static StringBuilder pad(StringBuilder builder, int level) {
		for (int i = 0; i < level; ++i) builder.append("	"); // 添加level个Tab
		return builder;
	}
	
	private static StringBuilder attributeObject(NamedNodeMap attrs) { // 属性结点映射表转为一个{},内部是多个键值对
		var result = new StringBuilder("{");
		for (int i = 0; i < attrs.getLength(); ++i) { // 类似对子元素的转换,但是简单一些
			if (i > 0) result.append(", ");
			result.append(jsonEscape(attrs.item(i).getNodeName())); // 键(JSON格式)
			result.append(": ");
			result.append(jsonEscape(attrs.item(i).getNodeValue())); // 值(JSON格式)
		}
		result.append("}");
		return result;
	}
}
```
输入 `./src/dom/server.xml` ，执行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207111737272.png)

`dom/Treeviewer.java`（第10版程序）也将这些技术都运用了一遍。可以使用 `File->Open` 菜单选项来读入一个XML文件。`DocumentBuilder` 对象会解析这个XML文件，并产生一个 `Document` 对象。该程序将 `Document` 对象显示为一个 `JTree`（参见下图）。
![图 一个XML文档的解析树](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207112159591.png)

```java
package dom;

import java.awt.*;
import java.io.*;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.tree.*;
import javax.xml.parsers.*;

import org.w3c.dom.*;
import org.w3c.dom.CharacterData;

/**
 * This program displays an XML document as a tree in GUI
 */
public class Treeviewer {
	public static void main(String[] args) {
		EventQueue.invokeLater(() -> {
			JFrame frame = new DOMTreeFrame();
			frame.setTitle("XMLTreeViewer");
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}
}

/**
 * This frame contains a tree that displays the contents of an XML document.
 */
class DOMTreeFrame extends JFrame {
	private static final int DEFAULT_WIDTH = 400;
	private static final int DEFAULT_HEIGHT = 400;
	
	private DocumentBuilder builder;
	
	public DOMTreeFrame() {
		setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);
		
		JMenu fileMenu = new JMenu("File");
		
		JMenuItem openItem = new JMenuItem("Open");
		openItem.addActionListener(event -> openFile());
		fileMenu.add(openItem);
		
		JMenuItem exitItem = new JMenuItem("Exit");
		exitItem.addActionListener(event -> System.exit(0));
		fileMenu.add(exitItem);
		
		JMenuBar menuBar = new JMenuBar();
		menuBar.add(fileMenu);
		setJMenuBar(menuBar);
	}
	
	/**
	 * Open a file and load the document
	 */
	public void openFile() {
		JFileChooser chooser = new JFileChooser();
		chooser.setCurrentDirectory(new File("./src/dom"));
		chooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("XML files", "xml"));
		int r = chooser.showOpenDialog(this);
		if (r != JFileChooser.APPROVE_OPTION) return;
		final File file = chooser.getSelectedFile();
		
		new SwingWorker<Document, Void>() {
			protected Document doInBackground() throws Exception {
				if (builder == null) {
					DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
					builder = factory.newDocumentBuilder();
				}
				return builder.parse(file);
			}
			
			protected void done() {
				try {
					Document doc = get();
					JTree tree = new JTree(new DOMTreeModel(doc));
					tree.setCellRenderer(new DOMTreeCellRenderer());
					
					setContentPane(new JScrollPane(tree));
					validate();
				} catch (Exception e) {
					JOptionPane.showMessageDialog(DOMTreeFrame.this, e); // 这个this是DOMTreeFrame的this
				}
			}
		}.execute(); // 用一个worker线程进行调度执行
	}
}

/**
 * This tree model describes the tree structure of an XML document.
 */
class DOMTreeModel implements TreeModel {
	private Document doc;
	
	/**
	 * Constructs a document tree model;
	 * @param doc the document
	 */
	
	public DOMTreeModel(Document doc) {
		this.doc = doc;
	}
	
	public Object getRoot() {
		return doc.getDocumentElement();
	}
	
	public int getChildCount(Object parent) {
		Node node = (Node) parent;
		NodeList list = node.getChildNodes();
		return list.getLength();
	}
	
	public Object getChild(Object parent, int index) {
		Node node = (Node) parent;
		NodeList list = node.getChildNodes();
		return list.item(index);
	}
	
	public int getIndexOfChild(Object parent, Object child) {
		Node node = (Node) parent;
		NodeList list = node.getChildNodes();
		for (int i = 0; i < list.getLength(); ++i) 
			if (getChild(node, i) == child) return i; // 同个对象
		return -1;
	}
	
	public boolean isLeaf(Object node) {
		return getChildCount(node) == 0;
	}
	
	public void valueForPathChanged(TreePath path, Object newValue) {}
	public void addTreeModelListener(TreeModelListener l) {}
	public void removeTreeModelListener(TreeModelListener l) {}
}

/**
 * This class renders an XML node.
 */
class DOMTreeCellRenderer extends DefaultTreeCellRenderer {
	public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected,
		boolean expanded, boolean leaf, int row, boolean hasFocus) {
		Node node = (Node) value;
		if (node instanceof Element) return elementPanel((Element) node);
		
		super.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
		if (node instanceof CharacterData) setText(characterString((CharacterData) node)); // 字符数据
		else setText(node.getClass() + ": " + node.toString());
		return this;
	}
	
	public static JPanel elementPanel(Element e) {
		JPanel panel = new JPanel();
		panel.add(new JLabel("Element: " + e.getTagName()));
		final NamedNodeMap map = e.getAttributes();
		panel.add(new JTable(new AbstractTableModel() {
			public int getRowCount() {
				return map.getLength();
			}
			
			public int getColumnCount() {
				return 2;
			}
			
			public Object getValueAt(int r, int c) {
				return c == 0 ? map.item(r).getNodeName() : map.item(r).getNodeValue();
			}
		}));
		
		return panel;
	}
	
	private static String characterString(CharacterData node) {
		StringBuilder builder = new StringBuilder(node.getData());
		for (int i = 0; i < builder.length(); ++i) {
			if (builder.charAt(i) == '\r') {
				builder.replace(i, i + 1, "\\r");
				++i;
			} else if (builder.charAt(i) == '\n') {
	            builder.replace(i, i + 1, "\\n");
	            ++i;
	        } else if (builder.charAt(i) == '\t') {
	            builder.replace(i, i + 1, "\\t");
	            ++i;
	        }
		}
		if (node instanceof CDATASection) builder.insert(0, "CDATASection: ");
		else if (node instanceof Text) builder.insert(0, "Text: ");
		else if (node instanceof Comment) builder.insert(0, "Comment: ");
		
		return builder.toString();
	}
}
```
该树形结构清楚地显示了子元素是怎样被「包含空白字符和注释的文本」包围起来的 `how child elements are surrounded by text containing whitespace and comments` 。为了更清楚起见，这个程序将换行和回车字符显示为 `\n` 和 `\r` （否则，它们将显示为空的文本框，这是Swing对「字符串中不能绘制的字符」显示的默认符号）。

Swing高级技术中，会学习到该程序中**用来显示树形结构和属性表的技术**。`DOMTreeModel` 类实现了 `treeModel` 接口。`getRoot` 方法返回文档的根元素，`getChild` 方法得到子元素的节点列表、并返回被请求的索引值的项。表的单元格渲染器 `DOMTreeCellRenderer` 显示了以下内容：
- 对元素，显示的是元素标签名和「由所有的属性构成的一张表」。
- 对字符数据，显示的是界面（文本、注释、CDATA部分），后面跟着数据，其中换行和回车字符被 `\n` 和 `\r` 取代。
- 对其他所有的节点类型，显示的是类名，后面跟着 `toString` 的结果。

> `javax.xml.parsers.DocumentBuilderFactory` 1.4
> - `static DocumentBuilderFactory newInstance()`
> 返回 `DocumentBuilderFactory` 类的一个实例。
> - `DocumentBuilder newDocumentBuilder()`
> 返回 `DocumentBuilder` 类的一个实例。

> - `javax.xml.parsers.DocumentBuilder` 1.4
> - `Document parse(File f)`
> - `Document parse(String url)`
> - `Document parse(InputStream in)`
> 解析来自给定文件、URL或输入流的XML文档，返回解析后的文档。

> `org.w3c.dom.Document` 1.4
> - `Element getDocumentElement()`
> 返回文档的根元素。

> `org.w3c.dom.Element` 1.4
> - `String getTagName()`
> 返回元素的名字。
> - `String getAttribute(String name)`
> 返回给定名字的属性值，没有该属性时返回空字符串。

> `org.w3c.dom.Node` 1.4
> - `NodeList getChildNodes()`
> 返回包含该节点所有子元素的节点列表。
> - `Node getFirstChild()`
> - `Node getLastChild()`
> 获取该节点的第一个或最后一个子节点，在该节点没有子节点时返回 `null` 。
> - `Node getNextSibling()`
> - `Node getPreviousSibling()`
> 获取该节点的下一个或上一个兄弟节点，在该节点没有兄弟节点时返回 `null` 。
> - `Node getParentNode()`
> 获取该节点的父节点，在该节点是文档节点时返回 `null` 。
> - `NamedNodeMap getAttributes()`
> 返回含有描述该节点属性的所有 `Attr` 节点的映射表。
> - `String getNodeName()`
> 返回该节点的名字。当该节点是 `Attr` 节点时，该名字就是属性名。
> - `String getNodeValue()`
> 返回该节点的值。当该节点是 `Attr` 节点时，该值就是属性值。

> `org.w3c.dom.CharacterData` 1.4
> - `String getData()`
> 返回存储在节点中的文本。

> `org.w3c.dom.NodeList` 1.4
> - `int getLength()`
> 返回列表中的节点数。
> - `Node item(int index)`
> 返回给定索引值的节点。索引值范围在 `0` 到 `getLength()-1` 之间。

> `org.w3c.dom.NamedNodeMap` 1.4
> - `int getLength()`
> 返回该节点映射表中的节点数。
> - `Node item(int index)`
> 返回给定索引值的节点。索引值范围在 `0` 到 `getLength()-1` 之间。

---
# 1.3 验证XML文档
在前一节中，了解了如何遍历DOM文档的树形结构。然而，==如果仅按照这种方法来操作，会发现需要大量冗长的编程和错误检查工作——不但需要处理元素间的空白字符，还要检查该文档包含的节点是否和期望的一样==。例如，在读入下面这个元素时，将首先得到第一个子节点，这是一个含有空白字符 `"\n"` 的文本节点。跳过文本节点找到第一个元素节点。然后，要检查它的标签名是不是 `"name"` ，还要检查它是否有一个 `Text` 类型的子节点。接下去，转到下一个非空白字符的子节点，并进行同样的检查。那么，当文档作者改变了子元素的顺序、或是加入另一个子元素时，又会怎样呢？要是对所有的错误检查进行编码，就会显得太琐碎麻烦了，而跳过这些检查又是不慎重的。
```xml
<font>
	<name>Helvetica</name>
	<size>36</size>
</font>
```
幸好，XML解析器的一个很大的好处就是**它能自动校验某个文档是否具有正确的结构** `it can automatically verify that a document has the correct structure` 。这样，解析就变得简单多了。例如，如果知道 `font` 片段已经通过了验证，那么不用进一步检查就能得到其两个孙节点，并把它们转换成 `Text` 节点，得到它们的文本数据。

如果要指定文档结构，可以提供一个文档类型定义 `DTD` 或一个 `XML Schema` 定义。  **DTD或XML Schema包含了解释文档应如何构成的规则，通过指定每个元素的合法子元素和属性**。例如，某个DTD可能含有一个规则：
```xml
<!ELEMENT font (name,size)>
```
这个规则表示，一个 `font` 元素必须总是有两个子元素，分别是 `name` 和 `size` 。用 `XML Scheme` 将同样的约束表示如下：
```xml
<xsd:element name="font">
	<xsd:sequence>
		<xsd:element name="name" type="xsd:string"/>
		<xsd:element name="size" type="xsd:int"/>
	</xsd:sequence>
</xsd:element>
```
与DTD相比，XML Schema可以表达更加复杂的验证条件（比如 `size` 元素必须包含一个整数）。与DTD语法不同，XML Schema语法自身使用XML，这为处理Schema文件带来了方便。

**XML Schema语言是设计用来替代DTD的**。然而，到 *Core Java* 出版为止，DTD仍然具有旺盛的生命力。XML Schema很复杂，且还远没有得到普遍的采纳。事实上，==某些XML用户对XML Schema的复杂性感到很烦恼，以致他们会采用其他可替代的验证语言==，最常用的一种就是[Relax NG](http://www.relaxng.org)。

下一节将详细讨论DTD。接着简要介绍XML Schema的一些基础知识。最后展示一个完整的应用程序、来演示验证是如何简化XML编程的 `how validation simplifies XML programming` 。
## 1.3.1 文档类型定义
提供DTD的方式有多种。可以像下面这样将其纳入到XML文档中：
```xml
<?xml version="1.0"?>
<!DOCTYPE config [
	<!ELEMENT config . . .>
	more rules
	...
]>
<config>
...
</config>
```
正如看到的，这些规则被纳入到了 `DOCTYPE` 声明中，该代码块使用 `[...]` 来限定其界限。文档类型必须匹配根元素的名字 `The document type must match the name of the root element` ，比如例子中的 `config` 。

==在XML文档内部提供DTD不是很普遍，因为DTD会使文件长度变得很长。把DTD存储在外面可能更具意义==。**`SYSTEM` 声明可以用来实现这个目标**。可以指定一个包含DTD的URL，例如：
```xml
<!DOCTYPE config SYSTEM "config.dtd">
```
或者：
```xml
<!DOCTYPE config SYSTEM "http://myserver.com/config.dtd">
```
> 警告：如果使用的是DTD的相对URL（比如 `"config.dtd"` ），那么要给解析器一个 `File` 或 `URL` 对象，而不是 `InputStream` 。如果必须从一个输入流来解析，请提供一个实体解析器，请看下面的说明。

最后，有一个来源于 `SGML` 的用于识别「“众所周知的”DTD」的机制，下面是一个例子：
```xml
<!DOCTYPE web-app
	PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN"
		"http://java.sun.com/j2ee/dtds/web-app_2_2.dtd">
```
如果一个XML处理器知道如何定位「带有公共标识符的DTD」`the DTD with the public identifier` ，那么就不需要转到URL了 ` it need not go to the URL` 。
> 注意：DTD的系统标识符URL `system identifier URL` 可能实际无法工作，或者会显著地降低性能。后者有一个例子，即 `XHTML 1.0 Strict DTD` 的[系统标识符](http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd)。如果要解析一个XHTML文件，可能会花费一两分钟来处理DTD。
> 
> 有一种方法是使用**实体解析器** `entity resolver` ，它会将公共标识符 `public identifiers` 映射为本地文件。在Java 9之前，我们不得不提供一个实现了 `EntityResolver` 接口、并实现了 `resolveEntity` 方法（该接口只有这个方法）的某个类的对象，并调用 `DocumentBuilder` 类的 `setEntityResolver` 方法、来安装「 `EntityResolver` 接口的某个实现类」 的一个对象。下面是一个典型实现的代码框架：
> ```java
> class MyEntityResolver implements EntityResolver {
>     public InputSource resolveEntity(String publicID, String systemID) {
>         if (publicID.equals(a known ID))
>             return new InputSource(DTD data);
>         else
>             return null; // use default behavior
>     }
> }
> ```
> 我们可以从 `InputStream` 、`Reader` 或字符串构建输入源 `construct the input source` 。
> 
> 但是现在，我们可以使用XML目录 `XML catalogs` 来管理这种映射。我们需要提供一个或多个「具有下面这种形式的目录文件 `catalog files` 」：
> ```xml
> <?xml version="1.0"?>
> <!DOCTYPE catalog 
>     PUBLIC "-//OASIS//DTD XML Catalogs V1.0//EN"
>     "http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd">
> <catalog xmlns="urn:oasis:names:tc:entity:xmlns:xml:catalog" prefer="public">
>     <public publicId=". . ." uri=". . ."/>
>     ...
> </catalog>
> ```
> 然后像下面这样构造和安装一个解析器：
> ```java
> builder.setEntityResolver(CatalogManager.catalogResolver(
>     CatalogFeatures.defaults(),
>     Paths.get("catalog.xml").toAbsolutePath().toUri()
> ));
> ```
> 参阅程序 `xpath/XPathTest.java` 中完整的示例。
> 
> 除了在程序中设置目录文件的位置，还可以在命令行中用 `javax.xml.catalog.files` 系统属性来设置它们，我们需要提供由分号分隔的 `file` 的绝对URL。

现在，我们已经知道解析器怎样定位DTD了，下面看看不同类型的规则。`ELEMENT` 规则用于指定某个元素可以拥有什么样的子元素。使用一个正则表达式，它由下表中所示组成。
![表2-1 元素内容的规则](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207120931738.png)

下面是一些简单而典型的例子。下面的规则声明了 `menu` 元素包含 $0$ 或多个 `item` 元素：
```xml
<!ELEMENT menu (item)*>
```
下面这组规则声明 `font` 是用一个 `name` 后跟一个 `size` 来描述的，它们都包含文本：
```xml
<!ELEMENT font (name,size)>
<!ELEMENT name (#PCDATA)>
<!ELEMENT size (#PCDATA)>
```
**缩写 `PCDATA` 表示已解析的字符数据 `parsed character data`** 。这些数据被称为“已解析的”是因为，解析器通过寻找「表示一个新标签起始的 `<` 字符」或「表示一个实体起始的 `&` 字符」，而解释了这些文本字符串。

**元素的规格说明可以包含「嵌套的和复杂的正则表达式」**，例如，下面是一条描述书中章节组成的规则，每章都以简介开头，其后是 $1$ 或多个小节，每个小节由一个标题和 $1$ 个或多个段落、图片、表格或说明构成。
```xml
<!ELEMENT chapter (intro,(heading,(para|image|table|note)+)+)
```
然而，有一种常见的情况，是不能把规则定义得像我们希望的那样灵活的。==当一个元素可以包含文本时，那么就只有两种合法的情况。要么元素只包含文本==，比如：
```xml
<!ELEMENT name (#PCDATA)>
```
==要么元素包含任意顺序的文本和标签的组合==，比如：
```xml
<!ELEMENT para (#PCDATA|em|strong|code)*>
```
==指定其他包含 `#PCDATA` 规则的类型都是不合法的==。例如，以下规则是非法的：
```xml
<!ELEMENT captionedImage (image,#PCDATA)>
```
必须重写这样的规则，要么引入另一个 `caption` 元素，要么允许 `image` 元素和文本的任何组合。

这种限制简化了XML解析器在解析混合式内容 `mixed content`（标签和文本的混合）时的工作。==因为在允许混合式内容时会难免失控，所以最好在设计DTD时，让其中所有的元素要么包含其他元素，要么只有文本==。
> 注意：实际上，**在DTD规则中并不能为元素指定任意的正则表达式**，XML解析器会拒绝某些导致非确定性的复杂规则。例如，正则表达式 `((x, y) | (x, z))` 就是非确定性的 `nondeterministic` 。当解析器看到 `x` 时，它不知道在两个选择中取哪一个。**这个表达式可以改写成确定性的形式**，如 `(x, (y|z))`（？不太明白，有区别吗？）。然而，有一些表达式不能被改写，如 `((x, y)*|x?)` 。**Java XML库中的解析器在遇到有歧义的DTD时，不会给出警告**。在解析时，它仅仅在两者中选取第一个匹配项，这将导致它拒绝一些正确的输入。当然，解析器有权这么做，因为**XML标准允许解析器假设DTD都是非二义性的** `the DTD is unambiguous` 。在实际应用中，这不是一个会让我们睡不着觉的问题，因为大多数DTD都非常简单，根本不会遇上二义性问题。

还可以指定描述合法的元素属性 `the legal attributes of elements` 的规则。通用语法为：
```xml
<!ATTLIST element attribute type default>
```
下表显示了合法的属性类型 `type` ，第二张表显示了属性默认值 `default` 的语法。
![表 属性类型](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207121909803.png)
- `CDATA` 属性值的处理与前面看到 `#PCDATA` 的处理，有着微妙的差别，并且与 `<![CDATA[...]]>` 部分没有多大关系。属性值首先被规范化，也就是说，解析器要处理对字符和实体的引用（比如 `&#233;` 或 `&lt;` ），并且要用空格来替换空白字符 `replaces whitespace with spaces` 。
- `NMTOKEN`（即名字标记 `name token` ）与 `CDATA` 相似，但是大多数非字母数字字符和内部的空白字符是不允许使用的，而且解析器会删除起始和结尾的空白字符。`NMTOKENS` 是一个以空白字符分隔的名字标记列表 `a whitespace-separated list of name tokens` 。
- ID结构是很有用的，ID是在文档中惟一的名字标记，解析器会检查其惟一性。在下一个示例程序中，会看到它的应用。`IDREF` 是对同一文档中已存在的ID的引用，解析器也会对它进行检查。`IDREFS` 是以空白字符分隔的ID引用的列表。
- `ENTITY` 属性值将引用一个“未解析的外部实体”。这是从 `SGML` 那里沿用下来的，在实际应用中很少见到。[被注解的XML规范](http://www.xml.com/axml/axml.html)有该属性的一个例子。

![表 属性的默认值](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207121909492.png)

以下是两个典型的属性规格说明。第一个规格说明描述了 `font` 元素的 `style` 属性。它有 $4$ 个合法的属性值，默认值是 `plain` 。第二个规格说明表示 `size` 元素的 `unit` 属性可以包含任意字符数据序列。
```xml
<!ATTLIST font style (plain|bold|italic|bold-italic) "plain">
<!ATTLIST size unit CDATA #IMPLIED>
```
> 注意：**一般情况下，我们推荐用元素而非属性来描述数据**。按照这个推荐，`font  style` 应该是一个独立的元素，例如 `<font><style>plain</style>...</font>` 。然而，==对于枚举类型，属性有一个不可否认的优点，那就是解析器能够校验取值是否合法==。例如，如果 `font style` 是一个属性，解析器就会检查它是不是 $4$ 个允许值之一，并且如果没有提供属性值，解析器还会提供一个默认值 `supplies a default if no value was given` 。

**DTD也可以定义实体，或者定义解析过程中被替换的缩写**。可以在Mozilla/Netscape 6浏览器的用户接口描述中、找到一个使用实体的很好的例子。这些描述被格式化为XML格式，包含了如下的实体定义：
```xml
<!ENTITY back.label "Back">
```
其他地方的文本可以包含对这个实体的引用，例如：
```xml
<menuitem label="&back.label;"/>
```
**解析器用替代字符串来替换实体引用**。如果要对应用程序进行国际化处理，只需修改实体定义中的字符串即可。其他实体的使用方法更加复杂，且不太常用，详细说明参见XML规范。

这样我们就结束了对DTD的介绍。现在已经知道如何使用DTD了，可以配置我们的解析器以充分利用它们。

首先，通知文档生成工厂 `the document builder factory` 打开验证特性。这样，该工厂生成的所有文档生成器都将根据DTD来验证它们的输入。
```java
factory.setValidating(true);
```
**验证的最大好处是可以忽略元素内容中的空白字符**。例如，考虑下面的XML代码片段：
```xml
<font>
	<name>Helvetica</name>
	<size>36</size>
</font>
```
一个不进行验证的解析器会报告 `font, name, size` 元素之间的空白字符，因为它无法知道 `font` 的子元素是哪一个：
```xml
(name,size)
(#PCDATA,name,size)*
ANY
```
一旦DTD指定了子元素是 `(name, size)` ，解析器就知道它们之间的空白字符不是文本。调用下面的代码，这样生成器将不会报告文本节点中的空白字符。这意味着，我们可以依赖 `font` 节点只有 $2$ 个子元素这一事实：
```java
factory.setIgnoringElementContentWhitespace(true);
```
再也不用编写下面这样的单调冗长的循环代码：
```java
for (int i = 0; i < children.getLength(); ++i) {
	Node child = children.item(i);
	if (child instanceof Element) {
		var childElement = (Element) child;
		if (childElement.getTagName().equals("name")) ...
		else if (childElement.getTagName().equals("size")) ...
	}
}
```
而只需通过如下代码访问第一个和第二个子元素：
```java
var nameElement = (Element) children.item(0);
var sizeElement = (Element) children.item(1);
```
这就是DTD如此有用的原因。我们不会因为检查规则而使程序负担过重。在得到文档 `document` 之前，解析器已经做完了这些工作。
> 提示：**许多刚开始使用XML的程序员都对验证不习惯，并且最终还是在系统运行过程中分析DOM树**。如果要说服同事、使他们相信使用验证过的文档的好处，就给他们看上述两种不同的编码方式，这样才能使他们相信你。

当解析器报告错误时，应用程序希望对该错误执行某些操作。例如，记录到日志中、把它显示给用户、或是抛出一个异常以放弃解析。因此，**在验证时，我们应该安装一个错误处理器，这需要提供一个实现了 `ErrorHandler` 接口的对象**。这个接口有三个方法：
```java
void warning(SAXParseException exception)
void error(SAXParseException exception)
void fatalError(SAXParseException exception)
```
可以通过 `DocumentBuilder` 类的 `setErrorHandler` 方法来安装错误处理器：
```java
builder.setErrorHandler(handler);
```

> `javax.xml.parsers.DocumentBuilder` 1.4
> - `void setEntityResolver(EntityResolver resolver)`
> 设置解析器，来定位要解析的XML文档中引用的实体。
> - `void setErrorHandler(ErrorHandler handler)`
> 设置报告解析过程中出现的错误和警告的处理器。

> `org.xml.sax.EntityResolver` 1.4
> - `public InputSource resolveEntity(String publicID, String systemID)`
> 返回一个输入源，它包含了「被给定ID所引用的数据」，或者，当解析器不知道如何解析这个特定名字时，返回 `null` 。如果没有提供 `publicID`，那么参数 `publicID` 可以为 `null` 。

> `org.xml.sax.InputSource` 1.4
> - `InputSource(InputStream in)`
> - `InputSource(Reader in)`
> - `InputSource(String systemID)`
> 从流、读入器或系统ID（通常是相对或绝对URL）中构建输入源。

> `org.xml.sax.ErrorHandler` 1.4
> - `void fatalError(SAXParseException exception)`
> - `void error(SAXParseException exception)`
> - `void warning(SAXParseException exception)`
> 覆盖这些方法以提供「对致命错误、非致命错误和警告进行处理的处理器」。

> `org.xml.sax.SAXParseException` 1.4
> - `int getLineNumber()`
> - `int getColumnNumber()`
> 返回引起异常的、已处理的输入信息末尾的行号和列号。

> `javax.xml.catalog.CatalogManager` 9
> - `static CatalogResolver catalogResolver(CatalogFeatures features, URI ... uris)`
> 产生一个解析器，它将使用「由所提供的URI指定的位置」上的目录文件。这个类实现了 `EntityResolver` 接口，StAX、Schema校验和XSL转换用到的解析器类也实现了该接口。

> `javax.xml.catalog.CatalogFeatures` 9
> - `static CatalogFeatures defaults()`
> 用默认设置产生一个实例。

> `javax.xml.parsers.DocumentBuilderFactory` 1.4
> - `boolean isValidating()`
> - `void setValidating(boolean value)`
> 获取和设置工厂的 `validating` 属性。当它设为 `true` 时，工厂生成的解析器会验证它们的输入信息。
> - `boolean isIgnoringElementContentWhitespace()`
> - `void setIgnoringElementContentWhitespace(boolean value)`
> 获取和设置工厂的 `ignoringElementContentWhitespace` 属性。当它设为 `true` 时，工厂生成的解析器会忽略「不含混合内容（即，元素与 `#PCDATA` 混合）的元素节点之间的空白字符」。

## 1.3.2 XML Schema
因为XML Schema比起DTD语法要复杂许多，所以我们只涉及其基本知识。更多信息请参考[指南](http://www.w3.org/TR/xmlschema-0)。

**如果要在文档中引用Schema文件，需要在根元素中添加属性**，例如：
```xml
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="config.xsd">
. . .
</config>
```
这个声明说明Schema文件 `config.xsd` 会被用来验证文档。如果使用命名空间，语法就更加复杂了。详细请参见XML Schema指南（前缀 `xsi` 是一个命名空间别名 `namespace alias` ，请查看第1.5节以了解更多信息）。

**Schema（使用名字空间）为每个元素和属性都定义了类型**。类型中的简单类型是对内容有限制的字符串，其他都是复杂类型。==具有简单类型的元素可以没有任何属性和子元素；否则，它就必然是复杂类型。与此相反，属性总是简单类型==。一些简单类型已经被内建到了XML Schema内，包括：
```xml
xsd:string
xsd:int
xsd:boolean
```
> 注意：我们用前缀 `xsd:` 来表示XSL Schema定义的命名空间。一些作者代之以 `xs:` 。

**可以定义自己的简单类型**。例如，下面是一个枚举类型：
```xml
<xsd:simpleType name="StyleType">
	<xsd:restriction base="xsd:string">
		<xsd:enumeration value="PLAIN" />
		<xsd:enumeration value="BOLD" />
		<xsd:enumeration value="ITALIC" />
		<xsd:enumeration value="BOLD_ITALIC" />
	</xsd:restriction>
</xsd:simpleType>
```
当定义元素时，要指定它的类型：
```xml
<xsd:element name="name" type="xsd:string"/>
<xsd:element name="size" type="xsd:int"/>
<xsd:element name="style" type="StyleType"/>
```
**类型约束了元素的内容**。例如，下面的元素将被验证为正确格式：
```xml
<size>10</size>
<style>PLAIN</style>
```
但是，下面的元素会被解析器拒绝：
```xml
<size>default</size>
<style>SLANTED</style>
```
**可以把类型组合成复杂类型**，如下所示，`FontType` 是 `name, size, style` 的序列。在这个类型定义中，我们用了 `ref` 属性来引用「在Schema中位于别处的定义」。
```xml
<xsd:complexType name="FontType">
	<xsd:sequence>
		<xsd:element ref="name"/>
		<xsd:element ref="size"/>
		<xsd:element ref="style"/>
	</xsd:sequence>
</xsd:complexType>
```
也可以嵌套定义，像这样（注意 `style` 元素的匿名类型定义）。
```xml
<xsd:complexType name="FontType">
	<xsd:sequence>
		<xsd:element name="name" type="xsd:string"/>
		<xsd:element name="size" type="xsd:int"/>
		<xsd:element name="style">
			<xsd:simpleType>
				<xsd:restriction base="xsd:string">
					<xsd:enumeration value="PLAIN" />
					<xsd:enumeration value="BOLD" />
					<xsd:enumeration value="ITALIC" />
					<xsd:enumeration value="BOLD_ITALIC" />
				</xsd:restriction>
			</xsd:simpleType>
		</xsd:element>
	</xsd:sequence>
</xsd:complexType>
```
**`xsd:sequence` 和DTD中的连接符号等价，而 `xsd:choice` 和 `|` 操作符等价**。如下所示，这和DTD中的类型 `email|phone` 类型是等价的。
```xml
<xsd:complexType name="contactinfo">
	<xsd:choice>
		<xsd:element ref="email"/>
		<xsd:element ref="phone"/>
	</xsd:choice>
</xsd:complexType>
```
**如果要允许重复元素，可以使用 `minoccurs` 和 `maxoccurs` 属性**，例如，与DTD类型 `item*` 的等价形式如下：
```xml
<xsd:element name="item" type="..." minoccurs="0" maxoccurs="unbounded">
```
如果要指定属性，可以把 `xsd:attribute` 元素添加到 `complexType` 定义中去：
```xml
<xsd:element name="size">
	<xsd:complexType>
		...
		<xsd:attribute name="unit" type="xsd:string" use="optional" default="cm"/>
	</xsd:complexType>
</xsd:element>
```
这是DTD声明等价的形式：
```xml
<!ATTLIST size unit CDATA #IMPLIED "cm">
```
可以把我们的Schema的元素和类型定义 `element and type definitions` 封装在 `xsd:schema` 元素中：
```xml
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
	...
</xsd:schema>
```
**解析「带有Schema的XML文件」和解析「带有DTD的文件」相似**，但有 $3$ 点差别：
1. 必须打开对命名空间的支持，即使在XML文件里你不使用它。
```java
factory.setNamespaceAware(true);
```
2. 必须通过如下“魔咒”来准备好处理 `Schema` 的工厂。	
```java
final String JAXP_SCHEMA_LANGUAGE = "http://java.sun.com/xml/jaxp/properties/schemaLanguage";
final String W3C_XML_SCHEMA = "http://www.w3.org/2001/XMLSchema";
factory.setAttribute(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);
```
3. 解析器不会丢弃元素中的空白字符，这确实很令人恼火，关于这是否是一个bug，人们看法不一。有一种变通方法，参看下列程序中的代码。

## 1.3.3 实用示例
在本节中介绍两个实用的示例程序、来说明在实际环境中XML的用法。

第一个示例程序见 *Core Java, 11 Edition* 。假设**有一个应用程序需要配置数据** `configuration data` ，这些数据可以**指定任意对象**、而不只是文本字符串。我们提供了两种机制来实例化对象：使用构造器和使用工厂方法。下面展示了如何使用构造器来构造 `Color` 对象。
```xml
<construct class="java.awt.Color">
	<int>55</int>
	<int>200</int>
	<int>100</int>
</construct>
```
下面是使用工厂方法的例子：
```xml
<factory class="java.util.logging.Logger" method="getLogger">
	<string>com.horstmann.corejava</string>
</factory>
```
如果忽略工厂方法名，那么其默认值就是 `getInstance` 。

正如所见，有多个元素用来描述字符串和整数。我们还支持 `boolean` 类型，其他基本类型也都可以按照相同方式添加进来。只是为了显摆一下，我们给出了第二种用于基本类型的机制：
```xml
<value type="int">30</value>
```
一个配置是由多个项构成的序列。每一项都有一个ID和一个对象 `A configuration is a sequence of entries. Each entry has an ID and an object` 。解析器会检查这些ID是否唯一。如下是配置文件 `read11/config.xml` ：
```xml
<?xml version="1.0"?>
<!DOCTYPE config SYSTEM "config.dtd">
<config>
  <entry id="background">
    <construct class="java.awt.Color">
      <int>55</int>
      <int>200</int>
      <int>100</int>
    </construct>
  </entry>
  <entry id="currency">
    <factory class="java.util.Currency">
      <string>USD</string>
    </factory>
  </entry>
</config>
```
```xml
// read11/config-schema.xml
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="config.xsd">
  <entry id="background">
    <construct class="java.awt.Color">
      <int>55</int>
      <int>200</int>
      <int>100</int>
    </construct>
  </entry>
  <entry id="currency">
    <factory class="java.util.Currency">
      <string>USD</string>
    </factory>
  </entry>
</config>
```

DTD显示在程序 `read11/config.dtd` 。
```java
// read11/config.dtd
<!ELEMENT config (entry)*>

<!ELEMENT entry (string|int|boolean|construct|factory)>
<!ATTLIST entry id ID #IMPLIED>

<!ELEMENT construct (string|int|boolean|construct|factory)*>
<!ATTLIST construct class CDATA #IMPLIED>

<!ELEMENT factory (string|int|boolean|construct|factory)*>
<!ATTLIST factory class CDATA #IMPLIED>
<!ATTLIST factory method CDATA "getInstance">

<!ELEMENT string (#PCDATA)>
<!ELEMENT int (#PCDATA)>
<!ELEMENT boolean (#PCDATA)>
```
**程序 `read11/config.xsd` 包含了一个等价的Schema**。**在这个Schema中，我们可以提供额外的检查**：一个 `int` 或 `boolean` 元素只能包含整数或布尔值。注意，这里使用了 `xsd:group` 结构来定义「会反复使用的复杂类型」的各个部件。
```xml
<!--  read11/config.xsd -->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <xsd:element name="config">
      <xsd:complexType>
         <xsd:sequence>
            <xsd:element name="entry" minOccurs="0" maxOccurs="unbounded">
               <xsd:complexType>
                  <xsd:group ref="Object"/>
                  <xsd:attribute name="id" type="xsd:ID"/>
               </xsd:complexType>
            </xsd:element>
         </xsd:sequence>            
      </xsd:complexType>
   </xsd:element>

   <xsd:element name="construct">
      <xsd:complexType>
         <xsd:group ref="Arguments"/>
         <xsd:attribute name="class" type="xsd:string"/>
      </xsd:complexType>
   </xsd:element>

   <xsd:element name="factory">
      <xsd:complexType>
         <xsd:group ref="Arguments"/>
         <xsd:attribute name="class" type="xsd:string"/>
         <xsd:attribute name="method" type="xsd:string" default="getInstance"/>
      </xsd:complexType>
   </xsd:element>

   <xsd:group name="Object">
      <xsd:choice>
         <xsd:element ref="construct"/>
         <xsd:element ref="factory"/>
         <xsd:element name="string" type="xsd:string"/>
         <xsd:element name="int" type="xsd:int"/>         
         <xsd:element name="boolean" type="xsd:boolean"/>         
      </xsd:choice>      
   </xsd:group>
   
   <xsd:group name="Arguments">
      <xsd:sequence>
         <xsd:group ref="Object" minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
   </xsd:group>
</xsd:schema>
```
`read11/XMLReadTest.java` 中的程序展示了如何解析一个简单的配置文件 *a sample configuration* ，配置定义在 `read11/config.xml` 中。如果我们选择了一个包含 `-schema` 的文件，那么该程序使用Schema而非DTD。
```java
// read11/XMLReadTest.java
package read11;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;

import javax.xml.parsers.*;

import org.w3c.dom.*;
import org.xml.sax.*;

/**
 * This program shows how to use an XML file to describe Java objects
 */
public class XMLReadTest {
	public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException, ReflectiveOperationException {
		String filename;
		if (args.length == 0) {
			try (var in = new Scanner(System.in)) {
				System.out.print("Input file: ");
				filename = in.nextLine();
			}
		} else filename = args[0];

		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		factory.setValidating(true);

		if (filename.contains("-schema")) {
			factory.setNamespaceAware(true);
			final String JAXP_SCHEMA_LANGUAGE = 
				"http://java.sun.com/xml/jaxp/properties/schemaLanguage";
			final String W3C_XML_SCHEMA = "http://www.w3.org/2001/XMLSchema";
			factory.setAttribute(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);
		}
		factory.setIgnoringElementContentWhitespace(true);

		DocumentBuilder builder = factory.newDocumentBuilder();
		builder.setErrorHandler(new ErrorHandler() {
			public void warning(SAXParseException e) throws SAXException {
				System.err.println("Warning: " + e.getMessage());
			}

			public void error(SAXParseException e) throws SAXException {
				System.err.println("Error: " + e.getMessage());
				System.exit(0);
			}

			public void fatalError(SAXParseException e) throws SAXException {
				System.err.println("Fatal error: " + e.getMessage());
				System.exit(0);
			}
		});

		Document doc = builder.parse(filename);
		Map<String, Object> config = parseConfig(doc.getDocumentElement());
		System.out.println(config);
	}

	private static Map<String, Object> parseConfig(Element e) 
		throws ReflectiveOperationException {
		var result = new HashMap<String, Object>();
		NodeList children = e.getChildNodes();
		for (int i = 0; i < children.getLength(); ++i) {
			var child = (Element)children.item(i);
			String name = child.getAttribute("id");
			Object value = parseObject((Element) child.getFirstChild());
			result.put(name, value);
		}
		return result;
	}

	private static Object parseObject(Element e) throws ReflectiveOperationException {
		String tagName = e.getTagName();
		if (tagName.equals("factory")) return parseFactory(e);
		else if (tagName.equals("construct")) return parseConstruct(e);
		else {
			String childData = ((CharacterData) e.getFirstChild()).getData();
			if (tagName.equals("int")) 
				return Integer.valueOf(childData);
			else if (tagName.equals("boolean")) 
				return Boolean.valueOf(childData);
			else
				return childData;
		}
	}

	private static Object parseFactory(Element e) 
		throws ReflectiveOperationException {
		String className = e.getAttribute("class");
		String methodName = e.getAttribute("method");
		Object[] args = parseArgs(e.getChildNodes());
		Class<?>[] parameterTypes = getParameterTypes(args);
		Method method = Class.forName(className).getMethod(methodName, parameterTypes);
		return method.invoke(null, args);
	}

	private static Object parseConstruct(Element e)
		throws ReflectiveOperationException {
		String className = e.getAttribute("class");
		Object[] args = parseArgs(e.getChildNodes());
		Class<?>[] parameterTypes = getParameterTypes(args);
		Constructor<?> constructor = Class.forName(className).getConstructor(parameterTypes);
		return constructor.newInstance(args);
	}

	private static Object[] parseArgs(NodeList elements) 
		throws ReflectiveOperationException {
		var result = new Object[elements.getLength()];
		for (int i = 0; i < result.length; ++i)
			result[i] = parseObject((Element) elements.item(i));
		return result;	
	}

	private static Map<Class<?>, Class<?>> toPrimitive = Map.of(
		Integer.class, int.class,
		Boolean.class, boolean.class
	);
	
	private static Class<?>[] getParameterTypes(Object[] args) {
		var result = new Class<?>[args.length];
		for (int i = 0; i < result.length; ++i) {
			Class<?> cl = args[i].getClass();
			result[i] = toPrimitive.get(cl);
			if (result[i] == null) result[i] = cl;
		}
		return result;
	}
}
```
这个例子是XML的典型用法。XML格式十分健壮，足以表达复杂的关系。在此基础上，通过接管有效性检查和提供默认值等例行工作，XML解析器添加了新的价值。

运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212181843527.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212181843764.png)


---
第二个示例程序见 *Core Java, 10 Edition* 。先回忆一下 *Core Java, Volume Ⅰ Chapter 9* ，`GridBagLayout` 是Swing构件中最有用的布局管理器。然而，人们都很畏惧它，这不仅是因为它的复杂，而且因为其编码冗长乏味。**把布局指令放到一个文本文件中 `put a layout description into a text file` 来替代大量重复代码将会带来很大便利**。在本节中，将看到怎样**用XML来描述网格组 `grid bag` 布局**和怎样解析布局文件 `the layout files` 。

**网格组是由行和列构成的，它和HTML表格非常相似**。与HTML表格相似的是，我们把它描述成一个行的序列，每个行都包含若干单元格：
```xml
<gridbag>
	<row>
		<cell>...</cell>
		<cell>...</cell>
		...
	</row>
	<row>
		<cell>...</cell>
		<cell>...</cell>
		...
	</row>
	...
</gridbag>
```
`gridbag.dtd` 指定了以下规则：
```xml
<!ELEMENT gridbag (row)*>
<!ELEMENT row (cell)*>
```
有些单元格可以跨多行多列。**在网格组布局中，这是通过将 `gridwidth` 和 `gridheight` 设置为大于 $1$ 的值来实现的**。这里使用相同的名字作为属性名：
```xml
<cell gridwidth="2" gridheight="2">
```
同样，我们**将属性应用于网格组的其他约束**：`fill, anchor, gridx, gridy, weightx, weighty, ipadx, ipady` （我们不处理 `insets` 约束，因为它的值不是简单类型，但是要支持它也是很简单的）。例如：
```xml
<cell fill="HORIZONTAL" anchor="NORTH">
```
对大多数属性，我们都提供了与 `GridBagConstraints` 的无参构造器所提供的相同的默认值：
```java
<!ATTLIST cell gridwidth CDATA "1">
<!ATTLIST cell gridheight CDATA "1">
<!ATTLIST cell fill (NONE|BOTH|HORIZONTAL|VERTICAL) "NONE">
<!ATTLIST cell anchor (CENTER|NORTH|NORTHEAST|EAST
	|SOUTHEAST|SOUTH|SOUTHWEST|WEST|NORTHWEST) "CENTER">
...
```
**`gridx` 和 `gridy` 的值受到了特殊处理**，因为如果手工设定会很冗长且易于出错。我们用以下的可选项来提供它们的值：
```java
<!ATTLIST cell gridx CDATA #IMPLIED>
<!ATTLIST cell gridy CDATA #IMPLIED>
```
如果没有提供这些值，程序会通过如下的启发方法来确定它们：在第 $0$ 列，`gridx` 的默认值是 $0$ ；否则，它是前面的 `gridx` 加上前面的 `gridwidth` ；`gridy` 的默认值总是与行数相同。这样，在跨越多行的大多数情况下你不必指定 `gridx` 和 `gridy` 的值。**但是，如果一个构件跨越多列，那么，每当要跨越这个构件时，就必须指定 `gridx`** 。
> 注意：网格组专家可能会奇怪，我们为什么不使用 `RELATIVE` 和 `REMAINDER` 机制、让网格组布局自动确定 `gridx` 和 `gridy` 的位置呢？我们试过这种方法，但是怎么也不能产生下图中那个字体对话框示例的布局。阅读了 `GridBagLayout` 的源代码后发现，很明显它的算法无法完成恢复绝对位置 *recover the absolute positions* 所必需的繁重任务。
> ![图 由XML布局定义的字体对话框](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207131311021.png)

**这个程序对属性进行解析，并且设置了网格组的约束条件**。例如，要读取网格宽度，程序需要包含下面这行代码：
```java
constraints.gridwidth = Integer.parseInt(e.getAttribute("gridwidth"));
```
程序不必担心属性的缺失，因为当文档中没有指定值时，解析器会自动提供默认值。

如果要测试 `gridx` 或 `gridy` 属性是否被指定了，我们可以调用 `getAttribute` 方法来检查它是否返回空串：
```java
value = e.getAttribute("gridy");
if (value.length() == 0) // use default
constraints.gridy = r;
else constraints.gridy = Integer.parseInt(value);
```
我们发现允许单元格包含任意对象会显得很方便，这使我们能指定如边界那样的非构件类型。这里只要求这些对象属于遵循JavaBean惯例的某个类，即具有一个默认构造器，而对每个属性都提供了相应的获取器（getter）/设置器（setter）对。

`bean` 是由一个类名和0或多个属性定义的：
```java
<!ELEMENT bean (class, property*)>
<!ATTLIST bean id ID #IMPLIED>

<!ELEMENT class (#PCDATA)>
```
属性包含一个名字和一个值，该值可以是整数、布尔值、字符串或者其他 `bean` ：
```java
<!ELEMENT property (name, value)>
<!ELEMENT name (#PCDATA)>
<!ELEMENT value (int|string|boolean|bean)>
```
下面是一个典型示例，这是一个 `JLabel` 对象的实例，它的文本属性被设为"Face："：
```java
<bean>
	<class>javax.swing.JLabel</class>
	<property>
		<name>text</name>
		<value><string>Face: </string></value>
	</property>
</bean>
```
把字符串用 `<string>` 标签围起来似乎有点麻烦。为什么不只用 `#PCDATA` 表示字符串、而把那个标签留给别的类型呢？因为那样我们必须使用混合式内容，这样会把 `value` 元素的规则弱化为：
```java
<!ELEMENT value (#PCDATA|int|boolean|bean)*>
```
然而，这样的规则允许任意混合的文本和标签。

程序可以使用 `BeanInfo` 类来设置属性，而 `BeanInfo` 可以枚举 `bean` 的属性描述符。我们用匹配名字的方式来查找属性，然后调用它的 `setter` 方法来设置其值。

**当我们的程序读入一个用户界面描述时，它有足够的信息来构建和布局用户界面构件**。但当然，这个界面是死的，因为它没有事件监听器。如果要添加事件监听器，我们必须先定位构件。因为这个缘故，我们为每个 `bean` 提供了ID类型的可选属性：
```java
<!ATTLIST bean id ID #IMPLIED>
```
例如，下面是一个带有ID的组合框：
```xml
<bean id="face">
	<class>javax.swing.JComboBox</class>
</bean>
```
回想一下，我们说过解析器会检查ID是否惟一。

程序员可以用下面的方式来附加事件处理器：
```java
gridbag = new GridBagPane("fontdialog.xml");
add(gridbag);

face = (JComboBox<String>) gridbag.get("face");
face.addActionListener(listener);
```
注意：在这个示例中，我们只使用XML来描述构件布局，而把在Java代码中附加事件处理器的工作留给了程序员。可以更进一步，==将该代码添加到XML描述中去==。==最有前途的方式是用JavaScript这样的脚本语言来编码这种代码==。如果你想添加这样的增强功能，参考[Rhino解释器](http://www.mozilla.org/rhino)。

`read10/GridBagTest.java` 显示了如何使用 `GridBagPane` 类、来完成设定网格组布局时所有的无聊工作，这个布局是在 `read10/fontdialog.xml` 中定义的。下图显示了运行结果。该程序只初始化了组合框（这项工作对于 `GridBagPane` 支持的 `bean` 属性设定机制来说过于复杂了）和添加事件监听器；`read10/GridBagPane.java` 中的 `GridBagPane` 类用于解析XML文件，构造构件并安置它们；`read10/gridbag.dtd` 显示的是DTD文件。

除了DTD，如果像下面这样运行，该程序也可以处理Schema：
```java
$ java GridBagTest fontdialog-shcema.xml
```
`read/gridbag.xsd` 就包含了一个Schema。
```xml
<!-- fontdialog-schema.xml -->
<?xml version="1.0"?>
<gridbag xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="gridbag.xsd">
   <row>
      <cell anchor="EAST">
      <bean>
        <class>javax.swing.JLabel</class>
        <property>
          <name>text</name>
          <value><string>Face: </string></value>
        </property>
      </bean>
    </cell>
    <cell fill="HORIZONTAL" weightx="100">
      <bean id="face">
        <class>javax.swing.JComboBox</class>
      </bean>
    </cell>
    <cell gridheight="4" fill="BOTH" weightx="100" weighty="100">
      <bean id="sample">
        <class>javax.swing.JTextArea</class>
        <property>
          <name>text</name>
          <value><string>The quick brown fox jumps over the lazy dog</string></value>
        </property>
        <property>
          <name>editable</name>
          <value><boolean>false</boolean></value>
        </property>
        <property>
          <name>lineWrap</name>
          <value><boolean>true</boolean></value>
        </property>
        <property>
          <name>border</name>
          <value>
            <bean>
              <class>javax.swing.border.EtchedBorder</class>
            </bean>
          </value>
        </property>
      </bean>
    </cell>
  </row>
  <row>
    <cell anchor="EAST">
      <bean>
        <class>javax.swing.JLabel</class>
        <property>
          <name>text</name>
          <value><string>Size: </string></value>
        </property>
      </bean>
    </cell>
    <cell fill="HORIZONTAL" weightx="100">
      <bean id="size">
        <class>javax.swing.JComboBox</class>
      </bean>
    </cell>
  </row>
  <row>
    <cell gridwidth="2" fill="NONE" weighty="100" >
      <bean id="bold">
        <class>javax.swing.JCheckBox</class>
        <property>
          <name>text</name>
          <value><string>Bold</string></value>
        </property>
      </bean>
    </cell>
  </row>
  <row>
    <cell gridwidth="2" fill="NONE" weighty="100" >
      <bean id="italic">
        <class>javax.swing.JCheckBox</class>
        <property>
          <name>text</name>
          <value><string>Italic</string></value>
        </property>
      </bean>
    </cell>
  </row>
</gridbag>
```

这个例子是XML的典型用法。XML格式十分健壮，足以表达复杂的关系。在此基础上，通过接管有效性检查和提供默认值等例行工作，XML解析器添加了新的价值。
```java
// read/GridBagTest.java
package read10;

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import javax.swing.*;

/**
 * This program shows how to use an XML file to describe a gridbag layout
 */
public class GridBagTest
{
    public static void main(String[] args)
    {
        EventQueue.invokeLater(() ->
            {
                JFileChooser chooser = new JFileChooser(".");
                chooser.showOpenDialog(null);
                File file = chooser.getSelectedFile();
                JFrame frame = new FontFrame(file);
                frame.setTitle("GridBagTest");
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setVisible(true);
        });
    }
}

/**
 * This frame contains a font selection dialog that is described by an XML file.
 * @param filename the file containing the user interface components for the dialog.
 */
class FontFrame extends JFrame
{
    private GridBagPane gridbag;
    private JComboBox<String> face;
    private JComboBox<String> size;
    private JCheckBox bold;
    private JCheckBox italic;

    @SuppressWarnings("unchecked")
    public FontFrame(File file)
    {
        gridbag = new GridBagPane(file);
        add(gridbag);

        face = (JComboBox<String>) gridbag.get("face");
        size = (JComboBox<String>) gridbag.get("size");
        bold = (JCheckBox) gridbag.get("bold");
        italic = (JCheckBox) gridbag.get("italic");

        face.setModel(new DefaultComboBoxModel<String>(new String[] { "Serif", 
                "SansSerif", "Monospaced", "Dialog", "DialogInput" }));

        size.setModel(new DefaultComboBoxModel<String>(new String[] { "8", 
                "10", "12", "15", "18", "24", "36", "48" }));

        ActionListener listener = event -> setSample();

        face.addActionListener(listener);
        size.addActionListener(listener);
        bold.addActionListener(listener);
        italic.addActionListener(listener);

        setSample();
        pack();
    }

    /**
     * This method sets the text sample to the selected font.
     */
    public void setSample()
    {
        String fontFace = face.getItemAt(face.getSelectedIndex());
        int fontSize = Integer.parseInt(size.getItemAt(size.getSelectedIndex()));
        JTextArea sample = (JTextArea) gridbag.get("sample");
        int fontStyle = (bold.isSelected() ? Font.BOLD : 0)
                + (italic.isSelected() ? Font.ITALIC : 0);

        sample.setFont(new Font(fontFace, fontStyle, fontSize));
        sample.repaint();
    }
}
```
```java
// read/GridBagPane.java
package read10;

import java.awt.*;
import java.beans.*;
import java.io.*;
import java.lang.reflect.*;
import javax.swing.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;

/**
 * This panel uses an XML file to describe its components and their grid bag layout positions.
 */
public class GridBagPane extends JPanel
{
   private GridBagConstraints constraints;

   /**
    * Constructs a grid bag pane.
    * @param filename the name of the XML file that describes the pane's components and their
    * positions
    */
   public GridBagPane(File file)
   {
      setLayout(new GridBagLayout());
      constraints = new GridBagConstraints();

      try
      {
         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
         factory.setValidating(true);

         if (file.toString().contains("-schema"))
         {
            factory.setNamespaceAware(true);
            final String JAXP_SCHEMA_LANGUAGE = 
               "http://java.sun.com/xml/jaxp/properties/schemaLanguage";
            final String W3C_XML_SCHEMA = "http://www.w3.org/2001/XMLSchema";
            factory.setAttribute(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);
         }

         factory.setIgnoringElementContentWhitespace(true);

         DocumentBuilder builder = factory.newDocumentBuilder();
         Document doc = builder.parse(file);
         parseGridbag(doc.getDocumentElement());         
      }
      catch (Exception e)
      {
         e.printStackTrace();
      }
   }

   /**
    * Gets a component with a given name
    * @param name a component name
    * @return the component with the given name, or null if no component in this grid bag pane has
    * the given name
    */
   public Component get(String name)
   {
      Component[] components = getComponents();
      for (int i = 0; i < components.length; i++)
      {
         if (components[i].getName().equals(name)) return components[i];
      }
      return null;
   }

   /**
    * Parses a gridbag element.
    * @param e a gridbag element
    */
   private void parseGridbag(Element e)
   {
      NodeList rows = e.getChildNodes();
      for (int i = 0; i < rows.getLength(); i++)
      {
         Element row = (Element) rows.item(i);
         NodeList cells = row.getChildNodes();
         for (int j = 0; j < cells.getLength(); j++)
         {
            Element cell = (Element) cells.item(j);
            parseCell(cell, i, j);
         }
      }
   }

   /**
    * Parses a cell element.
    * @param e a cell element
    * @param r the row of the cell
    * @param c the column of the cell
    */
   private void parseCell(Element e, int r, int c)
   {
      // get attributes

      String value = e.getAttribute("gridx");
      if (value.length() == 0) // use default
      {
         if (c == 0) constraints.gridx = 0;
         else constraints.gridx += constraints.gridwidth;
      }
      else constraints.gridx = Integer.parseInt(value);

      value = e.getAttribute("gridy");
      if (value.length() == 0) // use default
      constraints.gridy = r;
      else constraints.gridy = Integer.parseInt(value);

      constraints.gridwidth = Integer.parseInt(e.getAttribute("gridwidth"));
      constraints.gridheight = Integer.parseInt(e.getAttribute("gridheight"));
      constraints.weightx = Integer.parseInt(e.getAttribute("weightx"));
      constraints.weighty = Integer.parseInt(e.getAttribute("weighty"));
      constraints.ipadx = Integer.parseInt(e.getAttribute("ipadx"));
      constraints.ipady = Integer.parseInt(e.getAttribute("ipady"));

      // use reflection to get integer values of static fields
      Class<GridBagConstraints> cl = GridBagConstraints.class;

      try
      {
         String name = e.getAttribute("fill");
         Field f = cl.getField(name);
         constraints.fill = f.getInt(cl);

         name = e.getAttribute("anchor");
         f = cl.getField(name);
         constraints.anchor = f.getInt(cl);
      }
      catch (Exception ex) // the reflection methods can throw various exceptions
      {
         ex.printStackTrace();
      }

      Component comp = (Component) parseBean((Element) e.getFirstChild());
      add(comp, constraints);
   }

   /**
    * Parses a bean element.
    * @param e a bean element
    */
   private Object parseBean(Element e)
   {
      try
      {
         NodeList children = e.getChildNodes();
         Element classElement = (Element) children.item(0);
         String className = ((Text) classElement.getFirstChild()).getData();

         Class<?> cl = Class.forName(className);

         Object obj = cl.newInstance();

         if (obj instanceof Component) ((Component) obj).setName(e.getAttribute("id"));

         for (int i = 1; i < children.getLength(); i++)
         {
            Node propertyElement = children.item(i);
            Element nameElement = (Element) propertyElement.getFirstChild();
            String propertyName = ((Text) nameElement.getFirstChild()).getData();

            Element valueElement = (Element) propertyElement.getLastChild();
            Object value = parseValue(valueElement);
            BeanInfo beanInfo = Introspector.getBeanInfo(cl);
            PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();
            boolean done = false;
            for (int j = 0; !done && j < descriptors.length; j++)
            {
               if (descriptors[j].getName().equals(propertyName))
               {
                  descriptors[j].getWriteMethod().invoke(obj, value);
                  done = true;
               }
            }
         }
         return obj;
      }
      catch (Exception ex) // the reflection methods can throw various exceptions
      {
         ex.printStackTrace();
         return null;
      }
   }

   /**
    * Parses a value element.
    * @param e a value element
    */
   private Object parseValue(Element e)
   {
      Element child = (Element) e.getFirstChild();
      if (child.getTagName().equals("bean")) return parseBean(child);
      String text = ((Text) child.getFirstChild()).getData();
      if (child.getTagName().equals("int")) return new Integer(text);
      else if (child.getTagName().equals("boolean")) return new Boolean(text);
      else if (child.getTagName().equals("string")) return text;
      else return null;
   }
}
```
```xml
<!--  read/fontdialog.xml -->
<?xml version="1.0"?>
<!DOCTYPE gridbag SYSTEM "gridbag.dtd">
<gridbag>
   <row>
      <cell anchor="EAST">
         <bean>
            <class>javax.swing.JLabel</class>
            <property>
               <name>text</name>
               <value><string>Face: </string></value>
            </property>
         </bean>
      </cell>
      <cell fill="HORIZONTAL" weightx="100">
         <bean id="face">
            <class>javax.swing.JComboBox</class>
         </bean>
      </cell>
      <cell gridheight="4" fill="BOTH" weightx="100" weighty="100">
         <bean id="sample">
            <class>javax.swing.JTextArea</class>
            <property>
               <name>text</name>
               <value><string>The quick brown fox jumps over the lazy dog</string></value>
            </property>
            <property>
               <name>editable</name>
               <value><boolean>false</boolean></value>
            </property>
            <property>
               <name>rows</name>
               <value><int>8</int></value>
            </property>
            <property>
               <name>columns</name>
               <value><int>20</int></value>
            </property>
            <property>
               <name>lineWrap</name>
               <value><boolean>true</boolean></value>
            </property>
            <property>
               <name>border</name>
               <value>
                  <bean>
                     <class>javax.swing.border.EtchedBorder</class>
                  </bean>
               </value>
            </property>
         </bean>
      </cell>
   </row>
   <row>
      <cell anchor="EAST">
         <bean>
            <class>javax.swing.JLabel</class>
            <property>
               <name>text</name>
               <value><string>Size: </string></value>
            </property>
         </bean>
      </cell>
      <cell fill="HORIZONTAL" weightx="100">
         <bean id="size">
            <class>javax.swing.JComboBox</class>
         </bean>
      </cell>
   </row>
   <row>
      <cell gridwidth="2" weighty="100">
         <bean id="bold">
            <class>javax.swing.JCheckBox</class>
            <property>
               <name>text</name>
               <value><string>Bold</string></value>
            </property>
         </bean>
      </cell>
   </row>
   <row>
      <cell gridwidth="2" weighty="100">
         <bean id="italic">
            <class>javax.swing.JCheckBox</class>
            <property>
               <name>text</name>
               <value><string>Italic</string></value>
            </property>
         </bean>
      </cell>
   </row>
</gridbag>
```
```java
// read/gridbag.dtd
<!ELEMENT gridbag (row)*>
<!ELEMENT row (cell)*>
<!ELEMENT cell (bean)>
<!ATTLIST cell gridx CDATA #IMPLIED>
<!ATTLIST cell gridy CDATA #IMPLIED>
<!ATTLIST cell gridwidth CDATA "1">
<!ATTLIST cell gridheight CDATA "1">
<!ATTLIST cell weightx CDATA "0">
<!ATTLIST cell weighty CDATA "0">
<!ATTLIST cell fill (NONE|BOTH|HORIZONTAL|VERTICAL) "NONE">
<!ATTLIST cell anchor 
   (CENTER|NORTH|NORTHEAST|EAST|SOUTHEAST|SOUTH|SOUTHWEST|WEST|NORTHWEST) "CENTER">
<!ATTLIST cell ipadx CDATA "0">
<!ATTLIST cell ipady CDATA "0">

<!ELEMENT bean (class, property*)>
<!ATTLIST bean id ID #IMPLIED>

<!ELEMENT class (#PCDATA)>
<!ELEMENT property (name, value)>
<!ELEMENT name (#PCDATA)>
<!ELEMENT value (int|string|boolean|bean)>
<!ELEMENT int (#PCDATA)>
<!ELEMENT string (#PCDATA)>
<!ELEMENT boolean (#PCDATA)>
```
```xml
<!--  read/gridbag.xsd -->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">

   <xsd:element name="gridbag" type="GridBagType"/>

   <xsd:element name="bean" type="BeanType"/>

   <xsd:complexType name="GridBagType">
      <xsd:sequence>
         <xsd:element name="row" type="RowType" minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
   </xsd:complexType>

   <xsd:complexType name="RowType">
      <xsd:sequence>
         <xsd:element name="cell" type="CellType" minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
   </xsd:complexType>

   <xsd:complexType name="CellType">
      <xsd:sequence>
         <xsd:element ref="bean"/>
      </xsd:sequence>
      <xsd:attribute name="gridx" type="xsd:int" use="optional"/>
      <xsd:attribute name="gridy" type="xsd:int" use="optional"/>
      <xsd:attribute name="gridwidth" type="xsd:int" use="optional" default="1" />
      <xsd:attribute name="gridheight" type="xsd:int" use="optional" default="1" />
      <xsd:attribute name="weightx" type="xsd:int" use="optional" default="0" />
      <xsd:attribute name="weighty" type="xsd:int" use="optional" default="0" />
      <xsd:attribute name="fill" use="optional" default="NONE">
        <xsd:simpleType>
          <xsd:restriction base="xsd:string">
            <xsd:enumeration value="NONE" />
            <xsd:enumeration value="BOTH" />
            <xsd:enumeration value="HORIZONTAL" />
            <xsd:enumeration value="VERTICAL" />
          </xsd:restriction>
        </xsd:simpleType>
      </xsd:attribute>
      <xsd:attribute name="anchor" use="optional" default="CENTER">
        <xsd:simpleType>
          <xsd:restriction base="xsd:string">
            <xsd:enumeration value="CENTER" />
            <xsd:enumeration value="NORTH" />
            <xsd:enumeration value="NORTHEAST" />
            <xsd:enumeration value="EAST" />
            <xsd:enumeration value="SOUTHEAST" />
            <xsd:enumeration value="SOUTH" />
            <xsd:enumeration value="SOUTHWEST" />
            <xsd:enumeration value="WEST" />
            <xsd:enumeration value="NORTHWEST" />
          </xsd:restriction>
        </xsd:simpleType>
      </xsd:attribute>
      <xsd:attribute name="ipady" type="xsd:int" use="optional" default="0" />
      <xsd:attribute name="ipadx" type="xsd:int" use="optional" default="0" />
   </xsd:complexType>

   <xsd:complexType name="BeanType">
      <xsd:sequence>
         <xsd:element name="class" type="xsd:string"/>
         <xsd:element name="property" type="PropertyType" minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
      <xsd:attribute name="id" type="xsd:ID" use="optional" />
   </xsd:complexType>

   <xsd:complexType name="PropertyType">
      <xsd:sequence>
         <xsd:element name="name" type="xsd:string"/>
         <xsd:element name="value" type="ValueType"/>
      </xsd:sequence>
   </xsd:complexType>

   <xsd:complexType name="ValueType">
      <xsd:choice>
         <xsd:element ref="bean"/>
         <xsd:element name="int" type="xsd:int"/>
         <xsd:element name="string" type="xsd:string"/>
         <xsd:element name="boolean" type="xsd:boolean"/>
      </xsd:choice>
   </xsd:complexType>
</xsd:schema>
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212181933058.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212181933246.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212181934462.png)

---
## 1.4 使用XPath来定位信息
如果要定位某个XML文档中的一段特定信息，那么，通过遍历DOM树的众多节点来进行查找显得有些麻烦。XPath语言使得访问树节点变得很容易。例如，假设有如下XML文档：
```html
<html>
	<head>
		...
		<title>...</title>
		...
	</head>
	...
</html>
```
可以通过对XPath表达式 `/html/head/title/text()` 求值来得到标题中的文本。

使用XPath执行下列操作，比普通的DOM方式要简单得多：
1. 获得文档根节点。
2. 获取第一个子节点，并将其转型为一个 `Element` 对象。
3. 在其所有子节点中定位 `title` 元素。
4. 获取其第一个子元素，并将其转型为一个 `CharacterData` 节点。
5. 获取其数据。 

XPath可以描述XML文档中的一个节点集，例如下面的XPath，描述了XHTML文件中 `body` 元素的子元素中所有的 `form` 元素：
```java
/html/body/form
```
**可以用 `[]` 来选择特定元素**，这表示的是第一个 `form`（索引号从 $1$ 开始）：
```java
/html/body/form[1]
```
**使用 `@` 操作符可以得到属性值**。下列XPath表达式描述了第一个 `form` 中的 `action` 属性：
```java
/html/body/form[1]/@action
```
下列XPath表达式描述了 `body` 元素的子元素中所有 `form` 元素的所有 `action` 属性节点：
```java
/html/body/form/@action
```
XPath有很多有用的函数，如下所示返回 `body` 元素的 `form` 子元素的数量：
```java
count(/html/body/form)
```
精细的XPath表达式还有很多，参见[XPath规范](http://www.w3c.org/TR/xpath)，或[一个非常好的在线指南](http://www.zvon.org/xxl/XPathTutorial/General/examples.html)。

Java SE 5.0增加了一个API来计算XPath表达式，首先需要先从 `XPathFactory` 创建一个XPath对象：
```java
XPathFactory xpfactory = XPathFactory.newInstance();
path = xpfactory.newXPath();
```
然后，调用 `evaluate` 方法来计算XPath表达式：
```java
String username = path.evaluate("/html/head/title/text()", doc);
```
可以用同样的XPath对象来计算多个表达式。

**这种形式的 `evaluate` 方法将返回一个字符串。这很适合用来获取文本**，比如前面例子中的 `title` 元素节点中的文本子节点。如果XPath表达式产生了一组节点，请做如下调用。`XPathNodes` 类与 `NodeList` 类相似，但是它扩展了 `Iterable` 接口，使得我们可以使用增强的for循环。
```java
XPathNodes result = path.evaluateExpression("/html/body/form", doc,
	XPathNodes.class);
```
这个方法是在Java 9中添加进来的，在老版本中，需要使用下面这条语句：
```java
var nodes = (NodeList) path.evaluate("/html/body/form", doc,
	XPathConstants.NODESET);
```
如果结果只有一个节点，则使用下面的调用：
```java
Node node = path.evaluateExpression("/html/body/form[1]", doc, 
	Node.class);
node = (Node) path.evaluate("/html/body/form[1]", doc, 
	XPathConstants.NODE);
```
如果结果是一个数字，则使用：
```java
int count = path.evaluateExpression("count(/html/body/form)", doc,
	Integer.class);
count = ((Number) path.evaluate("count(/html/body/form)", doc,
	XPathConstants.NUMBER)).intValue();
```
**不必从文档的根节点开始搜索，可以从任意一个节点或节点列表开始**。例如，如果有前一次计算得到的节点，那么就可以调用：
```java
String result = path.evaluate(expression, node);
```
如果不知道XPath表达式的计算结果是什么（可能该表达式来自于用户），那么就调用：
```java
XPathEvaluationResult<?> result = path.evaluateExpression(expression, doc);
```
表达式 `result.type()` 是下列 `XPathEvaluationResult.XPathResultType` 枚举常量之一，调用 `result.type()` 可以获取结果值：
```java
STRING
NODESET
NODE
NUMBER
BOOLEAN
```
程序 `xpath10/XPathTester.java` 展示了对任意的XPath表达式的计算过程。==加载一个XML文件，输入一个表达式，选择表达式的类型，点击计算按钮，该表达式的结果就会显示出来==（见下图）。
![图 计算XPath表达式](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207150845585.png)
```java
package xpath10;

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.nio.file.*;
import java.util.*;

import javax.swing.*;
import javax.swing.border.*;

import javax.xml.namespace.*;
import javax.xml.parsers.*;
import javax.xml.xpath.*;

import org.w3c.dom.*;
import org.xml.sax.*;

/**
 * This program evaluates XPath expressions in GUI.
 */
public class XPathTester {
	public static void main(String[] args) {
		EventQueue.invokeLater(() -> {
			JFrame frame = new XPathFrame();
			frame.setTitle("XPathTester");
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}
}

/**
 * This frame shows an XML document, a panel to type an XPath expression, 
 * and a text file to display the result.
 */
class XPathFrame extends JFrame {
	private DocumentBuilder builder;
	private Document doc;
	private XPath path;
	private JTextField expression;
	private JTextField result;
	private JTextArea docText;
	private JComboBox<String> typeCombo;

	public XPathFrame() {
	    // 菜单项
		JMenu fileMenu = new JMenu("File");
		JMenuItem openItem = new JMenuItem("Open");
		openItem.addActionListener(event -> openFile());
		fileMenu.add(openItem);
      
		JMenuItem exitItem = new JMenuItem("Exit");
		exitItem.addActionListener(event -> System.exit(0));
		fileMenu.add(exitItem);
		// 菜单栏
		JMenuBar menuBar = new JMenuBar();
		menuBar.add(fileMenu);
		setJMenuBar(menuBar);
      
		// XPath表达式输入框、计算按钮
		ActionListener listener = event -> evaluate();
		expression = new JTextField(20);
		expression.addActionListener(listener);
		JButton evaluateButton = new JButton("Evaluate");
		evaluateButton.addActionListener(listener);
		// 复选框
		typeCombo = new JComboBox<String>(new String[] { 
			"STRING", "NODE", "NODESET", "NUMBER", "BOOLEAN" });
		typeCombo.setSelectedItem("STRING");
      
		JPanel panel = new JPanel();
		panel.add(expression);
		panel.add(typeCombo);
		panel.add(evaluateButton);
		docText = new JTextArea(10, 40);
		result = new JTextField();
		result.setBorder(new TitledBorder("Result"));

		add(panel, BorderLayout.NORTH); // XPath表达式输入框、计算按钮和复选框在北方
		add(new JScrollPane(docText), BorderLayout.CENTER); // 有滚动条
		add(result, BorderLayout.SOUTH);

		try {
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			builder = factory.newDocumentBuilder();
		} catch (ParserConfigurationException e) {
			JOptionPane.showMessageDialog(this, e);
		}

		XPathFactory xpfactory = XPathFactory.newInstance();
		path = xpfactory.newXPath();
		pack();
	}

	/**
	 * Open a file and load the document.
	 */
	public void openFile() {
		JFileChooser chooser = new JFileChooser();
		chooser.setCurrentDirectory(new File("./src/xpath10"));
		chooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("XML files", "xml"));
		
		int r = chooser.showOpenDialog(this);
		if (r != JFileChooser.APPROVE_OPTION) return;
		File file = chooser.getSelectedFile();
		
		try {
			docText.setText(new String(Files.readAllBytes(file.toPath()))); // 显示XML内容
			doc = builder.parse(file);
		} catch (IOException e) {
			JOptionPane.showMessageDialog(this, e);
		} catch (SAXException e) {
			JOptionPane.showMessageDialog(this, e);
		}
	}
	
	public void evaluate() {
		try {
			String typeName = (String) typeCombo.getSelectedItem(); // XPath表达式计算出的类型
			QName returnType = (QName) XPathConstants.class.getField(typeName).get(null);
			Object evalResult = path.evaluate(expression.getText(), doc, returnType);
			if (typeName.equals("NODESET")) {
				NodeList list = (NodeList) evalResult;
				// Can't use String.join since NodeList isn't Iterable
				StringJoiner joiner = new StringJoiner(",", "{", "}");
				for (int i = 0; i < list.getLength(); ++i)
					joiner.add("" + list.item(i));
				result.setText("" + joiner);
			} else result.setText("" + evalResult); // XPath计算结果显示区
		} catch (XPathExpressionException e) {
			result.setText("" + e);
		} catch (Exception e) { // reflectioin exception
			e.printStackTrace();
		}
	}
}
```
另一版本的程序 `xpath11/XPathTest.java` 则是一个命令行程序，输入要加载的一个XML文件的路径，再输入一个XPath表达式，该表达式的结果显示在命令行界面中：
```java
package xpath11;

import java.io.*;
import java.nio.file.*;
import java.util.*;

import javax.xml.catalog.*;
import javax.xml.parsers.*;
import javax.xml.xpath.*;

import org.w3c.dom.*;
import org.xml.sax.*;

/**
 * This program evaluates XPath expressions.
 */
public class XPathTest {
	public static void main(String[] args) throws Exception {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		
		// Avoid a delay in parsing an XHTML file
		builder.setEntityResolver(CatalogManager.catalogResolver( // 设置实体解析器
			CatalogFeatures.defaults(),
			Paths.get("xpath/catalog.xml").toAbsolutePath().toUri()
		));
		
		XPathFactory xpfactory = XPathFactory.newInstance();
		XPath path = xpfactory.newXPath();
		try (var in = new Scanner(System.in)){
			String filename;
			if (args.length == 0) {
				System.out.print("Input file: ");
				filename = in.nextLine();
			} else {
				filename = args[0];
			}
			Document doc = builder.parse(filename);
			var done = false;
			while (!done) {
				System.out.print("XPath expression (empty line to exit): ");
				String expression = in.nextLine();
				if (expression.trim().isEmpty()) done = true;
				else {
					try {
						XPathEvaluationResult<?> result =
							path.evaluateExpression(expression, doc);
						if (result.type() == XPathEvaluationResult.XPathResultType.NODESET) { // 节点列表
							for (Node n : (XPathNodes) result.value()) // 循环打印节点的值
								System.out.println(description(n));
						} else if (result.type() == XPathEvaluationResult.XPathResultType.NODE) { // 单个节点
							System.out.println((Node) result.value());
						} else // 不是节点列表也不是节点时
							System.out.println(result.value());
					} catch (XPathExpressionException e) {
						System.out.println(e.getMessage());
					}
				}
			}
		}
	}
	
	public static String description(Node n) {
		if (n instanceof Element) return "Element " + n.getNodeName();
		else if (n instanceof Attr) return "Attribute " + n;
		else return n.toString();
	}
}
```
使用之前的 `./src/dom/server.xml` 作为输入，结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207131913932.png)

> `javax.xml.xpath.XPathFactory` 5.0
> - `static XPathFactory newInstance()`
> 返回 `XPathFactory` 实例，用于创建 `XPath` 对象。
> - `XPath newXpath()`
> 构建 `XPath` 对象，用于计算XPath表达式。

> `javax.xml.xpath.XPath` 5.0
> - `String evaluate(String expression, Object startingPoint)`
> 从给定的起点计算表达式。起点可以是一个节点或节点列表。如果结果是一个节点或节点集，则返回的字符串由「所有文本节点子元素的数据」构成。
> - `Object evaluate(String expression, Object startingPoint, QName resultType)`
> 从给定的起点计算表达式。起点可以是一个节点或节点列表。`resultType` 是 `XPathConstants` 类的常量 `STRING, NODE, NODESET, NUMBER, BOOLEAN` 之一。返回值是 `String, Node, NodeList, Number, Boolean` 。
> - `<T> T evaluateExpression(String expression, Object item, Class<T> type)` 9
> 计算给定表达式，并产生一个给定类型的值、作为结果。
> - `XPathEvaluationResult<?> evaluateExpression(String expression, InputSource source)` 9
> 计算给定表达式。

> `javax.xml.xpath.XPathEvaluationResult<T>`
> - `XPathEvaluationResult.XPathResultType type()`
> 返回枚举常量 `STRING, NODESET, NODE, NUMBER, BOOLEAN` 。
> - `T value()`
> 返回结果值。

---
# 1.5 使用命名空间
Java语言使用包来避免名字冲突，程序员可以在不同的类中使用相同的名字，只要它们不在同一个包中即可。XML也有类似的命名空间 `namespace` 机制，可以用于元素名和属性名。

**名字空间是由统一资源标识符 `Uniform Resource Identifier, URI` 来标识的**，比如：
```java
http://www.w3.org/2001/XMLSchema
uuid:1c759aed-b748-475c-ab68-10679700c4f2
urn:com:books-r-us
```
HTTP的URL格式是最常用的。注意，URL只用作标识符字符串 `an identifier string` ，而不是一个文件的定位符 `a locator for a document` 。例如，下列名字空间标识符表示了不同的命名空间，尽管Web服务器将为这两个URL提供相同的文档：
```java
http://www.horstmann.com/corejava
http://www.horstmann.com/corejava/index.html
```
==在一个命名空间的URL所表示的位置上不需要有任何文档——XML解析器不会尝试去该处查找任何东西。然而，为了给遇到不熟悉的命名空间的程序员一些帮助，人们习惯于将「解释命名空间用途的文档」放置在URL位置上==。例如，如果把浏览器指向[XML Schema的命名空间URL](http://www.w3.org/2001/XMLSchema)，就会发现一个描述XML Schema标准的文档。

**为什么要用HTTP URL作为命名空间的标识符？这是因为这样容易确保它们是独一无二的**。如果使用一个实际的URL，那么主机部分的惟一性就将由域名系统来保证。然后，你的组织可以安排URL余下部分的惟一性，这和Java包名中的反向域名是一个原理。

虽然长命名空间标识符有利于唯一性，但我们不想再处理长标识符了。在Java中，可以**用 `import` 机制来指定很长的包名，然后只需使用较短的类名**。在XML中有类似的机制，比如：
```xml
<element xmlns="namespaceURI">
	children
</element>
```
现在，该元素和它的子元素都是给定命名空间的一部分了。

**子元素可以提供自己的命名空间**，例如：
```xml
<element xmlns="namespaceURI1">
	<child xmlns="namespaceURI2">
		grandchildren
	</child>
	more children
</element>
```
这时，第一个子元素和孙元素都是第二个命名空间的一部分。

无论是只需要一个命名空间，还是命名空间是自然嵌套的，这个简单机制都工作得很好。如若不然，就需要使用第二种机制，而Java中并没有类似的机制。**我们可以用一个前缀 <code><i>prefix</i></code> 来表示命名空间，即为特定文档选取的一个短的标识符**。下面是一个典型的例子——在一个XML Schema文件中的 `xsd` 前缀：
```xml
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<xsd:element name="config"/>
	...
	http://www.rejoiceblog.com/
</xsd:schema>
```
**属性 `xmlns:prefix="namespaceURI"` 用于定义命名空间和前缀**。在我们的例子中，前缀是 `xsd` 。这样，`xsd:schema` 实际上指的是"命名空间 `http://www.w3.org/2001/XMLSchema` "中的 `schema` 。
> 注意：==只有子元素继承它们父元素的命名空间，而不带显式前缀的属性不是命名空间的一部分== `Attributes without an explicit prefix` 。请看下面这个构造出来的例子：
> ```xml
> <configuration xmlns="http://www.horstmann.com/corejava" xmlns:si="http://www.bipm.fr/enus/3_SI/si.html">
>    <size value="210" si:unit="mm"/>
>    ...
> </configuration>
> ```
>   在这个示例中，元素 `configuration` 和 `size` 是URI为 `http://www.horstmann.com/corejava` 的命名空间的一部分。属性 `si:unit` 是URI为 `http://www.bipm.fr/enus/3_SI/si.html` 命名空间的一部分。然而，属性 `value` 不是任何命名空间的一部分。

**我们可以控制解析器对命名空间的处理**。默认情况下，Java XML库的DOM解析器并非“命名空间感知的 `namespace-aware` ”。要打开命名空间处理特性，调用 `DocumentBuilderFactory` 类的 `setNamespace Aware` 方法：
```java
factory.setNamespaceAware(true);
```
这样，工厂产生的所有生成器便都支持命名空间了。每个节点有三个属性：
- 带有前缀的限定名 `qualified name, with a prefix` ，由 `getNodeName` 和 `getTagName` 等方法返回。
- 命名空间URI，由 `getNamespaceURI` 方法返回。
- 不带前缀和命名空间的本地名 `local name, without a prefix or a namespace` ，由 `getLocalName` 方法返回。

下面是一个例子。假设解析器看到了以下元素：
```xml
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
```
它会报告：
- 限定名 = `xsd:schema`
- 命名空间URI = `http://www.w3.org/2001/XMLSchema`
- 本地名 = `schema`

> 注意：如果对命名空间的感知特性被关闭，`getLocalName` 和 `getNamespaceURI` 方法将返回 `null` 。

> `org.w3c.dom.Node` 1.4
> - `String getLocalName()`
> 返回本地名（不带前缀），或者在解析器不感知命名空间时，返回 `null` 。
> - `String getNamespaceURI()`
> 返回命名空间URI，或者在解析器不感知命名空间时，返回 `null` 。

> `javax.xml.parsers.DocumentBuilderFactory` 1.4
> - `boolean isNamespaceAware()`
> - `void setNamespaceAware(boolean value)`
获取或设置工厂的 `namespaceAware` 属性。当设为 `true` 时，工厂产生的解析器是命名空间感知的。

---
# 1.6 流机制解析器
**DOM解析器完整地读入XML文档，然后将其转换成一个树形的数据结构**。对于大多数应用，DOM都运行得很好。但是，如果文档很大，并且处理算法又非常简单，可以在运行时解析节点，而不必看到完整的树形结构，那么DOM可能就会显得效率低下了。在这种情况下，我们应该使用流机制解析器 `streaming parser` 。

在下面的小节中，讨论Java类库提供的流机制解析器：老而弥坚的SAX解析器和添加到Java SE 6中的更现代化的StAX解析器。SAX解析器使用的是**事件回调** `event callback` ，而StAX解析器提供了遍历解析事件的迭代器，后者用起来通常更方便一些。
## 1.6.1 使用SAX解析器
在解析XML输入的组成部分时，SAX解析器会报告事件，但不会以任何方式存储文档，而是由事件处理器 `event handlers` 建立相应的数据结构。实际上，**DOM解析器是在SAX解析器的基础上建立起来的**，它在接收到解析器事件 `parser events` 时建立DOM树。

在使用SAX解析器时，需要一个处理器来为不同的解析器事件定义事件动作 `event actions` 。`ContentHandler` 接口定义了若干个「在解析文档时解析器会调用的回调方法」。下面是最重要的几个：
- `startElement` 和 `endElement` 在每当遇到起始或终止标签时调用。
- `characters` 在每当遇到字符数据时调用。
- `startDocument` 和 `endDocument` 分别在文档开始和结束时各调用一次。

例如，解析以下片断时：
```xml
<font>
	<name>Helvetica</name>
	<size units="pt">36</size>
</font>
```
解析器会产生以下回调：
1. `startElement` ，元素名：`font`
2. `startElement` ，元素名：`name`
3. `characters` ，内容：`Helvetica`
4. `endElement` ，元素名：`name`
5. `startElement` ，元素名：`size` ，属性：`units="pt"`
6. `characters` ，内容：`36`
7. `endElement` ，元素名：`size`
8. `endElement` ，元素名：`font`

**我们的处理器必须覆盖 `override` 这些方法，让它们在解析文件时、执行我们想要执行的任何动作**。本节最后的程序会打印出一个HTML文件中的所有链接 `<a href="...">` 。它直接覆盖了处理器的 `startElement` 方法，用来检查名字为 `a` 、且属性名为 `href` 的链接，其潜在用途包括用于实现“网络爬虫”，即一个沿着链接到达越来越多网页的程序。
> 注意：遗憾的是，==HTML不必是合法的XML，大多数HTML页面都与良构的XML差别很大，以至于示例程序无法解析它们==。但是，W3C编写的大部分页面都是用XHTML编写的，**XHTML是一种HTML方言，又是良构的XML**，我们可以用这些页面来测试示例程序。例如，运行：
> ```shell
> $ java SAXTest http://www.w3c.org/MarkUp
> ```
> 将看到那个页面上所有链接的URL列表（**上面要用https！**）。

**示例程序是一个很好的使用SAX的例子**。我们根本不在乎 `a` 元素出现的上下文环境，而且不必存储树形结构。下面是如何得到SAX解析器的代码：
```java
SAXParserFactory factory = SAXParserFactory.newInstance();
SAXParser parser = factory.newSAXParser();
```
现在可以处理文档了：
```java
parser.parse(source, handler);
```
这里的 **`source` 可以是一个文件、一个URL字符串或者是一个输入流**。`handler` 属于 `DefaultHandler` 的一个子类，`DefaultHandler` 类为以下四个接口定义了空的方法：
```java
ContentHandler
DTDHandler
EntityResolver
ErrorHandler
```
示例程序定义了一个处理器，它覆盖了 `ContentHandler` 接口的 `startElement` 方法、来观察带有 `href` 属性的 `a` 元素。`startElement` 方法有 $3$ 个描述元素名的参数，其中 `qname` 参数以 `prefix:localname` 的形式报告限定名。如果命名空间处理特性已经打开，那么 `namespaceURI` 和 `lname` 参数描述的就是命名空间和本地（非限定）名 `local (unqualified) name` 。
```java
var handler = new DefaultHandler() {
	public void startElement(String namespaceURI, String lname, String qname, Attributes attrs) throws SAXException {
		if (lname.equalsIgnoreCase("a") && attrs != null) {
			for (int i = 0; i < attrs.getLength(); i++) {
				String aname = attrs.getLocalName(i);
				if (aname.equalsIgnoreCase("href"))
					System.out.println(attrs.getValue(i));
			}
		}
	}
};
```
**与DOM解析器一样，命名空间处理特性默认是关闭的**，可以调用工厂类的 `setNamespaceAware` 方法来激活命名空间处理特性：
```java
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(true);
SAXParser saxParser = factory.newSAXParser();
```
在这个程序中，我们还处理了另一个常见的问题。XHTML文件总是以一个「包含对DTD引用的标签」开头，解析器将加载这个DTD。可以理解的是，W3C肯定不乐意对诸如 `www.w3.org/TR/xhtml/DTD/xhtml-strict.dtd` 这样的文件提供千万亿次的下载。总有一天他们会完全拒绝提供这些文件，但到此时，他们还在并不情愿地提供DTD下载。**如果你不需要验证文件，只需调用**：
```java
factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
```
**程序 `sax/SAXTest.java` 包含了网络爬虫程序的代码**。具体代码如下所示：
```java　
package sax;

import java.io.*;
import java.net.*;
import javax.xml.parsers.*;

import org.xml.sax.*;
import org.xml.sax.helpers.*;

/**
 * This program demonstrates how to use a SAX parser. 
 * The program prints all hyperlinks of an XHTML web page. <br>
 * Usage: java sax.saxText URL
 */
// 命令行程序,展示如何使用一个SAX解析器,打印所有超链接
public class SAXTest {
	public static void main(String[] args) throws Exception {
		String url;
		if (args.length == 0) {
			url = "http://www.w3c.org/MarkUp";
			System.out.println("Using " + url);
		} else url = args[0]; // 得到URL
		
		var handler = new DefaultHandler() {
			public void startElement(String namespaceURI, String lname,
				String qname, Attributes attrs) {
				if (lname.equals("a") && attrs != null) { // 是超链接且属性不为空
					for (int i = 0; i < attrs.getLength(); ++i) {
						String aname = attrs.getLocalName(i);
						if (aname.equals("href")) // 且属性有href
							System.out.println(attrs.getValue(i));
					}
				}
			}
		};
		
		SAXParserFactory factory = SAXParserFactory.newInstance();
		factory.setNamespaceAware(true); // 可感知命名空间的
		factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
		SAXParser saxParser = factory.newSAXParser();
		InputStream in = new URL(url).openStream(); // 打开到这个URL的连接,并将读入内容返回为流
		saxParser.parse(in, handler);
	}
}
```
不过我没运行出来，它提示 `元素类型 "p" 必须由匹配的结束标记 "</p>" 终止` 。打印 `openStream()` 得到的结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207151311705.png)
参考[301 Moved Permanently问题排查与解决](https://blog.csdn.net/taipoucha5799/article/details/109490041)：
> 3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 重新发送请求获取资源，也就是重定向。
> - 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。
> - 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。
 > 
 > 301 和 302 都会在响应头里使用字段 Location ，指明后续要跳转的 URL，浏览器、postman等会自动定向新的 URL。

参考[java根据url下载文件出现301 Moved Permanently](https://blog.csdn.net/u013015301/article/details/94740880)，出现这种问题一般是由Nginx重新定向导致的，解决方法是**对Nginx重新定向、再重新实例化URL对象并进行操作**。再将后面一部分代码修改成如下所示，运行发现，新的URL应该为 `https://www.w3.org/MarkUp` 。谜团这才破解，原来URL改用HTTPS了、且改为 `w3` 了。
```java
	...
		URL realUrl = new URL(url); 
    	URLConnection conn = realUrl.openConnection(); // 打开和URL之间的连接
    	Map<String, List<String>> map = conn.getHeaderFields();
        for (String key : map.keySet()) { // 遍历所有的响应头字段
        	if ("Location".equals(key)) { //获取新地址
        		url = map.get(key).get(0);
        		System.out.println("newUrl---> " + url);
        		break;
        	}
        }
		InputStream in = new URL(url).openStream(); // 重新打开到这个URL的连接,并将读入内容返回为流
		for (byte c : in.readAllBytes()) System.out.print((char)c);
	}
}
```
改用新的URL后，运行还是提示 `元素类型 "p" 必须由匹配的结束标记 "</p>" 终止` ，即网页 `https://www.w3.org/MarkUp` 不符合XML标准。因此使用 `https://www.w3.org/` ，运行结果如下所示，下面还有一大串链接：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207151342516.png)

在后续部分，将会看到SAX的另一个有趣用法——「将非XML数据源转换成XML的一个简单方法」，就是报告XML解析器将要报告的SAX事件 ` report the SAX events that an XML parser would report` 。详细参见第1.8节。
> `javax.xml.parsers.SAXParserFactory` 1.4
> - `static SAXParserFactory newInstance()`
> 返回 `SAXParserFactory` 类的一个实例。
> - `SAXParser newSAXParser()`
> 返回 `SAXParser` 类的一个实例。
> - `boolean isNamespaceAware()`
> - `void setNamespaceAware(boolean value)`
> 获取和设置工厂的 `namespaceAware` 属性。当设为 `true` 时，该工厂生成的解析器是命名空间感知的。
> - `boolean isValidating()`
> - `void setValidating(boolean value)`
获取和设置工厂的 `validating` 属性。当设为 `true` 时，该工厂生成的解析器将要验证其输入。

> `javax.xml.parsers.SAXParser` 1.4
> - `void parse(File f, DefaultHandler handler)`
> - `void parse(String url, DefaultHandler handler)`
> - `void parse(InputStream in, DefaultHandler handler)`
> 解析来自给定文件、URL或输入流的XML文档，并把解析事件报告给指定的处理器。

> `org.xml.sax.ContentHandler` 1.4
> - `void startDocument()`
> - `void endDocument()`
> 在文档的起始或结束时被调用。
> - `void startElement(String uri, String lname, String qname, Attributes attr)`
> - `void endElement(String uri, String lname, String qname)`
> 在元素的起始或结束时被调用。如果解析器是名字空间感知的，那么它会报告名字空间的URI、无前缀的本地名字、以及带前缀的限定名。参数：
>   - `uri` ：命名空间的URI（如果解析器是命名空间感知的）
>   - `lname` ：不带前缀的本地名（如果解析器是命名空间感知的）
>   - `qname` ：元素名（如果解析器是命名空间感知的），或者是带有前缀的限定名（如果解析器除了报告本地名之外还报告限定名）
> - `void characters(char[] data, int start, int length)`
> 解析器报告字符数据时被调用。参数：
>   - `data` ：字符数据数组
>   - `start` ：在「作为被报告的字符 `characters` 的一部分」的字符数组中，第一个字符的索引
>   - `length` ：被报告的字符串的长度

> `org.xml.sax.Attributes` 1.4
> - `int getLength()`
> 返回存储在该属性集合中属性数量。
> - `String getLocalName(int index)`
> 返回给定索引的属性的本地名（无前缀），或当解析器不是命名空间感知的时返回空字符串。
> - `String getURI(int index)`
> 返回给定索引的属性的命名空间URI，或当该节点不是命名空间的一部分，或解析器不是命名空间感知的时返回空字符串。
> - `String getQName(int index)`
> 返回给定索引的属性的限定名（带前缀），或当解析器不报告限定名时返回空字符串。
> - `String getValue(int index)`
> - `String getValue(String qname)`
> - `String getValue(String uri, String lname)`
根据给定索引、限定名或命名空间URI+本地名，返回属性值；该值不存在时，返回 `null` 。

## 1.6.2 使用StAX解析器
**StAX解析器是一种“拉解析器 `pull parser` ”**，与安装事件处理器不同，我们只需使用下面这样的基本循环来**迭代所有的事件**：
```java
InputStream in = url.openStream();
XMLInputFactory factory = XMLInputFactory.newInstance();
XMLStreamReader parser = factory.createXMLStreamReader(in);
while (parser.hasNext()) {
	int event = parser.next();
	Call parser methods to obtain event details
}
```
例如，在解析下面的片断时：
```xml
<font>
	<name>Helvetica</name>
	<size units="pt">36</size>
</font>
```
解析器将产生下面的事件：
1. `START_ELEMENT` ，元素名：`font`
2. `CHARACTERS` ，内容：空白字符
3. `START_ELEMENT` ，元素名：`name`
4. `CHARACTERS` ，内容：`Helvetica`
5. `END_ELEMENT` ，元素名：`name`
6. `CHARACTERS` ，内容：空白字符
7. `START_ELEMENT` ，元素名：`size`
8. `CHARACTERS` ，内容：`36`
9. `END_ELEMENT` ，元素名：`size`
10. `CHARACTERS` ，内容：空白字符
11. `END_ELEMENT` ，元素名：`font`

要分析这些属性值，需要调用 `XMLStreamReader` 类的恰当方法，例如如下语句获取当前元素的 `units` 属性。
```java
String units = parser.getAttributeValue(null, "units");
```
**默认情况下，命名空间处理是启用的**，可以通过修改下面的工厂来使其无效：
```java
XMLInputFactory factory = XMLInputFactory.newInstance();
factory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, false);
```
程序 `stax/StAXTest.java` 包含了用StAX解析器实现的网络爬虫程序。正如所见，这段代码比等效的SAX代码要简短了许多，因为此时我们不必操心事件处理问题。
```java
package stax;

import java.io.*;
import java.net.*;
import javax.xml.stream.*;

/**
 * This program demonstrates how to use a StAX parser. 
 * The program prints all hyperlinks of an XHTML web page. <br>
 * Usage: java stax.StAXTest URL
 */
public class StAXTest {
	public static void main(String[] args) throws Exception {
		String url;
		if (args.length == 0) {
			url = "https://www.w3.org/";
			System.out.println("Using " + url);
		} else url = args[0];
		
		InputStream in = new URL(url).openStream(); // 重新打开到这个URL的连接,并将读入内容返回为流
		XMLInputFactory factory = XMLInputFactory.newInstance();
		XMLStreamReader parser = factory.createXMLStreamReader(in);
		while (parser.hasNext()) {
			int event = parser.next();
			if (event == XMLStreamConstants.START_ELEMENT) { // 开始元素事件
				if (parser.getLocalName().equals("a")) { // 是超链接
					String href = parser.getAttributeValue(null, "href");
					if (href != null)
						System.out.println(href);
				}
			}
		}
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207151401768.png)

> `javax.xml.stream.XMLInputFactory` 6
> - `static XMLInputFactory newInstance()`
> 返回 `XMLInputFactory` 类的一个实例。
> - `void setProperty(String name, Object value)`
> 设置这个工厂的属性，或者在要设置的属性不支持设置成给定值时，抛出 `IllegalArgument Exception` 。Java SE的实现支持下列 `Boolean` 类型的属性：
>   - `"javax.xml.stream.isValidating` 为 `false`（默认值）时，这个文档不被验证。规范不要求。
>   - `"javax.xml.stream.isNamespaceAware"` 为 `true`（默认值）时，将处理命名空间。规范不要求。
>   - `"javax.xml.stream.isCoalescing"` 为 `false`（默认值）时，邻近的字符数据不进行连接 `coalesce` 。
>   - `"javax.xml.stream.isReplacingEntityReferences"` 为 `true`（默认值）时，实体引用将作为字符数据被替换和报告。
>   - `"javax.xml.stream.isSupportingExternalEntities"` 为 `true`（默认值）时，外部实体将被解析。规范对于这个属性没有给出默认值。
>   - `"javax.xml.stream.supportDTD"` 为 `true`（默认值）时，DTD将作为事件被报告。
> - `XMLStreamReader createXMLStreamReader(InputStream in)`
> - `XMLStreamReader createXMLStreamReader(InputStream in, String character Encoding)`
> - `XMLStreamReader createXMLStreamReader(Reader in)`
> - `XMLStreamReader createXMLStreamReader(Source in)`
> 创建一个从给定的流、`reader` 或JAXP源读入的解析器。

> `javax.xml.stream.XMLStreamReader` 6
> - `boolean hasNext()`
> 如果有另一个解析事件，则返回 `true` 。
> `int next()`
> 将解析器的状态设置为下一个解析事件，并返回下列常量之一：`START_ELEMENT, END_ELEMENT, CHARACTERS, START_DOCUMENT, END_DOCUMENT, CDATA, COMMENT, SPACE`（可忽略的空白字符）、`PROCESSING_INSTRUCTION, ENTITY_REFERENCE, DTD` 。
> - `boolean isStartElement()`
> - `boolean isEndElement()`
> - `boolean isCharacters()`
> - `boolean isWhiteSpace()`
> 如果当前事件是一个开始元素、结束元素、字符数据或空白字符，则返回 `true` 。
> - `QName getName()`
> - `String getLocalName()`
> 获取在 `START_ELEMENT` 或 `END_ELEMENT` 事件中的元素的名字。
> - `String getText()`
> 返回一个 `CHARACTERS, COMMENT, CDATA` 事件对应的字符 `characters` ，或一个 `ENTITY_REFERENCE` 的替换值，或者一个DTD的内部子集。
> - `int getAttributeCount()`
> - `QName getAttributeName(int index)`
> - `String getAttributeLocalName(int index)`
> - `String getAttributeValue(int index)`
> 只要当前事件是 `START_ELEMENT` ，则获取属性数量和属性的名字与值。
> - `String getAttributeValue(String namespaceURI, String name)`
> 只要当前事件是 `START_ELEMENT` ，则获取给定属性的值。如果 `namespaceURI` 为 `null` ，则不检查名字空间。

---
# 1.7 生成XML文档
现在已经知道怎样编写「**读取XML的Java程序**」了。下面让我们开始介绍它的反向过程，即**产生XML输出**。当然，我们可以直接通过一系列 `print` 调用，打印出各元素、属性和文本内容、来编写XML文件——但这并不是一个好主意这样代码会非常冗长复杂，对于属性值和文本内容中的那些特殊符号（如：`"` 和 `<` ），一不注意就会出错。

一个比较好的方法是，**用文档的内容构建一棵DOM树，然后再写出该树的所有内容**。下面的小节将讨论其细节。
# 1.7.1 不带命名空间的文档
要建立一棵DOM树，可以从一个空的文档开始。通过调用 `DocumentBuilder` 类的 `newDocument` 方法可以得到一个空文档。
```java
Document doc = builder.newDocument();
```
使用 `Document` 类的 `createElement` 方法可以构建文档里的元素：
```java
Element rootElement = doc.createElement(rootName); 
Element childElement = doc.createElement(childName);
```
使用 `createTextNode` 方法可以构建文本节点：
```java
Text textNode = doc.createTextNode(textContents);
```
使用以下方法可以给文档添加根元素，给父结点添加子节点：
```java
doc.appendChild(rootElement); 
rootElement.appendChild(childElement);
childElement.appendChild(textNode);
```
在建立DOM树时，可能还需要设置元素属性，只需调用 `Element` 类的 `setAttribute` 方法：
```java
rootElement.setAttribute(name, value);
```
# 1.7.2 带命名空间的文档
如果要使用命名空间，那么创建文档的过程就会稍微有些区别。首先，**需要将生成器工厂设置为是命名空间敏感的，然后再创建生成器**：
```java
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
factory.setNamespaceAware(true);
builder = factory.newDocumentBuilder();
```
然后**使用 `createElementNS` 而不是 `createElement` 来创建所有节点**：
```java
String namespace = "http://www.w3.org/2000/svg";
Element rootElement = doc.createElementNS(namespace, "svg");
```
如果节点具有带命名空间前缀的限定名 `your node has a qualified name with a namespace prefix` ，那么所有必需的 `xmlns` 前缀属性都会被自动创建。例如，如果需要在HTML中包含SVG，那么就可以像下面这样构建元素：
```java
Element svgElement = doc.createElement(namespace, "svg:svg")
```
当该元素被写入XML文件时，它会转变为：
```xml
<svg:svg xmlns:svg="http://www.w3.org/2000/svg">
```
如果需要设置的元素其属性名字位于命名空间中，那么可以使用 `Element` 类的 `setAttributeNS` 方法：
```java
rootElement.setAttributeNS(namespace, qualifiedName, value);
```
## 1.7.3 写出文档
有些奇怪的是，把DOM树写出到输出流中并非一件易事。最容易的方式是**使用可扩展的格式页转换** `Extensible Stylesheet Language Transformations, XSLT` API。关于XSLT的更多信息，参见1.8节“XSL转换”。当下，我们先考虑「根据生成XML输出的“魔咒”」而编写的代码。

我们把「“不做任何操作”的转换」应用于文档，并且捕获它的输出。为了将一个 `DOCTYPE` 节点纳入输出，我们还需要**将 `SYSTEM` 和 `PUBLIC` 标识符设置为输出属性**。
```java
// construct the do-nothing transformation
Transformer t = TransformerFactory.newInstance().newTransformer();
// set output properties to get a DOCTYPE node
t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemIdentifier);
t.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, publicIdentifier);
// set indentation
t.setOutputProperty(OutputKeys.INDENT, "yes");
t.setOutputProperty(OutputKeys.METHOD, "xml");
t.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
// apply the do-nothing transformation and send the output to a file
t.transform(new DOMSource(doc), new StreamResult(new FileOutputStream(file)));
```
另一种方式是使用 `LSSerializer` 接口。为了获取实例，可以使用下面的魔咒：
```java
DOMImplementation impl = doc.getImplementation();
var implLS = (DOMImplementationLS) impl.getFeature("LS", "3.0");
LSSerializer ser = implLS.createLSSerializer();
```
如果需要**空格和换行**，可以设置下面的标志：
```java
ser.getDomConfig().setParameter("format-pretty-print", true);
```
然后可以易如反掌地**将文档转换为字符串**：
```java
String str = ser.writeToString(doc);
```
**如果想要将输出直接写入到文件中，则需要一个 `LSOutput`** ：
```java
LSOutput out = implLS.createLSOutput();
out.setEncoding("UTF-8");
out.setByteStream(Files.newOutputStream(path));
ser.write(doc, out);
```
> `javax.xml.parsers.DocumentBuilder` 1.4
> - `Document newDocument()`
> 返回一个空文档。

> `org.w3c.dom.Document` 1.4
> - `Element createElement(String name)`
> - `Element createElementNS(String uri, String qname)`
> 返回具有给定名字的元素。
> - `Text createTextNode(String data)`
> 返回具有给定数据的文本节点。

> `org.w3c.dom.Node` 1.4
> - `Node appendChild(Node child)`
> **将一个节点附加到该节点的子节点列表**，返回该节点。

> `org.w3c.dom.Element` 1.4
> - `void setAttribute(String name, String value)`
> - `void setAttributeNS(String uri, String qname, String value)`
> 将有给定名字的属性设置为指定的值。参数：
>   - `uri` ：名字空间的URI或 `null` 
>   - `qname` ：限定名。如果有别名前缀，`uri` 不能为 `null` 
>   - `value` ：属性值

> `javax.xml.transform.TransformerFactory` 1.4
> - `static TransformerFactory newInstance()`
> 返回 `TransformerFactory` 类的一个实例。
> - `Transformer newTransformer()`
> 返回 `Transformer` 类的一个实例，它用来实现标识符转换 `an identity (do-nothing) transformation` 。

> `javax.xml.transform.Transformer` 1.4
> - `void setOutputProperty(String name, String value)`
> 设置输出属性。标准输出属性参见[标准](http://www.w3.org/TR/xslt#output)，其中最有用的几个参数如下所示：
>   - `doctype-public` ：`DOCTYPE` 声明中使用的公共ID
>   - `doctype-system` ：`DOCTYPE` 声明中使用的系统ID
>   - `Indent` ：`"yes"` 或者 `"no"`
>   - `method`　`"xml", "html", "text"` 或定制的字符串 `a custom string`
> - `void transform(Source from, Result to)`
> 转换一个XML文档。

> `javax.xml.transform.dom.DOMSource` 1.4
> - `DOMSource(Node n)`
> 根据给定的节点构建一个源。通常，`n` 是文档节点。

> `javax.xml.transform.stream.StreamResult` 1.4
> - `StreamResult(File f)`
> - `StreamResult(OutputStream out)`
> - `StreamResult(Writer out)`
> - `StreamResult(String systemID)`
> 根据文件、流、写入程序或系统ID（通常是相对或绝对URL）来构建数据流结果。

## 1.7.4 使用StAX写XML文档
在前一节中，看到了如何通过「写DOM树的方法」来产生XML文件。**如果这个DOM树没有其他任何用途，那么这种方式就不是很高效**。

StAX API使我们可以直接将XML树写出 `write an XML tree directly` 。从某个 `OutputStream` 中构建一个 `XMLStreamWriter` ，就像下面这样：
```java
XMLOutputFactory factory = XMLOutputFactory.newInstance();
XMLStreamWriter writer = factory.createXMLStreamWriter(out);
```
要**产生XML文件头**，需要调用：
```java
writer.writeStartDocument();
```
然后调用：
```java
writer.writeStartElement(name);
```
添加属性需要调用：
```java
writer.writeAttribute(name, value);
```
现在，可以通过再次调用 `writeStartElement` 添加新的子节点，或者用下面的语句写出字符：
```java
writer.writeCharacters(text);
```
在添加完所有子节点之后，调用：
```java
writer.writeEndElement();
```
**这会导致当前元素被关闭**。

要写出没有子节点的元素 `an element without children`（例如 `<img.../>` ；应该是**只有单个标签、没有对应结束标签的元素**），可以使用下面的调用：
```java
writer.writeEmptyElement(name);
```
最后，在文档的结尾，调用：
```java
writer.writeEndDocument();
```
这个调用将关闭所有的元素。

<font color='red'>**我们仍然需要关闭 `XMLStreamWriter` ，并且需要手动关闭**</font>，因为 `XMLStreamWriter` 接口不扩展 `AutoCloseable` 接口。

与使用 `DOM/XSLT` 方式一样，我们不必担心属性值和字符数据中的转义字符。但是，我们仍旧有可能会产生非良构的XML，例如具有多个根节点的文档。并且，StAX当前的版本还没有任何对产生缩进输出的支持。

## 1.7.5 两个示例：生成SVG文件
下面的两个示例（同样目标）是生成XML输出的典型程序——它们都绘制了一幅现代画，即一组随机的彩色矩形（参见下图）。它们展示了**两种产生XML的方式：通过构建并保存DOM树；直接用StAX API写出XML**。
![图 生成的现代艺术品](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207152225588.png)

我们使用可伸缩向量图形 `Scalable Vector Graphics, SVG` 来保存作品——==SVG是XML格式的，它使用设备无关的方式描述复杂图形，可以在[W3C网址](http://www.w3.org/Graphics/SVG)找到更多关于SVG的信息==。我们没有涉及SVG的细节。就我们的目的而言，我们只需要知道怎样表示一组彩色的矩形。下面是一个例子：
```java
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20000802//EN"
	"http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd">
<svg xmlns="http://www.w3.org/2000/svg" width="300" height="150">
<rect x="231" y="61" width="9" height="12" fill="#6e4a13"/>
<rect x="107" y="106" width="56" height="5" fill="#c406be"/>
...
</svg>
```
正如看到的，每个矩形都描述为一个 `rect` 节点。它有位置、宽度、高度和填充色等属性，其中填充色以十六进制RGB值表示。
> 注意：**SVG大量使用了属性**。实际上，某些属性相当复杂。例如， `path` 元素 `<path d="M 100 100 L 300 100 L 200 300 z">` 之中，`M` 是指 `"moveto"` 命令、`L` 是指 `"lineto"` 、`z` 是指 `"closepath"`（！）。显然，**该数据格式的设计者不太信任XML表示结构化数据的能力**。在自己的XML格式中，可能想使用元素来替代复杂的属性。

**要查看SVG文件，只需使用任意的现在主流的浏览器**，这也是程序 `write11/XMLWriteTest.java`（在浏览器中打开）的做法，不过程序 `write10/XMLWriteTest.java, write10/XMLWriteFrame.java, write10/RectangleComponent.java` 使用了GUI，后两个类是矩形绘制的框架和组件类。

先看第10版书的程序：
```java
// write10/XMLWriteTest.java
package write;

import java.awt.*;
import javax.swing.*;

/**
 * This program shows how to write an XML file. It saves a file describing a modern drawing in SVG
 * format.
 * @version 1.12 2016-04-27
 * @author Cay Horstmann
 */
public class XMLWriteTest
{
    public static void main(String[] args)
    {
        EventQueue.invokeLater(() ->
            {
                JFrame frame = new XMLWriteFrame();
                frame.setTitle("XMLWriteTest");
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setVisible(true);
            });
    }
}
```
```java
// write10/XMLWriteFrame.java
package write;

import java.io.*;
import java.nio.file.*;

import javax.swing.*;
import javax.xml.stream.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;

import org.w3c.dom.*;
/**
 * A frame with a component for showing a modern drawing.
 */
public class XMLWriteFrame extends JFrame
{
    private RectangleComponent comp;
    private JFileChooser chooser;

    public XMLWriteFrame()
    {
        chooser = new JFileChooser();

        // add component to frame

        comp = new RectangleComponent();
        add(comp);

        // set up menu bar

        JMenuBar menuBar = new JMenuBar();
        setJMenuBar(menuBar);

        JMenu menu = new JMenu("File");
        menuBar.add(menu);

        JMenuItem newItem = new JMenuItem("New");
        menu.add(newItem);
        newItem.addActionListener(event -> comp.newDrawing());
        
        JMenuItem saveItem = new JMenuItem("Save with DOM/XSLT");
        menu.add(saveItem);
        saveItem.addActionListener(event -> saveDocument()); 

        JMenuItem saveStAXItem = new JMenuItem("Save with StAX");
        menu.add(saveStAXItem);
        saveStAXItem.addActionListener(event -> saveStAX());
        
        JMenuItem exitItem = new JMenuItem("Exit");
        menu.add(exitItem);
        exitItem.addActionListener(event -> System.exit(0));
        pack();
    }

    /**
     * Saves the drawing in SVG format, using DOM/XSLT
     */
    public void saveDocument() 
    {
        try 
        {
            if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) return;
            File file = chooser.getSelectedFile();
            Document doc = comp.buildDocument();
            Transformer t = TransformerFactory.newInstance().newTransformer();
            t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM,
                    "http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd");
            t.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, "-//W3C//DTD SVG 20000802//EN");
            t.setOutputProperty(OutputKeys.INDENT, "yes");
            t.setOutputProperty(OutputKeys.METHOD, "xml");
            t.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
            t.transform(new DOMSource(doc), new StreamResult(Files.newOutputStream(file.toPath())));
        }
        catch (TransformerException | IOException ex) 
        { 
            ex.printStackTrace();
        }        
    }
    
    /**
     * Saves the drawing in SVG format, using StAX
     */
    public void saveStAX()
    {
        if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) return;
        File file = chooser.getSelectedFile();
        XMLOutputFactory factory = XMLOutputFactory.newInstance();
        try
        {
            XMLStreamWriter writer = factory.createXMLStreamWriter(Files.newOutputStream(file.toPath()));
            try
            {
                comp.writeDocument(writer);
            }
            finally
            {
                writer.close(); // Not autocloseable
            }
        }            
        catch (XMLStreamException | IOException ex) 
        { 
            ex.printStackTrace();
        }        
    }
}
```
```java
// write10/RectamgleComponent.java
package write10;

import java.awt.*;
import java.awt.geom.*;
import java.util.*;
import javax.swing.*;
import javax.xml.parsers.*;
import javax.xml.stream.*;
import org.w3c.dom.*;

/**
 * A component that shows a set of colored rectangles
 */
public class RectangleComponent extends JComponent
{
    private static final Dimension PREFERRED_SIZE = new Dimension(300, 200);    

    private java.util.List<Rectangle2D> rects;
    private java.util.List<Color> colors;
    private Random generator;
    private DocumentBuilder builder;

    public RectangleComponent()
    {
        rects = new ArrayList<>();
        colors = new ArrayList<>();
        generator = new Random();

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        try
        {
            builder = factory.newDocumentBuilder();
        }
        catch (ParserConfigurationException e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Create a new random drawing.
     */
    public void newDrawing()
    {
        int n = 10 + generator.nextInt(20);
        rects.clear();
        colors.clear();
        for (int i = 1; i <= n; i++)
        {
            int x = generator.nextInt(getWidth());
            int y = generator.nextInt(getHeight());
            int width = generator.nextInt(getWidth() - x);
            int height = generator.nextInt(getHeight() - y);
            rects.add(new Rectangle(x, y, width, height));
            int r = generator.nextInt(256);
            int g = generator.nextInt(256);
            int b = generator.nextInt(256);
            colors.add(new Color(r, g, b));
        }
        repaint();
    }

    public void paintComponent(Graphics g)
    {
        if (rects.size() == 0) newDrawing();
        Graphics2D g2 = (Graphics2D) g;

        // draw all rectangles
        for (int i = 0; i < rects.size(); i++)
        {
            g2.setPaint(colors.get(i));
            g2.fill(rects.get(i));
        }
    }

    /**
     * Creates an SVG document of the current drawing.
     * @return the DOM tree of the SVG document
     */
    public Document buildDocument()
    {        
        String namespace = "http://www.w3.org/2000/svg";
        Document doc = builder.newDocument();
        Element svgElement = doc.createElementNS(namespace, "svg");
        doc.appendChild(svgElement);
        svgElement.setAttribute("width", "" + getWidth());
        svgElement.setAttribute("height", "" + getHeight());
        for (int i = 0; i < rects.size(); i++)
        {
            Color c = colors.get(i);
            Rectangle2D r = rects.get(i);
            Element rectElement = doc.createElementNS(namespace, "rect");
            rectElement.setAttribute("x", "" + r.getX());
            rectElement.setAttribute("y", "" + r.getY());
            rectElement.setAttribute("width", "" + r.getWidth());
            rectElement.setAttribute("height", "" + r.getHeight());
            rectElement.setAttribute("fill", String.format("#%06x",
                    c.getRGB() & 0xFFFFFF));
            svgElement.appendChild(rectElement);
        }
        return doc;
    }

    /**
     * Writes an SVG document of the current drawing.
     * @param writer the document destination
     */
    public void writeDocument(XMLStreamWriter writer) throws XMLStreamException
    {
        writer.writeStartDocument();
        writer.writeDTD("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 20000802//EN\" " 
                + "\"http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd\">");
        writer.writeStartElement("svg");
        writer.writeDefaultNamespace("http://www.w3.org/2000/svg");
        writer.writeAttribute("width", "" + getWidth());
        writer.writeAttribute("height", "" + getHeight());
        for (int i = 0; i < rects.size(); i++)
        {
            Color c = colors.get(i);
            Rectangle2D r = rects.get(i);
            writer.writeEmptyElement("rect");
            writer.writeAttribute("x", "" + r.getX());
            writer.writeAttribute("y", "" + r.getY());
            writer.writeAttribute("width", "" + r.getWidth());
            writer.writeAttribute("height", "" + r.getHeight());
            writer.writeAttribute("fill", String.format("#%06x",
                    c.getRGB() & 0xFFFFFF));            
        }
        writer.writeEndDocument(); // closes svg element
    }  

    public Dimension getPreferredSize() { return PREFERRED_SIZE; }
}
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212181306120.png)

再看第11版书的程序，**需要手动关闭 `XMLStreamWriter` **：
```java
package write11;

import java.io.*;
import java.nio.file.*;
import java.util.*;

import javax.xml.parsers.*;
import javax.xml.stream.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;

import org.w3c.dom.*;

/**
 * This program shows how to write an XML file.
 * It produces modern art in SVG format.
 */
public class XMLWriteTest {
	public static void main(String[] args) throws Exception {
		Document doc = newDrawing(600, 400);
		writeDocument(doc, "./src/write11/drawing1.svg"); // 写文档
		writeNewDrawing(600, 400, "./src/write11/drawing2.svg"); // 写SVG文件
	}
	
	private static Random generator = new Random();
	
	/**
	 * Create a new random drawing.
	 * @param drawingWidth the width of the drawing in pixels
	 * @param drawingHeight the width of the drawing in pixels
	 * @return the DOM tree of the SVG document
	 */
	public static Document newDrawing(int drawingWidth, int drawingHeight) 
		throws ParserConfigurationException {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		factory.setNamespaceAware(true); // 可感知名字空间的
		DocumentBuilder builder = factory.newDocumentBuilder();
		
		var namespace = "http://www.w3.org/2000/svg";
      	Document doc = builder.newDocument();
      	Element svgElement = doc.createElementNS(namespace, "svg");
      	doc.appendChild(svgElement);
        svgElement.setAttribute("width", "" + drawingWidth);
        svgElement.setAttribute("height", "" + drawingHeight);
        
        int n = 10 + generator.nextInt(20);
        for (int i = 1; i <= n; ++i) {
        	int x = generator.nextInt(drawingWidth);
        	int y = generator.nextInt(drawingHeight);
        	int width = generator.nextInt(drawingWidth - x);
        	int height = generator.nextInt(drawingHeight - y);
        	
        	int r = generator.nextInt(256);
            int g = generator.nextInt(256);
            int b = generator.nextInt(256);   
            
            Element rectElement = doc.createElementNS(namespace, "rect"); 
            rectElement.setAttribute("x", "" + x);
            rectElement.setAttribute("y", "" + y);
            rectElement.setAttribute("width", "" + width);
            rectElement.setAttribute("height", "" + height);
            rectElement.setAttribute("fill", String.format("#%02x%02x%02x", r, g, b));
            svgElement.appendChild(rectElement);
         }
         return doc;
	}
	/**
	 * Saves a document using DOM/XSLt.
	 * @param doc the document to be written
	 * @param filename the name of the destination file
	 */
	public static void writeDocument(Document doc, String filename) 
		throws TransformerException, IOException {
		Transformer t = TransformerFactory.newInstance().newTransformer();
	    t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM,
	    	"http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd");
	    t.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, 
            "-//W3C//DTD SVG 20000802//EN");
        t.setOutputProperty(OutputKeys.INDENT, "yes");
        t.setOutputProperty(OutputKeys.METHOD, "xml");
        t.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
        t.transform(new DOMSource(doc), new StreamResult(
        	Files.newOutputStream(Paths.get(filename))));
     }
	
	// 另一种方式产生XML文件
	/**
	 * Uses StAX to write an SVG document with a random drawing.
	 * @param drawingWidth the width of the drawing in pixels
	 * @param drawingHeight the width of the drawing in pixels
	 * @param filename the name of the destination file
	 */
	public static void writeNewDrawing(int drawingWidth, int drawingHeight, String filename) 
		throws XMLStreamException, IOException {
		XMLOutputFactory factory = XMLOutputFactory.newInstance();
		XMLStreamWriter writer = factory.createXMLStreamWriter(
			Files.newOutputStream(Paths.get(filename))
		);
		writer.writeStartDocument();
		writer.writeDTD("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 20000802//EN\" " 
			+ "\"http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd\">");
		writer.writeStartElement("svg");
		writer.writeDefaultNamespace("http://www.w3.org/2000/svg");
		writer.writeAttribute("width", "" + drawingWidth);
		writer.writeAttribute("height", "" + drawingHeight);
		
		int n = 10 + generator.nextInt(20);      
      	for (int i = 1; i <= n; i++) {
      		int x = generator.nextInt(drawingWidth);
      		int y = generator.nextInt(drawingHeight);
      		int width = generator.nextInt(drawingWidth - x);
      		int height = generator.nextInt(drawingHeight - y);
      		int r = generator.nextInt(256);
      		int g = generator.nextInt(256);
      		int b = generator.nextInt(256);
      		writer.writeEmptyElement("rect");
      		writer.writeAttribute("x", "" + x);
      		writer.writeAttribute("y", "" + y);
      		writer.writeAttribute("width", "" + width);
      		writer.writeAttribute("height", "" + height);
      		writer.writeAttribute("fill", String.format("#%02x%02x%02x", r, g, b)); 
      }
//      writer.writeEndElement(); // closes svg element
      writer.writeEndDocument(); // closes svg element
      writer.close();  // remember!
   }  
}
```
运行结果为下面两幅图：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207171401665.png)

> `javax.xml.stream.XMLOutputFactory` 6
> - `static XMLOutputFactory newInstance（）
> 返回 `XMLOutputFactory` 类的一个实例。
> - `XMLStreamWriter createXMLStreamWriter（OutputStream in）
> - `XMLStreamWriter createXMLStreamWriter（OutputStream in，String character Encoding）
> - `XMLStreamWriter createXMLStreamWriter（Writer in）
> - `XMLStreamWriter createXMLStreamWriter（Result in）
> 创建写出到给定流、写出器或JAXP结果的写出器。

> `javax.xml.stream.XMLStreamWriter 6
> - `void writeStartDocument()`
> - `void writeStartDocument(String xmlVersion)`
> - `void writeStartDocument(String encoding, String xmlVersion)`
> 在文档的顶部写入XML处理指令。注意，`encoding` 参数只是用于写入这个属性，它不会设置输出的字符编码机制。
> - `void setDefaultNamespace(String namespaceURI)`
> - `void setPrefix(String prefix, String namespaceURI)`
> 设置默认的命名空间，或者具有前缀的命名空间。这种声明的作用域只是当前元素，如果没有写入任何元素，其作用域为文档的根。
> - `void writeStartElement(String localName)`
> - `void writeStartElement(String namespaceURI, String localName)`
> 写出一个开始标签，其中 `namespaceURI` 将用相关联的前缀来代替。
> - `void writeEndElement()`
> **关闭** `close` 当前元素。
> - `void writeEndDocument()`
> **关闭** `close` 所有打开的元素。
> - `void writeEmptyElement(String localName)`
> - `void writeEmptyElement(String namespaceURI, String localName)`
> 写出一个**自闭合** `self-closing` 的标签，其中 `namespaceURI` 将用相关联的前缀来代替。
> - `void writeAttribute(String localName, String value)`
> - `void writeAttribute(String namespaceURI, String localName, String value)`
> 写出一个用于当前元素的属性，其中 `namespaceURI` 用相关联的前缀来代替。
> - `void writeCharacters(String text)`
> 写出字符数据。
> - `void writeCData(String text)`
> 写出 `CDATA` 块。
> - `void writeDTD(String dtd)`
> 写出 `dtd` 字符串，该字串需要包含一个 `DOCTYPE` 声明。
> - `void writeComment(String comment)`
> 写出一个注释。
> - `void close()`
> 关闭这个写出器。

---
# 15.8 XSL转换（一个示例程序）
XSL转换（XSLT）机制允许我们指定「将XML文档转换为其他格式的规则」，例如纯文本、XHTML或其他任何XML格式。==XSLT通常用来将「某种机器可读的XML格式」转译为「另一种机器可读的XML格式」，或者将XML转译为「适于人类阅读的表示格式」==。

我们需要提供XSLT样式表 `XSLT stylesheet` ，它描述了「XML文档向某种其他格式转换的规则」。XSLT处理器将读入XML文档和这个样式表，并产生所要的输出（参见下图）。
![图2-7 应用XSL转换](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207152317314.png)

XSLT规范很复杂，已经有很多书描述了该主题。我们不可能讨论XSLT的全部特性，所以只能介绍一个有代表性的例子。可以在 *Don Box* 等人合著的 *Essential XML* 一书中找到更多的信息，或查看[XSLT规范](http://www.w3.org/TR/xslt)。

下面是一个典型的例子。我们想要把有雇员记录的XML文件转换成HTML文件。请看这个输入文件：
```xml
<staff>
	<employee>
		<name>Carl Cracker</name>
 		<salary>75000</salary>
		<hiredate year="1987" month="12" day="15"/>
	</employee>
	<employee>
		<name>Harry Hacker</name>
		<salary>50000</salary>
		<hiredate year="1989" month="10" day="1"/>
	</employee>
	<employee>
		<name>Tony Tester</name>
		<salary>40000</salary>
		<hiredate year="1990" month="3" day="15"/>
	</employee>
</staff>
```
我们希望的输出是一张HTML表格：
```html
<table border="1">
	<tr>
		<td>Carl Cracker</td><td>$75000.0</td><td>1987-12-15</td>
	</tr>
	<tr>
		<td>Harry Hacker</td><td>$50000.0</td><td>1989-10-1</td>
	</tr>
	<tr>
		<td>Tony Tester</td><td>$40000.0</td><td>1990-3-15</td>
	</tr>
</table>
```
具有转换模板的样式表形式如下：
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
	<xsl:output method="html"/>
	template
	template
	...
</xsl:stylesheet>
```
在我们的例子中，**`xsl:output` 元素将方法设定为HTML**，而其他有效的方法设置 `method settings` 是 `xml` 和 `text` 。下面是一个典型的模板：
```xml
<xsl:template match="/staff/employee">
	<tr><xsl:apply-templates/></tr>
</xsl:template>
```
`match` 属性的值是一个XPath表达式。该模板说明，每当看到XPath集合 `/staff/employee` 中的一个节点时，将做以下操作：
1. 产生字符串 `<tr>` 。
2. 对于要处理的子元素继续应用模板。
3. 当处理完所有子元素后，产生字符串</tr>。

换句话说，该模板围绕每个雇员记录，生成HTML表格的行标记。

==XSLT处理器以检查根元素开始其处理过程。每当一个节点匹配某个模板时，就会应用该模板（如果匹配多个模板，就会使用最佳匹配的那个，详情参见[这里](http://www.w3.org/TR/xslt)）==。如果没有匹配的模板，处理器会执行默认操作。对于文本节点，默认操作是**把它的内容囊括到输出中去**；对于元素，默认操作是**不产生任何输出，但会继续处理其子节点**。

下面是一个用来转换雇员记录文件中的name节点的模板：
```xml
<xsl:template match="/staff/employee/name">
	<td><xsl:apply-templates/></td>
</xsl:template>
```
正如知道的，模板产生定界符 `<td>...</td>` ，并且请求处理器递归访问 `name` 元素的子节点。它只有一个子节点，即文本节点。**当处理器访问该节点时，它产生文本内容**（当然，前提是没有其他匹配的模板）。

如果想要把属性值复制到输出中去，就不得不再做一些稍微复杂的操作了。下面是一个例子：
```xml
<xsl:template match="/staff/employee/hiredate">
	<td><xsl:value-of select="@year"/>-<xsl:value-of select="@month"/>-<xsl:value-of select="@day"/></td>
</xsl:template>
```
当处理 `hiredate` 节点时，该模板会产生：
1. 字符串 `<td>`
2. `year` 属性的值
3. 一个连字符
4. `month` 属性的值
5. 一个连字符
6. `day` 属性的值
7. 字符串 `</td>`

**`xsl:value-of` 语句用于计算节点集的字符串值**，其中，**节点集由 `select` 属性的XPath值指定**。在这个例子中，路径是相对于当前处理节点的相对路径。**节点集通过将「各个节点的字符串值」连接起来、而被转换成一个字符串**。==一个属性节点的字符串值就是它的值，文本节点的字符串值是它的内容，元素节点的字符串值是它子节点（而不是属性）的字符串值的连接==。

程序 `transform/makehtml.xsl` 包含了将带有雇员记录的XML文件转换成HTML表格的样式表。
```xml
<!-- transform/makehtml.xsl -->
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet 
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:output method="html"/>

   <xsl:template match="/staff">
      <table border="1"><xsl:apply-templates/></table>
   </xsl:template>

   <xsl:template match="/staff/employee">
      <tr><xsl:apply-templates/></tr>
   </xsl:template>

   <xsl:template match="/staff/employee/name">
      <td><xsl:apply-templates/></td>
   </xsl:template>

   <xsl:template match="/staff/employee/salary">
      <td>$<xsl:apply-templates/></td>
   </xsl:template>

   <xsl:template match="/staff/employee/hiredate">
      <td><xsl:value-of select="@year"/>-<xsl:value-of select="@month"/>-<xsl:value-of select="@day"/></td>
   </xsl:template>
</xsl:stylesheet>
```
程序 `transform/makeprop.xsl` 显示了一组不同的转换。其输入是相同的XML文件，其输出是我们熟悉的属性文件格式的纯文本。
```txt
employee.1.name=Carl Cracker
employee.1.salary=75000.0
employee.1.hiredate=1987-12-15
employee.2.name=Harry Hacker
employee.2.salary=50000.0
employee.2.hiredate=1989-10-1
employee.3.name=Tony Tester
employee.3.salary=40000.0
employee.3.hiredate=1990-3-15
```
示例**使用 `position()` 函数来产生「以其父节点的角度来看」的当前节点的位置**。我们==只要切换样式表，就可以得到一个完全不同的输出。这样就可以安全地使用XML来描述数据了==，即便一些应用程序需要其他格式的数据，我们也只要用XSLT来产生该种替代格式。
```xml
<!-- transform/makeprop.xsl -->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
<xsl:output method="text" omit-xml-declaration="yes"/>
	<xsl:template match="/staff/employee">
		employee.<xsl:value-of select="position()"/>.name=<xsl:value-of select="name/text()"/>
		employee.<xsl:value-of select="position()"/>.salary=<xsl:value-of select="salary/text()"/>
		employee.<xsl:value-of select="position()"/>.hiredate=<xsl:value-of select="hiredate/@year"/>-<xsl:value-of select="hiredate/@month"/>-<xsl:value-of select="hiredate/@day"/>
	</xsl:template>
</xsl:stylesheet>
```
在Java平台下产生XML转换极其简单，只需**为每个样式表设置一个转换器工厂，然后得到一个转换器对象，并告诉它把一个源转换成结果**。
```java
var styleSheet = new File(filename);
var styleSource = new StreamSource(styleSheet);
Transformer t = TransformerFactory.newInstance().newTransformer(styleSource);
t.transform(source, result);
```
**`Transform` 方法的参数是 `Source` 和 `Result` 接口的实现类的对象**。`Source` 接口有如下 $4$ 个实现类，我们可以自一个文件、流、`Reader` 或URL构建一个 `StreamSource` ，从DOM树的节点构造 `DOMSource` 。
```java
DOMSource
SAXSource
StAXSource
StreamSource
```
例如，在上一节中，我们调用了如下的标识转换 `the identity transformation` ：
```java
t.transform(new DOMSource(doc), result);
```

在示例程序中，我们做了一些更有趣的事情。我们并不是从一个现有的XML文件开始工作，而是**产生一个SAX XML阅读器，通过产生适当的SAX事件 `emitting appropriate SAX events` ，给人以解析XML文件的错觉**。实际上，XML阅读器读入的是一个平面文件 `flat file` ，输入文件看上去是这样的：
```java
Carl Cracker|75000.0|1987|12|15
Harry Hacker|50000.0|1989|10|1
Tony Tester|40000.0|1990|3|15
```
处理输入时，XML阅读器将产生SAX事件。下面是实现 `XMLReader` 接口的 `EmployeeReader` 类的 `parse` 方法的一部分代码：
```java
var attributes = new AttributesImpl();
handler.startDocument();
handler.startElement("", "staff", "staff", attributes);
while ((line = in.readLine()) != null) {
	handler.startElement("", "employee", "employee", attributes);
	var tokenizer = new StringTokenizer(line, "|");
	handler.startElement("", "name", "name", attributes);
	String s = tokenizer.nextToken();
	handler.characters(s.toCharArray(), 0, s.length());
	handler.endElement("", "name", "name");
	...
	handler.endElement("", "employee", "employee");
}
handler.endElement("", rootElement, rootElement);
handler.endDocument();
```
用于转换器的 `SAXSource` 是从XML阅读器构建的：
```java
t.transform(new SAXSource(new EmployeeReader(),
	new InputSource(new FileInputStream(filename))), result);
```
这是一个将非XML的遗留数据转换成XML的一个小技巧。当然，大多数XSLT应用程序都已经有了XML格式的输入数据，只需要在一个 `StreamSource` 对象上调用 `transform` 方法即可，例如：
```java
t.transform(new StreamSource(file), result);
```
其转换结果是 `Result` 接口实现类的一个对象。Java库提供了 $3$ 个类：
```java
DOMResult
SAXResult
StreamResult
```
**如果要把结果存储到DOM树中，请使用 `DocumentBuilder` 产生一个新的文档节点**，并将其包装到 `DOMResult` 中：
```java
Document doc = builder.newDocument();
t.transform(source, new DOMResult(doc));
```
**如果要将输出保存到文件中，请使用 `StreamResult`** ：
```java
t.transform(source, new StreamResult(file));
```
程序 `transform/TransformTest.java` 包含了完整的源代码。
```java
package transform;

import java.io.*;
import java.nio.file.*;
import java.util.*;

import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.*;

import org.xml.sax.*;
import org.xml.sax.helpers.*;

/**
 * This program demonstrates XSL transformations. 
 * It applies a transformation to a set of employee records.
 * The records are stored in the file employee.dat and turned into XML format.
 * Specify the stylesheet on the command line, e.g. 
 * XML\src>javac -encoding GBK ./transform/TransformTest.java
 * XML\src> java transform.TransformTest ./transform/makeprop.xsl 
 * --> 命令行中无法运行成功,是因为当前工作目录不同吗?
 * --> 不过在Eclipse中使用命令行参数可以成功运行
 * --> Eclipse中当前工作目录为项目根路径XML
 * --> 而在命令行中,必须在XML/src下运行上述命令,于是找不到样式表和数据文件
 */
public class TransformTest {
	public static void main(String[] args) throws Exception {
		Path path;
		if (args.length > 0) path = Paths.get(args[0]);
		else path = Paths.get("./src/transform/makeprop.xsl");
		try (InputStream styleIn = Files.newInputStream(path)) { // 样式表的输入流
			StreamSource styleSource = new StreamSource(styleIn); // 以样式表构建的源
			
			Transformer t = TransformerFactory.newInstance().newTransformer(styleSource); // 转换器
			t.setOutputProperty(OutputKeys.INDENT, "yes");
			t.setOutputProperty(OutputKeys.METHOD, "xml");
			t.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
			
			try (InputStream docIn = Files.newInputStream(Paths.get("./src/transform/employee.dat"))) { // 待转换的文件的输入流
				t.transform(new SAXSource(new EmployeeReader(), new InputSource(docIn)), 
					new StreamResult(System.out));
			}
		}
	} 
}

/**
 * This class reads the flat file employee.dat and 
 * reports SAX parser events to act as if it was parsing an XML file
 */ 
class EmployeeReader implements XMLReader {
	private ContentHandler handler;
	
	public void parse(InputSource source) throws IOException, SAXException {
		InputStream stream = source.getByteStream();
		BufferedReader in = new BufferedReader(new InputStreamReader(stream));
		String rootElement = "staff";
		AttributesImpl atts = new AttributesImpl();
		
		if (handler == null) throw new SAXException("No content handler");
		
		handler.startDocument(); // 开始文档
		handler.startElement("", rootElement, rootElement, atts);
		String line;
		while ((line = in.readLine()) != null) {
			handler.startElement("", "employee",  "employee", atts); // employee元素有name,salary,hiredate(有属性)子元素
			StringTokenizer t = new StringTokenizer(line, "|"); // 根据"|"分割Token
			
			handler.startElement("", "name", "name", atts); // 空属性
			String s = t.nextToken();
			handler.characters(s.toCharArray(), 0, s.length());
			handler.endElement("", "name", "name");
			
			handler.startElement("", "salary", "salary", atts);
			s = t.nextToken();
			handler.characters(s.toCharArray(), 0, s.length());
			handler.endElement("", "salary", "salary");
			
			atts.addAttribute("", "year", "year", "CDATA", t.nextToken());
			atts.addAttribute("", "month", "month", "CDATA", t.nextToken());
			atts.addAttribute("", "day", "dat", "CDATA", t.nextToken());
			handler.startElement("", "hiredate", "hiredate", atts); // 有属性
			handler.endElement("", "hiredate", "hiredate");
			atts.clear();
			
			handler.endElement("", "employee", "employee");
		}
		handler.endElement("", rootElement, rootElement);
		handler.endDocument();
	}
	
	public void setContentHandler(ContentHandler newValue) {
		handler = newValue;
	}
	
	public ContentHandler getContentHandler() {
		return handler;
	}
	
	// the following methods are just do-nothing implementationis
   public void parse(String systemId) throws IOException, SAXException {}
   public void setErrorHandler(ErrorHandler handler) {}
   public ErrorHandler getErrorHandler() { return null; }
   public void setDTDHandler(DTDHandler handler) {}
   public DTDHandler getDTDHandler() { return null; }
   public void setEntityResolver(EntityResolver resolver) {}
   public EntityResolver getEntityResolver() { return null; }
   public void setProperty(String name, Object value) {}
   public Object getProperty(String name) { return null; }
   public void setFeature(String name, boolean value) {}
   public boolean getFeature(String name) { return false; }
}
```
使用 `transform/makehtml.xsl` 的运行结果如下图：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207162347654.png)
使用 `transform/makeprop.xsl` 的运行结果如下图：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207162348189.png)

> `javax.xml.transform.TransformerFactory` 1.4
> - `transformer newTransformer(Source stylesheet)`
> 返回一个 `transformer` 类的实例，用来从指定的源中读取样式表。

> `javax.xml.transform.stream.StreamSource` 1.4
> - `StreamSource(File f)`
> - `StreamSource(InputStream in)`
> - `StreamSource(Reader in)`
> - `StreamSource(String systemID)`
> 自一个文件、流、阅读器或系统ID（通常是相对或绝对URL）构建一个数据流源。

> `javax.xml.transform.sax.SAXSource` 1.4
> - `SAXSource(XMLReader reader, InputSource source)`
> 构建一个SAX数据源，以便从给定输入源获取数据，并使用给定的阅读器来解析输入数据。

> `org.xml.sax.XMLReader` 1.4
> - `void setContentHandler(ContentHandler handler)`
> 设置「在输入被解析时会被告知解析事件」的处理器。
> - `void parse(InputSource source)`
> 解析来自给定输入源的输入数据，并将解析事件发送到内容处理器。

> `javax.xml.transform.dom.DOMResult` 1.4
> - `DOMResult(Node n)`
> 自给定节点构建一个数据源。通常，`n` 是一个新文档节点。

> `org.xml.sax.helpers.AttributesImpl` 1.4
> - `void addAttribute(String uri, String lname, String qname, String type, String value)`
> 将一个属性添加到该属性集合。参数：
>   - `uri` ：名字空间的URI
>   - `lname` ：无前缀的本地名
>   - `qname` ：带前缀的限定名
>   - `type` ：类型，`"CDATA", "ID", "IDREF", "IDREFS", "NMTOKEN", "NMTOKENS", "ENTITY", "ENTITIES", "NOTATION"` 之一
>   - `value`： 属性值
> - `void clear()`
> 删除属性集合中的所有属性。

我们以该示例、结束对Java库中的XML支持特性的讨论。现在，应该对XML的强大功能有了很好的了解，尤其是**它的自动解析、验证和强大的转换机制**。当然，所有这些技术只有在**很好地设计了XML格式**之后、才能发挥作用——我们必须==确保那些格式足够丰富，能够表达全部业务需求，随着时间的推移也依旧稳定==，且业务伙伴也愿意接受我们的XML文档。这些问题要远比处理解析器、DTD或转换更具挑战。

下面讨论Java平台上的网络编程，从最基础的网络套接字开始，逐渐过渡到用于E-mail和万维网的更高层协议。