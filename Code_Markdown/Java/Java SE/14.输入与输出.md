这里介绍Java中用于输入和输出的各种应用编程接口 *Application Programming Interface, API* 。学习如何==访问文件与目录==，以及如何==以二进制格式和文本格式来读写数据==。还==展示对象序列化机制==，它可以使存储对象像存储文本和数值数据一样容易。然后，==介绍在Java SE 1.4中引入的“新I/O”包== `java.nio` 所带来的种种改进，以及==Java 7的“新新I/O”改进==。最后==讨论正则表达式==，尽管这部分内容实际上与流和输入输出并不相关，但也找不到更合适的地方来处理这个话题。很明显，Java设计团队在这个问题的处理上也一样，因为正则表达式API的规格说明隶属于“新I/O *new I/O*”特性的规格说明。

---
## 14.1 输入/输出流
在Java API中，可以从其中读入一个字节序列 *a sequence of bytes* 的对象称做**输入流**，而可以向其中写入一个字节序列的对象称为**输出流**。这些字节序列的来源地和目的地可以是文件（且通常都是文件），但也可以是网络连接、甚至是内存块。**抽象类 `InputStream` 和 `OutputStream` 构成了输入/输出（I/O）类层次结构的基础**。
> 注意，这些输入/输出流与[[13.流]]看到的流没有任何关系。为清楚起见，只要是讨论用于输入和输出的流，都使用术语输入流、输出流或输入/输出流。
 
**因为面向字节的流不便于处理以Unicode形式存储的信息**（回忆：Unicode中每个字符都使用了多个字节来表示），**所以从抽象类 `Reader` 和 `Writer` 中继承出来了一个专门用于处理Unicode字符的、单独的类层次结构**，这些类拥有的读入和写出操作都是基于两字节的 `char` 值（即UTF-16码元）、而不是基于 `byte` 值即单字节的字符。

## 14.1.1 读写字节
`InputStream` 类有一个抽象方法：
```java
abstract int read()
```
这个方法将读入一个字节、并返回读入的字节，或在遇到输入源结尾时返回-1。==在设计具体的输入流类时，必须覆盖这个方法以提供有用的功能==，例如，在 `FileInputStream` 类中，这个方法将从某个文件中读入一个字节，而 `System.in`（ `InputStream` 的一个子类的预定义对象）却从键盘读入信息。

`InputStream` 类还有若干个非抽象的方法，它们可以读入一个字节数组，或者跳过大量的字节。Java 9开始有一个非常有用的、可以读取流中所有字节的方法：
```java
byte[] bytes = in.readAllBytes();
```
还有多个用来读取给定数量字节的方法（API说明）。*这些方法都要调用抽象 `read` 方法，因此，各个子类都只需覆盖这一个方法* 。

与此类似，`OutputStream` 类定义了下面的抽象方法，它可以向某个输出位置写出一个字节：
```java
abstract void write(int b)
```
如果我们有一个字节数组，那么就可以一次性写出它们：
```java
byte[] values = ...;
out.write(values);
```
**`transferTo` 方法可以将所有字节从一个输入流转移到另一个输出流**：
```java
in.transferTo(out);
```

**`read` 和 `write` 方法在执行时都将阻塞，直至字节确实被读入或写出**。这就意味着，如果流不能被立即访问（通常因为网络连接忙），那么当前线程将被阻塞。==这使得在「这两个方法等待指定的流变为可用」的这段时间里，其他线程就有机会去执行有用的工作==。

`available` 方法使我们可以去检查当前可读入的字节数量，这意味着像下面这样的代码片段就不可能被阻塞：
```java
int bytesAvailable = in.available();
if (bytesAvailable > 0) {
	var data = new byte[bytesAvailable];
	in.read(data);
}
```

**当完成对流的读写时，应该通过调用 `close` 方法**（或 `try-with-resources` ）**来关闭它，这个调用会释放掉十分有限的操作系统资源**。如果一个应用程序打开了过多的流而没有关闭，那么系统资源将被耗尽 *depleted* 。==关闭一个输出流的同时，还会冲刷 *flush* 用于该输出流的缓冲区：所有被临时置于缓冲区中、以便用更大的包的形式传递的字符，在关闭输出流时都将被送出== *Any bytes that were temporarily placed in a buffer so that they could be delivered as a larger packet are sent off* 。特别是，如果不关闭文件，那么写出字节的最后一个包可能将永远也得不到传递。当然，还可以用 `flush` 方法来人为冲刷这些输出。

即使某个输入/输出流类提供了使用原生 `read` 和 `write` 功能的某些具体方法，应用系统的程序员还是很少使用它们，因为大家感兴趣的数据可能包含数字、字符串和对象，而不是原生字节 *raw bytes* 。

我们可以使用众多构建于基本的 `InputStream` 和 `OutputStream` 类之上的某个输入/输出类，这些类使我们可以处理那些以常用格式表示的数据，而不只是字节。

> [API] `java.io.InputStream` 1.0
> - `abstract int read()`
> 从数据中读入一个字节，并返回该字节。在碰到输入流的结尾时返回-1。
> - `int read(byte[] b)`
> 读入一个字节数组，并返回实际读入的字节数，或在碰到流的结尾时返回-1。这个 `read` 方法最多读入 `b.length` 个字节。
> - `int read(byte[] b, int off, int len)`
> - `int readNBytes(bytes[] b, int off, int len)` 9
> 如果没阻塞，则读入由 `len` 指定数量的字节，或阻塞至所有的值都被读入（ `readNBytes` ）。读入的值将置于 `b` 中从 `off` 开始的位置。返回实际读入的字节数，或在碰到输入流的结尾时返回-1。
> - `bytes[] readAllBytes` 9
> 产生一个数组，包含可从当前流中读入的所有字节。
> - `long transferTo(OutputStream out)` 9
> 将当前输入流中的所有字符传送到给定的输出流，返回传递的字节数。这两个流都不应处于关闭状态。
> - `long skip(long n)`
> 在输入流中跳过 `n` 个字节，返回实际跳过的字节数（如果碰到流的结尾，则可能小于 `n` ）。
> - `int available()`
> 返回在不阻塞的情况下可获取的字节数（回忆一下，阻塞意味着当前线程将失去它对资源的占用）。
> - `void close()`
> 关闭这个输入流。
> - `void mark(int readlimit)`
> 在输入流的当前位置打一个标记（并非所有的流都支持这个特性）。如果从输入流中已经读入的字节多于 `readlimit` 个，则这个流允许忽略这个标记。
> - `void reset()`
> 返回到最后一个标记，随后对 `read` 的调用将重新读入这些字节。如果当前没有任何标记，则这个流不被重置。
> - `boolean markSupported()`
> 如果这个流支持打标记，则返回 `true` 。

> [API] `java.io.OutputStream` 1.
> - `abstract void write(int n)`
> 写出一个字节的数据。
> - `void write(byte[] b)`
> - `void write(byte[]b, int off, int len)`
> 写出所有字节或者某个范围的字节到数组 `b` 中。
> - `void close()`
> 冲刷并关闭输出流。
> - `void flush()`
> 冲刷输出流，也就是将所有缓冲的数据发送到目的地。

## 14.1.2 完整的流家族
与C只有单一类型 `FILE*` 包不同，Java拥有一个流家族，包含各种输入/输出流类型，其数量超过60个！参见图14-1和图14-2。
![图14-1 输入流与输出流的层次结构](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211231642019.png)
我们把流家族中的成员**按照它们的使用方法**来进行划分，这样就形成了**处理字节和字符的两个单独的层次结构**。正如所见，**`InputStream` 和 `OutputStream` 类可以读写单个字节或字节数组**，它们构成了图示层次结构的基础。要想读写字符串和数字，就需要功能更强大的子类，例如，**`DataInputStream` 和  `DataOutputStream` 可以二进制格式读写所有的基本Java类型**。最后还包含了多个很有用的流，例如，**`ZipInputStream` 和 `ZipOutputStream` 可以常见的ZIP压缩格式读写文件**。

![图14-2 Reader和Writer的层次结构](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211231647864.png)
另一方面，对于Unicode文本，可以使用抽象类 `Reader, Writer` 的子类。`Reader` 和 `Writer` 类的基本方法与 `InputStream` 和 `OutputStream` 中的方法类似。
```java
abstract int read()
abstract void write(int c)
```
`read` 方法将返回一个**Unicode码元**（**一个在0~65535之间的整数**），或者在碰到文件结尾时返回-1。`write` 方法在被调用时，需要传递一个Unicode码元（卷I章3有关Unicode码元的讨论）。

![图14-3 Closeable、Flushable、Readable和Appendable接口](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211231721823.png)
还有4个附加的接口：`Closeable, Flushable, Readable, Appendable`（图14-3）。前两个接口非常简单，它们分别拥有下面的方法：
```java
void close() throws IOException
// or 
void flush()
```
**`InputStream, OutputStream, Reader, Writer` 都实现了 `Closeable` 接口。而 `OutputStream` 和 `Writer` 还实现了 `Flushable` 接口**。
> 注意：**`java.io.Closeable` 接口扩展了 `java.lang.AutoCloseable` 接口**。因此，对任何 `Closeable` 进行操作时，都可以使用try-with-resource语句（声明了一个或多个资源的try语句）。**为什么要有两个接口呢**？因为 `Closeable` 接口的 `close` 方法只抛出 `IOException` ，而 `AutoCloseable.close` 方法可以抛出任何异常。

`Readable` 接口只有一个方法：
```java
int read(CharBuffer cb)
```
**`CharBuffer` 类拥有按顺序和随机读写访问的方法，它表示一个内存中的缓冲区或一个内存映像的文件**（见14.5.2节“缓冲区数据结构”）。

`Appendable` 接口有两个用于**添加单个字符和字符序列**的方法，**在流类的家族中，只有 `Writer` 实现了 `Appendable`** ：
```java
Appendable append(char c)
Appendable append(CharSequence s)
```
**`CharSequence` 接口描述了一个 `char` 值序列的基本属性**，`String, CharBuffer, StringBuilder, StringBuffer` 都实现了它。

> [API] `java.io.Closeable` 5.0
> - `void close()`
> 关闭这个 `Closeable` ，这个方法可能会抛出 `IOException` 。

> [API] `java.io.Flushable` 5.0
> - `void flush()`
> 冲刷这个 `Flushable` 。

> [API] `java.lang.Readable` 5.0
> - `int read(CharBuffer cb)`
> 尝试向 `cb` 读入其可持有数量的 `char` 值。返回读入的 `char` 值的数量，或当从这个 `Readable` 中无法再获得更多的值时返回-1。

> [API] `java.lang.Appendable` 5.0
> - `Appendable append(char c)`
> - `Appendable append(CharSequence cs)`
> 向这个 `Appendable` 中追加给定的码元或者给定的序列中的所有码元，返回 `this` 。

> [API] `java.lang.CharSequence` 1.4
> - `char charAt(int index)`
> 返回给定索引处的码元。
> - `int length()`
> 返回在这个序列中的码元的数量。
> - `CharSequence subSequence(int startIndex, int endIndex)`
> 返回由存储在 `startIndex` 到 `endIndex-1` 处的所有码元构成的 `CharSequence` 。
> - `String toString()`
> 返回这个序列中所有码元构成的字符串。

## 14.1.3 组合输入/输出流过滤器
`FileInputStream` 和 `FileOutputStream` 可以提供附着在一个磁盘文件上的输入流和输出流，而你**只需向其构造器提供文件名或文件的完整路径名**。例如，下面这行代码可以查看在用户目录下名为"employee.dat"的文件。：
```java
var fin = new FileInputStream("employee.dat");
```
所有在 `java.io` 中的类，都将相对路径名解释为「以用户工作目录开始」，可以**通过调用 `System.getProperty("user.dir")` 获得这个信息**。
> 警告：由于反斜杠 *backslash* 字符在Java字符串中是转义字符，因此要确保在Windows风格的路径名中使用 `\\`（如 `C:\\Windows\\win.ini` ）。
> 
> 在Windows中，还可以使用单斜杠 *single  forward slash* 字符（ `C:/Windows/win.ini` ），因为大部分Windows文件处理的系统调用、都会将斜杠解释成文件分隔符。但并不推荐这样做，因为Windows系统函数的行为会因与时俱进而发生变化。因此，**对于可移植的程序来说，应该使用程序所运行平台的文件分隔符，可以通过常量字符串 `java.io.File.separator` 获得它**。

**与抽象类 `InputStream, OutputStream` 一样，这些类只支持在字节级别上的读写**。也就是说，只能从 `fin` 对象中读入字节和字节数组。
```java
byte b = (byte) fin.read();
```
正如下节看到的，如果只有 `DataInputStream` ，那么我们就只能读入数值类型：
```java
DataInputStream din = ...;
double x = din.readDouble();
```
但正如 `FileInputStream` 没有任何读入数值类型的方法一样，`DataInputStream` 也没有任何从文件中获取数据的方法。

==**Java使用了一种灵巧的机制来分离这两种职责**。某些流==（例如 `FileInputStream` 和由URL类的 `openStream` 方法返回的输入流）==可以从文件和其他更外部的位置上获取字节，而其他的流==（例如 `DataInputStream, PrintWriter` ）==可以将字节组装到更有用的数据类型中== *assemble bytes into more useful data types* 。==Java程序员必须对二者进行组合==。例如，为了从文件中读入数字，首先要创建一个 `FileInputStream` ，然后将其传递给 `DataInputStream` 的构造器：
```java
var fin = new FileInputStream("employee.dat");
var din = new DataInputStream(fin);
double x = din.readDouble();
```
如果再次查看图14-1，就会看到 `FilterInputStream, FilterOutputStream` 类，==这些类的子类为「处理字节的输入/输出流」添加功能== *add capabilities to input/output streams that process bytes* 。

可以**通过嵌套过滤器来添加多重功能** *add multiple capabilities by nesting the filters* 。例如，输入流 *input stream* 在默认情况下是不被缓冲区缓存的，也就是说，每个对 `read` 的调用都会请求操作系统再分发一个字节。相比之下，请求一个数据块并将其置于缓冲区中会显得更加高效。如果我们想用缓冲机制 *buffering* 、和用于文件的数据输入方法 *the data input methods for a file* ，那么就需要使用下面这种相当恐怖的构造器序列：
```java
var din = new DataInputStream(
	new BufferedInputStream(
		new FileInputStream("employee.dat")));
```
注意，**我们把 `DataInputStream` 置于构造器链的最后，这是因为我们希望使用 `DataInputStream` 的方法，并且希望它们 *them* 能够使用带缓冲机制的 `read` 方法**。

==有时当多个流链接在一起时，你需要跟踪各个中介流 *intermediate stream*== 。例如，当读入输入时，经常需要浏览下一个字节，以了解它是否是你想要的值。Java提供了用于此目的的 `PushbackInputStream` ：
```java
var pbin = new PushbackInputStream(
	new BufferedInputStream(
		new FileInputStream("employee.dat")));
```
现在可以预读下一个字节：
```java
int b = pbin.read();
```
并且在它并非你所期望的值时，将其推回流中 *throw it back* 。
```java
if (b != '<') pbin.unread(b);
```
但读入和推回 *reading and unreading* 是可应用于一个 
*push-back* 输入流的仅有的方法。如果你希望能够预先浏览 *look ahead* 且还可以读入数字，那么就需要一个既是可回推输入流，又是一个数据输入流的引用：
```java
var din = new DataInputStream(
	pbin = new PushbackInputStream(
		new BufferedInputStream(
		new FileInputStream("employee.dat"))));
```

当然，在其他编程语言的输入/输出流类库中，诸如缓冲机制和预览等细节都是自动处理的。因此==相比较而言，Java有一点麻烦，它必须将多个流过滤器 *stream filter* 组合起来==。但是，==这种混合并匹配过滤器类 *mix and match filter classes* 、以构建真正有用的输入/输出流序列的能力，将给你极大的灵活性==，例如，可以从一个ZIP压缩文件中，通过使用下面的输入流序列来读入数字（图14.4）：
```java
var zin = new ZipInputStream(new FileInputStream("employee.zip"));
var din = new DataInputStream(zin);
```
（查看14.2.3节“ZIP文档”，了解更多有关Java处理ZIP文件功能的知识）。
![图14.4 过滤器流序列](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211240005615.png)

> [API] `java.io.FileInputStream` 1.0
> - `FileInputStream(String name)`
> - `FileInputStream(File file)`
> 使用由「 `name` 字符串或 `file` 对象」指定路径名的文件，创建一个新的文件输入流（ `File` 类在结尾处描述）。非绝对的路径名，将按照相对于「VM启动时所设置的工作目录」来解析。
　
> [API] `java.io.FileOutputStream` 1.0
> - `FileOutputStream(String name)`
> - `FileOutputStream(String name, boolean append)`
> - `FileOutputStream(File file)`
> - `FileOutputStream(File file, boolean append)`
> 使用由「 `name` 字符串或 `file` 对象」指定路径名的文件，创建一个新的文件输出流。如果 `append` 参数为 `true` ，那数据将被添加到文件尾，而具有相同名字的已有文件不会被删除;否则，这个方法会删除所有具有相同名字的已有文件。

> [API] `java.io.BufferedInputStream` 1.0
> - `BufferedInputStream(InputStream in)`
> 创建一个带缓冲区的流。**带缓冲区的输入流在从流中读入字符时，不会每次都对设备访问**。当缓冲区为空时，会向缓冲区中读入一个新的数据块。

> [API] `java.io.BufferedOutputStream` 1.0
> - `BufferedOutputStream(OutputStream out)`
> 创建一个带缓冲区的流。**带缓冲区的输出流在收集要写出的字符时，不会每次都对设备访问**。当缓冲区填满或当流被冲刷时，数据就被写出。

> [API] `java.io.PushbackInputStream` 1.0
> - `PushbackInputStream(InputStream in)`
> - `PushbackInputStream(InputStream in, int size)`
> 构建一个可以预览一个字节 *one-byte lookahead* 或者具有指定尺寸的回推缓冲区 *a pushback buffer of specified size* 的流。
> - `void unread(int b)`
> 回推一个字节，它在下次调用 `read` 时被再次获取。

## 14.1.4 文本输入与输出
**在保存数据时，可以选择二进制格式或文本格式**。例如，整数1234存储成二进制数时，它被写为由字节00 00 04 D2构成的序列（十六进制表示法），而存储成文本格式时，它被存成了字符串"1234"。==尽管二进制格式的I/O高速且高效，但不宜人来阅读==。首先讨论文本格式的I/O，然后在14.2节“读写二进制数据”中讨论二进制格式的I/O。

**在存储文本字符串时，需要考虑字符编码 *character encoding* 方式**。在UTF-16编码方式中，字符串"José"编码为00 4A 00 6F 00 73 00 E9(in hex)。但许多程序都希望文本文件按照其他的编码方式编码。在UTF-8这种互联网上最常用的编码方式中，这个字符串将写成4A 6F 73 C3 A9，其中并没有前3个字母的0字节，而字符é占用了两个字节。

`Reader, Writer` 类都只有读入和写出单个字符的基础方法。在使用（Unicode）流时，可以使用处理字符串和数字的子类。

`OutputStreamWriter` 类将使用选定的字符编码方式，把Unicode码元的输出流、转换为字节流。而 **`InputStreamReader` 类将包含字节**（在某些字符编码中的指定字符 *specifying characters* ）**的输入流、转换为可以产生Unicode码元的读入器**（字节流->Unicode码元流）。

例如，下面的代码就展示了，如何让一个输入读入器从控制台读入键盘敲击信息，并将其转换为Unicode：
```java
var in = new InputStreamReader(System.in);
```
这个输入流读入器会假定使用「主机系统所使用的默认字符编码方式」，在桌面操作系统中，可能是像Windows 1252或MacRoman这样古老的字符编码方式。**应该总是在 `InputStreamReader` 的构造器中，选择一种具体的编码方式**（查看14.1.8节“字符集”，了解字符编码方式的更多信息）。例如，
```java
var in = new InputStreamReader(new FileInputStream("data.txt"), StandardCharsets.UTF_8);
```

## 14.1.5 如何写出文本输出
对于文本输出，可以**使用 `PrintWriter` ，这个类拥有以文本格式打印字符串和数字的方法**。为了打印到文件，需要用文件名和字符编码方式构建一个 `PrintStream` 对象，下面的语句：
```java
var out = new PrintWriter("employee.txt", StandardCharsets.UTF_8);
```

为了输出到一个 *print writer* ，需要使用「与使用 `System.out` 时相同的 `print, println, printf` 方法」。可以用这些方法来打印数字 `int, short, long, float, double` 、字符、`boolean`值、字符串和对象。例如，考虑下面的代码：
```java
String name = "Harry Hacker";
double salary = 75000;
out.print(name);
out.print(' ');
out.println(salary);
```
它将把字符 `Harry Hacker 75000.0` 输出到写出器 `out` ，之后这些字符将会被转换成字节、并最终写入 `employee.txt` 中。

`println` 方法在行中、添加了对目标系统来说恰当的行结束符（Windows系统是 `"\r\n"` ，UNIX系统是 `"\n"` ），也就是通过调用 `System.getProperty("line.separator")` 而获得的字符串。

如果写出器设置为**自动冲刷模式** *autoflush mode* ，那么只要 `println` 被调用，缓冲区中的所有字符都会被发送到它们的目的地（**打印写出器总是带缓冲区的**）。默认情况下，自动冲刷机制是禁用的，你可以通过使用 `PrintWriter(Writer out, Boolean autoFlush)` 来启用或禁用自动冲刷机制：
```java
var out = new PrintWriter(new OutputStreamWriter(
	new FileOutputStream("employee.txt"),
		StandardCharsets.UTF_8),
	true
); // autoflush
```
`print` 方法不抛出异常，可以调用 `checkError` 方法来查看输出流是否出现了某些错误。
> 注意：Java的老手们可能会很想知道 `PrintStream` 类和 `System.out` 发生了什么。在Java 1.0中，`PrintStream` 类只是通过将高字节丢弃的方式，把所有Unicode字符截断成ASCII字符（那时Unicode仍旧是16位编码方式）。很明显，这并非一种干净利落和可移植的方式，这个问题在Java 1.1中通过引入读入器和写出器 *readers and writers* 得到了修正。
> 
> 为了与已有的代码兼容，`System.in, System.out, System.err` 仍旧是输入/输出流、而非读入器和写出器。但现在 `PrintStream` 类在内部采用与 `PrintWriter` 相同的方式，将Unicode字符转换成默认的主机编码方式 *default host encoding* 。当你在使用 `print` 和 `println` 方法时，`PrintStream` 类型对象的行为看起来确实很像打印写出器，但与打印写出器不同的是，它们允许我们用 `write(int)` 和 `write(byte[])`方法输出原生字节。

> [API] `java.io.PrintWriter` 1.1
> - `PrintWriter(Writer out)`
> - `PrintWriter(Writer out, boolean autoFlush)`
> 创建一个向给定写出器写出的、新的 `PrintWriter` 。`autoflush` 如果为 `true` ，则 `println` 方法将冲刷输出缓冲区（默认 `false` ）。
> - `PrintWriter(OutputStream out)`
> - `PrintWriter(OutputStream out, boolean autoflush)`
> 通过创建必需的中介 `OutputStreamWriter` ，从已有的 `OutputStream` 中创建一个新的 `PrintWriter` 。
> - `PrintWriter(String filename, String encoding)`
> - `PrintWriter(File file, String encoding)`
> 通过创建必需的中介 `FileWriter` ，创建一个向给定的文件写出的新的 `PrintWriter` ，使用给定的编码方式。
> - `void print(Object obj)`
> 通过打印从 `toString` 产生的字符串来打印一个对象。
> - `void print(String s)`
> 打印一个包含Unicode码元的字符串。
> - `void println(String s)`
> 打印一个字符串，后面紧跟一个行终止符。如果这个流处于自动冲刷模式，那么就会冲刷这个流。
> - `void print(char[] s)`
> 打印在给定的字符串中的所有Unicode码元。
> - `void print(char c)`
> 打印一个Unicode码元。
> - `void print(int i)`
> - `void print(long l)`
> - `void print(float f)`
> - `void print(double d)`
> - `void print(boolean b)`
> 以文本格式打印给定的值。
> - `void printf(String format, Object...args)` 
> 按照格式字符串指定的方式打印给定的值。看卷I章3了解格式化字符串的相关规范。
> - `boolean checkError()`
> 如果产生格式化或输出错误，则返回 `true` 。一旦这个流碰到了错误，它就受到了污染，并且所有对 `checkError` 的调用都将返回 `true` 。

## 14.1.6 如何读入文本输入
可以将短小的文本文件、像下面这样读入到一个字符串中：
```java
var content = new String(Files.readAllBytes(path), charset);
```
但想要将这个文件一行行读入，则可以调用：
```java
List<String> lines = Files.readAllLines(path, charset);
```
如果文件太大，那么可将行惰性处理为一个 `Stream<String>` 对象：
```java
try (Stream<String> lines = Files.lines(path, charset)) {
	...
}
```

众所周知：
- 以二进制格式写出数据，需要使用 `DataOutputStream` 。
- 以文本格式写出数据，需要使用 `PrintWriter` 。

因此，你可能认为存在着与 `DataInputStream` 类似的类允许我们以文本格式读入数据，而在卷I中广泛使用的、与此最接近的类是扫描器 `Scanner` 类，**也是最简单的处理任意文本的方式**，它可以从任何输入流中构建 `Scanner` 对象。还可以使用扫描器来读入**符号** *token* ，即由分隔符分隔的字符串。例如，下面的代码将接收任何非Unicode字母作为分隔符，这个扫描器只接受Unicode字母组成的符号。
```java
Scanner in = ...;
in.useDelimiter("\\PL+");
```
调用 `next` 方法可以产生下一个符号：
```java
while (in.hasNext()) {
	String word = in.next();
	...
}
```
或者可以像下面这样，获取一个包含所有符号的流：
```java
Stream<String> words = in.tokens();
```

早期的Java版本中（在Java SE 5.0之前），处理文本输入的唯一方式就是使用 `BufferedReader` 类。它的 `readLine` 方法产生一行文本，或在无法获得更多输入时返回 `null` 。典型的输入循环看起来像下面这样，**需要将带缓冲区的读入器与输入源组合起来**：
```java
InputStream inputStream = . . .;
try (var in = new BufferedReader(new InputStreamReader(inputStream, charset))) {
	String line;
	while ((line = in.readLine()) != null) {
		// do something with line	
	}
}
```
如今，`BufferedReader` 类又有了一个 `lines` 方法，可产生一个 `Stream<String>` 对象。但**与 `Scanner` 不同，`BufferedReader` 没有任何读入数字的方法**。

## 14.1.7 以文本格式存储对象
在本节领略一个示例程序，它将一个 `Employee` 记录数组存储成了一个文本文件，其中每条记录都保存成单独的一行，而实例字段彼此之间使用分隔符分离开，这里使用竖线 `|` 作为分隔符（冒号 `:`  是另一种流行的选择，有趣的是，每个人都会使用不同的分隔符）。因此，这里是在假设**不会发生「要存储的字符串中存在 `|` 」的情况**。

下面是一个记录集的样本：
```java
arry Hacker|35500|1989-10-01
Carl Cracker|75000|1987-12-15
Tony Tester|38000|1990-03-15
```
写出记录相当简单，因为我们是要写出到一个文本文件中，所以使用 `PrintWriter` 类。直接写出所有的字段，每个字段后面跟着一个 `|` ，而最后一个字段的后面跟着一个 `\n` 。这项工作是在下面这个添加到 `Employee` 类中的 `writeData` 方法里完成的：
```java
public static void writeEmployee(PrintWriter out, Employee e) {
	out.println(e.getName() + "|" + e.getSalary() + "|" + e.getHireDay());
}
```

为了读入记录，我们每次读入一行，然后分离所有的字段。我们使用一个扫描器来读入每一行，然后用 `String.split` 方法将这一行断开成一组符号 *split the line into tokens* 。
```java
public static Employee readEmployee(Scanner in) {
	String line = in.nextLine();
	String[] tokens = line.split("\\|");
	String name = tokens[0];
	double salary = Double.parseDouble(tokens[1]);
	LocalDate hireDate = LocalDate.parse(tokens[2]);
	int year = hireDate.getYear();
	int month = hireDate.getMonthValue();
	int day = hireDate.getDayOfMonth();
	return new Employee(name, salary, year, month, day);
}
```
`split` 方法的参数是「一个描述分隔符的正则表达式」，在末尾讨论正则表达式。碰巧的是，竖线在正则表达式中具有特殊的含义，因此要用 `\` 字符来表示转义，而这个 `\` 又需要用另一个 `\` 来转义，这样就产生了 `\\|` 表达式。

静态方法 `void writeData(Employee[] e, PrintWriter out)` 先写出该数组的长度，然后写出每条记录。静态方法 `Employee[] readData(BufferedReader in)` 首先读入该数组的长度，然后读入每条记录。这显得稍微有点棘手：
```java
int n = in.nextInt();
in.nextLine(); // consume newline
var employees = new Employee[n];
for (int i = 0; i < n; i++) {
	employees[i] = new Employee();
	employees[i].readData(in);
}
```
对 `nextInt` 的调用读入的是数组长度，但不包括行尾换行字符，我们必须处理掉这个换行符，这样，在调用 `nextLine` 方法后，`readData` 方法就可以获得下一行输入了。
```java
// textFile/TextFileTest.java
package textFile;

import java.io.*;
import java.nio.charset.*;
import java.time.*;
import java.util.*;

public class TextFileTest {
	public static void main(String[] args) throws IOException {
		var staff = new Employee[3];
		staff[0] = new Employee("Carl Cracker", 75000, 1987, 12, 15);
		staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
		staff[2] = new Employee("Tony Tester", 40000, 1990, 3, 15);
		
		// save all employee records to the file employee.dat
		try (var out = new PrintWriter("./src/textFile/employee.dat", StandardCharsets.UTF_8)) {
			writeData(staff, out);
		}

		// retrieve all records into a new array
		try (var in = new Scanner(
			new FileInputStream("./src/textFile/employee.dat"), "UTF-8")) {
			Employee[] newStaff = readData(in);
			// print the newly read employee records
			for (Employee e : newStaff)
				System.out.println(e);
		}
	}

	/**
	 * Writes all employees in an array to a print writer
	 * @param employees an array of employees
	 * @param out a print writer
	 */
	private static void writeData(Employee[] employees, PrintWriter out) throws IOException {
		// write number of employees
		out.println(employees.length);
		for (Employee e : employees) {
			writeEmployee(out, e);
		}
	}

	/**
	 * Reads an array of employees from a scanner
	 * @param in the scanner
	 * @return the array of employees
	 */
	private static Employee[] readData(Scanner in) {
		// retrieve the array size
		int n = in.nextInt();
		in.nextLine(); // consume newline

		var employees = new Employee[n];
		for (int i = 0; i < n; ++i) {
			employees[i] = readEmployee(in);
		}
		return employees;
	}

	/**
	 * Writes employee data to a print writer
	 * @param out the print writer
	 */
	public static void writeEmployee(PrintWriter out, Employee e) {
		out.println(e.getName() + "|" + e.getSalary() + "|" + e.getHireDay());
	}

	/**
	 * Reads employee data from a buffered reader
	 * @param in the scanner
	 */
	public static Employee readEmployee(Scanner in) {
		String line = in.nextLine();
		String[] tokens = line.split("\\|");
		String name = tokens[0];
		double salary = Double.parseDouble(tokens[1]);
		LocalDate hireDate = LocalDate.parse(tokens[2]);
		int year = hireDate.getYear();
		int month = hireDate.getMonthValue();
		int day = hireDate.getDayOfMonth();
		return new Employee(name, salary, year, month, day);
	}
}
```
```java
// textFile/Employee.java
package textFile;

import java.time.*;

public class Employee {
	private String name;
	private double salary;
	private LocalDate hireDay;

	public Employee(String n, double s, int year, int month, int day) {
		name = n;
		salary = s;
		hireDay = LocalDate.of(year, month, day);
	}

	public String getName() { return name; }

	public double getSalary() { return salary; }

	public LocalDate getHireDay() { return hireDay; }

	public void raiseSalary(double byPercent) {
	   double raise = salary * byPercent / 100;
	   salary += raise;
	}

	public String toString() {
		return getClass().getName() 
				+ "[name=" + name + ",salary=" + salary + ",hireDay=" + hireDay + "]";
	}
}
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212171819008.png)

## 14.1.8 字符编码方式和字符集
输入和输出流都是用于字节序列的，但在许多情况下，我们希望操作的是文本，即字符序列（Unicode码元序列）。于是字符如何编码成字节就成立问题。

==Java针对字符使用的是Unicode标准 *the Unicode standard for characters* ，每个字符或“编码点”都有一个21位的整数。有多种不同的字符编码方式== *character encodings——methods for packaging those 21-bit numbers into bytes* ，也就是说==将这些21位数字包装成字节的方法有多种==。

最常见的编码方式是**UTF-8，它会将每个Unicode编码点编码为1到4个字节的序列**（表14-1）。==UTF-8的好处是，「传统的、包含了英语中用到的所有字符的ASCII字符集」中的每个字符，都只会占用一个字节==。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211241015079.png)
另一种常见的编码方式是**UTF-16，它会将每个Unicode编码点编码为1或2个16位值** *one or two 16-bit values*（表14-2）。这是一种**在Java字符串中使用的编码方式**。实际上有两种形式的UTF-16，分别是大端和小端 *big-endian and little-endian* 。考虑16位置 `0x2122` 。大端格式下，高位字节 *the more significant byte* 先出现：`0x21` 后面跟着 `0x22` 。小端格式下是另一种排列方式：`0x22 0x21` 。为了表示使用的是哪一种格式，文件可以以“字节顺序标记 *byte order mark*, BOM”开头，这个标记为16位数值 `0xFEFF` 。读入器可以使用这个值来确定字节顺序，然后丢弃它。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211241027885.png)
> 查看[RFC 2279](http://ietf.org/rfc/rfc2279.txt)和[RFC 2781](http://ietf.org/rfc/rfc2781.txt)以了解UTF-8和UTF-16的定义。

> 警告：有些程序包括Microsoft Notepad在内，都在UTF-8编码的文件开头处添加了一个字节顺序标记。这很明显并不需要，因为在UTF-8中并不存在字节顺序的问题。但Unicode标准允许这样做，甚至认为这是一种好的做法，因为这样可以使编码机制不留疑惑。*It is supposed to be removed when reading a UTF-8 encoded file* 。
> 
> 遗憾的是，Java并没有这么做，有关这个问题的缺陷报告最终以"will not fix"（不做修正）关闭的。对我们来说，最好的做法是**将输入中发现的所有前导 `\uFEFF` 都剥离掉**。

除了UTF编码方式，还有一些编码方式，它们都各自覆盖了「适用于特定用户人群的字符范围」。例如，ISO 8859-1是一种单字节编码，它包含了西欧各种语言中用到的、带有重音符号的字符，而Shift-JIS是一种用于日文字符的可变长编码。类似这些的大量编码方式至今仍被广泛使用。

==不存在任何可靠的方式，可以自动探测出字节流中使用的字符编码方式==。某些API方法让我们使用“默认字符集”，即计算机的操作系统首选的字符编码方式。这种字符编码方式与「我们的字节源中所使用的编码方式」相同吗？字节源中的字节可能来自世界上的其他国家或地区，因此你**应总是明确指定编码方式**。例如，在编写网页时，应检查 `Content-Type` 头信息。
> 警告：在不指定任何编码方式时，有些方法（如 `String(byte[])` 构造器）会使用默认的平台编码方式，而其他方法（如 `Files.readAllLines` ）会使用UTF-8。

在过去，国际化字符集已经得到了处理，但处理得很不系统，散布在Java类库的各处。**在Java 1.4中引入的 `java.nio` 包用 `Charset` 类统一了对字符集的转换**（注意 `s` 是小写的）。
> 注释：平台使用的编码方式 *platform encoding* 可以由静态方法 `Charset.defaultCharset` 返回。**静态方法 `Charset.availableCharsets` 返回所有可用的 `Charset` 实例**，返回结果是一个从字符集的规范名称 *canonical name* 到 `Charset` 对象的映射表。

> 警告：Oracle的Java实现，有一个用于覆盖平台默认值的系统属性 `file.encoding` ，但它并非官方支持的属性，并且Java库的Oracle实现的所有部分、并非都以一致的方式处理该属性，因此你不应该设置它。

**字符集建立了「两字节Unicode码元序列」与「使用本地字符编码方式的字节序列」之间的映射**。
- ISO-8859-1是最流行的字符编码方式之一，这是一种对Unicode前256个字符进行单字节编码的方式。
- ISO-8859-15则更加重要，它用法语和芬兰语中带有重音符号的字母取代了ISO-8859-1中某些不常用到的字符，更重要的是，它用欧元符号 `€` 取代了编码为 `0xA4` 的“国际货币”字符 `¤` 。
- 通常用于日语和中文的可变字节编码方式，是另一个字符编码方式的例子。

**`Charset` 类使用的是由IANA字符集注册中心标准化的[字符集名字](http://www.iana.org/assignments/character-sets)**，这些名字与以前版本所使用的名字略有差异。例如，ISO-8859-1的“官方”名字现在是“ISO-8859-1”而不再是“ISO8859-1”，而后者是直到Java 1.3还在使用的名字（[一顿极佳的ISO8859字母大餐](http://czyborra.com/charsets/iso8859.html)）。

为了兼容其他的命名惯例，每个字符集都可以拥有许多别名。例如，ISO-8859-1的别名有：
```java
ISO8859-1
ISO_8859_1
ISO8859_1
ISO_8859-1
ISO_8859-1:1987
8859-1
latin1
csISOLatin1
iso-ir-100
cp819
819
...
```
`aliases` 方法可以返回由别名构成的 `Set` 对象。下面是迭代遍历这些别名的代码：
```java
Set<String> aliases = cset.aliases();
for (String alias : aliases)
	System.out.println(alias);
```
**字符集名字是大小写不敏感的**。可以通过调用静态的 `forName` 方法来获得一个 `Charset` ，只需向这个方法传递一个官方名字或者是它的某个别名：
```java
Charset cset = Charset.forName("ISO-8859-1");
```

为了确定在某个特定实现中哪些字符集是可用的，可以调用静态的 `availableCharsets` 方法。使用下面的代码可以确定所有可用字符集的名字：
```java
Map<String, Charset> charsets = Charset.availableCharsets();
for (String name : charsets.keySet())
	System.out.println(name);
```
下表1列出了每一种Java实现都必须涵盖的字符编码方式，下表2列出了Java开发包（JDK）默认安装的基本字符编码模式，下表3中的字符集只能在使用非欧洲语言的操作系统上安装，即扩展的字符编码方式。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211241130071.png)
`StandardCharsets` 类具有类型为 `Charset` 的静态变量，用于表示每种Java虚拟机都必须支持的字符编码方式：
```java
StandardCharsets.UTF_8
StandardCharsets.UTF_16
StandardCharsets.UTF_16BE
StandardCharsets.UTF_16LE
StandardCharsets.ISO_8859_1
StandardCharsets.US_ASCII
```

本地编码方式模式不能表示所有的Unicode字符，如果某个字符不能表示，它将被转换成 `?` 。

**一旦有了字符集，就可以使用它在「包含Unicode码元的Java字符串」和「编码而成的字节序列」之间进行转换**，下面是如何编码Java字符串的代码：
```java
String str = ...;
ByteBuffer buffer = cset.encode(str);
byte[] bytes = buffer.array();
```
与之相反，**要想解码字节序列，需要有字节缓冲区**。使用
`ByteBuffer` 的静态方法 `wrap` ，可以将一个字节数组转换成一个字节缓冲区。`decode` 方法的结果是一个 `CharBuffer` ，调用它的 `toString` 方法可以获得一个字符串。
```java
byte[] bytes = ...;
ByteBuffer bbuf = ByteBuffer.wrap(bytes, offset, length);
CharBuffer cbuf = cset.decode(bbuf);
String str = cbuf.toString();
```
在读入或写出文本时，应该使用 `Charset` 对象。例如可以像下面这样将一个字节数组转换为字符串：
```java
var str = new String(bytes, StandardCharsets.UTF_8);
```
> 提示：**在Java 10中，`java.io` 包中的所有方法都允许我们用以 `Charset` 对象或字符串来指定字符编码方式**。应选择的是 `StandardCharsets` 常量，这样就不会在编译时捕获到任何拼写错误了。

> [API] `java.nio.charset.Charset` 1.4
> - `static SortedMap availableCharsets()`
> 获取这个虚拟机可用的所有字符集。返回一个映射表，它的键是字符集的名字，值是字符集。
> - `static Charset forName(String name)`
> 获取给定名字的字符集。
> - `Set aliases()`
> 返回这个字符集的别名集
> - `ByteBuffer encode(String str)`
> 将给定的字符串编码为字节序列。
> - `CharBuffer decode(ByteBuffer buffer)`
> 解码给定的字节序列。无法识别的输入将被转换成Unicode的“替代字符” `'\uFFFD'` 。

> [API] `java.nio.ByteBuffer` 1.4
> - `byte[] array()`
> 返回这个缓冲区所管理的字节数组。
> - `static ByteBuffer wrap(byte[] bytes)` 
> - `static ByteBuffer wrap(byte[] bytes, int offset, int length)`
> 返回管理给定字节数组或给定字节数组的某个范围的字节缓冲区。

> [API] `java.nio.CharBuffer`
> - `char[] array()`
> 返回这个缓冲区所管理的码元数组。
> - `char charAt(int index)`
> 返回给定索引处的码元。
> - `String toString()`
> 返回由这个缓冲区所管理的码元构成的字符串。

---
# 14.2 读写二进制数据
文本格式对于测试和调试来说很方便，因为是人类可阅读的，但它并不像二进制格式传递数据那样高效。下面各小节中用二进制数据来完成输入输出。
## 14.2.1 `DataInput, DataOutput` 接口
`DataOutput` 接口定义了下面以二进制格式写数组、字符、`boolean` 值和字符串的方法：
```java
writeChars  writeByte writeInt
writeShort  writeLong writeFloat
writeDouble writeChar writeBoolean
writeUTF
```
例如，`writeInt` 总是将一个整数写出为4字节的二进制数量值，而不管它有多少位，`writeDouble` 总是将一个 `double` 值写出为8字节的二进制数量值。这样产生的结果并非人可阅读，但对于给定类型的每个值，所需空间都是相同的，而且将其读回也比解析文本要更快。
> 注意：**根据所使用的处理器类型，在内存存储整数和浮点数有两种不同的方法**。例如，假设使用的是4字节的 `int` ，如果有一个十进制数1234，也就是4D2(in hex)（1234=4×256+13×16+2），那么它可以按照「内存中4字节的第一个字节存储最高位字节」的方式来存储为：00 00 04 D2，这就是所谓的高位在前顺序 *most significant byte, MSB* ;也可以从最低位字节开始：`D2 04 00 00` ，这种方式自然就是所谓的低位在前顺序 *least significant byte, LSB* 。例如，SPARC使用的是高位在前顺序，而Pentium使用的则是低位在前顺序。
> 
> 这就可能会带来问题，当存储C或者C++文件时，数据会精确地按照处理器存储它们的方式来存储，这就使得即使是最简单的数据在从一个平台迁移到另一个平台上时也是一种挑战。==在Java中，所有的值都按照高位在前的模式写出，不管使用何种处理器，这使得Java数据文件可以独立于平台==。

`writeUTF` 方法使用「修订版的8位Unicode转换格式 *Unicode Transformation Format* 」写出字符串，这种方式与直接使用标准的UTF-8编码方式不同，其中==Unicode码元序列首先用UTF-16表示，其结果之后使用UTF-8规则进行编码==。修订后的编码方式对于编码大于 `0xFFFF` 的字符的处理有所不同，这是为了向后兼容在Unicode还没有超过16位时构建的虚拟机。因为没有其他方法会使用UTF-8的这种修订 *this modification of UTF-8* ，所以应只在写出「用于一个Java虚拟机的字符串」时才使用 `writeUTF` 方法，例如，当你需要编写一个生成字节码的程序时。对于其他场合，都应该使用 `writeChars` 方法。
 
为了读回数据，可以使用在 `DataInput` 接口中定义的下列方法：
```java
readInt   readShort readLong
readFloat readDouble readChar
readBoolean readUTF
```
**`DataInputStream` 类实现了 `DataInput` 接口，为了从文件中读入二进制数据，可以将 `DataInputStream` 与某个字节源相组合**，例如 `FileInputStream` ：
```java
var in = new DataInputStream(new FileInputStream("employee.dat"));
```
与此类似，要想写出二进制数据，可以使用实现了 `DataOutput接口的DataOutput-Stream类：
```java
var out = new DataOutputStream(new FileOutputStream("employee.dat"));
```

> [API] `java.io.DataInput` 1.0
> - `boolean readBoolean()`
> - `byte readByte()`
> - `char readChar()`
> - `double readDouble()`
> - `float readFloat()`
> - `int readInt()`
> - `long readLong()`
> - `short readShort()`
> 读入一个给定类型的值。
> - `void readFully(byte[] b)`
> 将字节读入到数组 `b` 中，其间阻塞直至所有字节都读入。
> - `void readFully(byte[]b, int off, int len)`
> 将 `len` 数量的字节读入到数组 `b` 中从 `off` 开始的位置，其间阻塞直至所有字节都读入。
> - `String readUTF()`
> 读入由“修订过的UTF-8”格式的字符构成的字符串。
> - `int skipBytes(int n)`
> 跳过 `n` 个字节，其间阻塞直至所有字节都被跳过。

> [API] `java.io.DataOuput` 1.0
> - `void writeBoolean(boolean b)`
> - `void writeByte(int b)`
> - `void writeChar(int c)`
> - `void writeDouble(double d)`
> - `void writeFloat(float f)`
> - `void writeInt(int i)`
> - `void writeLong(long l)`
> - `void writeShort(int s)`
> 写出一个给定类型的值。
> - `void writeChars(String s)`
> 写出字符串中的所有字符。
> - `void writeUTF(String s)`
> 写出由“修订过的UTF-8”格式的字符构成的字符串。

## 14.2.2 随机访问文件
**`RandomAccessFile` 类可以在文件中的任何位置查找或写入数据**。磁盘文件都是随机访问的，但从网络而来的、与网络*socket*通信的输入/输出流却不是。你**可以打开一个随机访问文件，只用于读入或者同时用于读写**，使用字符串 `"r"`（用于读入访问）或 `"rw"`（用于读入/写出访问）作为构造器的第二个参数来指定这个选项。
```java
var in = new RandomAccessFile("employee.dat", "r");
var inOut = new RandomAccessFile("employee.dat", "rw");
```
**将已有文件作为 `RandomAccessFile` 打开时，这个文件并不会被删除**。

随机访问文件有一个表示「下一个将被读入或写出的字节所处位置」的文件指针，`seek` 方法可以将这个文件指针设置到文件中的任意字节位置，`seek` 的参数是一个 `long` 类型的整数，它的值位于0到文件按照字节来度量的长度之间。`getFilePointer` 方法将返回文件指针的当前位置。

**`RandomAccessFile` 类同时实现了 `DataInput` 和 `DataOutput` 接口**。为了读写随机访问文件，可使用前面小节的诸如 `readInt/writeInt, readChar/writeChar` 之类的方法。

现在要剖析一个将雇员记录存储到随机访问文件中的示例程序，其中每条记录都拥有相同的大小，这样我们可以很容易地读入任何记录。假设希望将文件指针置于第三条记录处，那么只需将文件指针置于恰当的字节位置，然后就可以开始读入了。
```java
long n = 3;
in.seek((n - 1) * RECORD_SIZE);
var e = new Employee();
e.readData(in);
```
**如果希望修改记录，然后将其存回到相同的位置，那么请切记要将文件指针置回到这条记录的开始处**：
```java
in.seek((n - 1) * RECORD_SIZE);
e.writeData(out);
```
要确定文件中的字节总数，可以使用 `length` 方法，而记录的总数则是用字节总数除以每条记录的大小。
```java
long nbytes = in.length(); // length in bytes
int nrecords = (int) (nbytes / RECORD_SIZE);
```

整数和浮点值在二进制格式中都具有固定的尺寸，但在处理字符串时就有些麻烦了，因此我们提供了两个助手方法来读写具有固定尺寸的字符串。
- `writeFixedString` 写出从字符串开头开始的指定数量的码元（如果码元过少，该方法将用0值来补齐字符串）。
- `readFixedString` 方法从输入流中读入字符，直至读入 `size` 个码元，或直至遇到具有0值的字符值，然后跳过输入字段中剩余的0值。为了提高效率，这个方法使用了 `StringBuilder` 类来读入字符串。

```java
public static void writeFixedString(String s, int size, DataOutput out) throws IOException {
	for (int i = 0; i < size; i++) {
		char ch = 0;
		if (i < s.length()) ch = s.charAt(i);
		out.writeChar(ch);
	}
}

public static String readFixedString(int size, DataInput in) throws IOException {
	var b = new StringBuilder(size);
	int i = 0;
	var done = false;
	while (!done && i < size) {
		char ch = in.readChar();
		i++;
		if (ch == 0) done = true;
		else b.append(ch);
	}
	in.skipBytes(2 * (size - i)); // 
	return b.toString();
}
```
我们将 `writeFixedString, readFixedString` 方法放到 `DataIO` 助手类的内部。

为了写出一条固定尺寸的记录，我们直接以二进制方式写出所有的字段：
```java
DataIO.writeFixedString(e.getName(), Employee.NAME_SIZE, out);
out.writeDouble(e.getSalary());
LocalDate hireDay = e.getHireDay();
out.writeInt(hireDay.getYear());
out.writeInt(hireDay.getMonthValue());
out.writeInt(hireDay.getDayOfMonth());
```
读回数据也很简单：
```java
String name = DataIO.readFixedString(Employee.NAME_SIZE, in);
double salary = in.readDouble();
int y = in.readInt();
int m = in.readInt();
int d = in.readInt();
```
计算每条记录的大小：使用40个字符来表示姓名字符串，因此每条记录包含100个字节：
- 40字符=80字节，用于姓名。
- 1 double=8字节，用于薪水。
- 3 int=12字节，用于日期。

所示程序 `randomAccess/RandomAccessTest.java` 将三条记录写到了一个数据文件中，然后以逆序将它们从文件中读回。为了高效地执行，这里需要使用随机访问，因为我们需要首先读入第三条记录。
```java
// randomAccess/DataIO.java
package randomAccess;

import java.io.*;

public class DataIO {
    public static String readFixedString(int size, DataInput in) throws IOException {  
        var b = new StringBuilder(size);
        int i = 0;
        var done = false;
        while (!done && i < size)
        {  
            char ch = in.readChar();
            i++;
            if (ch == 0) done = true;
            else b.append(ch);
        }
        in.skipBytes(2 * (size - i));
        return b.toString();
    }

    public static void writeFixedString(String s, int size, DataOutput out) throws IOException {
        for (int i = 0; i < size; i++) {  
            char ch = 0;
            if (i < s.length()) ch = s.charAt(i);
            out.writeChar(ch);
        }
    }
}
```
```java
// randomAccess/Employee.java
package randomAccess;

import java.time.*;

public class Employee {
	public static final int NAME_SIZE = 40;
	public static final int RECORD_SIZE = 2 * NAME_SIZE + 8 + 4 + 4 + 4;
	private String name;
	private double salary;
	private LocalDate hireDay;

	public Employee() {}
	public Employee(String n, double s, int year, int month, int day) {
		name = n;
		salary = s;
		hireDay = LocalDate.of(year, month, day);
	}

	public String getName() { return name; }

	public double getSalary() { return salary; }

	public LocalDate getHireDay() { return hireDay; }

	public void raiseSalary(double byPercent) {
	   double raise = salary * byPercent / 100;
	   salary += raise;
	}

	public String toString() {
		return getClass().getName() 
				+ "[name=" + name + ",salary=" + salary + ",hireDay=" + hireDay + "]";
	}
}
```
```java
// randomAccess/RandomAccessTest.java
package randomAccess;

import java.io.*;
import java.time.*;

public class RandomAccessTest {
	public static void main(String[] args) throws IOException {
		var staff = new Employee[3];
		staff[0] = new Employee("Carl Cracker", 75000, 1987, 12, 15);
		staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
		staff[2] = new Employee("Tony Tester", 40000, 1990, 3, 15);
		
		try (var out = new DataOutputStream(new FileOutputStream("./src/randomAccess/employee.dat"))) {
			// save all employee records to the file employee.dat
			for (Employee e : staff)
				writeData(out, e);
		}

		try (var in = new RandomAccessFile("./src/randomAccess/employee.dat", "r")) {
			// retrieve all records into a new array
			// compute the array size
			int n = (int)(in.length() / Employee.RECORD_SIZE);
			var newStaff = new Employee[n];

			// read employees in reverse order
			for (int i = n - 1; i >= 0; --i) {
				newStaff[i] = new Employee();
				in.seek(i * Employee.RECORD_SIZE);
				newStaff[i] = readData(in);
			}

			// print the newly read employee records
			for (Employee e : newStaff)
				System.out.println(e);
		}
	}

	/**
	 * Writes employee data to a data output
	 * @param out the data output
	 * @param e the employee
	 */
	public static void writeData(DataOutput out, Employee e) throws IOException {
		DataIO.writeFixedString(e.getName(), Employee.NAME_SIZE, out);
		out.writeDouble(e.getSalary());

		LocalDate hireDay = e.getHireDay();
		out.writeInt(hireDay.getYear());
		out.writeInt(hireDay.getMonthValue());
		out.writeInt(hireDay.getDayOfMonth());
	}

	/**
	 * Reads employee data from a data input
	 * @param in the data input
	 * @return the employee
	 */
	public static Employee readData(DataInput in) throws IOException {
		String name = DataIO.readFixedString(Employee.NAME_SIZE, in);
		double salary = in.readDouble();
		int y = in.readInt();
		int m = in.readInt();
		int d = in.readInt();
		return new Employee(name, salary, y, m, d);
	}
}
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212172358104.png)


> [API] `java.io.RandomAccessFile` 1.0
> - `RandomAccessFile(String file, String mode)`
> - `RandomAccessFile(File file, String mode)`
> 打开给定的用于随机访问的文件。`mode` 字符串 `"r"` 表示只读模式;`"rw"` 表示读/写模式;`"rws"` 表示**每次更新时，都对数据和元数据的写磁盘操作进行同步的读/写模式** *read/write mode with synchronous disk writes of data and metadata for every update* ;`"rwd"` 表示每次更新时，只对数据的写磁盘操作进行同步的读/写模式。
> - `long getFilePointer()`
> 返回文件指针的当前位置。
> - `void seek(long pos)`
> 将文件指针设置到距文件开头 `pos` 个字节处。
> - `long length()`
> 返回文件按照字节来度量的长度。

## 14.2.3 ZIP文档
==ZIP文档（通常）以压缩格式存储了一个或多个文件，每个ZIP文档都有一个头，包含诸如每个文件名字和所使用的压缩方法等信息==。在Java中，可以**使用 `ZipInputStream` 来读入ZIP文档**。

可能需要浏览文档中每个单独的项 *entries* ，`getNextEntry` 方法返回一个描述这些项的 `ZipEntry` 类型的对象，该方法会从流中读入数据、直至末尾，实际上这里的末尾是指「正在读入的项的末尾」然后你必须调用 `closeEntry` 来读入下一项。下面是典型的通读ZIP文件的代码序列：
```java
var zin = new ZipInputStream(new FileInputStream(zipname));
ZipEntry entry;
while ((entry = zin.getNextEntry()) != null) {
	// read the contents of zin
	zin.closeEntry();
}
zin.close();
```
> 警告：在读入单个ZIP项后，不要关闭ZIP输入流，也不要将其传递给可能会关闭它的方法。否则，就不能再读入后续的项了。

**要写出到ZIP文件，可以使用 `ZipOutputStream`** ，而对于希望放入到ZIP文件中的每一项，都应该创建一个 `ZipEntry` 对象，并将文件名传递给 `ZipEntry` 的构造器，它将设置其他诸如文件日期和解压缩方法等参数。如果需要，可以覆盖这些设置。然后，需要调用 `ZipOutputStream` 的 `putNextEntry` 方法来开始写出新文件，并将文件数据发送到ZIP输出流中。当完成时，需要调用 `closeEntry` 。然后，需要对所有你希望存储的文件都重复这个过程。下面是代码框架：
```java
var fout = new FileOutputStream("test.zip");
var zout = new ZipOutputStream(fout);
for all files {
	var ze = new ZipEntry(filename);
	zout.putNextEntry(ze);
	// send data to zout
	zout.closeEntry();
}
zout.close();
```
> 注意：==JAR文件==（卷I章10）==只是带有一个特殊项的ZIP文件== *simply ZIP files with a special entry*，==这个项称作清单== *manifest* 。可以使用 `JarInputStream` 和 `JarOutputStream` 类来读写清单项。

ZIP流是一个能展示流抽象化 *stream abstraction* 的强大之处的实例。==当读入以压缩格式存储的数据时，不必担心边请求边解压数据的问题，而且ZIP格式的字节源并非必须是文件，也可以是来自网络连接的ZIP数据==。事实上，当Applet的类加载器读入JAR文件时，它就是在读入和解压来自网络的数据。
> 注意：14.4.8节“ZIP文件系统”将展示如何使用Java 7的`FileSystem` 类、而无需特殊API来访问ZIP文档。

> [API] `java.util.zip.ZipInputStream` 1.1
> - `ZipInputStream(InputStream in)`
> 创建一个 `ZipInputStream` ，使我们可以从给定的 `InputStream` 向其中填充数据。
> - `ZipEntry getNextEntry()`
> 为下一项返回 `ZipEntry` 对象，或在没有更多的项时返回 `null` 。
> - `void closeEntry()`
> 关闭这个ZIP文件中当前打开的项。之后可以通过使用 `getNextEntry()` 读入下一项。

> [API] `java.util.zip.ZipOutputStream` 1.1
> - `ZipOutputStream(OutputStream out)`
> 创建一个将压缩数据写出到指定的 `OutputStream` 的 `ZipOutputStream` 。
> - `void putNextEntry(ZipEntry ze)`
> 将给定的 `ZipEntry` 中的信息写出到流中，并定位用于写出数据的流，然后这些数据可以通过 `write()` 写出到这个流中。
> - `void closeEntry()`
> 关闭这个ZIP文件中当前打开的项。使用 `putNextEntry` 方法可以开始下一项。
> - `void setLevel(int level)`
> 设置后续的各个 `DEFLATED` 项的默认压缩级别、为从 `Deflater.NO_COMPRESSION` 到 `Deflater.BEST_COMPRESSION` 的某个值。默认值是 `Deflater.DEFAULT_COMPRESSION` 。如果级别无效，则抛出 `IllegalArgumentException` 。
> - `void setMethod(int method)`
> 设置用于这个 `ZipOutputStream` 的默认压缩方法，这个压缩方法会作用于所有没有指定压缩方法的项上。压缩方法可以是 `DEFLATED` 或 `STORED`

> [API] `java.util.zip.ZipEntry` 1.1
> - `ZipEntry(String name)`
> 用给定的名字构建一个Zip项。
> - `long getCrc()`
> 返回用于这个 `ZipEntry` 的CRC32校验和的值。
> - `String getName()`
> 返回这一项的名字。
> - `long getSize()`
> 返回这一项未压缩的尺寸，或在未压缩的尺寸不可知的情况下返回-1。
> - `boolean isDirectory()`
> 当这一项是目录时返回 `true` 。
> - `void setMethod(int method)`
> 设置用于这一项的压缩方法，必须是 `DEFLATED` 或 `STORED` 。
> - `void setSize(long size)`
> 设置这一项的尺寸，只有在压缩方法是 `STORED` 时才是必需的。
> - `void setCrc(long crc)`
> 给这一项设置CRC32校验和，这个校验和是使用 `CRC32` 类计算的。只有在压缩方法是 `STORED` 时才是必需的。

> [API] `java.util.zip.ZipFile` 1.1
> - `ZipFile(String name)`
> - `ZipFile(File file)`
> 创建一个 `ZipFile` ，用于从给定的字符串或File对象中读入数据。
> - `Enumeration entries()`
> 返回一个 `Enumeration` 对象，它枚举了描述这个 `ZipFile` 中各个项的 `ZipEntry` 对象。
> - `ZipEntry getEntry(String name)`
> 返回给定名字所对应的项，或在没有对应项的时候返回 `null` 。
> - `InputStream getInputStream(ZipEntry ze)`
> 返回用于给定项的 `InputStream` 。
> - `String getName()`
> 返回这个ZIP文件的路径。

---
# 14.3 对象流与序列化
当需要存储相同类型的数据时，使用固定长度的记录格式是一个不错的选择。但在面向对象程序中创建的对象很少全部都具有相同的类型。例如，可能有一个称为 `staff` 的数组，它名义上是一个 `Employee` 记录数组，但实际上却包含诸如 `Manager` 这样的子类实例。

当然可以自己设计出一种数据格式来存储这种多态集合，但幸运的是，我们并不需要这么做。==Java语言支持一种称为**对象序列化** *object serialization* 的非常通用的机制，它可以将任何对象写出到输出流中，并在之后将其读回==。

为了保存对象数据，首先需要打开一个 `ObjectOutputStream` 对象：
```java
var out = new ObjectOutputStream(new FileOutputStream("employee.dat"));
```
现在，为了保存对象，可以直接使用 `ObjectOutputStream` 的 `writeObject` 方法，如下所示：
```java
var harry = new Employee("Harry Hacker", 50000, 1989, 10, 1);
var boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);
out.writeObject(harry);
out.writeObject(boss);
```
为了将这些对象读回，首先需要获得一个 `ObjectInputStream` 对象：
```java
var in = new ObjectInputStream(new FileInputStream("employee.dat"));
```
然后，用 `readObject` 方法以「这些对象被写出时的顺序」获得它们：
```java
var e1 = (Employee) in.readObject();
var e2 = (Employee) in.readObject();
```
但，**对「希望在对象流中存储或恢复的所有类」，你都需要进行一个修改 *change* ，这些类必须实现 `Serializable` 接口**：
```java
class Employee implements Serializable { ... }
```
`Serializable` 接口没有任何方法，因此不需要对这些类做任何改动。在这一点上，它与卷I章6讨论过的 `Cloneable` 接口很相似。但**为了使类可克隆，仍需要覆盖 `Object` 类中的 `clone` 方法**，而**为了使类可序列化，不需要做任何事**。
> 注意：**只有在写出对象时，才能用 `writeObject/readObject` 方法**。对于基本类型值，需要使用诸如 `writeInt/readInt` 或 `writeDouble/readDouble` 这样的方法（对象流类 *object stream class* 都实现了 `DataInput/DataOutput` 接口）。

在幕后 *behind the scenes* ，一个 `ObjectOutputStream` 浏览对象的所有字段、并存储它们的内容。例如，当写出一个 `Employee` 对象时，其名字、日期和薪水字段都会被写出到输出流中。

但有一种重要的情况需要考虑：*What happens when one object is shared by several objects as part of its state*
当一个对象被多个对象共享，作为它们各自状态的一部分时，会发生什么呢？为了说明这个问题，对 `Manager` 类稍微做些修改，假设每个经理都有一个秘书：
```java
class Manager extends Employee {
	private Employee secretary;
	...
}
```
现在每个 `Manager` 对象都包含一个表示秘书的 `Employee` 对象的引用，当然，两个经理可以共用一个秘书，正如下图和下面的代码所示：
```java
var harry = new Employee("Harry Hacker", ...);
var carl = new Manager("Carl Cracker", ...);
carl.setSecretary(harry);

var tony = new Manager("Tony Tester", ...);
tony.setSecretary(harry);
```
![图14-5 两个经理可以共用一个共有的雇员](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211242350681.png)

保存这样的对象网络是一种挑战，在这里我们当然不能去保存和恢复 *save and restore* 秘书对象的内存地址，因为当对象被重新加载时，它可能占据与原来完全不同的内存地址。与此不同的是，==每个对象都是用一个序列号 *serial number* 保存的，这就是这种机制之所以称为对象序列化的原因==。下面是其算法：
- 关联一个序列号到你遇到的每一个对象引用（如图14-6所示）。
- 对于每个对象，当第一次遇到时，保存其对象数据到流中。
- 如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为 `x` 的对象相同”。
![图14-6 一个对象序列化的实例](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211242357237.png)

在读回对象时，整个过程是反过来的。
- 对于一个对象输入流中的对象，在第一次遇到其序列号时，构建它，并使用流中数据来初始化它，然后记录这个序列号和新对象之间的关联。
- 当遇到“与之前保存过的序列号为 `x` 的对象相同”标记时，获取与这个序列号相关联的对象引用。

> 注意：这里，我们使用序列化将对象集合保存到磁盘文件中，并按照它们被存储的样子获取它们。==序列化的另一种非常重要的应用是，通过网络将对象集合传送到另一台计算机上==。正如在文件中保存原生的内存地址毫无意义一样，这些地址对于「在不同处理器之间的通信」也是毫无意义的。==因为序列化用序列号代替了内存地址，所以它允许将对象集合从一台机器传送到另一台机器==。后面会讨论远程方法调用时，会学习序列化的这种用法。

`objectStream/ObjectStreamTest.java` 是保存和重新加载 `Employee` 和 `Manager` 对象网络的代码（有些对象共享相同的表示秘书的雇员）。注意，秘书对象在重新加载之后是惟一的，当 `newStaff[1]` 被恢复时，它会反映到经理们的 `secretary` 字段中。
```java
// objectStream/ObjectStreamTest.java
package objectStream;

import java.io.*;

class ObjectStreamTest {
	public static void main(String[] args) throws IOException, ClassNotFoundException {
		var harry = new Employee("Harry Hacker", 50000, 1989, 10, 1);
		var carl = new Manager("Carl Cracker", 80000, 1987, 12, 15);
		carl.setSecretary(harry);
		var tony = new Manager("Tony Tester", 40000, 1990, 3, 15);
		tony.setSecretary(harry);

		var staff = new Employee[3];
		staff[0] = carl;
		staff[1] = harry;
		staff[2] = tony;

		// save all employee records to the file employee.dat
		try (var out = new ObjectOutputStream(new FileOutputStream("./src/objectStream/employee.dat"))) {
			out.writeObject(staff);
		}

		try (var in = new ObjectInputStream(new FileInputStream("employee.dat"))) {
			// retrieve all records into a new array
			var newStaff = (Employee[]) in.readObject();
			// raise secretary's salary
			newStaff[1].raiseSalary(10);
			// print the newly read employee records
			for (Employee e : newStaff)
				System.out.println(e);
		}
	}
}
```
相对应的 `Employee.java, Manager.java` 都在文件夹中（ `Employee` 实现了 `Serializable` 接口）。运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212171846495.png)

> [API] `java.io.ObjectOutputStream` 1.1
> - `ObjectOutputStream(OutputStream out)`
> 创建一个 `ObjectOutputStream` ，使你可以将对象写出到指定的 `OutputStream` 。
> - `void writeObject(Object obj)`
> 写出指定的对象到 `ObjectOutputStream` ，**这个方法将存储指定对象的类、类的签名以及「这个类及其超类中所有非静态和非瞬时的字段的值」** *the values of the nontransient and nonstatic fields of the class and all its superclasses.* 。

> [API] `java.io.ObjectInputStream` 1.1
> - `ObjectInputStream(InputStream in)`
> 创建一个 `ObjectInputStream` 用于从指定的 `InputStream` 中读回对象信息。
> - `Object readObject()`
> 从 `ObjectInputStream` 中读入一个对象。特别是，这个方法会读回对象的类、类的签名以及这个类及其超类中所有非静态和非瞬时的字段的值。**它执行的反序列化允许恢复多个对象引用**。

## 14.3.2 理解对象序列化的文件格式
对象序列化是以特殊的文件格式存储对象数据的，当然，你不必了解文件中表示对象的确切字节序列，就可以使用 `writeObject/readObject` 方法。但我们发现，==研究这种数据格式对于洞察对象序列化 *the object serialization process* 的处理过程非常有益==。因为其细节显得有些专业，所以如果对其实现不感兴趣，则可以跳过。

每个文件都是**以下面这两个字节的“魔幻数字”开始的**：
```java
AC ED
```
后面紧跟着**对象序列化格式的版本号**，目前是（本节中统一使用十六进制数字来表示字节）：
```java
00 05
```
然后是**它包含的对象序列，其顺序即它们被存储的顺序**。

字符串对象被存为：
```java
74 two-byte-length characters
```
例如，字符串“Harry”被存为：
```java
74 00 05 Harry
```
**字符串中的Unicode字符被存储为修订过的UTF-8格式**。

**当存储一个对象时，这个对象所属的类也必须存储**。这个类的描述**包含**：
- 类名。
- 序列化的版本惟一的ID *serial version unique ID* ，它是数据字段类型和方法签名的指纹 *fingerprint* 。
- 描述序列化方法 *serialization method* 的标志集 *a set of flags* 。
- 对数据域的描述。

指纹是通过对类、超类、接口、字段类型和方法签名按照规范方式 *in a canonical way* 排序，然后将安全散列算法（SHA）应用于这些数据而获得的。

==SHA是一种可以为较大的信息块提供指纹的快速算法，不论最初的数据块尺寸有多大，这种指纹总是一个20个字节的数据包==。它是通过在数据上执行一个灵巧的位操作序列而创建的，这个序列在本质上可以百分之百地保证，==无论这些数据以何种方式发生变化，其指纹也都会跟着变化==（关于SHA的更多细节，可以查看一些参考资料，如 *Cryptography and Network Security：Principles and Practice, edition 5, William Stallings* 。但，序列化机制只使用了SHA码的前8个字节作为类的指纹。即便这样，当类的数据字段或方法发生变化时，其指纹跟着变化的可能性还是非常大。

==在读入一个对象时，会拿其指纹与它所属的类的当前指纹进行比对，如果它们不匹配，那么就说明这个类的定义在该对象被写出之后发生过变化，因此会产生一个异常==。在实际情况下，类当然是会演化的，对于一个程序来说，读入较旧版本的对象可能是必需的。14.4.5节“版本管理”讨论这个问题。

下面表示了一个类标识符是**如何存储**的：
- 72
- 2字节的类名长度
- 类名
- 8字节长的指纹
- 1字节长的标志
- 2字节长的数据域描述符的数量
- 数据域描述符
- 78（结束标记）
- 超类类型（如果没有就算70）。

标志字节是由在 `java.io.ObjectStreamConstants` 中定义的3位掩码构成的：
```java
static final byte SC_WRITE_METHOD = 1;
	// class has a writeObject method that writes additional data
static final byte SC_SERIALIZABLE = 2;
	// class implements the Serializable interface
static final byte SC_EXTERNALIZABLE = 4;
	// class implements the Externalizable interface
```
稍后讨论 `Externalizable` 接口。可外部化的类提供了定制的接管其实例域输出的读写方法。我们要写出的这些类实现了 `Serializable` 接口，并且其标志值为02，而可序列化的 `java.util.Date` 类定义了它自己的 `readObject/writeObject` 方法，并且其标志值为03。

每个数据域描述符的格式如下：
- 1字节长的类型编码
- 2字节长的域名长度
- 域名 *field name*
- 类名

其中类型编码是下列取值之一：
```java
B byte
C char
D double
F float
I int
J long
L object
S short
Z boolean
[ array
```
当类型编码为 `L` 时，域名称后面紧跟域类型 *the field name is followed by the field type*（如下面的 `salary` 名称后面跟着 `Ljava/util/Date` 类型，或 `name` 后面跟着 `Ljava/lang.String` 类型）。**类名和域名字符串不是以字符串编码74开头的，但域类型是**。域类型使用的是与域名稍有不同的编码机制，即本地方法使用的格式。

例如，`Employee` 类的薪水域被编码为：
```java
D 00 06 salary
```
下面是 `Employee` 类完整的类描述符：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211250102006.png)

这些描述符相当长，如果在文件中再次需要相同的类描述符，可以使用一种缩写版，这个序列号将引用到前面已经描述过的类描述符，我们稍后将讨论编号模式 *numbering scheme* ：
```java
71 4-byte serial number
```

一个对象将被存储为：
```java
73 class-descriptor object-data
```
例如，下面展示的就是 `Employee` 对象如何存储：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211250119507.png)

正如所看见的，数据文件包含了足够的信息来恢复这个 `Employee`对象。

数组总是被存储成下面的格式：
```java
75 类描述符class-descriptor 4字节长的数组项的数量 数组项
```
注意，在类描述符中的数组类名的格式，与本地方法 *native methods* 中使用的格式相同（它与「其他类描述符中的类名使用的格式」稍微有些差异）。在这种格式中，类名以 `L` 开头，以分号结束。

例如，3个 `Employee` 对象构成的数组写出，开始就像下面一样：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211250124771.png)
注意，`Employee` 对象数组的指纹与 `Employee` 类自身的指纹并不相同。

**所有对象（包含数组和字符串）和所有的类描述符，在存储到输出文件时都被赋予了一个序列号** *serial numbers ，这个数字以00 7E 00 00开头。

已经看到过，==任何给定类其完整的类描述符只保存一次，后续的描述符将引用它==。例如，在前面的示例中，对 `Date` 类的重复引用就被编码为：
```java
71 00 7E 00 08
```
==相同的机制还被用于对象。如果要写出一个对之前存储过的对象的引用，那么这个引用也会以完全相同的方式存储，即71后面跟随序列号==。从上下文中可以很清楚地了解，这个特殊的序列引用 *a particular serial reference* 表示的是一个类描述符还是一个对象。

最后，空引用被存储为：
```
70
```
下面是前面小节中 `ObjectRefTest` 程序的带注释的输出。如果你喜欢，可以运行这个程序，然后查看其数据文件 `employee.dat` 的十六进制码，并将其与注释列表比较。在输出中接近结束部分的几行重要编码，展示了对之前存储过的对象的引用。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211250137835.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211250139079.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211250140534.png)

当然，研究这些编码很枯燥。了解确切的文件格式确实不那么重要（除非试图通过修改数据来达到不可告人的目的），但==对象流对其所包含的所有对象都有详细描述，且这些充足的细节可以用来重构对象和对象数组，因此了解它还是大有益处的==。

应该记住：
- 对象流输出中包含所有对象的类型和数据域。
- **每个对象都被赋予一个序列号**。
- **相同对象的重复出现，将被存储为对这个对象的序列号的引用**。

## 14.3.3 修改默认的序列化机制
==某些数据域不应 *should never* 被序列化==，例如，只对本地方法有意义的、存储文件句柄或窗口句柄的整数值，在稍后重新加载对象或将其传送到其他机器上时，这种信息都是没有用处的。事实上，这种域的值如果不恰当，还会引起本地方法崩溃。

Java拥有一种很简单的机制来**防止这种域被序列化，那就是将它们标记成是 `transient` 的**。如果这些域属于不可序列化的类 *nonserializable classes* ，也需要将它们标记成 `transient` 的。**瞬时的域在对象被序列化时总是被跳过的**。

序列化机制为单个的类提供了一种方式，去向默认的读写行为添加验证或任何其他想要的行为 *add validation or any other desired action to the default read and write behavior* 。==可序列化的类可以定义具有下列签名的方法。之后，数据域就再也不会被自动序列化，取而代之的是调用这些方法==：
```java
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException;
private void writeObject(ObjectOutputStream out) throws IOException;
```

下面是一个典型的示例。在 `java.awt.geom` 包中有大量的类都是不可序列化的，例如 `Point2D.Double` 。现在假设想要序列化一个 `LabeledPoint` 类，它存储了一个 `String` 和一个  `Point2D.Double` 。首先，需要将 `Point2D.Double` 标记成 `transient` ，以避免抛出 `NotSerializableException` 。
```java
public class LabeledPoint implements Serializable {
	private String label;
	private transient Point2D.Double point;
	...
}
```
在 `writeObject` 方法中，我们**首先通过调用 `defaultWriteObject` 方法写出对象描述符和 `String` 域 `label`** ，这是 **`ObjectOutputStream` 类中的一个特殊的方法，它只能在可序列化类的 `writeObject` 方法中被调用**。然后，我们使用标准的 `DataOutput` 调用写出点的坐标。
```java
private void writeObject(ObjectOutputStream out)
	throws IOException {
	out.defaultWriteObject();
	out.writeDouble(point.getX());
	out.writeDouble(point.getY());
}
```
在 `readObject` 方法中，我们反过来执行上述过程：
```java
private void readObject(ObjectInputStream in)
	throws IOException {
	in.defaultReadObject();
	double x = in.readDouble();
	double y = in.readDouble();
	point = new Point2D.Double(x, y);
}
```

另一个例子是 `java.util.Date` 类，它提供了自己的 `readObject, writeObject` 方法，这些方法将日期写出为从纪元（UTC时间1970年1月1日0点）开始的毫秒数。`Date` 类有一个复杂的内部表示，为了优化查询，它存储了一个 `Calendar` 对象和一个毫秒计数值。`Calendar` 的状态是冗余的，因此并不需要保存。`readObject, writeObject` 方法只需要保存和加载它们的数据域，而不需要关心超类数据和任何其他类的信息。

==除了让序列化机制来保存和恢复对象数据，类还可以定义它自己的机制==。为了做到这一点，这个类必须实现 `Externalizable` 接口，这需要它定义两个方法：
```java
public void readExternal(ObjectInputStream in)
	throws IOException, ClassNotFoundException;
public void writeExternal(ObjectOutputStream out)
	throws IOException;
```
与前面一节描述的 `readObject, writeObject` 不同，==这些方法对「包括超类数据在内的整个对象」的存储和恢复负全责 *fully responsible* ，而序列化机制在输出流中、仅仅只是记录该对象所属的类==。
在读入可外部化的类时，对象输入流将用无参构造器创建一个对象 *creates an object with the no-argument constructor*、然后调用 `readExternal` 方法。下面展示了如何为 `Employee` 类实现这些方法：
```java
public void readExternal(ObjectInput s) throws IOException {
	name = s.readUTF();
	salary = s.readDouble();
	hireDay = LocalDate.ofEpochDay(s.readLong());
}

public void writeExternal(ObjectOutput s)
	throws IOException {
	s.writeUTF(name);
	s.writeDouble(salary);
	s.writeLong(hireDay.toEpochDay());
}
```
> 警告：**`readObject, writeObject` 方法是私有的，并且只能被序列化机制调用**。与此不同的是，`readExternal, writeExternal` 方法是公共的。特别是，`readExternal` 还潜在地允许修改现有对象的状态。

## 14.3.4 序列化单例和类型安全的枚举
==在序列化和反序列化时，如果目标对象是唯一的，那么必须加倍当心==，这通常会在实现单例和类型安全的枚举 *singletons and typesafe enumerations* 时发生。

**如果你使用Java语言的 `enum` 结构，那么你就不必担心序列化，它能够正常工作**。但假设你在维护遗留代码，其中包含下面这样的枚举类型：
```java
public class Orientation {
	public static final Orientation HORIZONTAL = new Orientation(1);
	public static final Orientation VERTICAL = new Orientation(2);
	private int value;
	private Orientation(int v) { value = v; }
}
```
在枚举被添加到Java中之前，这种风格是很普遍的。注意，其构造器是私有的。因此，不可能创建出超出 `Orientation.HORIZONTAL, Orientation.VERTICAL` 之外的对象。特别是，你可以使用 `==` 操作符来测试对象的等同性：
```java
if (orientation == Orientation.HORIZONTAL) ...
```

**当类型安全的枚举实现 `Serialzable` 接口时，你必须牢记存在着一种重要的变化，此时，默认的序列化机制是不适用的**。假设我们写出一个 `Orientation` 类型的值，并再次将其读回：
```java
Orientation original = Orientation.HORIZONTAL;
ObjectOutputStream out = ...;
out.write(original);
out.close();
ObjectInputStream in = ...;
var saved = (Orientation) in.read();
```
现在，下面的测试将失败。事实上，`saved` 的值是 `Orientation` 类型的一个全新的对象，它与任何预定义的常量都不等同。即使构造器是私有的，序列化机制也可以创建新的对象！
```java
if (saved == Orientation.HORIZONTAL) ...
```

**为了解决这个问题，你需要定义另外一种称为 `readResolve` 的特殊序列化方法**。如果定义了 `readResolve` 方法，**在对象被反序列化之后就会调用它** *it is called after the object is deserialized* 。它必须返回一个对象，而该对象之后会成为 `readObject` 的返回值。在上面的情况中，`readResolve` 方法将检查 `value` 域、并返回恰当的枚举常量：
```java
protected Object readResolve() throws ObjectStreamException {
	if (value == 1) return Orientation.HORIZONTAL;
	if (value == 2) return Orientation.VERTICAL;
	throw new ObjectStreamException(); 
		// this shouldn't happen
}
```
请记住，向「遗留代码中所有类型安全的枚举」以及向「所有支持单例设计模式的类」中添加 `readResolve` 方法。

## 14.3.6 版本管理
==如果使用序列化来保存对象，就需要考虑在程序演化时会有什么问题==。例如，1.1版本可以读入旧文件吗？仍旧使用1.0版本的用户可以读入新版本产生的文件吗？显然，==如果对象文件可以处理类的演化问题，那它正是我们想要的==。

乍一看，这好像是不可能的。无论类的定义产生了什么样的变化，它的SHA指纹也会跟着变化，而我们都知道**对象流将拒绝读入具有不同指纹的对象**。但，==类可以表明它对其早期版本保持兼容，要想这样做，就必须首先获得这个类的早期版本的指纹==。我们可以使用JDK中的单机程序 `serialver` 来获得这个数字，例如，运行下面的命令：
```java
serialver Employee
```
将会打印出：
```java
Employee: static final long serialVersionUID = -1814239825517340645L;
```
如果在运行 `serialver` 程序时添加 `-show` 选项，那么这个程序就会产生一个图形化对话框。

**这个类的所有较新的版本，都必须把 `serialVersionUID` 常量定义为与最初版本的指纹相同**。如果一个类具有名为 `serialVersionUID` 的静态数据成员，**它就不需要再人工地计算其指纹，而只需直接使用这个值**。
```java
class Employee implements Serializable { // version 1.1
	...
	public static final long serialVersionUID = -1814239825517340645L;
}
```
==一旦这个静态数据成员被置于某个类的内部，那么序列化系统就可以读入这个类的对象的不同版本==。

在将 `serialVersionUID` 域添加到类中之前，问问自己为什么要让这个类是可序列化的。如果序列化只是用于短期持久化，例如在一个应用服务器中的分布式方法调用，那么就不需要关心版本机制和 `serialVersionUID` 。**如果碰巧要扩展一个可序列化的类，但又从来没想过要持久化该扩展类的任何实例，那么同样不需要关心它们**。如果IDE总是报有关此问题的警告信息，那么可以修改IDE preferences、将它们关闭，或添加 `@SuppressWarnings("serial")` 注解。这样做比添加 `serialVersionUID` 更安全，因为也许后续我们会忘记修改 `serialVersionUID` 。

如果这个类只有方法产生了变化，那么在读入新对象数据时是不会有任何问题的。==但如果数据域产生了变化，那么就可能会有问题==。例如，旧文件对象可能比程序中的对象具有更多或更少的数据域，或者数据域的类型可能有所不同。在这些情况中，==对象输入流将尽力将流对象转换成这个类当前的版本==。

对象输入流会将这个类当前版本的数据域，与流中版本的数据域进行比较，当然，**对象流只会考虑非瞬时和非静态的数据域**。
- 如果这两部分数据域之间名字匹配、而类型不匹配，那么对象流不会尝试将一种类型转换成另一种类型，因为这两个对象不兼容;
- 如果流中的对象具有在当前版本中所没有的数据域，那么对象流会忽略这些额外的数据;
- 如果当前版本具有在流化对象中所没有的数据域，那么这些新添加的域将被设置成它们的默认值（如果是对象则是 `null` ，如果是数字则为0，如果是 `boolean` 值则是 `false` ）。**以当前版本为主**。

下面是一个示例：假设已经用雇员类的最初版本（1.0）、在磁盘上保存了大量的雇员记录，现在我们在 `Employee` 类中添加了称为 `department` 的数据域，从而将其演化到了2.0版本。图14-7展示了将1.0版的对象读入到使用2.0版对象的程序中的情形，可以看到 `department` 域被设置成了 `null` 。图14-8展示了相反的情况：一个使用1.0版对象的程序读入了2.0版的对象，可以看到额外的 `department` 域被忽略。
![图14-7 读入具有较少数据域的对象](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211250856534.png)
![图14-8 读入具有较多数据域的对象](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211250857308.png)

这种处理是安全的吗？视情况而定。丢掉数据域看起来是无害的，因为接收者仍旧拥有它知道该如何处理的所有数据，但将数据域设置为 `null` 却有可能并不那么安全。许多类都费尽心思地在其所有的构造器中、将所有的数据域都初始化为非 `null` 的值，以使得其各个方法都不必去处理 `null` 数据。因此，**这个问题取决于类的设计者「是否能在 `readObject` 方法中实现额外的代码」去订正版本不兼容问题**，或是否能够确保所有的方法在处理 `null` 数据时都足够健壮。

## 14.3.6 为克隆使用序列化
==序列化机制有一种很有趣的用法：即提供了一种克隆对象的简便途径，只要对应的类是可序列化的即可==。其做法很简单：**直接将对象序列化到输出流中，然后将其读回**。这样产生的新对象是对现有对象的一个**深拷贝** *deep copy* 。在此过程中，我们不必将对象写出到文件中，因为可以**用 `ByteArrayOutputStream` 将数据保存到字节数组中**。

正如下面所示，**要想得到 `clone` 方法，只需扩展 `SerialCloneable` 类**，这样就完事了。
```java
// serialClone/SerialCloneTest.java
package serialClone;

import java.io.*;
import java.time.*;

public class SerialCloneTest {
	public static void main(String[] args) throws CloneNotSupportedException {
		var harry = new Employee("Harry Hacker", 35000, 1989, 10, 1);
		// clone harry
		var harry2 = (Employee) harry.clone();
		// mutate harry
		harry.raiseSalary(10);

		// now harry and the clone are different
		System.out.println(harry);
		System.out.println(harry2);
	}
}

/**
 * A class whose clone method uses serialization.
 */
class SerialCloneable implements Cloneable, Serializable {
	public Object clone() throws CloneNotSupportedException {
		try {
			// save the object to a byte array
			var bout = new ByteArrayOutputStream();
			try (var out = new ObjectOutputStream(bout)) { /** key point **/
				out.writeObject(this);
			}

			// read a clone of the object from the byte array
			try (var bin = new ByteArrayInputStream(bout.toByteArray())) {
				var in = new ObjectInputStream(bin);
				return in.readObject();
			} 
		} catch (IOException | ClassNotFoundException e) {
			var e2 = new CloneNotSupportedException();
			e2.initCause(e);
			throw e2;
		}
	}
}

/**
 * The familiar Employee class, redefined to extend the
 * SerialCloneable class.
 */
class Employee extends SerialCloneable {
	private String name;
	private double salary;
	private LocalDate hireDay;

	public Employee(String n, double s, int year, int month, int day) {
		name = n;
		salary = s;
		hireDay = LocalDate.of(year, month, day);
	}

	public String getName() { return name; }
	public double getSalary() { return salary; }
	public LocalDate getHireDay() { return hireDay; }

	/**
	 * Raises the salary of this employee
	 * @param byPercent the percentage of the raise.
	 */
	public void raiseSalary(double byPercent) {
		double raise = salary * byPercent / 100; 
		salary += raise;
	}

	public String toString() {
		return getClass().getName()
			+ "[name=" + name
			+ ",salary=" + salary
			+ ",hireDay=" + hireDay
			+ "]";
	}
}
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212171852239.png)

应当心这个方法，==尽管它很灵巧，但它通常会比显式地构建新对象、并复制或克隆数据域的克隆方法慢得多==。

---
# 14.4 操作文件
已学习了如何从文件中读写数据，然而文件管理的内涵远远比读写要广。**`Path, Paths` 和 `Files` 类封装了「在用户机器上处理文件系统所需的所有功能」**。例如，可以使用 `Files` 类来移除或重命名文件，或查询文件最后被修改的时间。换句话说，==流类关心的是文件的内容，此处讨论的类关心的是在磁盘上如何存储文件==。

**`Path` 和 `Files` 是在Java 7中新添加进来的类，它们用起来比「自JDK 1.0以来就一直使用的 `File` 类」要方便得多**。我们认为这两个类会在Java程序员中流行起来，因此这里做深度讨论。
## 14.4.1 `Path`
`Path`（路径）表示的是一个目录名序列，其后还可以跟着一个文件名。路径中的第一个部件可以是根部件 *root component* ，例如 `/` 或 `C:\` ，而允许访问的根部件取决于文件系统。

**以根部件开始的路径是绝对路径;否则就是相对路径**。例如，我们要分别创建一个绝对路径和一个相对路径;其中，对于绝对路径，假设计算机运行的是类Unix的文件系统：
```java
Path absolute = Paths.get("/home", "harry");
Path relative = Paths.get("myprog", "conf", "user.properties");
```
**静态的 `Paths.get` 方法接受一个或多个字符串，并将它们用默认文件系统的路径分隔符**（类Unix文件系统是 `/` ，Windows是 `\` ）连接起来。**然后它解析连接起来的结果**，如果其表示的不是给定文件系统中的合法路径，那么就抛出 `InvalidPathException` 异常。这个连接起来的结果就是一个 `Path` 对象。

**`get` 方法可以获取「包含多个部件的单个字符串」**，例如，可以像下面这样从配置文件中读取路径：
```java
String baseDir = props.getProperty("base.dir");
	// May be a string such as /opt/myprog or c:\Program Files\myprog
Path basePath = Paths.get(baseDir); 
	// OK that baseDir has separators
```
> 注意：**路径不必对应着某个实际存在的文件**，它只是一个抽象的名字序列。在接下来将要看到，==当你想要创建文件时，首先要创建一个路径，然后才调用方法去创建对应的文件==。

组合或解析 *resolve* 路径是司空见惯的操作，调用 `p.resolve(q)` 将按照下列规则返回一个路径：
- **如果 `q` 是绝对路径，则结果就是 `q`** 。
- 否则，根据文件系统的规则，将“ `p` 后面跟着 `q` ”作为结果。

例如，假设你的应用系统要查找它的「相对于一个给定基目录的工作目录 *working directory* 」，其中基目录是从配置文件中读取的，就像前一个例子一样：
```java
Path workRelative = Paths.get("work");
Path workPath = basePath.resolve(workRelative);
```
**`resolve` 方法有一个快捷方式，它接受一个字符串而不是路径**：
```java
Path workPath = basePath.resolve("work");
```
还有一个很方便的方法 **`resolveSibling` ，它通过解析指定路径的父路径产生其兄弟路径**。例如，如果 `workPath` 是 `/opt/myapp/work` ，那么下面的调用
将创建 `/opt/myapp/temp` 。
```java
Path tempPath = workPath.resolveSibling("temp");
```

`resolve` 的对立面是 `relativize` ，即调用 `p.relativize(r)` 将产生路径 `q` ，对 `q` 进行解析会产生 `r`（？）。例如，以 `"/home/cay"` 为目标对 `"/home/fred/myprog"` 进行相对化操作，会产生 `"../fred/myprog"` ，其中，我们假设 `..` 表示文件系统中的父目录。
```java
p.resolve(q) = r;
p.relative(r) = q;
```

`normalize` 方法将移除所有冗余的 `.` 和 `..` 部件（或者文件系统认为冗余的所有部件）。例如，规范化 `/home/cay/../fred/./myprog` 将产生 `/home/fred/myprog` 。

`toAbsolutePath` 方法将产生给定路径的绝对路径，该绝对路径从根部件开始。

`Path` 类有许多有用的方法，用来将路径断开、以及和其他路径进行组合。下面的代码示例展示了部分最有用的方法：
```java
Path p = Paths.get("/home", "fred", "myprog.properties");
Path parent = p.getParent(); // the path /home/fred
Path file = p.getFileName(); // the path myprog.properties
Path root = p.getRoot(); // the path /
```
> 注意：偶尔可能需要与**遗留系统的API**交互，**它们使用的是 `File` 类而不是 `Path` 类**。`Path` 类有一个 `toFile` 方法，而 `File` 类也有一个 `toPath` 方法。

还可以从 `Path` 对象中构建 `Scanner` 对象：
```java
var in = new Scanner(Paths.get("/home/fred/input.txt"));
```

> [API] `java.nio.file.Paths` 7
> - `static Path get(String first, String... more)`
> 通过连接给定的字符串创建一个路径。

> [API] `java.nio.file.Path 7
> - `Path resolve(Path other)`
> - `Path resolve(String other)`
> 如果 `other` 是绝对路径，那么就返回 `other` ;否则，返回通过连接 `this` 和 `other` 获得的路径。
> - `Path resolveSibling(Path other)`
> - `Path resolveSibling(String other)`
> 如果 `other` 是绝对路径，那么就返回 `other` ;否则，返回通过「连接 `this` 的父路径和 `other` *joining the parent of this and other* 」获得的路径。
> - `Path relativize(Path other)`
> 返回用 `this` 进行解析，相对于 `other` 的相对路径。
> - `Path normalize()`
> 移除诸如 `.` 和 `..` 等冗余的路径元素。
> - `Path toAbsolutePath()`
> 返回与该路径等价的绝对路径。
> - `Path getParent()`
> 返回父路径，或者在该路径没有父路径时，返回 `null` 。
> - `Path getFileName()`
> 返回该路径的最后一个部件，或者在该路径没有任何部件时，返回 `null` 。
> - `Path getRoot()`
> 返回该路径的根部件，或者在该路径没有任何根部件时，返回 `null` 。
> - `toFile()`
> 从该路径中创建一个 `File` 对象。

> [API] `java.io.File` 1.0
> - `Path toPath()` 7
> 从该文件中创建一个 `Path` 对象。

## 14.4.2 读写文件
**`Files` 类可以使普通文件操作变得快捷**。例如，可以用下面的方式很容易地读取文件的所有内容：
```java
byte[] bytes = Files.readAllBytes(path);
```
如果想**将文件当作字符串读入**，那么可以在调用 `readAllBytes` 之后执行下面的代码：
```java
var content = new String(bytes, charset);
```
但如果希望**将文件当作行序列读入**，那么可以调用：
```java
List<String> lines = Files.readAllLines(path, charset);
```
相反地，如果希望**写出一个字符串到文件中**，可以调用：
```java
Files.write(path, content.getBytes(charset));
```
向指定文件追加内容，可以调用：
```java
Files.write(path, content.getBytes(charset), StandardOpenOption.APPEND);
```
还可以用下面的语句，将一个行的集合 *collection* 写出到文件中：
```java
Files.write(path, lines);
```
==这些简便方法适用于处理中等长度的**文本文件**，如果要处理的文件长度比较大、或是二进制文件，那么还是应使用所熟知的流或者读入器/写出器==：
```java
InputStream in = Files.newInputStream(path);
OutputStream out = Files.newOutputStream(path);
Reader in = Files.newBufferedReader(path, charset);
Writer out = Files.newBufferedWriter(path, charset);
```
这些便捷方法可将你从处理 `FileInputStream, FileOutputStream, BufferedReader, BufferedWriter` 的繁复操作中解脱出来（？）。

> [API] `java.nio.file.Files` 7
> - `static byte[] readAllBytes(Path path)`
> - `static ListreadAllLines(Path path, Charset charset)`
> 读入文件的内容。
> - `static Path write(Path path, byte[] contents, OpenOption... options)`
> - `static Path write(Path path, String contents, Charset charset, OpenOption... options)`
> - `static Path write(Path path, Iterable<? extends CharSequence> contents, OpenOption options)`
> 将给定内容写出到文件中，并返回 `path` 。
> - `static InputStream newInputStream(Path path, OpenOption... options)`
> - `static OutputStream newOutputStream(Path path, OpenOption... options)`
> - `static BufferedReader newBufferedReader(Path path, Charset charset)`
> - `static BufferedWriter newBufferedWriter(Path path, Charset charset, OpenOption... options)`
> 打开一个文件，用于读入或写出。

## 14.4.3 创建文件和目录
创建新目录可以调用以下语句，==其中，路径中除最后一个部件外，其他部分都必须是已存在的==：
```java
Files.createDirectory(path);
```
要创建路径中的中间目录，应该使用：
```java
Files.createDirectories(path);
```
可以使用下面的语句创建一个空文件：
```java
Files.createFile(path);
```
如果文件已经存在了，那么这个调用就会抛出异常。==检查文件是否存在和创建文件是原子性的，如果文件不存在，该文件就会被创建，且其他程序在此过程中、是无法执行文件创建操作的==。

有些便捷方法可以用来在给定位置或者系统指定位置，**创建临时文件或临时目录**：
```java
Path newPath = Files.createTempFile(dir, prefix, suffix);
Path newPath = Files.createTempFile(prefix, suffix);
Path newPath = Files.createTempDirectory(dir, prefix);
Path newPath = Files.createTempDirectory(prefix);
```
其中，`dir` 是一个 `Path` 对象，`prefix, suffix` 是可以为 `null` 的字符串。例如，调用 `Files.createTempFile(null, ".txt")` 可能会返回一个像 `/tmp/1234405522364837194.txt` 这样的路径。

在创建文件或目录时，可以指定属性，例如文件的拥有者和权限。但指定属性的细节取决于文件系统，在此不做讨论。
> [API] `java.nio.file.Files` 7
> - `static Path createFile(Path path, FileAttribute<?>... attrs)`
> - `static Path createDirectory(Path path, FileAttribute<?>... attrs)`
> - `static Path createDirectories(Path path, FileAttribute<?>... attrs)`
> 创建一个文件或目录，`createDirectories` 方法还会创建路径中所有的中间目录。
> - `static Path createTempFile(String prefix, String suffix, FileAttribute<?>... attrs)`
> - `static Path createTempFile(Path parentDir, String prefix, String suffix, FileAttribute<?>... attrs)`
> - `static Path createTempDirectory(String prefix, FileAttribute<?>... attrs)`
> - `static Path createTempDirectory(Path parentDir, String prefix, FileAttribute<?>... attrs)`
> 在适合临时文件的位置，或在给定的父目录中，创建一个临时文件或目录。返回所创建的文件或目录的路径。

## 14.4.4 复制、移动和删除文件
**将文件从一个位置复制到另一个位置**，可以直接调用：
```java
Files.copy(fromPath, toPath);
```
**移动文件**（即复制并删除原文件）可以调用：
```java
Files.move(fromPath, toPath);
```
如果目标路径已存在，那么复制或移动将失败。如果想覆盖已有的目标路径，可以使用 `REPLACE_EXISTING` 选项。如果想复制所有的文件属性，可以使用 `COPY_ATTRIBUTES` 选项。也可以像下面这样、同时选择这两个选项：
```java
Files.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING,
	StandardCopyOption.COPY_ATTRIBUTES);
```

你**可以将移动操作定义为原子性的**，这样就可以保证要么移动操作成功完成，要么源文件继续保持在原来位置。具体可以使用 `ATOMIC_MOVE` 选项来实现：
```java
Files.move(fromPath, toPath, StandardCopyOption.ATOMIC_MOVE);
```

还可以将一个输入流复制到 `Path` 中，这表示**想要将该输入流存储到硬盘上**。类似地，可以将一个 `Path` 复制到输出流中。可以使用下面的调用：
```java
Files.copy(inputStream, toPath);
Files.copy(fromPath, outputStream);
```
至于其他对 `copy` 的调用，可以根据需要提供相应的复制选项。

最后，删除文件可以调用：
```java
Files.delete(path);
```
**如果要删除的文件不存在，这个方法就会抛出异常**。因此，可转而使用下面的方法，**该删除方法还可以用来移除空目录**：
```java
boolean deleted = Files.deleteIfExists(path);
```
表14-3了解对文件操作而言可用的选项：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211260129706.png)

> [API] `java.nio.file.Files` 7
> - `static Path copy(Path from, Path to, CopyOption... options)`
> - `static Path move(Path from, Path to, CopyOption... options)`
> 将 `from` 复制或移动到给定位置，并返回 `to` 。
> - `static long copy(InputStream from, Path to, CopyOption... options)`
> - `static long copy(Path from, OutputStream to, CopyOption... options)`
> 从输入流复制到文件中，或者从文件复制到输出流中，返回复制的字节数。
> - `static void delete(Path path)`
> - `static boolean deleteIfExists(Path path)`
> 删除给定文件或空目录。第一个方法在文件或目录不存在情况下抛出异常，而第二个方法在这种情况下会返回`false` 。

## 14.4.5 获取文件信息
下面的静态方法都将返回一个 `boolean` 值，表示检查路径的某个属性的结果：
- `exists`
- `isHidden`
- `isReadable, isWritable, isExecutable`
- `isRegularFile, isDirectory, IsSymbolicLink`

`size` 方法将返回文件的字节数：
```java
long fileSize = Files.size(path);
```
`getOwner` 方法将文件的拥有者作为 `java.nio.file.attribute.UserPrincipal` 的一个实例返回。

**所有的文件系统都会报告一个基本属性集，它们被封装在 `BasicFileAttributes` 接口中**，这些属性与上述信息有部分重叠。基本文件属性包括：
- 创建文件、最后一次访问以及最后一次修改文件的时间，这些时间都表示成 `java.nio.file.attribute.FileTime` 。
- ==文件是常规文件、目录还是符号链接，抑或这三者都不是==。
- 文件尺寸。
- 文件主键，这是某种类的对象，具体所属类与文件系统相关，有可能是文件的唯一标识符，也可能不是。

要获取这些属性，可以调用：
```java
BasicFileAttributes attributes = Files.readAttributes(path, BasicFileAttributes.class);
```
如果了解到用户的文件系统兼容POSIX，那么可以获取一个 `PosixFileAttributes` 实例：
```java
PosixFileAttributes attributes = Files.readAttributes(path, PosixFileAttributes.class);
```
然后从中找到组拥有者、拥有者、组，以及访问权限。不详细讨论其细节，因为==这种信息中很多内容在操作系统之间并不具备可移植性==。

> [API] `java.nio.file.Files` 7
> - `static boolean exists(Path path)`
> - `static boolean isHidden(Path path)`
> - `static boolean isReadable(Path path)`
> - `static boolean isWriter(Path path)`
> - `static boolean isExecutable(Path path)`
> - `static boolean isRegularFile(Path path)`
> - `static boolean isDirectory(Path path)`
> - `static boolean isSymbolicLink(Path path)`
> 检查由路径指定的文件的给定属性。
> - `static long size(Path path)`
> 获取文件按字节数度量的尺寸。
> `A readAttributes（Path path, Class<A>type, LinkOption... options)`
> 读取类型为 `A` 的文件属性。

> [API] `java.nio.file.attribute.BasicFileAttributes` 7
> - `FileTime creationTime()`
> - `FileTime lastAccessTime()`
> - `FileTime lastModifiedTime()`
> - `boolean isRegularFile()`
> - `boolean isDirectory()`
> - `boolean isSymoblicLink()`
·> - `ong size()`
> - `Object fileKey()`
> 获取所请求的属性。

## 14.4.6 迭代目录中的文件
旧的 `File` 类有一个方法，可用来获取由一个目录中的所有文件构成的数组，但当目录中包含大量的文件时，这个方法的性能会非常低。

正由于此，`Files` 类设计了一个静态方法 `Files.list` ，它可以产生一个 `Stream<Path>` 对象、读取目录中各个项。==目录是被惰性读取的，这使得处理具有大量项的目录可以变得很高效==。因为读取目录，涉及到需要关闭的系统资源，所以应使用 `try` 语句块：
```java
try (Stream<Path> entries = Files.list(pathToDirectory)) {
	// ...
}
```
**`list` 方法不会进入子目录，为了处理目录中的所有子目录，需要使用 `Files.walk` 方法**：
```java
try (Stream<Path> entries = Files.walk(pathToRoot)) {
	// Contains all descendants, visited in depth-first order
}
```
下面是解压后的 `src.zip` 树的遍历样例：
```java
java
java/nio
java/nio/DirectCharBufferU.java
java/nio/ByteBufferAsShortBufferRL.java
java/nio/MappedByteBuffer.java
...
java/nio/ByteBufferAsDoubleBufferB.java
java/nio/charset
java/nio/charset/CoderMalfunctionError.java
java/nio/charset/CharsetDecoder.java
java/nio/charset/UnsupportedCharsetException.java
java/nio/charset/spi
java/nio/charset/spi/CharsetProvider.java
java/nio/charset/StandardCharsets.java
java/nio/charset/Charset.java
...
java/nio/charset/CoderResult.java
java/nio/HeapFloatBufferR.java
...
```
正如所见，无论何时只要遍历的项是目录，那么在继续访问它的兄弟项之前，会先进入它。

**可以通过调用 `Files.walk(pathToRoot, depth)` 来限制想要访问的树的深度**。两种 `walk` 方法都具有 `FileVisitOption...` 的可变长参数，但你只能提供一种选项—— `FOLLOW_LINKS` ，即跟踪符号链接。

如果要过滤 `walk` 返回的路径，且过滤标准涉及与目录存储关的文件属性，例如大小、创建时间和类型（文件、目录或符号链接），那么应使用 `find` 方法来替代 `walk` 方法。可以用某个谓词函数来调用这个方法，该谓词函数接受一个路径和一个 `BasicFileAttributes` 对象。这样做唯一的优势就是效率高。因为路径总是会被读入，所以这些属性很容易获取。

下面的代码，使用了 `Files.walk` 方法来将一个目录复制到另一个目录：
```java
Files.walk(source).forEach(p -> {
	try {
		Path q = target.resolve(source.relativize(p));
		if (Files.isDirectory(p))
			Files.createDirectory(q);
		else
			Files.copy(p, q);
		} catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
);
```
遗憾的是，无法很容易地使用 `Files.walk` 方法来删除目录树，因为你必须在删除父目录之前、先删除子目录。下一节展示如何克服此问题。

## 14.4.7 使用目录流
正如前一节看到的，`Files.walk` 方法会产生一个可以遍历目录中所有子孙的 `Stream<Path>` 对象。有时，**需要对遍历过程进行更细粒度的控制。在这种情况下，应使用 `Files.newDirectoryStream` 对象，它会产生一个 `DirectoryStream`** 。注意，它不是 `java.util.stream.Stream` 的子接口，而是专门用于目录遍历的接口。它**是 `Iterable` 的子接口**，因此可以在增强的for循环中使用目录流。下面是其使用模式：
```java
try (DirectoryStream<Path> entries = Files.newDirectoryStream(dir)) {
	for (Path entry : entries)
		Process entries
}
```
带资源的 `try` 语句块，用来确保目录流可以被正确关闭，访问目录中的项并没有具体顺序。

可以用 `glob` 模式来过滤文件：
```java
try (DirectoryStream<Path> entries = Files.newDirectoryStream(dir, "*.java"))
```
表14-4展示了所有的 `glob` 模式。
![表14-4 Glob模式](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211261145437.png)
> 警告：**如果使用Windows的 `glob` 语法，则必须对反斜杠转义两次——一次为 `glob` 语法转义，一次为Java字符串转义**。例如 `Files.newDirectoryStream(dir, "C:\\\\")` 。

**如果想要访问某个目录的所有子孙成员，可以转而调用 `walkFileTree` 方法，并向其传递一个 `FileVisitor` 类型的对象**，这个对象会得到下列通知：
- 在遇到一个文件或目录时：`FileVisitResult visitFile(T path, BasicFileAttributes attrs)`
- 在一个目录被处理前：`FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)`
- 在一个目录被处理后：`FileVisitResult postVisitDirectory(T dir, BasicFileAttributes attrs)`
- 在试图访问文件或目录时发生错误，例如没有权限打开目录：`FileVisitResult visitFileFailed(path, IOException)` 

对于上述每种情况，都可以指定是否希望执行下面的操作：
- 继续访问下一个文件：`FileVisitResult.CONTINUE` ;
- 继续访问，但不再访问这个目录下的任何项了：`FileVisitResult.SKIP_SUBTREE`
- 继续访问，但不再访问这个文件的兄弟文件（和该文件在同一个目录下的文件）了：`FileVisitResult.SKIP_SIBLINGS`
- 终止访问：`FileVisitResult.TERMINATE`

当有任何方法抛出异常时，就会终止访问，而这个异常会从 `walkFileTree` 方法中抛出。
> 注意：**`FileVisitor` 接口是泛化类型**，但你不太可能会使用除 `FileVisitor<Path>` 之外的东西。`walkFileTree` 方法可以接受 `FileVisitor<? Super Path>` 类型的参数，但 `Path` 并没有多少超类型。

便捷类 `SimpleFileVisitor` 实现了 `FileVisitor` 接口，但其除 `visitFileFailed` 方法之外的所有方法、并不做任何处理而是直接继续访问，而 `visitFileFailed` 方法会抛出由失败导致的异常，并进而终止访问。

例如，下面代码展示了如何打印出给定目录下的所有子目录：
```java
Files.walkFileTree(Paths.get("/"), new SimpleFileVisitor<Path>() {
	public FileVisitResult preVisitDirectory(Path path, BasicFileAttributes attrs) throws IOException {
		System.out.println(path);
		return FileVisitResult.CONTINUE;
	}
	
	public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
		return FileVisitResult.CONTINUE;
	}
	
	public FileVisitResult visitFileFailed(Path path, IOException exc) throws IOException {
		return FileVisitResult.SKIP_SUBTREE;
	}
});
```
值得注意的是，**我们要覆盖 `postVisitDirectory, visitFileFailed` 方法，否则，访问会在遇到「不允许打开的目录」或「不允许访问的文件」时立即失败**。

还应注意的是，路径的众多属性是作为 `preVisitDirectory` 和 `visitFile` 方法的参数传递的。访问者 *visitor* 已经不得不通过操作系统调用来获得这些属性，因为它需要区分文件和目录。因此，你就不需要再次执行系统调用了（？）。

如果你需要在进入或离开一个目录时执行某些操作，那么 `FileVisitor` 接口的其他方法就显得非常有用了。例如，在创建目录树的副本时，必须先创建当前目录的副本，然后再向该副本中添加文件的副本。在删除目录树时，需要在移除当前目录的所有文件之后，才能移除该目录。下边是删除目录树的完整代码：
```java
// Delete the directory tree starting at root
Files.walkFileTree(root, new SimpleFileVisitor<Path>() {
	public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
		Files.delete(file);
		return FileVisitResult.CONTINUE;
	}
	
	public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {
		if (e != null) throw e;
			Files.delete(dir);
		return FileVisitResult.CONTINUE;
	}
});
```

> [API] `java.nio.File.Files` 7
> - `static DirectoryStream<Path> newDirectoryStream(Path path)`
> - `static DirectoryStream<Path> newDirectoryStream(Path path, String glob)`
> 获取给定目录中可以遍历所有文件和目录的迭代器。第二个方法只接受那些与给定的 `glob` 模式匹配的项。
> - `static Path walkFileTree(Path start, FileVisitor<? Super Path> visitor)`
> 遍历给定路径的所有子孙，并将访问器应用于这些子孙之上。

> [API] `java.nio.file.SimpleFileVisitor<T>` 7
> - `FileVisitResult visitFile(T path, BasicFileAttributes attrs)`
> 在访问文件或目录时被调用，返回 `CONTINUE, SKIP_SUBTREE, SKIP_SIBLINGS, TERMINATE` 之一，默认实现是不做任何操作而继续访问。
> - `FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)`
> - `FileVisitResult postVisitDirectory(T dir, BasicFileAttributes attrs)`
> 在访问目录之前和之后被调用，默认实现是不做任何操作而继续访问。
> - `FileVisitResult visitFileFailed(T path, IOException exc)`
> 如果在试图获取给定文件的信息时抛出异常，则该方法被调用。默认实现是重新抛出异常，这会导致访问操作以这个异常而终止。如果你想自己访问，可以覆盖这个方法。

## 14.4.8 ZIP文件系统
`Paths` 类会在默认文件系统中查找路径，即在用户本地磁盘中的文件。**你也可以有别的文件系统，其中最有用的之一是ZIP文件系统**。如果 `zipname` 是某个ZIP文件的名字，那么下面的调用将建立一个文件系统，它包含ZIP文档中的所有文件：
```java
FileSystem fs = FileSystems.newFileSystem(Paths.get(zipname), null);c
```
如果知道文件名，那么从ZIP文档中复制出这个文件就会变得很容易：
```java
Files.copy(fs.getPath(sourceName), targetPath);
```
其中，**`fs.getPath` 对于任意文件系统来说，都与 `Paths.get` 类似**。

要列出ZIP文档中的所有文件，可以遍历文件树：
```java
FileSystem fs = FileSystems.newFileSystem(Paths.get(zipname), null);
Files.walkFileTree(fs.getPath("/"), new SimpleFileVisitor<Path>() {
	public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
		System.out.println(file);
		return FileVisitResult.CONTINUE;
	}
});
```
> 注意：**此处在编译 `ZipTest.java` 时报错**：`FileSystems` 中的方法 
 `newFileSystem(Path,ClassLoader)` 和 `FileSystems` 中的方法 `newFileSystem(Path,Map<String,?>)` 都匹配。应改为：`newFileSystem(Paths.get(zipname), ClassLoader.getSystemClassLoader());` 。
>
>  `newFileSystem(Path, Map<String, ?>)` 方法是在现有 `newFileSystem(Path, ClassLoader)` 方法基础上，对参数`classLoader` 作 `null` 处理的调用。因此需要避免上述使用。

这比14.2.3小节“ZIP文档”中描述的API要好用，后者使用的是多个专门处理ZIP文档的新类（ `ZipInputStream, ZipOutputStream` ）。
```java
// zip/ZipTest.java
package zip;

import java.io.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.util.*;
import java.util.zip.*;

public class ZipTest {
	public static void main(String[] args) throws IOException {
		String zipname = args[0];
		showContents(zipname);
		System.out.println("---");
		showContents2(zipname);
	}
   
	public static void showContents(String zipname) throws IOException {
		// Here, we use the classic zip API
		try (var zin = new ZipInputStream(new FileInputStream(zipname))) {
			ZipEntry entry;
			while ((entry = zin.getNextEntry()) != null) {
				System.out.println(entry.getName());            
				var in = new Scanner(zin, StandardCharsets.UTF_8);
				while (in.hasNextLine())
					System.out.println("   " + in.nextLine());
				// DO NOT CLOSE in            
				zin.closeEntry();
			}
		}
	}
   
	public static void showContents2(String zipname) throws IOException {
		FileSystem fs = FileSystems.newFileSystem(Paths.get(zipname), ClassLoader.getSystemClassLoader());
		Files.walkFileTree(fs.getPath("/"), new SimpleFileVisitor<Path>() {
			public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) 
                  throws IOException {               
				System.out.println(path);
				for (String line : Files.readAllLines(path, Charset.forName("UTF-8")))
					System.out.println("   " + line);
				return FileVisitResult.CONTINUE;
			}
		});
	}
}
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212171809246.png)

> [API] `java.nio.file.FileSystems` 7
> - `static FileSystem newFileSystem(Path path, ClassLoader loader)`
> 对被安装的文件系统提供者进行迭代 *iterates over the installed file system providers* ，并且如果 `loader` 不为 `null` ，那么就还会迭代「给定的类加载器能加载的文件系统」，返回由「接受给定路径的第一个文件系统提供者」创建的文件系统。默认情况下，ZIP文件系统是有一个提供者，它接受名字以 `.zip` 或 `.jar` 结尾的文件。

> [API] `java.nio.file.FileSystem` 7
> - `static Path getPath(String first, String... more)`
> 将给定的字符串连接起来创建一个路径.

---
# 14.5 内存映射文件
==大多数操作系统都可以利用虚拟内存实现、来将一个文件或者文件的一部分“映射”到内存中。然后，这个文件就可以被当作是内存数组 *in-memory array* 一样地访问==，这比传统的文件操作要快得多。
## 14.5.1 内存映射文件的性能
在本节的末尾，可以发现一个计算传统的文件输入和内存映射文件的CRC32校验和的程序。在同一台机器上，我们对JDK的 `jre/lib` 目录中的37MB的 `rt.jar` 文件，用不同的方式来计算校验和，记录下来的时间数据如表14-5所示。
![表14-5 文件操作的处理时间数据](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211261250225.png)

如你所见，在这台特定的机器上，内存映射比使用带缓冲的顺序输入要稍微快一点，但比使用 `RandomAccessFile` 快很多。

当然，精确的值因机器不同会产生很大的差异，但很明显，与随机访问相比，性能提高总是很显著的。另一方面，**对于中等尺寸文件的顺序读入则没有必要使用内存映射**。

`java.nio` 包使内存映射变得十分简单，下面是我们要做的。首先，==从文件中获得一个通道 *channel* ，通道是用于磁盘文件的一种抽象，它使我们可以访问诸如内存映射、文件加锁机制、以及文件间快速数据传递== *memory mapping, file locking, and fast data transfers between files* 等操作系统特性。
```java
FileChannel channel = FileChannel.open(path, options);
```
然后，**通过调用 `FileChannel` 类的 `map` 方法，从这个通道中获得一个 `ByteBuffer`** 。可以指定「想要映射的文件区域」与映射模式，支持的模式有三种：
- `FileChannel.MapMode.READ_ONLY` ：所产生的缓冲区是只读的，任何对该缓冲区写入的尝试都会导致 `ReadOnlyBufferException` 异常。
- `FileChannel.MapMode.READ_WRITE` ：所产生的缓冲区是可写的，任何修改都会在某个时刻写回到文件中。注意，==其他映射同一个文件的程序可能不能立即看到这些修改，多个程序同时进行文件映射的确切行为是依赖于操作系统的==。
- `FileChannel.MapMode.PRIVATE` ：所产生的缓冲区是可写的，但任何修改对这个缓冲区来说都是私有的，不会传播到文件中。

**一旦有了缓冲区，就可以使用 `ByteBuffer` 类和 `Buffer` 超类的方法读写数据了**。

缓冲区支持顺序和随机数据访问，它有一个可以通过 `get` 和 `put` 操作来移动的**位置** *position* 。例如，可以像下面这样顺序遍历缓冲区中的所有字节：
```java
while (buffer.hasRemaining()) {
	byte b = buffer.get();
	...
}
```
或，像下面这样进行随机访问：
```java
for (int i = 0; i < buffer.limit(); i++) {
	byte b = buffer.get(i);
	...
}
```
可以用下面的方法来读写字节数组：
```java
get(byte[] bytes)
get(byte[], int offset, int length)
```
最后，**还有下面的方法，用来读入在文件中存储为二进制值的基本类型值**：
```java
getInt getLong getShort
getChar getFloat getDouble
```
正如提到的，**Java对二进制数据使用高位在前的排序机制**，但，如果需要以低位在前的排序方式处理包含二进制数字的文件，那么只需调用：
```java
buffer.order(ByteOrder.LITTLE_ENDIAN);
```
要查询缓冲区内当前的字节顺序，可以调用：
```java
ByteOrder b = buffer.order();
```
> 警告：这一对方法没有使用 `set/get` 命名惯例。

要向缓冲区写数字，可以使用下列的方法：
```java
putInt putLong putShort
putChar putFloat putDouble
```
**在恰当的时机，以及当通道关闭时，会将这些修改写回到文件中**。

`memoryMap/MemoryMapTest.java` 用于计算文件的32位的循环冗余校验和（CRC32），这个数值经常用来判断一个文件是否已损坏的校验和，因为文件损坏极有可能导致校验和改变。**`java.util.zip` 包中包含一个CRC32类，可以使用下面的循环来计算一个字节序列的校验和**：
```java
var crc = new CRC32();
while (more bytes)
	crc.update(next byte);
long checksum = crc.getValue();
```
注意：对CRC算法有一个很精细的[解释](http://www.relisoft.com/Science/CrcMath.html)。CRC计算的细节并不重要，这里只将它作为一个有用的文件操作实例来使用。==在实践中，每次会以更大的块而不是一个字节为单位、来读取和更新数据，而它们的速度差异并不明显==。

应像下面这样运行程序：
```java
java memoryMap.MemoryMapTest filename
```
```java
// memoryMap/MemoryMapTest.java
package memoryMap;

import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.util.zip.*;

/**
 * This program computes the CRC checksum of a file in four ways. <br>
 * Usage: java memoryMap.MemoryMapTest filename
 */
public class MemoryMapTest {
	public static long checksumInputStream(Path filename) throws IOException {
		try (InputStream in = Files.newInputStream(filename)) {
			var crc = new CRC32();
			int c;
			while ((c = in.read()) != -1)
				crc.update(c);
			return crc.getValue();
		}
	}

	public static long checksumBufferedInputStream(Path filename) throws IOException {
		try (var in = new BufferedInputStream(Files.newInputStream(filename))) {
			var crc = new CRC32();
			int c;
			while ((c = in.read()) != -1)
				crc.update(c);
			return crc.getValue();
		}
	}

	public static long checksumRandomAccessFile(Path filename) throws IOException {
		try (var file = new RandomAccessFile(filename.toFile(), "r")) {
			long length = file.length();
			var crc = new CRC32();
			for (long p = 0; p < length; ++p) {
				file.seek(p);
				int c = file.readByte();
				crc.update(c);
			}	
			return crc.getValue();
		}
	}

	public static long checksumMapppedFile(Path filename) throws IOException {
		try (FileChannel channel = FileChannel.open(filename)) {
			var crc = new CRC32();
			int length = (int) channel.size();
			MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, length);

			for (int p = 0; p < length; ++p) {
				int c = buffer.get(p);
				crc.update(c);
			}
			return crc.getValue();
		}
	}

	public static void main(String[] args) throws IOException {
		Path filename = Paths.get(args[0]);
		
		System.out.println("Input Stream: ");
		long start = System.currentTimeMillis();
		long crcValue = checksumInputStream(filename);
		long end = System.currentTimeMillis();	
		System.out.println(Long.toHexString(crcValue));
		System.out.println((end - start) + " milliseconds");

		System.out.println("Buffered Input Stream: ");
		start = System.currentTimeMillis();
		crcValue = checksumBufferedInputStream(filename);
		end = System.currentTimeMillis();
		System.out.println(Long.toHexString(crcValue));
		System.out.println((end - start) + " milliseconds");

		System.out.println("Random Access File: ");
		start = System.currentTimeMillis();
		crcValue = checksumRandomAccessFile(filename);
		end = System.currentTimeMillis();
		System.out.println(Long.toHexString(crcValue));
		System.out.println((end - start) + " milliseconds");

		System.out.println("Mapped File: ");
		start = System.currentTimeMillis();
		crcValue = checksumMapppedFile(filename);
		end = System.currentTimeMillis();
		System.out.println(Long.toHexString(crcValue));
		System.out.println((end - start) + " milliseconds");
	}
}
```
运行如下命令：
```bash
$ javac memoryMap/*.java
$ java memoryMap.MemoryMapTest memoryMap/MemoryMapTest.java
```
结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212171941592.png)

> [API] `java.io.FileInputStream` 1.0
> - `FileChannel getChannel()` 1.4
> 返回用于访问这个流的通道。

> [API] `java.io.FileOutputStream` 1.0
> - `FileChannel getChannel()` 1.4
> 返回用于访问这个流的通道。

> [API] `java.io.RandomAccessFile` 1.0
> - `FileChannel getChannel()` 1.4
> 返回用于访问这个流的通道。

> [API] `java.nio.channels.FileChannel` 1.4
> - `static FileChannel open(Path path, OpenOption... optioins)` 7
> 打开指定路径的文件通道，默认情况下，通道打开时用于读入。参数 `optioins` 是 `StandardOpenOption` 枚举中的 `WRITE, APPEND, TRUNCATE_EXISTING, CREATE` 值。
> - `MappedByteBuffer map(FileChannel.MapMode mode, long position, long size)`
> 将文件的一个区域映射到内存中。参数 `mode` 是 `FileChannel.MapMode` 类中的常量 `READ_ONLY, READ_WRITE, PRIVATE` 之一。

> [API] `java.nio.Buffer` 1.4
> - `boolean hasRemaining()`
> 如果当前的缓冲区位置没有到达这个缓冲区的界限位置，则返回 `true` 。
> - `int limit()`
> 返回这个缓冲区的界限位置，即没有任何值可用的第一个位置。

> [API] `java.nio.ByteBuffer` 1.4
> - `byte get()`
> 从当前位置获得一个字节，并将当前位置移动到下一个字节。
> - `byte get(int index)`
> 从指定索引处获得一个字节。
> - `ByteBuffer put(byte b)
> 向当前位置推入一个字节，并将当前位置移动到下一个字节。返回对这个缓冲区的引用。
> - `ByteBuffer put(int index, byte b)`
> 向指定索引处推入一个字节。返回对这个缓冲区的引用。
> - `ByteBuffer get(byte[] destination)`
> - `ByteBuffer get(byte[] destination, int offset, int length)`
> 用缓冲区中的字节来填充字节数组，或者字节数组的某个区域，并将当前位置向前移动读入的字节数个位置。如果缓冲区不够大，那么就不会读入任何字节，并抛出 `BufferUnderflowException` 。返回对这个缓冲区的引用。
> - `ByteBuffer put(byte[] source)`
> - `ByteBuffer put(byte[] source, int offset, int length)`
> 将字节数组中的所有字节或者给定区域的字节、都推入缓冲区中，并将当前位置向前移动写出的字节数个位置。如果缓冲区不够大，那么就不会读入任何字节，并抛出 `BufferUnderflowException` 。返回对这个缓冲区的引用。
> - `Xxx getXxx()`
> - `Xxx getXxx(int index)`
> - `ByteBuffer putXxx(xxx value)`
> - `ByteBuffer putXxx(int index, xxx value)`
> 获得或放置一个二进制数。`Xxx` 是 `Int, Long, Short, Char, Float, Double` 中的一个。
> - `ByteBuffer order(ByteOrder order)`
> - `ByteOrder order()`
> 设置或获得字节顺序，`order` 的值是 `ByteOrder` 类的常量 `BIG_ENDIAN` 或 `LITTLE_ENDIAN` 中的一个。
> - `static ByteBuffer allocate(int capacity)`
> 构建具有给定容量的缓冲区。
> - `static ByteBuffer wrap(byte[] values)`
> 构建具有指定容量的缓冲区，该缓冲区是对给定数组的包装。
> - `CharBuffer asCharBuffer()`
> **构建字符缓冲区**，它是对这个缓冲区的包装。对该字符缓冲区的变更将在这个缓冲区中反映出来 *Changes to the character buffer will show up in this buffer* ，但该字符缓冲区有自己的位置、界限和标记。

> [API] `java.nio.CharBuffer` 1.4
> - `char get()`
> - `CharBuffer get(char[] destination)`
> - `CharBuffer get(char[] destination, int offset, int length)`
> 从这个缓冲区的当前位置开始，获取一个 `char` 值，或一个范围内的所有 `char` 值，然后将位置向前移动、越过所有读入的字符。最后两个方法将返回 `this` 。
> - `CharBuffer put(char c)`
> - `CharBuffer put(char[] source)`
> - `CharBuffer put(char[] source, int offset, int length)`
> - `CharBuffer put(String source)`
> - `CharBuffer put(CharBuffer source)`
> 从这个缓冲区的当前位置开始，放置一个 `char` 值，或者一个范围内的所有 `char` 值，然后将位置向前移动、越过所有被写出的字符。当放置的值是从 `CharBuffer` 读入时，将读入所有剩余字符。所有方法将返回 `this` 。

## 1.7.1 缓冲区数据结构
在使用内存映射时，我们创建了单一的缓冲区横跨整个文件或我们感兴趣的文件区域。我们**还可以使用更多的缓冲区、来读写大小适度的信息块**。

本节简介 `Buffer` 对象上的基本操作。**缓冲区是由相同类型的数值构成的数组** *A buffer is an array of values of the same type* ，`Buffer` 类是一个抽象类，它有众多的具体子类，包括 `ByteBuffer, CharBuffer, DoubleBuffer, IntBuffer, LongBuffer, ShortBuffer` 。
> 注意：`StringBuffer` 类与这些缓冲区没有关系。

在实践中，最常用的将是 `ByteBuffer` 和 `CharBuffer` 。如图14-9所示，每个缓冲区都具有：
- 一个容量 *capacity* ，它永远不能改变。
- 一个读写位置 *position* ，下一个值将在此进行读写。
- 一个界限 *limit* ，超过它进行读写是没有意义的。
- 一个可选的标记 *optional mark* ，用于重复一个读入或写出操作。

这些值满足**0≤标记≤位置≤界限≤容量**。==使用缓冲区的主要目的是执行“写，然后读入”循环==。假设我们有一个缓冲区，在一开始，它的位置为0，界限等于容量。我们不断地调用 `put` 将值添加到这个缓冲区中，==当我们耗尽所有的数据（不一定到了界限）、或写出的数据量达到容量大小 *reach the capacity* 时，就该切换到读入操作了==。
![图14-9　一个缓冲区](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211261744458.png)
**这时，调用 `flip` 方法将界限设置到当前位置，并把位置复位到0**。现在在 `remaining` 方法返回正数时（它返回的值是“界限-位置”），不断地调用 `get` 。在我们将缓冲区中所有的值都读入之后，调用 `clear` 使缓冲区为下一次写循环做好准备。 `clear` 方法将位置复位到0，并将界限复位到容量。

**如果你想重读缓冲区，可以使用 `rewind, mark/reset` 方法**，详细内容请查看API注释。

要获取缓冲区，可以调用诸如 `ByteBuffer.allocate` 或 `ByteBuffer.wrap` 这样的静态方法。然后，**可以用来自某个通道的数据填充缓冲区，或者将缓冲区的内容写出通道中**。例如：
```java
ByteBuffer buffer = ByteBuffer.allocate(RECORD_SIZE);
channel.read(buffer);
channel.position(newpos);
buffer.flip();
channel.write(buffer);
```
这是一种非常有用的方法，可以替代随机访问文件。
> [API] `java.nio.Buffer` 1.4
> - `Buffer clear()`
> 通过将位置复位到0，并将界限设置到容量，**使这个缓冲区为写做好准备**。返回 `this` 。
> - `Buffer flip()`
> 通过将界限设置到位置，并将位置复位到0，**使这个缓冲区为写后的读做好准备** *prepares this buffer for reading after writing* 。返回 `this` 。
> - `Buffer rewind()`
> 通过将读写位置复位到0，并保持界限不变，**使这个缓冲区为重读相同的值做好准备**。返回 `this` 。
> - `Buffer mark()`
> **将这个缓冲区的标记设置到读写位置**，返回 `this` 。
> - `Buffer reset()`
> **将这个缓冲区的位置设置到标记**，从而**允许被标记的部分可以再次被读入或写出**，返回 `this` 。
> - `int remaining()`
> 返回剩余可读入或可写出的值的数量，即界限与位置之间的差异。
> - `int position()`
> - `void position(int newValue)`
> 返回这个缓冲区的位置。
> - `int capacity()`
> 返回这个缓冲区的容量。

---
## 14.6 文件加锁机制
==考虑下「多个同时执行的程序需要修改同一个文件」的情形，很明显，这些程序需要以某种方式进行通信，不然这个文件很容易被损坏==。**文件锁**可以解决这个问题，它可以**控制对「文件或文件中某个范围的字节」的访问**。

假设你的应用程序将用户的偏好存储在一个配置文件中，当用户调用这个应用的两个实例时，这两个实例就有可能会同时希望写这个配置文件。在这种情况下，第一个实例应该锁定这个文件，当第二个实例发现这个文件被锁定时，它必须决策是等待直至这个文件解锁，还是直接跳过这个写操作过程。

要锁定一个文件，可以调用 `FileChannel` 类的 `lock` 或 `tryLock` 方法：
```java
FileChannel = FileChannel.open(path);
FileLock lock = channel.lock();
// or
FileLock lock = channel.tryLock();
```
第一个调用会阻塞直至可获得锁，而第二个调用将立即返回，要么返回锁，要么在锁不可获得的情况下返回 `null` 。这个文件将保持锁定状态，直至这个通道关闭，或者在锁上调用了release方法。

你还可以通过下面的调用锁定文件的一部分：
```java
FileLock lock(long start, long size, boolean shared)
FileLock tryLock(long start, long size, boolean shared)
```
如果 `shared` 标志为 `false` ，则锁定文件的目的是读写，而如果为 `true` ，则这是一个共享锁，它允许多个进程从文件中读入，并阻止任何进程获得独占的锁。并非所有的操作系统都支持共享锁，因此你可能会在请求共享锁的时候得到的是独占的锁。**调用 `FileLock` 类的 `isShared` 方法，可以查询你所持有的锁的类型**。
> 注意：如果锁定了文件的尾部，而这个文件的长度随后增长超过了锁定的部分，那么增长出来的额外区域是未锁定的，**要想锁定所有的字节，可以使用 `Long.MAX_VALUE` 来表示尺寸**。

要确保在操作完成时释放锁，与往常一样，最好在一个 `try` 语句中执行释放锁的操作：
```java
try (FileLock lock = channel.lock()) {
	access the locked file or segment
}
```
请记住，文件加锁机制是依赖于操作系统的，下面是需要注意的几点：
- **在某些系统中，文件加锁仅仅是*建议性的*** ，如果一个应用未能得到锁，它仍旧可以向被另一个应用并发锁定的文件执行写操作。
- **在某些系统中，不能在锁定一个文件的同时将其映射到内存中**。
- **文件锁是由整个Java虚拟机持有的**。如果有两个程序是由同一个虚拟机启动的（例如Applet和应用程序启动器），那么它们不可能每一个都获得一个在同一个文件上的锁。当调用 `lock` 和 `tryLock` 方法时，如果虚拟机已经在同一个文件上持有了另一个重叠的锁，那么这两个方法将抛出 `OverlappingFileLockException` 。
- **在一些系统中，关闭一个通道会释放由Java虚拟机持有的底层文件上的所有锁**。因此，在同一个锁定文件上应避免使用多个通道。
- **在网络文件系统上锁定文件是高度依赖于系统的**，因此应该尽量避免。

> [API] `java.nio.channels.FileChannel` 1.4
> - `FileLock lock()`
> 在整个文件上获得一个独占的锁，这个方法将阻塞直至获得锁。
> - `FileLock tryLock()`
> 在整个文件上获得一个独占的锁，或者在无法获得锁的情况下返回 `null` 。
> - `FileLock lock(long position, long size, boolean shared)`
> - `FileLock tryLock(long position, long size, boolean shared)`
> 在文件的一个区域上获得锁。第一个方法将阻塞直至获得锁，而第二个方法将在无法获得锁时返回 `null` 。参数 `shared` 为 `true` 表示共享锁，`false` 为独占锁。

> [API] `java.nio.channels.FileLock` 1.4
> - `void close()` 1.7
> 释放这个锁。

---
# 14.8 正则表达式
**正则表达式** `regular expression` 用于**指定字符串的模式**，==你可以在任何需要定位「匹配某种特定模式的字符串」的情况下，使用正则表达式==。例如，有一个示例程序就是用来定位HTML文件中的所有超链接的，它是通过查找 `<a href="...">` 模式的字符串来实现此目的的。

当然，对于指定模式来说，`...` 标记法并不够精确。需要精确地指定，什么样的字符序列才是合法的匹配，这就要求无论何时，当你要描述一个模式时，都需要使用某种特定的语法。
## 14.8.1 正则表达式语法
下面是一个简单的示例，正则表达式 `[Jj]ava.+` 匹配下列形式的所有字符串：
- 第一个字母是 `J` 或 `j` 。
- 接下来的三个字母是 `ava` 。
- 字符串的其余部分由一个或多个任意的字符构成。

例如，字符串“javanese”就匹配这个特定的正则表达式，但是字符串“core java”就不匹配。

如所见，你需要了解一点这种语法，以理解正则表达式的含义。幸运的是，对于大多数情况，一小部分很直观的语法结构就足够用了。
- ==**字符类** *character class* 是一个括在括号中的、可选择的字符集==，例如，`[Jj], [0-9], [A-Za-z], [^0-9]` 。这里 **`-` 表示是一个范围**（所有Unicode值落在两个边界范围之内的字符），而 **`^` 表示补集**（除了指定字符之外的所有字符）。
- 如果字符类中包含 `-` ，那么它必须是第一项或最后一项;如果要包含 `[` ，那么它必须是第一项;如果要包含 `^` ，那么它可以是除开始位置之外的任何位置。其中，只需要转义 `[` 和 `\` 。
- 有许多预定的字符类，例如 `\d`（数字）和 `\p{Sc}`（Unicode货币符号）。查看下表。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211262221948.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211262222961.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211262228109.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211262231806.png)
![表14-7 预定义的字符类名字](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211262232881.png)

- **大部分字符都可以与它们自身匹配**，例如在前面示例中的ava字符。
- **`.` 符号可以匹配任何字符**（有可能不包括行终止符，这取决于标志的设置）。
- **使用 `\` 作为转义字符**，例如，`\.` 匹配句号而 `\\` 匹配反斜线。
- **`^` 和 `$` 分别匹配一行的开头和结尾**。
- 如果 `X` 和 `Y` 是正则表达式，那么 `XY` 表示“任何 `X` 的匹配后面跟随 `Y` 的匹配”，`X|Y` 表示“任何 `X` 或 `Y` 的匹配”。
- 可以**将量词运用到表达式 `X`** ：`X+`（1个或多个）、`X*`（0个或多个）与 `X?`（0个或1个）。
- ==默认情况下，量词要匹配能**使整个匹配成功**的最大可能的重复次数 *the largest possible repetition*== 。可以修改这种行为，方法是使用后缀 `?`（使用勉强或吝啬匹配 *reluctant or stingy* ，也就是匹配最小的重复次数）或使用后缀 `+`（使用占有或贪婪匹配 *possessive, or greedy, match* ，也就是即使让整个匹配失败，也要匹配最大的重复次数）。
	例如，字符串 `cab` 匹配 `[a-z]*ab` ，但不匹配 `[a-z]*+ab` 。在第一种情况中，表达式 `[a-z]*` 只匹配字符 `c` ，使得字符 `ab` 匹配该模式的剩余部分;但贪婪版本 `[a-z]*+` 将匹配字符 `cab` ，模式的剩余部分将无法匹配。
- **我们使用群组来定义子表达式**，其中群组用括号 `()` 括起来。例如，`([+-]?)([0-9]+)` 。然后你**可以询问模式匹配器** *ask the pattern matcher* ，**让其返回每个组的匹配**，或者用 `\n` 来引用某个群组，其中 `n` 是群组号（从 `\1` 开始）。

例如，下面是一个有些复杂但是却可能很有用的正则表达式，它描述了十进制和十六进制整数：
```java
[+-]?[0-9]+|0[Xx][0-9A-Fa-f]+
```
==遗憾的是，在使用正则表达式的各种程序和类库之间，表达式语法并未完全标准化==。尽管在基本结构上达成了一致，但它们在细节上仍存在着许多令人抓狂的差异。Java正则表达式类使用的语法，与Perl语言使用的语法十分相似，但并不完全一样。**上一张表展示的是Java语法中的所有结构**。

关于正则表达式语法的更多信息，可以求教于 `Pattern` 类的API文档和 *Mastering Regular Expressions, Jeffrey E.F.Friedl* 。
## 14.7.2 匹配字符串
正则表达式的最简单用法就是，测试某个特定的字符串是否与它匹配。下面展示如何用Java来编写这种测试。首先**用表示正则表达式的字符串构建一个 `Pattern` 对象**，然后**从这个模式中获得一个 `Matcher` ，并调用它的 `matches` 方法**：
```java
Pattern pattern = Pattern.compile(patternString);
Matcher matcher = pattern.matcher(input);
if (matcher.matches()) ...
```
**这个匹配器的输入，可以是任何实现了 `CharSequence` 接口的类的对象**，例如 `String, StringBuilder, CharBuffer` 。

在编译这个模式时，可以设置一个或多个标志，例如：
```java
Pattern pattern = Pattern.compile(expression,
	Pattern.CASE_INSENSITIVE + Pattern.UNICODE_CASE);
```
下面是所支持的六个标志：
- `CASE_INSENSITIVE` 或 `i` ：匹配字符时忽略字母的大小写，默认情况下，这个标志只考虑US ASCII字符。
- `UNICODE_CASE` 或 `u` ：当与 `CASE_INSENSITIVE` 组合时，用Unicode字母的大小写来匹配。
- `UNICODE_CHARACTER_CLASS` 或 `U` ：选择Unicode字符类而非POSIX，其中蕴含了 `UNICODE_CASE` 。
- `MULTILINE` 或 `m` ：**`^` 和 `$` 匹配行的开头和结尾，而不是整个输入的开头和结尾**。
- `UNIX_LINES` 或 `d` ：在多行模式 *multiline mode* 中匹配 `^` 和 `$` 时，只有 `'\n'` 被识别成行终止符。
- `DOTALL` 或 `s` ：当使用这个标志时，`.` 符号匹配所有字符，包括行终止符。
- `COMMENTS` 或 `x` ：空白字符和注释（从 `#` 到行末尾）将被忽略。
- `LITERAL` ：模式将被逐字地采纳、必须精确匹配 *taken literally and must be matched exactly* ，因字母大小写而造成的差异除外 *except possibly for letter case* 。
- `CANON_EQ` ：考虑Unicode字符规范的等价性，例如，`u` 后面跟随 `¨`（分音符号）匹配 `ü` 。

最后两个标志不能在正则表达式内部指定。

**如果想要在集合或流中匹配元素，那么可以将模式转换为谓词**。下面的结果中，包含了匹配正则表达式的所有字符串：
```java
Stream<String> strings = ...;
Stream<String> result = strings.filter(pattern.asPredicate());
```

**如果正则表达式包含群组，那么 `Matcher` 对象可以揭示群组的边界**。下面的方法将产生指定群组的开始索引和结束之后的索引：
```java
int start(int groupIndex)
int end(int groupIndex)
```

可以直接通过调用下面的方法、抽取匹配的字符串。群组0是整个输入，而用于第一个实际群组的群组索引是1：
```java
String group(int groupIndex)
```
调用 `groupCount` 方法可以获得全部群组的数量。**对于具名的组，使用下面的方法**：
```java
int start(String groupName)
int end(String groupName)
String group(String groupName)
```

**嵌套群组是按照开括号排序的**，例如，假设我们有下面的模式：
```java
(([1-9]|1[0-2]):([0-5][0-9]))[ap]m
```
和下面的输出：
```java
11:59am
```
那么，匹配器会报告下面的群组：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211270046479.png)

`regex/RegexTest.java` 提示输入一个模式，然后提示输入用于匹配的字符串，随后将打印出输入是否与模式相匹配。**如果输入匹配模式，并且模式包含群组，那么这个程序将用括号打印出群组边界**，例如：
```java
((11):(59))am
```
```java
// regex/RegexTest.java
package regex;

import java.util.*;
import java.util.regex.*;

/**
 * This program tests regular expression matching. Enter a pattern and strings to match,
 * or hit Cancel to exit. If the pattern contains groups, the group boundaries are displayed 
 * in the match.
 */
public class RegexTest {
	public static void main(String[] args) throws PatternSyntaxException {
		var in = new Scanner(System.in);
		System.out.println("Enter pattern: ");
		String patternString = in.nextLine();

		Pattern pattern = Pattern.compile(patternString);
		while (true) {
			System.out.println("Enter string to match: ");
			String input = in.nextLine();
			if (input == null || input.equals("")) return;
			Matcher matcher = pattern.matcher(input);
			if (matcher.matches()) {
				System.out.println("Match");
				int g = matcher.groupCount();
				if (g > 0) {
					for (int i = 0; i < input.length(); ++i) {
						// Print any empty groups
						for (int j = 1; j <= g; ++j) 
							if (i == matcher.start(j) && i == matcher.end(j)) 
								System.out.print("()");
						// Print ( for non-empty groups starting here
						for (int j = 1; j <= g; ++j)
							if (i == matcher.start(j) && i != matcher.end(j)) 
								System.out.print('(');
						System.out.print(input.charAt(i));
						// Print ) for non-empty groups ending here
						for (int j = 1; j <= g; ++j)
							if (i + 1 != matcher.start(j) && i + 1 == matcher.end(j)) 
								System.out.print(')');
					}
					System.out.println();
				} 
			} else System.out.println("No match");
		}
	}
}
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212172005616.png)

## 14.7.3 找出多个匹配
通常，你不希望用正则表达式来匹配全部输入 *match the entire input against a regular expression* ，而只是想找出「**输入中一个或多个匹配的子字符串**」。这时可以使用 `Matcher` 类的 `find` 方法来查找匹配内容，如果返回 `true` ，再使用 `start` 和 `end` 方法来查找匹配的内容，**或使用不带参数的 `group` 方法来获取匹配的字符串**：
```java
while (matcher.find()) {
	int start = matcher.start();
	int end = matcher.end();
	String match = input.group();
	...
}
```
==这种方式中，可以依次处理每个匹配==。正如上面的代码片段所示，==可以获取匹配的字符串，以及它在输入字符串中的位置==。

更优雅的是，可以调用 `results` 方法来获取一个 `Stream<MatchResult>` 。`MatchResult` 接口有 `group, start, end` 方法，就像 `Matcher` 一样（事实上，**`Matcher` 类实现了这个接口**）。下面展示如何获取所有匹配的列表：
```java
List<String> matches = pattern.matcher(input)
	.results()
	.map(Matcher::group)
	.collect(Collectors.toList());
```

如果要处理的是文件中的数据，那么可以使用 `Scanner.findAll` 方法、获取一个 `Stream<MatchResult>` ，这样就无须将内容读取到一个字符串中。可以给 `Scanner` 传递一个 `Pattern` 或一个模式字符串：
```java
var in = new Scanner(path, StandardCharsets.UTF_8);
Stream<String> words = in.findAll("\\pL+")
	.map(MatchResult::group);
```

`match/HrefMatch.java` 对这种机制进行了应用，它定位一个Web页面上的所有超文本引用、并打印它们。为了运行这个程序，需要在命令行中提供一个URL，例如 `java match.HrefMatch http://horstmann.com` 。
```java
// match/HrefMatch.java
package match;

import java.io.*;
import java.net.*;
import java.nio.charset.*;
import java.util.regex.*;

/**
 * This program displays all URLs in a web page by matching a regular expression that
 * describes the <a href=...> HTML tag. Start the program as <br>
 * java match.HrefMatch URL
 */
public class HrefMatch {
	public static void main(String[] args) {
		try {
			// get URL string from command line or use default
			String urlString;
			if (args.length > 0) urlString = args[0];
			else urlString = "http://openjdk.java.net/";

			// read contents of URL
			InputStream in = new URL(urlString).openStream();
			var input = new String(in.readAllBytes(), StandardCharsets.UTF_8);

			// search for all occurrences of pattern
			var patternString = "<a\\s+href\\s*=\\s*(\"[^\"]*\"|[^\\s>]*)\\s*>";
			Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
			pattern.matcher(input).results()
				.map(MatchResult::group)
				.forEach(System.out::println);
		} catch (IOException | PatternSyntaxException e) {
			e.printStackTrace();
		}
	}
}
```

运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212172047609.png)

## 14.7.4 用分隔符来分割
有时，需要将输入按照匹配的分隔符断开、而其他部分保持不变。`Pattern.split` 方法可自动完成这项任务。调用此方法后，可以获得一个剔除分隔符后的字符串数组：
```java
String input = ...;
Pattern commas = Pattern.compile("\\s*,\\s*");
String[] tokens = commas.split(input);
	// "1, 2, 3" turns into ["1", "2", "3"]
```
如果有多个 *tokens* ，那么可以惰性获取它们：
```java
Stream<String> tokens = commas.splitAsStream(input);
```
如果不关心预编译模式和惰性获取，那么可以使用 `String.split` 方法：
```java
String[] tokens = input.split("\\s*,\\s*");
```
如果输入数据在文件中，那么需要使用扫描器：
```java
var in = new Scanner(path, StandardCharsets.UTF_8);
in.useDelimiter("\\s*,\\s*");
Stream<String> tokens = in.tokens();
```

## 14.7.5 替换匹配
`Matcher` 类的 `replaceAll` 方法，将「正则表达式出现的所有地方」都用替换字符串来替换。例如，下面的指令将所有的数字序列都替换成 `#` 字符：
```java
Pattern pattern = Pattern.compile("[0-9]+");
Matcher matcher = pattern.matcher(input);
String output = matcher.replaceAll("#");
```
**替换字符串可以包含对模式中群组的引用**：`$n` 表示替换成第 `n` 个群组，因此需要使用 `\$` 来表示在替换文本中包含一个 `$` 字符 *include a $ character in the replacement text* 。

如果字符串中包含 `$` 和 `\` ，但又不希望它们被解释成群组的替换符，那么就可以调用 `matcher.replaceAll(Matcher.quoteReplacement(str))` 。

如果想执行比按照群组匹配拼接 *splicing in group matches* 更复杂的操作，**可以提供一个替换函数、而不是替换字符串**。该函数接受一个 `MatchResult` 对象，并产生一个字符串。例如下面的代码中，我们将所有单词都替换为「至少4个字母转换为大写形式」的版本：
```java
String result = Pattern.compile("\\pL{4,}")
	.matcher("Mary had a little lamb")
	.replaceAll(m -> m.group().toUpperCase());
	// Yields "MARY had a LITTLE LAMB"
```
`replaceFirst` 方法将只替换模式的第一次出现。

> [API] `java.util.regex.Pattern` 1.4
> - `static Pattern compile(String expression)`
> - `static Pattern compile(String expression, int flags)`
> 把正则表达式字符串编译到一个用于快速处理匹配的模式对象中。参数 `flags` 是 `CASE_INSENSITIVE, UNICODE_CASE, MULTILINE, UNIX_LINES, DOTALL, CANON_EQ` 标志中的一个
> - `Matcher matcher(CharSequence input)`
> 返回一个 `matcher` 对象，可以用它在输入中定位模式的匹配。
> - `String[] split(CharSequence input)
> - `String[] split(CharSequence input, int limit)`
> - `Stream<String> splitAsStream(CharSequence input)` 8
> 将输入分割成标记，其中模式指定了分隔符的形式。返回标记数组，分隔符并非标记的一部分。第二种形式有一个名为 `limit` 的参数，它表示所产生的字符串的最大数量。如果已经发现了 `limit-1` 个匹配的分隔符，那么返回的数组中的最后一项就包含所有剩余未分割的输入。如果 `limit<0` ，那么整个输入 *entire input* 都被分割;如果 `limit` 为0，那么结尾的空字符串 *trailing empty strings* 将不会置于返回的数组中

> [API] `java.util.regex.Matcher` 1.4
> - `boolean matches()`
> 如果输入匹配模式，则返回 `true` 。
> - `boolean lookingAt()`
> 如果输入的开头匹配模式，则返回 `true` 。
> - `boolean find()`
> - `boolean find(int start)`
> 尝试查找下一个匹配，如果找到了另一个匹配，则返回`true` 。
> - `int start()`
> - `int end()`
> 返回当前匹配的开始索引和结尾之后的索引位置。
> - `String group()`
> 返回当前的匹配。
> - `int groupCount()`
> 返回输入模式 *input pattern* 中的群组数量。
> - `int start(int groupIndex)
> - `int start(String name)` 8
> - `int end(int groupIndex)`
> - `int end(String name)`
> 返回当前匹配中给定群组的开始和结尾之后的位置。群组是由（从1开始的） `groupIndex` 群组索引指定的，或者用0表示整个匹配，或用一个表示具名组的（名字）字符串来指定。
> - `String group(int groupIndex)`
> - `String group(String name)`
> 返回匹配给定群组的字符串。
> - `String replaceAll(String replacement)`
> - `String replaceFirst(String replacement)`
> 返回从匹配器输入获得的、通过将所有匹配或第一个匹配用替换字符串替换之后的字符串。替换字符串可以包含用 `$n` 表示的对群组的引用，这时需要用 `\$` 来表示字符串中包含一个 `$` 符号。
> - `static String quoteReplacement(String str)` 5.0
> 引用 *quotes* `str` 中的所有 `\` 和 `$` 。
> - `Matcher reset()`
> - `Matcher reset(CharSequence input)`
> 复位匹配器的状态。第二个方法将使匹配器作用于另一个不同的输入。这两个方法都返回 `this` 。
> - `String replaceAll(Function<MatchResult, String> replacer)` 9
> 将每个匹配都替换为 `replacer` 函数应用于 `MatchResult` 上所产生的结果。
> - `Stream<MatchResult> results()` 9
> 产生一个包含所有匹配结果的流。

> [API] `java.util.regex.MatchResult` 5
> - `String group()`
> - `String group(int group)`
> 产生匹配的字符串，或者匹配给定群组的字符串。
> - `int start()`
> - `int end()`
> - `int start(int group)`
> - `int end(int group)`
> 产生匹配字符串 *matched string* 或匹配给定群组的字符串 *the string matched by the given group* 的开头与结尾的偏移量。 

> [API] `java.util.Scanner` 5.0
> - `Stream<MatchResult> findAll(Pattern pattern)` 9
> 产生一个流，其中包含了这个扫描器产生的输入中、针对给定模式的所有匹配。
