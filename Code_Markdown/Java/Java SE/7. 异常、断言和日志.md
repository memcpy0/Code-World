@[toc]

▲ 处理错误
▲ 使用断言
▲ 捕获异常
▲ 记录日志
▲ 使用异常机制的技巧
▲ 调试技巧

在理想状态下，用户输入数据的格式永远都是正确的，选择打开的文件也一定存在，并且永远不会出现bug。迄今为止，似乎都处在这样一个理想境界中。然而，在现实世界中却充满了不良的数据和带有问题的代码，现在是时候讨论Java处理这些问题的机制了。

人们在遇到错误时会感觉不爽。如果由于程序的错误或一些外部环境的影响，导致用户数据的丢失，用户就有可能不再使用这个程序了。为避免这类事情的发生，至少应做到以下几点：
- 向用户通告错误；
- 保存所有的工作结果；
- 允许用户妥善退出程序。

对于异常情况，例如，可能造成程序崩溃的错误输入，Java使用一种称为**异常处理** `exception handing` 的错误捕获机制。Java中的异常处理与C++或Delphi中的异常处理十分类似。本章第1部分**先介绍Java的异常**。

在测试期间，需要进行大量的检测以验证程序操作的正确性。然而这些检测可能非常耗时，在测试完成后也不必保留，因此可将这些检测删掉，需要另做测试时再将它们粘贴回来，这很乏味。本章第2部分介绍**如何使用断言来有选择地启用检测**。

当程序出现错误时，并不总是能与用户或终端进行沟通。此时，可能希望记录下出现的问题，以备日后进行分析。本章第3部分讨论**标准Java日志框架**。

---
# 7.1 处理错误
假设在一个Java程序运行期间出现了一个错误。这个错误可能是由于文件包含了错误信息，或网络连接出现问题造成的，也有可能是因为使用无效的数组下标，或试图使用一个没有被赋值的对象引用而造成的。用户期望在出现错误时，程序能采用合理的行为。如果由于出现错误而使得某些操作没有完成，程序应该：
- **返回到一种安全状态，并能让用户执行一些其他的命令**；或
- **允许用户保存所有操作的结果，并以妥善的方式终止程序**。
 
要做到这些并不是一件很容易的事情。其原因是——「检测（或引发）错误条件的代码」通常离那些「能让数据恢复到安全状态，或能保存用户的操作结果、并妥善退出程序的代码」很远。==异常处理的任务，就是将控制权从错误产生的地方、转移给能处理这种情况的错误处理器==。为了能在程序中处理异常情况，必须考虑程序中可能会出现的错误和问题：
1. 用户输入错误
除了那些不可避免的键盘输人错误外，有些用户喜欢各行其是，不遵守程序的要求。例如，假设有一个用户请求连接一个 URL，而语法却不正确。你的代码中应对此进行检查，如果没有检査，网络层就会报错。
2. 设备错误
硬件并不总是让它做什么，它就做什么。打印机可能被关掉了。网页可能临时不能浏览。在一个任务的处理过程中，硬件经常出现问题。例如，打印机在打印过程中可能没有纸了。
3. 物理限制
磁盘满了，可用存储空间已被用完。
4. 代码错误
程序方法可能无法正确执行。例如，方法可能返回了一个错误的答案，或错误地调用了其他的方法。计算的数组索引不合法，试图在散列表中查找一个不存在的记录，或试图让一个空找执行弹出操作，这些都属于代码错误。

**对于方法中的一个错误，传统的做法是返回一个特殊的错误码，由调用方法分析**。例如，对于一个从文件中读取信息的方法来说，返回值通常不是标准字符，而是一个-1，表示文件结束。**这种处理方式对于很多异常状况都是可行的**。还有一种表示错误状况的常用返回值是 `null` 引用。

遗憾的是，==并不是在任何情况下都能返回一个错误码，有时可能无法明确地将有效数据与无效数据加以区分==。一个返回整型的方法，就不能简单地通过返回-1表示错误，因为-1可能是一个完全合法的结果。

正如第5章中所叙述的那样，在Java中，如果某个方法不能采用正常途径完成它的任务，就可以通过另外一个路径退出方法。在这种情况下，方法并不返回任何值，而是抛出 *throw* 一个封装了错误信息的对象。需要注意的是，==这个方法将会立刻退出，并不返回任何值，此外也不会从「调用这个方法的代码」继续执行。取而代之的是，异常处理机制开始搜索能处理这种异常状况的**异常处理器** *exception handler*== 。

异常有自己的语法和特定的继承结构。下面首先介绍语法，然后再给出有效使用这种语言功能的技巧。
## 7.1.1 异常分类
**在Java中，异常对象都是派生于 `Throwable` 类的一个实例**。稍后还可以看到，如果Java中内置的异常类不能满足需求，用户可以创建自己的异常类。图7-1是Java异常层次结构的一个简化示意图。
![图7-1 Java中的异常层次结构](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210132006811.png)

需要注意，**所有的异常都由 `Throwable` 继承而来**，但在下一层立即分解为两个分支：`Error` 和 `Exception` 。
- `Error` 类层次结构描述了「Java运行时系统的内部错误和资源耗尽错误」。**你的应用程序不应抛出这种类型的对象**。如果出现了这样的内部错误，**除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了**。这种情况很少出现。
- 在设计Java程序时，需要关注 `Exception` 层次结构。这个层次结构又分解为两个分支，一个分支派生于 `RuntimeException` ；另一个分支包含其他异常。划分两个分支的规则是：**发生 `RuntimeException` 是因为你犯了一个编程错误** *you made a programming error* ；**任何其他异常都是因为你「本身没问题的程序」遇到了不好的问题**，如I/O错误。

派生于 `RuntimeException` 的异常包含下面几种情况：
- 错误的强制类型转换；
- 数组访问越界；
- 访问 `null` 指针。

不是派生于 `RuntimeException` 的异常包括：
- 试图超越文件尾部继续读取数据。
- 试图打开一个不存在的文件。
- 试图根据给定的字符串查找 `Class` 对象，而这个字符串表示的类并不存在。

**If it is a RuntimeException, it was your fault** 是一条相当有道理的规则。应通过检测数组下标是否越界来避免 `ArrayIndexOutOfBoundsException` 异常；应通过在使用变量之前检测是否为 `null` 、来杜绝 `NullPointerException` 异常的发生。

如何处理不存在的文件呢？难道不能先检查文件是否存在、再打开它吗？其实，这个文件有可能在你检查它是否存在之后、就立即被删除了。因此，**“是否存在”取决于环境，而不只是取决于你的代码**。

Java语言规范将「派生于 `Error` 类或 `RuntimeException` 类的所有异常」称为**非检查型/不受查型** `unchecked` 异常，所有其他的异常称为**检查型/受查型** `checked` 异常。这是两个很有用的术语，在后面还会用到。编译器将检查你是否为所有的检查型异常提供了异常处理器。
> 注释：`RuntimeException` 这个名字很容易让人混淆。实际上，现在讨论的所有错误都发生在运行时。

> C++注释：如果熟悉标准C++类库中的异常层次结构，就一定会感到有些困惑。C++有两个基本的异常类，一个是 `runtime_error` ；另一个是 `logic_error` 。`logic_error` 类相当于Java中的 `RuntimeException` ，它表示程序中的逻辑错误；`runtime_error` 类是所有由于不可预测的原因所引发的异常的基类，它相当于Java中的非 `RuntimeException` 异常。

## 7.1.2 声明检查型异常
如果遇到了无法处理的情况，Java的方法可以抛出一个异常。这个道理很简单：一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。例如，一段读取文件的代码知道有可能读取的文件不存在、或内容为空，因此，试图处理文件信息的代码就需要通知编译器，可能会抛出 `IOException` 类的异常。

**方法应在其首部，指出这个方法可能抛出一个异常**。这样可以从方法首部，体现出这个方法可能抛出哪类**检查型异常**。例如，下面是标准类库中 `FileInputStream` 类的一个构造器的声明（有关输入和输出的更多信息请参看卷II第2章）。
```java
public FileInputStream(String name) throws FileNotFoundException
```
这个声明表示，这个构造器将根据给定的 `String` 参数产生一个`FileInputStream` 对象，但也有可能抛出一个 `FileNotFoundException` 异常。如果发生了这种糟糕情况，构造器将不会初始化一个新的 `FileInputStream` 对象，而是抛出一个 `FileNotFoundException` 类对象。如果这个方法真抛出了这样一个异常对象，运行时系统就会开始搜索异常处理器，以知道如何处理 `FileNotFoundException` 对象。

**在自己编写方法时，不必声明这个方法可能抛出的所有异常**。至于什么时候要在方法中用 `throws` 子句声明异常、什么异常必须使用 `throws` 子句声明，需要记住——**在遇到下面4种情况时会抛出异常**：
1. **调用了一个抛出检查型异常的方法**，例如 `FileInputStream` 构造器。
2. **发现了错误，并且利用 `throw` 语句抛出一个检查型异常**（下一节详细介绍 `throw` 语句）。
3. 你犯了一个编程错误，例如，`a[-1] = 0` 会抛出一个`ArrayIndexOutOfBoundsException` 这样的非检查型异常 `RuntimeException`。
4. Java虚拟机或运行时库出现的内部错误 `Error` 。

**如果出现前两种情况，则必须告诉调用这个方法的程序员有可能抛出异常**。为什么？因为任何一个抛出异常的方法，都有可能是一个死亡陷阱。如果没有处理器捕获这个异常，当前执行的线程就会结束。

有些Java方法包含在对外提供的类中、可能被他人使用，对于这些方法，应通过方法首部的异常规范 `exception specification` ，声明这个方法可能抛出的异常。
```java
class MyAnimation {
	...
	public Image loadImage(String s) throws IOException {
		...	
	}
}
```
**如果一个方法有可能抛出多个检查型异常类型，那么就必须在方法的首部列出所有的异常类**。每个异常类之间用逗号隔开。如下面这个例子所示：
```java
class MyAnimation {
	public Image loadlmage(String s) 
		throws FileNotFoundException, EOFException
}
```
但是，**不需要声明Java的内部错误，即从 `Error` 继承的错误**。任何程序代码都有可能抛出那些异常，而我们对其完全无法控制。同样，**也不应该声明从 `RuntimeException` 继承的那些非检查型异常**。这些运行时错误完全在我们的控制之下。如果特别关注数组下标引发的错误，就应多花时间修正这些错误，而不是说明这些错误有可能发生。
```java
class MyAnimation {
	void drawImage(int i) 
		throws ArrayIndexOutOfBoundsException // bad style
}
```
总之，**一个方法必须声明所有可能抛出的检查型异常**，而非受查异常要么不可控制 `Error` ，要么就应避免发生 `RuntimeException` 。==如果你的方法没有声明所有可能发生的检查型异常，编译器就会发出一个错误消息==。

当然，从前面的示例中可以知道——除了声明异常之外，还可以捕获异常。这样就不会从这个方法抛出这个异常，也不需要 `throws` 。稍后，将讨论如何决定一个异常是被捕获，还是将其抛出由他人捕获。
> 警告：如果在子类中覆盖了超类的一个方法，子类方法中声明的检查型异常、不能比超类方法中声明的异常更通用（即，**子类方法中可以抛出更特定的异常，或根本不抛出任何异常**）。特别要说明的是，==如果超类方法没有抛出任何检查型异常，子类也不能抛出任何检查型异常==。例如，如果覆盖 `JComponent.paintComponent` 方法，由于超类中这个方法没有抛出任何异常，所以自定义的 `paintComponent` 也不能抛出任何检查型异常。

**如果类中的一个方法声明它会抛出一个异常，而这个异常是某个特定类的实例，则这个方法抛出的异常可能属于这个类，或这个类的任意一个子类**。例如，`FileInputStream` 构造器声明有可能抛出一个 `IOException` 异常，你并不知道具体是哪种 `IOException` 异常。它既可能是 `IOException` 异常，也可能是其子类的异常，例如，`FileNotFoundException` 。
> C++注释：Java中的 `throws` 说明符与C++中的 `throw` 说明符基本类似，但有一点重要的区别。**在C++中，`throw` 说明符在运行时执行，而不是在编译时执行**。也就是说，**C++编译器将不处理任何异常规范**。但如果函数抛出的异常没有出现在 `throw` 列表中，就会调用 `unexpected` 函数，这个函数的默认处理方式是终止程序的执行。
> 
> 另外，在C++中，如果没有给出 `throw` 说明，函数可能会抛出任何异常。而**在Java中，没有 `throws` 说明符的方法将根本不能抛出任何检查型异常**。

## 7.1.3 如何抛出异常
假设在程序代码中发生了一些糟糕的事情。一个名为 `readData` 的方法正在读取一个首部具有下列信息的文件，它承诺文件长度为1024个字符：
```java
Content-length: 1024
```
然而，读到733个字符之后文件就结束了。我们认为这是一种不正常的情况，希望抛出一个异常。

**首先要决定应抛出什么类型的异常**。将上述异常归结为 `IOException` 是一种很好的选择。仔细阅读Java API文档之后会发现，`EOFException` 异常描述的是“指示输入过程中意外遇到了EOF”。这正是我们要抛出的异常。下面是抛出这个异常的语句：
```java
throw new EOFException();
```
或：
```java
EOFException e = new EOFException();
throw e;
```
下面将这些代码放在一起：
```java
String readData(Scanner in) { throws EOFException
	while (...) {
		if (!in.hasNext()) { // EOF encountered
			if (n < len)
				throw new EOFException();
		}
		...
	}
	return s;
}
```
`EOFException` 类还有一个带一个字符串型参数的构造器。可以很好地利用这个构造器，更细致描述异常。
```java
String gripe = "Content-length: " + len + ", Received: " + n;
throw new EOFException(gripe);
```
在前面已看到，如果一个已有的异常类能满足你的要求，将其抛出非常容易。在这种情况下：
1. 找到一个合适的异常类。
2. 创建这个类的一个对象。
3. 将对象抛出。

**一旦方法抛出了异常，这个方法就不可能返回到调用者**。也就是说，不必操心建立一个默认的返回值或错误码。
> C++注释：在C++与Java中，抛出异常的过程基本相同，只有一点微小的差别。在Java中，只能抛出 `Throwable` 子类的对象，而在C++中，却可以抛出任何类型的值。

## 7.1.4 创建异常类
在程序中，可能会遇到任何标准异常类都无法描述清楚的问题。在这种情况下，创建自己的异常类就是一件顺理成章的事情了。**我们需要做的只是定义一个派生于 `Exception` 的类，或派生于 `Exception` 子类的类**。例如，定义一个派生于 `IOException` 的类。

习惯上，**自定义的类应包含两个构造器，一个是默认的构造器；另一个是包含详细描述信息的构造器**（超类 `Throwable` 的 `toString` 方法会返回一个字符串，其中包含这些详细信息，这在调试中非常有用）。
```java
class FileFormatException extends IOException {
	public FileFormatExceptionO {}
	public FileFormatException(String gripe) {
		super(gripe);
	}
}
```
现在，就可以抛出自己定义的异常类型了。
```java
String readData(BufferedReader in) throws FileFormatException {
	while (...) {
		if (ch == -1) { // EOF encountered
			if (n < len)
				throw new FileFormatException();
		}
		...
	}
}
```

> [API] `java.lang.Throwable` 1.0
> - `Throwable()`
> 构造一个新的 `Throwable` 对象，这个对象没有详细的描述信息。
> - `Throwable(String message)`
> 构造一个新的 `Throwable` 对象，这个对象带有指定的详细描述信息。习惯上，**所有派生的异常类都支持一个默认构造器和一个带有详细描述信息的构造器**。
> - `String getMessage()`
> 获得 `Throwable` 对象的详细描述信息。

---
# 7.2 捕获异常
到目前为止，已经知道如何抛出一个异常。这个过程十分容易。只要将其抛出就不用理踩了。当然，**有些代码必须捕获异常**。捕获异常需要进行周密的计划。这正是下面要介绍的内容。
## 7.2.1 捕获异常
如果某个异常发生了、且没有在任何地方进行捕获，那程序就会终止，并在控制台上打印出异常信息，其中包括异常的类型和一个堆栈轨迹。图形用户界面程序（包括applet和应用程序）在捕获异常之后，也会打印出堆栈轨迹信息，但程序将返回到用户界面的处理循环中（在调试GUI程序时，最好保证控制台窗口可见，并且没有被最小化）。

**要想捕获一个异常，必须设置 `try/catch` 语句块**。最简单的 `try` 语句块如下所示：
```java
try {
	code
	more code
	more code
} catch (ExceptionType e) {
	handler for this type
}
```
如果在 `try` 语句块中的任何代码，抛出了一个在 `catch` 子句中说明的异常类，那么
1. 程序将跳过 `try` 语句块的其余代码。
2. 程序将执行 `catch` 子句中的处理器代码。

如果在 `try` 语句块中的代码没有拋出任何异常，那么程序将跳过 `catch` 子句。

如果方法中的任何代码，拋出了一个在 `catch` 子句中没有声明的异常类型，那么这个方法就会立刻退出（希望它的调用者为这种类型的异常设`try catch` 子句）。

为了演示捕获异常的处理过程，下面给出一个读取数据的典型程序代码：
```java
public void read(String filename) {
	try {
		InputStream in = new FileInputStream(filename);
		int b;
		while ((b = in.read()) != -1) {
			process input
		}
	} catch (IOException exception) {
		exception.printStackTrace();
	}
}
```
需要注意的是，`try` 语句中的大多数代码都很容易理解：读取并处理字节，直到遇到文件结束符为止。正如在Java API中看到的那样，`read` 方法有可能拋出一个 `IOException` 异常。在这种情况下，将跳出整个 `while` 循环，进入 `catch` 子旬，并生成一个堆栈轨迹。对于一个玩具程序来说，这样处理异常看上去合乎情理。还有其他的选择吗？

通常，**最好的选择是什么也不做，而是将异常传递给调用者**。如果 `read` 方法出现了错误，就让 `read` 方法的调用者去操心！如果采用这种处理方式，就必须声明这个方法可能会拋出一个 `IOException` 。
```java
public void read(String filename) throws IOException {
	InputStream in = new FileInputStream(filename);
	int b;
	while ((b = in.read()) != -1) {
		process input
	}
}
```
记住，**编译器严格地执行 `throws` 说明符。如果调用了一个抛出检查型异常的方法，就必须对它进行处理，或继续传递这个异常**。

哪种方法更好呢？一般经验是，**应该捕获那些你知道如何处理的异常，而继续传播那些你不知道怎样处理的异常**。如果想传递一个异常，就必须在方法的首部添加一个 `throws` 说明符，告知调用者这个方法可能会抛出异常。

仔细阅读Java API文档，以知道每个方法可能会抛出哪种异常，然后再决定是自己处理，还是添加到 `throws` 列表中。对于后一种情况，也不必难堪。将异常交给能胜任的处理器进行处理，要比压制 `squelch` 这个异常更好。

同时请记住，这个规则也有一个例外。前面曾经提到过：**如果编写一个覆盖超类的方法，而这个超类方法又没有抛出异常**（如 `JComponent` 中的 `paintComponent` ），**那么这个方法就必须捕获方法代码中出现的每一个检查型异常**。不允许在子类的 `throws` 说明符中，出现超类方法未列出的异常类。
> C++注释：在Java与C++中，捕获异常的方式基本相同。严格地说，代码 `catch (Exception e) // Java` 与 `catch (Exception* e) // C++` 是一样的。
> 
> 在Java中，没有与C++中 `catch(...)` 对应的东西。这在Java中并不需要，因为Java中的所有异常类都派生于一个公共的超类。

## 7.2.2 捕获多个异常
**在一个 `try` 语句块中，可以捕获多个异常类型，并对不同类型的异常做出不同的处理**。可以如下为每个异常类型使用一个单独的 `catch` 子句：
```java
try {
	code that might throw exceptions
} catch (FileNotFoundException e) {
	emergency action for missing files
} catch (UnknownHostException e) {
	emergency action for unknown hosts
} catch (IOException e) {
	emergency action for all other I/O problems
}
```
异常对象可能包含有关异常性质的信息。要想获得对象的更多信息，可以试着使用 `e.getMessage()` 得到详细的错误信息（如果有的话），或使用 `e.getClass().getName()`  得到异常对象的实际类型。

**在Java SE 7中，一个 `catch` 子句中可以捕获多个异常类型**。例如，假设对应缺少文件和未知主机异常的动作是一样的，就可以合并 `catch` 子句：
```java
try {
	code that might throw exceptions
} catch (FileNotFoundException | UnknownHostException e) {
	emergency action for missing files and unknown hosts
} catch (IOException e) {
	emergency action for all other I/O problems
}
```
**只有当捕获的异常类型彼此之间不存在子类关系时，才需要这个特性**。
> 注释：捕获多个异常时，异常变量隐含为 `final` 变量。例如，不能在以下子句体中为 `e` 赋不同的值：
> ```java
> catch (FileNotFoundException | UnknownHostException e) { ... }
> ```

> 注释：捕获多个异常不仅会让代码看起来更简单，还会更高效。生成的字节码只包应公共 `catch` 子句的代码块。

## 7.2.3 再次抛出异常与异常链
在 `catch` 子句中可以抛出一个异常，通常这样做的目的是**改变异常的类型**。如果开发了一个供其他程序员使用的子系统，可以使用一个指示子系统故障的异常类型，这很有道理。`ServletException` 就是这样一个异常类型的例子，执行一个servlet的代码可能不想知道发生错误的细节原因，但希望明确知道servlet是否有问题。

下面给出了**捕获异常并将它再次抛出**的基本方法。这里，构造 `ServletException` 时提供了异常的信息文本。
```java
try {
	access the database
} catch (SQLException e) {
	throw new ServletException("database error: " + e.getMessage());
}
```
不过，可以有一种更好的处理方法，即**将原始异常设置为新异常的“原因**”：
```java
try {
	access the database
} catch (SQLException e) {
	Throwable se = new ServletException("database error");
	se.initCause(e);
	throw se;
}
```
当捕获到异常时，可以使用下面这条语句重新得到原始异常：
```java
Throwable e = se.getCause();
```
**强烈建议使用这种包装技术**。这样可以让用户在子系统中抛出高层异常，而不会丢失原始异常的细节。
> 提示：如果在一个方法中发生了一个检查型异常，但这个方法不允许抛出检查型异常，那么包装技术就十分有用。**我们可以捕获这个检查型异常，并将它包装成一个运行时异常**。

有时你可能只想记录一个异常，再将它重新抛出，而不做任何改变：
```java
try {
	access the database
} catch (Exception e) {
	logger.log(level, message, e);
	throw e;
}
```
在Java SE 7之前，这种方法存在一个问题。假设这个代码在以下方法中：
```java
public void updateRecord() throws SQLException
```
Java编译器查看 `catch` 块中的 `throw` 语句，然后查看 `e` 的类型，会指出这个方法可以抛出任何 `Exception` 而不只是 `SQLException` 。现在这个问题已经改进。编译器会跟踪到 `e` 来自 `try` 块。假设这个 `try` 块中仅有的检査型异常是 `SQLException` 实例，另外，假设 `e` 在 `catch` 块中未改变，将外围方法声明为 `throws SQLException` 就是合法的。
## 7.2.4 `finally` 子句
代码抛出一个异常时，就会停止处理方法中剩余的代码，并退出这个方法。==如果这个方法已经获得了「只有它自己知道的一些本地资源」，且这些资源在退出方法之前必须被回收，那么就会产生资源回收问题==。一种解决方案是捕获所有异常、完成资源的清理、再重新抛出异常。但
是，这种解决方案比较繁琐，这是因为要在两个地方清除资源分配。一个在正常的代码中；另一个在异常代码中。`finally` 子句可以解决这个问题。
> 注释：Java 7之后，还有一种更精巧的解决方案，即 `try-with-resources` 语句。之所以详细讨论 `finally` 机制，是因为这是概念基础。不过在实际中，`try-with-resources` 语句可能比 `finally` 子句更常用。

不管是否有异常被捕获，`finally` 子句中的代码都会执行。下面示例中，所有情况下程序都将关闭输入流。
```java
InputStream in = new FileInputStream(...);
try {
	// 1
	code that might throw exceptions
	// 2
} catch (IOException e) {
	// 3
	show error message
	// 4
} finally {
	// 5
	in.close();
}
// 6
```
这段代码中有以下3种情况执行 `finally` 子句：
1. **代码没有抛出异常**。在这种情况下，程序首先执行 `try` 语句块中的全部代码，然后执行 `finally` 子句中的代码。随后，继续执行 `try` 语句块之后的第一条语句。也就是说，执行标注的1、2、5、6 处。
2. **代码抛出一个在 `catch` 子句中捕获的异常**。在上面的示例中就是 `IOException` 异常。在这种情况下，程序将执行 `try` 语句块中的所有代码，直到发生异常为止。此时，将跳过 `try` 语句块中的剩余代码，转去执行与该异常匹配的 `catch` 子句中的代码，最后执行 `finally` 子句中的代码。
	1.	**如果 `catch` 子句没有抛出异常**，程序将执行 `try` 语句块之后的第一条语句。在这里，执行标注1、3、4、5、6处的语句。
	2. **如果 `catch` 子句抛出了一个异常**，异常将被抛回到这个方法的调用者。在这里，执行标注1、3、5 处的语句。
3. **代码抛出了一个异常，但没有任何 `catch` 子句捕获这个异常**。在这种情况下，程序将执行 `try` 语句块中的所有语句，直到有异常被抛出为止。此时，将跳过 `try` 语句块中的剩余代码，然后执行 `finally` 子句中的语句，并将异常抛回给这个方法的调用者。在这里，执行标注1、5处的语句。

`try` 语句可以只有 `finally` 子句、而没有 `catch` 子句。例如，下面这条 `try` 语句中，无论在 `try` 语句块中是否遇到异常，`finally` 子句中的 `in.close()` 语句都会被执行。当然，如果真的遇到一个异常，这个异常将会被重新抛出，并且必须由另一个 `catch` 子句捕获。
```java
InputStream in = ...;
try {
	code that might throw exceptions
} finally {
	in.close();
}
```
事实上，我们认为**在需要关闭资源时，用这种方式使用 `finally` 子句是一种不错的选择**。下面的提示将给出具体的解释。
```java
InputStream in = ...;
try {
	try {
		code that might throw exceptions
	} finally {
		in.close();
	}
} catch (IOException e) {
	show error message
}
```
这里，强烈建议**解耦合 `try/catch` 和 `try/finally` 语句块**。这样可以提高代码的清晰度——内层的 `try` 语句块只有一个职责，就是确保关闭输入流。外层的 `try` 语句块也只有一个职责，就是确保报告出现的错误。**这种解决方案不仅清楚，而且还具有一个功能，就是将会报告 `finally` 子句中出现的错误**。
> 警告：当 `finally` 子句包含 `return` 语句时，有可能出现意想不到的结果。假设你利用 `return` 语句从 `try` 语句块中间退出，而在方法返回前，会执行 `finally` 子句。**如果 `finally` 子句中也有一个 `return` 语句，这个返回值将会覆盖原始的返回值**。请看一个复杂的例子：
> ```java
> public static int f(String s) { 
> 	try {
> 		return Integer.parseInt(s);
> 	} finally {
> 		return 0; // ERROR
> 	}
> }
> ```
> 看起来在 `parseInt("42")` 调用中，`try` 块的体会返回整数42。不过这个方法真正返回之前、会执行 `finally` 子句，这就使得方法最后会返回0，而忽略原来的返回值。
> 更糟糕的是，考虑调用 `parseInt("zero")` 。`Integer.parseInt` 方法会抛出一个 `NumberFormatException` 。然后执行 `finally` 子句。`return` 语句甚至会“吞掉”这个异常！
> **`finally` 子句的体要用于清理资源，不要把改变控制流的语句 `return, throw, break, continue` 放在 `finally` 子句中**。

有时 `finally` 子句也会带来麻烦。例如，清理资源的方法也有可能抛出异常。假设希望能确保——在流处理代码中遇到异常时将流关闭。现在，假设在 `try` 语句块中的代码抛出了一些非 `IOException` 异常，这些异常只有这个方法的调用者才能给予处理。于是执行 `finally` 语句块，并调用 `in.close` 方法，这一方法本身也有可能抛出 `IOException` 异常。**当出现这种情况时，原始的异常将会丢失，转而抛出 `close` 方法的异常**。这会有问题，因为第一个异常很可能更有意思。如果你想做适当的处理，重新抛出原来的异常，代码会变得极其繁琐。
```java
InputStream in = ...;
Exception ex = null;
try {
	try {
		code that might throw exceptions
	} catch (Exception e) {
		ex = e;
		throw e;
	}
} finally {
	try {
		in.close();
	} catch (Exception e) {
		if (ex == null) throw e;
	}
}
```
不过Java 7中关闭资源的处理会容易很多。
## 7.2.5 带资源的 `try` 语句
对于以下代码模式:
```java
open a resource
try {
	work with the resource
} finally {
	close the resource
}
```
假设资源属于一个实现了 `AutoCloseable` 接口的类，Java SE 7为这种代码模式提供了一个很有用的快捷方式。`AutoCloseable` 接口有一个方法：
```java
void close() throws Exception
```
> 注释：另外，**还有一个 `Closeable` 接口。这是 `AutoCloseable` 的子接口，也包令一个 `close` 方法**。不过，这个方法声明为抛出一个 `IOException` 。

带资源的 `try-with-resources` 语句的最简形式为：
```java
try (Resource res = ...) {
	work with res
}
```
**`try` 块退出时，会自动调用 `res.close()`** 。下面给出一个典型的例子，这里要读取一个文件中的所有单词：
```java
try (var in = new Scanner(
	new FileInputStream("/usr/share/dict/words"), StandardCharsets.UTF_8) {
	while (in.hasNext())
		System.out.println(in.next());
}
```
**这个块正常退出时，或存在一个异常时，都会调用 `in.close()` 方法，就好像使用了 `finally` 块一样**。

还可以指定多个资源。例如：
```java
try (var in = new Scanner(
	new FileInputStream("/usr/share/dict/words"), StandardCharsets.UTF_8);
	var out = new PrintWriter("out.txt", StandardCharsets.UTF_8)) {
	while (in.hasNext())
		out.println(in.next().toUpperCase());
}
```
**不论这个块如何退出，`in` 和 `out` 都会关闭**。如果你用常规方式手动编程，就需要两个嵌套的 `try/finally` 语句。

在Java 9中，可以在 `try` 首部中提供之前声明的事实最终变量 *previously declared effectively final variables* ：
```java
public static void printAll(String[] lines, PrintWriter out) {
	try (out) { // effectively final variable
		for (String line : lines)
			out.println(line);
	} // out.close() called here
}
```
上一节已经看到，如果 `try` 块抛出一个异常，而 `close` 方法也抛出一个异常，这就会带来一个难题。`try-with-resources` 语句可以很好地处理这种情况——**原来的异常会重新抛出，而 `close` 方法抛出的异常会被抑制 *suppressed* ，且这些异常将被自动捕获、并由 `addSuppressed` 方法增加到原来的异常**。如果对这些异常感兴趣，可以调用 `getSuppressed` 方法，它会得到「从 `close` 方法抛出并被抑制的异常」的数组。

你肯定不想采用这种常规方式编程。**只要需要关闭资源，就要尽可能使用 `try-with-resources` 语句**。
> 注释：**`try-with-resources` 语句自身也可以有 `catch` 子句和一个 `finally` 子句。这些子句会在关闭资源之后执行**。不过在实际中，一个 `try` 语句中加入这么多内容可能不是一个好主意。

## 7.2.6 分析堆栈轨迹元素
**堆栈轨迹** `stack trace` 是程序执行过程中、某个特定点上所有挂起的方法调用的一个列表 *a listing of all pending method calls at a particular point in the execution of a program* 。肯定已经看到过这种列表，当Java程序因为一个未捕获的异常而终止时，会显示堆栈轨迹。

可以调用 `Throwable` 类的 `printStackTrace` 方法，访问堆栈轨迹的文本描述信息：
```java
var t = new Throwable();
var out = new StringWriter();
t.printStackTrace(new PrintWriter(out));
String description = out.toString();
```
> 注释：在Java 9之前，`Throwable` 类的 `getStackTrace` 方法会生成一个 `StackTraceElement[]` 数组，可以在你的程序中分析这个对象数组。例如：
> ```java
> Throwable t = new Throwable();
> StackTraceElement[] frames = t.getStackTrace();
> for (StackTraceElement frame : frames)
> 	analyze frame
> ```
> 从现在来说，**这个调用的效率不高**，因为它要得到整个堆栈，即使调用者可能只需要几个栈帧。另外，它只允许访问挂起方法的类名，而不能访问类对象。
> 
> 静态的 `Thread.getAllStackTrace` 方法，它可以产生所有线程的堆栈轨迹，下面给出使用这个方法的具体方式：
> ```java
> Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();
> for (Thread t : map.keySet()) {
> 	StackTraceElement[] frames = map.get(t);
> 	analyze frames
> }
> ```

更灵活的方法是使用 `StackWalker` 类，它会生成一个 `StackWalker.StackFrame` 实例，其中每个实例分别描述一个栈帧 *stack frame* ，可以利用以下调用迭代处理这些栈帧：
```java
StackWalker walker = StackWalker.getInstance();
walker.forEach(frame -> analyze frame);
```
如果想以懒方式处理 `Stream<StackWalker.StackFrame>` ，可以调用：
```java
walker.walk(stream -> process stream);
```
利用 `StackWalker.StackFrame` 类的一些方法，可以得到所执行代码行的文件名和行号，以及类对象和方法名。`toString` 方法会生成一个格式化字符串，其中包含所有这些信息。

`stackTrace/StackTraceTest.java` 打印了递归阶乘函数的堆栈轨迹。例如，如果计算 `factorials(3)` ，将会打印下列内容：
```java
factorial(3):
stackTrace.StackTraceTest.factorial(StackTraceTest.java:20)
stackTrace.StackTraceTest.main(StackTraceTest.java:36)
factorial(2):
stackTrace.StackTraceTest.factorial(StackTraceTest.java:20)
stackTrace.StackTraceTest.factorial(StackTraceTest.java:26)
stackTrace.StackTraceTest.main(StackTraceTest.java:36)
factorial(1):
stackTrace.StackTraceTest.factorial(StackTraceTest.java:20)
stackTrace.StackTraceTest.factorial(StackTraceTest.java:26)
stackTrace.StackTraceTest.factorial(StackTraceTest.java:26)
stackTrace.StackTraceTest.main(StackTraceTest.java:36)
return 1
return 2
return 6
```
```java
// stackTrace/StackTraceTest.java
package stackTrace;

import java.util.*;

/**
 * A program that displays a trace feature of a recursive method call.
 */
public class StackTraceTest {
	/**
	 * Computes the factorial of a number
	 * @param n a non-negative integer
	 * @return n != 1 * 2 * ... * n
	 */
	public static int factorial(int n) {
		System.out.println("factorial(" + n + "):");
		var walker = StackWalker.getInstance();
		walker.forEach(System.out::println);

		int r;
		if (n <= 1) r = 1;
		else r = n * factorial(n - 1);
		System.out.println("return " + r);
		return r;
	}

	public static void main(String[] args) {
		try (var in = new Scanner(System.in)) {
			System.out.print("Enter n: ");
			int n = in.nextInt();
			factorial(n);
		}
	}
}
```
> [API] `java.lang.Throwable` 1.0
> - `Throwable(Throwable cause)` 1.4
> - `Throwable(String message, Throwable cause)` 1.4
> 用给定的原因构造一个 `Throwable` 对象。
> - `Throwable initCause(Throwable cause)` 1.4
> 为这个对象设置原因。如果这个对象已经有原因，则抛出一个异常。返回 `this` 引用。
> - `Throwable getCause()` 1.4
> 获得设置为这个对象的原因的异常对象。如果没有设置原因，则返回 `null` 。
> - `StackTraceElement[] getStackTrace()` 1.4
> 获得构造这个对象时调用堆栈的轨迹。
> - `void addSuppressed(Throwable t)` 7
> 为这个异常增加一个“抑制的”异常。这出现在 `try-with-resources` 语句中，其中 `t` 是 `close` 方法抛出的一个异常。
> - `Throwable[] getSuppressed()` 7
> 得到这个异常的所有“抑制的”异常。一般来说，这些是 `try-with-resources` 语句中 `close` 方法拋出的异常。

> [API] `java.lang.Exception` 1.0
> - `Exception(Throwable cause)` 1.4
> - `Exception(String message, Throwable cause)`
> 用给定的“原因”构造一个异常对象。

> [API] `java.lang.RuntimeException` 1.0
> - `RuntimeException(Throwable cause)` 1.4
> - `RuntimeException(String message, Throwable cause)` 1.4
> 用给定的“原因”构造一个 `RuntimeException` 对象。

> [API] `java.lang.StackWalker` 9
> - `static StackWalker getInstance()`
> - `static StackWalker getInstance(StackWalker.Option option)`
> - `static StackWalker getInstance(Set<StackWalker.Option> options)`
> 得到一个 `StackWalker` 实例。选项包括 `StackWalker.Option` 枚举中的 `RETAIN_CLASS_REFERENCE, SHOW_HIDDEN_FRAMES, SHOW_REFLECT_FRAMES` 。
> - `forEach(Consumer<? super StackWalker.StackFrame> action)`
> 在每个栈帧上完成给定的动作，从最近调用的方法开始。
> - `walk(Function<? super Stream<StackWalker.StackFrame>, ? extends T> function)`
> 对一个栈帧流应用给定的函数，返回这个函数的结果。

> [API] `java.lang.StackWalker.StackFrame` 9
> - `String getFileName()`
> 得到包含该元素执行点的源文件的文件名。如果这个信息不可用则返回 `null` 。
> - `int getLineNumber()`
> 得到包含该元素执行点的源文件的行号。如果这个信息不可用则返回-1。
> - `String getClassName()`
> 得到方法包含该元素执行点的类的完全限定名。
> - `String getDeclaringClass()`
> 得到方法包含该元素执行点的类的 `Class` 对象，如果这个栈遍历器 *stack walker* 不是用 `RETAIN_CLASS_REFERENCE` 构造的，则会抛出一个异常。
> - `String getMethodName()`
> 得到包含该元素执行点的方法的方法名。构造器的方法名为 `<init>` ，静态初始化器的方法名为 `<clinit>` 。无法区分同名的重载方法。
> - `boolean isNativeMethod()`
> 如果这个元素的执行点在一个原生方法中，则返回 `true` 。
> - `String toString()`
> 返回一个格式化字符串，包含类和方法名、文件名以及行号（如果这些信息可用）。

> [API] `java.lang.StackTraceElement` 1.4
> - `String getFileName()`
> 返回这个元素运行时对应的源文件名。如果这信息不存在，则返回 `null` 。
> - `int getLineNumber()`
> 返回这个元素运行时对应的源文件行数。如果这个信息不存在，则返回-1。
> - `String getClassName()`
> 返回这个元素运行时对应的类的完全限定名。
> - `String getMethodName()`
> 返回这个元素运行时对应的方法名。构造器名是 `<init>` ，静态初始化器名是 `<clinit>` ，这里无法区分同名的重载方法。
> - `boolean isNativeMethod()`
> 如果这个元素运行时在一个原生方法中，则返回 `true` 。
> - `String toString()`
> 如果存在的话，返回一个包含类名、方法名、 文件名和行数的格式化字符串。

---
# 7.3 使用异常机制的技巧
目前，如何恰当地使用异常机制还有很大争议。有些程序员认为所有的检查型异常都令人厌恶；还有一些程序员认为能拋出的异常量不够。我们认为异常机制（甚至是检查型异常）还是有存在意义。下面给出使用异常机制的几个技巧。
1. **异常处理不能代替简单的测试**
作为一个示例编写了一段代码，试着上百万次地对一个空栈进行退栈操作。在实施退栈操作之前，首先要查看栈是否为空。
   ```java
   if (!s.empty()) s.pop();
   ```
接下来，强行进行退栈操作。然后，捕获 `EmptyStackException` 异常来告知我们不能这样做。
   ```java
   try {
	   s.pop();
   } catch (EmptyStackException e) { }
   ```
在测试的机器上，调用 `isEmpty` 的版本运行时间为646毫秒。捕获 `EmptyStackException` 的版本运行时间为21739毫秒。
可以看出，*与执行简单的测试相比，捕获异常所花费的时间大大超过了前者*，因此使用异常的基本规则是：**只在异常情况下使用异常机制**。
2. **不要过分地细化异常**
很多程序员习惯，将每一条语句都分装在一个独立的 `try` 语句块中。
   ```java
   PrintStream out;
   Stack s;
   for (i = 0; i < 100; i++) {
       try {
           n = s.pop();
       } catch (EmptyStackException e) {
           // stack was empty
       }
       try {
           out.writeInt(n);
       } catch (IOException e) {
           // problem writing to file
       }
   }
   ```
这种编程方式将导致代码量的急剧膨胀。首先看这段代码所完成的任务。在这里，希望从栈中弹出100个数值，然后将它们存入一个文件中。如果栈是空的，则不会变成非空状态；如果文件出现错误，则也很难给予排除。出现上述问题后，这种编程方式无能为力。因此，有必要将整个任务包装在一个 `try` 语句块中，这样，**当任何一个操作出现问题时，整个任务都可以取消**。
   ```java
   try {
       for (i = 0; i < 100; i++) {
           n = s.pop();
           out.writeInt(n);
       } 
   } catch (IOException e) {
       // problem writing to file 
   } catch (EmptyStackException e) {
       // stack was empty
   }
   ```
这段代码看起来清晰多了。这样也满足了异常处理机制的一个承诺，**将正常处理与错误处理分开**。
3. **利用异常层次结构**
**不要只抛出 `RuntimeException` 异常**。应该寻找更加适当的子类或创建自己的异常类。
**不要只捕获 Thowable 异常**，否则，会使程序代码更难读、 更难维护。
**考虑检查型异常与非检查型异常的区别**。检查型异常本来就很庞大，不要为逻辑错误抛出这些异常（例如，反射库的做法就不正确。调用者经常需要捕获那些早已知道不可能发生的异常）。
**如果能将一种异常转换成另一种更加适合的异常，就不要犹豫**。例如，在解析某个文件中的一个整数时，捕获 `NumberFormatException` 异常，然后将它转换成 `IOException` 或 `MySubsystemException` 的一个子类。
4. **不要压制异常** *squelch exceptions*
在Java中，往往强烈地倾向关闭异常 *shut up exceptions* 。如果编写了一个调用另一个方法的方法，而那个方法有可能100年才抛出一个异常，但是，如果你没有将这个异常列在 `throws` 表中，编译器就会报错。你不想把它放在 `throws` 列表中，因为这样一来编译器会对「调用了你的方法的所有方法」报错 *whine* 。因此，你会将这个异常关闭：
   ```java
   public Image loadImage(String s) {
       try {
           // code that threatens to throw checked exceptions
       } catch (Exception e) {} // so there
   }
   ```
现在你的代码就可以通过编译了。除非发生异常，否则它可以正常地运行。即使发生了异常也会被忽略。**如果认为异常非常重要 *are at all important*，就应该对它们进行处理**。
5. **在检测错误时，苛刻 *tough love* 要比放任更好**
当检测到错误的时候，有些程序员担心抛出异常。在用无效的参数调用一个方法时，返回一个虚拟值，还是抛出一个异常，哪种处理方式更好？例如，当栈空时，`Stack.pop` 是返回一个 `null` ，还是抛出一个异常？我们认为：在出错的地方抛出一个 `EmptyStackException` 异常要比在后面抛出一个 `NullPointerException` 异常更好。
6. **不要羞于传递异常**
很多程序员都感觉应该捕获抛出的全部异常。如果调用了一个抛出异常的方法，例如 `FileInputStream` 构造器或 `readLine` 方法，它们就会本能地捕获这些可能产生的异常。其实，**传递异常要比捕获这些异常更好**：
   ```java
   public void readStuff(String filename) 
	   throws IOException { // not a sign of shame! 
       InputStream in = new FileInputStream(filename);
   }
   ```
更高层的方法通常可以更好地通知用户发生了错误，或放弃不成功的命令。**规则5、6可以归纳为"早抛出，晚捕获"**。

---
# 7.4 使用断言
断言是一种常用的防御性编程习语 *defensive programming* 。在下面的小节中，了解如何有效地使用断言。
## 7.4.1 断言的概念
假设确信某个属性符合要求，且代码的执行依赖于这个属性。例如，需要计算 `double y = Math.sqrt(x);` 。我们确信，这里的 `x` 是一个非负数值。原因是：`x` 是另外一个计算的结果，而这个结果不可能是负值；或 `x` 是一个方法的参数，而这个方法要求它的调用者只能提供一个正数。

然而，你还是希望再做一次检查，以避免让“不是一个数”的数值 `NaN` 参与计算操作。当然，也可以抛出一个异常：
```java
if (x < 0) throw new IllegalArgumentException("x < 0");
```
但这段代码会一直保留在程序中，即使测试完毕也不会自动地删除。如果在程序中含有大量这种检查，程序运行起来会相当慢。

==断言机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插入的检测语句将会被自动地移走==。Java语言引人了关键字 `assert` 。这个关键字有两种形式：
```java
assert condition;
assert condition : expression;
```
这两种形式都会对条件进行检测，如果结果为 `false` ，则抛出一个 `AssertionError` 异常。在第二个形式中，表达式将被传入 `AssertionError` 的构造器，并转换成一个消息字符串。
> 注释：“表达式”部分的唯一目的是产生一个消息字符串。`AssertionError` 对象并不存储具体的表达式值，因此，不可能在以后得到这个表达式值。正如JDK文档所描述的那样：如果使用表达式的值，就会鼓励程序员试图从断言中恢复程序的运行，这不符合断言机制的初衷。

要想断言 `x` 是一个非负数值，只需要简单地使用下面这条语句：
```java
assert x >= 0;
```
或将 `x` 的实际值传递给 `AssertionError` 对象，从而可以在后面显示出来。
```java
assert x >= 0 : x;
```
> C++注释：C语言中的 `assert` 宏将断言中的条件转换成一个字符串。当断言失败时，这个字符串将会被打印出来。例如，若 `assert(x >= 0)` 失败，那么将打印出失败条件 `"x >= 0"` 。
> **在Java中，条件并不会自动地成为错误报告中的一部分**。如果希望看到这个条件，就必须将它以字符串的形式传递给 `AssertionError` 对象：`assert x >= 0 : "x >= 0"` 。

## 7.4.2 启用和禁用断言
**在默认情况下，断言被禁用**。可以在运行程序时用 `-enableassertions` 或 `-ea` 选项启用：
```bash
$ java -enableassertions MyApp
```
需要注意的是，**在启用或禁用断言时不必重新编译程序**。启用或禁用断言是类加载器 `class loader` 的功能。当断言被禁用时，类加载器将去除断言代码，因此不会降低程序运行的速度。

也可以**在某个类或整个包中启用断言**，例如这条命令将开启 `MyClass` 类、以及在 `com.mycompany.mylib` 包和它的子包中的所有类的断言。选项 `-ea:...` 将开启默认包中的所有类的断言。
```bash
$ java -ea:MyClass -ea:com.mycompany.mylib MyApp
```
也可以用选项 `-disableassertions` 或 `-da` 禁用某个特定类和包的断言：
```bash
$ java -ea:... -da:MyClass MyApp
```
**有些类不是由类加载器加载，而是直接由虚拟机加载**。可以使用这些开关有选择地启用或禁用那些类中的断言。然而，启用和禁用所有断言的 `-ea` 和 `-da` 开关，不能应用到那些「没有类加载器的“系统类”」上。对于这些系统类来说，需要使用 `-enablesystemassertions/-esa` 开关启用断言。

也可以通过编程，控制类加载器的断言状态。有关这方面的内容参看本节末尾的API注释。
## 7.4.3 使用断言完成参数检查
在Java语言中，给出了3种处理系统错误的机制：
- 抛出一个异常
- 日志 `logging`
- 使用断言

什么时候应该选择使用断言呢？ 请记住下面几点：
- **断言失败是致命的、不可恢复 *unrecoverable* 的错误**。
- **断言检查只用于开发和测试阶段**（这种做法有时候被戏称为“在靠近海岸时穿上救生衣，但在海中央时就把救生衣抛掉吧” *wearing a life jacket when you are close to shore, and throwing it overboard once you are in the middle of the ocean* ）。

因此，**不应使用断言、向程序的其他部分通告发生了可恢复性的错误**，**或者不应作为程序向用户通告问题的手段**。断言只应用于**在测试阶段确定程序内部的错误位置**。

下面看一个十分常见的例子：检查方法的参数。是否应该使用断言来检查非法的下标值或 `null` 引用呢？要想回答这个问题，首先阅读一下这个方法的文档。假设实现一个排序方法。
```java
/**
	Sorts the specified range of the specified array in ascending numerical order.
	The range to be sorted extends from fromIndex, inclusive, to toIndex, exclusive.
	@param a the array to be sorted.
	@param fromIndex the index of the first element (inclusive) to be sorted.
	@param toIndex the index of the last element (exclusive) to be sorted.
	©throws IllegalArgumentException if fromIndex > toIndex
	©throws ArrayIndexOutOfBoundsException if fromIndex < 0 or toIndex > a.length
*/
static void sort(int[] a, int fromIndex, int toIndex)
```
文档指出，如果方法中使用了错误的下标值，那么就会抛出一个异常。这是方法与其调用者之间约定的处理行为。如果实现这个方法，那就必须要遵守这个约定，并抛出表示下标值有误的异常。因此，**这里使用断言不太适宜**。

是否应该断言 `a` 不是 `null` 呢？这也不太适宜。当 `a` 是 `null` 时，这个方法的文档没有指出应采取什么行动。在这种情况下，调用者可以认为这个方法将会成功地返回，而不会抛出一个断言错误。

然而，假设对这个方法的约定做一点微小的改动：
```java
@param a the array to be sorted (must not be null).
```
现在，这个方法的调用者就必须注意：用 `null` 数组调用这个方法是不合法的。这样一来，就可以在这个方法的开头使用断言：
```java
assert a != null;
```
计算机科学家将这种约定称为前置条件 `Precondition` 。最初的方法对参数没有前置条件，即承诺在任何条件下都给予正确的执行。修订后的方法有一个前置条件，即 `a` 非空。如果调用者在调用这个方法时没有提供满足这个前置条件的参数，断言会失败 *all bets are off* ，这个方法就能“为所欲为”。

事实上，由于有这个断言，当方法被非法调用时，它的行为将是难以预料的。有时候会拋出一个断言错误，有时候会产生一个 `null` 指针异常，这完全取决于类加载器的配置。
## 7.4.4 为文档假设使用断言
很多程序员使用注释来（在文档中）说明假设条件 *use comments to document their underlying assumptions* 。看一下[这里](http://docs.oracle.eom/javase/8/docs/technotes/guides/language/assert.html)上的一个示例；
```java
if (i % 3 == 0)
else if (i % 3 = 1)
else // (i % 3 == 2)
```
在这个示例中，使用断言会更好一些。
```java
if (i % 3 == 0) ...
else if (i % 3 == 1) ...
else {
	assert i % 3 == 2;
	...
}
```
当然，如果仔细考虑这个问题，会发现一个更有意思的内容。`i % 3` 会产生什么结果？如果 `i` 是正值，那余数肯定是 `0, 1, 2` 。如果 `i` 是负值，则余数可以是 `-1` 和 `-2` 。因此，实际的假设是 `i` 是非负值，因此，最好在 `if` 语句之前使用下列断言：
```java
assert i >= 0;
```
无论如何，这个示例说明了程序员如何使用断言来进行自我检查。前面已经知道，**断言是一种测试和调试阶段使用的战术性工具**；与之不同，日志是一种在程序整个生命周期都可以使用的战略性工具。下一节将介绍日志。
> [API] `java.lang.ClassLoader` 1.0
> - `void setDefaultAssertionStatus(boolean b)` 1.4
> 对「通过类加载器加载的所有类」来说，如果没有显式地说明类或包的断言状态，就启用或禁用断言。
> - `void setClassAssertionStatus(String className, boolean b )` 1.4 
> 对于给定的类和它的内部类，启用或禁用断言。
> - `void setPackageAssertionStatus(String packageName, bool ean b)` 1.4
> 对于给定包和其子包中的所有类，启用或禁用断言。
> - `void clearAssertionStatus()` 1.4
> 删除所有显式的类和包的断言状态设置，并禁用「所有通过这个类加载器加载的类」的断言。
---
# 7.5 曰志
每个Java程序员都很熟悉，在有问题的代码中插入一些： `System.out.println` 方法调用、来帮助观察程序运行的操作过程。当然，一旦发现问题的根源，就要将这些语句从代码中删去。如果接下来又出现了问题，就需要再插入几个调用 `System.out.println` 方法的语句。日志API就是为了解决这个问题而设计的。下面先讨论这些API的优点。
- **可以很容易地取消全部日志记录，或仅仅取消某个级别的日志**，而且打开和关闭这个操作也很容易。
- **可以很简单地禁止日志记录**，因此，将这些日志代码留在程序中的开销很小。
- **日志记录可以被定向到不同的处理器**，用于在控制台中显示、存储在文件中等。
- **日志记录器和处理器都可以对记录进行过滤**。过滤器可以根据过滤实现器 *filter implementor* 制定的标准丢弃那些无用的记录项。
- **日志记录可以采用不同的方式格式化**，例如纯文本或XML。
- **应用程序可以使用多个日志记录器**，它们使用类似包名的这种具有层次结构的名字，例如 `com.mycompany.myapp` 。
- **在默认情况下，日志系统的配置由配置文件控制**。如果需要的话，应用程序可以替换这个配置。

> 注释：很多应用会使用其他日志框架，如[Log4J2](https://logging.apache.org/log4j/2.x)和[Logback](https://logback.qos.ch)，它们能提供比标准Java日志框架更高的性能。这些框架的API稍有区别。[SLF4J](https://www.slf4j.org)和[Commons Logging](https://commons.apache.org/proper/commons-logging)等日志外观 `logging facades` 提供了一个统一的API，利用这个API，无须重写应用就可以替换日志框架。让人更混乱的是，Log4J2也可以是使用SLF4J的组件的外观 *Log4J 2 can also be a façade to components that use SLF4J* 。
> 
> 这里只介绍标准Java日志框架，很多用途上这个框架已经足够好，而且学习这个框架的API、也可以做好准备去理解其他的框架。

> 注释：Java 9中，Java平台有一个单独的轻量级日志系统，它不依赖于 `java.logging` 模块（这个模块包含标准Java日志框架）。这个系统只用于Java API。如果 `java.logging` 模块存在 *present* ，日志消息会自动转发给它。第三方日志框架可以提供适配器来接收平台日志消息。这里不打算介绍平台日志，因为开发应用程序的程序员不太会用到平台日志。

## 7.5.1 基本曰志
要生成简单的日志记录，可以使用**全局日志记录器** *global logger* 并调用其 `info` 方法：
```java
Logger.getGlobal.info("File->Open menu item selected");
```
在默认情况下，这条记录将会显示以下内容：
```java
May 10, 2013 10:12:15 PM LogginglmageViewer fileOpen
INFO: File->Open menu item selected
```
但是，如果在适当的地方（如 `main` 开始）调用以下语句，将会取消所有的日志。
```java
Logger.getGlobal().setLevel(Level.OFF);
```
## 7.5.2 高级曰志
从前面已经看到“虚拟日志” *logging for dummies* ，下面看更高级的**行业级 *industrial-strength* 日志**。在一个专业的应用程序中，肯定不想将所有的日志都记录到一个全局日志记录器中，可以自定义日志记录器。

可以调用 `getLogger` 方法创建或获取记录器：
```java
private static final Logger myLogger =
	Logger.getLogger("com.mycompany.myapp");
```
> 提示：未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要像上面的例子一样，用静态变量存储日志记录器的引用。
 
**与包名类似，日志记录器名也具有层次结构**。事实上，与包名相比，日志记录器的层次性更强。对于包来说，**包与父包之间没有语义关系**，但**日志记录器的父与子之间将共享某些属性**。例如，如果对 `com.mycompany` 日志记录器设置了日志级别，它的子记录器也会继承这个级别。通常，有以下7个日志记录器级别：
- SEVERE
- WARNING
- INFO
- CONFIG
- FINE
- FINER
- FINEST

**在默认情况下，只记录前3个级别**。也可以设置其他的级別。使用如下语句后，`FINE` 和更高级别的记录都可以记录下来。
```java
logger.setLevel(Level.FINE);
```
另外，还可以**使用 `Level.ALL` 开启所有级别的记录**，或**使用 `Level.OFF` 关闭所有级别的记录**。

所有的级别都有日志记录方法：
```java
logger.warning(message);
logger.fine(message);
```
同时，还可以使用 `log` 方法指定级别，例如：
```java
logger.log(Level.FINE, message);
```
> 提示：默认的日志配置记录了 `INFO` 或更高级别的所有记录，因此，**应该使用 `CONFIG, FINE, FINER, FINEST` 级别来记录那些有助于诊断、但对用户意义不大的调试信息**。

> 警告：如果将记录级别设置为比 `INFO` 更低的级别，还需要修改日志处理器的配置。**默认的日志处理器会抑制低于 `INFO` 级别的信息**。更加详细的内容参看下节。

默认的日志记录 *default log record* 将显示「包含日志调用的类名和方法名 *the name of the class and method that contain* the logging call* 」（根据调用堆栈得出）。但如果虚拟机对执行过程进行了优化，就得不到准确的调用信息。此时，可以调用 `logp` 方法获得调用类和方法 *the calling class and method* 的确切位置，这个方法的签名为：
```java
void logp(Level l, String className, String methodName, String message)
```
下面有一些用来跟踪执行流的便利方法：
```java
void entering(String className, String methodName)
void entering(String className, String methodName, Object param)
void entering(String className, String methodName, Object[] params)
void exiting(String className, String methodName)
void exiting(String className, String methodName, Object result)
```
例如，如下这些调用将生成 `FINER` 级别和以字符串 `ENTRY` 和 `RETURN` 开始的日志记录。
```java
int read(String file, String pattern) {
	logger.entering("com.mycompany.mylib.Reader", "read",
		new Object[] { file, pattern });
	...
	logger.exiting("com.mycompany.mylib.Reader", "read", count);
	return count;
}
```
> 注释：在未来，带 `Object[]` 参数的曰志记录方法可能会被重写，以便支持可变参数列表 *varargs* 。此后就可以用 `logger.entering("com.mycompany.mylib.Reader", "read", file, pattern)` 格式调用这个方法了。

**记录日志的常见用途是记录那些不可预料的异常**。可以使用下面两个方法、在日志记录中包含异常的描述。其中，调用 `throwing` 可以记录一条 `FINER` 级别的记录和一条以 `THROW` 开始的信息。
```java
void throwing(String className, String methodName, Throwable t)
void log(Level l, String message, Throwable t)
```
典型的用法是：
```java
if (...) {
	IOException exception = new IOException("...");
	logger.throwing("com.mycompany.mylib.Reader", "read", exception);
	throw exception;
}
```
还有：
```java
try {
	...
} catch (IOException e) {
	Logger.getLogger("com.mycompany.myapp").log(Level.WARNING, "Reading image", e);
}
```
## 7.5.3 修改日志管理器配置
可以通过**编辑配置文件**来修改日志系统的各个属性。在默认情况下，配置文件存在于：`jre/lib/logging.properties`（Java 9之前）或 `conf/logging.properties` 。

要想使用另一个配置文件，就要将 `java.util.logging.config.file` 属性设置为配置文件的存储位置。为此，要用下列命令启动应用程序：
```bash
$ java -Djava.util.logging.config.file=configFile MainClass
```
要想修改默认的日志级别，就需要编辑配置文件，并修改这一行：
```bash
.level=INFO
```
可以通过添加下面一行、来指定自定义日志记录器的日志级别。也就是说，在日志记录器名后面添加后缀 `.level` 。
```bash
com.mycompany.myapp.level=FINE
```
稍后可以看到，**日志记录并不将消息发送到控制台上，这是处理器的任务**。另外，**处理器也有级别**。要想在控制台上看到 `FINE` 级别的消息，就需要进行下列设置
```bash
java.util.logging.ConsoleHandler.level=FINE
```
> 警告：**日志管理器配置中的属性设置不是系统属性**，因此，用 `-Dcom.mycompany.myapp.level=FINE` 启动应用程序不会对日志记录器产生任何影响。

**日志管理器在JVM启动过程中初始化，这在 `main` 方法执行之前完成**。如果想要定制日志属性，但没有用 `-Djava.util.logging.config.file` 命令行选项启动应用，可以在程序中调用 `System.setProperty("java.util.logging.config.file", file)`
。不过这样一来，还必须调用 `LogManager.getLogManager().readConfiguration()` 来重新初始化曰志管理器。

在Java 9中，可以通过调用以下方法更新日志配置。这样就会从 `java.util.logging.config.file` 系统属性指定的位置读取一个新配置，然后应用这个映射器来解析老配置或新配置中所有键的值，映射器是一个 `Function<String, BiFunction<String, String, String>>` ，它将现有配置中的键映射到替换函数 *replacement functions* 。每个替换函数接收到与键关联的老值和新值（或如果没有关联的值则得到 `null` ），生成一个替换 *produces a replacement* ，或如果要在更新中删除这个键则返回 `null` 。
```java
LogManager.getLogManager().updateConfiguration(mapper);
```
这听起来相当复杂，来看几个例子。==一种很有用的映射机制是合并老配置和新配置，如果一个键在老配置和新配置中都出现，则优先选择新值==。这样一个映射器 `mapper` 就是：
```java
key -> ((oldValue, newValue) -> newValue == null ? oldValue : newValue)
```
或者可能只想更新以 `com.mycompany` 开头的键，其他的键保持不变：
```java
key -> key.startsWith("com.mycompany")
	? ((oldValue, newValue) -> newValue)
	: ((oldValue, newValue) -> oldValue)
```
还可以**使用 `jconsole` 程序，改变一个正在运行的程序的日志级别**。有关信息参见[官网文档](www.oracle.com/technetwork/articles/java/jconsole-1564139.html#LoggingControl)。
> 注释：日志属性文件由 `java.util.logging.LogManager` 类处理。可以通过将 `java.util.logging.manager` 系统属性设置为某个子类的名字、来指定一个不同的日志管理器。
> 
> 或者，可在保留标准日志管理器的同时，而绕过日志属性文件中的初始化 *bypass the initialization from the logging properties file* 。设置 `java.util.logging.config.class` 系统属性为某个类名，该类再以另外某种方式设置日志管理器 *log manager* 属性。
> 
> 有关 `LogManager` 类的详细内容参看API文档。
 
## 7.5.4 本地化
我们可能希望将日志消息本地化，以便让全球用户都可以阅读。应用程序的国际化问题将在卷II第5章讨论。下面简要说明在本地化日志消息时需要牢记的一些要点。

本地化的应用程序包含**资源包** `resource bundle` 中的本地特定信息。资源包包括一组映射，分别对应各个本地化环境 *locale*（如美国或德国）。例如，某个资源包可能将字符串 `"readingFile"` 映射成英文的 `"Reading file"` 或德文的 `"Achtung! Datei wird eingelesen` 。

**一个程序可以包含多个资源包**，例如一个用于菜单，其他用于日志消息。每个资源包都有一个名字（如 `com.mycompany.logmessages` ）。**要想将映射添加到一个资源包中，需要对应每个本地化环境提供一个文件**。英文消息映射位于 `com/mycompany/logmessages_en.properties` 文件中；德文消息映射位于 `com/mycompany/logmessages_de.properties` 文件中（ `en` 和 `de` 是语言编码）。可以将这些文件与应用程序的类文件放在一起，以便 `ResourceBundle` 类自动地对它们进行定位。这些文件都是纯文本文件，包含如下的条目：
```java
readingFile=Achtung! Datei wird eingelesen
renamingFile=Datei wird umbenannt
```
请求一个日志记录器时，可以指定一个资源包：
```java
Logger logger =
	Logger.getLogger(loggerName, "com.mycompany.logmessages");
```
然后，为日志消息指定资源包的关键字，而不是实际的日志消息字符串。
```java
logger.info("readingFile");
```
通常需要在本地化的消息中增加一些参数，因此，消息可能包括占位符 `{0}, {1}` 等。例如，要想在日志消息中包含文件名，可如下使用占位符：
```java
Reading file {0}.
Achtung! Datei {0} wird eingelesen.
```
然后，通过调用下面的一个方法向占位符传递具体的值：
```java
logger.log(Level.INFO, "readingFile", fileName);
logger.log(Level.INFO, "renamingFile", new Object[] { oldName, newName });
```
或者在Java 9中，可在 `logrb` 方法中指定资源包对象（而不是名字）：
```java
logger.logrb(Level.INFO, bundle, "renamingFile", oldName,
newName);
```
## 7.5.5 处理器
**在默认情况下，日志记录器将记录发送到 `ConsoleHandler` 中，并由它输出到 `System.err` 流中**。具体地，日志记录器会将记录发送到父处理器中，而最终的祖先处理器（命名为 `""` ）有一个 `ConsoleHandler` 。

与日志记录器一样，处理器也有日志级别 *logging level* 。**对于一个要被记录的日志记录，它的日志级别必须高于日志记录器和处理器的阈值** *be above the threshold of both the logger and the handler* 。日志管理器 *log manager* 配置文件设置的「默认控制台处理器的日志记录级别」为：
```java
java.util.logging.ConsoleHandler.level=INFO
```
**要想记录 `FINE` 级别的日志，就必须修改配置文件中的默认日志记录器级别和处理器级别** *both the default logger level and the handler level* 。另外，还可以绕过配置文件，安装自己的处理器。
```java
Logger logger = Logger.getLogger("com.mycompany.myapp");
logger.setLevel(Level.FINE);
logger.setUseParentHandlers(false);
var handler = new ConsoleHandler();
handler.setLevel(Level.FINE);
logger.addHandler(handler)；
```
**在默认情况下，一个日志记录器将记录发送到 *both to* 自己的处理器和父处理器**。我们的日志记录器是祖先日志记录器（命名为 `""` ）的子类，而这个祖先日志记录器将会把「所有等于或高于 `INFO` 级別的记录」发送到控制台。然而，我们并不想两次看到这些记录。因此，我们将 `useParentHandlers` 属性设置为 `false` 。

要想将日志记录发送到其他地方，就要添加其他的处理器。日志API为此提供了两个很有用的处理器，一个是 `FileHandler` ；另一个是 `SocketHandler` 。`SocketHandler` 将记录发送到指定的主机和端口，而更令人感兴趣的是 `FileHandler` ，它可以将记录收集到文件中。

可以如下直接将记录发送到一个默认的文件处理器 *default file handler* ：
```java
FileHandler handler = new FileHandler();
logger.addHandler(handler);
```
这些记录被发送到用户主目录的 `javan.log` 文件中，`n` 是保证文件唯一的一个编号。如果用户系统没有主目录（例如，在Windows95/98/ME中），文件就存储在 `C:\Window` 这样的默认位置上。默认情况下，记录被格式化为XML。下面是一个典型的日志记录的形式：
```xml
<record>
	<date>2002-02-04T07:45:15</date>
	<millis>1012837515710</nillis>
	<sequence>l</sequence>
	<logger>com.mycompany.myapp</logger>
	<level>INFO</level>
	<class>com.mycompany.mylib.Reader</class>
	<method>read</method>
	<thread>10</thread>
	<message>Reading file corejava.gif</message>
</record>
```
可以通过**设置日志管理器配置文件中的不同参数**（参看表7-1），或利用其他的构造器（参看本节给出的API注释）来修改文件处理器的默认行为。
![表7-1 文件处理器配置参数](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210171621113.png)

也有可能不想使用默认的日志文件名，因此应该使用另一种模式，例如，`％h/myapp.log`（有关模式变量的解释见表7-2）。
 ![表7-2 日志记录文件模式变量](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210171623504.png)

**如果多个应用程序（或同一个应用程序的多个副本）使用同一个日志文件，就应该开启 `append` 标志**。另外，应该在文件名模式中使用 `％u` ，以便每个应用程序创建日志的唯一副本 *each application creates a unique copy of the log* 。

开启文件循环功能也是一个不错的主意。日志文件以循环序列的形式保存（如 `myapp.log.0, myapp.log.1, myapp.log.2` 等），只要文件超出了大小限制，最旧的文件就会被删除，其他的文件将重新命名，同时创建一个新文件，其生成号为0。
> 提示：很多程序员将曰志记录作为辅助文档、提供给技术支持人员。如果程序的行为有误，用户就可以发回日志文件、以找到错误的原因 。在这种情况下，应该开启 `append` 标志，或使用循环日志，也可以两个功能同时使用。

还可以**通过扩展 `Handler` 类或 `StreamHandler` 类自定义处理器**。在本节结尾的示例程序中，就定义了这样一个处理器，这个处理器将在窗口中显示日志记录（如图7-2所示）。
![图7.2 在窗口显示日志记录的日志处理器](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210171655106.png)
这个处理器扩展了 `StreamHandler` 类，并安装了一个流。这个流的 `write` 方法将流输出显示到一个文本区中。
```java
class WindowHandler extends StreamHandler {
	public WindowHandler() {
		...
		var output = new JTextArea();
		
		setOutputStream(new OutputStream() { // an object of an inner class extending OutputStream
			public void write(int b) {} // not called
			public void write(byte[] b, int off, int len) {
				output.append(new String(b，off，len));
			}
		});
	}
	...
}
```
使用这种方式只存在一个问题，这就是**处理器会缓存记录** *the handler buffers the records* ，并且只有在缓存满的吋候才将它们写入流中，因此，需要覆盖 `publish` 方法，以便在处理器获得每个记录之后刷新输出缓冲区。
```java
class WindowHandler extends StreamHandler {
	public void publish(LogRecord record) {
		super.publish(record);
		flush();
	}
}
```
如果希望编写更加复杂的流处理器，就应该扩展 `Handler` 类，并自定义 `publish, flush, close` 方法。
## 7.5.6 过滤器
在默认情况下，**过滤器会根据日志记录的级别进行过滤**。每个日志记录器和处理器都有一个**可选的过滤器**来完成附加的过滤。另外，可以通过实现 `filter` 接口并定义下列方法、来自定义过滤器。
```java
boolean isLoggable(LogRecord record)
```
在这个方法中，可以利用自己喜欢的标准、分析日志记录，返回 `true` 来表示这些记录应该包含在日志中。例如，某个过滤器可能只对 `entering` 方法和 `exiting` 方法产生的消息感兴趣，这个过滤器可以调用 `record.getMessage()` 方法，并査看这个消息是否用 `ENTRY` 或
`RETURN` 开头。

要想将一个过滤器安装到一个日志记录器或处理器中，只需要调用 `setFilter` 方法就可以了。注意，**同一时刻最多只能有一个过滤器**。
## 7.5.7 格式化器
`ConsoleHandler` 类和 `FileHandler` 类可以生成文本和XML格式的日志记录，但也可以自定义格式。这需要扩展 `Formatter` 类并覆盖下面这个方法：
```java
String format(LogRecord record)
```
**可以根据自己的需要，以任何方式对记录中的信息进行格式化，并返回结果字符串**。在 `format` 方法中，可能会调用下面这个方法：
```java
String formatMessage(LogRecord record)
```
这个方法对记录中的消息部分进行格式化，将替换参数并应用本地化处理。

很多文件格式（如XML) 需要在已格式化的记录的前后、加上一个头部和尾部。在这个例子中，要覆盖下面两个方法：
```java
String getHead(Handler h)
String getTail(Handler h)
```
最后，调用 `setFormatter` 方法将格式化器安装到处理器中。
## 7.5.8 日志技巧
面对日志记录如此之多的可选项，很容易让人忘记最基本的东西。下面总结了一些最常用的操作。
1. 为一个简单的应用程序，选择一个日志记录器。**可以把日志记录器命名为与主应用程序包一样的名字**，例如 `com.mycompany.myprog` ，这是一种好的编程习惯。总是可以通过调用下列方法得到日志记录器。
   ```java
   Logger logger = Logger.getLogger("com.mycompany.myprog");
   ```
为了方便起见，可能希望为「有大量日志记录活动的类」增加静态字段：
   ```java
   private static final Logger logger = 
	   Logger.getLogger("com.mycompany.nyprog");
   ```
2. 默认的日志配置将「级别等于或高于 `INFO` 级别的所有消息」记录到控制台。用户可以覆盖这个默认配置。但如前所述，改变配置需要做相当多工作。因此，**最好在你的应用中安装一个更适宜的默认配置**。
下列代码**确保将所有的消息记录到应用程序特定的一个文件** *an application-specific file* 中。可以将这段代码放置在应用程序的 `main` 方法中。
   ```java
if (System.getProperty("java.util.logging.config.class") == null
	&& System.getProperty("java.util.logging.config.file") == null) {
	try {
		Logger.getLogger("").setLevel(Level.ALL);
		final int LOG_ROTATION_COUNT = 10;
		Handler handler = new FileHandler("%h/myapp.log", 0, LOG_ROTATION_COUNT);
		Logger.getLogger("").addHandler(handler);
	} catch (IOException e) {
		logger.log(Level.SEVERE, "Can't create log file handler", e);
	}
}
   ```
3. 现在，可以记录自己想要的内容了。但需要牢记：**所有级别为 `INFO, WARNING, SEVERE` 的消息都将显示到控制台上**。因此，最好只将对程序用户有意义的消息设置为这几个级别。**将程序员想要的日志记录设定为 `FINE` 是一个很好的选择**。
**想要调用 `System.out.println` 时，可以换成发出以下的日志消息**：
   ```java
logger.fine("File open dialog canceled");
   ```
**记录那些预料以外的异常也是一个不错的想法**，例如：
   ```java
try {
	...
} catch (SonreException e) {
	logger.log(Level.FINE, "explanation", e);
}
   ```
`logging/LoggingImageViewer.java` 利用上述技巧，还做了一些调整：日志记录消息还会显示在一个日志窗口中。
```java
// logging/LoggingImageViewer.java
package logging;

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.logging.*;
import javax.swing.*;

/**
 * A modification of the image viewer program that logs various events.
 */
public class LoggingImageViewer {
	public static void main(String[] args) {
		if (System.getProperty("java.util.logging.config.class") == null
			&& System.getProperty("java.util.logging.config.file") == null) {
			try {
				Logger.getLogger("com.horstmann.corejava").setLevel(Level.ALL);
				final int LOG_ROTATION_COUNT = 10;
				var handler = new FileHandler("%h/LoggingImageViewer.log", 0, LOG_ROTATION_COUNT);
				Logger.getLogger("com.horstmann.corejava").addHandler(handler);
				
			} catch (IOException e) {
				Logger.getLogger("com.horstmann.corejava").log(Level.SEVERE,
				"Can't create log file handler", e);
			}
		}
		EventQueue.invokeLater(() -> {
			var windowHandler = new WindowHandler();
			windowHandler.setLevel(Level.ALL);
			Logger.getLogger("com.horstmann.corejava").addHandler(windowHandler);
			var frame = new ImageViewerFrame();
			frame.setTitle("LoggingImageViewer");
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			Logger.getLogger("com.horstmann.corejava").fine("Showing frame");
			frame.setVisible(true);
		}
	}
}

/**
 * The frame that shows the image.
 */
class ImageViewerFrame extends JFrame {
	private static final int DEFAULT_WIDTH = 300;
	private static final int DEFAULT_HEIGHT = 400;

	private JLabel label;
	private static Logger logger = Logger.getLogger("com.horstmann.corejava");

	public ImageViewerFrame() {
		logger.entering("ImageViewerFrame", "<init>");
		setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);

		// set up menu bar
		var menuBar = new JMenuBar();
		setJMenuBar(menuBar);

		var openItem = new JMenuItem("Open");
		menu.add(openItem);
		openItem.addActionListener(new FileOpenListener());

		var exitItem = new JMenuItem("Exit");
		menu.add(exitItem);
		exitItem.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				logger.fine("Exiting.");
				System.exit(0);
			}
		});
		
		// use a label to display the images
		label = new JLabel();
		add(label);
		logger.exiting("ImageViewerFrame", "<init>");
	}

	private class FileOpenListener implements ActionListener {
		public void actionPerformed(ActionEvent event) {
			logger.entering("ImageViewerFrame.FileOpenListener", "actionPerformed", event);

			// set up file chooser
			var chooser = new JFileChooser();
			chooser.setCurrentDirectory(new File("."));

			// accept all files ending with .gif
			chooser.setFileFilter(new javax.swing.filechooser.FileFilter() {
				public boolean accept(File f) {
					return f.getName().toLowerCase().endsWith(".gif") || f.isDirectory();
				}

				public String getDescription() {
					return "GIF Images";
				}
			});

			// show file chooser dialog
			int r = chooser.showDialog(ImageViewerFrame.this);

			// if image file accepted, set it as icon of the label
			if (r == JFileChooser.APPROVE_OPTION) {
				String name = chooser.getSelectedFile().getPath();
				logger.log(Level.FINE, "Reading file {0}", name);
				label.setIcon(new ImageIcon(name));
			} else logger.fine("File open dialog canceled.");
			logger.exiting("ImageViewerFrame.FileOpenListener", "actionPerformed");
		}
	}
}
							   
/**
 * A handler for displaying log records in a window
 */
class WindowHandler extends StreamHandler {
	private JFrame frame;
	public WindowHandler() {
		frame = new JFrame();
		var output = new JTextArea();
		output.setEditable(false);
		frame.setSize(200, 200);
		frame.add(new JScrollPane(output));
		frame.setFocusableWindowState(false);
		frame.setVisible(true);
		setOutputStream(new OutputStream() {
			public void write(int b) {
				// not called
			}
			public void write(byte[], int off, int len) {
				output.append(new String(b, off, len));
			}
		});
	}

	public void publish(LogRecord record) {
		if (!frame.isVisible()) return;
		super.publish(record);
		flush();
	}
}
```
> [API] `java.util.logging.Logger`
> - `Logger getLogger(String 1oggerName)`
> - `Logger getLogger(String 1oggerName, String bund eName)`
> 获得给定名字的日志记录器。如果这个日志记录器不存在，创建一个日志记录器。参数 `loggerName` 需要是具有层次结构的日志记录器名。例如，`com.mycompany.myapp` 。本地化消息位于名为 `bundleName` 的资源包中。
> - `void severe(String message)`
> - `void warning(String message)`
> - `void info(String message)`
> - `void config(String message)`
> - `void fine(String message)`
> - `void finer(String message)` 
> - `void finest(String message)`
> 记录一个日志记录，包括方法名指示的级别和给定的消息。
> - `void entering(String className, String methodName)`
> - `void entering(String className, String methodName, Object param)`
> - `void entering(String className, String methodName, Object[] param)`
> - `void exiting(String className, String methodName)`
> - `void exiting(String className, String methodName, Object result)`
> 记录一个描述进入/退出方法（有给定的参数和返回值）的日志记录。
> - `void throwing(String className, String methodName, Throwable t)`
> 记录一个描述拋出给定异常对象的日志记录。
> - `void log(Level level, String message)`
> - `void log(Level level, String message, Object obj)`
> - `void log(Level level, String message, Object[] objs)`
> - `void log(Level level, String message, Throwable t)`
> 记录一个**给定级别和消息的日志记录**，其中可以包括对象或可抛出对象。要想包括对象，消息中必须包含格式化占位符 `{0}, {1}` 等。
> - `void logp(Level level, String className, String methodName, String message)`
> - `void logp(Level level, String className, String methodName, String message, Object obj)`
> - `void logp(Level level, String className, String methodName, String message, Object[] objs)`
> - `void logp(Level level, String className, String methodName, String message, Throwable t)`
> 记录一个**有给定级别、准确的调用者信息和消息**的日志记录，其中可以包括对象或可抛出对象。
> - `void logrb(Level level, String className, String methodName, ResourceBundle bundle, String message, Object... params)` 9
> - `void logrb(Level level, String className, String methodName, ResourceBundle bundle, String message, Throwable thrown)` 9
> 记录一个**有给定级别、准确的调用者信息、资源包名和消息**的日志记录，其中可以包括对象或可拋出对象。
> - `Level getLevel()`
> - `void setLevel(Level l)`
> 获得和设置这个日志记录器的级别。
> - `Logger getParent()`
> - `void setParent(Logger l)`
> 获得和设置这个日志记录器的父日志记录器。
> - `Handler[] getHandlers()`
> 获得这个日志记录器的所有处理器。 
> - `void addHandler(Handler h)`
> - `void removeHandler(Handler h)`
> 增加或删除这个日志记录器中的一个处理器。
> - `boolean getUseParentHandlers()`
> - `void setUseParentHandlers(boolean b)`
> 获得和设置 `use parent handler` 属性。如果这个属性是 `true` ，则日志记录器会将全部的日志记录转发给它的父处理器。
> - `Filter getFilter()`
> - `void setFilter(Filter f)`
> 获得和设置这个日志记录器的过滤器。

> [API] `java.util.logging.Handler` 1.4
> - `abstract void publish(LogRecord record)`
> 将日志记录发送到希望的目的地。
> - `abstract void flush()`
> 刷新输出所有已缓冲的数据。
> - `abstract void close()`
> 刷新输出所有已缓冲的数据，并释放所有相关的资源。
> - `Filter getFilter()`
> - `void setFilter(Filter f)`
> 获得和设置**这个处理器的过滤器**。
> - `Formatter getFormatter()`
> - `void setFormatter(Formatter f)`
> 获得和设置**这个处理器的格式化器**。
> - `Level getLevel()`
> - `void setLevel(Level l)`
> 获得和设置这个处理器的级别。

> [API] `java.util.logging.ConsoleHandler` 1.4
> - `ConsoleHandler()`
> 构造一个新的控制台处理器。

> [API] `java.util.logging.FileHandler` 1.4
> - `FileHandler(String pattern)`
> - `FileHandler(String pattern, boolean append)`
> - `FileHandler(String pattern, int limit, int count)`
> - `FileHandler(String pattern, int limit, int count, boolean append)`
> 构造一个文件处理器。参数 `pattern` 是构造日志文件名的模式，格式参见表7-2列出的模式变量。`limit` 是在打开一个新日志文件之前，日志文件可以包含的近似最大字节数。`count` 是循环序列的文件数量。如果 `append` 为 `true` ，记录则应追加在一个已存在的日志文件尾部。

> [API] `java.util.logging.LogRecord` 1.4
> - `Level getLevel()`
> 获得这个日志记录的记录级别。
> - `String getLoggerName()`
> 获得「正在记录这个日志记录的日志记录器」的名字。
> - `ResourceBundle getResourceBundle()`
> - `String getResourceBundleName()`
> 获得用于本地化消息的资源包或资源包的名字。如果没有获得，则返回 `null` 。
> - `String getMessage()`
> 获得本地化和格式化之前的原始消息。
> - `Object[] getParameters()`
> 获得参数对象。如果没有提供，则返回 `null` 。
> - `Throwable getThrown()`
> 获得被拋出的对象。如果没有提供，则返回 `null` 。
> - `String getSourceClassName()`
> - `String getSourceMethodName()`
> 获得记录这个日志记录的代码区域。这个信息有可能是由日志记录代码提供的，也有可能是自动从运行时堆栈推测出来的。如果日志记录代码提供的值有误，或运行时代码由于被优化而无法推测出确切的位置，这两个方法的返回值就有可能不准确。
> - `long getMillis()`
> 获得创建时间。以毫秒为单位（从1970年开始）。
> - `long getSequenceNumber()`
> 获得这个日志记录的唯一序列序号。
> - `int getThreadID()`
> 获得创建这个日志记录的线程的唯一ID。这些ID是由 `LogRecord` 类分配的，并且与其他线程的ID无关。

> `java.util.logging.LogManager` 1.4
> - `static LogManager getLogManager()`
> 获得全局 `LogManager` 实例。
> - `void readConfiguration()`
> - `void readConfiguration(InputStream in)`
> 从系统属性 `java.util.logging.config.file` 指定的文件或给定的输入流读取日志配置。
> - `void updateConfiguration(InputStream in, Function<String,BiFunction<String,String,String>> mapper)` 9
> - `void updateConfiguration(Function<String,BiFunction<String,String,String>> mapper)` 9
> 将日志配置与系统属性 `java.util.logging.config.file` 指定的文件或给定的输入流合并，参见7.5.3节，其中给出了映射器参数的描述。

> [API] `java.util.logging.Filter` 1.4
> - `boolean isLoggable(LogRecord record)`
> 如果给定日志记录需要记录，则返回 `true` 。

> `java.util.logging.Formatter` 1.4
> - `abstract String format(LogRecord record)`
> 返回对日志记录格式化后得到的字符串。
> - `String getHead(Handler h)`
> - `String getTail(Handler h)`
> 返回应出现在包含日志记录的文档的开头和结尾的字符串。超类 `Formatter` 定义了这些方法，它们只返回空字符串。如果必要的话，可以对它们进行覆盖。
> - `String formatMessage(LogRecord record)`
> 返回日志记录的本地化和格式化消息部分 *the localized and formatted message part of the log record* 。

---
# 7.6 调试技巧
假设你编写了一个程序，捕获和恰当处理了所有的异常、以保证它万无一失，然后运行这个程序，但还是出现问题，现在该怎么办呢？当然，如果有一个方便且功能强大的调试器就太好了。调试器是Eclipse、Intellij这类专业集成开发环境的一部分。在启动调试器之前，本节先给出一些有价值的建议。

1. 可以用下面的方法打印或记录任意变量的值：
   ```java
System.out.println("x=" + x);
   ```
或
   ```java
Logger.getGlobal().info("x=" + x);
   ```
如果 `x` 是一个数值，则会被转换成等价的字符串。如果 `x` 是一个对象，那么Java就会调用这个对象的 `toString` 方法。**要想获得隐式参数对象的状态，就可以打印 `this` 对象的状态**。
   ```java
Logger.getGlobal().info("this=" + this);
   ```
Java类库中的绝大多数类都覆盖了 `toString` 方法，以便提供有用的类信息。这样会使调试更加便捷。**在自定义的类中，也应该这样做**。
2. 一个不太为人所知但却非常有效的技巧，是**在每一个类中放置一个单独的 `main` 方法，这样可以对每个类提供一个单元测试桩 *stub* ，能够独立地测试类**。
   ```java
public class MyClass {
	methods and fields
	...
	public static void main(String[] args) {
		test code
	}
}
   ```
可以创建一些对象，调用所有的方法，并检测每个方法是否能正确地运行。另外，**可以为每个类保留一个 `main` 方法，然后分别为每个文件调用Java虚拟机进行运行测试**。在运行applet时，这些 `main` 方法不会被调用，而在运行应用程序时，Java 虚拟机只调用启动类的 `main` 方法。
3. 如果喜欢使用前面讲的技巧，应该到[http://junit.org](http://junit.org)网站上査看下JUnit。JUnit是一个非常流行的单元测试框架，利用它可以很容易地组织测试用例套件。**只要修改类，就需要运行测试**。一旦发现bug，还要补充一些其他的测试用例。
4. **日志代理** *logging proxy* 是一个「截获方法调用、记录日志、然后调用超类中的方法的子类」的对象 *an object of a subclass that intercepts method calls, logs them, and then calls the superclass* 。例如，如果在调用 `Random` 类的 `nextDouble` 方法时出现了问题，就可以如下以**匿名子类实例**的形式创建一个代理对象：
   ```java
Random generator = new Random() {
	public double nextDouble() {
		double result = super.nextDouble();
		Logger.getGlobal().info("nextDouble: " + result);
		return result;
	}
};
   ```
只要调用 `nextDouble` 方法，就会产生一个日志消息。要想知道谁调用了这个方法，还可以生成一个堆栈轨迹。
5. **利用 `Throwable` 类提供的 `printStackTrace` 方法，可以从任一个异常对象中获得堆栈轨迹**。下面的代码将捕获任意异常、打印异常对象和堆栈轨迹，然后重新拋出异常，以便能找到相应的处理器。
   ```java
try {
	...
} catch (Throwable t) {
	t.printStackTrace();
	throw t;
}
   ```
不一定要通过捕获异常来生成堆栈轨迹。只要在代码的某个位置插入下面这条语句，就可以获得堆栈轨迹：`Thread.dumpStack()` 。
6. —般来说，堆栈轨迹显示在 `System.err` 上。**如果想要记录或显示堆栈轨迹，可以如下将它捕获到一个字符串中**：
   ```java
   var out = new StringWriter();
   new Throwable().printStackTrace(new PrintWriter(out));
   String description = out.toString();
   ```
7. 通常，将一个程序中的错误信息保存在一个文件会很有用。然而，错误被发送到 `System.err` 中，而不是 `System.out` 。因此，不能通过运行下面的语句获取它们：
   ```bash
$ java MyProgram > errors.txt
   ```
而是**如下捕获错误流**：
   ```bash
$ java MyProgram 2> errors.txt
   ```
要想**在同一个文件中同时捕获 `System.err` 和 `System.out`** ，需要使用下面这条命令：
   ```bash
$ java MyProgram 1> errors.txt 2>&1
   ```
这条命令在bash和Windows shell中都有效。
8. **让未捕获的异常的堆栈轨迹显示在 `System.err` 中，并不是一个很理想的方法**。如果最终用户碰巧看到这些消息、会很慌乱，而且在真正需要诊断错误原因时，却又无法得到这些消息。比较好的方法是，**将这些内容记录到一个文件中**。可以调用静态方法 `Thread.setDefaultUncaughtExceptionHandler` 改变非捕获异常的处理器：
   ```java
Thread.setDefaultUncaughtExceptionHandler(
	new Thread.UncaughtExceptionHandler() {
		public void uncaughtException(Thread t, Throwable e) {
			save information in log file
		}
	}
);
   ```
9. **要想观察类的加载过程，启动JVM时可以使用 `-verbose` 标志**。这样就可以看到如下所示的输出结果：
   ```java
[0.012s][info][class,load] opened: /opt/jdk-
9.0.1/lib/modules
[0.034s][info][class,load] java.lang.Object source: jrt:/java.base
[0.035s][info][class,load] java.io.Serializable source: jrt:/java.base
[0.035s][info][class,load] java.lang.Comparable source: jrt:/java.base
[0.035s][info][class,load] java.lang.CharSequence source: jrt:/java.base
[0.035s][info][class,load] java.lang.String source: jrt:/java.base
[0.036s][info][class,load] java.lang.reflect.AnnotatedElement source: jrt:/java.base
[0.036s][info][class,load] java.lang.reflect.GenericDeclaration source: jrt:/java.base
[0.036s][info][class,load] java.lang.reflect.Type source: jrt:/java.base ...
   ```
有时候，这种方法有助于诊断由于类路径引发的问题。
10. **`-Xlint` 选项告诉编译器找出常见的代码问题**。例如，如果使用命令 `javac -Xlint:fall through` 编译——当 `switch` 语句中缺少 `break` 语句时，编译器就会给出报告（术语 `lint` 最初用来描述一种定位C程序中潜在问题的工具，现在通常用于描述查找「可疑但不违背语法规则的问题代码」的工具）。你会得到如下的信息：
	```java
	warning: [fallthrough] possible fall-through into case
	```
   中括号内的字符串标识了警告类型。可以启用和禁用各种类型。**因为它们大多数都很有用，所以最好还是保留这些警告，只禁用那些你不感兴趣的信息**，如下所示：
    ```bash
    $ javac -Xlint:all,-fallthrough,-serial sourceFiles
    ```
   下面列出了可以使用的选项（或用 `javac --help -X` 得到所有警告的一个列表）：
   ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210172205876.png)
11. Java虚拟机增加了对Java应用程序的监控 *monitoring* 和管理 
 *management* 的支持。**它允许在虚拟机中安装代理来跟踪内存消耗、 线程使用、类加载等情况**。这个功能对于像应用程序服务器这样大型的、长时间运行的Java程序来说特别重要。
 作为展示这种功能的一个例子，JDK加载了一个称为 `jconsole` 的图形工具，可以显示有关虚拟机性能的统计结果，如图7-3所示。启动你的程序，然后启动 `jconsole` ，从正在运行的Java程序列表中选择你的程序。
 ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210172350851.png)
控制台会给出有关运行程序的大量信息，更详细的信息参见[这里](www.oracle.com/technetwork/articles/java/jconsole-1564139.html)。
12. **Java任务控制器 `Java Mission Control` 是一个专业级性能分析和诊断工具**，包含在Oracle JDK中，可免费用于开发。如果在生产环境使用则需要商业授权。目前OpenJDK中提供了一个开源版本。类似于 `jconsole` ，`Java Mission Control` 可以关联到正在运行的虚拟机。
它还能记录Java飞行记录器 `Java Flight Recorder` 的输出，这个工具可以从一个正在运行的Java应用程序收集诊断和性能分析数据。更多信息见[这里](https://docs.oracle.com/javacomponents/index.html)。
13. **可以使用 `jmap` 实用工具获得一个堆的转储，其中显示了堆中的每个对象**。使用如下命令，然后，通过浏览器进入 `localhost:7000` ，将会运行一个网络应用程序，借此探查转储对象时堆的内容。
   ```bash
$ jmap -dump:format=b, file=dumpFileName processID
$ jhat dumpFileName
   ```
14. 如果使用 `-Xprof` 标志运行Java虚拟机，就会运行一个基本的剖析器来跟踪那些代码中经常被调用的方法。剖析信息将发送给 `System.out` 。输出结果中还会显示哪些方法是由即时编译器编译的。
警告：编译器的 `-X` 选项并没有正式支持，而且在有些JDK版本中并不存在这个选项。**可以运行命令 `java -X` 得到所有非标准选项的列表**。

上面介绍了异常处理和日志，还讲解了关于测试和调试的一些有用技巧。接下来会介绍泛型程序设计和它最重要的应用：Java集合框架。