@[toc]

▲ 接口
▲ 接口示例
▲ lambda表达式
▲ 内部类
▲ 代理

到目前为止，已经学习了Java面向对象编程的核心概念：类，继承和多台。这里介绍几种常用的高级技术。这些内容不太容易理解，但一定要掌握它们，以完善自己的Java工具箱。
- 首先，接口 `interface` 技术，这种技术主要用来描述类应该**做什么**，而不指定它们**如何做**。一个类可以**实现** `implement` 一个或多个接口。有些情况可能要求符合这些接口——只要有这种要求，就可以随时使用「实现了这个接口的类的对象」。
- 再继续介绍lambda表达式 *lambda expressions* ，这是一种很简洁的方式，用来创建「**可在将来某个时间点执行的代码块**」。通过使用lambda表达式，可以用一种精巧而简洁的方式、表示使用回调或可变行为 *callbacks or variable behavior* 的代码。
- 然后讨论内部类 `inner class` 机制。理论上讲，内部类有些复杂，内部类定义在另外一个类的内部，它们的方法可以访问包含它们的外部类的字段。**内部类技术在设计「具有相互协作关系的类集合」时很有用**。
- 最后介绍代理 `proxy` ，一种实现任意接口的对象。**代理是一种非常专业的构造工具，可以用来构建系统级的工具**。

---
# 6.1 接口
在下面小节中，了解Java接口是什么以及如何使用，还了解Java最新的几个版本中接口的功能有怎样的提升。
## 6.1.1 接口概念
**在Java中，接口不是类，而是对类的一组需求描述 *a set of requirements* ，这些类要遵从接口描述的统一格式进行定义**。

经常听到服务提供商这样说：“如果你的类符合某个特定接口，我就履行这项服务”。下面给出一个具体的示例。`Arrays` 类中的 `sort` 方法承诺可以对对象数组进行排序，但要求满足下列前提：**对象所属的类必须实现了 `Comparable` 接口**。

下面是 `Comparable` 接口的代码：
```java
public interface Comparable {
	int compareTo(Object other);
}
```
这说明，**任何实现 `Comparable` 接口的类都需要包含 `compareTo` 方法**，这个方法的参数必须是一个 `Object` 对象，返回一个整数。
> 注释：在Java 5.0中，`Comparable` 接口已经提升为一个泛型类型。
> ```java
> public interface Comparable<T\> {
>     int compareTo(T other); // parameter has type T
> }
> ```
> 例如，在实现 `Comparable<Employee>` 接口的类中，必须提供方法 `int compareTo(Employee other)` 。
> 
> 仍可以使用不带类型参数的“原始” `Comparable` 类型。这样一来，`compareTo` 方法就有一个 `Object` 类型的参数，必须手动将 `compareTo` 方法的这个参数强制转换为所希望的类型。稍后就会做这个工作，所以不用担心同时出现两个新概念。

**接口中的所有方法自动是 `public` 。因此，在接口中声明方法时，不必提供关键字 `public`** 。

当然，这个接口中还有一个没有明确说明的附加要求：在调用 `x.compareTo(y)` 时，这个 `compareTo` 方法必须确实能**比较**两个对象，并返回比较的结果。当 `x` 小于 `y` 时，返回一个负数；当 `x` 等于 `y` 时，返回 `0` ；否则返回一个正数。

上面这个接口只有一个方法，而有些接口可能包含多个方法。稍后可以看到，**在接口中还可以定义常量**。然而，更重要的是要知道**接口不能提供什么**——**接口绝不会有实例字段**，在Java 8之前，也不能在接口中实现方法（在6.1.4节和6.1.5节中可看到，现在已经可以在接口中提供简单方法了，当然这些方法不能引用实例字段——接口没有实例字段 *instance fields* 。

==提供实例字段和方法实现的任务，应该由实现接口的那个类来完成==。因此，可以将接口看成是没有实例字段的抽象类。但是这两个概念还是有一定区别的，稍后给出详细的解释。

现在假设，希望使用 `Arrays` 类的 `sort` 方法，对 `Employee` 对象数组进行排序。为此，`Employee` 类就必须实现 `Comparable` 接口。

**为了让类实现一个接口，通常需要下面两个步骤**：
1. 将类声明为实现给定的接口。
2. 对接口中的所有方法进行定义。

要将类声明为实现某个接口，需要使用关键字 `implements` ：
```java
class Employee implements Comparable
```
当然，这里的 `Employee` 类需要提供 `compareTo` 方法。假设希望根据雇员的薪水进行比较。以下是 `compareTo` 方法的实现。在这里，我们使用了静态的 `Double.compare` 方法，如果第一个参数小于第二个参数，它会返回一个负值；如果二者相等则返回0；否则返回一个正值。
```java
public int compareTo(Object otherObject) {
	Employee other = (Employee) otherObject;
	return Double.compare(salary, other.salary);
}
```
> 警告：在接口声明中，没有将 `compareTo` 方法声明为 `public` ，这是因为在接口中的所有方法都自动是 `public` 。不过在实现接口时，必须把方法声明为 `public` ；否则，编译器将认为这个方法的访问属性是包可见性，这是**类**的默认访问属性，之后编译器就会报错，指出**你试图提供更严格的访问权限**。

我们可以做得更好一些。可以为泛型 `Comparable` 接口提供一个类型参数。
```java
class Employee implements Comparable<Employee> {
	public int compareTo(Employee other) {
		return Double.compare(salary, other.salary);
	}
}
```
注意，对 `Object` 参数进行强制类型转换总是让人感觉不太顺眼，但现在已经不见了。
> 提示：`Comparable` 接口中的 `compareTo` 方法将返回一个整型数值。如果两个对象不相等，则返回一个正值或者一个负值。在对两个整数字段进行比较时，这种灵活性非常有用。例如，假设每个雇员都有一个唯一整数ID，并希望根据ID对雇员进行重新排序，那么就可以返回 `id - other.id` ——如果第一个ID小于另一个ID，则返回一个负值；如果两个ID相等，则返回0；否则，返回一个正值。但有一点需要注意：**整数的范围不能过大，以避免造成减法运算的溢出**。如果能够确信ID为非负整数，或者它们的绝对值不会超过 `(Integer.MAX_VALUE-1)/2` ，就不会出现问题。否则，调用静态 `Integer.compare` 方法。
> 
> 当然，这里的相减技巧不适用于浮点值。因为在 `salary` 和 `other.salary` 很接近但又不相等的时候，它们的差经过四舍五入后有可能变成0。`x < y` 时，`Double.compare(x, y)` 调用会返回-1；如果 `x > y` 则返回1。

> 注释：`Comparable` 接口的文档建议，**`compareTo` 方法应当与 `equals` 方法兼容**。也就是说，**当 `x.equals(y)` 时 `x.compareTo(y)` 就应当等于0**。Java API中大多数实现 `Comparable` 接口的类都遵从了这个建议。不过有一个重要的例外，就是 `BigDecimal` ——考虑 `x = new BigDecimal("1.0")` 和 `y = new BigDecimal("1.00")` 。这里 `x.equals(y)` 为 `false` ，因为两个数的精度不同。不过 `x.compareTo(y)` 为0。理想结果应该不返回0，但是没有明确的方法能够确定这两个数哪一个更大。

现在，我们已经看到，要让一个类使用排序服务必须让它实现 `compareTo` 方法。这是理所当然的，因为要向 `sort` 方法提供对象的比较方式。但为什么不能在 `Employee` 类直接提供一个 `compareTo` 方法，而必须实现 `Comparable` 接口呢？主要原因在于**Java是一种强类型 `strongly typed` 语言**——**在调用方法的时候，编译器要能检查这个方法确实存在**。在 `sort` 方法中可能存在下面这样的语句：
``` java
if (a[i].compareTo(a[j]) > 0) {
	// rearrange a[i] and a[j]
}
```
为此，编译器必须确认 `a[i]` 一定有 `compareTo` 方法。如果 `a` 是一个 `Comparable` 对象的数组，就可以确保拥有 `compareTo` 方法，因为**每个实现 `Comparable` 接口的类都必须提供这个方法的定义**。
> 注释：有人认为，将 `Arrays` 类中的 `sort` 方法定义为接收一个 `Comparable[]` 数组，就可以在使用「元素类型没有实现 `Comparable` 接口的数组」作为参数调用 `sort` 方法时，由编译器给出错误报告。但事实并非如此。在这种情况下，`sort` 方法可以接收一个 `Object[]` 数组，并对其使用一个笨拙的强制类型转换（**不能将生来就是 `Object[]` 的转换为其他对象数组，但能将 `Object` 和其他对象包括数组互相转换**）：
> ```java
> // approach used in the standard library--not recommended
> if (((Comparable) a[i]).compareTo(a[j]) > 0) {
> 	// rearrange a[i] and a[j]
> }
> ```
> 如果 `a[i]` 不属于一个实现了 `Comparable` 接口的类，那么虚拟机就会抛出一个异常。

`InterfaceLambda/interfaces/EmployeeSortTest.java` 给出了对一个 `Employee` 类的实例数组进行排序的完整代码,
```java
package interfaces;
import java.util.*;

/**
 * This program demonstrates the use of the Comparable interface.
 */
public class EmployeeSortTest {
	public static void main(String[] args) {
		var staff = new Employee[3];
		staff[0] = new Employee("Harry Hacker", 35000);
		staff[1] = new Employee("Carl Cracker", 75000);
		staff[2] = new Employee("Tony Tester", 38000);

		Arrays.sort(staff);
		// print out information about all Employee objects
		for (Employee e : staff)
			System.out.println("name=" + e.getName() + ",salary=" + e.getSalary());
	}
}
```
```java
// InterfaceLambda/interfaces/Employee.java
package interfaces;
public class Employee implements Comparable<Employee> {
	private String name;
	private double salary;

	public Employee(String name, double salary) {
		this.name = name;
		this.salary = salary;
	}
	public String getName() {
		return name;
	}
	public double getSalary() {
		return salary;
	}
	public void raiseSalary(double byPercent) {
		double raise = salary * byPercent / 100;
		salary += raise;
	}

	/**
	 * Compares employees by salary
	 * @param other another Employee object
	 * @return a negative value if this employee has a lower salary than
	 * otherObject, 0 if the salaries are the same, a positive value otherwise
	 */
	public int compareTo(Employee other) {
		return Double.compare(salary, other.salary);
	}
}
```
运行结果如下所示：
```java
name=Harry Hacker,salary=35000.0
name=Tony Tester,salary=38000.0
name=Carl Cracker,salary=75000.0
```
> [API] `java.lang.Comparable<T>` 1.0
> - `int compareTo(T other)`
> 用这个对象与 `other` 进行比较。如果这个对象小于 `other` 则返回负值；如果相等则返回0；否则返回正值。

 > [API] `java.util.Arrays` 1.2
> - `static void sort(Object[] a)`
> 对数组 `a` 中的元素进行排序。要求数组中的元素必须属于实现了 `Comparable` 接口的类，并且元素之间必须是可比较的。

> [API] `java.lang.Integer` 1.0
> - `static int compare(int x, int y)` 7
> 如果 `x < y` 返回一个负整数；如果 `x` 和 `y` 相等，则返回0；否则返回一个正整数。

> [API] `java.lang.Double` 1.0
> - `static int compare(double x, double y)` 1.4
> 如果 `x < y` 返回一个负整数；如果 `x` 和 `y` 相等，则返回0；否则返回一个正整数。

 > 注释：语言标准规定，**对于任意的 `x` 和 `y` ，实现必须能够保证`sgn(x.compareTo(y)) = -sgn(y.compareTo(x))`** 。也就是说，如果 `y.compareTo(x)` 抛出一个异常，那么 `x.compareTo(y)` 也应该抛出一个异常）。这里的"sgn"是一个数值的符号：如果 `n` 是负值，`sgn(n)` 等于-1；如果 `n` 是0，`sgn(n)` 等于0；如果 `n` 是正值，`sgn(n)` 等于1。**简单地讲，如果调换 `compareTo` 的参数，结果的符号也应该调换（而不是实际值）**。
 > 
 > **与 `equals` 方法（还有 `hashCode` 方法）一样，在继承过程中有可能会出现问题**。
 > 
 > 这是因为 `Manager` 扩展了 `Employee` ，而 `Employee` 实现的是`Comparable<Employee>` ，不是 `Comparable<Manager>` 。如果 `Manager` 覆盖了 `compareTo` ，就必须要有经理与雇员进行比较的思想准备，绝不能仅将雇员转换成经理：
 > ```java
 > class Manager extends Employee {
 > 	public int compareTo(Employee other) {
 > 		Manager otherManager = (Manager) other; // NO
 > 		...
 > 	}
 > }
 > ```
 > 这不符合"反对称"的规则。如果 `x` 是一个 `Employee` 对象，`y` 是一个 `Manager` 对象，调用 `x.compareTo(y)` 不会抛出异常，它只是将 `x` 和 `y` 都作为雇员进行比较。但反过来，`y.compareTo(x)` 将会抛出一个 `ClassCastException` 。
 > 
 > **这种情况与第5章中讨论的 `equals` 方法一样，补救方式也一样，有两种不同的情况**。==如果子类之间的比较有不同的含义，那就应将「属于不同类的对象之间的比较」视为非法==。每个 `compareTo` 方法都应该在开始时进行下列检测：
 > ```java
 > if (getClass() != other.getClass()) throw new ClassCastException();
 > ```
 > 如果存在这样一种通用算法，它能对两个不同的子类对象进行比较，则应该在超类中提供一个 `compareTo` 方法，并将这个方法声明为 `final` 。
 > 
 > 例如，假设不管薪水多少都想让经理大于雇员，像 `Executive` 和 `Secretary` 这样的子类又该怎么办呢？如果一定要按照职务排列的话，那就应该在 `Employee` 类中提供一个 `rank` 方法，让每个子类覆盖 `rank` ，并实现一个考虑 `rank` 值的 `compareTo` 方法。

---
## 6.1.2 接口的特性
**接口不是类，尤其不能使用 `new` 运算符实例化一个接口**：
```java
x = new Comparable(...); // ERROR
```
然而，**尽管不能构造接口的对象，却能声明接口的变量**（尽管不能构造抽象类的对象，却能声明抽象类的变量）：
```java
Comparable x; // OK
```
**接口变量必须引用实现了接口的类对象**：
```java
x = new Employee(...); // OK provided Employee implements Comparable
```
接下来，如同**使用 `instanceof` 检查一个对象是否属于某个特定类**一样，也可以**使用 `instanceof` 检查一个对象是否实现了某个特定的接口**：
```java
if (anObject instanceof Comparable) {...}
```
**与可以建立类的继承层次一样，接口也可以被扩展**。这里允许存在多条「从通用性较高的接口到专用性较高的接口」的接口链。例如，假设有一个称为 `Moveable` 的接口：
```java
public interface Moveable {
	void move(double x, double y);
}
```
然后，可以假设一个名为 `Powered` 的接口扩展了以上 `Moveable` 接口：
```java
public interface Powered extends Moveable {
	double milesPerGallon();
}
```
虽然在接口中不能包含实例字段，但却可以包含常量。例如：
```java
public interface Powered extends Moveable {
	double milesPerGallon();
	double SPEED_LIMIT = 95; // a public static final constant
}
```
**与接口中的方法都自动地被设置为 `public` 一样，接口中的字段将被自动设为 `public static final`** 。
> 注释：可以将接口方法标记为 `public` ，将字段标记为 `public static final` 。有些程序员出于习惯或提高清晰度的考虑，可能这样做。但Java语言规范却建议**不要提供这些多余的关键字**，这里也采纳了这个建议。

**有些接口只定义了常量，而没有定义方法**。例如，在标准库中有一个`SwingConstants` 就是这样一个接口，其中只包含 `NORTH, SOUTH, HORIZONTAL` 等常量。任何实现 `SwingConstants` 接口的类都自动地继承了这些常量，并可以在方法中直接地引用 `NORTH` ，而不必采用 `SwingConstants.NORTH` 这样的繁琐书写形式。然而，这样应用接口似乎有点偏离了接口概念的初衷（更像是退化），最好不要这样使用它。

**尽管每个类只能拥有一个超类，但却可以实现多个接口**。这就为定义类的行为提供了极大的灵活性。例如，Java语言有一个非常重要的内置接口，称为 `Cloneable`（将在6.2.3节中详细讨论）。如果某个类实现了这个 `Cloneable` 接口，`Object` 类中的 `clone` 方法就可以创建你的类对象的一个准确副本。如果希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了。使用逗号将实现的各个接口分隔开：
```java
class Employee implements Cloneable, Comparable
```
## 6.1.3 接口与抽象类
如果阅读了第5章中抽象类的内容，就可能会产生这样一个疑问：为什么Java语言还要不辞辛苦地引入接口概念？为什么不将 `Comparable` 直接设计成如下所示的抽象类。
```java
abstract class Comparable { // why not?
	public abstract int compareTo(Object other);
}
```
然后，`Employee` 类再直接扩展这个抽象类，并提供 `compareTo` 方法的实现：
```java
class Employee extends Comparable { // why not?
	public int compareTo(Object other) {...}
}
```
非常遗憾，**使用抽象类表示通用属性存在一个严重的问题：每个类只能扩展于一个类**。假设 `Employee` 类已经扩展于一个类，例如 `Person` ，它就不能再像下面这样扩展第二个类了：
```java
class Employee extends Person, Comparable // Error
```
但每个类可以实现多个接口：
```java
class Employee extends Person implements Comparable // OK
```
有些程序语言允许一个类有多个超类，例如C++。我们将此特性称为**多重继承** `multiple inheritance` 。而Java的设计者选择了不支持多继承，其主要原因是多继承会让语言本身变得非常复杂（如同C++），效率也会降低（如同Eiffel）。

实际上，==接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性==。
> C++注释：C++具有多重继承特性，随之带来了一些复杂的特性，如虚基类、控制规则和横向指针类型转换 *virtual base classes, dominance rules, and transverse pointer casts* 等 ，很少有C++程序员使用多继承，甚至有些人说：就不应该使用多继承。也有些程序员建议只对“混合 *mix-in*” 风格的继承使用多继承。**在“混合”风格中，一个主要的基类描述父对象，其他的基类（因此称为混合）提供辅助特性**。这种风格类似于**Java类从一个基类派生，然后实现若干个辅助接口**。

## 6.1.4 静态方法
**在Java 8中，允许在接口中增加静态方法**。理论上讲，没有任何理由认为这是不合法的。==只是这有违于将接口作为抽象规范的初衷==。目前为止，**通常的做法都是将静态方法放在伴随类中**。在标准库中，会看到成对出现的接口和实用工具类，如 `Collection/Collections` 或 `Path/Paths` 。

`Paths` 类中包含两个工厂方法。可以由一个URI或字符串序列，构造一个文件或目录的路径，如 `Paths.get("jdk-11", "conf", "security")` 。在Java 11中，`Path` 接口提供了等价的方法：
```java
public interface Path {
	public static Path of(URI uri) { ... }
	public static Path get(String first, String... more) { ... }
	...
}
```
这样一来，`Paths` 类就不再是必要的了。不过整个Java库都以这种方式重构也是不太可能的。类似的，**实现你自己的接口时，没有理由再为实用工具方法另外提供一个伴随类**。
> 注释：在Java API中，你会看到很多接口都有相应的伴随类，这个伴随类中实现了相应接口的部分或所有方法，如 `Collection/AbstractCollection` 或 `MouseListener/MouseAdapter` 。在Java 8中，这个技术已经过时。现在可以直接在接口中实现方法。

**在Java 9中，接口中的方法可以是 `private`** 。`private` 方法可以是静态方法或实例方法。由于私有方法只能在接口本身的方法中使用，所以它们的用法很有限，只能作为接口中其他方法的辅助方法。

## 6.1.5 默认方法
可以为接口方法提供一个**默认实现** *default implementation* 。**必须用 `default` 修饰符标记这样一个方法**。
```java
public interface Comparable<T> {
	default int compareTo(T other) { return 0; }
		// by default, all elements are the same
}
```
当然，这并没有太大用处，因为 `Comparable` 的每一个具体实现都要覆盖这个方法。不过**有些情况下，默认方法可能很有用**。如在第9章会看到一个 `Iterator` 接口，用于访问一个数据结构中的元素。这个接口声明了一个 `remove` 方法，如下所示：
```java
public interface Iterator<E> {
	boolean hasNext();
	E next();
	default void remove() { 
		throw new UnsupportedOperationException("remove"); 
	}
	...
}
```
如果我们要实现一个迭代器，就需要提供 `hasNext` 和 `next` 方法，这些方法没有默认实现——它们依赖于你要遍历访问的数据结构。不过，如果你的迭代器是只读的，就不用操心实现 `remove` 方法。

还会在第11章看到，如果希望在发生鼠标点击事件时得到通知，就要实现一个包含5个方法的接口：
```java
public interface MouseListener {
	void mousedieked(MouseEvent event);
	void mousePressed(MouseEvent event);
	void mouseReleased(MouseEvent event);
	void mouseEntered(MouseEvent event);
	void mouseExited(MouseEvent event);
}
```
大多数情况下，你只需要关心其中的1、2个事件类型。**在Java 8中，可以把所有方法声明为默认方法，这些默认方法什么也不做**。这样一来，实现这个接口的程序员，只需要为他们真正关心的事件覆盖相应的监听器。
```java
public interface MouseListener {
	default void mousedieked(MouseEvent event) {}
	default void mousePressed(MouseEvent event) {}
	default void mouseReleased(MouseEvent event) {}
	default void mouseEntered(MouseEvent event) {}
	default void mouseExited(MouseEvent event) {}
}
```

**默认方法可以调用任何其他方法**。例如，`Collection` 接口可以定义一个便利方法，这样实现 `Collection` 的程序员就不用操心实现 `isEmpty` 方法了：
```java
public interface Collection {
	int size(); // An abstract method
	default boolean isEmpty() { return size() == 0; }
	...
}
```
> 注释：Java API中的 `Collection` 接口并没有这样做。实际上，有一个 `AbstractCollection` 类实现了 `Collection` ，并根据 `size` 定义了 `isEmpty` 。**建议实现集合的程序员扩展 `AbstractCollection`** 。不过那个技术已经过时，现在可以直接在接口中实现方法。

默认方法的一个重要用法是"**接口演化**" `interface evolution` 。以 `Collection` 接口为例，这个接口作为Java的一部分已经有很多年了。假设很久以前你提供了这样一个类：
```java
public class Bag implements Collection
```
后来，在Java 8中，又为这个接口增加了一个 `stream` 方法。假设 `stream` 方法不是一个默认方法，那么 `Bag` 类将不能编译，因为它没有实现这个新方法。**为接口增加一个非默认方法不能保证"源代码兼容 *binary compatible*"** 。

不过，假设不重新编译这个类，而只是使用原先的一个包含这个类的JAR文件。这个类仍能正常加载，尽管没有这个新方法。程序仍然可以正常构造 `Bag` 实例，不会有意外发生（为接口增加方法可以保证"二进制兼容"）。

不过，如果程序在一个 `Bag` 实例上调用 `stream` 方法，就会出现一个 `AbstractMethodError` 。**将方法实现为一个默认方法，就可以解决这两个问题**。`Bag` 类又能正常编译了。另外如果没有重新编译、而直接加载这个类，并在一个 `Bag` 实例上调用 `stream` 方法，将调用 `Collection.stream` 方法。

## 6.1.6 解决默认方法冲突
如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况？诸如Scala和C++等语言对于解决这种二义性有一些复杂的规则。幸运的是，**Java的相应规则要简单得多**。规则如下：
1. **超类优先**。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。
2. **接口冲突**。如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。

下面来看第二个规则。考虑两个包含 `getName` 方法的接口：
```java
interface Person {
	default String getName() { return ""; }
}
interface Named {
	default String getName() { 
		return getClass().getName() + "_" + hashCode(); 
	}
}
```
如果有一个类同时实现了这两个接口会怎么样呢？
```java
class Student implements Person, Named { ... }
```
类会继承 `Person` 和 `Named` 接口提供的两个不一致的 `getName` 方法。并不是从中选择一个，Java编译器会报告一个错误，让程序员来解决这个二义性问题。只需要在 `Student` 类中提供一个 `getName` 方法即可。**在这个方法中，可以选择两个冲突方法中的一个**，如下所示：
```java
class Student implements Person, Named {
	public String getName() { return Person.super.getName() ; }
}
```
现在假设 `Named` 接口没有为 `getName` 提供默认实现—— `Student` 类会从 `Person` 接口继承默认方法吗？这好像挺合理，不过，Java设计者更强调一致性。==两个接口如何冲突并不重要。如果至少有一个接口提供了一个实现，编译器就会报告错误，而程序员就必须解决这个二义性==。
```java
interface Named {
	String getName();
}
```
> 注释：当然，如果两个接口都没有为共享方法提供默认实现，那么就与Java 8之前的情况一样，这里不存在冲突。实现类可以有两个选择：实现这个方法，或者干脆不实现。**如果是后一种情况，这个类本身就是抽象的**。

我们只讨论了两个接口的命名冲突。现在来考虑另一种情况，**一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法**。例如，假设 `Person` 是一个类，`Student` 定义为：
```java
class Student extends Person implements Named {...}
```
在这种情况下，**只会考虑超类方法，接口的所有默认方法都会被忽略**。在我们的例子中，`Student` 从 `Person` 继承了 `getName` 方法，`Named` 接口是否为 `getName` 提供了默认实现、并不会带来什么区别。这正是"类优先 *class wins*" 规则。

"类优先"规则可以确保与Java 7的兼容性。如果为一个接口增加默认方法，这对于「有这些默认方法之前能正常工作的代码」不会有任何影响。
> 警告：**千万不要让一个默认方法重新定义 `Object` 类中的某个方法**。例如，不能为 `toString` 或 `equals` 定义默认方法，尽管对于 `List` 之类的接口，这可能很有吸引力。但由于“类优先”规则，这样的方法绝对无法超越 `Object.toString` 或 `Objects.equals` 。

---
# 6.1.7 接口与回调
接下来3节中，给出接口的另外一些示例，可以从中了解接口的实际使用。

**回调 `callback` 是一种常见的程序设计模式**。在这种模式中，可以**指定某个特定事件发生时应该采取的动作**。例如，可以指出在按下鼠标或选择某个菜单项时，应该采取什么行动。然而，由于至此还没有介绍如何实现用户接口，所以只能讨论一些与上述操作类似、但比较简单的情况。

在 `java.swing` 包中有一个 `Timer` 类，如果希望经过一定时间间隔就得到通知，`Timer` 类就很有用。例如，假如程序中有一个时钟，可以请求每秒通知一次，以便更新时钟的表盘。在构造定时器时，需要设置一个时间间隔，并告之定时器，经过这个时间间隔时需要做些什么。

如何告之定时器做什么呢？在很多程序设计语言中，可以提供一个函数名，定时器周期性地调用它。但是，Java标准类库中的类采用的是面向对象方法。==它将某个类的对象传递给定时器，然后定时器调用这个对象的方法。由于对象可以携带一些附加的信息，所以传递一个对象比传递一个函数要灵活得多==。

当然，定时器需要知道调用哪一个方法，并要求「传递的对象所属的类」实现了 `java.awt.event` 包的 `ActionListener` 接口。下面是这个接口：
```java
public interface ActionListener {
	void actionPerformed(ActionEvent event);
}
```
当到达指定的时间间隔时，定时器就调用 `actionPerformed` 方法。

假设希望每隔10秒钟打印一条信息"At the tone, the time is...""，然后响一声，就应该定义一个**实现 `ActionListener` 接口的类**，然后将需要执行的语句放在 `actionPerformed` 方法中。
```java
class TimePrinter implements ActionListener {
	public void actionPerformed(ActionEvent event) {
		System.out.println("At the tone, the time is " + 
			Instant.ofEpochMilli(event.getWhen());
		Toolkit.getDefaultToolkit().beep();
	}
}
```
需要注意 `actionPerformed` 方法的 **`ActionEvent` 参数，这个参数提供了事件的相关信息**，例如，发生这个事件的时间，产生这个事件的源对象。有关这方面的详细内容参看第8章。`event.getWhen()` 调用会返回这个事件时间，表示为"纪元"（1970年1月1日）以来的毫秒数。**如果把它传入静态方法 `Instant.ofEpochMilli` ，可以得到一个更可读的描述**。

接下来，构造这个类的一个对象，并将它传递给 `Timer` 构造器。`Timer` 构造器的第一个参数是发出通知的时间间隔（单位是毫秒）。这里希望每隔1秒钟通告一次。第二个参数是监听器对象。
```java
ActionListener listener = new TimePrinter();
Timer t = new Timer(1000, listener);
```
最后，启动定时器：
```java
t.start();
```
每隔1秒钟，下列信息显示一次，然后响一声铃。
```java
At the tone, the time is Wed Apr 13 23:29:08 PDT 2016
```
程序 `InterfaceLambda/timer/TimerTest.java` 展示了定时器和动作监听器的具体使用。在定时器启动以后，程序将弹出一个消息对话框，并等待用户点击Ok按钮来终止程序的执行。在程序等待用户操作的同时，每隔1秒显示一次当前的时间（如果关闭这个对话框，一旦 `main` 方法退出，程序就终止）。

```java
// InterfaceLambda/timer/TimerTest.java
package timer;

import java.awt.*;
import java.awt.event.*;
import java.time.*;
import javax.swing.*;

public class TimerTest {
	public static void main(String[] args) {
		var listener = new TimePrinter();
		
		// construct a timer that calls the listener
		// once every second
		var timer = new Timer(1000, listener);
		timer.start();

		// keep program running until the user selects "OK"
		JOptionPane.showMessageDialog(null, "Quit Program?");
		System.exit(0);
	}
}

class TimePrinter implements ActionListener {
	public void actionPerformed(ActionEvent event) {
		System.out.println("At the tone, the time is "
			+ Instant.ofEpochMilli(event.getWhen()));
		Toolkit.getDefaultToolkit().beep();
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211022235066.png)

> [API] `javax.swing.JOptionPane` 1.2
> - `static void showMessageDialog(Component parent, Object message)`
> 显示一个包含一条消息和OK按钮的对话框。这个对话框将位于其 `parent` 组件的中央。如果 `parent` 为 `null` ，对话框将显示在屏幕的中央。

> [API] `javax.swing.Timer` 1.2
> - `Timer(int interval, ActionListener listener)`
> 构造一个定时器，每隔 `interval` 毫秒通告 `listener` —次。
> - `void start()`
> 启动定时器。一旦启动成功，定时器将调用监听器的 `actionPerformed` 。
> - `void stop()`
> 停止定时器。一旦停止成功，定时器将不再调用监听器的 `actionPerformed` 。
 
> [API] `java.awt.Toolkit` 1.0
> - `static Toolkit getDefaultToolkit()`
> 获得默认的工具箱。工具箱包含有关GUI环境的信息。
> - `void beep()`
> 发出一声铃响。
## 6.2.2 `Comparator` 接口
6.1.1节中，已经了解了如何对一个对象数组排序，前提是这些对象是实现了 `Comparable` 接口的类的实例。例如，可以对一个字符串数组排序，因为 String 类实现了 `Comparable<String>` ，而且 `String.compareTo` 方法可以按字典顺序比较字符串。

现在假设希望按长度递增的顺序对字符串进行排序，而不是按字典顺序进行排序。**肯定不能让 `String` 类用两种不同的方式实现 `compareTo` 方法**——更何况，`String` 类也不应由我们来修改。

要处理这种情况，`Arrays.sort` 方法还有第二个版本，有一个数组和一个比较器 `comparator` 作为参数，**比较器是实现了 `Comparator` 接口的类的实例**。
```java
public interface Comparator<T> {
	int compare(T first, T second);
}
```
要按长度比较字符串，可以如下定义一个实现 `Comparator<String>` 的类：
```java
class LengthComparator implements Comparator<String> {
	public int compare(String first, String second) {
		return first.length() - second.length();
	}
}
```
具体完成比较时，需要建立一个实例：
```java
Comparator<String> comp = new LengthComparator();
if (comp.compare(words[i], words[j]) > 0) ...
```
将这个调用与 `words[i].compareTo(words[j])` 做比较。**这个 `compare` 方法要在比较器对象上调用，而不是在字符串本身上调用**。
> 注释：尽管 `LengthComparator` 对象没有状态，不过还是需要建立这个对象的一个实例。**我们需要这个实例来调用 `compare` 方法——它不是一个静态方法**。

要对一个数组排序，需要为 `Arrays.sort` 方法传入一个 `LengthComparator` 对象：
```java
String[] friends = { "Peter", "Paul", "Mary"};
Arrays.sort(friends, new LengthComparator());
```
现在这个数组可能是 `["Paul", "Mary", "Peter"]` 或 `["Mary", "Paul", "Peter"]` 。在6.2节中会了解，利用lambda表达式可以更容易地使用 `Comparator` 。
## 6.1.9 对象克隆
本节讨论 **`Cloneable` 接口，这个接口指示一个类提供了一个安全的 `clone` 方法**。由于克隆并不太常见，而且有关的细节技术性很强，可能只是想稍做了解，等真正需要时再深人学习。

要了解克隆的具体含义，先回忆为「一个包含对象引用的变量」建立副本时会发生什么。**原变量和副本都是同一个对象的引用**（见图6-1)。这说明，任何一个变量改变都会影响另一个变量。
```java
Employee original = new Employee("John Public", 50000);
Employee copy = original;
copy.raiseSalary(10); // oops-also changed original
```
如果希望 `copy` 是一个新对象，它的初始状态与 `original` 相同，但之后它们各自会有自己不同的状态，这种情况下就可以使用 `clone` 方法。
```java
Employee copy = original.clone();
copy.raiseSalary(10); // OK original unchanged
```
![图6-1 拷贝和克隆|450x550](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209281046623.png)
不过并没有这么简单。`clone` 方法是 `Object` 的一个 `protected` 方法，这说明你的代码不能直接调用这个方法。只有 `Employee` 类可以克隆 `Employee` 对象。这个限制是有原因的。想想看 **`Object` 类如何实现 `clone` 。它对于这个对象一无所知，所以只能逐个字段地进行拷贝**。如果**对象中的所有数据字段都是数值或其他基本类型**，拷贝这些字段没有任何问题、 但如果对象包含子对象的引用，拷贝字段就会得到相同子对象的另一个引用，这样一来，原对象和克隆的对象仍然会共享一些信息。

为了更直观地说明这个问题，考虑第4章介绍过的 `Employee` 类。图6-2显示了使用 `Object` 类的 `clone` 方法克隆这样一个 `Employee` 对象会发生什么。可以看到，**默认的克隆操作是"浅拷贝"，并没有克隆对象中引用的其他对象**（这个图显示了一个共享的 `Date` 对象，出于某种原因（稍后就会解释这个原因），这个例子使用了 `Employee` 类的老版本，其中的雇用日期仍用 `Date` 表示）。==浅拷贝会有什么影响吗？这要看具体情况。如果原对象和浅克隆对象共享的子对象是**不可变**的，那么这种共享就是安全的==。如果子对象属于一个不可变的类，如 `String` ，就是这种情况。==或者在对象的生命期中，子对象一直包含不变的常量，没有更改器方法会改变它，也没有方法会生成它的引用，这种情况下同样是安全的==。
![图6-2 A shallow copy](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209281149139.png)
不过，**通常子对象都是可变的，必须重新定义 `clone` 方法来建立一个深拷贝，同时克隆所有子对象**。在这个例子中，`hireDay` 域是一个 `Date` ，这是可变的，所以它也需要克隆（出于这个原因，这个例子使用 `Date` 类型的字段、而非 `LocalDate`  来展示克隆过程。如果 `hireDay` 是不可变的 `LocalDate` 类的一个实例，就无需我们做任何处理了）。

对于每一个类，需要确定：
1. 默认的 `clone` 方法是否满足要求；
2. 是否可以在可变的子对象上，调用 `clone` 来修补默认的 `clone` 方法；或者
3. 是否不该使用 `clone` 。

实际上**第3个选项是默认选项**。如果选择第1项或第2项，类必须：
1. 实现 *implements* `Cloneable` 接口；
2. **重新定义 `clone` 方法，并指定 `public` 访问修饰符**。
> 注释：`Object` 类中 `clone` 方法声明为 `protected` ，所以你的代码不能直接调用 `anObject.clone()` 。但是，不是所有子类都能访问受保护方法吗？不是所有类都是 `Object` 的子类吗？幸运的是，受保护访问的规则比较微妙（见第5章）。**子类只能调用受保护的 `clone` 方法来克隆它自己的对象**。必须重新定义 `clone`  为 `public` 才能允许所有方法克隆对象。

在这里，**`Cloneable` 接口的出现与接口的正常使用并没有关系**。具体来说，它没有指定 `clone` 方法，这个方法是从 `Object` 类继承的。这个接口只是作为一个标记，指示类设计者了解克隆过程。==对象对于克隆很“偏执”，如果一个对象请求克隆，但没有实现这个接口，就会生成一个检查型异常==。
> 注释：`Cloneable` 接口是Java提供的一组**标记接口** `tagging interface` 之一（有些程序员称之为**记号接口** `marker interface` 。应该记得，`Comparable` 等**接口的通常用途是确保一个类实现一个或一组特定的方法**。标记接口不包含任何方法；**它唯一的作用就是允许在类型查询中使用 `instanceof`** ：
> ```java
> if (obj instanceof Cloneable)...
> ```
> 建议你自己的程序中不要使用标记接口。

**即使 `clone` 的默认（浅拷贝）实现能够满足要求，还是需要实现 `Cloneable` 接口，将 `clone` 重新定义为 `public` ，再调用 `super.clone()`** 。下面给出一个例子：
```java
class Employee implements Cloneable {
	// raise visibility level to public, change return type
	public Employee clone() throws CloneNotSupportedException {
		return (Employee) super.clone();
	}
}
```
> 注释：在Java 1.4之前，`clone` 方法的返回类型总是 `Object` ，而现在可以为你的 `clone` 方法指定正确的返回类型。这是协变返回类型 *covariant return types* 的一个例子（见第5章）。

与 `Object.clone` 提供的浅拷贝相比，前面看到的 `clone` 方法并没有为它增加任何功能。这里**只是让这个方法是公有的**。==要建立深拷贝，还需要做更多工作，克隆对象中可变的实例字段==。下面看创建深拷贝的 `clone` 方法的一个例子：
```java
class Employee implements Cloneable {
	public Employee clone() throws CloneNotSupportedException {
		// call Object.clone()
		Employee cloned = (Employee) super.clone();
		// clone mutable fields
		cloned.hireDay = (Date) hireDay.clone();
		return cloned;
	}
}
```
**如果在一个对象上调用 `clone` ，但这个对象的类并没有实现 `Cloneable` 接口，`Object` 类的 `clone` 方法就会拋出一个 `CloneNotSupportedException`** 。当然，`Employee` 和 `Date` 类实现了 `Cloneable` 接口，所以不会抛出这个异常。不过，**编译器并不了解这一点，因此我们声明了这个异常**。

捕获这个异常是不是更好一些？
```java
public Employee clone() {
	try {
		Employee cloned = (Employee) super.clone();
		...
	} catch (CloneNotSupportedException e) { 
		return null; 
	}
	// this won't happen, since we are Cloneable
}
```
**这适用于 `final` 类**（？）。否则，最好还是**保留 `throws` 说明符**。这样就允许子类在不支持克隆时，选择抛出一个 `CloneNotSupportedException` 。

**必须当心子类的克隆**。例如，一旦为 `Employee` 类定义了 `clone` 方法，任何人都可以使用它来克隆 `Manager` 对象。`Employee` 的克隆方法能完成工作吗？这取决于 `Manager` 类的字段。在这里是没有问题的，因为 `bonus` 字段是基本类型。但是 `Manager` 可能会有需要深拷贝或不可克隆的字段。不能保证子类的实现者一定会修正 `clone` 方法让它正常工作。出于这个原因，在 `Object` 类中 `clone` 方法声明为 `protected` 。不过，如果希望类用户调用 `clone` ，就不能这样做。

要不要在自己的类中实现 `clone` 呢？ 如果你的客户需要建立深拷贝，可能就需要实现这个方法。有些人认为应该完全避免使用 `clone` ，而实现另一个方法来达到同样的目的。**`clone` 相当笨拙**，这一点我们也同意，不过如果让另一个方法来完成这个工作，还是会遇到同样的问题。毕竟，**克隆没有你想象中那么常用**。标准库中只有不到5%的类实现了 `clone` 。

 `InterfaceLambda/clone/CloneTest.java` 程序克隆了 `Employee` 类的一个实例，然后调用两个更改器方法。`raiseSalary` 方法会改变 `salary` 字段的值，而 `setHireDay` 方法改变 `hireDay` 字段的状态。**这两个更改器方法都不会影响原来的对象，因为 `clone` 定义为建立一个深拷贝**。
> 注释：所有数组类型都有一个 `public` 的 `clone` 方法，而不是 `protected` ——可以用这个方法建立一个新数组，包含原数组所有元素的副本。例如：
> ```java
> int[] luckyNumbers = { 2, 3, 5, 7, 11, 13 };
> int[] cloned = luckyNumbers.clone();
> cloned[5] = 12; // doesn't change luckyNumbers[5]
> ```

> 注释：卷II第2章将展示另一种克隆对象的机制，其中使用了Java的对象串行化特性。这个机制很容易实现，而且很安全，但效率不高。
 
```java
// InterfaceLambda/clone/CloneTest.java
package clone;

/**
 * This program demonstrates cloning.
 */
public class CloneTest {
	public static void main(String[] args) throws CloneNotSupportedException {
		var original = new Employee("John Q. Public", 50000);
		original.setHireDay(2000, 1, 1);
		Employee copy = original.clone();
		copy.raiseSalary(10);
		copy.setHireDay(2002, 12, 31);
		System.out.println("original=" + original);
		System.out.println("copy=" + copy);
	}
}
```
```java
// InterfaceLambda/clone/Employee.java
package clone;

import java.util.Date;
import java.util.GregorianCalendar;

public class Employee implements Cloneable {
	private String name;
	private double salary;
	private Date hireDay;

	public Employee(String name, double salary) {
		this.name = name;
		this.salary = salary;
		hireDay = new Date();
	}

	public Employee clone() throws CloneNotSupportedException {
		// call Object.clone()
		Employee cloned = (Employee) super.clone();

		// clone mutable fields
		cloned.hireDay = (Date) hireDay.clone();

		return cloned;
	}

	/** 
	 * Set the hire day to a given date.
	 * @param year the year of the hire day
	 * @param month the month of the hire day
	 * @param day the day of the hire day
	 */
	public void setHireDay(int year, int month, int day) {
		Date newHireDay = new GregorianCalendar(year, month - 1, day).getTime();
		// example of instance field mutation
		hireDay.setTime(newHireDay.getTime());
	}

	public void raiseSalary(double byPercent) {
		double raise = salary * byPercent / 100;
		salary += raise;
	}

	public String toString() {
		return "Employee[name=" + name + ",salary=" + salary + ",hireDay=" + hireDay + "]";
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211030048142.png)

---
# 6.2 lambda表达式
现在可以来学习lambda表达式，这是这些年来Java最让人激动的一个变化。了解如何**使用lambda表达式**，采用一种简洁的语法定义代码块，以及如何**编写处理lambda表达式的代码**。
## 6.3.1 为什么引入lambda表达式
**lambda表达式是一个可传递的代码块，可以在以后执行一次或多次**。具体介绍语法（以及解释这个让人好奇的名字）之前，下面先退一步，观察一下我们在Java 中的哪些地方用过这种代码块。

在6.1.7节中，已经了解了如何按指定时间间隔完成工作。将这个工作放在一个 `ActionListener` 的 `actionPerformed` 方法中：
```java
class Worker implements ActionListener {
	public void actionPerformed(ActionEvent event) {
		// do some work
	}
}
```
想要反复执行这个代码时，可以构造 `Worker` 类的一个实例。然后把这个实例提交到一个 `Timer` 对象。**这里的重点是 `actionPerformed` 方法包含希望以后执行的代码**。

或者可以考虑如何用一个**定制比较器**完成排序。如果想按长度、而不是默认的字典顺序对字符串排序，可以向 `sort` 方法传人一个 `Comparator` 对象：
```java
class LengthComparator implements Comparator<String> {
	public int compare(String first, String second) {
		return first.length() - second.length();
	}
}
...
Arrays.sort(strings, new LengthComparator());
```
`compare` 方法不是立即调用。实际上，在数组完成排序之前，`sort` 方法会一直调用 `compare` 方法，只要元素的顺序不正确就会重新排列元素。将比较元素所需的代码段放在 `sort` 方法中，这个代码将与其余的排序逻辑集成（可能并不打算重新实现其余的这部分逻辑）。

这两个例子有一些共同点，都是**将一个代码块传递到某个对象**（一个定时器，或者一个 `sort` 方法），**这个代码块会在将来某个时间调用**。

到目前为止，在Java中传递一个代码段并不容易。**不能直接传递代码段**，Java是一种面向对象语言，所以**必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码**。而在其他语言中，可以直接处理代码块。Java的设计者很长时间以来一直拒绝增加这个特性。

毕竟，Java的强大之处就在于其简单性和一致性。如果只要一个特性能够让代码稍简洁一些，就把这个特性增加到语言中，那这个语言很快就会变得一团糟，无法管理。不过，在另外那些语言中，并不只是创建线程或注册按钮点击事件处理器更容易；它们的大部分API都更简单、更一致而且更强大。在Java中也可以编写类似的API，处理实现了某个特定接口的类对象，不过这种API使用可能很不方便。

就现在来说，问题已经不是是否增强Java来支持函数式编程，而是要如何做到这一点。设计者们做了多年的尝试，终于找到一种适合Java的设计。下一节中了解**Java 8中如何处理代码块**。
## 6.2.2 lambda表达式的语法
再来考虑上一节讨论的排序例子。我们传入代码来检查一个字符串是否比另一个字符串短。这里要计算：`first.length() - second.length()` 。`first` 和 `second` 是什么？它们都是字符串。Java是一种强类型语言，所以我们还要指定它们的类型：
```java
(String first, String second)
	-> first.length() - second.length()
```
这是我们看到的第一个表达式。==lambda表达式就是一个代码块，以及必须传入代码块的任何变量的规范 *a block of code, together with the specification of any variables that must be passed to the code*== 。

为什么起这个名字呢？很多年前，那时还没有计算机，逻辑学家 *Alonzo Church* 想要形式化地表示能有效计算的数学函数 *what it means for a mathematical function to be effectively computable*（奇怪的是，有些函数已经知道是存在的，但没有人知道该如何计算这些函数的值），他使用了希腊字母 $\lambda$（lambda）来标记参数。如果他知道Java API，可能就会写为：
```java
λfirst.λsecond.first.length() - second.length()
```
> 注释：为什么是字母 $\lambda$ ? *Church* 已经把字母表里的所有其他字母都用完了吗？ 实际上，权威的《数学原理 *Principia Mathematica* 》一书中就使用重音符 `^` 来表示自由变量，受此启发，*Church* 使用 $\Lambda$（大写lambda）表示参数。不过，最后他还是改为使用 $\lambda$（小写lambda）。从那以后，带参数变量的表达式就被称为 lambda表达式。

已经见过Java中的**一种lambda表达式形式：参数，箭头 `->` 以及一个表达式**。如果代码要完成的计算无法放在一个表达式中，就**可以像写方法一样，把这些代码放在 `{}` 中，并包含显式的 `return` 语句**。例如：
```java
(String first, String second) -> {
	if (first.length() < second.length()) return -1;
	else if (first.length() > second.length()) return 1;
	else return 0;
}
```
**即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样**：
```java
() -> { 
	for (int i = 100; i >= 0; ++i) 
		System.out.println(i); 
}
```
**如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型**。例如：
```java
Comparator<String> comp
	= (first, second) // Same as (String first, String second)
		-> first.length() - second.length();
```
在这里，编译器可以推导出 `first` 和 `second` 必然是字符串，因为这个lambda表达式将赋给一个字符串比较器（下一节更详细地分析这个赋值）。

**如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号**：
```java
ActionListener listener = event ->
	System.out.println("The time is " + new Date());
		// Instead of (event) -> ... or (ActionEvent event) ->.. .
```
**无需指定lambda表达式的返回类型**。lambda表达式的返回类型总是会由上下文推导得出。例如，下面的表达式可以在需要 `int` 类型结果的上下文中使用。
```java
(String first, String second) -> first.length() - second.length()
```
> 注释：如果一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。例如，`(int x) -> { if (x >= 0) return 1; }` 就不合法。

程序 `InterfaceLambda/lambda/LambdaTest.java` 显示了如何在一个比较器和一个动作监听器中使用lambda表达式。
```java
package lambda;

import java.util.*;
import javax.swing.*;
import javax.swing.Timer;

/**
 * This program demonstrates the use of lambda expressions.
 */
public class LambdaTest {
	public static void main(String[] args) {
		var planets = new String[] { "Mercury", "Venus", "Earth", "Mars",
			"Jupiter", "Saturn", "Uranus", "Neptune"};
		System.out.println(Arrays.toString(planets));
		System.out.println("Sorted in dictionary order:");
		Arrays.sort(planets);
		System.out.println(Arrays.toString(planets));
		System.out.println("Sorted by length:");
		Arrays.sort(planets, (first, second) -> first.length() - second.length());
		System.out.println(Arrays.toString(planets));

		var timer = new Timer(1000, event ->
			System.out.println("The time is " + new Date()));
		timer.start();

		// keep program running util user selects "OK"
		JOptionPane.showMessageDialog(null, "Quit program?");
		System.exit(0);
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211031613912.png)

## 6.3.3 函数式接口
前面讨论过，Java中已经有**很多封装代码块的接口**，如 `ActionListener` 或 `Comparator` ——**lambda表达式与这些接口是兼容的**。

==对于「**只有一个抽象方法的接口**」，需要这种接口的对象时，就可以提供一个lambda表达式==。这种接口称为**函数式接口** `functional interface` 。
> 注释：可能想知道为什么函数式接口必须有一个抽象方法。**不是接口中的所有方法都是抽象的吗**？ 实际上，接口完全有可能重新声明 `Object` 类的方法，如 `toString` 或 `clone` ，这些声明有可能会让方法不再是抽象的 *do not make the methods abstract*（Java API中的一些接口会重新声明 `Object` 的方法来附加 `javadoc` 注释。`Comparator` API就是这样一个例子）。更重要的是，正如6.1.5节所述，**在Java 8中，接口可以声明非抽象方法**（默认方法？）。

为了展示如何转换为函数式接口，下面考虑 `Arrays.sort` 方法。它的第二个参数需要一个 `Comparator` 实例，`Comparator` 就是只有一个方法的接口，所以可以提供一个 `lambda` 表达式：
```java
Arrays.sort(words, (first, second) -> first.length() - second.length());
```
在底层，`Arrays.sort` 方法会接收**实现了 `Comparator<? super String>` 的某个类的对象**，在这个对象上调用 `compare` 方法会**执行这个lambda表达式的体**。这些对象和类的管理完全取决于具体实现，与使用传统的内部类 *inner class* 相比，这样可能要高效得多。==最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口==。

**lambda表达式可以转换为接口**，这一点让lambda表达式很有吸引力。具体的语法很简短。下面再来看一个例子，与使用实现了 `ActionListener` 接口的类相比，这个代码可读性要好得多。
```java
Timer t = new Timer(1000, event -> {
	System.out.println("At the tone, the time is " + new Date());
	Toolkit.getDefaultToolkit().beep();
});
```
==实际上在Java中，对lambda表达式所能做的也**只是**能转换为函数式接口==。在其他支持函数字面量的程序设计语言中，可以声明函数类型（如 `(String, String) -> int)` ，声明这些类型的变量，还可以使用变量保存函数表达式。不过，Java设计者还是决定保持我们熟悉的接口概念，没有为Java语言增加函数类型。
> 注释：甚至不能把lambda表达式赋给类型为 `Object` 的变量，**`Object` 不是一个函数式接口**。

Java API在 `java.util.function` 包中定义了很多**非常通用的函数式接口**。其中一个接口 `BiFunction<T, U, R>` 描述了参数类型为 `T` 和 `U` 且返回类型为 `R` 的函数。可以把我们的字符串比较lambda表达式保存在这个类型的变量中：
```java
BiFunction<String, String, Integer> comp
	= (first, second) -> first.length() - second.length();
```
不过，这对于排序并没有帮助。没有哪个 `Arrays.sort` 方法想要接收一个 `BiFunction`（它接受的是 `Comparator` 接口）。如果之前用过某种函数式程序设计语言，可能会发现这很奇怪。不过，对于Java程序员而言，这非常自然。**一个类似 `Comparator` 的接口往往有一个特定的用途，而不只是提供一个有指定参数和返回类型的方法**。Java 8沿袭了这种思路。想要用lambda表达式做某些处理，还是要谨记表达式的用途，为它建立一个特定的函数式接口 *have a specific functional interface for it* 。

`java.util.function` 包中有一个尤其有用的接口 `Predicate` :
```java
public interface Predicate<T> {
	boolean test(T t);
	// Additional default and static methods
}
```
`ArrayList` 类有一个 `removeIf` 方法，它的参数就是一个 `Predicate` 。这个接口专门被设计来传递lambda表达式。例如，下面的语句将从一个数组列表删除所有 `null` 值：
```java
list.removeIf(e -> e == null);
```
另一个有用的函数式接口是 `Supplier<T>` ：
```java
public interface Supplier<T> {
	T get();
}
```
供应者 `supplier` 没有参数，调用时生成一个 `T` 类型的值。**供应者用于实现懒求值**。例如，考虑以下调用：
```java
LocalDate hireDay = Objects.requireNonNullOrElse(day,
	new LocalDate(1970, 1, 1));
```
这不是最优的。我们预计 `day` 很少为 `null` ，所以希望只在必要时才构造默认的 `LocalDate` 。通过使用供应者，我们就能延迟这个计算：
```java
LocalDate hireDay = Objects.requireNonNullOrElseGet(day,
	() -> new LocalDate(1970, 1, 1));
```
**`requireNonNullOrElseGet` 方法只在需要值时才调用供应者**。
## 6.2.4 方法引用
有时，lambda表达式涉及一个方法——可能已经有现成的方法，可以完成你想要传递到其他代码的某个动作。例如，假设希望只要出现一个定时器事件、就打印这个事件对象。当然，为此也可以调用:
```java
Timer t = new Timer(1000, event -> System.out.println(event));
```
但是，如果直接把 `println` 方法传递到 `Timer` 构造器就更好了。具体做法如下：
```java
Timer t = new Timer(1000, System.out::println);
```
表达式 `System.out::println` 是一个**方法引用** `method reference` ，**它指示编译器生成一个函数式接口的实例，覆盖接口里面的单个抽象方法来调用给定的方法**。在这个例子中，会生成一个 `ActionListener` ，它的 `actionPerformed(ActionEvent e)` 方法要调用 `System.out.println(e)` 。等价于lambda表达式：
```java
x -> System.out.println(x);
```

> 注释：**类似于lambda表达式，方法引用也不是一个对象**。不过，赋值给一个类型为函数式接口的变量时，会生成一个对象 *gives rise to an object* 。

> 注释：`PrintStream` 类（ `System.out` 就是 `PrintStream` 类的一个实例）中有10个重载的 `println` 方法。编译器需要根据上下文确定使用哪一个方法。在我们的例子中，方法引用 `System.out::println` 必须转换为「一个包含以下方法的 `ActionListener` 实例」：
> ```java
> void actionPerformed(ActionEvent e)
> ```
> 这样会从10个重载的 `println` 方法中选出 `println(Object x)` 方法，因为 `Object` 与 `ActionEvent` 最匹配。调用 `actionPerformed` 方法时，就会打印这个事件对象。
> 现在，假设我们把同样的这个方法引用，赋至一个不同的函数式接口：
> ```java
> Runnable task = System.out::println;
> ```
> 这个 `Runnable` 函数式接口，有一个无参数的抽象方法：
> ```java
> void run()
> ```
> 在这里，会选择无参数的 `println()` 方法。调用 `task.run()` 会向 `System.out` 打印一个空行。

再来看一个例子，假设想对字符串排序、而不考虑字母的大小写。可以传递以下方法表达式：
```java
Arrays.sort(strings, String::compareToIgnoreCase)
```
从这些例子可以看出，**要用 `::` 操作符分隔方法名与对象或类名**。主要有3种情况：
- `object::instanceMethod` ——在第1种情况中，方法引用等价于「向方法传递参数的lambda表达式」。对于 `System.out::println` ，对象是 `System.out` ，所以方法表达式等价于 `x -> System.out.println(x)` 。
- `Class::instanceMethod` ——在第2种情况中，第1个参数会成为方法的隐式参数。例如，`String::compareToIgnoreCase` 等同于 `(x, y) -> x.compareToIgnoreCase(y)` 。
- `Class::staticMethod` ——在第3种情况中，所有参数都传递到静态方法：`Math.pow` 等价于 `(x, y) -> Math.pow(x, y)` 。

表6-1提供了更多示例。
![520x600](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209291659238.png)

![520x400](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209291700759.png)

注意，**只有当lambda表达式的体只调用一个方法、而不做其他操作时，才能把lambda表达式重写为方法引用**。考虑以下lambda表达式：
```java
s -> s.length() == 0
```
这里有一个方法调用，但还有一个比较，所以这里不能使用方法引用。

> 注释：如果有多个同名的重载方法，编译器就会尝试从上下文中找出你指的那一个方法。例如，`Math.max` 方法有两个版本，一个用于整数，另一个用于 `double` 值。选择哪一个版本取决于 `Math::max` 转换为哪个函数式接口的方法参数。**类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例**。

> 注释：有时API包含一些专门用作方法引用的方法。例如，`Objects` 类有一个方法 `isNull` ，用于测试一个对象引用是否是 `null` 。看上去好像没什么用，因为测试 `obj == null` 比 `Objects.isNull(obj)` 更可读。不过，可以把方法引用传递到任何有 `Predicate` 参数的方法。例如，要从一个列表中删除所有 `null` 引用，可以调用：
> ```java
> list.removeIf(Objects::isNull);
> 	// A bit easier to read than list.removeIf(e -> e == null);
> ```

> 注释：包含对象的方法引用与等价的lambda表达式还有一个细微的差别。考虑一个方法引用，如 `separator::equals` 。如果 `separator` 为 `null` ，构造 `separator::equals` 时就会立即抛出一个 `NullPointerException` 异常。lambda表达式 `x -> separator.equals(x)` 只在调用时才会抛出 `NullPointerException` 。

**可以在方法引用中使用 *capture* `this` 参数**。例如，`this::equals` 等同于 `x-> this.equals(x)` 。**使用`super` 也是合法的**。下面的方法表达式 `super::instanceMethod` 使用 `this` 作为目标，会调用给定方法的超类版本。为了展示这一点，下面给出一个假想的例子：
```java
class Greeter {
	public void greet() {
		System.out.println("Hello, the time is "
			+ Instant.ofEpochMilli(event.getWhen()));
	}
}
class TimedCreeter extends Greeter {
	public void greet() { 
		var timer = new Timer(1000, super::greet);
		timer.start();
	}
}
```
`RepeatedGreeter.greet` 方法开始执行时，会构造一个 `Timer` ，它会在每次定时器滴答时执行 `super::greet` 方法。这个方法会调用超类的 `greet` 方法。
## 6.3.5 构造器引用
**构造器引用与方法引用很类似**，只不过方法名为 `new` 。例如，`Person::new` 是 `Person` 构造器的一个引用。**哪一个构造器呢？这取决于上下文**。假设你有一个字符串列表。可以把它转换为一个 `Person` 对象数组，为此要在各个字符串上调用构造器，调用如下：
```java
ArrayList<String> names = ...;
Stream<Person> stream = names.stream().map(Person::new);
List<Person> people = stream.collect(Collectors.toList());
```
在卷II第1章讨论 `stream, map, collect` 方法的详细内容。就现在来说，重点是 `map` 方法会为各个列表元素调用 `Person(String)` 构造器。如果有多个 `Person` 构造器，编译器会选择有一个 `String` 参数的构造器，因为它从上下文**推导**出这是在调用带一个字符串的构造器。

**可以用数组类型建立构造器引用**。例如，`int[]::new` 是一个构造器引用，它有一个参数：即数组的长度。这等价于lambda表达式 `x-> new int[x]` 。

**Java有一个限制，无法构造泛型类型 `T` 的数组。数组构造器引用对于克服这个限制很有用**。表达式 `new T[n]` 是一个错误，因为它会被擦除为 *be erased to* `new Object[n]` 。对于开发类库的人来说，这是一个问题。例如，假设我们需要一个 `Person` 对象数组。`Stream` 接口有一个 `toArray` 方法可以返回 `Object` 数组：
```java
Object[] people = stream.toArray();
```
不过，这并不让人满意。用户希望得到一个 `Person` 引用数组、而不是 `Object` 引用数组。**流库利用构造器引用解决了这个问题**。可以把 `Person[]::new` 传入 `toArray` 方法：
```java
Person[] people = stream.toArray(Person[]::new);
```
`toArray` 方法调用这个构造器来得到一个正确类型的数组。然后填充这个数组并返回。

## 6.2.6 变量作用域
通常，可能希望**能在lambda表达式中访问外围方法或类中的变量**。考虑下面这个例子：
```java
public static void repeatMessage(String text, int delay) {
	ActionListener listener = event ->
		System.out.println(text);
		Toolkit.getDefaultToolkit().beep();
	};
	new Timer(delay, listener).start();
}
```
来看这样一个调用：
```java
repeatMessage("Hello", 1000); // Prints Hello every 1,000 milliseconds
```
现在来看lambda表达式中的变量 `text` 。注意这个变量**并不是**在这个lambda表达式中定义的。实际上，这是 `repeatMessage` 方法的一个参数变量。再想想看，**这里好像会有问题，尽管不那么明显**。lambda表达式的代码可能会在 `repeatMessage` 调用返回很久以后才运行，而那时这个参数变量已经不存在了。如何保留 `text` 变量呢？

要了解到底会发生什么，下面来巩固我们对lambda表达式的理解。lambda表达式有3个部分：
1. 一个代码块；
2. 参数;
3. **自由变量的值**，这是指**非参数而且不在代码里面定义的变量**。

在我们的例子中，这个lambda表达式有1个自由变量 `text` 。**表示lambda表达式的数据结构必须存储自由变量的值，在这里就是字符串"Hello"**。我们说它被lambda表达式**捕获** `captured`（下面来看具体的实现细节。例如，==可以把一个lambda表达式转换为包含一个方法的对象，这样自由变量的值就会复制到这个对象的实例变量中==）。

> 注释：关于代码块以及自由变量值有一个术语：**闭包** `closure` 。如果有人吹嘘他们的语言有闭包，现在你也可以自信地说Java也有闭包。**在Java中，lambda表达式就是闭包**。

可以看到，**lambda表达式可以捕获外围作用域 *the enclosing scope* 中变量的值**。在Java 中，为了确保所捕获的值是明确定义的，有一个重要的限制——**在lambda表达式中，只能引用值不会改变的变量**。例如，下面的做法是不合法的：
```java
public static void countDown(int start, int delay) {
	ActionListener listener = event -> {
		start--; // Error: Can't mutate captured variable
		System.out.println(start);
	};
	new Timer(delay, listener).start();
}
```
之所以有这个限制是有原因的。**如果在lambda表达式中更改变量，并发执行多个动作时就会不安全**。对于目前为止我们看到的动作不会发生这种情况，不过一般来讲，这确实是一个严重的问题。关于这个重要问题的更多内容参见第12章。

另外，**如果在lambda表达式中引用变量，而这个变量可能在外部改变，这也是不合法的**。例如，下面就是不合法的：
```java
public static void repeat(String text, int count) {
	for (int i = 1; i <= count; i++) {
		ActionListener listener = event -> {
			System.out.println(i + ": " + text);
				// Error: Cannot refer to changing i
		};
		new Timer(1000, listener).start();
	}
}
```
这里有一条规则：**lambda表达式中捕获的变量，必须实际上是事实最终变量** `effectively final` 。实际上的最终变量是指，**这个变量初始化之后就不会再为它赋新值**。在这里，`text` 总是指示同一个 `String` 对象，所以捕获这个变量是合法的。不过，`i` 的值会改变，因此不能捕获 `i` 。

==lambda表达式的体与**嵌套块**有**相同的作用域==**。这里同样适用命名冲突和遮蔽的有关规则。**在lambda表达式中，声明与一个局部变量同名的参数或局部变量是不合法的**。
```java
Path first = Paths.get("usr/bin");
Comparator<String> comp =
	(first, second) -> first.length() - second.length();
	// Error: Variable first already defined
```
**在方法中，不能有两个同名的局部变量**，因此，**lambda表达式中同样也不能有同名的局部变量**。

在一个lambda表达式中使用 `this` 关键字时，是指创建这个lambda表达式的方法的 `this` 参数。例如，考虑下面的代码：
```java
public class Application() {
	public void init() {
		ActionListener listener = event -> {
			System.out.println(this.toString());
		}
	}
}
```
表达式 `this.toString()` 会调用 `Application` 对象的 `toString` 方法，而不是 `ActionListener` 实例的方法。**在lambda表达式中，`this` 的使用并没有任何特殊之处**。lambda表达式的作用域嵌套在 `init` 方法中，与出现在这个方法中的其他位置一样，lambda表达式中 `this` 的含义并没有变化。
## 6.2.7 处理lambda表达式
到目前为止，已经了解了如何**生成lambda表达式**，以及如何**把lambda表达式传递到「需要一个函数式接口的方法」**。下面来看如何**编写方法处理lambda表达式**。

使用lambda表达式的重点是**延迟执行** `deferred execution` 。毕竟，如果想耍立即执行代码，完全可以直接执行，而无需把它包装在一个lambda表达式中。之所以希望以后再执行代码，这有很多原因，如：
- 在一个单独的线程中运行代码；
- 多次运行代码；
- 在算法的适当位置运行代码（例如，排序中的比较操作）；
- 发生某种情况时执行代码 （如，点击了一个按钮，数据到达，等等 )；
- 只在必要时才运行代码。

下面来看一个简单的例子。假设想要重复一个动作 `n` 次。将这个动作和重复次数传递到一个 `repeat` 方法：
```java
repeat(10, () -> System.out.println("Hello, World!"));
```
**要接受这个lambda表达式，需要选择（偶尔可能需要提供）一个函数式接口**。表6-1列出了Java API中提供的最重要的函数式接口。在这里，我们可以使用 `Runnable` 接口：
```java
public static void repeat(int n, Runnable action) {
	for (int i = 0; i < n; i++) action.run();
}
```
需要说明，调用 `action.run()` 时会执行这个lambda表达式的主体。
 ![表6-2 常用函数式接口](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209301007098.png)

现在让这个例子更复杂一些。我们希望告诉这个动作它出现在哪一次迭代中。为此，**需要选择一个合适的函数式接口，其中要包含一个方法，这个方法有一个 `int` 参数、且返回类型为 `void`** 。处理 `int` 值的标准接口如下：
```java
public interface IntConsumer {
	void accept(int value);
}
```
下面给出 `repeat` 方法的改进版本：
```java
public static void repeat(int n, IntConsumer action) {
	for (int i = 0; i < n; i++) action.accept(i);
}
```
可以如下调用它：
```java
repeat(10, i -> System.out.println("Countdown: " + (9 - i)));
```
表6-3列出了基本类型 `int, long, double` 的34个可用的特殊化接口。**最好使用这些特殊化接口来减少自动装箱**。在第8章会了解到，使用这些特殊化接口比使用通用接口更高效。出于这个原因，我在上一节的例子中使用了 `IntConsumer` 、而不是 `Consumer<Integer>` 。
。
![表6-3 基本类型的函数式接口](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209301017896.png)

> 提示：最好使用表6-2或表6-3中的接口。例如，假设要编写一个方法来处理满足某个特定条件的文件。对此有一个遗留接口 `java.io.FileFilter` ，不过最好使用标准的 `Predicate<File>` ，只有一种情况下可以不这么做，那就是你已经有很多有用的、生成 `FileFilter` 实例的方法。

> 注释：**大多数标准函数式接口都提供了非抽象方法来生成或合并函数** *producing or combining functions* 。例如，`Predicate.isEqual(a)` 等同于 `a::equals` ，不过如果 `a` 为 `null` 也能正常工作。**已经提供了默认方法 `and, or, negate` 来合并谓词**。例如，`Predicate.isEqual(a).or(Predicate.isEqual(b))` 就等同于 `x -> a.equals(x) || b.equals(x)` 。

 > 注释：**如果设计你自己的接口，其中只有一个抽象方法，可以用 `@FunctionalInterface` 注解来标记这个接口**。这样做有两个优点。如果你无意中增加了另一个非抽象方法，编译器会产生一个错误消息。另外 **`javadoc` 页里会指出你的接口是一个函数式接口**。
 > 
 > 并不是必须使用注解。根据定义，任何有一个抽象方法的接口都是函数式接口。不过使用 `@FunctionalInterface` 注解确实是一个很好的做法。
## 6.2.8 再谈 `Comparator`
`Comparator` 接口包含很多方便的静态方法来创建比较器。这些方法可以用于lambda表达式或方法引用。

静态 `comparing` 方法取 *takes* 一个"键提取器”函数，它将类型 `T` 映射为一个可比较的类型（如 `String` ）。**这个函数被应用到要比较的对象上面，比较将在返回的键上进行**。例如，假设有一个 `Person` 对象数组，可以如下按名字对这些对象排序：
```java
Arrays.sort(people, Comparator.comparing(Person::getName));
```
与手动实现一个 `Compamtor` 相比，这当然要容易得多。另外，代码也更为清晰，因为显然我们都希望按人名来进行比较。

可以把比较器与 `thenComparing` 方法串起来。如下，如果两个人的姓相同，就会使用第二个比较器。
```java
Arrays.sort(people,
	Comparator.comparing(Person::getLastName)
	.thenComparing(Person::getFirstName));
```
这些方法有很多变体形式。**可以为 `comparing` 和 `thenComparing` 方法提取的键，指定一个比较器**。例如，可以如下根据人名长度完成排序：
```java
Arrays.sort(people, 
	Comparator.comparing(Person::getName, 
		(s, t) -> Integer.compare(s.length(), t.length())
	)
);
```
另外，`comparing` 和 `thenComparing` 方法都有变体形式，可以避免 `int, long, double` 值的装箱。要完成前一个操作，还有一种更容易的做法：
```java
Arrays.sort(people, Comparator.comparingInt(p -> p.getName().length()));
```
**如果键函数可以返回 `null` ，可能就要用到 `nullsFirst` 和 `nullsLast` 适配器**。这些静态方法会修改现有的比较器，从而在遇到 `null` 值时不会抛出异常，而是将这个值标记为小于或大于正常值。例如，假设一个人没有中名时 `getMiddleName` 会返回一个 `null` ，就可以使用：
```java
Comparator.comparing(Person::getMiddleName(), Comparator.nullsFirst(...))。
```
**`nullsFirst` 方法需要一个比较器**，在这里就是比较两个字符串的比较器。**`naturalOrder` 方法可以为任何实现了 `Comparable` 的类建立一个比较器**。在这里，`Comparator<String>.naturalOrder()` 正是我们需要的。下面是一个完整的调用，可以按可能为 `null` 的中名进行排序。这里使用了一个静态导入 `java.util.Comparator.*` ，使这个表达式更为简洁，更便于阅读。注意 `naturalOrder` 的类型可以推导得出。
```java
Arrays.sort(people, comparing(Person::getMiddleName, nullsFirst(naturalOrder())));
```
静态 `reverseOrder` 方法会提供自然顺序的逆序。要让比较器逆序比较，可以使用 `reversed` 实例方法。例如 `naturalOrder().reversed()` 等同于 `reverseOrder()` 。

---
# 6.3 内部类
**内部类 `inner class` 是定义在另一个类中的类**。为什么需要使用内部类呢？ 其主要原因有以下三点：
- **内部类可以对同一个包中的其他类隐藏**。
- 内部类方法可以访问「该类定义所在的作用域」中的数据，包括原本私有的数据。

内部类原本对于「简洁地定义与实现回调函数」非常重要，不过如今lambda表达式在这方面可以做得更好。但内部类对于构建代码还是很有用的。下面几节详细介绍内部类。我们将这比较复杂的内容分几部分介绍。
- 在6.3.1节中，给出一个简单的内部类，它将访问外围类的实例字段。
- 在6.3.2节中，给出内部类的特殊语法规则。
- 在6.3.3节中，领略一下内部类的内部，探讨一下如何将其转换成常规类。
- 在6.3.4节中，讨论局部内部类，它可以访问外围作用域中的局部变量。
- 在6.3.5节中，介绍匿名内部类，说明在Java有lambda表达式之前用于实现回调的基
本方法。
- 在6.3.6节中，介绍如何将静态内部类嵌套在辅助类中。

 > C++注释：C++有嵌套类，一个被嵌套的类包含在外围类的作用域内。下面是一个典型
的例子，一个链表类定义了一个保存链接的类，还包含一个定义迭代器位置的类。
> ```java
> class LinkedList {
> public:
> 	class Iterator { // a nested class
> 	public:
> 		void insert(int x);
> 		int erase();
> 		...
> 	private:
> 		Link* current;
> 		LinkedList* owner;
> 	}
> private:
> 	class Link { // a nested class
> 	public:
> 		Link* prev;
> 		Link* next;
> 		...
> 	}
> 	Link* head;
> 	Link* tail;
> }
> ```
> **嵌套是一种类之间的关系，而不是对象之间的关系**。一个 `LinkedList` 对象并不包含`Iterator` 类型的子对象。
> 
> **嵌套类有两个好处：命名控制和访问控制**。由于名字 `Iterator` 嵌套在 `LinkedList` 类的内部，所以在外部被命名为 `LinkedList::Iterator` ，这样就**不会与其他名为 `Iterator` 的类发生冲突**。在Java中这个并不重要，因为**Java包已经提供了相同的命名控制**。需要注意的是，`Link` 类位于 `LinkedList` 类的私有部分，因此，`Link` 对其他的代码均不可见。鉴于此情况，可以将 `Link` 的数据字段设计为公有的，它仍然是安全的。这些数据字段只能被`LinkedList` 类 （具有访问这些数据字段的合理需要）中的方法访问，而不会暴露给其他的代码。**在Java中，只有内部类能够实现这样的控制**。
> 
> 然而，Java内部类还有一个额外的功能，这使得它比C++的嵌套类更丰富、更有用。**内部类的对象有一个隐式引用，它指向实例化该内部对象的外围类对象**。通过这个指针，可以访问外围类对象的全部状态。例如，在Java中，`Iterator` 类不需要一个显式指针指向它所指的 `LinkedList` 。后续会看到有关这个Java机制的详细介绍。
> 
> **在Java中，`static` 内部类没有这个附加指针**，这样的内部类与C++中的嵌套类很相似（相当于）。

## 6.3.1 使用内部类访问对象状态
内部类的语法相当复杂。鉴于此情况，我们选择一个简单但不太实用的例子说明内部类的使用。下面重构 `TimerTest` 示例，并抽象出一个 `TalkingClock` 类。构造一个 `TalkingClock` 语音时钟需要提供两个参数：发布通告的间隔和开关铃声的标志。
```java
public class TalkingClock {
	private int interval:
	private boolean beep;
	
	public TalkingClock(int interval, boolean beep) {...}
	public void start() { ... }

	public class TimePrinter implements ActionListener { // an inner class
		...
	}
}
```
需要注意，这里的 `TimePrinter` 类位于 `TalkingClock` 类内部。**这并不意味着每个`TalkingClock` 都有一个 `TimePrinter` 实例字段**，如前所示，`TimePrinter` 对象是由 `TalkingClock` 类的方法构造。

下面是 `TimePrinter` 类的详细内容。需要注意一点，`actionPerformed` 方法在发出铃声之前
检查了 `beep` 标志：
```java
public class TimePrinter implements ActionListener {
	public void actionPerformed(ActionEvent event) {
		System.out.println("At the tone, the time is " + new Date());
		if (beep) Toolkit.getDefaultToolkit();
	}
}
```
令人惊讶的事情发生了。`TimePrinter` 类没有实例字段或者名为 `beep` 的变量，实际上， `beep` 引用了「创建这个 `TimePrinter` 字段的 `TalkingClock` 对象」中的字段。内部类既可以访问自身的数据字段，也可以访问创建它的外围类对象的数据字段。

为了能够运行这个程序，**内部类的对象总有一个隐式引用，指向创建它的外部类对象**。如图6-3所示。
![图6-3 内部类对象拥有一个对外围类对象的引用](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209301825462.png)
**这个引用在内部类的定义中是不可见的**。然而，为了说明这个概念，我们将外围类对象的引用称为 `outer` 。于是 `actionPerformed` 方法将等价于下列形式：
```java
public void actionPerformed(ActionEvent event) {
	System.out.println("At the tone, the time is " + new Date());
	if (outer.beep) Toolkit.getDefaultToolkit().beep();
}
```
**外围类的引用在构造器中设置** *The outer class reference is set in the constructor* 。==编译器会修改所有的内部类的构造器，添加一个对应外围类引用的参数==。因为 `TimePrinter` 类没有定义构造器，所以编译器为这个类生成了一个默认的构造器，其代码如下所示：
```java
public TimePrinter(TalkingClock clock) { // automatically generated code
	outer = clock;
}
```
再注意一下，`outer` 不是Java的关键字。我们只是用它说明内部类中的机制。在 `start` 方法中构造一个 `TimePrinter` 对象后，编译器就会将「当前语音时钟的 `this` 引用」传递给这个构造器：
```java
ActionListener listener = new TimePrinter(this); // parameter automatically added
```
下面再看访问控制。如果有一个 `TimePrinter` 类是一个普通类，它就需要通过 `TalkingClock` 类的公有方法访问 `beep` 标志，而**使用内部类是一个改进，不必提供仅用于另外一个类的访问器**。
> 注释：我们也可以把 `TimePrinter` 类声明为私有的。这样一来，只有 `TalkingClock` 的方法才能够构造 `TimePrinter` 对象。==只有内部类可以是私有类，而常规类只可以具有包可见性、或公有可见性== *Only inner classes can be private. Regular classes always have either package or public access* 。

程序 `InterfaceLambda/innerClass/InnerClassTest.java` 给出了测试这个内部类的完整程序。
```java
// InterfaceLambda/innerClass/InnerClassTest.java
package innerClass;

import java.awt.*;
import java.awt.event.*;
import java.time.*;
import javax.swing.*;

/**
 * This program demonstrates the use of inner class.
 */
public class InnerClassTest {
	public static void main(String[] args) {
		var clock = new TalkingClock(1000, true);
		clock.start();

		// keep program running util the user selects "OK"
		JOptionPane.showMessageDialog(null, "Quit program?");
		System.exit(0);
	}
}

/**
 * A clock that prints the time in regular intervals.
 */
class TalkingClock {
	private int interval;
	private boolean beep;

	/**
	 * Constructs a talking clock
	 * @param interval the interval between messages (in milliseconds)
	 * @param beep true if the clock should beep
	 */
	public TalkingClock(int interval, boolean beep) {
		this.interval = interval;
		this.beep = beep;
	}

	/**
	 * Starts the clock.
	 */
	public void start() {
		var listener = new TimePrinter();
		var timer = new Timer(interval, listener);
		timer.start();
	}

	public class TimePrinter implements ActionListener {
		public void actionPerformed(ActionEvent event) {
			System.out.println("At the tone, the time is " 
				+ Instant.ofEpochMilli(event.getWhen())
			);
			if (beep) Toolkit.getDefaultToolkit().beep();
		}
	}
}
```
运行结果如下所示（会不断发出蜂鸣音）：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211040112883.png)
## 6.3.2 内部类的特殊语法规则
在上一节中，已经讲述了内部类有一个外围类的引用 `outer` 。事实上，使用外围类引用的正规语法还要复杂一些。**表达式 `OuterClass.this` 表示外围类引用**。例如，可以像下面这样编写 `TimePrinter` 内部类的 `actionPerformed` 方法：
```java
public void actionPerformed(ActionEvent event) {
	if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();
}
```
反过来，可以采用下列语法格式、更加明确地写出内部类对象的构造器 *write the inner object constructor* ：
```java
outerObject.new InnerClass(construction parameters)
```
例如，
```java
ActionListener listener = this.new TimePrinter();
```
在这里，**最新构造的 `TimePrinter` 对象的外围类引用，被设置为创建内部类对象的方法中的 `this` 引用** *the reference of the method that creates the inner class object* 。这是一种最常见的情况。通常，`this` 限定词是多余的。不过，可以通过显式地命名将外围类引用设置为其他的对象。例如，**由于 `TimePrinter` 是一个公有内部类，对于任意的语音时钟都可以构造一个 `TimePrinter`** ：
```java
TalkingClock jabberer = new TalkingClock(1000, true);
TalkingClock.TimePrinter listener = jabberer.new TimePrinter();
```
需要注意，在外围类的作用域之外，可以这样引用内部类：
```java
OuterClass.InnerClass
```
> 注释：**内部类中声明的所有静态字段都必须是 `final`，并初始化为一个编译时常量**。原因很简单。我们希望一个静态字段只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个字段不是 `final`（即常量），它可能就不是唯一的。
> 
> **内部类不能有 `static` 方法**。Java语言规范对这个限制没有做任何解释。也可以允许有静态方法，但只能访问外围类的静态域和方法。显然，Java设计者认为相对于这种复杂性来说，它带来的好处有些得不偿失。
## 6.3.3 内部类是否有用、必要和安全
当Java在Java 1.1中增加内部类时，很多程序员都认为这是一项很主要的新特性，但这却违背了Java要比C++更加简单的设计理念。内部类的语法很复杂（稍后介绍的匿名内部类更加复杂）。它与访问控制和安全性等其他的语言特性没有明显的关联。

由于增加了一些看似优美有趣、实属没必要的特性，似乎Java也开始走上了许多语言饱受折磨的毁灭性道路上。我们并不打算就这个问题给予一个完整的答案。

需要指出，==内部类是一种编译器现象 *a phenomenon of the compiler* ，与虚拟机无关==。**编译器将会把内部类转换为常规的类文件**，用 `$` 分隔外部类名与内部类名，而虚拟机则对此一无所知。例如，在 `TalkingClock` 类内部的 `TimePrinter` 类将被翻译成类文件 `TalkingClock$TimePrinter.class` 。

为了查看它的实际工作，可以做一下这个实验：运行第5章中的程序 `ReflectionTest` ，并将类 `TalkingClock$TimePrinter` 传递给它进行反射。也可以选择简单地使用 `javap` ，如下所示:
```java
javap -private ClassName
```
> 注释：如果使用UNIX，并在命令行上提供类名，就需要记住将 `$` 字符进行转义。也就是说，应该按照下面这种格式运行 `javap` 或 `ReflectionTest` 程序：
> ```java
> java reflection.ReflectionTest innerClass.TalkingClock\$TimePrinter
> ```
> 或
> ```
> javap -private innerClass.TalkingClock\$TimePrinter
> ```

这时会看到下面的输出结果：
```java
public class innerClass.TalkingClock$TimePrinter
	implements java.awt.event.ActionListener 
{
	final innerClass.TalkingClock this$0;
	public innerClass.TalkingClock$TimePrinter(innerClass.TalkingClock);
	public void actionPerformed(java.awt.event.ActionEvent);
}
```
可以清楚地看到，**编译器为了引用外围类，生成了一个附加的实例字段 `this$0`**（名字 `this$0` 是编译器合成的，在自己编写的代码中不能够引用它）。另外，**还可以看到构造器的 `TalkingClock` 参数**。

如果编译器能自动完成这个转换，那么能不能自己编写程序实现这种机制呢？让我们试试看。将 `TimePrinter` 定义成一个常规类，并把它置于 `TalkingClock` 类的外部。在构造`TimePrinter` 对象的时候，传入「创建它的对象」的 `this` 指针。
```java
class TalkingClock {
	...
	public void start() {
		ActionListener listener = new TimePrinter(this);
		Timer t = new Timer(interval, listener);
		t.start();
	}
}

class TimePrinter implements ActionListener {
	private TalkingClock outer;
	...
	public TimePrinter(TalkingClock clock) {
		outer = clock;
	}
}
```
现在，看一下 `actionPerformed` 方法，它需要访问 `outer.beep` 。
```java
if (outer.beep) ... // Error
```
这就遇到了一个问题。内部类可以访问外围类的私有数据，但这里的 `TimePrinter` 类则不行。可见，**由于内部类拥有访问特权，所以与常规类比较起来功能更加强大**。

可能有人会好奇，既然内部类会被翻译成名字古怪的常规类（而虚拟机对此一点也不了解），**内部类又如何得到那些额外的访问特权呢**？为了揭开这个谜团，让我们再利用 `ReflectionTest` 程序査看一下 `TalkingClock` 类：
```java
class TalkingClock {
	private int interval;
	private boolean beep;
	
	public TalkingClock(int, boolean);
	
	static boolean access$0(TalkingClock);
	public void start();
}
```
注意，**编译器在外围类添加静态方法 `access$0` 。它将返回「作为参数传递的那个对象」的 `beep` 字段**（方法名可能稍有不同，如 `access$000` ，这取决于你的编译器）。内部类方法将调用那个方法。在 `TimePrinter` 类的 `actionPerformed` 方法中，语句 `if (beep)` 实际上会产生以下调用：
```java
if (TalkingClock.access$0(outer))
```
这样做不是存在安全风险吗？这种担心是很有道理的。**任何人都可以通过调用 `access$0` 方法、很容易地读取到私有字段 `beep`** 。当然，`access$0` 不是Java的合法方法名。但熟悉类文件结构的黑客，能使用十六进制编辑器、轻松地创建一个类文件，其中用虚拟机指令调用那个方法。*由于隐秘方法需要拥有包可见性，所以攻击代码需要与被攻击类放在同一个包中*。

总而言之，如果内部类访问了私有数据字段，就有可能通过「外围类所在包中增加的其他类」访问那些字段，但做这些事情需要高超的技巧和极大的决心。程序员不可能无意之中就获得对类的访问权限，而必须刻意地构建或修改类文件，才有可能达到这个目的。
> 注释：合成的构造器和方法令人费解（如果过于注重细节 *squeamish* ，可以跳过这个注释）。假设将 `TimePrinter` 转换为一个**私有内部类**。**而在虚拟机中不存在私有类，因此编译器会生成一个近乎最好的结果，生成的这个类有包可见性（没有私有外部类）和一个私有构造器**：
> ```java
> private TalkingClock$TimePrinter(TalkingClock);
> ```
> 当然，没有人可以调用这个构造器，因此，**存在第二个包可见构造器**：
> ```java
> TalkingClock$TimePrinter(TalkingClock, TalkingClock$1):
> ```
> 它将调用第一个构造器。合成 `TalkingClock$1` 类只是为了将这个构造器与其他构造器区分开。
> 
> 编译器将 `TalkingClock` 类 `start` 方法中的构造器调用转换为（就是调用第二个包可见构造器）：
> ```java
> new TalkingClock$TimePrinter(this, null)
> ```

## 6.3.4 局部内部类
如果仔细地阅读 `TalkingClock` 示例代码就会发现，`TimePrinter` 这个类名字、只在 `start` 方法中创建这个类型的对象时使用了一次。**当遇到这类情况时，可以在一个方法中定义局部类**。
```java
public void start() {
	class TimePrinter implements ActionListener {
		public void actionPerformed(ActionEvent event) {
			System.out.println("At the tone, the time is " + new Date());
			if (beep) Toolkit.getDefaultToolkit().beep();
		}
	}
	ActionListener listener = new TimePrinter();
	Timer t = new Timer(interva1, listener);
	t.start();
}
```
**声明局部类时不能有访问说明符（即`public` 或 `private`）**，它的作用域被限定在「声明这个局部类的块」中。

**局部类有一个很大的优势，即对外部世界完全隐藏**。甚至 `TalkingClock` 类中的其他代码也不能访问它。除 `start` 方法之外，没有任何方法知道 `TimePrinter` 类的存在。
## 6.3.5 由外部方法访问变量
与其他内部类相比较，局部类还有一个优点。**它们不仅能够访问「包含它们的外部类的字段」，还可以访问局部变量**。不过，那些局部变量必须是事实最终变量 `effectively final`（即事实上为 `final` ）。这说明，它们一旦赋值就绝不会改变。

下面是一个典型的示例。这里，将 `TalkingClock` 构造器的参数 `interval` 和 `beep` 移至 `start` 方法中。
```java
public void start(int interval, boolean beep) {
	class TimePrinter implements ActionListener {
		public void actionPerformed(ActionEvent event) {
			System.out.println("At the tone, the time is " + new Date());
			if (beep) Toolkit.getDefaultToolkit().beep();
		}
	}
	ActionListener listener = new TimePrinter();
	Timer t = new Timer(interval, listener);
	t.start();
}
```
注意，`TalkingClock` 类不再需要存储实例变量 `beep` 了，它只是引用 `start` 方法中的 `beep` 参数变量。这看起来好像没什么值得大惊小怪的。程序行 `if (beep) ...` 毕竟在 `start` 方法内部，为什么不能访问 `beep` 变量的值呢？

为了能清楚地看到内部的问题，让我们仔细地考査一下控制流程。
1. 调用 `start` 方法。
2. 调用内部类 `TimePrinter` 的构造器，以便初始化对象变量 `listener` 。
3. 将 `listener` 引用传递给 `Timer` 构造器，定时器开始计时，整个 `start` 方法结束。此时，`start` 方法的 `beep` 参数变量不复存在。
4. 然后，`actionPerformed` 方法执行 `if (beep) ...` 。

为了能让 `actionPerformed` 方法工作，`TimePrinter` 类在 `beep` 字段释放之前，必须将 `beep` 字段用 `start` 方法的局部变量进行备份 *have copied the beep field as a local variable of the start method* 。实际上也是这样做的。在例子中，编译器为局部内部类构造了名字 `TalkingClock$TimePrinter` 。如果再次运行 `ReflectionTest` 程序，查看 `TalkingClock$TimePrinter` 类，就会看到下列结果：
```java
class TalkingClock$TimePrinter {
	TalkingClock$TimePrinter(TalkingClock, boolean);
	public void actionPerformed(java.awt.event.ActionEvent);
	
	final boolean val$beep;
	final TalkingClock this$0;
}
```
注意构造器的 `boolean` 参数和 `val$beep` 实例变量。当创建一个对象时，`beep` 就会被传递给构造器，并存储在 `val$beep` 字段中。==编译器检测对局部变量的访问，为每一个变量建立相应的实例字段，并将局部变量复制到构造器中，从而将这些实例字段初始化为局部变量的副本==。

从程序员的角度看，**局部变量的访问非常容易。它减少了需要显式编写的实例字段，从而使得内部类更加简单**。

前面曾经提到，**局部类的方法只可以引用事实最终局部变量**。鉴于此情况，在列举的示例中，（编译器）将 `beep` 参数声明为 `final` ，对它进行初始化后不能再进行修改。因此，就使得局部变量与「在局部类内建立的拷贝」保持一致。
> 注释：在Java SE 8之前，必须把「从局部类访问的局部变量」声明为 `final` 。例如，`start` 方法原本应当这样声明，从而使内部类能够访问 `beep` 参数：
> ```java
> public void start(int interval, final boolean beep)
> ```

有时，`final` 限制显得并不太方便。例如，假设想更新在一个封闭作用域内的计数器。这里想统计在排序过程中调用 `compareTo` 方法的次数。
```java
int counter = 0;
Date[] dates = new Date[100];
for (int i = 0; i < dates.length; i++)
	dates[i] = new Date() { // 匿名内部类
		public int compareTo(Date other) {
			counter++; // Error
			return super.compareTo(other);
		}
	};
Arrays.sort(dates);
System.out.println(counter + " comparisons.");
```
由于清楚地知道 `counter` 需要更新，所以不能将 `counter` 声明为 `final` 。由于 `Integer` 对象是不可变的，所以也不能用 `Integer` 代替它。补救的方法是使用一个长度为1的数组：
```java
int[] counter = new int[1];
for (int i = 0; i < dates.length; i++)
	dates[i] = new Date() {
		public int compareTo(Date other) {
			counter[0]++;
			return super.compareTo(other);
		}
	};
```
在内部类被首次提出时，原型编译器对内部类中修改的局部变量自动地进行转换。不过，后来这种做法被废弃。毕竟，这里存在一个危险。**同时在多个线程中执行内部类中的代码时，这种并发更新会导致竞态条件**——有关内容参见第12章。
## 6.3.6 匿名内部类
将局部内部类的使用再深入一步。假如只想创建这个类的一个对象，就不必命名了。这种类被称为**匿名内部类** `anonymous inner class` 。
```java
public void start(int interval, boolean beep) {
	ActionListener listener = new ActionListener() {
		public void actionPerformed(ActionEvent event) {
			System.out.println("At the tone, the time is " + new Date());
			if (beep) Toolkit.getDefaultToolkit().beep();
		}
	};
	Timer t = new Timer(interval, listener);
	t.start();
}
```
这种语法确实有些难以理解 `cryptic` 。它的含义是：**创建一个实现`ActionListener` 接口的类的新对象，需要实现的方法 `actionPerformed` 定义在括号 `{}` 内**。

通常的语法格式如下。其中，`SuperType` 可以是接口，如 `ActionListener` ，如果是这样，**内部类就要实现这个接口**。`SuperType` 也可以是一个类，如果是这样，**内部类就要扩展这个类**。
```java
new SuperType(construction parameters) {
	inner class methodsand data
}
```
==由于构造器的名字必须与类名相同，而匿名内部类没有类名，所以，**匿名内部类不能有构造器==**。实际上，**构造参数要传递给超类 `superclass` 构造器**。具体地，**只要内部类实现一个接口，就不能有任何构造参数**。不过，仍然要提供一组小括号：
```java
new InterfaceType() {
	methods and data
}
```
必须仔细研究，「构造一个类的新对象」与「构造一个扩展了那个类的匿名内部类的对象」之间有什么差别。
```java
Person queen = new Person("Mary"); // a Person object
Person count = new Person("Dracula") { ... };
	// an object of an inner class extending Person
```
如果构造参数列表 *construction parameter list* 的闭小括号 *closing parenthesis* 后面跟一个开大括号 *opening brace* ，正在定义的就是匿名内部类。
> 注释：**尽管匿名类不能有构造器，但可以提供一个对象初始化块**。
> ```java
> var count = new Person("Dracula") {
> 	{ initialization } 
> }
> ```
 
`InterfaceLambda/anonymousInnerClass/AnonymousInnerClassTest.java` 包含了用匿名内部类实现语音时钟程序的全部源代码。将这个程序与之前比较，就会发现使用匿名内部类的解决方案比较简短、 更切实际、 更易于理解。

多年来，Java程序员习惯的做法是**用匿名内部类实现事件监听器和其他回调**。如今最好还是使用lambda表达式。例如，这一节前面给出的 `start` 方法用lambda表达式来写会简洁得多，如下所示：
```java
public void start(int interval, boolean beep) {
	var t = new Timer(interval, event -> {
		System.out.println("At the tone，the time is " + new Date());
		if (beep) Toolkit.getDefaultToolkit().beep();
	});
	t.start();
}
```

```java
// anonymousInnerClass/AnonymousInnerClassTest.java
package anonymousInnerClass;

import java.awt.*;
import java.awt.event.*;
import java.time.*;

import javax.swing.*;

/**
 * This program demonstrates anonymous inner classes.
 */
public class AnonymousInnerClass {
	public static void main(String[] args) {
		var clock = new TalkingClock();
		clock.start(1000, true);

		// keep program running until the user selects "OK"
		JOptionPane.showMessageDialog(null, "Quit program?");
		System.exit(0);
	}
}

/**
 * A clock that prints the time in regular intervals.
 */
class TalkingClock {
	/**
	 * Starts the clock.
	 * @param interval the interval between messages (in milliseconds)
	 * @param beep true if the clock should beep
	 */
	public void start(int interval, boolean beep) {
		var listener = new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				System.out.println("At the tone, the time is " 
					+ Instant.ofEpochMilli(event.getWhen()));
				if (beep) Toolkit.getDefaultToolkit().beep();
			}
		};
		var timer = new Timer(interval, listener);
		timer.start();
	} 
}
```
 
> 注释：下面的技巧称为**双括号初始化** `double brace initialization` ，这里**利用了内部类语法**。假设想构造一个数组列表，并将它传递到一个方法：
> ```java
> var friends = new ArrayList\<String>();
> friends.add("Harry");
> friends.add("Tony");
> invite(friends);
> ```
> 如果不再需要这个数组列表，最好让它作为一个匿名列表。不过作为一个匿名列表，该如何为它添加元素呢？方法如下：
> ```java
> invite(new ArrayList\<String>() {{ add("Harry"); add("Tony"); }});
> ```
> 注意这里的双括号。**外层括号建立了 `ArrayList` 的一个匿名子类，内层括号则是一个对象构造块**（见第4章）。

> 警告：建立一个与超类大体类似（但不完全相同）的匿名子类通常会很方便。不过，对于 `equals` 方法要特别当心。第5章中曾建议 `equals` 方法最好使用以下测试：
> ```java
> if (getClass() != other.getClass()) return false;
> ```
> 但是对匿名子类做这个测试时会失败。

> 提示：**生成日志或调试消息时，通常希望包含当前类的类名**，如：
> ```java
> System.err.println("Something awful happened in " + getClass());
> ```
> 不过，**这对于静态方法不奏效**。毕竟，调用 `getClass` 时调用的是 `this.getClass()` ，而静态方法没有 `this` 。所以应该使用以下表达式：
> ```java
> new Object(){}.getClass().getEnclosingClass() // gets class of static method
> ```
> 在这里，**`newObject(){}` 会建立 `Object` 的一个匿名子类的一个匿名对象，`getEnclosingClass` 则得到其外围类，也就是包含这个静态方法的类**。

## 6.4.7 静态内部类
有时候，==使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象==。为此，可以将内部类声明为 `static` ，以便取消产生的那个引用。

下面是一个想使用静态内部类的典型例子。考虑计算数组中最小值和最大值的问题。当然，可以编写两个方法，一个方法用于计算最小值，另一个方法用于计算最大值。在调用这两个方法的时候，数组被遍历两次。如果只遍历数组一次，并能够同时计算出最小值和最大值，那么就可以大大地提高效率了。
```java
double min = Double.POSITIVE_INFINITY;
double max = Double.NEGATIVE.INFINITY;
for (double v : values) {
	if (min > v) min = v;
	if (max < v) max = v;
}
```
然而，这个方法必须返冋两个数值，为此，可以定义一个包含两个值的类 `Pair` ：
```java
class Pair {
	private double first;
	private double second;
	public Pair(double f, double s) {
		first = f;
		second = s;
	}
	public double getFirst() { return first; }
	public double getSecond() { return second; }
}
```
`minmax` 方法可以返回一个 `Pair` 类型的对象。
```java
class ArrayAlg {
	public static Pair minmax(double[] values) {
		...
		return new Pair(min, max);
	}
}
```
这个方法的调用者可以使用 `getFirst` 和 `getSecond` 方法获得答案：
```java
Pair p = ArrayAlg.minmax(d);
System.out.println("min = " + p.getFirst());
System.out.println("max = " + p.getSecond());
```
当然，`Pair` 是一个十分大众化的名字。在大型项目中，除了定义包含一对字符串的 `Pair` 类之外，其他程序员也很可能使用这个名字。这样就会产生名字冲突。解决这个问题的办法是，**将 `Pair` 定义为 `ArrayAlg` 的内部公有类**。此后，通过 `ArrayAlg.Pair` 访问它：
```java
ArrayAlg.Pair p = ArrayAlg.minmax(d);
```
不过，与前面例子中所使用的内部类不同，**在 `Pair` 对象中不需要引用任何其他的对象，为此可将这个内部类声明为 `static` ，从而不生成那个引用**：
```java
class ArrayAlg {
	public static class Pair {
		...
	}
	...
}
```
当然，**只有内部类可以声明为 `static`** 。==静态内部类就类似其他内部类，只不过静态内部类的对象没有「生成它的外围类对象的引用」==。

特别地，在我们的示例中，必须使用静态内部类，这是由于**内部类对象是在静态方法中构造的**：
```java
public static Pair minmax(double[] d) {
	...
	return new Pair(min, max);
}
```
如果没有将 `Pair` 类声明为 `static` ，那么编译器将会给出错误报告，指出没有可用的隐式 `ArrayAlg` 类型对象来初始化内部类对象。
> 注释：**只要内部类不需要访问外围类对象，就应该使用静态内部类**。有些程序员用嵌套类 *nested class* 表示静态内部类。

> 注释：与常规内部类不同，**静态内部类可以有静态字段和方法**。常规内部类中声明的所有静态字段必须是 `final` 的，且不能有静态方法。

> 注释：在接口中声明的内部类，自动成为 `static` 和 `public` 类。

`staticInnerClass/StaticInnerClassTest.java` 包含 `ArrayAlg` 类和嵌套的 `Pair` 类的全部源代码。
```java
// staticInnerClass/StaticInnerClassTest.java
package staticInnerClass;

/**
 * This program demonstrates the use of static inner classes.
 */
public class StaticInnerClassTest {
	public static void main(String[] args) {
		var values = new double[20];
		for (int i = 0; i < values.length; ++i)
			values[i] = 100 * Math.random();
		ArrayAlg.Pair p = ArrayAlg.minmax(values);
		System.out.println("min = " + p.getFirst());
		System.out.println("max = " + p.getSecond());
	}
}

class ArrayAlg {
	/**
	 * A pair of floating-point numbers
	 */
	public static class Pair {
		private double first;
		private double second;

		/**
		 * Constructs a pair from two floating-point numbers
		 * @param f the first number
		 * @param s the second number
		 */
		public Pair(double f, double s) {
			first = f;
			second = s;
		}

		/**
		 * Returns the first number of the pair
		 * @return the first number
		 */
		public double getFirst() {
			return first;
		}

		/**
		 * Returns the second number of the pair
		 * @return the second number
		 */
		public double getSecond() {
			return second;
		}

		/**
		 * Computes both the minimum and the maximum of an array
		 * @param values an array of floating-point numbers
		 * @return a pair whose first element is the minimum and
		 * whose second element is the maximum
		 */
		public static Pair minmax(double[] values) {
			double min = Double.POSITIVE_INFINITY;
			double max = Double.NEGATIVE_INFINITY;
			for (double v : values) {
				if (min > v) min = v;
				if (max < v) max = v;
			}
			return new Pair(min, max);
		}
	}

}
```

---
# 6.4 服务加载器
有时会开发一个**服务架构** *service architecture* 的应用。有些平台支持这种方法，如[OSGi](http://osgi.org)，可以用于开发环境、应用服务器和其他复杂的应用。这些平台超出了讨论范畴，不过**JDK还提供了一个加载服务的简单机制**（这里会介绍），这种机制由Java平台模块系统提供支持，详细内容见卷II第9章。

通常提供一个服务时，程序希望服务设计者能有一些自由，能确定如何实现服务的特性。另外还希望有多个实现以供选择。**利用 `ServiceLoader` 类可以很容易加载符合一个公共接口的服务**。

定义一个接口（或者，如果愿意也可以定义一个超类），其中包含服务的各个实例应当提供的方法。例如，假设你的服务要提供加密。
```java
package serviceLoader;

public interface Cipher {
	byte[] encrypt(byte[] source, byte[] key);
	byte[] decrypt(byte[] source, byte[] key);
	int strength();
}
```
服务提供者可以提供一个或多个实现这个服务的类，例如：
```java
package serviceLoader.impl;

public class CaesarCipher implements Cipher {
	public byte[] encrypt(byte[] source, byte[] key) {
		var result = new byte[source.length];
		for (int i = 0; i < source.length; ++i)
			result[i] = (byte)(source[i] + key[0]);
		return result;
	}

	public byte[] decrypt(byte[] source, byte[] key) {
		return encrypt(source, new byte[] { (byte) -key[0] });
	}

	public int strength() { return 1; }
}
```
实现类可以放在任意的包中，而不一定是服务接口所在的包。**每个实现类必须有一个无参数构造器**。

现在，把这些类的类名增加到 `META-INF/services` 目录下的一个UTF-8编码文本文件中，**该文件名必须与完全限定类名一致**。在我们的例子中，文件 `META-INF/services/serviceLoader.Cipher` 必须包含这样一行：
```java
serviceLoader.impl.CaesarCipher
```
在这个例子中，我们提供了一个实现类。还可以提供多个类，以后可从中选择。完成这个准备工作后，**程序可以如下初始化一个服务加载器**：
```java
public static ServiceLoader<Cipher> cipherLoader = ServiceLoader.load(Cipher.class);
```
这个初始化工作只在程序中完成一次。

服务加载器的 `iterator` 方法，会返回一个迭代器来迭代处理「所提供的所有服务实现」，有关迭代器的更多信息参见第9章。最容易的做法是，**使用一个增强的 `for` 循环进行遍历**。在循环中，选择一个适当的对象来完成服务。
```java
public static Cipher getCipher(int minStrength) {
	for (Cipher cipher : cipherLoader) { // implicitly calls cipherLoader.iterator()
		if (cipher.strength() >= minStrength) return cipher;
	}
	return null;
}
```
或者也可使用流（卷II第1章）来定位所要的服务。`stream` 方法会生成一个 `ServiceLoader.Provider` 实例的流。这个接口包含 `type` 和 `get` 方法，可以用来得到提供者类和提供者实例 *getting the provider class and the provider instance* 。如果按类型选择一个提供者，只需要调用 `type` 、而没有必要实例化任何服务实例（ `Optional` 类在卷II第1章详细解释）。
```java
public static Optional<Cipher> getCipher2(int minStrength) {
	return cipherLoader.stream()
		.filter(descr -> descr.type() == serviceLoader.impl.CaeserCipher.class)
		.findFirst()
		.map(ServiceLoader.Provider::get);
}
```
最后，如果想要得到任一服务实例，只需要调用 `findFirst` ：
```java
Optional<Cipher> cipher = cipherLoader.findFirst();
```

> `java.util.ServiceLoader<S>` 1.6
> - `static <S> ServiceLoader<S> load(Class<S> service)`
> 创建一个服务加载器，来加载「实现给定服务接口的类」。
> - `Iterator<S> iterator()`
> 生成一个以懒方式加载服务类的迭代器。即，迭代器推进时才会加载类。
> - `Stream<ServiceLoader.Provider<S>> stream()` 9
> 返回提供者描述符的一个流，从而可以懒加载「所要的类的提供者」。
> - `Optional<S> findFirst()` 9
> 查找第一个可用的服务提供者（如果有）。

> `java.util.ServiceLoader.Provider<S>` 9
> - `Class<? extends S> type()`
> 获得这个提供者的类型。
> - `S get()`
> 获得这个提供者的实例。


---	
# 6.5 代理
最后讨论一下**代理** `proxy` 。利用代理，可以**在运行时创建一个实现了一组给定接口的新类** *create, at runtime, new classes that implement a given set of interfaces* ——**这一功能，只有在编译时你无法确定需要实现哪个接口时、才有必要使用**。对于应用程序设计人员来说，遇到这种情况的机会很少。然而，对于系统程序设计人员来说，代理带来的灵活性却十分重要。
## 6.5.1 何时使用代理
假设有个表示接口的 `Class` 对象（或对象数组，包含一个或多个接口），它们的确切类型在编译时你可能并不知道，又想要构造一个「实现了这些接口的类」的对象。这个问题确实有些难度。

要想构造一个具体的类，只需要使用 `newInstance` 方法或者使用反射、找出这个类的构造器。但是，**不能实例化一个接口。我们需要在程序处于运行状态时定义一个新类**。

为了解决这个问题，有些程序会生成代码；将这些代码放置在一个文件中，调用编译器，然后再加载结果类文件。很自然，这样做的速度会比较慢，并且需要将编译器与程序一起部署。而代理机制则是一种更好的解决方案。**代理类可以在运行时创建全新的类，这样的代理类能够实现你指定的接口**。具体地，它包含下列方法：
- 指定接口所需要的全部方法。
- `Object` 类中的全部方法，例如，`toString, equals` 等。

然而，**不能在运行时为这些方法定义新代码**。实际上，必须提供一个**调用处理器** `invocation handler` 。调用处理器是实现了 `InvocationHandler` 接口的类对象。这个接口中只有一个方法：
```java
Object invoke(Object proxy, Method method, Object[] args)
```
无论何时调用代理对象的方法（包括接口方法和 `Object` 方法）*a method is called on the proxy object* ，调用处理器的 `invoke` 方法都会被调用，并向其传递 `Method` 对象和原始的调用参数。调用处理器必须给出处理调用的方式。
## 6.5.2 创建代理对象
要想**创建一个代理对象**，需要使用 `Proxy` 类的 `newProxyInstance` 方法。这个方法有三个参数：
- 一个类加载器 `class loader` 。**作为Java安全模型的一部分，可以对平台和应用类、从因特网上下载的类等使用不同的类加载器**。有关类加载器的详细内容在卷II第9章。这个例子中，我们指定“系统类加载器”加载平台和应用类。
- 一个 `Class` 对象数组，每个元素对应需要实现的各个接口。
- 一个**调用处理器**。

还有两个需要解决的问题。如何定义一个处理器？另外，**对于得到的代理对象能够做些什么**？当然，这两个问题的答案，取决于我们打算用代理机制解决什么问题。使用代理可能出于很多原因，例如：
- 将方法调用路由到远程服务器。
- 在程序运行期间，将用户界面事件与动作关联起来。
- 为了调试，跟踪方法调用。

在示例程序中，我们使用代理和调用处理器跟踪方法调用。**我们定义了一个 `TraceHander` 包装器类来存储一个「被包装的对象」即 `target`** 。其中的 `invoke` 方法会打印出「所调用方法的名字和参数」，随后用**包装好的对象**作为隐式参数调用这个方法。
```java
class TraceHandler implements InvocationHandler {
	private Object target;
	
	public TraceHandler(Object t) {
		target = t;
	}
	
	public Object invoke(Object proxy, Method m, Object[] args) 
		throws Throwable {
		// print method name and parameters
		...
		// invoke actual method
		return m.invoke(target, args);
	}
```
下面说明如何构造「可以跟踪方法调用的代理对象」。
```java
Object value = ...;

// construct wrapper
InvocationHandler handler = new TraceHandler(value);
// construct proxy for one or more interfaces
Class[] interfaces = new Class[] { Comparable.class };

Object proxy = Proxy.newProxyInstance(null, interfaces, handler);
```
现在，无论何时在 `proxy` 上调用了某个接口的方法，这个方法的名字和参数就会打印出来，之后再用 `value` 调用这个方法。

在给出的程序 `InterfaceLambda/proxy/ProxyTest.java` 中，**我们使用代理对象跟着一个二分查找**。这里，首先用1~1000整数的代理填充数组，然后调用 `Arrays` 类中的 `binarySearch` 方法、在数组中查找一个随机整数。最后，打印出与之匹配的元素。
```java
Object[] elements = new Object[1000];
// fill elements with proxies for the integers 1...1000
for (int i = 0; i < elements.length; i++) {
	Integer value = i + 1;
	elements[i] = Proxy.newProxyInstance(...); // proxy for value;
}	

// construct a random integer
Integer key = new Random().nextInt(elements.length) + 1;

// search for the key
int result = Arrays.binarySearch(elements, key);

// print match if found
if (result >= 0) System.out.println(elements[result]);
```
在上述代码中，`Integer` 类实现了 `Comparable` 接口。**代理对象属于在运行时定义的类** （它有一个名字，如 `$Proxy0` ），这个类也实现了 `Comparable` 接口。不过，它的 `compareTo` 方法调用了代理对象处理器 *the proxy object’s handler* 的 `invoke` 方法。

> 注释：前面已经讲过，在Java SE 5.0中，`Integer` 类实际上实现了 `Comparable<Integer>` 。然而，**在运行时，所有的泛型类型都被擦除**，会用对应原始 `Comparable` 类的类对象来构造代理 *the proxy is constructed with the class object for the raw Comparable class.*

`binarySearch` 方法按下面这种方式调用：
```java
if (elements[i].compareTo(key) < 0) ...
```
由于数组中填充了代理对象，所以 `compareTo` 调用了 `TraceHander` 类中的 `invoke` 方法。这个方法打印出了方法名和参数，之后在包装好的 `Integer` 对象上调用 `compareTo` 。

最后，在示例程序的结尾调用：
```java
System.out.println(elements[result]);
```
**`println` 方法调用代理对象的 `toString` ，这个调用也会被重定向到调用处理器上**。

下面是程序运行的全部跟踪结果。可以看出二分查找算法查找关键字的过程，即每一步都将查找区间缩减一半。注意，**即使不属于 `Comparable` 接口，`toString` 方法也会被代理**。在下一节中会看到，有相当一部分的 `Object` 方法都会被代理。
```java
500.compareTo(288)
250.compareTo(288)
375.compareTo(288)
312.compareTo(288)
281.compareTo(288)
296.compareTo(288)
288.compareTo(288)
288.toString()
```

```java
// proxy/ProxyTest.java
package proxy;

import java.lang.reflect.*;
import java.util.*;

/**
 * This program demonstrates the use of proxies.
 */
public class ProxyTest {
	public static void main(String[] args) {
		var elements = new Object[1000];

		// fill elements with proxies for the integer 1...1000
		for (int i = 0; i < elements.length; ++i) {
			Integer value = i + 1;
			var handler = new TraceHandler(value);
			Object proxy = Proxy.newProxyInstance(
				ClassLoader.getSystemClassLoader(),
				new Class[] { Comparable.class }, handler
			);
			elements[i] = proxy;
		}

		// construct a random integer
		Integer key = new Random().nextInt(elemetns.length) + 1;

		// search for the key
		int result = Arrays.binarySearch(elements, key);

		// print match if found
		if (result >= 0) System.out.println(elements[result]);
	}
}

/**
 * An invocation handler that prints out the method name and parameters, then
 * invokes the original method
 */
class TraceHandler implements InvocationHandler {
	private Object target;

	/**
	 * Constructs a TraceHandler
	 * @param t the implicit parameter of the method call
	 */
	public TraceHandler(Object t) {
		target = t;
	}

	public Object invoke(Object proxy, Method m, Object[] args) throws Throwable {
		// print implicit argument
		System.out.print(target);
		// print method name
		System.out.print("." + m.getName() + "(");
		// print explicit arguments
		if (args != null) {
			for (int i = 0; i < args.length; ++i) {
				System.out.print(args[i]);
				if (i < args.length - 1) System.out.print(", ");
			}
		}
		System.out.println(")");

		// invoke actual method
		return m.invoke(target, args);
	}
}
```

## 6.5.3 代理类的特性
现在，我们已经看到了代理类的应用，接下来了解它们的一些特性。需要记住，**代理类是在程序运行过程中动态创建的**。然而，==一旦被创建，它们就变成了常规类，与虚拟机中的任何其他类没什么区别==。

**所有的代理类都扩展自 `Proxy` 类**。**一个代理类只有一个实例字段——调用处理器，它定义在 `Proxy` 的超类中**。为了履行代理对象的职责，所需要的任何额外数据，都必须存储在调用处理器中。例如，在 `proxy/ProxyTest.java` 中，代理 `Comparable` 对象时，`TraceHandler` 就包装了实际的对象。

**所有的代理类都覆盖了 `Object` 类中的方法 `toString, equals, hashCode`** 。如同所有的代理方法一样，这些方法只是在调用处理器上调用 `invoke` 方法。`Object` 类中的其他方法（如 `clone` 和 `getClass` ）没有被重新定义。

没有定义代理类的名字，Oracle虚拟机中的 `Proxy` 类将生成一个以字符串 `$Proxy` 开头的类名。

对于一个特定的类加载器和预设的一组接口来说，只能有一个代理类。也就是说，**如果使用同一个类加载器和接口数组调用两次 `newProxyInstance` 方法，那么只能得到同一个类的两个对象**，也可以利用 `getProxyClass` 方法获得这个类：
```java
Class proxyClass = Proxy.getProxyClass(null, interfaces);
```
**代理类一定是 `public` 和 `final`** 。如果代理类实现的所有接口都是 `public` ，代理类就不属于某个特定的包；否则，**所有非公有的接口都必须属于同一个包，同时代理类也属于这个包**。

可以通过调用 `Proxy` 类中的 `isProxyClass` 方法，检测一个特定的 `Class` 对象是否代表一个代理类。

> [API] `java.lang.reflect.InvocationHandler` 1.3
> - `Object invoke(Object proxy, Method method, Object[] args)`
> 定义这个方法包含一个动作，你希望只要在代理对象上调用一个方法时，就执行的动作。

> [API] `java.lang.reflect.Proxy` 1.3
> - `static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces)`
> 返回实现指定接口的代理类。
> - `static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler handler)`
> 构造「实现指定接口的代理类」的一个新实例。所有方法都调用给定处理器对象的 `invoke` 方法。
> - `static boolean isProxyClass(Class<?> cl)`
> 如果 `cl` 是一个代理类则返回 `true` 。

到此为止，Java的基础概念介绍完毕。接口、lambda表达式和内部类是经常遇到的几个概念。然而，克隆、反射、服务加载器和代理等高级技术，主要是库设计者和工具构造者感兴趣。对应用程序员来说，它们并不十分重要。