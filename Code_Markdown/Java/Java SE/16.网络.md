▲连接到服务器
▲实现服务器
▲获取Web数据
▲HTTP客户端
▲可中断套接字

开头首先回顾网络方面的基本概念，然后介绍如何**编写「连接网络服务的Java程序」**，并演示**网络客户端和服务器是如何实现的**，最后介绍**通过Java程序发送E-mail**，以及**从Web服务器获得信息**。

---
## 16.1 连接到服务器
下面各节学习如何连接到服务器，先是手工用 `telnet` 连接，然后用Java程序连接。
## 16.1.1 使用 `telnet`
在编写第一个网络程序之前，首先了解 `telnet` 这个你已经拥有的工具，==它是一个用于网络编程的非常强大的调试工具，对我们调试网络程序非常有帮助==。大多数系统都已经预装了 `telnet` ，可以在命令Shell中输入 `telnet` 来启动它。
> 注意：在Windows中，`telnet` 是安装了的，但是默认情况下是未激活的。要激活它，需要到“控制面板”-“程序”-“打开/关闭Windows特性”，然后选择“Telnet客户端”复选框。Windows防火墙会阻止我们在这里使用的很多网络端口，可能需要管理员账户才能解除对它们的禁用。

我们可能曾**使用过 `telnet` 来连接远程计算机**，但其实也可以**用它与因特网主机所提供的其他服务进行通信**。下面是一个可操作的例子。请输入：
```bash
$ telnet time-a.nist.gov 13
59930 22-12-17 08:53:04 00 0 0  40.5 UTC(NIST) *


遗失对主机的连接。
```
如图16-1所示，可以得到与下面这一行相似的信息：
![图16-1 “当日时间”服务的输出](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212171653198.png)
上面例子说明了什么？它说明你已经连接到了大多数UNIX计算机都支持的“当日时间”服务 *"time of day" service that most UNIX machines constantly run* 。而你刚才所连接的那台服务器，就设在美国科罗拉多州博尔德市的国家标准与技术研究所，这家研究所负责提供铯原子钟 *Cesium atomic clock* 的计量时间（当然，由于网络延迟的缘故，原子钟反馈过来的时间并不完全准确）。==按照惯例，“当日时间”服务总是连接到端口13==。
> 注意：**在网络术语中，端口并不是指物理设备**，而是为了**便于实现服务器与客户端之间通信所使用的抽象概念**（见图16-2）。
> ![图16-2 连接到服务器端口的客户端](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212171656477.png)

运行在远程计算机上的服务器软件，不停地等待那些希望与端口13连接的网络请求。当远程计算机上的操作系统，接收到一个请求与端口13连接的网络数据包时，它便唤醒「正在监听网络连接请求的服务器进程」，并为两者建立连接。这种连接将一直保持下去，直到被其中任何一方中止。

当你开始用 `time-a.nist.gov` 在端口13上建立 `telnet` 会话时，网络软件中有一段代码非常清楚地知道、应该将字符串 `time-a.nist.gov` 转换为正确的IP地址129.6.15.28。随后，`telnet` 软件发送一个连接请求给该地址，请求一个到端口13的连接。一旦建立连接，远程程序便发送回一行数据，然后关闭该连接。当然一般而言，客户端和服务器在其中一方关闭连接之前，会进行更多的对话。

下面是另一个同类的试验，但它更加有趣。请执行以下操作：
```bash
$ telnet horstmann.com 80
```
然后非常仔细地键入以下内容（未成功）：
```java
GET / HTTP/1.1
Host: horstmann.com
blank line
```
也就是在末尾按两次Enter键。图16-3显示了以上操作的响应结果。它看上去应是非常熟悉的——得到的是一个HTML格式的文本页，即Cay Horstmann的主页。
![图16-3 使用telnet访问HTTP端口](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212171701093.png)

上述操作与Web浏览器访问某个网页所经历的过程是完全一致的，它使用HTTP向服务器请求Web页面。当然，浏览器能够更精致地显示HTML代码。
> 注意：如果一台Web服务器用相同的IP地址为多个域提供宿主环境 *host multiple domains* ，那么在连接这台Web Server时，就必需提供Host键/值对。如果服务器只为单个域提供宿主环境，则可以忽略该键/值对。
## 16.1.2 用Java连接到服务器
`socket/SocketTest.java` 是我们的第一个网络程序。它的作用与使用 `telnet` 工具是一致的，即连接到某个端口、并打印出它所找到的信息。
```java
// socket/SocketTest.java
package socket;

import java.io.*;
import java.net.*;
import java.nio.charset.*;
import java.util.*;

/**
 * This program makes a socket connection to the atomic clock 
 * in Boulder, Colorado, and prints the time that the server sends.
 */
public class SocketTest {
	public static void main(String[] args) throws IOException {
		try (var s = new Socket("time-a.nist.gov", 13);
			var in = new Scanner(s.getInputStream()`, StandardCharsets.UTF_8)) {
			while (in.hasNextLine()`) {
				String line = in.nextLine()`;
				System.out.println(line);
			}	
		}
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212171724194.png)

下面是这个简单程序的几行关键代码：
```java
var s = new Socket("time-a.nist.gov", 13);
InputStream inStream = s.getInputStream()`;
```
第一行代码用于打开一个套接字，它也是网络软件中的一个抽象概念，负责启动该程序内部和外部之间的通信。我们将远程地址和端口号传递给套接字的构造器，如果连接失败，它将抛出一个 `UnknownHostException` 异常；如果存在其他问题，它将抛出一个 `IOException` 异常。因为 `UnknownHostException` 是 `IOException` 的一个子类，况且这只是一个示例程序，所以我们在这里**仅仅捕获超类的异常**。

一旦套接字被打开，`java.net.Socket` 类中的 `getInputStream` 方法就会返回一个 `InputStream` 对象，该对象可以像其他任何流对象一样使用。而一旦获取了这个流，该程序将直接把每一行打印到标准输出。这个过程将一直持续到流发送完毕、且服务器断开连接为止。

**该程序只适用于非常简单的服务器，比如“当日时间”之类的服务**。在比较复杂的网络程序中，客户端发送请求数据给服务器，而服务器可能在响应结束时并不立刻断开连接。在若干示例程序中，都会看到我们如何实现这种行为。

`Socket` 类非常简单易用，因为Java库隐藏了建立网络连接和通过连接发送数据的复杂过程。实际上，**java.net包提供的编程接口与操作文件时所使用的接口基本相同**。
> 注意：这里介绍的仅覆盖了TCP（传输控制协议）网络协议。Java平台另外还支持UDP（用户数据报协议）协议，该协议可以用于发送数据包（也称为数据报），它所需付出的开销要比TCP少得多。
> 
> UDP有一个重要的缺点：数据包无需按照顺序传递到接收应用程序，它们甚至可能在传输过程中全部丢失。==UDP要求数据包的接收者对它们进行排序，并请求发送者重新发送那些丢失的数据包==。UDP比较适合于那些可以忍受数据包丢失的应用，例如用于音频流和视频流的传输，或用于连续测量的应用领域。

> [API] `java.net.Socket` 1.0
> - `Socket(String host, int port)`
> 构建一个套接字，用来连接给定的主机和端口。
> - `InputStream getInputStream()`
> - `OutputStream getOutputStream()`
> 获取可以从套接字中读取数据的流，以及可以向套接字写出数据的流。

## 16.1.3 套接字超时
==从套接字读取信息时，在有数据可供访问之前，读操作将会被阻塞==。如果此时主机不可达，那么应用将要等待很长的时间，并且因为受底层操作系统的限制、而最终会导致超时。

**对于不同的应用，应该确定合理的超时值**。然后调用 `setSoTimeout` 方法设置这个超时值（单位：毫秒）。
```java
var s = new Socket(...);
s.setSoTimeout(10000); // time out after 10 seconds
```
如果已为套接字设置了超时值，并且之后的读操作和写操作在没有完成之前就超过了时间限制，那么这些操作就会抛出 `SocketTimeoutException` 异常。你可以捕获这个异常，并对超时做出反应。
```java
try {
	InputStream in = s.getInputStream(); // read from in
	...
} catch (SocketTimeoutException e) {
	// react to timeout
}
```
另外还有一个超时问题是必须解决的。**下面这个构造器会一直无限期地阻塞下去，直到建立了到达主机的初始连接为止**：
```java
Socket(String host, int port)
```
可以通过先构建一个无连接的套接字，然后再连接它（带一个超时参数）的方法解决这个问题。
```java
var s = new Socket();
s.connect(new InetSocketAddress(host, port), timeout);
```
如果希望允许用户在任何时刻都可以中断套接字连接，查看16.2.4节“可中断套接字”。
> [API] `java.net.Socket` 1.0
> - `Socket()`
> 创建一个还未被连接的套接字。
> - `void connect(SocketAddress address)` 1.4
> 将该套接字连接到给定的地址。
> - `void connect(SocketAddress address, int timeoutInMilliseconds)` 1.4
> 将套接字连接到给定的地址。如果在给定的时间内没有响应，则返回。
> - `void setSoTimeout(int timeoutInMilliseconds)` 1.1
> 设置该套接字上读请求的阻塞时间。如果超出给定时间，则抛出一个 `InterruptedIOException` 异常。
> - `boolean isConnected()` 1.4
> 如果该套接字已被连接，则返回 `true` 。
> - `boolean isClosed()` 1.4
> 如果套接字已经被关闭，则返回 `true` 。

## 16.1.4 因特网地址
通常，不用过多考虑因特网地址的问题，它们是用一串数字表示的主机地址，一个因特网地址由4个字节组成（在IPv6中是16个字节），比如132.163.4.102。但**如果需要在主机名和因特网地址之间进行转换，那么就可以使用 `InetAddress` 类**。

只要主机操作系统支持IPv6格式的因特网地址，`java.net` 包也将支持它。

静态的 `getByName` 方法可以返回代表某个主机的因特网地址 `InetAddress` 对象。例如，
```java
InetAddress address = InetAddress.getByName("time-a.nist.gov");
```
将返回一个 `InetAddress` 对象，该对象封装了一个4字节的序列：132.163.4.104。然后，可以使用 `getAddress` 方法来访问这些字节：
```java
byte[] addressBytes = address.getAddress();
```

**一些访问量较大的主机名通常会对应于多个因特网地址，以实现负载均衡**。例如，主机名 `google.com` 就对应着12个不同的因特网地址。当访问主机时，会随机选取其中的一个。可以通过调用 `getAllByName` 方法来获得所有主机：
```java
InetAddress[] addresses = InetAddress.getAllByName(host);
```

最后需要说明的是，**有时可能需要本地主机的地址**。**如果只是要求得到 `localhost` 的地址，那总会得到本地回环地址 `the local loopback address` 127.0.0.1，但其他程序无法用这个地址来连接到这台机器上**。此时，可以使用静态的 `getLocalHost` 方法来得到本地主机的地址：
```java
InetAddress address = InetAddress.getLocalHost();
```

`inetAddress/InetAddressTest.java` 是一段比较简单的程序代码。如果不在命令行中设置任何参数，那么它将打印出本地主机的因特网地址。反之，如果在命令行中指定了主机名，那么它将打印出该主机的所有因特网地址，例如：
```bash
$ java inetAddress/InetAddressTest www.horstmann.com
```
```java
// inetAddress/InetAddressTest.java
package inetAddress;

import java.io.*;
import java.net.*;

/**
 * This program demonstrates the InetAddress class. Supply a hose name as 
 * command-line argument, or run without command-line arguments to see the address of the local host.
 */
public class InetAddressTest {
	public static void main(String[] args) throws IOException {
		if (args.length > 0) {
			String host = args[0];
			InetAddress[] addresses = InetAddress.getAllByName(host);
			for (InetAddress a : addresses)
				System.out.println(a);
		} else {
			InetAddress localHostAddress = InetAddress.getLocalHost();
			System.out.println(localHostAddress);
		}
	}
}
```
运行结果如下：
```bash
LETHARGY/192.168.56.1
```
> [API] `java.net.InetAddress` 1.0
> - `static InetAddress getByName(String host)`
> - `static InetAddress[] getAllByName(String host)`
> 为给定的主机名创建一个 `InetAddress` 对象，或一个包含了该主机名所对应的所有因特网地址的数组。
> - `static InetAddress getLocalHost()`
> 为本地主机创建一个 `InetAddress` 对象。
> - `byte[] getAddress()`
> 返回一个包含数字型地址的字节数组。
> - `String getHostAddress()`
> 返回一个由十进制数组成的字符串，各数字间用圆点符号隔开，例如，“132.163.4.102”。
> - `String getHostName()`
> 返回主机名。

---
# 16.2 实现服务器
既然我们已实现了一个**基本的网络客户端**，并且用它从因特网上获取了数据，那么现在就再来实现一个**简单的服务器**，它可以向客户端发送信息。
## 16.2.1 服务器套接字
一旦启动服务器程序，它便等待某个客户端连接到它的端口。我们选择端口号8189，因为所有标准服务都不使用这个端口。ServerSocket类用于建立套接字。在我们的示例中，下面这行命令：
```java
var s = new ServerSocket(8189);
```
用于建立一个负责监控端口8189的服务器。以下命令：
```java
Socket incoming = s.accept();
```
用于告诉程序不停地等待，直到有客户端连接到这个端口。一旦有人通过网络发送了正确的连接请求，并以此连接到了端口上，该方法就会**返回一个表示连接已经建立的 `Socket` 对象**。你可以使用这个对象来得到输入流和输出流，代码如下：
```java
InputStream inStream = incoming.getInputStream();
OutputStream outStream = incoming.getOutputStream();
```
服务器发送给服务器输出流的所有信息、都会成为客户端程序的输入，同时来自客户端程序的所有输出、都会被包含在服务器输入流中。

因为在这里所有示例程序中，我们都要通过套接字来发送文本，所以我们将流转换成扫描器和写入器。
```java
var in = new Scanner(inStream, StandardCharsets.UTF_8);
var out = new PrintWriter(new OutputStreamWriter(outStream, StandardCharsets.UTF_8), true /* autoFlush */);
```
以下代码将给客户端发送一条问候信息：
```java
out.println("Hello! Enter BYE to exit.");
```
当使用 `telnet` 通过端口8189连接到这个服务器程序时，将会在终端屏幕上看到上述问候信息。

在这个简单的服务器程序中，它仅仅只是读取客户端输入，每次读取一行，并回送这一行。这表明程序接收到了客户端的输入。当然，实际应用中的服务器都会对输入进行计算并返回处理结果。

在代码的最后，我们关闭了连接进来的套接字。
```java
String line = in.nextLine();
out.println("Echo: " + line);
if (line.trim().equals("BYE")) done = true;
```
这就是整个示例代码的大致情况。每一个服务器程序，比如一个HTTP Web服务器，都不间断地执行下面这个循环：
1. 通过输入数据流从客户端接收一个命令（“get me this information”）。
2. 解码这个客户端命令。
3. 收集客户端所请求的信息。
4. 通过输出数据流发送信息给客户端。

`server/EchoServer.java`给出了这个程序的完整代码。
```java
// server/EchoServer.java
package server;

import java.io.*;
import java.net.*;
import java.nio.charset.*;
import java.util.*;

/**
 * This program implements a simple server that listens to 
 * port 8189 and echoes back all client input.
 */
public class EchoServer {
	public static void main(String[] args) throws IOException {
		// establish server socket;
		try (var s = new ServerSocket(8189)) {
			// wait for client connection
			try (Socket incoming = s.accept()) {
				InputStream inStream = incoming.getInputStream();
				OutputStream outStream = incoming.getOutputStream();

				try (var in = new Scanner(inStream, StandardCharsets.UTF_8)) {
					var out = new PrintWriter(
						new OutputStreamWriter(outStream, StandardCharsets.UTF_8), true /* autoflush */ ); 
					out.println("Hello! Enter BYE to exit.");

					// echo client input
					var done = false;
					while (!done && in.hasNextLine()) {
						String line = in.nextLine();
						out.println("Echo: " + line);
						if (line.trim().equals("BYE")) done = true;
					}
				}
			}
		}
	}
}
```
 想要试这个例子，就编译并运行这个程序。然后使用 `telnet` 连接到服务器localhost（或IP地址127.0.0.1）和端口8189。==如果你直接连接到因特网上，那么世界上任何人都可以访问到你的回送服务器，只要他们知道你的IP地址和端口号==。

当你连接到该端口时，将看到如图16-4的信息——可以随意键入一条信息，然后观察屏幕上的回送信息。输入BYE（全为大写字母）可以断开连接，同时，服务器程序也会终止运行：
![图16-4 访问一个回送服务器](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212190307271.png)
我使用 `telnet localhost 8189` ，看到如下信息：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212190310935.png)

> [API] `java.net.ServerSocket` 1.0
> - `ServerSocket(int port)`
> 创建一个监听端口的服务器套接字。
> - `Socket accept()`
> 等待连接。**该方法阻塞**（即，使之空闲）**当前线程直到建立连接为止**。该方法返回一个 `Socket` 对象，程序可以通过这个对象与连接中的客户端进行通信。
> - `void close()`
> 关闭服务器套接字。

## 16.2.1 为多个客户端服务
前面例子的简单服务器存在一个问题。==假设我们希望有多个客户端同时连接到我们的服务器上==，通常服务器总是不间断地运行在服务器计算机上，来自整个因特网的用户希望同时使用服务器。==前面的简单服务器会拒绝多客户端连接，使某个用户可能会因长时间地连接服务而独占服务==，其实我们可以运用线程的魔力、把这个问题解决得更好。

**每当程序建立一个新的套接字连接，也就是说当调用 `accept` 时，将启动一个新的线程来处理服务器和该客户端之间的连接，而主程序将立即返回并等待下一个连接**。为了实现这个机制，服务器应该具有类似以下代码的循环操作：
```java
while (true) {
	Socket incoming = s.accept();
	var r = new ThreadedEchoHandler(incoming);
	var t = new Thread(r);
	t.start();
}
```
`ThreadedEchoHandler` 类实现了 `Runnable` 接口，而且在它的 `run` 方法中包含了与客户端循环通信的代码。
```java
class ThreadedEchoHandler implements Runnable {
	public void run() {
		try (InputStream inStream = incoming.getInputStream();
		OutputStream outStream = incoming.getOutputStream()) {
			// Process input and send response
		} catch(IOException e) {
			// Handle exception
		}
	}
}
```
由于每一个连接都会启动一个新的线程，因而多个客户端就可以同时连接到服务器了。对此可以做个简单的测试：
1. 编译和运行服务器程序 `threaded/ThreadedEchoServer.java` 。
2. 如图16-5打开数个 `telnet` 窗口。
3. 在这些窗口之间切换，并键入命令。注意**你可以同时通过这些窗口进行通信**。
4. 当完成之后，切换到你启动服务器程序的窗口，并使用CTRL+C强行关闭它。
![图16-5 多个同时通信的telnet窗口](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212190328093.png)

注意：在这个程序中，我们为每个连接生成一个单独的线程。这种方法并不能满足高性能服务器的要求。为使服务器实现更高的吞吐量，可以使用 `java.nio` 包中[一些特性](http://www.ibm.com/developerworks/java/library/j-javaio)。
```java
// threaded/ThreadedEchoServer.java
package threaded;

import java.io.*;
import java.net.*;
import java.nio.charset.*;
import java.util.*;

/**
 * This program implements a multithreaded server that 
 * listens to port 8189 and echoes back all client input.
 */
public class ThreadedEchoServer {
	public static void main(String[] args) {
		try (var s = new ServerSocket(8189)) {
			int i = 1;
			while (true) {
				Socket incoming = s.accept();
				System.out.println("Spawning " + i);
				Runnable r = new ThreadedEchoHandler(incoming);
				var t = new Thread(r);
				t.start();
				++i;
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

/**
 * This class handles the client input for one server socket connection.
 */
class ThreadedEchoHandler implements Runnable {
	private Socket incoming;
	/**
	 * Constructs a handler.
	 * @param incomingSocket the incoming socket
	 */
	public ThreadedEchoHandler(Socket incomingSocket) {
		incoming = incomingSocket;
	}

	public void run() {
		try (InputStream inStream = incoming.getInputStream();
			OutputStream outStream = incoming.getOutputStream();
				var in = new Scanner(inStream, StandardCharsets.UTF_8);
				var out = new PrintWriter(
					new OutputStreamWriter(outStream, StandardCharsets.UTF_8), true /* auto flush */)
		) {
			out.println("Hello! Enter BYE to exit.");
			
			// echo client input
			var done = false;
			while (!done && in.hasNextLine()) {
				String line = in.nextLine();
				out.println("Echo: " + line);
				if (line.trim().equals("BYE")) done = true;
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212190327071.png)

## 16.2.2 半关闭
**半关闭** *half-close* 提供了这样一种能力：**套接字连接的一端可以终止其输出，同时仍旧可以接收来自另一端的数据**。

这是一种很典型的情况，例如我们在向服务器传输数据，但并不知道要传输多少数据。在向文件写数据时，我们只需在数据写入后关闭文件即可。但==如果关闭一个套接字，那么与服务器的连接将立刻断开，因而也就无法读取服务器的响应了==。

使用半关闭的方法就可以解决上述问题。可以通过关闭一个套接字的输出流、来**表示发送给服务器的请求数据已经结束**，但必须保持输入流处于打开状态。

如下代码演示了如何在客户端使用半关闭方法：
```java
try (var socket = new Socket(host, port)) {
	var in = new Scanner(socket.getInputStream(), StandardCharsets.UTF_8);
	var writer = new PrintWriter(socket.getOutputStream());
	// send request data
	writer.print(...);
	writer.flush();
	socket.shutdownOutput();
	// now socket is half-closed
	// read response data
	while (in.hasNextLine() != null) { 
		String line = in.nextLine(); 
		... 
	}
}
```
服务器端将读取输入信息，直到到达输入流的结尾，然后它再发送响应。

当然，**该协议只适用于一站式 *one-shot* 的服务，例如HTTP服务**，在这种服务中，客户端连接服务器，发送一个请求，捕获响应信息，然后断开连接。
> [API] `java.net.Socket` 1.0
> - `void shutdownOutput()` 1.3
> 将输出流设为“流结束”。
> - `void shutdownInput()` 1.3
> 将输入流设为“流结束”。
> - `boolean isOutputShutdown()` 1.4
> 如果输出已被关闭，则返回 `true` 。
> - `boolean isInputShutdown()` 1.4
> 如果输入已被关闭，则返回 `true` 。

## 16.2.4 可中断套接字
==当**连接到一个套接字**时，当前线程将会被阻塞、直到建立连接或**产生超时**为止==。同样地，==当**通过套接字读取数据**时，当前线程也会被阻塞、直到操作成功或**产生超时**为止== *There is no timeout for writing data* 。

在交互式的应用中，也许会考虑为用户提供一个选项，用以取消那些**看似**不会产生结果的连接（即使用中断来退出阻塞）。但**当线程阻塞在一个无法响应的套接字 *unresponsive socket* 时，则无法通过调用 `interrupt` 来解除阻塞**。

为了中断套接字操作，可以使用 `java.nio` 包提供的一个特性—— `SocketChannel` 类。可以使用如下方法打开 `SocketChannel` ：
```java
SocketChannel channel = SocketChannel.open(new InetSocketAddress(host, port));
```
通道 `channel` 并没有与之相关联的流。实际上，它所拥有的 `read` 和 `write` 方法、都是通过使用 `Buffer` 对象来实现的（关于NIO缓冲区的相关信息见章2）。`ReadableByteChannel` 接口和 `WritableByteChannel` 接口都声明了这两个方法。

如果不想处理缓冲区，可以使用 `Scanner` 类从 `SocketChannel` 中读取信息，因为 `Scanner` 有一个带 `ReadableByteChannel` 参数的构造器：
```java
var in = new Scanner(channel, StandardCharsets.UTF_8);
```

通过调用静态方法 `Channels.newOutputStream` ，可以将通道转换成输出流。
```java
OutputStream outStream = Channels.newOutputStream(channel);
```
*That's all you need to do* 。每当线程在打开（套接字）、读取（数据）或写入操作期间中断（以打断阻塞）时，该操作就不会阻塞，而是以异常终止。

`interruptible/InterruptibleSocketTest.java` 对比了可中断套接字和阻塞套接字：服务器将连续发送数字，并在发送十个数字后假装被阻塞 *pretends to be stuck after the tenth numbe* 。点击两个按钮中的任何一个，都会启动一个线程来连接服务器并打印输出。第一个线程使用可中断套接字，而第二个线程使用阻塞套接字。==如果在第一批的十个数字的读取过程中点击“Cancel”按钮，这两个线程都会中断==（从而退出阻塞；因为第二个线程还没有陷入阻塞，所以还能中断退出）。但==在第一批十个数字之后，就只能中断第一个线程了==，第二个线程将保持阻塞（因为服务器那边没有传来数据给它读取，它阻塞了，而中断无法退出阻塞）、直到服务器最终关闭连接（参见图16-6）。
![图16-6 中断一个套接字](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212202136943.png)

```java
// interruptible/InterruptibleSocketTest.java
package interruptible;

import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.io.*;
import java.nio.charset.*;
import java.nio.channels.*;
import java.util.*;

import javax.swing.*;

/**
 * This program shows how to interrupt a socket channel.
 */
public class InterruptibleSocketTest {
	public static void main(String[] args) {
		EventQueue.invokeLater(() -> {
			var frame = new InterruptibleSocketFrame();
			frame.setTitle("InterruptibleSocketTest");
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}
}

class InterruptibleSocketFrame extends JFrame {
	private Scanner in;
	private JButton interruptibleButton;
	private JButton blockingButton;
	private JButton cancelButton;
	private JTextArea messages;
	private TestServer server;
	private Thread connectThread;

	public InterruptibleSocketFrame() {
		var northPanel = new JPanel();
		add(northPanel, BorderLayout.NORTH);

		final int TEXT_ROWS = 20;
		final int TEXT_COLUMNS = 60;
		messages = new JTextArea(TEXT_ROWS, TEXT_COLUMNS);
		add(new JScrollPane(messages));

		interruptibleButton = new JButton("Interruptible");
		blockingButton = new JButton("Blocking");
		northPanel.add(interruptibleButton);
		northPanel.add(blockingButton);
		
		interruptibleButton.addActionListener(event -> {
			interruptibleButton.setEnabled(false);
			blockingButton.setEnabled(false);
			cancelButton.setEnabled(true);
			connectThread = new Thread(() -> {
				try {
					connectInterruptibly();
				} catch (IOException e) {
					messages.append("\nInterruptibleSocketTest.connectInterruptibly: " + e);
				}
			});
			connectThread.start();
		});

		blockingButton.addActionListener(event -> {
			interruptibleButton.setEnabled(false);
			blockingButton.setEnabled(false);
			cancelButton.setEnabled(true);
			connectThread = new Thread(() -> {
				try {
					connectBlocking();
				} catch (IOException e) {
					messages.append("\nInterruptibleSocketTest.connectBlocking: " + e);
				}
			});
			connectThread.start();
		});

		cancelButton = new JButton("Cancel");
		cancelButton.setEnabled(false);
		cancelButton.addActionListener(event -> {
			connectThread.interrupt();
			cancelButton.setEnabled(false);
		});
		northPanel.add(cancelButton);
		
		server = new TestServer();
		new Thread(server).start();
		pack();
	}

	/**
	 * Connects to the test server, using interruptible I/O
	 */
	public void connectInterruptibly() throws IOException {
		messages.append("Interruptible:\n");
		try (SocketChannel channel 
			= SocketChannel.open(new InetSocketAddress("localhost", 8189))) {
			in = new Scanner(channel, StandardCharsets.UTF_8);
			while (!Thread.currentThread().isInterrupted()) {
				messages.append("Reading ");
				if (in.hasNextLine()) {
					String line = in.nextLine();
					messages.append(line);
					messages.append("\n");
				}
			}
		} finally {
			EventQueue.invokeLater(() -> {
				messages.append("Channel closed\n");
				interruptibleButton.setEnabled(true);
				blockingButton.setEnabled(true);
			});
		}
	}

	/**
	 * Connects to the test server, using blocking I/O
	 */
	public void connectBlocking() throws IOException {
		messages.append("Blocking:\n");
		try (var sock = new Socket("localhost", 8189)) {
			in = new Scanner(sock.getInputStream(), StandardCharsets.UTF_8);
			while (!Thread.currentThread().isInterrupted()) {
				messages.append("Reading ");
				if (in.hasNextLine()) {
					String line = in.nextLine();
					messages.append(line);
					messages.append("\n");
				}
			}
		} finally {
			EventQueue.invokeLater(() -> {
				messages.append("Socket closed\n");
				interruptibleButton.setEnabled(true);
				blockingButton.setEnabled(true);
			});
		}
	}

	/** 
	 * A multithreaded server that listens to port 8189 and sends numbers to the client,
	 * simulating a hanging server after 10 numbers.
	 */
	class TestServer implements Runnable {
		public void run() {
			try (var s = new ServerSocket(8189)) {
				while (true) {
					Socket incoming = s.accept();
					Runnable r = new TestServerHandler(incoming);
					new Thread(r).start();
				}
			} catch (IOException e) {
				messages.append("\nTestServer.run: " + e);
			}
		}
	}

	/**
	 * This class handles the client input for one server socket connection.
	 */
	class TestServerHandler implements Runnable {
		private Socket incoming;
		private int counter;

		/**
		 * Constructs a handler.
		 * @param i the incoming socket
		 */
		public TestServerHandler(Socket i) { incoming = i; }

		public void run() {
			try {
				try {
					OutputStream outStream = incoming.getOutputStream();
					var out = new PrintWriter(
						new OutputStreamWriter(outStream, StandardCharsets.UTF_8), true /* autoflush */
					);
					while (counter < 100) {
						++counter;
						if (counter <= 10) out.println(counter);
						Thread.sleep(500);
					}
				} finally {
					incoming.close();
					messages.append("Closing server\n");
				}
			} catch (Exception e) {
				messages.append("\nTestServerHandler.run: " + e);
			}
		}
	}
}
```
运行结果如下，在前10个数字时都能中断退出客户端线程，服务端线程结束后也会退出。之后可中断套接字也能中断退出，但阻塞套接字不能中断退出阻塞：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301111344031.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301111352628.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301111353983.png)
问题在于，不知道为什么，如果第一个Start的是Blocking按钮，那前十个数字时也不能中断退出。

> [API] `java.net.InetSocketAddress` 1.4
> - `InetSocketAddress(String hostname, int port)`
> 通过主机和端口参数创建一个地址对象，并在创建过程中解析主机名。如果主机名不能被解析，那么该地址对象的 `unresolved` 属性将被设为 `true` 。
> - `boolean isUnresolved()`
> 如果不能解析该地址对象，则返回 `true` 。

> [API] `java.nio.channels.SocketChannel` 1.4
> - `static SocketChannel open(SocketAddress address)`
> 打开一个套接字通道，并将其连接到远程地址。

> [API] `java.nio.channels.Channels` 1.4
> - `static InputStream newInputStream(ReadableByteChannel channel)`
> 创建一个输入流，用以从指定的通道读取数据。
> - `static OutputStream newOutputStream(WritableByteChannel channel)`
> 创建一个输出流，用以向指定的通道写入数据。

---
# 16.3 获取Web数据
==为了在Java程序中访问Web服务器，你可能希望在更高的级别上进行处理，而不只是创建套接字连接和发送HTTP请求==。下面各个小节讨论专用于此目的的、Java类库中的各个类。
## 16.3.1 URL和URI
`URL` 和 `URLConnection` 类封装了大量复杂的实现细节，这些细节涉及如何从远程站点获取信息。例如，可以自一个字符串构建一个 `URL` 对象：
```java
var url = new URL(urlString);
```
如果只是想获得该资源的内容，可以使用 `URL` 类中的 `openStream` 方法。该方法将产生一个 `InputStream` 对象，**然后就可以按照一般的用法来使用这个对象了**，比如用它构建一个 `Scanner` 对象：
```java
InputStream inStream = url.openStream();
var in = new Scanner(inStream, StandardCharsets.UTF_8);
```

`java.net` 包对统一资源定位符 *Uniform Resource Locator, URL* 和统一资源标识符 *Uniform Resource Identifier, URI* 作了非常有用的区分 *makes a useful distinction* 。

==URI是个纯粹的语法结构，包含用来指定Web资源的字符串的各种组成部分==  *purely syntactical construct that contains the various parts of the string specifying a web resource* 。==URL是URI的一个特例，它包含了用于定位Web资源 *locate a resource* 的足够信息==。其他URI，比如：
```java
mailto:cay@horstmann.com
```
则不属于定位符 *locators* ，因为根据该标识符我们无法定位任何数据。像这样的URI我们称之为 *URN, uniform resource name* 统一资源名称。

**在Java类库中，URI类不包含任何用于访问资源的方法，它的惟一作用就是解析**。相反的是，**URL类可以打开一个到达资源的流**。因此，URL类只能作用于那些「Java类库知道该如何处理的模式」，例如 `http:, https:, ftp:` , 本地文件系统 `file:` 和JAR文件 `jar:` 。

要想了解为什么对URI进行解析、并不是可有可无的 *not trivial* ，那么考虑以下URL会变得多么复杂。例如，
```java
http:/google.com?q=Beach+Chalet
ftp://username:password@ftp.yourserver.com/pub/file.txt
```
URI规范给出了标记这些标识符的规则 *the rules for the makeup of these identifiers* 。一个URI具有以下句法：
```java
[scheme:]schemeSpecificPart[#fragment]
```
上式中，[...]表示可选部分，并且 `:` 和 `#` 可以被包含在标识符内。包含 `scheme:` 部分的URI称为**绝对URI**。否则，称为**相对URI**。

如果**绝对URI**的 `schemeSpecificPart` 不是以 `/` 开头的，我们就称它是**不透明的** *An absolute URI is opaque* 。例如：
```java
mailto:cay@horstmann.com
```
所有**绝对的透明URI**和所有**相对URI**都是**分层的** *hierarchical* 。例如：
```java
http://horstmann.com/index.html
../../java/net/Socket.html#Socket()
```
一个分层URI的 `schemeSpecificPart` 具有以下结构，这里，`[...]` 同样表示可选：
```java
[//authority][path][?query]
```
对于那些基于服务器的URI，`authority` 部分具有以下形式，`port` 必须是一个整数：
```java
[user-info@]host[:port]
```

RFC 2396（标准化URI的文献）还支持一种基于注册表的机制，此时 `authority` 采用了一种不同的格式。不过，这种情况并不常见。

URI类的作用之一是**解析标识符、并将它分解成各种不同的组成部分**。你可以用以下方法读取它们：
```java
getScheme
getSchemeSpecificPart
	getAuthority
		getUserInfo
		getHost
		getPort
	getPath
	getQuery
getFragment
```
URI类的另一个作用是**处理绝对标识符和相对标识符**。如果存在一个如下的绝对URI：
```java
http://docs.mycompany.com/api/java/net/ServerSocket.html
```
和一个如下的相对URI：
```java
../../java/net/Socket.html#Socket()
```
那么可以用它们组合出一个绝对URI：
```java
http://docs.mycompany.com/api/java/net/Socket.html#Socket()
```
这个过程称为**解析 *resolve* 相对URL**（相对变绝对）。

与此相反的过程称为**相对化** `relativization`（绝对变相对）。例如，假设有一个基本URI：
```java
http://docs.mycompany.com/api
```
和另一个URI：
```java
http://docs.mycompany.com/api/java/lang/String.html
```
那么相对化之后的URI就是：
```java
java/lang/String.html
```

URI类同时支持以下两个操作：
```java
relative = base.relativize(combined); 
combined = base.resolve(relative);
```

## 16.3.2 使用 `URLConnection` 获取信息
如果想从某个Web资源获取更多信息，那么应该使用 `URLConnection` 类，**通过它能得到比基本的 `URL` 类更多的控制功能**。

当操作一个 `URLConnection` 对象时，必须像下面这样、非常小心地安排操作步骤：
1. 调用 `URL` 类中的 `openConnection` 方法获得 `URLConnection` 对象：
	```java
	URLConnection connection = url.openConnection();
	```
1. 使用以下方法来**设置任意的请求属性**：
	```java
	setDoInput
	setDoOutput
	setIfModifiedSince
	setUseCaches
	setAllowUserInteraction
	setRequestProperty
	setConnectTimeout
	setReadTimeout
	```
	本节稍后部分以及API说明中，讨论这些方法。
3. 调用 `connect` 方法连接远程资源：
	```java
	connection.connect();
	```
	除了与服务器建立套接字连接外，该方法还可用于向服务器查询头信息 *header information* 。
4. 与服务器建立连接后，你可以查询头信息。`getHeaderFieldKey` 和 `getHeaderField` 两个方法可用来枚举消息头的所有字段。`getHeaderFields` 方法返回一个「包含了消息头中所有字段的标准 `Map` 对象」。为了方便使用，以下方法可以查询各标准字段：
	```java
	getContentType
	getContentLength
	getContentEncoding
	getDate
	getExpiration
	getLastModified
	```
5. 最后，**访问资源数据。使用 `getInputStream` 方法获取一个输入流、用以读取信息**（这个输入流与 `URL` 类中的 `openStream` 方法所返回的流相同）。另一个方法 `getContent` 在实际操作中并不是很有用。**由标准内容类型（比如 `text/plain` 和 `image/gif` ）所返回的对象，需要使用 `com.sun` 层次结构中的类来进行处理**。也可以注册自己的内容处理器，但在这里不讨论这项技术。
> 警告：一些程序员在使用 `URLConnection` 类的过程中形成了错误的观念，他们认为 `URLConnection` 类中的 `getInputStream` 和 `getOutputStream` 方法与 `Socket` 类中的这些方法相似，但这种想法并不十分正确。
>
> **`URLConnection` 类具有很多表面之外的神奇功能**，尤其在处理请求和响应消息头时。正因为如此，严格遵循建立连接的每个步骤显得非常重要。

下面将详细介绍一下 `URLConnection` 类中的一些方法。有几个方法可以在与服务器建立连接之前设置连接属性，其中最重要的是 `setDoInput` 和 `setDoOutput` 。**在默认情况下，建立的连接只产生「从服务器读取信息的输入流」，并不产生「任何执行写操作的输出流」**。如果想获得输出流（例如，用于向一个Web服务器提交数据），那么你需要调用：
```java
connection.setDoOutput(true);
```
接下来，也许想设置某些请求头 *request header* 。请求头是与请求命令一起被发送到服务器的。例如：
```js
GET www.server.com/index.html HTTP/1.0
Referer: http://www.somewhere.com/links.html
Proxy-Connection: Keep-Alive
User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.4)
Host: www.server.com
Accept: text/html, image/gif, image/jpeg, image/png, */*
Accept-Language: en
Accept-Charset: iso-8859-1,*,utf-8
Cookie: orangemilano=192218887821987
```
`setIfModifiedSince` 方法告诉连接、你只对「自某个特定日期以来被修改过的数据」感兴趣 *connection that you are only interested in data modified since a certain date* ；
> `setUseCaches` 和 `setAllowUserInteraction` 这两个方法只作用于 `Applet` ；`setUseCaches` 方法用于命令浏览器首先检查它的缓存； `setAllowUserInteraction` 方法则用于在访问有密码保护的资源时\弹出对话框，以便查询用户名和口令。

最后再介绍一个**总览全局的方法**：`setRequestProperty` ，==它可以用来设置「对特定协议起作用的任何“名-值 *name/value* 对”」==。关于HTTP请求头的格式，参见RFC 2616，其中的某些参数没有很好地建档，它们通常在程序员之间口头传授。例如，如果你想访问一个有密码保护的Web页，那么就必须按如下步骤操作：
1. 将用户名、冒号和密码以字符串形式连接在一起。
	```java
	String input = username + ":" + password;
	```
2. 计算上一步骤所得字符串的 `Base64` 编码（ `Base64` 编码用于将字节序列编码成可打印的ASCII字符序列）。
	```java
	Base64.Encoder encoder = Base64.getEncoder();
	String encoding = encoder.encodeToString(input.getBytes(StandardCharsets.UTF_8));
	```
4. 调用 `setRequestProperty` 方法，设置 `name` 参数的值为 `"Authorization"` 、`value` 参数的值为 `"Basic " + encoding` ：
	```java
	connection.setRequestProperty("Authorization", "Basic " + encoding);
	```
> 提示：我们上面介绍的是如何访问一个有密码保护的Web页。==如果想要通过FTP访问一个有密码保护的文件时，要采用一种完全不同的方法。可以直接构建一个如下格式的URL==：
> ```java
> ftp://username:password@ftp.yourserver.com/pub/file.txt
> ```

**一旦调用了 `connect` 方法，就可以查询响应头信息**。首先，我们将介绍如何**枚举所有响应头的字段**。似乎是为了展示自己的个性，该类的实现者采用了另一种迭代方式。调用如下方法可以获得响应头的第 `n` 个键，其中 `n` 从 `1` 开始！如果 `n` 为 `0` 或大于消息头的字段总数，该方法将返回 `null` 值：
```java
String key = connection.getHeaderFieldKey(n);
```
**没有哪种方法可以返回字段的数量，你必须反复调用 `getHeaderFieldKey` 方法、直到返回 `null` 为止**。同样地，调用以下方法可以得到第 `n` 个值：
```java
String value = connection.getHeaderField(n);
```
`getHeaderFields` 方法可以返回一个封装了响应头字段的Map对象。
```java
Map<String, List<String>> headerFields = connection.getHeaderFields();
```
下面是一组来自典型的HTTP请求的响应头字段。
```java
Date: Wed, 27 Aug 2008 00:15:48 GMT
Server: Apache/2.2.2 (Unix)
Last-Modified: Sun, 22 Jun 2008 20:53:38 GMT
Accept-Ranges: bytes
Content-Length: 4813
Connection: close
Content-Type: text/html
```

为了简便起见，Java提供了6个方法用以访问最常用的消息头类型的值，并在需要时将它们转换成数字类型，这些方法的详细信息参见表16-1。返回类型为 `long` 的方法，返回的是从格林尼治时间1970年1月1日开始计算的秒数。
![表16-1 用于访问响应头值的简便方法](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212201923528.png)

通过程序 `urlConnection.URLConnectionTest.java` ，可以对URL连接做一些试验。程序运行起来后，请在命令行中输入一个URL以及用户名和密码（可选），例如：
```bash
$ java urlConnection.URLConnectionTest http://www.yourserver.com user password
```
该程序将输出以下内容：
- 消息头中的所有键和值。
- 表16-1中6个简便方法的返回值。
- 被请求资源的前10行信息。

> 除了 `Base64` 编码的计算稍显复杂之外，程序其他部分非常简单明了。有一个类 `sun.misc.BASE64Encoder` ，虽然还未归档 *undocumented* ，但可以用它来代替我们在示例程序中提供的类。
```java
// urlConnection/URLConnectionTest.java
package urlConnection;
import java.io.*;
import java.net.*;
import java.nio.charset.*;
import java.util.*;

/**
 * This program connects to an URL and displays the response 
 * header data and the first 10 lines of the requested data.
 * Supply the URL and an optional username and password 
 * (for HTTP basic authentication) on the command line.
 */
public class URLConnectionTest {
	public static void main(String[] args) {
		try {
			String urlName;
			if (args.length > 0) urlName = args[0];
			else urlName = "http://horstmann.com";

			var url = new URL(urlName);
			URLConnection connection = url.openConnection();

			// set username, password if specified on command line
			if (args.length > 2) {
				String username = args[1];
				String password = args[2];
				String input = username + ":" + password;
				Base64.Encoder encoder = Base64.getEncoder();
				String encoding = encoder.encodeToString(input.getBytes(StandardCharsets.UTF_8));
				connection.setRequestProperty("Authorization", "Basic " + encoding);
			}

			connection.connect();
			// print header fields
			Map<String, List<String>> headers = connection.getHeaderFields();
			for (Map.Entry<String, List<String>> entry : headers.entrySet()) {
				String key = entry.getKey();
				for (String value : entry.getValue()) {
					System.out.println(key + ": " + value);
				}
			}
			
	        // print convenience functions
			System.out.println("----------");
			System.out.println("getContentType: " + connection.getContentType());
			System.out.println("getContentLength: " + connection.getContentLength());
			System.out.println("getContentEncoding: " + connection.getContentEncoding());
			System.out.println("getDate: " + connection.getDate());
			System.out.println("getExpiration: " + connection.getExpiration());
			System.out.println("getLastModified: " + connection.getLastModified());
			System.out.println("----------");

			String encoding = connection.getContentEncoding();
			if (encoding == null) encoding = "UTF-8";
			try (var in = new Scanner(connection.getInputStream(), encoding)) {
				// print first ten lines of contents
				for (int n = 1; in.hasNextLine() && n <= 10; ++n) 
					System.out.println(in.nextLine());
				if (in.hasNextLine()) System.out.println("...");
			 } 
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```
直接运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301111516008.png)

> [API] `java.net.URL` 1.0
> - `InputStream openStream()`
> 打开一个用于读取资源数据的输入流。
> - `URLConnection openConnection()`
> 返回一个 `URLConnection` 对象，该对象负责管理与资源之间的连接。

> [API] `java.net.URLConnection` 1.0
> - `void setDoInput(boolean doInput)`
> - `boolean getDoInput()`
> 如果 `doInput` 为 `true` ，那么用户可以接收来自该 `URLConnection` 的输入。
> - `void setDoOutput(boolean doOutput)`
> - `boolean getDoOutput()`
> 如果 `doOutput` 为 `true` ，那么用户可以将输出发送到该 `URLConnection` 。
> - `void setIfModifiedSince(long time)`
> - `long getIfModifiedSince()`
> 属性 `ifModifiedSince` 用于配置该 `URLConnection` 对象，使它只获取那些自从某个给定时间以来被修改过的数据。调用方法时需要传入的 `time` 参数指的是从格林尼治时间1970年1月1日午夜开始计算的秒数。
> - `void setConnectTimeout(int timeout)` 5.0
> - `int getConnectTimeout()` 5.0
> 设置或得到连接超时时限（单位：毫秒）。如果在连接建立之前、就已经达到了超时的时限，那么相关联的输入流的 `connect` 方法就会抛出一个 `SocketTimeoutException` 异常。
> - `void setReadTimeout(int timeout)` 5.0
> - `int getReadTimeout()` 5.0
> 设置读取数据的超时时限（单位：毫秒）。如果在一个读操作成功之前就已经达到了超时的时限，那么 `read` 方法就会抛出一个 `SocketTimeoutException` 异常。
> - `void setRequestProperty(String key, String value)`
> 设置请求头的一个字段。
> - `Map<String, List<String>> getRequestProperties()` 1.4
> 返回请求头属性的一个映射表。相同的键对应的所有值被放置在同一个列表中。
> - `void connect()`
> **连接远程资源并获取响应头信息**。
> - `Map<String, List<String>> getHeaderFields()`1.4
> 返回响应的一个映射表。相同的键对应的所有值被放置在同一个列表中。
> - `String getHeaderFieldKey(int n)`
> 得到响应头第 `n` 个字段的键。如果 `n` 等于 `0` 或大于响应头字段的总数，则该方法返回 `null` 值。
> - `String getHeaderField(int n)`
> 得到响应头第 `n` 个字段的值。如果 `n` 等于 `0` 或大于响应头字段的总数，则该方法返回 `null` 值。
> - `int getContentLength()`
> 如果内容长度可获得，则返回该长度值，否则返回-1。
> - `String getContentType() 
> 获取内容的类型，比如 `text/plain` 或 `image/gif` 。
> - `String getContentEncoding()`
> 获取内容的编码机制，比如 `gzip` 。这个值不太常用，因为默认的 `identity` 编码机制并不是用 `Content-Encoding` 头来设定的。
> - `long getDate()`
> - `long getExpiration()`
> - `long getLastModifed()`
> 获取创建日期、过期日以及最后一次被修改的日期。这些日期指的是从格林尼治时间1970年1月1日午夜开始计算的秒数。
> - `InputStream getInputStream()`
> - `OutputStream getOutputStream()`
> 返回从资源读取信息、或向资源写入信息的流。
> - `Object getContent()`
> 选择适当的内容处理器，以便读取资源数据并将它转换成对象。该方法对于读取诸如 `text/plain` 或 `image/gif` 之类的标准内容类型并没有什么用处，除非你安装了自己的内容处理器。

## 16.3.3 提交表单数据
上一节介绍了如何从一个Web服务器读取数据。现在介绍如何让程序再将数据反馈回Web服务器、和那些被Web服务器调用的程序。

为了将信息从Web浏览器发送到Web服务器，用户需要填写一个类似图16-7中所示的表单（网页见https://tools.usps.com/zip-code-lookup.htm?byaddress）。
![图16-7 HTML表单](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212202137410.png)
当用户点击提交按钮时，文本框中的文本以及复选框和单选按钮的设定值、都被发送到了Web服务器。此时，Web服务器调用程序对用户的输入进行处理。

有许多技术可以**让Web服务器实现对程序的调用**。其中最广人所知的是Java Servlet、JavaServer Face、微软 *ASP, Active Server Pages* 动态服务器主页）以及 *CGI, Common Gateway Interface* 通用网关接口脚本。为简便起见，我们在说明问题时不考虑所用的具体技术，而一律使用通用术语：服务器端程序脚本。

==服务器端脚本用于处理表单数据并生成另一个HTML页，该页会被Web服务器发回给浏览器，这个操作过程我们在图16-8中作了说明==。返回给浏览器的响应页可能包含新的信息（例如，信息检索程序中的响应页）或者仅仅只是一个确认。之后，Web浏览器将显示响应页。
![图16-8 执行服务器端脚本过程中的数据流](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212202303957.png)
不会在这里介绍应该如何实现服务器端脚本，而将侧重点放在**如何编写客户端程序、使之与已有的服务器端脚本进行交互**。

==当表单数据被发送到Web服务器时，数据到底由谁来处理并不重要，可能是Servlet或CGI脚本，也可能是其他服务器端技术==。客户端以标准格式将数据发送给Web服务器，而Web服务器则负责将数据传递给具体的程序以产生响应。

在向Web服务器发送信息时，通常有两个命令会被用到：`GET` 和 `POST` 。
在使用 `GET` 命令时，只需将参数附在URL的结尾处即可。这种URL的格式如下：
```html
http://host/path?query
```
其中，每个参数都具有“名字=值”的形式，而这些参数之间用 `&` 字符分隔开。参数的值将遵循下面的规则，使用URL编码模式进行编码：
- 保留字符 `A-Z, a-z, 0-9.-*_` 。
- 用 `+` 字符替换所有的空格。
- 将其他所有字符编码为UTF-8，并将每个字节都编码为 `%` 后面紧跟一个两位的十六进制数字。

例如，若要发送街道名 `New York, NY` ，可以使用 `New+York%2C+NY` ，因为十六进制数 `2c`（即十进制数44）是 `,` 的ASCII码值。==这种编码方式使得在任何中间程序中都不会混入空格，并且也不需要对其他特殊字符进行转换==。

例如，之前Google Map可以接受带有两个名为 `q, hl` 参数的查询请求，为了得到1 Market Street, San Franciso, CA的地图，并且让响应使用德语，只需访问下面的URL即可：
```jav
http://www.google.com/maps?q=1+Market+Street+San+Francisco&hl=de
```
`GET` 命令很简单，但是它有一个重要的局限性，正是由于这个局限性使得它并不是非常受欢迎——==在浏览器中出现很多的查询字符串、很让人郁闷，而且老式浏览器和代理、都对GET请求中能包含的字符数作了限制==。

而 **`POST` 请求经常用于处理具有大量数据的表单**。在使用 `POST` 请求时，并不需要在URL中添加任何参数，而是**从 `URLConnection` 中获取输出流，并将名-值对写入该流中**。当然，**仍然需要对这些值进行URL编码**，并用 `&` 字符将它们隔开。

下面详细介绍这个过程。在提交数据给脚本之前，首先需要创建一个 `URLConnection` 对象。
```java
var url = new URL("http://host/path");
URLConnection connection = url.openConnection();
```
然后，调用 `setDoOutput` 方法建立一个用于输出的连接。
```java
connection.setDoOutput(true);
```
接着，调用 `getOutputStream` 方法获得一个流，可以通过这个流向服务器发送数据。如果要向服务器发送文本信息，那么可以非常方便地将流包装在 `PrintWriter` 对象中。
```java
var out = new PrintWriter(connection.getOutputStream(), StandardCharsets.UTF_8);
```
现在，可以向服务器发送数据了。
```java
out.print(name1 + "=" + URLEncoder.encode(value1, StandardCharsets.UTF_8) + "&");
out.print(name2 + "=" + URLEncoder.encode(value2, StandardCharset.UTF_8));
```
之后，关闭输出流。
```java
out.close();
```
最后，调用 `getInputStream` 方法读取服务器的响应。

下面我们来实际操作一个例子。地址为https://tools.usps.com/zip-code-lookup.htm?byaddress的Web站点包含一个用于查找街道地址的邮政编码的表单（见图16-7）。**要想在Java中使用这个表单，需要知道 `POST` 请求的URL和参数**——==可以通过查看这个表单的HTML源码、来获取这些信息，但通常用网络监视器 *network monitor* 来“窥视”发出的请求==，会更容易一些。作为其开发工具的组成部分，大多数浏览器都拥有网络监控器。例如，图16-9展示了FireFox网络监视器向我们的示例网站提交数据时的截图。可以发现其中的提交URL、以及参数名和参数值。
![图16-9](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212202334937.png)
上面是书上的，现在的Form data如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301111555476.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301111603013.png)
在提交表单数据时，HTTP头包含了内容类型——还可以其他格式提交表单。例如，发送用JavaScript对象表示法JSON表示的数据，将内容类型设置为 `application/json` ：
```java
Content-Type: application/x-www-form-urlencoded
```
一个POST的请求头也必须包括内容长度，例如：
```java
Content-Length: 124
```

`post/PostTest.java` 将 `POST` 数据发送给任何脚本，它将数据放在如下的 `.properties` 文件：
```java
url=https://tools.usps.com/tools/app/ziplookup/zipByAddress
User-Agent=HTTPie/0.9.2
address1=1 Market Street
address2=
city=San Francisco
state=CA
companyName=
```

```java
// post/PostTest.java
package post;
import java.io.*;
import java.net.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;

/**
 * This program demonstrates how to use the URLConnection class for a POST request.
 */
public class PostTest {
	public static void main(String[] args) throws IOException {
		String propsFilename = args.length > 0 ? args[0] : "./src/post/post.properties";
		var props = new Properties();
		try (InputStream in = Files.newInputStream(Paths.get(propsFilename))) {
			props.load(in);
		}
		String urlString = props.remove("url").toString();
		Object userAgent = props.remove("User-Agent");
		Object redirects = props.remove("redirects");
		CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL));
		String result = doPost(new URL(urlString), props,
			userAgent == null ? null : userAgent.toString(),
			redirects == null ? -1 : Integer.parseInt(redirects.toString()));
		System.out.println(result);
	}

	/**
	 * Do an HTTP POST.
	 * @param url the URL to post to
	 * @param nameValuePairs the query parameters
	 * @param userAgent the user agent to use, or null for the default user agent
	 * @param redirects the number of redirects to follow manually, or -1 for automatic redirects
	 * @return the data returned from the server
	 */
	public static String doPost(URL url, Map<Object, Object> nameValuePairs, String userAgent, int redirects) throws IOException {
		var connection = (HttpURLConnection)url.openConnection();
		if (userAgent != null)
			connection.setRequestProperty("User-Agent", userAgent);
		if (redirects >= 0)
			connection.setInstanceFollowRedirects(false);
		connection.setDoOutput(true);

		try (var out = new PrintWriter(connection.getOutputStream())) {
			var first = true;
			for (Map.Entry<Object, Object> pair : nameValuePairs.entrySet()) {
				if (first) first = false;
				else out.print('&');
				String name = pair.getKey().toString();
				String value = pair.getValue().toString();
				out.print(name);
				out.print('=');
				out.print(URLEncoder.encode(value, StandardCharsets.UTF_8));
			}
		}
		
		String encoding = connection.getContentEncoding();
		if (encoding == null) encoding = "UTF-8";

		if (redirects > 0) {
			int responseCode = connection.getResponseCode();
			if (responseCode == HttpURLConnection.HTTP_MOVED_PERM
				|| responseCode == HttpURLConnection.HTTP_MOVED_TEMP 
				|| responseCode == HttpURLConnection.HTTP_SEE_OTHER) {
				String location = connection.getHeaderField("Location");
				if (location != null) {
					URL base = connection.getURL();
					connection.disconnect();
					return doPost(new URL(base, location), nameValuePairs, userAgent, redirects - 1);
				}
			}
		} else if (redirects == 0) {
			throw new IOException("Too many redirects");
		}

		var response = new StringBuilder();
		try (var in = new Scanner(connection.getInputStream(), encoding)) {
			while (in.hasNextLine()) {
				response.append(in.nextLine());
				response.append("\n");
			}
		} catch (IOException e) {
			InputStream err = connection.getErrorStream();
			if (err == null) throw e;
			try (var in = new Scanner(err)) {
				response.append(in.nextLine());
				response.append("\n");
			}
		}
		return response.toString();
	}	
}
```
运行结果如下，是一个JSON，截了一部分图：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301111620762.png)

这个程序移除 *removes* 了 `url` 和 `User-Agent` 项，并**将其他内容都发送到了 `doPost` 方法**。在 `doPost` 方法中，我们**首先用URL打开连接并设置用户代理**（在默认的 `User-Agent` 请求参数包含字符串Java时，邮政编码服务 *zip code service* 无法工作，这可能是因为邮政局不想为程序自动产生的请求服务）。

然后调用 `setDoOutput(true)` 并打开输出流。然后，枚举 `Map` 对象中的所有键和值。对每一个键值对，我们发送 `key=value` 和 `&` 分隔符：
```java
out.print(key);
out.print('=');
out.print(URLEncoder.encode(value, StandardCharsets.UTF_8));
if (more pairs) out.print('&');
```
当从写出请求、切换到读取响应的任意部分时，就会发生与服务器的实际交互。`Content-Length` 头被设置为输出的尺寸，`Content-Type` 头被设置为 `application/x-www-form-urlencoded`  ，除非指定了不同的内容类型。这些头信息和数据、都被发送给服务器，然后响应头和服务器响应会被读取，并可以被查询。**在示例程序中，这种切换发生在对 `connection.getContentEncoding()` 的调用中**。

在读取响应过程中会碰到一个问题。如果服务器端出现错误，那么调用 `connection.getInputStream()` 时会抛出一个 `FileNotFoundException` 异常。但此时服务器仍然会向浏览器返回一个错误页面（例如常见的"错误404-找不到该页"）。为了捕捉这个错误页，可以调用 `getErrorStream` 方法：
```java
InputStream err = connection.getErrorStream();
```
> 注释：`getErrorStream` 方法与这个程序中的许多其他方法一样，属于 `URLConnection` 类的子类 `HttpURLConnection` 。如果要创建以 `http://` 或 `https://` 开头的URL，那么可以将所产生的连接对象强制转型为 `HttpURLConnection` 。

**在将 `POST` 数据发送给服务器时，服务器端程序产生的响应可能是 `redirect: a different URL` ，后面跟着一个完全不同的URL，该URL应被调用、以获取实际的信息**。服务器可以这么做，因为这些信息在他处可得，或提供一个可以作为书签标记的URL *bookmarkable URL* 。`HttpURLConnection` 类在大多数情况下可以处理重定向。

如果 `cookie` 需要在重定向中，从一个站点发送到另一个站点，那么可以像下面这样**配置一个全局的 `cookie` 处理器**：
```java
CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL));
```
然后，`cookie` 就可以被正确地包含在重定向请求中了。

尽管重定向通常是自动处理的，但有些情况下，你需要自己完成重定向。例如，**在HTTP和HTTPS之间的自动重定向因为安全原因而不被支持**。重定向还会因更细微的原因而失败。例如，一个早期版本的邮政编码服务就使用了重定向。回忆一下，我们设置了 `User-Agent` 请求参数，以便让邮局认为我们不是在通过Java API发送请求，尽管可以在最初的请求中将用户代理设置为其他的字符串，但这项设置在自动重定向中并没有被使用，自动重定向总是会发送包含单词Java的通用用户代理字符串。

在这些情况下，**可以人工实现重定向**。**在连接到服务器前，关闭自动重定向**：
```java
connection.setInstanceFollowRedirects(false);
```
在发送请求后，获取响应码：
```java
int responseCode = connection.getResponseCode();
```
再检查它是否是下列值之一：
```java
HttpURLConnection.HTTP_MOVED_PERM
HttpURLConnection.HTTP_MOVED_TEMP
HttpURLConnection.HTTP_SEE_OTHER
```
**如果是这些值之一，那么获取 `Location` 响应头，以获得重定位的URL**。然后断开连接，并**创建到新的URL的连接**：
```java
String location = connection.getHeaderField("Location");
if (location != null) {
	URL base = connection.getURL();
	connection.disconnect();
	connection = (HttpURLConnection) new URL(base, location).openConnection();
	...
}
```
无论何时你需要从某个现有的Web站点查询信息时，该程序展示的处理技术会显得很有用。只需找出需要发送的参数，然后从回复信息中剔除HTML tags和其他不必要的信息即可。
> [API] `java.net.HttpURLConnection` 1.0
> - `InputStream getErrorStream()`
> 返回一个流，通过这个流可以读取Web服务器的错误信息。

> [API] `java.net.URLEncoder` 1.0
> - `static String encode(String s, String encoding)` 1.4
> 采用指定的字符编码模式（推荐使用“UTF-8”）对字符串 `s` 进行编码，并返回它的URL编码形式。在URL编码中，`'A'-'Z', 'a'-'z', '0'-'9', '-', '_', '.', '*'` 等字符保持不变，空格被编码成 `'+'` ，所有其他字符被编码成 `"%XY"` 形式的字节序列，其中 `0xXY` 为该字节十六进制数。

> [API] `java.net.URLDecoder` 1.2
> - `static string decode(String s, String encoding)` 1.4
> 采用指定编码模式对已编码字符串 `s` 进行解码，并返回结果。

---
# 16.4 HTTP客户端
**`URLConnection` 类**是在HTTP成为Web普适协议之前设计的，它提供了对大量协议的支持，**但它对HTTP的支持有些笨重**。当做出决定要支持HTTP/2时情况就很清楚了——最好是提供一个新的客户端接口，而不是对现有API做重构。`HttpClient` 提供了更便捷的API和对HTTP/2的支持。**在Java 9和10中，其API类位于 `jdk.incubator.http` 包中**，使该API有机会成为根据用户反馈不断演化的产物，**到了Java 11，`HttpClient` 位于 `java.net.http` 包中**。
> 注释：在使用Java 9和10时，要用下面的命令行选项运行程序：
> ```java
> --add-modules jdk.incubator.httpclient
> ```

与 `URLConnection` 类相比，==HTTP client的API、从设计开始就提供了一种更简单的连接到Web服务器的机制==。

**`HttpClient` 对象可以发出请求并接收响应**，可以通过下面的调用获取客户端：
```java
HttpClient client = HttpClient.newHttpClient()
```
或者如果需要配置客户端，可以使用像下面这样的构建器API：
```java
HttpClient client = HttpClient.newBuilder()
	.followRedirects(HttpClient.Redirect.ALWAYS)
	.build();
```
即获取一个构建器 *builder* 、调用其方法定制需要被构建的项，然后调用 `build` 方法来终结构建过程，这是一种构造不可修改对象的常见模式。

还可以遵循构建器模式来定制请求，下面是一个 `Get` 请求：
```java
HttpRequest request = HttpRequest.newBuilder()
	.uri(new URI("http://horstmann.com"))
	.GET()
	.build();
```
==URI是指统一资源标识符，在使用HTTP时它与URL相同==。但在Java中，URL类有确实用来打开到某个URL的连接的方法，而**URI类只关心语法**（模式、主机、端口、路径、查询、片段 *scheme, host, port, path, query, fragment* 等）。

**对于 `POST` 请求，需要一个体发布器 *body publisher*** ，它会将请求数据转换为要POST的数据。有针对字符串、字节数组和文件的体发布器。例如，如果请求是JSON格式的，那么只需将JSON字符串提供给某个字符串体发布器：
```java
HttpRequest request = HttpRequest.newBuilder()
	.uri(new URI(url))
	.header("Content-Type", "application/json")
	.POST(HttpRequest.BodyPublishers.ofString(jsonString))
	.build();
```
遗憾的是，该API不支持对常见内容类型进行必须的格式化处理 *the required formatting for common content types* 。`client/HttpClientTest.java` 提供了用于表单数据和文件上传的体发布器。

**在发送请求时，必须告诉客户端如何处理响应**。如果只是想将体当做字符串处理，那么就可以像下面这样用 `HttpResponse.BodyHandler.asString()` 来发送请求：
```java
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
```
`HttpResponse` 类是一个泛化类 *generic type* ，它的类型参数表示体的类型。可以直接获取响应体字符串：
```java
String bodyString = response.body();
```
**还有其他的响应体处理器**，可将响应作为字节数组或输入流来获取。`BodyHandlers.ofFile(filePath)` 会产生一个处理器，将响应存储到给定的文件中。`BodyHandlers.ofFileDownload(directoryPath)` 会用 `Content-Disposition` 头中的信息将响应存入给定的目录中。最后，从 `BodyHandlers.discarding()` 中获取的处理器会直接丢弃响应。

**处理响应的内容并不在该API的考虑范围内**。例如，如果收到了JSON数据，那么就需要某个JSON库来解析其中的内容。

**`HttpResponse` 对象还会产生状态码和响应头**：
```java
int status = response.statusCode();
HttpHeaders responseHeaders = response.headers();
```
可以将 `HttpHeader` 对象转换为一个映射表：
```java
Map<String, List<String>> headerMap = responseHeaders.map();
```
这个映射表的值是列表，因为在HTTP中，每个键都可以有多个值。如果只想要某个特定键的值，并且知道它没有多个值，那么可以调用 `firstValue` 方法：
```java
Optional<String> lastModified = headerMap.firstValue("Last-Modified");
```
这样就可以得到响应的值，或在没有提供该值时返回空 `Optional` 对象。

可以异步处理响应。**在构建客户端时，可以提供一个执行器**：
```java
ExecutorService executor = Executors.newCachedThreadPool();
HttpClient client = HttpClient.newBuilder().executor(executor).build();
```
**构建一个请求，然后在该客户端上调用 `sendAsync` 方法**，就会收到一个 `CompletableFuture<HttpResponse<T>>` 对象，其中 `T` 是体处理器的类型，需要使用卷1章12描述的 `CompletableFuture` API：
```java
HttpRequest request = HttpRequest.newBuilder().uri(uri).GET().build();
client.sendAsync(request, HttpResponse.BodyHandler.asString())
	.thenAccept(response -> ...);
```
> 提示：为了启用针对 `HttpClient` 记录日志的功能，需要在JDK的 `net.properties` 文件中添加下面的行：
> ```java
> jdk.httpclient.HttpClient.log=all
> ```
> 除了 `all` ，还可以指定一个由逗号分隔的列表，其中包含 `headers, requests, content, errors, ssl, trace, and frames` ，后面还可以选择地跟着 `:control, :data, :window, :all` 。中间不要使用任何空格。
> 然后，将名为 `jdk.httpclient.HttpClient` 的日志记录器的日志级别设置为 `INFO` ,例如在JDK的 `logging.properties` 文件中添加下面的行：
> ```java
> jdk.httpclient.HttpClient.level=INFO
> ```

```java
// client/HttpClientTest.java
package client;

import java.io.*;
import java.math.*;
import java.net.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;

import java.net.http.*;
import java.net.http.HttpRequest.*;

class MoreBodyPublishers {
	public static BodyPublisher ofFormData(Map<Object, Object> data) {
		var first = true;
		var builder = new StringBuilder();
		for (Map.Entry<Object, Object> entry : data.entrySet()) {
			if (first) first = false;
			else builder.append("&");
			builder.append(URLEncoder.encode(entry.getKey().toString(),
				StandardCharsets.UTF_8));
			builder.append("=");
			builder.append(URLEncoder.encode(entry.getValue().toString(),
				StandardCharsets.UTF_8));
		}
		return BodyPublishers.ofString(builder.toString());
	}

	private static byte[] bytes(String s) { return s.getBytes(StandardCharsets.UTF_8); }

	public static BodyPublisher ofMimeMultipartData(Map<Object, Object> data, String boundary) throws IOException {
		var byteArrays = new ArrayList<byte[]>();
		byte[] separator = bytes("--" + boundary + "\nContent-Disposition: form-data; name=");
		for (Map.Entry<Object, Object> entry : data.entrySet()) {
			byteArrays.add(separator);
			if (entry.getValue() instanceof Path) {
				var path = (Path) entry.getValue();
				String mimeType = Files.probeContentType(path);
				byteArrays.add(bytes("\"" + entry.getKey() + "\"; filename=\"" + path.getFileName() +
					"\"\nContent-Type: " + mimeType + "\n\n"));
	            byteArrays.add(Files.readAllBytes(path));
			} else
				byteArrays.add(bytes("\"" + entry.getKey() + "\"\n\n" + entry.getValue() + "\n"));
		}
		byteArrays.add(bytes("--" + boundary + "--"));
		return BodyPublishers.ofByteArrays(byteArrays);
	}

	public static BodyPublisher ofSimpleJSON(Map<Object, Object> data) {
		var builder = new StringBuilder();
		builder.append("{");
		var first = true;
		for (Map.Entry<Object, Object> entry : data.entrySet()) {
			if (first) first = false;
			else builder.append(",");
			builder.append(jsonEscape(entry.getKey().toString())).append(": ")
				.append(jsonEscape(entry.getValue().toString()));
		}
		builder.append("}");
		return BodyPublishers.ofString(builder.toString());
	}

	private static Map<Character, String> replacements = Map.of('\b', "\\b", '\f', "\\f", '\n', "\\n", '\r', "\\r", '\t', "\\t", 
			'"', "\\\"", '\\', "\\\\");
	private static StringBuilder jsonEscape(String str) {
		var result = new StringBuilder("\"");
		for (int i = 0; i < str.length(); ++i) {
			char ch = str.charAt(i);
			String replacement = replacements.get(ch);
			if (replacement == null) result.append(ch);
			else result.append(replacement);
		}
		result.append("\"");
		return result;
	}
}

public class HttpClientTest {
	public static void main(String[] args)
		throws IOException, URISyntaxException, InterruptedException {
		System.setProperty("jdk.httpclient.HttpClient.log", "headers,errors");
		String propsFilename = args.length > 0 ? args[0] : "./src/client/json.properties";
		Path propsPath = Paths.get(propsFilename);
		var props = new Properties();
		try (InputStream in = Files.newInputStream(propsPath)) {
			props.load(in);
		}
		
		String urlString = "" + props.remove("url");
		String contentType = "" + props.remove("Content-Type");
		if (contentType.equals("multipart/form-data")) {
			var generator = new Random();
			String boundary = new BigInteger(256, generator).toString();
			contentType += ";boundary=" + boundary;
			props.replaceAll((k, v) -> 
				v.toString().startsWith("file://") ?
					propsPath.getParent().resolve(Paths.get(v.toString().substring(7)))
					: v
			);
		}
		String result = doPost(urlString, contentType, props);
		System.out.println(result);
	}

	public static String doPost(String url, String contentType, Map<Object, Object> data)
		throws IOException, URISyntaxException, InterruptedException {
		// build a http client
		HttpClient client = HttpClient.newBuilder()
			.followRedirects(HttpClient.Redirect.ALWAYS).build();
		// create a proper publisher
		BodyPublisher publisher = null;
		if (contentType.startsWith("multipart/form-data")) {
			String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
			publisher = MoreBodyPublishers.ofMimeMultipartData(data, boundary);
		} else if (contentType.equals("application/x-www-form-urlencoded")) 
			publisher = MoreBodyPublishers.ofFormData(data);
		else {
			contentType = "application/json";
			publisher = MoreBodyPublishers.ofSimpleJSON(data);
		}
		// build a request object
		HttpRequest request = HttpRequest.newBuilder()
			.uri(new URI(url))
			.header("Content-Type", contentType)
			.POST(publisher)
			.build();
		// get the response object
		HttpResponse<String> response
			= client.send(request, HttpResponse.BodyHandlers.ofString());
		return response.body();
	}
}
```
```json
// post.properties
# The data are the LOC in the java.base/java/util and java.base/com/sun directories
# We test the hypothesis whether the distributions are different  
url=http://www.physics.csbsju.edu/cgi-bin/stats/t-test_paste.n.plot
Content-Type=application/x-www-form-urlencoded
A=58\n1725\n79\n136\n97\n55\n118\n84\n53\n43\n33\n49\n52\n57\n88\n121\n114\n61\n67\n60\n167\n94\n98\n346\n84\n552\n1758\n833\n391\n392\n97\n801\n101\n95\n10245\n180\n291\n60\n55\n56\n3827\n48\n3018\n125\n757\n54\n65\n138\n105\n471\n103\n1075\n80\n260\n128\n126\n124\n749\n987\n69\n58\n78\n94\n76\n62\n97\n59\n57\n70\n88\n61\n65\n1822\n90\n69\n341\n398\n142\n560\n452\n340\n1051\n362\n121\n287\n179\n857\n238\n146\n37\n548\n33\n1880\n665\n78\n399\n958\n1869\n500\n1183\n2325\n289\n1681\n661\n318\n5963\n154\n431\n13\u2026\n89\n55\n61\n59\n52\n60\n53\n72\n83\n118\n559\n60\n54\n71\n579\n1301\n440\n664\n438\n978\n583\n274\n53\n237\n80\n190\n41\n679\n60\n466\n66\n75\n61\n72\n493\n659\n738\n1202\n52\n49\n56\n56\n95\n112\n91\n56\n72\n93\n731\n494\n50\n95\n347\n2032\n1123\n157\n111\n48\n102\n119\n83\n131\n80\n431\n203\n118\n72\n69\n119\n1497\n439\n93\n84\n1453\n570\n190\n143\n55\n993\n559\n622\n1947\n773\n488\n949\n359\n70\n3184\n645\n1333\n75\n2163\n78\n51\n1088\n2133\n720\n1063\n70\n55\n56\n56\n94\n55\n205\n89\n50\n354\n136933\n
B=645\n46\n697\n117\n90\n511\n263\n126\n428\n41\n558\n115\n91\n240\n1162\n284\n219\n259\n188\n198\n428\n39\n1145\n426\n168\n162\n145\n160\n90\n578\n167\n147\n160\n91\n435\n233\n204\n169\n144\n322\n323\n154\n130\n245\n598\n146\n113\n249\n294\n47\n109\n135\n47\n109\n125\n963\n200\n375\n248\n220\n84\n306\n155\n148\n535\n415\n525\n429\n435\n182\n152\n286\n218\n198\n817\n127\n90\n151\n320\n229\n475\n157\n264\n801\n102\n281\n190\n390\n93\n298\n1698\n2761\n618\n317\n398\n1489\n906\n43\n1658\n503\n729\n134\n134\n134\n174\n570\n818\n688\n331\n101\n1377\n2376\n1743\n611\n500\n331\n125\n262\n320\n54\n203\n67\n123\n203\n56\n506\n220\n64\n42\n31\n201\n74\n136\n699\n220\n62\n42\n109\n73\n331\n206\n94\n430\n213\n30\n51712\n
// json.properties
url=http://www.reverso.net/WebReferences/WSAJAXInterface.asmx/TranslateWS
searchText=Hello World 
direction=524289 
maxTranslationChars=-1
// fileupload.properties
url=https://dopiaza.org/tools/datauri/index.php
Content-Type=multipart/form-data
datasource=upload
MAX_FILE_SIZE=1048576
file=file://cup.png
text=
base64=base64
mimetype=ua
mimetypevalue=
Submit=Generate Data URI
```
cup.jpg如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301112137320.png)
使用 `post.properties` 会报错：`java.nio.channels.ClosedChannelException` 以及 `java.net.ConnectException` 。

使用 `fileupload.properties` 的运行结果如下（成功！）：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301112140873.png)
使用 `json.properties` 的运行结果如下（指向网页https://www.reverso.net/）：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301112135586.png)
不是很明白上面的意思，难不成 `json.properties` 是想翻译？`fileupload.properties` 是想上传图片、然后使用Base64生成一个Data URI？而且也没说明白 `properties` 文件如何写！

现在我明白了一些，`fileupload` 相关网页的POST请求体内容如下，所以 `ofMimeMultipartData` 方法是那样实现的：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301112154313.png)
而**得到的结果则是响应页的HTML**，如下 `fileupload` 响应结果中有编码出的Data URI：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301112156025.png)
而 `json` 相关网页的POST请求体内容如下（所以原来的 `json.properties` 不适用了，而且 `properties` 文件好像不是很好表达这个结构）：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301112201230.png)
改为如下以后再运行：
```java
url=https://api.reverso.net/translate/v1/translation
from=eng
input=Hello World 
to=chi
```
返回的HTML说，被拒绝访问什么的，搞不懂：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301112205132.png)

> [API] `java.net.http.HttpClient` 11
> - `static HttpClient newHttpClient()`
> 用默认配置产生一个 `HttpClient` 对象。
> - `static HttpClient.Builder newBuilder()`
> 产生一个用于构建 `HttpClient` 对象的**构建器**。
> - `<T> HttpResponse<T> send(HttpRequest request, HttpResponse.BodyHandler<T> responseBodyHandler)`
> - `<T> CompletableFuture<HttpResponse<T>> sendAsync(HttpRequest request, HttpResponse.BodyHandler<T> responseBodyHandler)`
> 产生一个同步或异步的请求，并**使用给定的处理器来处理响应体**。
 
> [API] `java.net.http.HttpClient.Builder 11
> - `HttpClient build()` 
> 用由当前构建器配置的属性，**产生一个 `HttpClient` 对象**。
> - `HttpClient.Builder followRedirects(HttpClient.Redirect policy)`
> 将重定向策略设置为 `HttpClient.Redirect` 枚举中的 `ALWAYS, NEVER, or NORMAL` (*only refuse redirects from HTTPS to HTTP*) 之一。
> - `HttpClient.Builder executor(Executor executor)`
> 设置用于异步请求的执行器。

> [API] `java.net.http.HttpRequest 11
> - `HttpRequest.Builder newBuilder()`
> 产生一个用于构建 `HttpRequest` 对象的构建器。

> [API] `java.net.http.HttpRequest.Builder` 11
> - `HttpRequest build()`
> 用「由当前构建器配置的属性」**产生一个 `HttpRequest` 对象**。 
> - `HttpRequest.Builder uri(URI uri)`
> 为当前请求设置URI。
> - `HttpRequest.Builder header(String name, String value)`
> 为当前请求设置请求头。
> - `HttpRequest.Builder GET()`
> - `HttpRequest.Builder DELETE()`
> - `HttpRequest.Builder POST(HttpRequest.BodyPublisher bodyPublisher)`
> - `HttpRequest.Builder PUT(HttpRequest.BodyPublisher bodyPublisher)`
> 为当前请求设置请求方法和请求头。

> [API] `java.net.http.HttpResponse<T>` 11
> - `T body()
> 产生当前响应的体。
> - `int statusCode()
> 产生当前响应的状态码。
> - `HttpHeaders headers()`
> 产生响应头。

> [API] `java.net.http.HttpHeaders` 11
> - `Map<String, List<String>> map()`
> 产生这些头的映射。
> - `Optional<String> firstValue(String name)`
> 在头中具有给定名的第一个值，如果存在的话。

---
# 16.5 发送E-mail
过去，编写程序、通过与「SMTP专用的端口25」建立套接字连接 *making a socket connection to port 25* 发送电子邮件，是一个很简单的事。**简单邮件传输协议用于描述E-mail消息的格式**。一旦连接到服务器，就可以发送一个**邮件报头**（采用SMTP格式，该格式很容易生成）。紧随其后的是**邮件消息**。

以下是操作的详细过程：
1. 打开一个到达主机的套接字：
   ```java
	var s = new Socket("mail.yourserver.com", 25); // 25 is SMTP
	var out = new PrintWriter(s.getOutputStream(), StandardCharsets.UTF_8);
   ```
2. 发送以下信息到打印流：
   ```java
   HELO sending host
   MAIL FROM: sender e­mail address
   RCPT TO: recipient e­mail address 
   DATA
   Subject: subject
   (blank line)
   mail message (any number of lines)
   .
   QUIT
   ```

SMTP规范（RFC 821）规定，每一行都要以 `\r` 再紧跟一个 `\n` 来结尾。SMTP曾经总是例行公事般地路由任何人的e-mail，但在蠕虫泛滥的今天，许多服务器都内置了检查功能，并且只接受来自授信用户或IP地址范围的请求。其中，**认证通常是通过安全套接字连接 *secure socket connections* 来实现的**。

实现人工认证模式的代码非常冗长乏味，因此，我们将展示如何利用JavaMail API在Java程序中发送e-mail。可以从www.oracle.com/technetwork/java/javamail处下载JavaMail，然后将它解压到硬盘上的某处。

如果要使用JavaMail，则需要设置一些和邮件服务器相关的属性。例如，在使用GMail时，需要设置（示例程序是从一个属性文件中读取这些属性值的）：
```java
mail.transport.protocol=smtps
mail.smtps.auth=true
mail.smtps.host=smtp.gmail.com
mail.smtps.user=accountname@gmail.com
```

出于安全的原因，我们没有将密码放在属性文件中，而是要求提示用户需要输入。首先要读入属性文件，然后**像下面这样获取一个邮件会话**：
```java
Session mailSession = Session.getDefaultInstance(props);
```
接着，用恰当的发送者、接受者、主题和消息文本来创建消息：
```java
var message = new MimeMessage(mailSession);
message.setFrom(new InternetAddress(from));
message.addRecipient(RecipientType.TO, new InternetAddress(to));
message.setSubject(subject);
message.setText(builder.toString());
```
然后将消息发送走：
```java
Transport tr = mailSession.getTransport();
tr.connect(null, password);
tr.sendMessage(message, message.getAllRecipients());
tr.close();
```
程序 `mail/MailTest.java` 是从「具有下面这种格式的文本文件」中读取消息的：
```java
Sender
Recipient 
Subject
Message text (any number of lines)
```
要运行该程序，需要从https://javaee.github.io/javamail下载JavaMail的实现，还需要Java激活框架 *Java Activation Framework* 的JAR文件，从http://www.oracle.com/technetwork/java/javase/jaf­135115.html处获得，或者可以从Maven Central中搜索，然后运行：
```bash
$ java ­classpath .:javax.mail.jar:activation­1.1.1.jar path/to/message.txt
```
其中，`mail.jar` 是JavaMail的JAR文件（Windows用户注意：记住在 `classpath` 中要输入分号而不是冒号）。

以前GMail不检查信息的真实性，即你可以输入任何你喜欢的发送者（当你下一次收到来自 `president@whitehouse.gov` 的e-mail消息、邀请你盛装出席白宫南草坪的活动时，请牢记这一点，谨防上当）。
> 提示：如果搞不清楚为什么你的邮件连接无法正常工作，那么可以调用：
> ```java
> mailSession.setDebug(true);
> ```
> 并检查消息。而且，JavaMail API FAQ也有些挺有用的调试提示。

```java
// mail/MailTest.java
package mail;

import java.io.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*;
import javax.mail.internet.MimeMessage.RecipientType;

/**
 * This program shows how to use JavaMail to send mail messages.
 */
public class MailTest {
	public static void main(String[] args) throws MessagingException, IOException {
		var props = new Properties();
		try (InputStream in = Files.newInputStream(Paths.get("mail", "./src/mail/mail.properties"))) {
			props.load(in);
		}
		List<String> lines = Files.readAllLines(Paths.get(args[0]), StandardCharsets.UTF_8);

		String from = lines.get(0);
		String to = lines.get(1);
		String subject = lines.get(2);

		var builder = new StringBuilder();
		for (int i = 3; i < lines.size(); i++) {
			builder.append(lines.get(i));
			builder.append("\n");
		}

		Console console = System.console();
		var password = new String(console.readPassword("Password: "));

		Session mailSession = Session.getDefaultInstance(props);
		// mailSession.setDebug(true);
		var message = new MimeMessage(mailSession);
		message.setFrom(new InternetAddress(from));
		message.addRecipient(RecipientType.TO, new InternetAddress(to));
		message.setSubject(subject);
		message.setText(builder.toString());
		Transport tr = mailSession.getTransport();
		try {
			tr.connect(null, password);
			tr.sendMessage(message, message.getAllRecipients());
		} finally {
			tr.close();
		}
	}
}
```
```java
// message.txt
president@whitehouse.gov
recipient@recipientdomain.com
Invitation 
Dear Friend:

It is my pleasure to invite you to a black-tie reception
on the front lawn of the White House on April 1, 2019.

Sincerely,


Donald J. Trump
// mail.properties
mail.transport.protocol=smtps
mail.smtps.auth=true
mail.smtps.host=smtp.gmail.com
mail.smtps.user=accountname@gmail.com
```
就不运行这个程序了。