第6章　高级Swing
▲列表
▲文本构件
▲表格
▲进度指示器
▲树
▲构件组织器与装饰器
在本章中，我们继续对第Ⅰ卷的Swing用户界面工具包进行讨论。Swing是功能丰富的工具包，而本书第Ⅰ卷仅仅涉及了若干简单而常用的构件。所以本章的大部分内容，将研究余下三个最为丰富复杂的构件：列表、树和表格。然后我们转向文本构件，讨论那些超越第Ⅰ卷中看到的简单的文本框和文本域的特性，我们将展示如何在文本框上添加校验和微调框，以及如何显示诸如HTML这样的结构化文本。接下来，你还将会看到大量用于显示耗时行为的进度的构件。在本章的最后，我们将介绍一些构件组织器，比如标签面板和带有内部框架的桌面面板。6.1　列表
如果你想向用户提供一个选项集，而单选按钮或复选框又显得占用了太多的空间，那么就可以使用组合框或列表。组合框相对简单，已经在卷I中介绍过。JList构件的功能更加丰富，而且它的设计与树形构件和表格构件都很相似。所以，对于复杂Swing构件的讨论，我们将从JList开始。
当然，你可以使用字符串列表，但也可以使用任意对象的列表，你可以完全控制它们的外在显示形式。正是列表控件的这种内部结构，使它不仅具备极强的通用性，而且也更精巧。遗憾的是，Sun公司的设计人员认为他们更应该炫耀这种精巧，而不是将它对那些只是想使用这些构件的程序员隐藏起来。大家很快就会发现，在通常情况下，这种列表控制有点不太灵活，因为你需要操作某些使其在通常情况下可用的复杂机制。我们先介绍最简单、最常用的情况，即字符串列表框，然后给出一个更复杂的例子来展示列表构件的灵活性。
	
	6.1.1　JList构件
JList可以将多个选项放置在单个框中，图6-1是一个大家公认的不合理的例子。用户可以选择狐狸的属性，比如“quick（敏捷的）”、“brown（棕色的）”、“hungry（饥饿的）”、“wild（野生的）”，以及我们选定的“static（静态的）”、“private（私有的）”和“final（最终的）”。结果，你可以让这只private的static的、final的狐狸从那只懒狗身上跳过去了。

图6-1　一个列表框
从Java SE7开始，JList是一个泛型，其type参数是用户可选的值的类型；在本例中，是JList<String>。
为了构建这个列表框，首先需要创建一个字符串数组，然后将这个数组传递给JList构造器。
列表框不能自动滚动，要想为列表框加上滚动条，必须将它插入到一个滚动面板中：
然后应该把滚动面板而不是列表框，插入到外围面板上。
我们必须承认，从理论上讲，把列表框的显示和滚动机制隔离开来是优雅的设计，但是在实际应用中却令人苦不堪言，其实我们遇到的所有列表框基本上都需要滚动功能。强制程序员在默认情况下每次都去作这种麻烦事，以使他们赞赏这种优雅设计，确实有点残忍。
默认情况下，列表框构件可以显示8个选项；可以使用setVisibleRowCount方法改变这个值：
还可以使用以下三个值中的任意一个来设置列表框摆放的方向：
·JList.VERTICAL（默认值）：垂直摆放所有选项。
·JList.VERTICAL_WRAP：如果选项数超过了可视行数，就开始新的一列（参见图6-2）。
图6-2　带有垂直和水平换行的列表框
·JList.HORIZONTAL_WRAP：如果选项数超过了可视行数，就开始新的一行，并且按照水平方向进行填充。请观察图6-2中单词“quick”，“brown”和“hungry”的位置，以弄清楚垂直换行和水平换行的不同。
在默认情况下，用户可以选择多个选项。为了选择多个选项，只需按住CTRL键，然后在要选择的选项上单击。要选择处于连续范围内的选项，首先选择第一个选项，然后按住SHIFT键，并在最后一个选项上单击即可。
使用setSelectionMode方法，还可以对用户的选择模式加以限制：
也许你还记得，在卷I中提到，当用户激活了基本的用户界面构件时，它们将发出动作事件。列表框使用另一种不同的事件通知机制，它不需要监听动作事件，而是监听列表选择事件。可以向列表构件添加一个列表选择监听器，然后在监听器中实现下面这个方法：
在用户选择了若干个选项的同时，将产生一系列列表选择事件。假如用户在一个新选项上单击，当鼠标按下的时候，就会有一个事件来报告选项的改变。这是一种过渡型事件，在调用
时，如果该选择仍未最终结束则返回true。然后，当松开鼠标时，就产生另一事件，此时getValueIsAdjusting返回false。如果你对这种过渡型事件不感兴趣，那么可以等待getValueIsAdjusting调用返回false的事件。不过，如果希望只要点击鼠标就给用户一个即时反馈，那么就需要处理所有的事件。
一旦被告知某个事件已经发生，那么就需要弄清楚当前选择了哪些选项。如果是单选模式，调用getSelectedValue可以获取所选中列表元素的值；否则调用getSelectedValues返回一个包含所有选中选项的对象数组。之后，可以以常规方式处理它。
注意：列表构件不响应鼠标的双击事件。正如Swing设计者所构想的那样，使用列表选择一个选项，然后点击某个按钮执行某个动作。但是，某些用户界面允许用户在一个列表选项上双击鼠标，作为选择一个选项并调用一个默认动作的快捷方式。如果想实现这种行为，那么必须对这个列表框添加一个鼠标监听器，然后按照下面这样捕获鼠标事件：
程序清单6-1展示了一个填入了字符串的列表框。请注意valueChanged方法是怎样根据被选项来创建消息字符的。
程序清单6-1　List/ListFrame.java
javax.swing.JList<E>1.2
·JList（E[]items）
构建一个显示这些选项（item）的列表。
·int getVisibleRowCount（）
·void setVisibleRowCount（int c）
获取或设置列表在没有滚动条时显示的默认行数。
·int getLayoutOrientation（）1.4
·void setLayoutOrientation（int orientation）1.4
获取或设置方向布局。
参数：orientation　VERTICAL、VERTICAL_WRAP、HORIZONTAL_WRAP其中之一
·int getSelectionMode（）
·void setSelectionMode（int mode）
获取或设置选择方式是单选或多选。
参数：mode　SINGLE_SELECTION、SINGLE_INTERVAL_SELECTION、MULTIPLE_INTERVAL_SELECTION其中之一
·void addListSelectionListener（ListSelectionListener listener）
向列表添加一个在每次选择结果发生变化时会被告知的监听器。
·List<E>getSelectedValues（）7
返回所有的选定值，如果选择结果为空，则返回一个空表。
·E getSelectedValue（）
返回第一个选定值，如果选择结果为空，则返回null。
javax.swing.event.ListSelectionListener 1.2
·void valueChanged（ListSelectionEvent e）
在任何时刻，只要选择结果发生了改变，该方法就会被调用。6.1.2　列表模式
通过前一节，我们已经对列表构件的一些最常用的方法有了一定的了解：
1）指定一组在列表中显示的固定字符串。
2）将列表放置到一个滚动面板中。
3）捕获列表选择事件。
在有关列表的章节的余下部分，我们将介绍一些需要一点技巧才能处理的复杂情形：
·很长的列表。
·内容会发生变化的列表。
·不包含字符串的列表。
在第一个例子中，我们构建的那个JList构件包含固定不变的字符串集合。不过，列表框中的选项并非只能固定不变。那么我们应该怎样添加或删除列表框中的选项呢？令人有点吃惊的是，JList类并未提供实现这些功能的任何方法。相反地，需要进一步了解列表构件的内部设计。列表构件使用了模型-视图-控制器这种设计模式，将可视化外观（以某种方式呈现的一列选项）和底层数据（一个对象集合）进行了分离。
JList类负责数据的可视化外观。实际上，它对这些数据是怎样存储的知之甚少，它只知道可以通过某个实现了ListModel接口的对象来获取这些数据：
通过这个接口，JList就可以获得元素的个数，并且能够获取每一个元素。另外，JList对象可以将其自身添加为一个ListDataListener。在这种方式下，一旦元素集合发生了变化，就会通知JList，从而使它能够重新绘制列表。
为什么这种通用性非常有用呢？为什么JList对象不直接存储一个对象数组呢？
请注意，这个接口并未指定这些对象是怎样存储的。尤其是，它根本就没有强制要求这些对象一定要被存储！无论何时调用getElementAt方法，它都会对每个值进行重新计算。如果想显示一个极大的集合，而且又不想存储这些值，那么这个方法可能会有所帮助。
这里举一个有点无聊的示例：允许用户在列表框中所有三个字母的单词当中进行选择（参见图6-3）。
图6-3　从相当长的选项列表中选择
三个字母的组合一共有26×26×26=17576个。我们不希望将所有这些组合都存储起来，而是想在用户滚动这些单词的时候，依照请求对它们重新计算。
事实证明，这实现起来很容易。其中比较麻烦的部分，即添加和删除监听器，在我们所继承的AbstractListModel类中已经为我们实现了。我们只需要提供getSize和getElementAt方法便可：
对第n个字符串的计算需要一点技巧，在程序清单6-3中将看到具体实现。
既然我们已经有了一个模型，那么，接下来我们就可以构建一个列表，让用户可以通过滚动来选择该模型所提供的任意元素：
这里的关键是这些字符串从来没有被存储过，而只有那些用户实际要求查看的字符串才会被生成。
我们还必须进行另一项设置。那就是，我们必须告诉列表构件，所有的选项都有一个固定的宽度和高度。最简单的方法就是通过设置单元格的尺寸大小（cell dimension）来设定原型单元格的值（prototype cell value）：
原型单元格的值通常用来确定所有单元格的尺寸（我们使用字符串“www”是因为“w”在大多数字体中都是最宽的小写字母）。另外，可以像下面这样设置一个固定不变的单元格尺寸：
如果你既没有设置原型值也没有设置固定的单元格尺寸，那么列表构件就必须计算每个选项的宽度和高度。这可能需要花费更长时间。
程序清单6-2展示了示例程序的框架类。
从实际情况来看，这种很长的列表没有什么实用价值。让用户滚动浏览一个巨大的选项列表会显得相当得笨重和不便。正因为如此，我们认为这种列表控制设计得有点过火。用户能够在屏幕上舒服操作的选项列表肯定应该足够小，因此，可以直接存储到列表构件中。这种做法可以将编程人员解脱出来，使他们不必把列表模型作为一个单独实体进行处理。另一方面，JList类与Jtree、JTable这两个类也保持了一致，对它们来说，通用性往往会显得很有用。
程序清单6-2　longList/LongListFrame.java
程序清单6-3　longList/WordListModel.java
javax.swing.JList<E>1.2
·JList（ListModel<E>dataModel）
构建一个以指定模型显示其元素的列表。
·E getPrototypeCellValue（）
·void setPrototypeCellValue（E newValue）
获取或设置用于设定列表中每一个单元格宽度和高度的原型单元格值。默认值为null，表示将强制对每一个单元格的尺寸进行测量。
·void setFixedCellWidth（int width）
如果width大于0，则设定列表中每一个单元格的宽度（单位为像素）。默认值为-1，表示将强制对每一个单元格的尺寸进行测量。
·void setFixedCellHeight（int height）
如果height大于0，则设定列表中每一个单元格的高度（单位为像素）。默认值为-1，表示将强制对每一个单元格的尺寸进行测量。
javax.swing.listModel<E>1.2
·int getSize（）
返回该模型中的元素个数。
·E getElementAt（int position）
返回该模型中给定位置上的一个元素。6.1.3　插入和移除值
不能直接编辑列表值的集合。相反地，必须先访问模型，然后再添加或移除元素。不过，说起来容易做起来难。假设想要向列表中添加更多的选项值，那么首先可以通过下面的语句获得对该模型的一个引用：
但是，正如在前一小节中看到的那样，这样做并不能带来任何好处，因为ListModel接口并未提供任何插入或移除元素的方法。毕竟，列表模型的整个重点是它不需要存储任何元素。
让我们试试另一种方法吧。JList有一个构造器可以接受一个对象向量作为参数：
现在，就可以通过编辑这个向量来添加或移除元素了，不过列表并不知道正在发生的事情，因此也就无法对这种变化做出响应。尤其是，当你向列表中添加元素时，列表无法更新它的显示视图。因此，这个构造器也不太实用。
取而代之的是，应该构建一个DefaultListModel对象，填入初始值，然后将它与一个列表关联起来。DefaultListModel类实现了ListModel接口，并管理着一个对象集合。
现在，就可以从model对象中添加或移除元素值了。然后，model对象会告知列表发生了哪些变化，接着，列表会对自身进行重新绘制。
由于历史遗留问题，DefaultListModel类使用的方法名和集合类的方法名并不相同。
默认的列表模型在内部是使用一个向量来存储元素值的。
警告：JList存在着多种构造器方法，可以用一个对象或字符串数组或向量来构建列表。你可能会认为这些构造器是使用一个DefaultListModel来存储这些元素值的。但情况并非如此，这些构造器构建了一个普通而简单的模型，它可以访问元素值，但是如果内容发生了改变，它并不提供任何通知机制。例如，下面这段代码是使用一个Vector来构造JList的构造器的代码：
这意味着，在列表被创建之后，如果要修改向量里面的内容，那么这个列表在被完全重新绘制之前，会将旧值和新值混在一起，杂乱无章地显示出来。（上面构造器中的关键字final并不能阻止你在其他地方对这个向量进行修改，它仅仅表示构造器本身不能修改listData引用的值；一定要有这个关键字是因为listData对象是在内部类中使用的。）
javax.swing.JList<E>1.2
·ListModel<E>getModel（）
获取该列表的模型。
javax.swing.DefaultListModel<E>1.2
·void addElement（E obj）
向该模型的末端添加一个对象。
·boolean removeElement（Object obj）
从模型中移除第一次出现的给定对象。如果该模型中包含此对象，则返回true，否则返回false。6.1.4　值的绘制
到目前为止，我们在本章看到的列表包含的都是字符串。实际上只需传递一个用Icon对象填充的数组或向量，便可以很容易地显示一个图标列表。更有意思的是，可以很容易地用任何图形来表示你的列表值。
尽管JList类可以自动地显示字符串和图标，但是仍然需要在JList对象中安装一个用于所有自定义图形的列表单元格绘制器。列表单元格绘制器可以是任何一个实现了下面接口的类：
这个方法会为每个单元格都调用一次，它返回一个用于绘制单元格内容的构件。无论何时，只要某个单元格需要被绘制，该构件就会被置于合适的位置。
实现单元格绘制器的一种方法是创建一个扩展了JComponent的类，如下所示：
在程序清单6-4中，我们按照字体的实际外观显示这些选择字体（参见图6-4）。在paintComponent方法内部，我们用每种字体显示其自身的名称。我们还需要确保JList类的外观与常用颜色相匹配。通过调用JList类中的getForeground/getBackground和getSelection Foreground/getSelectionBackground方法可以获取这些颜色。在getPreferredSize方法中，我们需要使用在卷I第7章中介绍的技术来测量字符串的大小。
图6-4　具有绘画单元格的列表框
如果要安装单元格绘制器，只需调用setCell Renderer方法即可：
现在，列表中的所有单元格都是按照自定义的方式绘制的了。
实际上，可以用一种更简单的方法来编写在大多情况下都能运行的自定义绘制器。如果绘制的图像仅仅包含文本、图标或者变化颜色，那么通过配置一个JLabel就可以得到这样的一个绘制器。例如，为了用每种字体显示该字体自身的名称，我们可以使用下面的绘制器：
注意，这里没有编写任何paintComponent或getPreferredSize方法；JLabel类早已实现了这些方法，完全能够满足我们的要求。我们要做的全部工作就是通过设置文本、字体以及颜色来恰当地配置标签。
这段代码在某些情形下确实是一个很便利的捷径，因为在这些情形中，有现成的构件——JLabel，它已经提供了绘制单元格值所需的全部功能。
我们在样例程序中使用了JLabel，但是我们给出的是更泛化的代码，这样你就可以在需要在列表单元格中显示任意图形时，通过修改这段代码来实现。
警告：在每一个getListCellRendererComponent调用中都构建一个新的构件并不是一个好主意。因为如果用户滚动了许多个列表项，那么每一次都需要构建一个新构件。而对已有构件进行重配置则显得更安全更高效。
程序清单6-4　listRendering/FontCellRenderer.java
javax.swing.JList<E>1.2
·Color getBackground（）
返回未选定单元格的背景颜色。
·Color getSelectionBackground（）
返回选定单元格的背景颜色。
·Color getForeground（）
返回未选定单元格的前景颜色。
·Color getSelectionForeground（）
返回选定单元格的前景颜色。
·void setCellRenderer（ListCellRenderer<？super E>cellRenderer）
设置用于绘制列表中单元格的绘制器。
javax.swing.ListCellRenderer<E>1.2
·Component getListCellRendererComponent（JList<？extends E>list，E item，int index，boolean isSelected，boolean hasFocus）
返回一个其paint方法用于绘制单元格内容的构件，如果列表的单元格尺寸没有固定，那么该构件还必须实现getPreferredSize。
参数：list　单元格正在被绘制的列表
item　要绘制的选项
index　存储在模型中的选项索引
isSelected　true表示指定的单元格被选定
hasFocus　true表示焦点在指定的单元格上6.2　表格
JTable构件用于显示二维对象表格。当然，表格在用户界面中很常见。Swing开发小组将大量的精力投入到了表格控制方面。表格本身比较复杂，但是它可能比其他Swing类更为成功，因为JTable构件隐藏了更多的复杂性。只需编写几行代码就能够产生具有完全功能化的、行为丰富的表格。当然，还可以编写更多的代码，为具体应用定制显示外观和运行特性。
在本节中，我们将着重讲解怎样产生简单表格，用户怎样与它们交互，以及怎样进行一些最常见的调整操作。与其他一些复杂的Swing构件一样，我们不可能覆盖所有的细节。如果想获得详细信息，请查阅David M.Geary撰写的《Graphic Java》（第3版）或Kim Topley撰写的《Core Swing》。6.2.1　简单表格
与JList构件类似，JTable并不存储它自己的数据，而是从一个表格模型中获取它的数据。JTable类有一个构造器能够将一个二维对象数组包装进一个默认的模型。这也正是我们第一个示例程序要用到的策略。在本章的后续部分，我们将转向介绍表格模型。
图6-5展示了一个典型的表格，用于描述太阳系各个行星的属性。（如果一个行星主要由氢气和氦气组成，那么它就是气态行星。对于“Color”项，你应该了解其巨大的作用，我们之所以将它添加为一列是因为在后面的示例代码中，它是很有用的。）
图6-5　简单表格
正如你在程序清单6-5中见到的那样，表格中的数据是以Object值的二维数组的形式存储的：
注意：这里，我们充分利用了自动装箱。第二列、第三列、第四列中的项会自动转换成类型为Double、Integer和Boolean的对象。
该表格直接调用每个对象上的toString方法来显示它们，这也正是为什么颜色显示成为java.awt.Color[r=...，g=...，b=...]的原因所在。
可以用一个单独的字符串数组来提供列名：
接着，就可以从单元格和列名数组中构建一个表格：
最后，通过将表格包装到一个JScrollPane中这个常用方法来添加滚动条：
注意：JTable与JList不同，它并非泛型。这么做是有原因的，列表中的元素总是具有统一类型的，但是，通常整个表格不会只有单一的元素类型。例如，在我们的示例中，行星名是字符串，颜色是java.awt.Color对象。
这样产生的表格已经具有令人吃惊的丰富行为特性了。可以垂直调整表格的尺寸大小直到滚动条显现出来，然后滚动表格。请注意，列表头并不会滑出视图的外面。
接着，单击列表头的某一列，并且向左或向右拖拉。看看整个列是怎样移开的（参见图6-6），你可以将它放到别的位置上。这种列的重新排列只是视图上的重新排列，对数据模型没有任何影响。
如果要调整列的尺寸大小，只需将鼠标移到两列之间，直到鼠标的形状变成箭头为止，然后将列的边界拖移到你期望的位置上（参见图6-7）。
图6-6　移动表格中的一列
图6-7　调整列的尺寸大小
用户可以通过点击行中任何一个地方来选中一行，而选中的行会高亮显示，后面将会介绍怎样获取这些选择事件。通过单击一个单元格并键入数据，用户还可以编辑表格中的各个项。不过，在这个代码示例中，这些编辑并没有改变底层的数据。在程序中，你应该要么使这些单元格不可编辑，要么处理单元格编辑事件并更新你的模型。我们将会在本节的后面对这些问题进行讨论。
最后，点击列的头，行就会自动排序。如果再次点击，排序顺序就会反过来。这个行为是通过下面的调用激活的：
可以使用下面的调用对表格进行打印：
此时会出现一个打印对话框，并将表格传送给打印机。我们将在第7章讨论定制打印选项。
注意：如果调整TableTest框架的尺寸，使它的高度超过了表的高度，那么就会看到表的下方有一块灰色区域。与JList和JTree构件不同，表没有填充滚动面板视图。当希望支持拖拽时，这可能会成为一个问题（关于拖拽的更多信息，请查看第7章）。在这种情况下，可以调用
程序清单6-5　table/TableTest.java
javax.swing.JTable 1.2
·JTable（Object[][]entries，Object[]columnNames）
用默认的表格模型构建一个表格。
·void print（）5.0
显示打印对话框，并打印该表格。
·boolean getAutoCreateRowSorter（）6
·void setAutoCreateRowSorter（boolean newValue）6
获取或设置autoCreateRowSorter属性，默认值为false。如果进行了设置，只要模型发生变化，就会自动设置一个默认的行排序器。
·boolean getFillsViewportHeight（）6
·void setFillsViewportHeight（boolean newValue）6
获取或设置fillsViewportHeight属性，默认值为false。如果进行了设置，该表格就总是会填充其外围的视图。6.2.2　表格模型
在上一个示例中，表格数据是存储在一个二维数组中的。不过，通常不应该在自己的代码中使用这种策略。如果你发现自己在将数据装入一个数组中，然后作为一个表格显示出来，那么就应该考虑实现自己的表格模型了。
表格模型实现起来特别简单，因为你可以充分利用AbstractTableModel类，它实现了大部分必需的方法。你仅仅需要提供下面三个方法便可：
实现getValueAt方法有多种途径。例如，如果你想显示包含数据库查询结果的RowSet的内容，只需提供下面的方法：
我们的示例程序相当简单，我们构建了一个只是用来显示某些计算结果的表格，这些计算结果也就是在不同利率条件下的投资增长额（参见图6-8）。
图6-8　一个投资增长额表格
getValueAt方法计算出正确值，并将其格式化：
getrowCount和getColumnCount方法只是返回行数和列数。
如果不提供列名，那么AbstractTableModel的getColumnName方法会将列命名为A、B、C等。如果要改变列名，请覆盖getColumnName方法。通常需要覆盖默认的行为。在这个示例中，我们只是将每列用利率标识了出来。
程序清单6-6中显示了完整的源代码。
程序清单6-6　tableModel/InvestmentTable.java
javax.swing.table.TableModel 1.2
·int getRowCount（）
·int getColumnCount（）
获取表模型中的行和列的数量。
·Object getValueAt（int row，int column）
获取在给定的行和列所确定的位置处的值。
·void setValueAt（Object newValue，int row，int column）
设置在给定的行和列所确定的位置处的值。
·boolean isCellEditable（int row，int column）
如果在给定的行和列所确定的位置处的值是可编辑的，则返回true。
·String getColumnName（int column）
获取列的名字。6.2.3　对行和列的操作
在本小节中，你会看到怎样操作一个表格中的行和列。在你阅读本材料的整个过程中，要牢记Swing中的表格是相当不对称的，也就是你可以实施的行操作和列操作会有所不同。表格构件已经被优化过，以便能够显示具有相同结构的行信息，例如，一次数据库查询的结果，而不是任意的二维对象表格。你将会看到，这种不对称性贯穿于本小节。
1.各种列类
在下一个示例中，我们将再次展示行星数据，不过这次我们会给出更多的有关表格列类型的信息。这是通过在表格模型中定义下面这个方法来实现的：
这个方法可以返回一个描述列类型的类。
JTable类会为该类选取合适的绘制器，表6-1显示了默认的绘制动作。
表6-1　默认的绘制操作
可以在图6-9中看到复选框和图像。（感谢Jim Evins提供了这些行星图像，网址为：http://www.snaught.com/JimsCoolIcons/Planets。）
要绘制其他类型，需要安装定制的绘制器，请参见第6.2.4节。
2.访问表格列
JTable类将有关表格列的信息存放在类型为TableColumn的对象中，由一个TableColumnModel对象负责管理这些列。（图6-10展示了最重要的表格类之间的关系。）如果不想动态地插入或删除，那么最好不要过多地使用表格列模型。列模型最常见的用法是直接获取一个TableColumn对象：
图6-9　具有单元格绘制器的表格
图6-10　表格类之间的关系图
3.改变列的大小
TableColumn类可以控制更改列的大小的行为。使用下面这些方法，可以设置首选的、最小的以及最大的宽度：
这些信息将提供给表格构件，以便对列进行布局。
使用方法
可以控制是否允许用户改变列的大小。
可以使用下面这个方法在程序中改变列的大小：
当调整了一个列的大小时，默认情况下表格的总体大小会保持不变。当然，更改过大小的列的宽度的增加值或减小值会分摊到其他列上。默认方式是更改那些在被改变大小列右边的所有列的大小。这是一种很好的默认方式，因为这样使得用户可以通过将所有列从左到右移动，将它们调整为自己所期望的宽度。
使用下面这个方法，可以设置表6-2中列出的其他行为：
表6-2　变更列大小的模式
4.改变行的大小
行的高度是直接由JTable类管理的。如果单元格比默认值高，那么可以像下面这样设置行的高度：
默认情况下，表格中的所有行都具有相同的高度，可以用下面的调用来为每一行单独设置高度：
实际的行高度等于用这些方法设置的行高度减去行边距，其中行边距的默认值是1个像素，但是可以通过下面的调用来修改它：
5.选择行、列和单元格
利用不同的选择模式，用户可以分别选择表格中的行、列或者单独的单元格。默认情况下，可能的是行选择，点击一个单元格的内部就可以选择整行（参见图6-9）。调用
可以禁用行选择。
当行选择功能可用时，可以控制用户是否可以选择单一行、连续几行或者任意几行。此时，需要获取选择模式，然后调用它的setSelectionMode方法：
在这里，mode是下面三个值的其中一个：
默认情况下，列选择是禁用的。不过可以调用下面这个方法启用列选择：
同时启用行选择和列选择等价于使单元格选择可用，这样用户就可以选择一定范围内的单元格（参见图6-11）。也可以使用下面的调用完成这项设置：
可以运行程序清单6-7中的程序，观察一下单元格选择的运行情况。启用Selection菜单中的行、列或单元格选项，然后观察选择行为是如何改变的。
图6-11　选择一个单元格范围
可以通过调用getSelectedRows方法和getSelectedColumns方法来查看选中了哪些行及哪些列。这两个方法都返回一个由被选定项的索引构成的int[]数组。注意，这些索引值是表格视图中的索引值，而不是底层表格模型中的索引值。尝试着选择一些行和列，然后将列拖拽到不同的位置，并通过点击列头来对这些行进行排序。使用Print Selection菜单项来查看它会报告哪些行和列被选中。
如果要将表格索引值转译为表格模型索引值，可以使用JTable的ConvertRowIndexToMode1和convertColumnIndexToModel方法。
6.对行排序
正如在第一个表格示例中看到的那样，向JTable中添加行排序机制是很容易的，只需调用setAutoCreateRowSorter方法。但是，要对排序行为进行细粒度的控制，就必须像JTable中安装一个TableRowSorter<M>对象，并对其进行定制化。类型参数M表示表格模型，它必须是TableModel接口的子类型。
某些列是不可排序的，例如，在我们的行星数据中的图像列，可以通过下面的调用来关闭排序机制：
可以对每个列都安装一个定制的比较器。在我们的示例中，我们将对Color列中的颜色进行排序，因为我们相对于红色来说，更喜欢蓝色和绿色。当你点击Color列时，将会看到蓝色行星出现在表格底部，这是通过下面的调用完成的：
如果不指定列的比较器，那么排序顺序就是按照下面的原则确定的：
1）如果列所属的类是String，就使用Collator.getInstance（）方法返回的默认比较器。它按照适用于当前locale的方式对字符串排序。（参见第5章以了解locale和比较器的更多信息）。
2）如果列所属的类型实现了Comparable，则使用它的compareTo方法。
3）如果已经为比较器设置过TableStringConverter，就用默认比较器对转换器的toString方法返回的字符串进行排序。如果要使用该方法，可以像下面这样定义转换器：
4）否则，在单元格的值上调用toString方法，然后用默认比较器对它们进行比较。
7.过滤行
除了可以对行排序之外，TableRowSorter还可以有选择性地隐藏行，这种处理称为过滤（filtering）。要想激活过滤机制，需要设置RowFilter。例如，要包含至少有一个卫星的所有行星行，可以调用：
这里我们使用了预定义的过滤器，即数字过滤器。要构建数字过滤器，需要提供：
·比较类型（EQUAL、NOT_EQUAL、AFTER和BEFORE之一）。
·Number的某个子类的一个对象（例如Integer和Double），只有与给定的Number对象属于相同的类的对象才在考虑的范围内。
·0或多列的索引值，如果不提供任何索引值，那么所有的列都被搜索。
静态的RowFilter.dataFilter方法以相同的方式构建了日期过滤器，这里需要提供Date对象而不是Number对象。
最后，静态的RowFilter.regexFilter方法构建的过滤器可以查找匹配某个正则表达式的字符串。例如：
将只显示那些名字以“s”结尾的行星（参见第1章以了解有关正则表达式的更新信息）。
还可以用andFilter、orFilter和notFilter方法来组合过滤器，例如，要过滤掉名字不是以“s”结尾，并且至少有一颗卫星的行星，可以使用下面的过滤器组合：
警告：令人恼火的是，andFilter和orFilter方法未使用可变参数，而是单个的类型为Iterable的参数。
要实现自己的过滤器，需要提供RowFilter的一个子类，并实现include方法来表示哪些行应该显示。这很容易实现，但是RowFilter类卓越的普适性令它有点可怕。
RowFilter<M，I>类有两个类型参数：模型的类型和行标识符的类型。在处理表格时，模型总是TableModel的某个子类型，而标识符类型总是Integer。（在将来的某个时刻，其他构件可能也会支持行过滤机制。例如，要过滤JTree中的行，就可能可以使用RowFilter<TreeModel，TreePath>了。）
行过滤器必须实现下面的方法：
RowFilter.Entry类提供了获取模型、行标识符和给定索引处的值等内容的方法，因此，按照行标识符和行的内容都可以进行过滤。
例如，下面的过滤器将隔行显示：
如果想要只包含那些具有偶数个卫星的行星，可以将上面的测试条件替换为下面的内容：
在我们的示例程序中，允许用户隐藏任意多行，我们在一个set中存储了所有隐藏的行的索引。而其中的行过滤器将包含那些索引不在这个set中的所有行。
过滤机制并不是为那些过滤标准在不时地发生变化的过滤器而设计的。因此，在我们的示例程序中，只要隐藏行的set发生了变化，我们就会调用下面的语句：
过滤器一旦被设置，就会立即得到应用。
8.隐藏和显示列
正如在前一节中看到的，可以根据内容或标识符来过滤表格行，而隐藏表格列使用的是完全不同的机制。
JTable类的removeColumn方法可以将一列从表格视图中移除。该列的数据实际上并没有从模型中移除，它们只是在视图中被隐藏了起来。removeColumn方法接受一个TableColumn参数，如果你有的是一个列号（比如来自于getSelectedColumns的调用结果），那就需要向表格模型请求实际的列对象：
如果你记得住该列，那么将来就可以再把它添加回去：
该方法将该列添加到表格的最后面。如果想让它出现在表格中的其他任何地方，那么可以调用moveColumn方法。
通过添加一个新的TableColumn对象，还可以添加一个对应于表格模型中的一个列索引的新列：
可以让多个表格列展示模型中的同一列。
程序清单6-7中的程序展示了如何选择和过滤行与列。
程序清单6-7　tableRowColumn/planetTableFrame.java
javax.swing.table.TableModel 1.2
·Class getColumnClass（int columnIndex）
获取该列中的值的类。该信息用于排序或绘制。
javax.swing.JTable 1.2
·TableColumnModel getColumnModel（）
获取描述表格列布局安排的“列模式”。
·void setAutoResizeMode（int mode）
设置自动更改表格列大小的模式。
参数：mode　AUTO_RESIZE_OFF、AUTO_RESIZE_NEXT_COLUMN、AUTO_RESIZE_SUBSEQUENT_COLUMNS、AUTO_RESIZE_LAST_COLUMN以及AUTO_RESIZE_ALL_COLUMNS其中之一
·int getRowMargin（）
·void setRowMargin（int margin）
获取和设置相邻行中单元格之间的间隔大小。
·int getRowHeight（）
·void setRowHeight（int height）
获取和设置表格中所有行的默认高度。
·int getRowHeight（int row）
·void setRowHeight（int row，int height）
获取和设置表格中给定行的高度。
·ListSelectionModel getSelectionModel（）
返回列表的选择模式。你需要该模式以便在行、列以及单元格之间进行选择。
·boolean getRowSelectionAllowed（）
·void setRowSelectionAllowed（boolean b）
获取和设置rowSelectionAllowed属性。如果为true，那么当用户点击单元格的时候，可以选定行。
·boolean getColumnSelectionAllowed（）
·void setColumnSelectionAllowed（boolean b）
获取和设置columnSelectionAllowed属性。如果为true，那么当用户点击单元格的时候，可以选定列。
·boolean getCellSelectionEnabled（）
如果既允许选定行又允许选定列，则返回true。
·void setCellSelectionEnabled（boolean b）
同时将rowSelectionAllowed和columnSelectionAllowed设置为b。
·void addColumn（TableColumn column）
向表格视图中添加一列作为最后一列。
·void moveColumn（int from，int to）
移动表格from索引位置中的列，使它的索引变成to。该操作仅仅影响到视图。
·void removeColumn（TableColumn column）
将给定的列从视图中移除。
·int convertRowIndexToModel（int index）6
·int convertColumnIndexToModel（int index）
返回具有给定索引的行或列的模型索引，这个值与行被排序和过滤，以及列被移动和移除时的索引不同。
·void setRowSorter（RowSorter<？extends TableModel>sorter）
设置行排序器。
javax.swing.table.TableColumnModel 1.2
·TableColumn getColumn（int index）
获取表格的列对象，用于描述给定索引的列。
javax.swing.table.TableColumn 1.2
·TableColumn（int modelColumnIndex）
构建一个表格列，用以显示给定索引位置上的模型列。
·void setPreferredWidth（int width）
·void setMinWidth（int width）
·void setMaxWidth（int width）
将表格的首选宽度、最小宽度以及最大宽度设置为width。
·void setWidth（int width）
设置该列的实际宽度为width。
·void setResizable（boolean b）
如果b为true，那么该列可以更改大小。
javax.swing.ListSelectionModel 1.2
·void setSelectionMode（int mode）
参数：mode　SINGLE_SELECTION、SINGLE_INTERVAL_SELECTION以及MULTIPLE_INTERVAL_SELECTION其中之一
javax.swing.DefaultRowSorter<M，I>6
·void setComparator（int column，Comparator<？>comparator）
设置用于给定列的比较器。
·void setSortable（int column，boolean enabled）
使对给定列的排序可用或禁用。
·void setRowFilter（RowFilter<？super M，？super I>filter）
设置行过滤器。
javax.swing.table.TableRowSorter<M extends TableModel>6
·void setStringConverter（TableStringConverter stringConverter）
设置用于排序和过滤的字符串转换器。
javax.swing.table.TableStringConverter<M extends TableModel>6
·abstract String toString（TableModel model，int row，int column）
将给定位置的模型值转换为字符串，你可以覆盖这个方法。
javax.swing.RowFilter<M，I>6
·boolean include（RowFilter.Entry<？extends M，？extends I>entry）
指定要保留的行，你可以覆盖这个方法。
·static<M，I>RowFilter<M，I>numberFilter（RowFilter.ComparisonType type，Number number，int...indices）
·static<M，I>RowFilter<M，I>dateFilter（RowFilter.ComparisonType type，Date date，int...indices）
返回一个过滤器，它包含的行是那些与给定的数字或日期进行给定比较后匹配的行。比较类型是EQUAL、NOT_EQUAL、AFTER或BEFORE之一。如果给定了列模型索引，则只搜索这些列。否则，将搜索所有列。对于数字过滤器，单元格的值所属的类必须与给定数字的类匹配。
·static<M，I>RowFilter<M，I>regexFilter（String regex，int...indices）返回一个过滤器，它包含的行含有与给定的正则表达式匹配的字符串。如果给定了列模型索引，则只搜索这些列。否则，将搜索所有列。注意，RowFilter.Entry的getStringValue方法返回的字符串是匹配的。
·static<M，I>RowFilter<M，I>andFilter（Iterable<？extends RowFilter<？super M，？super I>>filters）
·static<M，I>RowFilter<M，I>orFilter（Iterable<？extends RowFilter<？super M，？super I>>filters）
返回一个过滤器，它包含的项是那些包含在所有的过滤器或至少包含在一个过滤器中的项
·static<M，I>RowFilter<M，I>notFilter（RowFilter<M，I>filter）
返回一个过滤器，它包含的项是那些不包含在给定过滤器中的项。
javax.swing.RowFilter.Entry<M，I>6
·I getIdentifier（）
返回这个行的标识符。
·M getModel（）
返回这个行的模型。
·Object getValue（int index）
返回在这个行的给定索引处存储的值。
·int getValueCount（）
返回在这个行中存储的值的数量。
·String getStringValue（）
返回在这个行的给定索引处存储的值转换成的字符串。由TableRowSorter产生的项的getStringValue方法会调用排序器的字符串转换器。6.2.4　单元格的绘制和编辑
正如在第6.2.3节中看到的，列的类型确定了单元格应该如何绘制。Boolean和Icon类型有默认的绘制器，它们将绘制复选框或图标，而对于其他所有类型，都需要安装定制的绘制器。
表格的单元格绘制器与你在前面看到的列表单元格绘制器类似。它们都实现了TableCell Renderer接口，并只有一个方法
该方法在表格需要绘制一个单元格的时候被调用。它会返回一个构件，接着该构件的paint方法会被调用，以填充单元格区域。
在图6-12中的表格包含类型为Color的单元格，绘制器直接返回一个面板，其背景颜色设置为存储在该单元格中的颜色对象，该颜色是作为value参数传递的。
正如你看到的那样，当该单元格获得焦点的时候，绘制器会安装一个边框。（我们可以向UIManager寻求合适的边框。为了发现查找的关键所在，我们可以深入DefaultTableCell Renderer类的源码内部看个究竟。）
通常情况下，你可能还想设置单元格的背景颜色，以指示当前是否选中了它。这里我们跳过这步，因为这会干扰我们现在讨论的显示颜色。程序清单6-4中的ListRenderingTest示例展示了怎样在一个绘制器中指示选择状态。
提示：如果你的绘制器只是绘制一个文本字符串或者一个图标，那么可以继承DefaultTableCellRenderer这个类。该类会负责绘制焦点和选择状态。
图6-12　具有单元格绘制器的表格
你必须告诉表格要使用这个绘制器去绘制所有类型为Color的对象。JTable类的setDefaultRenderer方法可以让你建立它们之间的这种联系。你需要提供一个Class对象和绘制器。
现在这个绘制器就可以用于表格中具有给定类型的所有对象了。
如果想要基于其他标准选择绘制器，则需要从JTable类中扩展子类，并覆盖getCellRender方法。
1.绘制表头
为了在表头中显示图标，需要设置表头值。
然而，表头还未智能到可以为表头值选择一个合适的绘制器，因此，绘制器需要手工安装。例如，要在列头显示图像图标，可以调用：
2.单元格编辑
为了使单元格可编辑，表格模型必须通过定义isCellEditable方法来指明哪些单元格是可编辑的。最常见的情况是，你可能想使某几列可编辑。在这个示例程序中，我们允许对表格中的四列进行编辑。
注意：AbstractTableModel定义的isCellEditable方法总是返回false。DefaultTable Model覆盖了该方法以便总是返回true。
运行一下程序清单6-8到程序清单6-11的程序就会注意到，可以点击Gaseous列中的复选框，并能选中或取消复选标记。如果点击Moons列中的某个单元格，就会出现一个组合框（参见图6-13）。你很快就会看到怎样将这样一个组合框作为一个单元格编辑器安装到表格上。
图6-13　单元格编辑器
最后，点击第一列中的某个单元格，该单元格就会获取焦点。你就可以开始键入数据，而该单元格的内容也会随之更改。
你刚刚看到的是DefaultCellEditor类的三种变型。DefaultCellEditor可以用JTextField、JCheckBox或者JComboBox来构造。JTable类会自动为Boolean类型的单元格安装一个复选框编辑器，并为所有可编辑的、但未提供它们自己的绘制器的单元格安装一个文本编辑器。文本框可以让用户去编辑那些对表格模型getValueAt方法的返回值执行toString操作而产生的字符串。
一旦编辑完成，通过调用编辑器的getCellEditorValue方法就可以读取编辑过的值。该方法应该返回一个正确类型的值（也就是模型的getColumnType方法返回的类型）。
为了获得一个组合框编辑器，你需要手动设置单元格编辑器，因为JTable构件并不知道什么样的值对某一特殊类型来说是适合的。对于Moons列来说，我们希望可以让用户选择0~20的任何值。下面是对组合框进行初始化的代码。
为了构造一个DefaultCellEditor，需要在该构造器中提供一个组合框。
接下来，我们需要安装这个编辑器。与颜色单元格绘制器不同，这个编辑器不依赖于对象类型，我们未必想要把它作用于类型为Integer的所有对象上。相反地，我们需要把它安装到一个特定列中：
3.定制编辑器
再次运行一下示例程序并点击一种颜色。这时会弹出一个颜色选择器让你为行星选择一种新颜色。选中一种颜色，然后点击OK。单元格颜色就会随之更新（参见图6-14）。
图6-14　使用颜色选择器对单元格的颜色进行编辑
颜色单元格编辑器并不是一种标准的表格单元格编辑器，而是一种定制实现的编辑器。为了创建一个定制的单元格编辑器，需要实现TableCellEditor接口。这个接口有点拖沓冗长，从Java SE 1.3开始，提供了AbstractCellEditor类，用于负责事件处理的细节。
TableCellEditor接口的getTableCellEditorComponent方法请求某个构件去绘制单元格。除了没有focus参数之外，它和TableCellRenderer接口的getTableCellRendererComponent方法极为相似。因为我们要编辑单元格，所以我们假设它具有焦点。在编辑过程中，编辑器构件暂时取代绘制器。在我们的示例中，我们返回的是一个没有颜色的空面板。这只是告诉用户该单元格正在被编辑。
接下来，当用户点击单元格时，你希望能弹出你自己的编辑器。
JTable类用一个事件（例如鼠标点击）去调用你的编辑器，以便确定该事件是否可以被接受去启动编辑过程。AbstractCellEditor将该方法定义为能够接收所有的事件类型。
然而，如果你将该方法覆盖成false，那么表格模型就不会遇到插入编辑器构件这样的麻烦了。
一旦安装了编辑器构件，假设我们使用的是相同的事件，那么shouldSelectCell方法就会被调用。应该在这个方法中启动编辑过程，例如，弹出一个外部的编辑对话框。
如果用户取消编辑，表格会调用cancelCellEditing方法。如果用户已经点击了另一个表格单元，那么表格会调用stopCellEditing方法。在这两种情况中，你都应该将对话框隐藏起来。当stopCellEditing方法被调用时，表格可能会使用被部分编辑的值。如果当前值有效，那么应该返回true。在颜色选择器中，任何值都是有效的。但是如果编辑的是其他数据，那么应该保证只有有效的数据才能从编辑器中读取出来。
另外，应该调用超类的方法，以便进行事件的触发，否则，编辑事件就无法正确地撤销。
最后，必须提供一个方法，以便产生用户在编辑过程中所提供的值。
总结一下，你的定制编辑器应该遵循下面几点：
1）继承AbstractCellEditor类，并实现TableCellEditor接口。
2）定义getTableCellEditorComponent方法以提供一个构件。它可以是一个哑构件（如果你弹出一个对话框）或者是适当的编辑构件，例如复选框或文本框。
3）定义shouldSelectCell、stopCellEditing及cancelCellEditing方法，来处理编辑过程的启动、完成以及撤销。stopCellEditing和cancelCellEditing方法应该调用超类方法以保证监听器能够接收到通知。
4）定义getCellEditorValue方法返回编辑结果的值。
最后，通过调用stopCellEditing和cancelCellEditing方法，以表明用户什么时间完成了编辑操作。在构建颜色对话框的时候，我们安装了接受和取消的回调，用于触发这些事件。
这样就完成了定制编辑器的实现过程。
你现在已经知道了怎样使一个单元格可编辑，以及怎样安装一个编辑器。还剩下一个问题，即怎样使用用户编辑过的值来更新表格模型。当编辑完成的时候，JTable类会调用表格模型的下面这个方法：
需要将这个方法覆盖掉以便存储新值。value参数是单元格编辑器返回的对象。如果实现了单元格编辑器，那么你就知道从getCellEditorValue方法返回的是什么类型的对象。在DefaultCellEditor这种情况中，这个值有三种可能：如果单元格编辑器是复选框，那么它就是Boolean值；如果是一个文本框，那么它就是一个字符串；如果这个值来源于组合框，那么就是用户选定的对象。
如果value对象不具有合适的类型，那么需要对它进行转换。例如，在一个文本框中编辑一个数字，这种情况最常发生。在我们的示例中，我们是将组合框组装成了Integer对象，所以不需要任何转换。
程序清单6-8　tableCellRender/TableCellRenderFrame.java
程序清单6-9　tableCellRender/PlanetTableModel.java
程序清单6-10　tableCellRender/ColorTableCellRenderer.java
程序清单6-11　tableCellRender/ColorTableCellEditor.java
javax.swing.JTable 1.2
·TableCellRenderer getDefaultRenderer（Class<？>type）
获取给定类型的默认绘制器。
·TableCellEditor getDefaultEditor（Class<？>type）
获取给定类型的默认编辑器。
javax.swing.table.TableCellRenderer 1.2
·Component getTableCellRendererComponent（JTable table，Object value，boolean selected，boolean hasFocus，int row，int column）
返回一个构件，它的paint方法将被调用以便绘制一个表格单元格。
参数：table　该表格包含要绘制的单元格
value　要绘制的单元格
selected　如果该单元格当前已被选中，则为true
hasFocus　如果该单元格当前具有焦点，则为true
row，column　单元格的行及列
javax.swing.table.TableColumn 1.2
·void setCellEditor（TableCellEditor editor）
·void setCellRenderer（TableCellRenderer renderer）
为该列中的所有单元格设置单元格编辑器或绘制器。
·void setHeaderRenderer（TableCellRenderer renderer）
为该列中的所有表头单元格设置单元格绘制器。
·void setHeaderValue（Object value）
为该列中的表头设置用于显示的值。
javax.swing.DefaultCellEditor 1.2
·DefaultCellEditor（JComboBox comboBox）
构建一个单元格编辑器，并以一个组合框的形式显示出来，用于选择单元格的值。
javax.swing.table.TableCellEditor 1.2
·Component getTableCellEditorComponent（JTable table，Object value，boolean selected，int row，int column）
paint方法用于绘制表格的单元格。
参数：table　包含要绘制的单元格的表格
value　要绘制的单元格
selected　如果该单元格已被当前选中，则为true
row，colum　单元格的行及列
javax.swing.CellEditor 1.2
·boolean isCellEditable（EventObject event）
如果该事件能够启动对该单元格的编辑过程，那么返回true。
·boolean shouldSelectCell（EventObject anEvent）
启动编辑过程。如果被编辑的单元格应该被选中，则返回true。通常情况下，你希望返回的是true，不过，如果你不希望在编辑过程中改变单元格被选中的情况，那么你可以返回false。
·void cancelCellEditing（）
取消编辑过程。你可以放弃已进行了部分编辑的操作。
·boolean stopCellEditing（）
出于使用编辑结果的目的，停止编辑过程。如果被编辑的值对读取来说处于适合的状态，则返回true。
·Object getCellEditorValue（）
返回编辑结果。
·void addCellEditorListener（CellEditorListener l）
·void removeCellEditorListener（CellEditorListener l）
添加或移除必需的单元格编辑器的监听器。6.3　树
每个使用过分层结构的文件系统的计算机用户都见过树状显示。当然，目录和文件形式仅仅是树状组织结构中的一种。日常生活中还有很多这样的树结构，例如国家、州以及城市之间的层次结构，如图6-15所示。
作为一名编程人员，我们经常需要显示这些树型结构。幸运的是，Swing类库中有一个正是用于此目的的JTree类。JTree类（以及它的辅助类）负责布局树状结构，按照用户请求展开或折叠树的节点。在本节中，我们将介绍怎样使用JTree类。
与其他复杂的Swing构件一样，我们必须集中介绍一些常用方法，无法涉及所有的细节。如果读者想获得与众不同的效果，我们推荐你参考David M.Geary撰写的《Graphic Java 3》（第3版），Kim Topley编写的《Core Swing》。
在我们深入展开之前，先介绍一些术语（参见图6-16）。一棵树由一些节点（node）组成。每个节点要么是叶节点（leaf）要么是有孩子节点（child node）的节点。除了根节点（root node），每一个节点都有一个惟一的父节点（parent node）。一棵树只有一个根节点。有时，你可能有一个树的集合，其中每棵树都有自己的根节点。这样的集合称作森林（forest）。
图6-15　国家、州及城市的层次结构
图6-16　树中的术语6.3.1　简单的树
在第一个示例程序中，我们仅仅展示了一个具有几个节点的树（参见图6-18）。如同大多数Swing构件一样，只要提供一个数据模型，构件就可以将它显示出来。为了构建JTree，需要在构造器中提供这样一个树模型：
注意：还有一些构造器可以用一些元素的集合来构建树。
这些构造器不是特别有用。它们仅仅是创建出一个包含了若干棵树的森林，其中每棵树只有一个节点。第三个构造器显得特别没用，因为这些节点实际的显示次序是由键的散列码确定的。
怎样才能获得一个树模型呢？可以通过创建一个实现了TreeModel接口的类来构建自己的树模型。在本章的后面部分，将会介绍应该如何实现。现在，我们仍坚持使用Swing类库提供的DefaultTreeModel模型。
为了构建一个默认的树模型，必须提供一个根节点。
TreeNode是另外一个接口。可以将任何实现了这个接口的类的对象组类到默认的树模型中。这里，我们使用的是Swing提供的具体节点类，叫做DefaultMutableTreeNode。这个类实现了MutableTreeNode接口，该接口是TreeNode的一个子接口（参见图6-17）。
图6-17　有关树的类
任何一个默认的可变树节点都存放一个对象，即用户对象（user object）。树会为所有的节点绘制这些用户对象。除非指定一个绘制器，否则树将直接显示执行完toString方法之后的结果字符串。
在第一个示例程序中，我们使用了字符串作为用户对象。实际应用中，通常会在树中组装更具表现力的用户对象。例如，当显示一个目录树时，将File对象用于节点将具有实际意义。
可以在构造器中设定用户对象，也可以稍后在setUserObject方法中设定用户对象：
接下来，可以建立节点之间的父/子关系。从根节点开始，使用add方法来添加子节点：
图6-18显示了这棵树的外观。
图6-18　一棵简单的树
按照这种方式将所有的节点链接起来。然后用根节点构建一个DefaultTreeModel。最后，用这个树模型构建一个Jtree。
或者，使用快捷方式，直接将根节点传递给Jtree构造器。那么这棵树就会自动构建一个默认的树模型：
程序清单6-12给出了完整的代码。
程序清单6-12　tree/SimpleTreeFrame.java
运行这段程序代码时，最初的树外观如图6-19所示。只有根节点和它的子节点可见。单击圆圈图标（把手）展开子树。当子树折叠起来时，把手图标的线伸出指向右边，当子树展开时，把手图标的线伸出指向下方（参见图6-20）。虽然我们无法得知Metal外观的设计者当时是如何构想的，但是我们可以将这个图标看作一个门把手，按下把手就可以打开子树。
图6-19　最初的树的显示
图6-20　折叠和展开后的子树
注意：当然，树的显示还依赖于所选择的外观模式。我们这里只讨论Metal这种外观模式。在Windows或Motif外观模式中，把手则具有我们更熟悉的外观，即带有“-”或“+”的框结构（参见图6-21）。
可以使用下面这句神奇的代码撤销父子节点之间的连接线（参见图6-22）：
相反地，如果要确保显示这些线条，则可以使用：
另一种线条样式，“水平线”，如图6-23所示。这棵树显示有水平线，而这些水平线只是用来将根节点的孩子节点分离开来。我们很难说清这样做的好处。
默认情况下，这种树中的根节点没有用于折叠的把手。如果需要的话，可以通过下面的调用来添加一个把手：
图6-24显示了调用后的结果。现在你就可以将整棵树折叠到根节点中了。
图6-21　一棵具有Windows外观的树
图6-22　不带连接线的树
图6-23　具有水平线样式的树
图6-24　具有一个跟把手的树
相反地，也可以将根节点完全隐藏起来。这样做只是为了显示一个森林，即一个树集，每棵树都有它自己的根节点。但是仍然必须将森林中的所有树都放到一个公共节点下。因此，可以使用下面这条指令将根节点隐藏起来。
请观察图6-25。它看起来似乎有两个根节点，分别用“USA”和“Germany”标识了出来，而实际上将二者合并起来的根节点是不可见的。
图6-25　一个森林
让我们将注意力从树的根节点转移到叶节点。注意，这些叶节点的图标和其他节点的图标是不同的（参见图6-26）。
图6-26　叶节点和折叠节点的图标
在显示这棵树的时候，每个节点都绘有一个图标。实际上一共有三种图标：叶节点图标、展开的非叶节点图标以及闭合的非叶节点图标。为了简化起见，我们将后面两种图标称为文件夹图标。
节点绘制器必须知道每个节点要使用什么样的图标。默认情况下，这个决策过程是这样的：如果某个节点的isLeaf方法返回的是true，那么就使用叶节点图标，否则，使用文件夹图标。
如果某个节点没有任何儿子节点，那么DefaultMutableTreeNode类的isLeaf方法将返回true。因此，具有儿子节点的节点使用文件夹图标，没有儿子节点的节点使用叶节点图标。
有时，这种做法并不合适。假设我们要向我们那棵简单的树中添加一个“Montana”节点，但是我们还不知道要添加什么城市。此时，我们并不希望一个州节点使用叶节点图标，因为从概念上来讲，只有城市才使用叶节点。
JTree类无法知道哪些节点是叶节点，它要询问树模型。如果一个没有任何子节点的节点不应该自动地被设置为概念上的叶节点，那么可以让树模型对这些叶节点使用一个不同的标准，即可以查询“允许有子节点“的节点属性。
对于那些不应该有子节点的节点，调用
然后，告诉树模型去查询“允许有子节点”的属性值以确定一个节点是否应该显示成叶子图标。你可以使用DefaultTreeModel类中的方法setAsksAllowsChildren设定此动作：
有了这个判定规则，允许有子节点的节点就可以获得文件夹图标，而不允许有子节点的节点将获得叶子图标。
另外，如果你是通过提供根节点来构建一棵树的，那么请在构造器中直接提供“询问允许有子节点”属性值的设置。
javax.swing.JTree 1.2
·Jtree（TreeModel model）
根据一个树模型构造一棵树。
·Jtree（TreeNode root）
·Jtree（TreeNode root，boolean asksAllowChildren）
使用默认的树模型构造一棵树，显示根节点和它的子节点。
参数：root　根节点
asksAllowChildren　如果设置为true，则使用“允许有子节点”的节点属性来确定一个节点是否是叶节点
·void setShowsRootHandles（boolean b）
如果b为true，则根节点具有折叠或展开它的子节点的把手图标。
·void setRootVisible（boolean b）
如果b为true，则显示根节点，否则隐藏根节点。
javax.swing.tree.TreeNode 1.2
·boolean isLeaf（）
如果该节点是一个概念上的叶节点，则返回true。
·boolean getAllowsChildren（）
如果该节点可以拥有子节点，则返回true。
javax.swing.tree.MutableTreeNode 1.2
·void setUserObject（Object userObject）
设置树节点用于绘制的“用户对象”。
javax.swing.tree.TreeModev 1.2
·boolean isLeaf（object node）
如果该节点应该以叶节点的形式显示，则返回true。
javax.swing.tree.DefaultTreeModel 1.2
·void setAsksAllowsChildren（boolean b）
如果b为true，那么当节点的getAllowsChildren方法返回false时，这些节点显示为叶节点。否则，当节点的isLeaf方法返回true时，它们显示为叶节点。
javax.swing.tree.DefaultMutableTreeNode 1.2
·DefaultMutableTreeNode（object userObject）
用给定的用户对象构建一个可变树节点。
·void add（MutableTreeNode child）
将一个节点添加为该节点最后一个子节点。
·void setAllowsChildren（boolean b）
如果b为true，则可以向该节点添加子节点。
javax.swing.JComponent 1.2
·void putClientProperty（Object key，Object value）
将一个键/值对添加到一个小表格中，每一个构件都管理着这样的一个小表格。这是一种“紧急逃生”机制，很多Swing构件用它来存放与外观相关的属性。
编辑树和树的路径
在下面的一个示例程序中，将会看到怎样编辑一棵树。图6-27显示了用户界面。如果点击“Add Sibling”（添加兄弟节点）或“Add Child”（添加子节点）按钮，该程序将向树中添加一个新节点（带有“New”标题）。如果你点击“Delete”（删除）按钮，该程序将删除当前选中的节点。
为了实现这种行为，需要弄清楚当前选定的是哪个节点。JTree类用的是一种令人惊讶的方式来标识树中的节点。它并不处理树的节点，而是处理对象路径（称为树路径）。一个树路径从根节点开始，由一个子节点序列构成，参见图6-28。
图6-27　编辑一棵树
图6-28　一个树路径
你可能要怀疑JTree类为什么需要整个路径。它不能只获得一个TreeNode，然后不断调用getParent方法吗？实际上，JTree类一点都不清楚TreeNode接口的情况。该接口从来没有被TreeModel接口用到过，它只被DefaultTreeModel的实现用到了。你完全可以拥有其他的树模型，这些树模型中的节点可能根本就没有实现TreeNode接口。如果你使用的是一个管理其他类型对象的树模型，那么这些对象有可能根本就没有getParent和getChild方法。它们彼此之间当然会有其他某种连接。将其他节点连接起来这是树模型的职责，JTree类本身并没有节点之间连接属性的任何线索。因此，JTree类总是需要用完整的路径来工作。
TreePath类管理着一个Object（不是TreeNode！）引用序列。有很多JTree的方法都可以返回TreePath对象。当拥有一个树路径时，通常只需要知道其终端节点，该节点可以通过getLastPathComponent方法得到。例如，如果要查找一棵树中当前选定的节点，可以使用JTree类中的getSelectionPath方法。它将返回一个TreePath对象，根据这个对象就可以检索实际节点。
实际上，由于这种特定查询经常被使用到，因此还提供了一个更方便的方法，它能够立即给出选定的节点。
该方法之所以没有被称为getSelectedNode，是因为这棵树并不了解它包含的节点，它的树模型只处理对象的路径。
注意：树路径是JTree类描述节点的两种方式之一。JTree有许多方法可以接收或返回一个整数索引——行的位置。行的位置仅仅是节点在树中显示的一个行号（从0开始）。只有那些可视节点才有行号，并且如果一个节点之前的其他节点展开、折叠或者被修改过，这个节点的行号也会随之改变。因此，你应该避免使用行的位置。相反地，所有使用行的JTree方法都有一个与之等价的使用树路径的方法。
一旦你选定了的某个节点，那么就可以对它进行编辑了。不过，不能直接向树节点添加子节点：
如果你改变了节点的结构，那么改变的只是树模型，而相关的视图却没有被通知到。可以自己发送一个通知消息，但是如果使用DefaultTreeModel类的insertNodeInto方法，那么该模型类会全权负责这件事情。例如，下面的调用可以将一个新节点作为选定节点的最后子节点添加到树中，并通知树的视图。
类似的调用removeNodeFromParent可以移除一个节点并通知树的视图：
如果想保持节点结构，但是要改变用户对象，那么可以调用下面这个方法：
自动通知是使用DefaultTreeModel的主要优势。如果你提供自己的树模型，那么必须自己动手实现这种自动通知。（详见Kim Topley撰写的《Core Swing》。）
警告：DefaultTreeModel有一个reload方法能够将整个模型重新载入。但是，不要在进行了少数几个修改之后，只是为了更新树而调用reload方法。在重建一棵树的时候，根节点的子节点之后的所有节点将全部再次折叠起来。如果你的用户在每次修改之后都要不断地展开整棵树，这确实是一件令人很不安的事。
当视图接收到节点结构被改变的通知时，它会更新显示树的视图，但是不会自动展开某个节点以展现新添加的子节点。特别是在我们上面那个示例程序中，如果用户将一个新节点添加到其子节点正处于折叠状态的节点上，那么这个新添加的节点就被悄无声息地添加到了一个处于折叠状态的子树中，这就没有给用户提供任何反馈信息以告诉用户已经实施了该命令。在这种情况下，你可能需要特别费劲地展开所有的父节点，以便让新添加的节点成为可视节点。可以使用类JTree中的方法makeVisible实现这个目的。makeVisible方法将接受一个树路径作为参数，该树路径指向应该变为可视的节点。
因此，你需要构建一个从根节点到新添加节点的树路径。为了获得一个这样的树路径，首先要调用DefaultTreeModel类中的getPathToRoot方法，它返回一个包含了某一节点到根节点之间所有节点的数组TreeNode[]。可以将这个数组传递给一个TreePath构造器。
例如，下面展示了怎样将一个新节点变成可见的：
注意：令人惊奇的是，DefaultTreeModel类好像完全忽视了TreePath类，尽管它的职责是与一个JTree通信。JTree类大量地使用到了树路径，而它从不使用节点对象数组。
但是，现在假设你的树是放在一个滚动面板里面，在展开树节点之后，新节点仍是不可见的，因为它落在视图之外。为了克服这个问题，请调用
而不是调用makeVisible。这个调用将展开路径中的所有节点，并告诉外围的滚动面板将路径末端的节点滚动到视图中（参见图6-29）。
默认情况下，这些树节点是不可编辑的。不过，如果调用
那么，用户就可以编辑某一节点了。可以先双击该节点，然后编辑字符串，最后按下回车键。双击操作会调用默认单元格编辑器，它实现了DefaultCellEditor类（参见图6-30）。也可以安装其他一些单元格编辑器，其过程与表格单元格编辑器中讨论的过程一样。
程序清单6-13展示了树编辑程序的完整源代码。运行该程序，添加几个新节点，然后通过双击它们进行编辑操作。请观察折叠的节点是怎样展开以显现添加的子节点的，以及滚动面板是怎样让添加的节点保持在视图中的。
图6-29　滚动以显示新节点的滚动面板
图6-30　默认的单元格编辑器
程序清单6-13　treeEdit/TreeEditFrame.java
javax.swing.JTree 1.2
·TreePath getSelectionPath（）
获取到当前选定节点的路径，如果选定多个节点，则获取到第一个选定节点的路径。如果没有选定任何节点，则返回null。
·Object getLastSelectedPathComponent（）
获取表示当前选定节点的节点对象，如果选定多个节点，则获取第一个选定的节点。如果没有选定任何节点，则返回null。
·void makeVisible（TreePath path）
展开该路径中的所有节点。
·void scrollPathToVisible（TreePath path）
展开该路径中的所有节点，如果这棵树是置于滚动面板中的，则滚动以确保该路径中的最后一个节点是可见的。
javax.swing.tree.TreePath 1.2
·Object getLastPathComponent（）
获取该路径中最后一个节点，也就该路径代表的节点对象。
javax.swing.tree.TreeNode 1.2
·treeNode getParent（）
返回该节点的父节点。
·treeNode getChildAt（int index）
查找给定索引号上的子节点。该索引号必须在0和getChildCount（）-1之间。
·int getChildCount（）
返回该节点的子节点个数。
·Enumeration children（）
返回一个枚举对象，可以迭代遍历该节点的所有子节点。
javax.swing.tree.DefaultTreeModel 1.2
·void insertNodeInto（MutableTreeNode newChild，MutableTreeNode parent，int index）
将newChild作为parent的新子节点添加到给定的索引位置上，并通知树模型的监听器。
·void removeNodeFromParent（MutableTreeNode node）
将节点node从该模型中删除，并通知树模型的监听器。
·void nodesChanged（TreeNode node）
通知树模型的监听器：节点node发生了改变。
·void nodesChanged（TreeNode parent，int[]changedChildIndexes）
通知树模型的监听器：节点parent所有在给定索引位置上的子节点发生了改变。
·void reload（）
将所有节点重新载入到树模型中。这是一项动作剧烈的操作，只有当由于一些外部作用，导致树的节点完全改变时，才应该使用该方法。6.3.2　节点枚举
有时为了查找树中一个节点，必须从根节点开始，遍历所有子节点直到找到相匹配的节点。DefaultMutableTreeNode类有几个很方便的方法用于迭代遍历所有节点。
breadthFirstEnumeration方法和depthFirst Enumeration方法分别使用广度优先或深度优先的遍历方式，返回枚举对象，它们的nextElement方法能够访问当前节点的所有子节点。图6-31显示了对示例树进行遍历的情况，节点标签则指示遍历节点时的先后次序。
图6-31　树的遍历顺序
按照广度优先的方式进行枚举是最容易可视化的。树是以层的形式遍历的，首先访问根节点，然后是它的所有子节点，接着是它的孙子节点，依此类推。
为了可视化深度优先的枚举，让我们想像一只老鼠陷入一个树状陷阱的情形。它沿着第一条路径迅速爬行，直到它到达一个叶节点位置。然后，原路返回并转入下一条路径，依此类推。
计算机科学家也将其称为后序遍历（postorder traversal），因为整个查找过程是先访问到子节点，然后才访问到父节点。postOrderTraversal方法是depthFirstTraversal的同义语。为了完整性，还存在一个preOrderTraversal方法，它也是一种深度优先搜索方法，但是它首先枚举父节点，然后是子节点。
下面是一个典型的使用模式：
最后，还有一个相关方法pathFromAncestorEnumeration，用于查找一条从祖先节点到给定节点之间的路径，然后枚举出该路径中的所有节点。整个过程并不需要大量的处理操作，只需要不断调用getParent直到发现祖先节点，然后将该路径倒置过来存放即可。
在我们的下个示例程序中，将运用到节点枚举。该程序显示了类之间的继承树。向窗体最下面的文本框中输入一个类名，该类以及它的所有父类就会添加到树中（参见图6-32）。
图6-32　一棵继承树
在这个示例中，我们充分利用了这个事实，即树节点的用户对象可以是任何类型的对象。因为我们这里的节点是用来描述类的，因此我们在这些节点中存储的是Class对象。
当然，我们不想对同一个类对象添加两次，因此我们必须检查一个类是否已经存在于树中。如果在树中存在给定用户对象的节点，那么下面这个方法就可以用来查找该节点。
6.3.3　绘制节点
在应用中可能会经常需要改变树构件绘制节点的方式，最常见的改变当然是为节点和叶节点选取不同的图标，其他一些改变可能涉及节点标签的字体或节点上的图像绘制等方面。所有这些改变都可以通过向树中安装一个新的树单元格绘制器来实现。在默认情况下，JTree类使用DefaultTreeCellRenderer对象来绘制每个节点。DefaultTreeCellRenderer类继承自JLabel类，该标签包含节点图标和节点标签。
注意：单元格绘制器并不能绘制用于展开或折叠子树的“把手”图标。这些把手是外观模式的一部分，建议最好不要试图改变它们。
可以通过以下三种方式定制显示外观：
·可以使用DefaultTreeCellRenderer改变图标、字体以及背景颜色。这些设置适用于树中所有节点。
·可以安装一个继承了DefaultTreeCellRenderer类的绘制器，用于改变每个节点的图标、字体以及背景颜色。
·可以安装一个实现了TreeCellRenderer接口的绘制器，为每个节点绘制自定义的图像。
让我们逐个研究这几种可能。最简单的定制方法是构建一个DefaultTreeCellRenderer对象，改变图标，然后将它安装到树中：
可以在图6-32中看到运行效果。我们只是使用“球”图标作为占位符，这里假设你的用户界面设计者会为你的应用提供合适的图标。
我们不建议改变整棵树中的字体或背景颜色，因为这实际上是外观设置的职责所在。
不过，改变树中个别节点的字体，以突显某些节点还是很有用的。如果仔细观察图6-32，你会看到抽象类是设成斜体字的。
为了改变单个节点的外观，需要安装一个树单元格绘制器。树单元格绘制器与我们在本章前一节讨论的列表单元格绘制器很相似。TreeCellRenderer接口只有下面这个单一方法：
DefaultTreeCellRenderer类的getTreeCellRendererComponent方法返回的是this，换句话说，就是一个标签（DefaultTreeCellRenderer类继承了JLabel类）。如果要定制一个构件，需要继承DefaultTreeCellRenderer类。按照以下方式覆盖getTreeCell RendererComponent方法：调用超类中的方法，以便准备标签的数据，然后定制标签属性，最后返回this。
警告：getTreeCellRendererComponent方法的value参数是节点对象，而不是用户对象！请记住，用户对象是DefaultMutableTreeNode的一个特性，而JTree可以包含任意类型的节点。如果树使用的是DefaultMutableTreeNode节点，那么必须在第二个步骤中获取这个用户对象，正如我们在上一个代码示例中所做的那样。
警告：DefaultTreeCellRenderer为所有节点使用的是相同的标签对象，仅仅是为每个节点改变标签文本而已。如果想为某个特定节点更改字体，那么必须在该方法再次调用的时候将它设置回默认值。否则，随后的所有节点都会以更改过的字体进行绘制！见程序清单6-14中的程序代码，看看它是怎样将字体恢复到其默认值的。
我们没有给出有关用来绘制任意图形的树单元格绘制器的示例。如果你需要这个功能，可以参考程序清单6-4中的列表单元格绘制器；它们用到的技术完全相似。
根据Class对象有无ABSTRACT修饰符，程序清单6-14中的ClassNameTreeCellRenderer将类名设置为标准字体或斜体字体。我们不想设置成特殊的字体，因为我们不想改变通常用于显示标签的任何字体外观。因此，我们使用来自于标签本身的字体以及从它衍生而来的一个斜体字体。请回忆一下，全部的调用只返回一个共享的单一的JLabel对象。因此，我们需要保存初始字体，并在下一次调用gettreeCellRendererComponent方法时将其恢复为初始值。
同时，注意一下我们是如何改变ClassTreeFrame构造器中的节点图标的。
javax.swing.tree.DefaultMutableTreeNode 1.2
·Enumeration breadthFirstEnumeration（）
·Enumeration depthFirstEnumeration（）
·Enumeration preOrderEnumeration（）
·Enumeration postOrderEnumeration（）
返回枚举对象，用于按照某种特定顺序访问树模型中所有节点的。在广度优先遍历中，先访问离根节点更近的子节点，再访问那些离根节点远的节点。在深度优先遍历中，先访问一个节点的所有子节点，然后再访问它的兄弟节点。postOrderEnumeration方法与depthFirstEnumeration基本上相似。除了先访问父节点，后访问子节点之外，先序遍历和后序遍历基本上一样。
javax.swing.tree.TreeCellRenderer 1.2
·Component getTreeCellRendererComponent（JTree tree，Object value，boolean selected，boolean expanded，boolean leaf，int row，boolean hasFocus）
返回一个paint方法被调用的构件，以便绘制树的一个单元格。
参数：tree　包含要绘制节点的树
value　要绘制的节点
selected　如果该节点是当前选定的节点，则为true
expanded　如果该节点的子节点可见，则为true
leaf　如果该节点应该显示为叶节点，则为true
row　显示包含该节点的那行
hasFocus　如果当前选定的节点拥有输入焦点，则为true
javax.swing.tree.DefaultTreeCellRenderer 1.2
·void setLeafIcon（Icon icon）
·void setOpenIcon（Icon icon）
·void setClosedIcon（Icon icon）
设置叶节点、展开节点以及折叠节点的显示图标。6.3.4　监听树事件
通常情况下，一个树构件会成对伴随着其他某个构件。当用户选定了一些树节点时，某些信息就会在其他窗口中显示出来。参见图6-33的示例。当用户选定一个类时，这个类的实例及静态变量信息就会在右边的文本区显示出来。
图6-33　一个类浏览器
为了获得这项功能，你可以安装一个树选择监听器。该监听器必须实现TreeSelection-Listener接口，这是一个只有下面这个单一方法的接口：
每当用户选定或者撤销选定树节点的时候，这个方法就会被调用。
可以按照下面这种通常方式向树中添加监听器：
可以设定是否允许用户选定一个单一的节点、连续区间内的节点或者一个任意的、可能不连续的节点集。JTree类使用TreeSelectionModel来管理节点的选择。必须检索整个模型，以便将选择状态设置为SINGLE_TREE_SELECTION、CONTIGUOUS_TREE_SELECTION或DISCONTIGUOUS_TREE_SELECTION三种状态之一。（在默认情况下是非连续的选择模式。）例如，在我们的类浏览器中，我们希望只允许选择单个类：
除了设置选择模式之外，你并不需要担心树的选择模型。
注意：用户怎样选定多个选项则依赖于外观。在Metal外观中，按下CTRL键，同时点击一个选项将它添加到选项集中，如果当前已经选定了该选项，则将其从选项集中删除。按下SHIFT键，同时点击一个选项，可以选定一个选项范围，它从先前已选定的选项延伸到新选定的选项。
要找出当前的选项集，可以用getSelectionPaths方法来查询树：
如果想限制用户只能做单项选择，那么可以使用便捷的getSelectionPath方法，它将返回第一个被选择的路径，或者是null（如果没有任何路径被选）。
警告：TreeSelectionEvent类具有一个getPaths方法，它将返回一个TreePath对象数组，但是该数组描述的是选项集的变化，而不是当前的选项集。
程序清单6-14显示了类树这个程序的框体类。该程序可以显示继承的层次结构，并且将抽象类定制显示为斜体字（参见程序清单6-15的单元格绘制器）。可以在窗体下面的文本框中输入任何类名，按下Enter键或者点击“Add”按钮，将该类及其超类添加到树中。必须输入完整的包名，例如java.util.ArrayList。
这个程序用到了一点小小的技巧，它是通过反射机制来构建这棵类树的。这项操作包含在addClass方法内。（细节倒不那么重要，在这个例子中，我们之所以使用类树，是因为继承树不需要怎么费劲地编码就能生成一棵丰富的树。如果想在自己的应用中显示树，那么你需要准备自己的层次结构数据的来源。）该方法使用广度优先的搜索算法，通过调用我们在前一节实现的findUserObject方法，来确定当前的类是否已经存在于树中。如果这个类还不存在于树中，那么我们将其超类添加到这棵树中，然后将新节点作为它的子节点，并使该节点成为可见的。
在选择树的一个节点时，右侧的文本域将填充为选中的类的属性。在窗体构造器中，限制用户只能进行单个选项的选择，并添加了一个树选择监听器。当调用valueChanged方法时，我们忽略它的事件参数，只向该树询问当前的选定路径。正如通常情况那样，我们必须获得路径中的最后一个节点，并且查看它的用户对象。然后调用getFieldDescription方法，该方法使用反射机制将所选类的所有属性组装成一个字符串。
程序清单6-14　treeRender/ClassTreeFrame.java
程序清单6-15　treeRender/ClassNameTreeCellRenderer.java
javax.swing.JTree 1.2
·TreePath getSelectionPath（）
·TreePath[]getSelectionPaths（）
返回第一个选定的路径，或者一个包含所有选定节点的数组。如果没有选定任何路径，这两个方法都返回为null。
javax.swing.event.TreeSelectionListener 1.2
·void valueChanged（TreeSelectionEvent event）
每当选定节点或撤销选定的时候，该方法就被调用。
javax.swing.event.TreeSelectionEvent 1.2
·TreePath getPath（）
·TreePath[]getPaths（）
获取在该选择事件中已经发生更改的第一个路径或所有路径。如果你想知道当前的选择路径，而不是选择路径的更改情况，那么应该调用JTree.getSelectionPaths。6.3.5　定制树模型
在最后一个示例中，我们实现了一个能够查看变量内容的程序，正如调试器所做的那样（参见图6-34）。
图6-34　一个对象查看树
在继续深入之前，请先编译运行这个示例程序。其中每个节点对应于一个实例域。如果该域是一个对象，那么可以展开该节点以便查看它自己的实例域。该程序可以观察框架窗口的内容。如果你浏览了好几个实例域，那么你将会发现一些熟悉的类，还会对复杂的Swing用户界面构件有所了解。
该程序的不同之处在于它的树并没有使用DefaultTreeModel。如果你已经拥有按照层次结构组织的数据，那么你可能并不想花精力去再创建一棵副本树，而且创建副本树还要担心怎样保持两棵树的一致性。这正是我们要讨论的情形：通过对象的引用，要观察的对象已经彼此连接起来了，因此在这里就不需要复制这种连接结构了。
TreeModel接口只有几个方法。第一组方法使得JTree能够按照先是根节点，后是子节点的顺序找到树中的节点。JTree类只在用户真正展开一个节点的时候才会调用这些方法。
这个示例显示了为什么TreeModel接口像JTree类那样，不需要用于描述节点的显式概念。根节点和子节点可以是任何对象，TreeModel负责告知JTree它们是怎样联系起来的。
TreeModel接口的下一个方法与getChild相反：
实际上，这个方法可以用前面的三个方法实现，参见程序清单6-16中的代码。
树模型会告诉JTree哪些节点应该显示成叶节点：
如果你的代码更改了树模型，那么必须告知这棵树以便它能够对自己进行重新绘制。树是将它自己作为一个TreeModelListener添加到模型中的，因此，模型必须支持通常的监听器管理方法：
可以在程序清单6-17中看到这些方法的具体实现。
当模型修改了树的内容时，它会调用TreeModelListener接口中下面4个方法中的某一个：
TreeModelEvent对象用于描述修改的位置。对描述插入或移除事件的树模型事件进行组装的细节是相当技术性的。如果树中确实有要添加或移除的节点，只需要考虑如何触发这些事件。在程序清单6-16中，我们展示了怎么触发一个事件：将根节点替换为一个新的对象。
提示：为了简化事件触发的代码，我们使用了javax.swing.EventListenerList这个使用方便、能够收集监听器的类。程序清单6-17中最后3个方法展示了如何使用这个类。
最后，如果用户要编辑树节点，那么模型会随着这种修改而被调用：
如果不允许编辑，则永远不会调用到该方法。
如果不支持编辑功能，那么构建一个树模型就变得相当容易了。我们要实现下面3个方法：
这3个方法用于描述树的结构。还要提供另外5个方法的常规实现，如程序清单6-16那样，然后就可以准备显示你的树了。
现在让我们转向示例程序的具体实现，我们的树将包含类型为Variable的对象。
注意：一旦使用了DefaultTreeModel，我们的节点就可以具有类型为DefaultMutableTree-Node、用户对象类型为Variable的对象。
例如，假设我们查看下面这个变量
该变量的类型为Employee.class，名字为joe，值为对象引用joe的值。在程序清单6-18中，我们定义了Variable这个类，用来描述程序中的变量：
如果该变量的类型为基本类型，必须为这个值使用对象包装器。
如果变量的类型是一个类，那么该变量就会拥有一些域。使用反射机制可以将所有域枚举出来，并将它们收集存放到一个ArrayList中。因为Class类的getFields方法不返回超类的任何域，因此还必须调用超类中的getFields方法，你可以在Variable构造器中找到这些代码。Variable类的getFields方法将返回包含域的一个数组。最后，Variable类的toString方法将节点格式化为标签，这个标签通常包含变量的类型和名称。如果变量不是一个类，那么该标签还将包含变量的值。
注意：如果类型是一个数组，那么我们不会显示数组中的元素。这并不难实现，因此我们就把它留作众所周知的“读者练习”了。
让我们继续介绍树模型，头两个方法很简单。
getChild方法返回一个新的Variable对象，用于描述给定索引位置上的域。Field类的getType方法和getName方法用于产生域的类型和名称。通过使用反射机制，你可以按照f.get（parentValue）这种方式读取域的值。该方法可以抛出一个异常IllegalAccessException，不过，我们可以让所有域在Variable构造器中都是可访问的，这样，在实际应用中，就不会发生这种抛异常的情况。
下面是getChild方法的完整代码。
这3个方法展示了对象树到JTree构件之间的结构，其余的方法是一些常规方法，源代码请见程序清单6-17。
关于该树模型，有一个不同寻常之处：它实际上描述的是一棵无限树。可以通过追踪WeakReference对象来证实这一点。当你点击名字为referent的变量时，它会引导你回到初始的对象。你将获得一棵相同的子树，并且可以再次展开它的WeakReference对象，周而复始，无穷无尽。当然，你无法存储一个无限的节点集合。树模型只是在用户展开父节点时，按照需要来产生这些节点。
程序清单6-16展示了样例程序的框体类。
程序清单6-16　treeModel/ObjectInspectorFrame.java
程序清单6-17　treeModel/ObjectTreeModel.java
程序清单6-18　treeModel/Variable.java
javax.swing.tree.TreeModel 1.2
·Object getRoot（）
返回根节点。
·int getChildCount（Object parent）
获取parent节点的子节点个数。
·Object getChild（Object parent，int index）
获取给定索引位置上parent节点的子节点。
·int getIndexOfChild（Object parent，Object child）
获取parent节点的子节点child的索引位置。如果在树模型中child节点不是parent的一个子节点，则返回-1。
·boolean isLeaf（Object node）
如果节点node从概念上讲是一个叶节点，则返回true。
·void addTreeModelListener（TreeModelListener l）
·void removeTreeModelListener（TreeModelListener l）
当模型中的信息发生变化时，告知添加和移除监听器。
·void valueForPathChanged（TreePath path，Object newValue）
当一个单元格编辑器修改了节点值的时候，该方法被调用。
参数：path　到被编辑节点的树路径
newValue　编辑器返回的修改值
javax.swing.event.TreeModelListener 1.2
·void treeNodesChanged（TreeModelEvent e）
·void treeNodesInserted（TreeModelEvent e）
·void treeNodesRemoved（TreeModelEvent e）
·void treeStructureChanged（TreeModelEvent e）
如果树被修改过，树模型将调用该方法。
javax.swing.event.TreeModelEvent 1.2
·TreeModelEvent（Object eventSource，TreePath node）
构建一个树模型事件。
参数：eventSource　产生该事件的树模型
node　到达要修改节点的树路径6.4　文本构件
图6-35展示了Swing类库中包含的所有文本构件，在第Ⅰ卷第9章你已经看到过其中3个最常用的构件：JTextField、JPasswordField和JTextArea。在下面各节中，我们将介绍其余的文本构件。我们还将讨论JSpinner构件，它包含一个格式化的文本框，以及用来改变其内容的“up（上）”和“down（下）”小按钮。
图6-35　文本构件和文档的层次结构
所有文本构件都可以绘制和编辑存储在实现了Document接口的类的模型对象中的数据。JTextField和JTextArea构件使用的是PlainDocument，该构件直接存储普通文本的行序列，而不进行任何格式化。
JEditorPane可以展示和编辑各种格式的样式文本（包括字体、颜色等），特别是HTML，参见第6.4.4节，StyledDocument接口描述了对样式、字体和颜色的额外需求，而HTMLDocument类实现了这个接口。
JEditorPane的子类JTextPane可以持有样式化的文本和嵌入的Swing构件。我们在本书中将不讨论过于复杂的JTextPane，但是推荐你参考Kim Toley所著的《Core Swing》一书以了解其中关于此构件十分详细的描述。对于JTextPane类的典型用法，可以查看JDK中的StylePad演示程序。6.4.1　文本构件中的修改跟踪
只有当你希望实现自己的文本编辑器时，你才需要面对Document接口的复杂性。然而，这个接口的最常见的用法是：跟踪修改。
有时，你希望只要用户进行了文本编辑，无需等待他点击某个按钮，就马上更新部分用户界面。下面是一个简单的示例：我们显示了三个文本框，用于编辑颜色的红、蓝、绿色调。只要这些文本框的内容发生了变化，颜色就应该立即更新。图6-36展示了程序清单6-19中的程序运行起来的样子。
图6-36　跟踪文本框中的修改
首先请注意，监视键盘点击事件并非好主意，因为有些键盘点击事件并不修改文本（例如，点击方向键）。更重要的是，文本可以因鼠标的姿态变化而改变（例如在X11中的“鼠标中键粘贴”）。因此，应该让文档（document）来通知我们数据发生了变化，方法是在文档（而不是文本构件）上安装文档监听器（document listener）：
当文本发生变化时，会调用下列DocumentListener方法之一：
前两个方法是在插入或移除字符时被调用的，第三个方法对于文本框来说根本不会被调用，而对于更复杂的文档类型，在产生某些其他类型的变化，例如格式上的变化时，这个方法才会被调用。但是，由于没有任何单个的回调可以告诉我们文本发生了变化（通常我们也并不太关心文本发生了怎样的变化），同时也没有任何适配器类。因此，文档监听器必须实现所有这3个方法。下面是我们在示例程序中的做法：
setColor方法使用getText方法从文本框中获得当前的用户输入字符串，并设置其颜色。
我们的程序有一个限制：用户可以在文本框中键入非数字的畸形输入，例如“twenty”，或者使文本框保持为空。因此，目前我们将捕获parseInt方法抛出的NumberFormatException，并且在文本框中的内容不是数字时，不执行更新颜色的操作。在下一节，你将会看到可以如何预先防止用户键入无效的输入。
注意：除了监听文档事件，还可以在文本框上添加一个行为事件监听器。只要用户按下了回车键，动作监听器就会得到通知。我们不推荐这种方法，因为用户在完成数据输入后，并非总是记得按回车键。如果使用动作监听器，就应该同时安装一个焦点监听器，这样我们可以跟踪用户何时离开该文本框。
程序清单6-19　textChange/ColorFrame.java
javax.swing.JComponent 1.2
·Dimension getPreferredSize（）
·void setPreferredSize（Dimension d）
获取和设置该构件的偏好尺寸。
javax.swing.text.Document 1.2
·int getLength（）
返回文档中当前的字符数量。
·String getText（int offset，int length）
返回在文档的给定部分中所包含的文本。
参数：offset　文本的起始位置
length　希望得到的字符串的长度
·void addDocumentListener（DocumentListener listener）
注册监听器，使得在文档发生变化时，可以得到通知。
javax.swing.event.DocumentEvent 1.2
·Document getDocument（）
获取事件来源的文档。
javax.swing.event.DocumentListener 1.2
·void changedUpdate（DocumentEvent event）
当某个属性或属性集发生变化时，该方法即被调用。
·void insertUpdate（DocumentEvent event）
在文档中插入内容时，该方法即被调用。
·void removeUpdate（DocumentEvent event）
在文档中有部分内容被移除时，该方法即被调用。6.4.2　格式化的输入框
在前一个示例程序中，我们希望程序的用户键入数字而不是任意的字符串。也就是说，只允许用户键入数字0到9以及连字符，并且如果有连字符，它必须是输入字符串的第一个字符。
表面上看，这种输入检验任务很简单。我们可以在文本框上安装一个按键监听器，然后处理掉所有不是数字和连字符的按键事件。但是，这种简单的方法在实践中并非很有效，尽管这是通常被推荐的输入检验方法。首先，并非每一种有效输入字符的组合都是一个有效的数字，例如，--3和3-3都无效，尽管它们是由有效的输入字符构成的。但是，更重要的是，有些对文本修改的方式并不涉及输入字符键。根据不同的用户界面感观，某些组合键可以用来剪切、复制和粘贴文本。例如，在金属用户界面感观中，CTRL+V组合键可以将粘贴缓冲区中的内容粘贴到文本框中。也就是说，我们还需要监视用户是否粘贴了无效的字符。很明显，试图通过过滤键盘点击来确保文本框的内容总是有效这种方法看起来已经很麻烦了，而这些任务并不应该让应用系统的程序员去关注。
有点令人惊讶的是，在Java SE 1.4之前，没有任何构件用于输入数字型的值。从《Core Java》的第1版开始，我们就提供了一个IntTextField实现，这是一个用于输入正确格式的整数的文本框。在此后的每个新版本中，我们都在修改这个实现，以利用Java在其每个新版本中不断添加的各种不太全面的校验模式。最终，在Java SE 1.4中，Swing的设计者们正视了这个问题，并且提供了通用的JFormattedTextField类，它不仅可以用于数字型的输入，而且可以用于日期型输入以及更加专用的格式化输入值，例如IP地址。
1.整数输入
让我们从简单的情况入手：用于整数输入的文本框
NumberFormat.getIntegerInstance将使用当前的locale返回一个用于格式化整数的格式器对象。在美国locale中，逗号用作十进制分隔符，从而允许用户输入像1，729这样的值。第5章详细解释了如何选择其他的locale。
对于任何文本框，都可以设置其位数：
还可以用setValue方法设置其默认值，该方法接受一个Object类型的参数，因此我们需要将默认的int值包装到一个Integer对象中：
通常，用户会在多个文本框中输入，然后点击某个按钮来读取所有这些值。当按钮被点击后，可以用getValue方法来获取用户提供的值，这个方法返回的是一个Object类型的结果，必须将它转型为恰当的类型。如果用户对上述文本框中的值进行了编辑，那么JFormattedTextField将返回Long类型的对象。但是，如果用户没有进行修改，就会返回最初的Integer对象。因此，应该将返回值转型为它们的公共超类Number：
格式化文本框看上去可能并没什么太大的用处，但是如果你要考虑用户提供非法输入时的情况，那么它就有用处了，这正是下一节的主题。
2.失去焦点时的行为
考虑一下当用户向文本框中输入时会发生什么。用户键入输入，并且在完成后决定离开这个文本框，因此可能会用鼠标点击其他的构件，然后这个文本框将失去焦点（lose focus），在其中不再会看到像I一样的闪烁光标，键盘点击都将被导向另一个不同的构件。
当格式化文本框失去焦点时，格式器会查看用户输入的文本字符串。如果格式器知道如何将这个文本字符串转换为对象，那么这个文本就是有效的，否则就是无效的。可以使用isEditValid方法来检查文本框的当前内容是否有效。
失去焦点的默认行为称为“提交或恢复”。如果文本字符串有效，则它被提交（commit），之后格式器将其转换为对象，而该对象将成为文本框的当前值（也就是前一节中提到的getValue方法的返回值）。这个值然后再被转换回字符串，成为在文本框中看到的字符串。例如，整数格式器将输入的1729识别为有效，将当前值设置为new Long（1729），然后将其转换回带有十进制逗号的字符串1，729。
反之，如果文本字符串无效，则当前值不发生变化，而文本框将恢复到表示原有值的字符串。例如，如果用户输入了无效值，例如x1，那么当文本框失去焦点时，将恢复原有值。
注意：整数格式器将以整数开头的文本字符串当作是有效的。例如，1729x是有效的字符串，它将被转换为数字1729，这个数字之后会被格式化为字符串1，729。
可以用setFocusLostBehavior方法来设置其他的行为。“提交”行为与默认行为有些细微的差异，如果文本字符串无效，那么文本字符串和文本框的值都将保持不变，现在它们是不同步的。“持久化”行为更加保守，即使文本字符串是有效的，文本框和当前值也都不发生变化，这时需要调用commitEdit、setValue和setText来使它们同步。最后，还有一个“恢复”行为，它看起来永远都没什么用，其行为是只要失去了焦点，用户输入就会被丢弃，而文本字符串将恢复到原有值。
注意：通常，“提交或恢复”作为默认行为是合理的，这么做只有一个潜在可能发生的问题。假设对话框中包含用于整数值的文本框，而用户输入了字符串“1729”，其中带一个先导的空格，然后点击了OK按钮。这个先导的空格将会使数字无效，而这个文本框的值也将恢复到原有值。接着，OK按钮的动作监听器获取文本框的值，然后关闭对话框。这样用户永远都不会知道他输入的新值被拒绝了。在这种情况下，恰当的选择应该是“提交”行为，然后让OK按钮的监听器在关闭对话框之前检查所有的文本框编辑是否都有效。
3.过滤器
格式化文本框的基本功能对于大多数用户来说很直观，而且也足够用了。但是，我们还可以添加一些精化的功能，例如同时还要防止用户键入非数字字符，我们可以用文档过滤器（document filter）来实现这个行为。回忆一下，在模型-视图-控制器架构中，控制器将输入事件转译成了修改文本框底层文档的命令，这个底层文档也就是存储在PlainDocument对象中的文本字符串。例如，每当控制器处理的命令会导致在该文档中插入字符串时，它就会调用“插入字符串”命令。要插入的字符串可以是单个的字符，也可以是粘贴缓冲区中的内容。文档过滤器可以拦截这个命令，并修改字符串或放弃插入操作。下面是过滤器的insertString方法的代码，该方法对要插入的字符串进行分析，并只插入那些数字和负号（-）字符。（这段代码可以处理第I卷第3章中描述的补充Unicode字符，请参见第1章StringBuilder类。）
还应该覆盖DocumentFilter类的replace方法，该方法在文本被选中并被替换时调用。replace方法的实现很直观，参见程序清单6-21。
现在需要安装文档过滤器。但是，没有很直观的方法可以实现这个任务，必须覆盖某个格式器类的getDocumentFilter方法，然后将这个格式器的一个对象传递给JFormattedTextField。整数文本框使用的是用NumberFormat.getIntegerInstance（）初始化的InternationalFormatter。下面展示了如何安装格式器以产生所需的过滤器：
注意：Java SE文档声明DocumentFilter类被设计为禁止子类化。直到Java SE 1.3，文本框中的过滤机制才通过扩展PlainDocument类和覆盖insertString与replace方法得到了实现。现在，PlainDocument类有了可插拔的过滤器，这是一项极佳的改进。如果过滤器在格式器类中也是可插拔的，那么这项改进就更好了。唉，但是它不是，我们必须子类化格式器。
试验一下本节最后的FormatTest示例程序，其中第三个文本框就安装了一个过滤器，这样就只能插入数字和负号字符了。注意，现在你仍旧可以键入诸如“1-2-3”这样的无效字符串。通常，通过过滤机制来避免所有无效字符串是不可能的。例如，字符串“-”是无效的，但是过滤器不能拒绝它，因为它是合法字符串“-1”的前缀。即使过滤器不能进行完美的保护，但是使用它们来拒绝明显无效的输入仍旧是有意义的。
提示：过滤机制的另一种用法是将一个字符串的所有字符都转为大写。这样的过滤器很容易编写，在其insertString和replace方法中，将要插入的字符串转换成大写，然后调用超类的方法即可。
4.校验器
还有一种很有用的机制，可以就无效输入对用户发出警告，这就是在任意的JComponent上附着一个校验器（verifier）。如果该构件失去了焦点，那么校验器就会被查询。如果校验器报告该构件的内容无效，那么该构件就会立即重新获得焦点。这样，用户就被强制要求在进行其他输入之前先订正刚输入的内容。
校验器必须扩展InputVerifier类并定义verify方法，而定义检查格式化文本框的校验器非常容易。JFormattedTextField类的isEditValid方法将调用格式器，并且在格式器可以将文本字符串转换为对象时返回true。下面是一个校验器：
我们可以将它附着到任何JFormattedTextField上。
在示例程序中的第四个文本框就附着了一个校验器。试着在其中键入无效数字（例如x1729），然后按下TAB键，或者用鼠标点击其他文本框。注意，该文本框会立即重新得到焦点。但是，如果你点击OK按钮，动作监听器就会调用getValue，它会报告最后一个有效值。
但是，校验器并非总是很安全。如果点击了某个按钮，而这个按钮在无效构件再次获得焦点之前通知了它的动作监听器，那么这个动作监听器就会从未通过校验的构件中得到一个无效的结果。这种行为的原因在于：用户可能希望点击Cancel按钮，而无需订正无效输入。
5.其他的标准格式器
除了整数格式器，JFormattedTextField还支持若干种其他的格式器。NumberFormat类有下列静态方法：
它们将分别产生用于浮点数字、货币值和百分比的格式器。例如，通过下面的调用可以获得用于输入货币值的文本框。
要编辑日期和时间，可以调用DateFormat类的下列静态方法之一：
例如：
所产生的文本框将用默认格式或下面的“中等长度”格式来编辑日期：
也可以选择使用“短”格式
方法是调用下面的语句：
注意：默认情况下，日期格式器是很“宽容”的，也就是说，像2002年2月31号这样的无效日期将会滚动到下一个有效日期2002年3月3日。这种行为可能会让用户觉得意外，此时，可以在DateFormat对象上调用setLenient（false）。
对于任何类，只要它有一个接受字符串参数的构造器，以及相匹配的toString方法，那么DefaultFormatter就可以格式化它的对象。例如，URL类有一个URL（String）构造器，可以从字符串中构建URL，例如：
因此，我们可以用DefaultFormatter格式化URL对象。格式器会在文本框值上调用toString方法以初始化该文本框的文本。当文本框失去焦点时，格式器将使用带有String参数的构造器来构建与当前值属于相同类的新对象。如果这个构造器抛出了异常，那么这次编辑就是无效的。你可以运行示例程序，键入并非以“http:”这种前缀开头的URL，然后观察其响应。
注意：默认情况下，DefaultFormatter是覆写模式，这与其他格式器很不相同，并且不是非常有用。调用setOverwriteMode（false）可以关闭覆写模式。
最后，MaskFormatter对于包含部分常量和部分变量字符的固定尺寸的模式是非常有用的。例如，社会保障号（例如，078-05-1120）可以用下面的格式器进行格式化：
其中#符号表示单个数字，表6-3展示了可以在掩码格式器中使用的各种符号。
表6-3　MaskFormatter符号
我们可以通过调用MaskFormatter类的下列方法之一来限制可以键入到文本框中的字符：
例如，要读入用字母表示的成绩（例如A+或F），可以执行下面的语句：
但是，没有办法可以指定第二个字符不能是字母。
请注意，由掩码格式器格式化的字符串与掩码有严格相同的长度。如果用户在编辑时删除了某些字符，那么它们就会被占位符所替换。默认的占位符是空格，但是可以用setPlaceholderCharacter方法来改变它，例如：
默认情况下，掩码格式器处于覆写模式，这很直观，所以运行示例程序来观察它。同时还要注意脱字符的位置会跳过掩码中的固定字符。
掩码格式器对于像社会保障号或美国电话号码这样的严格模式来说显得非常有效。但是，请注意，掩码模式中不允许有任何变体。例如，不能将掩码格式器用于国际电话号码，因为它们的位数并不固定。
6.定制格式器
如果所有的标准格式器都不适用，那么我们可以很方便地定义自己的格式器。请考虑4字节的IP地址，例如：
我们不能使用MaskFormatter，因为每个字节都可以由1个、2个或3个数字表示。而且，我们希望格式器能够检查每个字节的值最大不能超过255。
要定义自己的格式器，需要扩展DefaultFormatter类，并覆盖下面的方法：
第一个方法将文本框的值转换为显示在其中的字符串；第二个方法解析用户键入的文本，并将其转换回对象。这两个方法只要发现了错误，就应该抛出ParseException。
在示例程序中，我们用长度为4的byte[]数组存储IP地址。valueToString方法将构建由这些字节构成的字符串，其中字节与字节之间由句点隔开。注意，byte值是有符号的，取值范围位于-128与127之间（例如，在IP地址130.65.86.66中，第一个八位实际上是表示-126的字节）。要想将负的字节值转换为无符号的整数值，需要加上256。
反过来，stringToValue方法解析这个字符串，并且在该字符串有效的情况下产生一个byte[]对象。如果该字符串无效，则抛出ParseException。
在示例程序中试验一下IP地址文本框，如果你键入了无效的地址，那么这个文本框就会恢复到最后一个有效的地址，完整的格式器见程序清单6-22。
程序清单6-20展示了各种格式化的文本框（参见图6-37），点击OK按钮可以从这些文本框中获取当前的值。
注意：“Swing Connection”在线通讯有一篇短文描述了一个可以与任何正则表达式匹配的格式器。参见http://www.oracle.com/technetwork/java/reftf-138955.html。
图6-37　FormatTest程序
程序清单6-20　textFormat/FormatTestFrame.java
程序清单6-21　textFormat/IntFilter.java
程序清单6-22　textFormat/IPAddressFormatter.java
javax.swing.JFormattedTextField 1.4
·JFormattedTextField（Format fmt）
构建使用指定格式的文本框。
·JFormattedTextField（JFormattedTextField.AbstractFormatter formatter）
构建使用指定格式器的文本框。注意，DefaultFormatter和InternationalFormatter都是JFormattedTextField.AbstractFormatter的子类。
·Object getValue（）
返回文本框当前的有效值。注意，它可能并不对应于正在编辑的字符串。
·void setValue（Object value）
尝试设置给定对象的值。如果格式器不能将该对象转换为字符串，则尝试失败。
·void commitEdit（）
尝试从编辑的字符串中设置文本框的有效值。如
·果格式器不能转换该字符串，则该尝试可能失败。
·boolean isEditValid（）
检查编辑的字符串表示的是否是一个有效值。
·int getFocusLostBehavior（）
·void setFocusLostBehavior（int behavior）
获取或设置“失去焦点”的行为。表示该行为的合法值是JFormattedTextField类的常量COMMIT_OR_REVERT、REVERT、COMMIT和PERSIST。
javax.swing.JFormattedTextField.AbstractFormatter 1.4
·abstract String valueToString（Object value）
将值转换为可编辑的字符串。如果值并不适用于这个格式器，则抛出ParseException。
·abstract Object stringToValue（String s）
将字符串转换为值。如果s格式不合适，则抛出ParseException。
·DocumentFilter getDocumentFilter（）
覆盖该方法以提供可以限制该文本框输入的文档过滤器。null返回值表示不需要任何过滤机制。
javax.swing.text.DefaultFormatter 1.3
·boolean getOverwriteMode（）
·void setOverwriteMode（boolean mode）
获取或设置覆写模式。如果确实处于覆写模式，那么在编辑文本时，新字符会覆写现有字符。
javax.swing.text.DocumentFilter 1.4
·void insertString（DocumentFilter.FilterBypass bypass，int offset，String text，AttributeSet attrib）
在字符串插入到文档中之前被调用。可以覆盖该方法并修改字符串。可以禁止插入，方法是不要调用super.insertString方法，或者是调用bypass方法来修改没有过滤机制的文档。
参数：bypass　这是一个允许我们执行绕开过滤器的编辑命令的对象
offset　插入文本处的偏移量
text　待插入的字符
attrib　待插入文本的格式化属性
·void replace（DocumentFilter.FilterBypass bypass，int offset，int length，String text，AttributeSet attrib）
在文档的部分内容被替换为新字符串之前被调用。可以覆盖该方法并修改字符串。可以禁止替换，方法是不要调用super.replace，或者是调用bypass方法来修改没有过滤机制的文档。
参数：bypass　这是一个允许我们执行绕开过滤器的编辑命令的对象
offset　插入文本处的偏移量
length　被替换部分的长度
text　待插入的字符
attrib　待插入文本的格式化属性
·void remove（DocumentFilter.FilterBypass bypass，int offset，int length）
在文本的部分内容被删除之前被调用。如果需要分析移除的效果，可以通过调用bypass.getDocument（）来获取该文档。
参数：bypass　这是一个允许我们执行绕开过滤器的编辑命令的对象
offset　待移除部分的偏移量
length　待移除部分的长度
javax.swing.text.MaskFormatter 1.4
·MaskFormatter（String mask）
用给定的掩码构建掩码格式器。参见表6-3以了解掩码中的符号。
·String getValidCharacters（）
·void setValidCharacters（String characters）
获取或设置有效的编辑字符。对于掩码中的可变部分，只有位于给定字符串中的字符才是可接受的。
·String getInvalidCharacters（）
·void setInvalidCharacters（String characters）
获取或设置无效的编辑字符。在给定字符串中的任何字符都不能作为输入接受。
char getPlaceholderCharacter（）
void setPlaceholderCharacter（char ch）
获取或设置占位字符，这些字符用作用户未提供的掩码中的可变字符。默认的占位符是空格。
·String getPlaceholder（）
·void setPlaceholder（String s）
获取或设置占位字符串。如果用户没有提供掩码中的所有可变字符，那么就会使用该字符串的末端。如果该字符串为null，或者比掩码短，那么占位符就会填充剩余的输入。
·boolean getValueContainsLiteralCharacters（）
·void setValueContainsLiteralCharacters（boolean b）
获取或设置“值包含字面常量字符”标志。如果该标志为true，那么该文本框的值就包含掩码中的字面常量（不可变）部分。如果该标志为false，那么字面常量字符将被移除。其默认值为true。6.4.3　JSpinner构件
JSpinner是包含一个文本框以及两个在文本框旁边的小按钮的构件。当点击按钮时，文本框的值就会递增或递减（参见图6-38）。
图6-38　JSpinner构件的数种变体
微调器中的值可以是数字、日期、列表中的值，或者是更为普遍的情况，即前驱和后继可以确定的任何值序列。JSpinner类为前三种情况定义了标准的数据模型。我们可以定义自己的数据模型来描述任意的序列。
默认情况下，微调器管理着一个整数，并且两个按钮将对其按照1进行递增和递减。可以通过调用getValue方法来获取当前值，这个方法将返回一个Object，应该将其转型为Integer并获取其中包装的值。
我们可以将递增的值修改为1之外的值，还可以提供递增的上界和下界。下面的微调器的初始值为5，边界为0到10，每次递增0.5：
SpinnerNumberModel有两个构造器，其中一个只有int参数，而另一个有double参数。只要有参数是浮点数，就会使用第二个构造器，它会将微调器的值设置为Double对象。
微调器并未限制为只能是数字型值，我们可以用微调器迭代任何值集合，只需将一个SpinnerListModel传递给JSpinner构造器即可。我们可以从数组或实现了List接口的类（例如ArrayList）中构建SpinnerListModel。在示例程序中，我们显示了一个微调控制器，它的值是所有可用的字体名。
但是，我们发现迭代的方向略有些令人疑惑，因为它与用户关于组合框的体验相关。在组合框中，较高的值在较低的值的下面，因此，我们用向下箭头来导航到较高的值。但是微调器将递增数组索引，使得向上箭头可以产生较高的值。在SpinnerListModel中没有用于颠倒遍历顺序的方法，但是临时创建一个匿名子类就可以产生想要的结果：
试运行这两个版本，看看哪一个更直观些。
微调器的另一个大显身手之处是可以让用户递增或递减的日期。用下面的调用就可以获得这样的微调器，并用当日的时间进行初始化。
但是，如果你仔细查看图6-38，就会发现微调器文本同时显示了日期和时间，例如
时间对于日期选择器来说没有任何意义，而让微调器只显示日期被证明有些困难，下面就是这样的“魔咒”：
使用相同的方法，还可以创建一个时间选择器
通过定义自己的微调器模型，你可以在微调器中显示任意的序列。在示例程序中，我们用一个微调器迭代了字符串“meat”的所有排列。你可以通过点击微调器按钮来获取“mate”、“meta”、“team”以及其他20种排列。
在定义自己的模型时，需要扩展AbstractSpinnerModel类并定义下面的4个方法：
getValue方法将返回模型存储的值，而setValue方法则把这个值设置为新值，如果新值并不适合用于设置，则该方法会抛出IllegalArgumentException。
警告：setValue方法必须在设置新值之后调用fireStateChanged方法，否则，微调器文本框并不会更新。
getNextValue和getPreviousValue方法将分别位于返回当前值之后和之前的值，或者在到达遍历的终点时返回null。
警告：getNextValue和getPreviousValue方法不应该改变当前值。当用户点击微调器的向上箭头时，getNextValue方法就会被调用。如果其返回值不是null，微调器的值会通过一个对setValue的调用进行设置。
在示例程序中，我们使用了标准的算法来确定下一个和前一个排列，而这个算法的细节并不重要（见程序清单6-24）。
程序清单6-23展示了如何生成各种不同的微调器类型，请点击Ok按钮以观察微调器的值。
程序清单6-23　spinner/SpinnerFrame.java
程序清单6-24　spinner/PermutationSpinnerModel.java
javax.swing.JSpinner 1.4
·JSpinner（）
构建一个微调器，它可以编辑从0开始、每次递增1，并且没有边界的整数值。
·JSpinner（SpinnerModel model）
构建一个微调器，它将使用给定的数据模型。
·Object getValue（）
获取微调器的当前值。
·void setValue（Object value）
尝试着设置微调器的值，如果模型不接受这个值，将抛出IllegalArgumentException。
·void setEditor（JComponent editor）
设置用于编辑微调器值的构件。
javax.swing.SpinnerNumberModel 1.4
·SpinnerNumberModel（int initval，int minimum，int maximum，int stepSize）
·SpinnerNumberModel（double initval，double minimum，double maximum，double stepSize）
这些构造器将产生一个管理Integer或Double类型值的数字模型。可以用Integer或Double类的MIN_VALUE和MAX_VALUE常量来表示不受边界限制的值。
参数：initval　值的间距
minimum　最小值
maximum　最大值
stepSize　每次微调的递增或递减量
javax.swing.SpinnerListModel 1.4
·SpinnerListModel（Object[]values）
·SpinnerListModel（List values）
这些构造器将产生从给定的值中选择一个值的模型。
javax.swing.SpinnerDateModel 1.4
·SpinnerDateModel（）
用当日的日期作为初始值构建一个日期模型，在该模型中没有上界和下界，其递增量为Calendar.DAY_OF_MONTH。
·SpinnerDateModel（Date initval，Comparable minimum，Comparable maximum，int step）
参数：initval　初始值
minimum　最小值，在不希望有下界时为null
maximum　最大值，在不希望有上界时为null
step　每次微调递增或递减的日期，它的值是Calendar类的常量ERA、YEAR、MONTH、WEEK_OF_YEAR、WEEK_OF_MONTH、DAY_OF_MONTH、DAY_OF_YEAR、DAY_OF_WEEK、DAY_OF_WEEK_IN_MONTH、AM_PM、HOUR、HOUR_OF_DAY、MINUTE、SECOND或MILLISECOND之一
java.text.SimpleDateFormat 1.1
·String toPattern（）1.2
获取用于这个日期格式器的编辑模式。典型的模式为“yyyy-MM-dd”，参见Java SE文档以了解关于该模式的详细信息。
javax.swing.JSpinner.DateEditor 1.4
·DateEditor（JSpinner spinner，String pattern）
构建一个用于微调器的日期编辑器。
参数：spinner　该编辑器所属的微调器
pattern　用于相关联的SimpleDateFormat的格式化模式
javax.swing.AbstractSpinnerModel 1.4
·Object getValue（）
获取该模型的当前值。
·void setValue（Object value）
尝试着设置用于该模型的新值。如果这个值不可接受，则抛出IllegalArgument Exception。当覆盖该方法时，应该在设置新值之后调用fireStateChanged。
·Object getNextValue（）
·Object getPreviousValue（）
计算（但不是设置）该模型所定义的序列中的下一个和前一个值。6.4.4　用JEditorPane显示HTML
与之前我们讨论的文本构件不同，JEditorPane能够以HTML和RTF的格式显示和编辑文本。（RTF即“富文本格式”，是许多微软应用进行文档交换的格式。它是一种弱文档格式，即使在微软自己的应用之间也无法很好地运行。在本书中我们将不介绍RTF的应用。）
坦白地说，JEditorPane的功能还不尽如人意。HTML绘制器只能显示简单的文件，但是对于在Web上经常出现的复杂页面，它往往难于处理。HTML编辑器不仅功能有限，而且还不稳定。
JEditorPane看似合理的一种应用就是以HTML的形式显示程序的帮助文档。因为你可以控制你提供的帮助文件，所以可以避开JEditorPane不能很好显示的特性。
注意：如果想获得有关业界强度的帮助系统的更多信息，请到网站http://javahelp.java.net上查看JavaHelp。
程序清单6-25中的程序代码包含一个编辑器面板，用于显示HTML页面的内容。在文本框中键入一个URL，该URL必须以http:或file：开头，接着点击Load按钮，选定的HTML页面就会显示到编辑器面板中（参见图6-39）。
图6-39　显示一个HTML页面的编辑器面板
该超链接是活动的：如果你点击一个链接，该应用程序就将其载入。Back按钮可以返回前一页面。
这个程序实际上是一个非常简单的浏览器。当然，它并不具有你期望从商业浏览器可获得的任何舒适特性，例如页面缓冲或者书签列表等。该编辑器面板甚至不能显示Applet。
如果你点击Editable复选框，那么编辑器面板就会成为可编辑的。你可以键入文本，并且可以使用BACKSPACE键删除文本。该构件还能够理解用于剪切、复制以及粘贴的CTRL+X、CTRL+C以及CTRL+V快捷键。不过，还必须进行一些编程来添加对字体和格式的支持。
当该构件变成可编辑的之后，超链接就不是活动的了。另外，对于一些Web页面，在启动编辑模式的时候（参见图6-40），你可以看到JavaScript命令、注释以及其他一些标签。这个示例程序可以让你查看到编辑的特性，但是我们建议在程序中忽略这些特性。
提示：在默认情况下，JEditorPane是处于编辑模式的。可以调用editorPane.setEditable（false）将其关闭。
在该示例程序中所看到的编辑器面板的一些特性是很容易使用的，可以使用setPage方法载入一个新文档。例如，
图6-40　处于编辑模式的编辑器面板
其参数要么是一个字符串，要么是一个URL对象。JEditorPane类继承了JTextComponent类。因此，也可以调用只能显示纯文本的setText方法。
提示：关于setPage是否是在一个单独的线程中载入一个新的文档，它的API文档写得也不是很清楚（这也是通常认为JEditorPane不成功的原因所在）。不过，可以使用下面几条语句在强制一个单独线程中载入：
为了监听超链接的点击事件，需要添加一个HyperlinkListener。HyperlinkListener接口只有一个单一方法hyperlinkUpdate，当用户移到或点击一个超链接的时候，该方法就会被调用。该方法接收一个类型为HyperlinkEvent的数据作为参数。
需要调用getEventType方法以确定发生了什么类型的事件。下面是三种可能的返回值：
第一个值表明用户点击了该超链接。在这种情况下，通常希望打开一个新的链接，可以使用第二个值和第三个值提供可视化的反馈信息，例如，当鼠标停留在一个链接上面，提供一个工具提示。
注意：至于为什么在HyperlinkListener接口里面不用3个独立的方法来处理启动、进入和退出，完全是一件神秘的事情。
HyperlinkEvent类的getURL方法返回超链接的URL。例如，下面展示了怎样安装一个超链接监听器追踪用户激活的链接：
事件处理器直接获得URL，并更新编辑器面板。setPage方法可以抛出一个IOException异常，在这种情况下，我们将一条错误消息作为纯文本进行显示。
程序清单6-25展示了构建一个HTML帮助系统所需的全部特性。从本质上讲，JEditorPane比树和表格构件都要复杂。不过，如果不需要编写定制文本格式的文本编辑器或者绘制器，这些复杂性就会自动对你隐藏起来了。
程序清单6-25　editorPane/EditorPaneFrame.java
javax.swing.JEditorPane 1.2
·void setPage（URL url）
将来自于url的页面导入到编辑器面板中。
·void addHyperlinkListener（HyperLinkListener listener）
为该编辑器面板添加一个超链接监听器。
javax.swing.event.HyperlinkListener 1.2
·void hyperlinkUpdate（HyperlinkEvent event）
无论何时，只要选定了一个超链接，该方法就会被调用。
javax.swing.event.HyperlinkEvent 1.2
·URL getURL（）
返回所选超链接的URL。6.5　进度指示器
在随后的几节中，我们将讨论三个类，用于指示耗时较长活动的进度。JProgressBar是一个用于指示进度的Swing构件；ProgressMonitor是一个包含进度条的对话框；在读取流的时候，ProgressMonitorInputStream用于显示进度监视器对话框。6.5.1　进度条
进度条只不过是一个矩形构件，它被部分地填充了颜色以指示一个操作的进度。默认情况下，进度是用字符串“n%”来指示的。在图6-41右下方，你可以看到一个进度条。
图6-41　进度条
通过提供最大值和最小值以及一个可供选择的定位方向，就可以像构建一个滑动条那样构建一个进度条：
也可以使用setMinimum和setMaximum方法来设置最大值和最小值。
和滑动条不同的是，进度条不能让用户自行调节。你的程序必须调用setValue才能对它进行更新。
如果调用
那么进度条会计算出某项操作完成的百分比，然后以一个“n%”形式的字符串将它显示出来。如果你想以不同形式的字符串将它显示出来，可以用setString方法提供该字符串：
程序清单6-26展示了一个进度条，用于监视一个耗时的模拟活动。
SimulatedActivity类将值current每秒钟增加10倍。每当它达到目标值的时候，该任务就结束。我们使用SwingWorker类实现了这项任务并在process方法中更新了进度条，而SwingWorker是在事件分发线程中调用方法的，这样它就可以安全地更新进度条了。（有关Swing中线程安全的更多信息请参见第Ⅰ卷第14章。）
Java SE 1.4增加了对不确定进度条的支持，这种进度条能够以动画显示某种类型的进度，而不具体显示完成情况的百分比。可以在你的浏览器中看到这种类型的进度条，它指示浏览器正在等待服务器，但是无法知道到底可能要等待多久。如果要以动画显示“不确定等待”，请调用setIndeterminate方法。
程序清单6-26显示了这个程序的完整代码。
程序清单6-26　progressBar/ProgressBarFrame.java
6.5.2　进度监视器
进度条是一个很简单的构件，可以放在一个窗体中。相比之下，ProgressMonitor是一个完整的包含进度条的对话框（参见图6-42）。这个对话框还包含一个Cancel按钮，如果点击该按钮，那么将会关闭监视器对话框。另外，程序还可以查询用户是否已经取消对话框并终止了监视活动。（注意：这个类的类名并不是以“J”开头的。）
图6-42　一个进度监视器对话框
通过提供下面这些信息，就可以构建一个进度监视器：
·在其上弹出对话框的父构件。
·在对话框上显示的一个对象（可能是一个字符串、图标或者是一个构件）。
·在对象下面显示的一个可选注释。
·最大值以及最小值。
不过，进度监视器无法自己测量进度或者取消活动。因此，仍须定时调用setProgress方法设置进度值。（该方法等价于JProgressBar类的setValue方法。）在取消监视器活动的时候，请调用close方法来撤销对话框。还可以再次调用start重新使用该对话框。
使用进度监视器的最大问题在于处理取消请求，因为我们不能将一个事件处理器附加到Cancel按钮上，而是应该周期性地调用isCancel方法来观察程序用户是否按下了Cancel按钮。
如果工作线程可以无限地阻塞下去（例如，在从网络连接中读取输入时），那么它就不能监视Cancel按钮。在我们的示例程序中，我们展示了如何使用定时器来达到此目的，另外，我们还让定时器负责更新对进度的度量。
如果运行一下程序清单6-27中的程序，你会观察到进度监视器对话框有一个很有趣的特性。该对话框不会立即出现，相反地，它会等待一小段时间看看活动是否已经完成，或者是否可能在比对话框出现所需时间更短的时间内完成。
使用setMillisToDecideToPopup方法可以设置在构建对话框对象和确定是否显示弹出对话框之间需要等待的毫秒数，默认值是500毫秒。setMillisToPopup是你估计对话框弹出所需的时间，Swing设计者将这个值默认设置为2秒。很显然，他们考虑了这个事实，即Swing对话框不总是按照我们希望的那样立即显示出来。最好不要修改这个值。
程序清单6-27　progressMonitor/ProgressMonitorFrame.java
6.5.3　监视输入流的进度
Swing包有一个很有用的流过滤器，ProgressMonitorInputStream，它可以自动弹出一个对话框，监视已经从流中读取了多少。
这个过滤器很容易使用。可以在常见的过滤流序列之间插入ProgressMonitorInput Stream。（请参阅第1章关于流的更多详细细节。）
例如，假定你现在要从一个文件中读取文本。首先要使用一个FileInputStream：
通常情况下，要将in转换成一个InputStreamReader：
但是，为了监视这个流，首先要将这个文件输入流转换成一个具有进度监视器的数据流：
你要提供一个父构件、一个标题，当然还有要监视的流。进度监视器流的read方法只能传输字节和更新进度对话框。
现在可以开始着手构建你的过滤器序列：
这就是我们要做的全部内容。当读取文件的时候，进度监视器会自动弹出（参见图6-43）。这是一个流过滤的极佳应用。
图6-43　用于输入流的进度监视器
警告：进度监视器流使用InputStream类的available方法来确定流中的总字节数。但是，available方法只报告流中不阻塞即可访问字节数。进度监视器适用于文件以及HTTP URL，因为它们的长度都是事先可以知道的，但它并不适用于所有的流。
程序清单6-28中的程序可以计算文件中的行数。如果读取的是一个大型文件（例如附带的代码中的gutenberg目录中的“The Count of Monte Cristo”），那么将会弹出进度对话框。
如果用户单击Cancel按钮，输入流就会关闭。因为处理输入的代码已经知道了应该如何处理输入结束，所以处理取消请求并不需要对编程逻辑做任何修改。
注意，该程序并没有使用很高效的方式来填充文本区域。如果首先将文件读取到一个StringBuffer中，然后将文本区域的文本设置为字符串缓冲的内容，可能会更快一些。不过，在这个示例程序中，我们实际上喜欢这种缓慢的方式，因为它可以让你有更多的时间欣赏进度对话框。
为了避免闪烁，我们并不显示正在进行填充的文本区域。
程序清单6-28　progressMonitorInputStream/TextFrame.java
javax.swing.JprogressBar 1.2
·JProgressBar（）
·JProgressBar（int direction）
·JProgressBar（int min，int max）
·JProgressBar（int direction，int min，int max）
按照给定的方向、最小值以及最大值构建一个滑动条。
参数：direction　SwingConstants.HORIZONTAL或者SwingConstants.VERTICAL其中之一。默认值是水平方向
min，max　进度条的最大值和最小值。默认值是0和100
·int getMinimum（）
·int getMaximum（）
·void setMinimum（int value）
·void setMaximum（int value）
获取并设置最小值以及最大值。
·int getValue（）
·void setValue（int value）
获取并设置当前的值。
·String getString（）
·void setString（String s）
获取并设置在进度条中显示的字符串。如果该字符串为null，那么将会显示一个默认字符串“n%”。
·boolean isStringPainted（）
·void setStringPainted（boolean b）
获取并设置“字符串绘制”属性。如果这个属性是true，那么会在进度条的上面绘制出一个字符串。默认值是false。
·boolean isIndeterminate（）1.4
·void setIndeterminate（boolean b）1.4
获取并设置“不确定”属性。如果该属性是true，那么该进度条就会变成一个前后移动的滑动块，表明一个持续时间不可知的等待。默认值是false。
javax.swing.ProgressMonitor 1.2
·ProgressMonitor（Component parent，Object message，String note，int min，int max）
构建一个进度监视器对话框。
参数：parent　父构件，在其上弹出对话框
message　对话框中要显示的消息对象
note　在消息下显示的可选字符串。如果该值为null，则不会为注释设置任何空间，并且随后对setNote的调用不会产生任何效果
min，max　进度条的最小值以及最大值
·void setNote（String note）
更改注释文本。
·void setProgress（int value）
将进度条的值设置为给定值。
·void close（）
关闭对话框。
·boolean isCanceled（）
如果用户取消了对话框，则返回true。
javax.swing.ProgressMonitorInputstream 1.2
·ProgressMonitorInputStream（Component parent，Object message，InputStream in）
用相关联的进度监视器对话框构建一个输入流过滤器。
参数：parent　父构件，在其上弹出对话框
message　在对话框中显示的消息对象
in　正被监视的输入流6.6　构件组织器和装饰器
我们在这里通过展示一些帮助组织其他构件的构件来结束对高级Swing特性的讨论。这些构件包括分割面板、选项卡面板以及桌面面板。分割面板是将一个区域分割成多个边界可调整的区域的一种机制。选项卡面板使用选项卡分割器，允许用户浏览多个面板。桌面面板可用来实现显示多个内部框体的应用。最后，我们将讨论层，即可以叠加在其他构件之上的装饰器。6.6.1　分割面板
分割面板可以将一个构件分割成两部分，并且这两部分之间具有可调整的边界。图6-44显示了一个具有两个分割面板的框体。外部面板中的构件是垂直布局的，底部是一个文本区，上面是另外一个分割面板。上面这个分割面板是水平分割的，左边是一个列表，右边是一个包含图形的标签。
如果要构建一个分割面板，需要设定一个方向，其值为JSplitPane.HORIZONTAL_SPLIT和JSplitPane.VERTICAL_SPLIT中的之一，随后是两个构件。例如：
这就是你要做的全部事情。如果你喜欢，可以为分割器添加“一触即展”的图标。你可以在图6-44中的顶层面板中看到这些图标。在Metal外观模式中，它们是小箭头的形式。如果你点中它们中的一个，那么分割器将会一直沿着箭头指定的方向移动，将其中的一个面板完全展开。
图6-44　具有两个嵌套的分割面板的框体
如果要添加这项功能，请调用：
当用户调整分割器的时候，“连续布局”特性会一直不断地刷新这两个构件的内容。这种情形看似经典，实则运行缓慢。你可以调用下面这个方法启动该功能：
在这个示例程序中，我们将分割器设为默认状态（非连续布局）。拖动它的时候，只能移动一个黑色的轮廓。当释放鼠标完成这项操作时，才会刷新这些构件。
在简单明了的程序清单6-29中，组装了一个具有行星数据的列表框。当用户进行选择的时候，行星的图片便在右边显示了出来，并且在底部的文本区显示出对它的描述。当你运行这个程序的时候，请调整一下分割器，并试试一触即展和连续布局这些特性。
程序清单6-29　splitPane/SplitPaneFrame.java
javax.swing.JSplitPane 1.2
·JSplitPane（）
·JSplitPane（int direction）
·JSplitPane（int direction，boolean continuousLayout）
·JSplitPane（int direction，Component first，Component second）
·JSplitPane（int direction，boolean continuousLayout，Component first，Component second）
构建一个新的分割面板。
参数：direction　HORIZONTAL_SPLIT或VERTICAL_SPLIT
continousLayout　如果为true，那么当移动分割器时，该构件是连续更新的
first，second　要添加的构件
·boolean isOneTouchExpandable（）
·void setOneTouchExpandable（boolean b）
获取并设置“一触即展”属性。如果设置了该属性，那么该分割器具有两个图标以完全展开分割面板某一侧的构件。
·boolean isContinuousLayout（）
·void setContinuousLayout（boolean b）
获取并设置“连续布局”属性。如果设置了该属性，那么当移动分割器的时候，该构件是连续更新的。
·void setLeftComponent（Component c）
·void setTopComponent（Component c）
这两个操作具有同等效果，用于将c设置为分割面板中第一个构件。
·void setRightComponent（Component c）
·void setBottomComponent（Component c）
这两个操作具有同等效果，用于将c设置为分割面板中第二个构件。6.6.2　选项卡面板
选项卡面板是一种大家都很熟悉的用户界面设施，它可以将一个复杂的对话框分割成相关选项的子集，也可以使用选项卡让用户浏览一组文档或图像（参见图6-45）。这也是我们在示例程序中要讲解的。
图6-45　一个选项卡面板
为了创建一个选项卡面板，首先要构建一个JTabbedPane对象，然后向其中添加选项卡。
addTab方法最后一个参数的类型为Component。为了向同一个选项卡中添加多个构件，首先要将这些构件包装到一个容器中，例如一个JPanel。
该方法中的图标参数是一个可选项。addTab方法并非一定要有一个图标参数，例如：
也可以使用insertTab方法，将一个选项卡添加到选项卡集中：
如果要从选项卡集中删掉一个选项卡，请使用
向选项集中添加一个新的选项卡时，并不能自动将其显示出来，必须使用setSelected Index方法选定它。例如，下面这段代码展示了怎样将刚刚添加到末尾的选项卡显示出来：
如果有很多选项卡，那么它们会占用很多空间。从Java SE 1.4开始，可以将选项卡以滚动模式显示出来，在这种模式中，只显示一行面板，但是会配有一组箭头允许用户滚动显示这些选项卡（参见图6-46）。
图6-46　具有滚动选项卡的选项卡面板
调用下面这个方法，就可以将选项卡布局设置为隐藏格式或者滚动模式：
或者
选项卡标签可以有快捷键，就像菜单项一样。例如：
之后M就会有下划线，而程序用户可以通过键入ALT+M来选择选项卡。
可以在选项卡标题栏中添加任何构件，此时，首先需要添加选项卡，然后调用：
在我们的示例程序中，我们向Pluto选项卡中添加了一个“关闭框”（因为毕竟有些天文学家不认为冥王星算得上一颗真正的行星）。实现这项任务的方法是将选项卡构件设置为包含两个构件的面板：具有图标和选项卡文本的标签，以及具有能够移除该选项卡的动作监听器的复选框。
这个示例程序展示了选项卡面板一个非常有用的技术。有时候需要在一个构件显示之前对其进行更新。在我们这个示例程序中，只在用户真正点击一个选项卡的时候才将行星图片载入。
为了在用户任何时候点击一个新选项卡时都能获得通知，需要为选项卡面板安装一个ChangeListener。注意，必须为选项卡面板本身添加监听器，而不是它所包含的任何一个选项卡构件。
当用户选定一个选项卡时，就会调用修改监听器的stateChanged方法。可以将选项卡面板作为事件源来读取，并调用getSelectedIndex方法就可以查明将要显示哪个面板。
在程序清单6-30中，我们首先将选项卡构件设置为null。当选定一个新的面板时，我们会测试它的构件是否仍为null。如果为null，我们会用一个图片替代显示。（这种情况在点击一个选项卡的那一瞬间发生，你将不会看到任何空的面板。）只是为了有趣，我们还将这个图标从黄色球更改为红色球以指示我们已经访问过的那些面板。
程序清单6-30　tabbedPane/TabbedPaneFrame.java
javax.swing.JTabbedPane 1.2
·JTabbedPane（）
·JTabbedPane（int placement）
构建一个选项卡面板。
参数：placement SwingConstants.TOP、SwingConstants.LEFT、SwingConstants.RIGHT或SwingConstants.BOTTOM其中之一
·void addTab（String title，Component c）
·void addTab（String title，Icon icon，Component c）
·void addTab（String title，Icon icon，Component c，String tooltip）
向选项卡面板的末尾添加一个选项卡。
·void insertTab（String title，Icon icon，Component c，String tooltip，int index）
在选项卡面板的给定索引处添加一个选项卡。
·void removeTabAt（int index）
移除指定索引处的选项卡。
·void setSelectedIndex（int index）
选定给定索引处的选项卡。
·void getSelectedIndex（）
获取选定的选项卡的索引。
·Component getSelectedComponent（）
返回选定的选项卡构件。
·String getTitleAt（int index）
·void setTitleAt（int index，String title）
·Icon getIconAt（int index）
·void setIconAt（int index，Icon icon）
·Component getComponentAt（int index）
·void setComponentAt（int index，Component c）
获取或设置给定索引处的标题、图标或者构件。
·int indexOfTab（String title）
·int indexOfTab（Icon icon）
·int indexOfComponent（Component c）
返回具有给定的标题、图标或者构件的索引。
·int getTabCount（）
返回该选项卡面板上的选项卡总数。
·int getTabLayoutPolicy（）
·void setTabLayoutPolicy（int policy）1.4
获得或者设置选项卡布局策略。policy是JTabbedPane.WRAP_TAB_LAYOUT或JTabbedPane.SCROLL_TAB_LAYOUT其中之一。
·int getMnemonicAt（int index）1.4
·void setMnemonicAt（int index，int mnemonic）
获得或者设置给定选项卡索引的快捷字符。这个字符是作为KeyEvent类的一个VK_X常量指定的，-1表示没有快捷方式。
·Component getTabComponentAt（int index）6
·void setTabComponentAt（int index，Component c）6
获得或者设置构件，用于绘制给定索引的选项卡的标题栏。如果该构件为null，则绘制选项卡的图标和标题，否则，在选项卡中只绘制给定的构件。
·int indexOfTabComponent（Component c）6
返回具有给定标题栏构件的选项卡的索引。
·void addChangeListener（ChangeListener listener）
添加一个修改监听器，当用户选定了另一个选项卡的时候，会通知它。6.6.3　桌面面板和内部框体
很多应用会将信息在多个窗口中显示，并且这些窗口都包含在一个大的框体中。如果将应用框体最小化，那么它当中的所有窗口会在同一时间全部隐藏起来。在Windows环境中，这种用户界面有时称作多文档界面（multiple document interface，MDI）。图6-47显示了一个使用到该界面的典型应用程序。
图6-47　一个多文档界面的应用
有一段时间，这种用户界面格式非常流行，不过最近几年已经变得不那么常用了。现在，很多应用为每个文档只显示一个独立的顶层框体。哪一种格式更好呢？MDI减少了窗口的混乱，但是如果拥有了独立的顶层窗口，意味着可以使用主窗口系统的按钮及热键浏览所有窗口。
在Java环境中，不能完全依赖于主机窗口系统提供的功能，让你的应用管理它自己的框体还是很有必要的。
图6-48显示了一个具有三个内部框体的Java应用程序，其中的两个有一些边框装饰，用于对它们进行最大化和图标显示，第三个已经处于图标状态。
在Metal外观模式中，内部框体具有独一无二的“grabber”区域，可以让你随意移动这些框体，并可以通过拖动调整大小的角来更改窗口的大小。
为了实现这项功能，请遵循下面几步：
1）在该应用中使用常规的JFrame。
2）向该JFrame添加JDesktopPane。
图6-48　具有三个内部框体的Java应用程序
3）构建JInternalFrame窗口，可以设定是否需要更改框体大小和关闭框体的图标。通常情况下，需要添加所有的图标。
4）向该内部框体中添加构件。
5）设置该内部框体的图标。该图标会显示在框体左上角。
注意：在Metal外观模式的当前版本中，框体图标并不在图标化的框体中显示出来。
6）设置内部框体的大小。和常规框体一样，内部框体初始大小为0×0个像素。因为你并不希望内部框体在另一个框体上面重叠地显示出来，因此，应该为下一个框体使用一个变量位置。使用reshape方法对框体的位置和大小进行设置：
7）和JFrames一样，需要将该框体设为可见的。
注意：在Swing的早期版本，内部框体自动是可见的，因此就不需要调用这个方法了。
8）将该框体添加到JDesktopPane中：
9）你可能想使新的框体成为选定框体。对于桌面上的内部框体，只有选定的框体才能接收键盘焦点。在Metal外观模式中，选定框体具有蓝色标题栏，相反地，其他框体是灰色标题栏。可以使用setSelected方法选定一个框体。不过，这种“选定”属性可能会被否决掉，当前选定的框体可以拒绝放弃焦点。在这种情况下，setSelected方法会抛出一个PropertyVetoException异常让你处理。
10）你可能希望下一个内部框体的位置能够向下移动，使得不至于覆盖已经存在的框体。框体之间的合适距离是标题栏的高度，可以通过下面的方式获得。
11）使用该距离确定下一个内部框体的位置。
6.6.4　级联与平铺
在Windows环境中，有一些用于级联及平铺窗口的标准命令（参见图6-49及图6-50）。Java语言的JDesktopPane类和JInternalFrame类对这些操作未提供任何内置支持。在程序清单6-31中，我们将展示如何实现这些操作。
图6-49　级联的内部框体
图6-50　平铺的内部框体
为了级联所有的窗口，可以将这些窗口重新绘制成同样的大小，并交错排列它们的位置。JDesktopPane类的getAllFrames方法可以返回一个所有内部框体的数组。
不过，要注意一下框体的状态。一个内部框体可以具有下面三种状态之一：
·图标
·可放缩
·最大化
可以使用isIcon方法确定哪些内部框体当前是处于图标状态，因而应该跳过。但是，如果一个框体处于最大状态，那么首先要通过调用setMaximum（false）方法将它设置为可放缩状态。这是另外一个可能被否决掉的属性，因此你必须捕获PropertyVetoException异常。
下面这个循环用于级联一个桌面上的所有内部框体：
平铺框体更具技巧性，尤其是当框体数不是一个完全平方数时。首先，计算出不是图标的框体数。然后，按照下面的方法计算行数：
然后是计算列数：
除了最后一列是：
其余每列的行数是rows+1。
下面这个循环用于平铺桌面上的所有内部框体：
这个示例程序演示了另一个常用的框体操作：将所选择的框体从当前框体转换为下一个非图标框体。此时，首先遍历所有的框体并调用isSelected方法，直到发现当前选定的框体为止。然后，查找框体序列中下一个非图标框体，进而通过如下调用选中它：
正如前面那样，该方法会抛出一个PropertyVetoException异常，在这种情况下，需要一直进行监视。如果返回到原先那个框体，那么其他任何框体都无法选定，因此只有放弃。下面是完整的循环代码：
6.6.5　否决属性设置
到现在为止，你已经看到所有这些否决异常，那么你可能会问，框体是怎样发布一个否决的呢？JInternalFrame类使用很普遍的JavaBean机制来监视这些属性设置。我们会在第8章详细讨论该机制。但是现在，我们只想展示框体是怎样对属性更改发送否决请求的。
框体通常并不想使用否决机制以抗议将窗口图标化或失去焦点，但是对于框体来说，检查它们是不是可以关闭则是很常见的。可以使用JInternalFrame类的setClosed方法关闭一个窗口。因为该方法是可否决的，因此在进行更改之前，它会调用所有已注册的可否决的更改监听器（vetoable change listener）。这样就赋予每个监听器抛出一个PropertyVetoException异常的机会，并且在它更改任何设置之前，终止对setClosed的调用。
在我们的示例程序中，我们建立了一个对话框，以询问用户是否可以关闭窗口（参见图6-51）。如果用户不同意关闭窗口，那么该窗口仍旧保持打开状态。
下面就说说要怎样才能实现这样一个通知机制。
1）为每个框体添加一个监听器对象。该监听器对象必须属于实现了VetoableChangeListener接口的某个类。最好是在刚构建完这个框体时就添加监听器。在我们的示例程序中，我们是使用框体类来构建内部框体的。另外一种选择是使用一个匿名内部类进行构建。
2）实现vetoableChange方法，该方法是VetoableChangeListener接口惟一要求要实现的方法。该方法接收一个PropertyChangeEvent对象，使用getName方法查找将要更改的属性的名称（例如，如果该方法调用要否决的方法是setClosed（true），那么属性名就是“closed”）。正如你将在第8章看到的那样，通过移除方法名的“set”前缀，并且将后面的字母变为小写，便可获得属性名。
图6-51　用户可以否决关闭属性
3）使用getNewValue方法获取建议使用的新值。
4）直接通过抛出一个PropertyVetoException异常来阻止属性修改。如果不想否决更改，则正常返回。
1.内部框体中的对话框
如果使用内部框体，那么不应该将JDialog类用作对话框。因为，这些对话框有两个缺点：
·它们是重量级的，因为它们是在窗口系统中创建了一个新的框体。
·窗口系统并不知道应该如何确定这些对话框与派生出它们的内部框体之间的相对位置。
相反地，对于简单的对话框，请使用JOptionPane类的showInternalXxxDialog方法。除了它们是在内部框体上放置一个轻量级窗口外，它们的运行特性和showXxxDialog方法极为相似。
对于更复杂的对话框，请使用一个JInternalFrame来构建。遗憾的是，这样你就无法使用任何对模式对话框的内置支持了。
在我们的示例程序中，我们使用了一个内部对话框，以询问用户是否可以关闭某个窗口。
注意：如果只是想在关闭一个框体时能够得到通知，那么就应该不使用否决机制。相反地，应该安装一个InternalFrameListener监听器。内部框体监听器和WindowListener监听器运行特性极为相似。当关闭一个内部框体时，调用的是internalFrameClosing方法，而不是大家所熟悉的windowClosing方法。其他六个内部框体的通知（打开/关闭，图标化/非图标化，激活/钝化）也对应于窗口监听器的相应方法。
2.边框拖拽
程序开发人员反对内部框体的原因之一是：它的性能不是很好。最缓慢的操作就是在桌面上拖拽具有复杂内容的框体。在拖动框体的过程中，桌面管理器会不断要求框体重新绘制，这样就导致其速度非常缓慢。
实际上，如果使用的Windows或者X Windows的视频驱动程序编写得比较差的话，你会遇到同样的问题。在大多数系统上，窗口拖动的运行速度看起来都很快，因为视频硬件支持拖动操作，在拖动过程中，可以将框体中的图像映射到屏幕别的位置上。
为了提高性能，而又不明显损害用户体验，可以设置“边框拖拽”。当用户拖动框体时，只有框体的边框是连续更新的。框体里面的内容只有当用户将框体拖动到它的最终停止位置上的时候才会刷新。
为了启动边框拖动，请调用
这个设置等价于JSplitPane类的“连续布局”。
注意：在Swing的早期版本中，必须使用下面这句“魔咒”开启边框拖拽：
在示例程序中，可以使用Window→Drag Outline复选框菜单选项，来开启或关闭边框拖拽。
注意：桌面上的内部框体由DesktopManager类负责管理，你并不需要知道该类是怎样用于常规编程的。通过安装一个新的桌面管理器，就可以实现不同的桌面行为，不过我们在这里将不做介绍。
在程序清单6-31的桌面中嵌入了一个用于显示HTML页面的内部框体。执行File→Open菜单选项，会弹出一个文件对话框用于将一个本地HTML文件读取到一个新的内部框体中。如果点击了任何一个链接，那么该链接文档便会在另外一个内部框体中显示出来。请试运行一下Window→Cascade和Window→Tile命令。
程序清单6-31　internalFrame/DesktopFrame.java
javax.swing.JDesktopPane 1.2
·JInternalFrame[]getAllFrames（）
获取该桌面面板中的所有内部框体。
·void setDragMode（int mode）
将拖动模式设置为实况拖动模式或边框拖动模式。
参数：mode　JDesktopPane.LIVE_DRAG_MODE、JDesktopPane.OUTLINE_DRAG_MODE其中之一
javax.swing.JInternalFrame 1.2
·JInternalFrame（）
·JInternalFrame（String title）
·JInternalFrame（String title，boolean resizable）
·JInternalFrame（String title，boolean resizable，boolean closable）
·JInternalFrame（String title，boolean resizable，boolean closable，boolean maximizable）
·JInternalFrame（String title，boolean resizable，boolean closable，boolean maximizable，boolean iconifiable）
构建一个新的内部框体。
参数：title　标题栏显示的字符串
resizable　如果该框体可放缩，则为true
closable　如果框体可以关闭，则为true
maxmizable　如果该框体可以最大化，则为true
iconifiable　如果该框体可以图标化，则为true
·boolean isResizable（）
·void setResizable（boolean b）
·boolean isClosable（）
·void setClosable（boolean b）
·boolean isMaximizable（）
·void setMaximizable（boolean b）
·boolean isIconifiable（）
·void setIconifiable（boolean b）
获取并设置属性resizable、closable、maximizable以及iconifiable。如果该属性为true，那么在框体的标题栏处会显示一个图标，用于缩放、关闭、最大化或者图标化该内部框体。
·boolean isIcon（）
·void setIcon（boolean b）
·boolean isMaximum（）
·void setMaximum（boolean b）
·boolean isClosed（）
·void setClosed（boolean b）
获取或设置icon、maximum或者closed属性。如果该属性为true那么该内部框体可以图标化、最大化以及关闭。
·boolean isSelected（）
·void setSelected（boolean b）
获取或设置selected属性。如果该属性为true，那么当前的内部框体就成为桌面上被选定的框体。
·void moveToFront（）
·void moveToBack（）
将该内部框体移到桌面的前面或后面。
·void reshape（int x，int y，int width，int height）
参数：xy　框体的左上角
width，height　框体的宽度及高度
·Container getContentPane（）
·void setContentPane（Container c）
获取并设置该内部框体的内容面板。
·JDesktopPane getDesktopPane（）
获取该内部框体的桌面面板。
·Icon getFrameIcon（）
·void setFrameIcon（Icon anIcon）
获取并设置显示在标题栏中的框体图标。
·boolean isVisible（）
·void setVisible（boolean b）
获取并设置“可见”属性。
·void show（）
将该内部框体设为可视的，并将它移到前面。
javax.swing.JComponent 1.2
·void addVetoableChangeListener（VetoableChangeListener listener）
添加一个可否决更改监听器，当试图更改一个受约束属性的时候，会将更改信息通告给它。
java.beans.VetoableChangeListener 1.1
·void vetoableChange（PropertyChangeEvent event）
当受约束属性的set方法通知可否决更改监视器的时候，调用该方法。
java.beans.PropertyChangeEvent 1.1
·String getPropertyName（）
返回将要被更改的属性的名称。
·Object getNewValue（）
返回建议用于该属性的新值。
java.beans.PropertyVetoException 1.1
·PropertyVetoException（String reason，PropertyChangeEvent event）
构建一个属性否决异常。
参数：reason　否决的原因
event　被否决的事件
3.层
Java SE 1.7引入了一个新特性，使得你可以将一个层置于其他构件之上。你可以在层上进行绘制，并监听其底层构件的事件。使用层可以为用户界面添加可视化的提示线索。例如，可以装饰当前的输入、无效的输入或禁用的构件。
JLayer类将一个构件与某个LayerUI对象关联在一起，而后者将负责绘制和事件处理。LayerUI类应该有一个必须与所关联的构件相匹配的类型参数。例如，下面的代码在一个JPanel中添加了一个层：
注意，这段代码向父面板添加的是层而不是面板，其中，PanelLayer是一个子类：
在paint方法中，可以绘制任意想要绘制的东西，但是要记住需要调用super.paint以确保构件被正确绘制。这里，我们在整个构件上绘制了透明的颜色：
为了监听来自所关联构件或其任意儿子构件的事件，LayerUI类必须设置层事件掩码，这应该在installUI方法中完成，就像下面这样：
现在就可以在名为processXxxEvent的方法中接收事件了。例如，在我们的示例应用中，每当有键盘输入时，就会重绘层：
程序清单6-32中的示例程序有三个输入框，用来设置颜色的RGB值。无论何时，只要用户改变了这些值，对应的颜色就会透明地显示在面板上。我们还捕获了焦点事件，并以粗体字显示了获得焦点的构件的文本。
程序清单6-32　layer/ColorFrame.java
javax.swing.JLayer<V extends Component>7
·JLayer（V view，LayerUI<V>ui）
构建在给定视图之上的层，将绘制和事件处理职责代理给ui对象。
·void setLayerEventMask（long layerEventMask）
开启所有匹配事件的发送机制，将所有发送给所关联的构件或其任意子孙构件的事件发送给相关联的LayerUI。对于事件掩码，可以组合AWTWEvent类中的以下任意常量：
javax.swing.plaf.LayerUI<V extends Component>7
·void installUI（JComponent c）
·void uninstallUI（JComponent c）
当为构件c安装或卸载LayerUI时调用。覆盖该方法时，应该设置或清除层事件掩码。
·void paint（Graphics g，JComponent c）
当装饰的构件被绘制时调用。覆盖该方法时，应该调用super.paint并绘制各种装饰。
·void processComponentEvent（ComponentEvent e，JLayer<？extends V>l）
·void processFocusEvent（FocusEvent e，JLayer<？extends V>l）
·void processHierarchyBoundsEvent（HierarchyEvent e，JLayer<？extends V>l）
·void processHierarchyEvent（HierarchyEvent e，JLayer<？extends V>l）
·void processInputMethodEvent（InputMethodEvent e，JLayer<？extends V>l）
·void processKeyEvent（KeyEvent e，JLayer<？extends V>l）
·void processMouseEvent（MouseEvent e，JLayer<？extends V>l）
·void processMouseMotionEvent（MouseEvent e，JLayer<？extends V>l）
·void processMouseWheelEvent（MouseWheelEvent e，JLayer<？extends V>l）
当指定事件发送到该LayerUI时被调用。
你已经看到了可以如何使用Swing框架提供的复杂构件。在下一章，我们将转向AWT相关的话题：复杂的绘制操作、图像处理、打印机制以及与本地窗口系统的接口机制等。