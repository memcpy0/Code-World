@[toc]

▲ 为什么要使用泛型程序设计
▲ 定义简单泛型类
▲ 泛型方法
▲ 类型变量的限定
▲ 限制和局限性
▲ 泛型类型的继承规则
▲ 通配符类型
▲ 反射和泛型
▲ 泛型代码和虚拟机

Java 5.0中泛型的引入，成为Java自最初发行以来最显著的变化。增加泛型机制的主要原因是，为了满足在1999年制定的、最早的Java规范需求之一（JSR 14）。专家组花费了5年左右的时间用来定义规范和测试实现。

**泛型类和泛型方法有类型参数，这使得它们可以准确描述用特定类型实例化时会发生什么**。泛型正是我们需要的程序设计手段，使用泛型机制编写的程序代码，要比那些杂乱地使用 `Object` 变量、然后再进行强制类型转换的代码，具有更好的安全性和可读性。

随着泛型 *generics* 的引入，Java有了一个表述能力很强的类型系统，允许设计者详细地描述**变量和方法的类型要如何变化**。对于简单的情况，会发现实现泛型代码很容易；不过在更高级的情况下，对于实现者来说会相当复杂。其目标是，提供让其他程序员可以轻松使用的类型和方法、而不会发生意外。

**泛型对于集合类尤其有用**，例如，`ArrayList` 就是一个无处不在的集合类。至少在表面上看来，泛型很像C++中的模板。与Java—样，在C++中，模板也是最先被添加到语言中支持强类型集合的。但是，多年之后人们发现模板还有其他的用武之地。学习完可以发现Java中的泛型在程序中也有新的用途。

Java的一个主要设计目标是**支持与之前版本的兼容性**。因此，Java的泛型还有一些让人不快的局限性。
# 8.1 为什么要使用泛型程序设计
泛型程序设计 *Generic programming* 意味着**编写的代码可以对多种不同类型的对象重用**。例如，我们并不希望为收集 `String` 和 `File` 对象分别设计不同的类。实际上，也不需要这样做，因为一个 `ArrayList` 类可以收集 *collect* 任何类型的对象。这是一个泛型程序设计的例子。

实际上，在Java增加泛型类之前已经有一个 `ArrayList` 类。下面来研究**泛型程序设计的机制是如何演变的**，另外还会讲解这对于用户和实现者来说意味着什么。
## 8.1.1 类型参数的好处
在Java中增加范型类之前，泛型程序设计是用**继承**实现的。`ArrayList` 类只维护一个 `Object` 引用的数组：
```java
public class ArrayList { // before generic classes
	private Object[] elementData;
	...
	public Object get(int i) { ... }
	public void add(Object o) { ... }
}
```
这种方法有两个问题。**当获取一个值时必须进行强制类型转换**。
```java
ArrayList files = new ArrayList();
String filename = (String) files.get(0);
```
此外，**这里没有错误检査**。可以向数组列表中添加任何类的对象。对于下面这个调用，编译和运行都不会出错。然而在其他地方，如果将 `get` 的结果强制类型转换为 `String` 类型，就会产生一个错误。
```java
files.add(new File("..."));
```

泛型提供了一个更好的解决方案：类型参数 `type parameters` 。`ArrayList` 类有一个类型参数用来指示元素的类型：
```java
ArrayList<String> files = new ArrayList<String>();
```
这使得代码具有更好的可读性。人们一看就知道这个数组列表中包含的是 `String` 对象。

如果用一个明确的类型而不是 `var` 声明一个变量，则可以通过使用菱形 *diamond* 语法、省略构造器中的类型参数，省略的类型可以从变量的类型推断得出：
```java
ArrayList<String> files = new ArrayList<>();
```
Java 9扩展了菱形语法的使用范围，原型不接受这种语法的地方、现在也可以使用了。例如，现在可以对匿名子类使用菱形语法：
```java
ArrayList<String> passwords = new ArrayList<>() { // diamond OK in Java 9 
	public String get(int n) { 
		return super.get(n).replaceAll(".", "*"); 
	}
};
```

编译器也可以很好地利用这个类型信息。当调用 `get` 的时候，不需要进行强制类型转换，编译器就知道返回值类型为 `String` ，而不是 `Object` ：
```java
String filename = files.get(0);
```
编译器还知道 `ArrayList<String>` 的 `add` 方法有一个类型为 `String` 的参数。这比使用 `Object` 类型的参数安全得多。现在，编译器可以检査，避免插入错误类型的对象。例如：
```java
files.add(new File("...")); // can only add String objects to an ArrayList<String>
```
是无法通过编译的。**出现编译错误比在运行时出现类的强制类型转换异常要好得多**。类型参数的魅力在于：使得程序具有更好的可读性和安全性。
## 8.1.2 谁想成为泛型程序员
使用像 `ArrayList` 的泛型类很容易。大多数Java程序员都会使用 `ArrayList<String>` 这样的类型，就好像它们是Java内置的类型一样，像 `String[]` 数组（当然，数组列表比数组要好，因为它可以自动扩展）。

但是，实现一个泛型类并没有那么容易。使用你的代码的程序员，可能想要插入 `plugin` 各种各样的类作为类型参数。他们希望一切都能正常工作，没有过多的限制以及混乱的错误消息。因此，作为一个泛型程序员，任务就是**预测出你的泛型类所有可能的用法**。

这一任务难到什么程度呢？ 下面是让标准类库的设计者们饱受折磨的一个典型问题。`AirayList` 类有一个方法 `addAll` 用来添加另一个集合的全部元素。程序员可能想要将 `ArrayList<Manager>` 中的所有元素添加到 `ArrayList<Employee>` 中去。当然，反过来就不行了。如何只允许前一个调用，而不允许后一个调用呢？Java语言的设计者发明了一个具有独创性的新概念来解决这个问题——**通配符类型** `wildcard type` 。通配符类型非常抽象，然而利用它们，构建类库的程序员可以编写出尽可能灵活的方法。

泛型程序设计划分为3个能力级别。基本级别是，仅仅使用泛型类—典型的是像 `ArrayList` 这样的集合——不必考虑它们如何工作与原因。大多数应用程序员都希望保持在这一级别上，除非出现了问题。不过，当混合使用不同的泛型类时，或要与对类型参数一无所知的遗留代码交互 *interfacing with legacy code that knows nothing about type parameter* 时，可能会看到令人困惑的错误消息。这样就需要对Java泛型有足够的了解，才能系统地解决这些问题，而不是胡乱猜测。当然，最终你可能想实现自己的泛型类与泛型方法。

应用程序员很可能不会编写太多的泛型代码。JDK开发人员已经做出了很大的努力，为所有的集合类提供了类型参数。凭经验来说 *as a rule of thumb* ，如果代码中原本涉及大量通用类型（如 `Object` 或 `Comparable` 接口）的强制类型转换，只有这些代码会因使用类型参数而受益。

这里介绍**实现自己的泛型代码**需要了解的全部知识，希望可以利用这些知识解决一些疑难问题，并满足对于参数化集合类的内部工作原理的好奇心。

---
# 8.2 定义简单泛型类
**一个泛型类 `generic class` 就是有一个或多个类型变量的类**。使用一个简单的 `Pair` 类作为例子。这个类使我们可以只关注泛型，而不用为数据存储的细节烦恼。下面是 `Pair` 类的代码：
```java
public class Pair<T> {
	private T first;
	private T second;
	
	public Pair() { first = null; second = null; }
	public Pair(T first, T second) { 
		this.first = first; 
		this.second = second; 
	}
	public T getFirst() { return first; }
	public T getSecond() { return second; }
	public void setFirst(T newValue) { first = newValue; }
	public void setSecond(T newValue) { second = newValue; }
}
```
`Pair` 类引入了一个类型变量 `T` ，用尖括号 `<>` 括起来，并放在类名的后面。**泛型类可以有多个类型变量**。例如，可以定义 `Pair` 类，其中第一个字段和第二个字段使用不同的类型：
```java
public class Pair<T, U> { ... }
```
**类型变量在整个类定义中，用于指定方法的返回类型、以及字段和局部变量的类型**。例如，
```java
private T first; // uses the type variable
```
> 注释：**常见的做法是类型变量使用大写形式、而且简短**。Java库使用变量 `E` 表示集合的元素类型，`K` 和 `V` 分别表示表的键与值的类型。`T`（需要时还可以用临近的字母 `U` 和 `S` ）表示“任意类型”。

**用具体的类型替换类型变量，就可以实例化 *instantiate* 泛型类型**，如 `Pair<String>` 。可以认为结果是一个普通类，构造器和方法如下：
```
Pair<String>()
Pair<String>(String, String)
String getFirst()
String getSecond()
void setFirst(String)
void setSecond(String)
```
换句话说，**泛型类可看作普通类的工厂**。

`pair1/PairTest1.java` 程序使用了 `Pair` 类。静态的 `minmax` 方法遍历了数组并同时计算出最小值和最大值。它用一个 `Pair` 对象返回了两个结果。回想一下 `compareTo` 方法比较两个字符串：如果字符串相同则返回0，如果按照字典顺序，第一个字符串比第二个字符串靠前，就返回负值，否则，返回正值。
> C++注释：从表面上看，Java的泛型类类似于C++的模板类。唯一明显的不同是**Java没有专用的 `template` 关键字**。但是，在本章中将会看到，**这两种机制有着本质的区别**。

```java
// pair1/PairTest1.java
package pair1;

public class PairTest1 {
	public static void main(String[] args) {
		String[] words = { "Mary", "had", "a", "little", "lamb" };
		Pair<String> mm = ArrayAlg.minmax(words);
		System.out.println("min = " + mm.getFirst());
		System.out.println("max = " + mm.getSecond());
	}
}

class ArrayAlg {
	/**
	 * Gets the minimum and maximum of an array of strings.
	 * @param a an array of strings
	 * @return a pair with the min and max values, or null if a is null or empty
	 */
	public static Pair<String> minmax(String[] a) {
		if (a == null || a.length == 0) return null;
		String min = a[0];
		String max = a[0];
		for (int i = 1; i < a.length; ++i) {
			if (min.compareTo(a[i]) > 0) min = a[i];
			if (max.compareTo(a[i]) < 0) max = a[i];
		}
		return new Pair<>(min, max);
	}
}
```
---
# 8.3 泛型方法
前面已经介绍了**如何定义一个泛型类**。实际上，还可以**定义一个带有类型参数的简单方法**。
```java
class ArrayAlg {
	public static <T> T getMiddle(T... a) {
		return a[a.length / 2];
	}
}
```
这个方法是在普通类中定义的，而不是在泛型类中。然而，**这是一个泛型方法，可以从尖括号和类型变量看出这一点**。注意，**类型变量放在修饰符（这里是 `public static` ）的后面，返回类型的前面**。泛型方法可以定义在普通类中，也可以定义在泛型类中。

当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：
```java
String middle = ArrayAlg.<String>getMiddle("John", "Q.", "Public");
```
**在这种情况（实际也是大多数情况）下**，方法调用中可以省略 `<String>` 类型参数。**编译器有足够的信息能推断出你想要的方法**。它将参数的类型与泛型类型 `T` 进行匹配，推断出 `T` 一定是 `String` ，也就是说，可以简单地调用：
```java
String middle = ArrayAlg.getMiddle("John", "Q.", "Public");
```
几乎在大多数情况下，泛型方法的类型推导都能正常工作。偶尔，编译器也会提示错误，此时就需要解译错误报告。考虑下面这个示例：
```java
double middle = ArrayAlg.getMiddle(3.14, 1729, 0);
```
错误消息会以晦涩的方式 *in cryptic terms* 指出（不同的编译器给出的错误消息可能有所不同）：解释这句代码有两种方法，而且这两种方法都是合法的。简单地说，**编译器将把参数自动装箱为1个 `Double` 和2个 `Integer` 对象，而后寻找这些类的共同超类型**。事实上，它找到2个这样的超类型：`Number` 和 `Comparable` 接口，`Comparable` 接口本身也是一个泛型类型。在这种情况下，可以采取的补救措施是将所有的参数写为 `double` 值 *the remedy is to write all parameters as double values* 。
> 提示：==如果想知道编译器对一个泛型方法调用、最终推断出哪种类型==，*Peter von der Ahé* 推荐了这样一个窍门：==故意引入一个错误，并研究所产生的错误消息==。例如，考虑调用 `ArrayAlg.getMiddle("Hello", 0, null)` 。将结果赋给 `JButton` ，这不可能正确。将会得到一个措误报告：
> ```java
> found:
> java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparabl e<?>>
> ```
> 大致的意思是：可以将结果赋给 `Object, Serialiable, Comparable` 。

> C++注释：**在C++中，要将类型参数放在方法名后面。这有可能会导致语法分析的歧义**。例如，`g(f<a, b>(c))` 可以理解为“用 `f<a, b>(c)` 的结果调用 `g` ”，或者理解为“用两个布尔值 `f<a` 和 `b>(c)` 调用 `g` ”。

---
# 8.4 类型变量的限定
有时，**类或方法需要对类型变量加以约束**。下面是一个典型的例子。我们要计算数组中的最小元素：
```java
class ArrayAlg {
	public static <T> T min(T[] a) { // almost correct
		if (a == null || a.length = 0) return null;
		T smallest = a[0];
		for (int i = 1; i < a.length; i ++)
			if (smallest.compareTo(a[i]) > 0) smallest = a[i];
		return smallest;
	}
}
```
但这里有一个问题。看 `min` 方法的代码内部。变量 `smallest` 类型为 `T` ，这意味着它可以是任何一个类的对象。如何确保 `T` 所属的类有 `compareTo` 方法呢？

解决这个问题的方案是，将 `T` 限制为实现了 `Comparable` 接口（只含一个方法 `compareTo` 的标准接口）的类。可以通过对类型变量 `T` 设置限定 *bound* 实现这一点：
```java
public static <T extends Comparab1e> T
```
实际上 `Comparable` 接口本身就是一个泛型类型。目前，我们忽略其复杂性以及编译器产生的警告。8.8节讨论如何在 `Comparable` 接口中适当地使用类型参数。

现在，泛型的 `min` 方法只能被实现了 `Comparable` 接口的类（如 `String, LocalDate` 等）的数组调用。由于 `Rectangle` 类没有实现 `Comparable` 接口，所以调用 `min` 将会产生一个编译错误。
> C++注释：在C++中不能对模板参数的类型加以限制。如果程序员用一个不适当的类型实例化一个模板，将会在模板代码中报告一个（通常是含糊不清的）错误消息。

或许会感到奇怪——在此为什么使用关键字 `extends` 而不是 `implements` ? 毕竟 `Comparable` 是一个接口。记法 `<T extends BoundingType>` 表示 **`T` 应该是限定类型的子类型** *T should be a subtype of the bounding type* 。**`T` 和限定类型可以是类，也可以是接口**。选择关键字 `extends` 的原因是它更接近子类型的概念，并且Java的设计者也不打算在语言中再添加一个新的关键字。

**一个类型变量或通配符可以有多个限定**，如下所示。**限定类型用 `&` 分隔，而逗号用来分隔类型变量**。
```java
T extends Comparable & Serializable
```
在Java的继承中，可以根据需要拥有多个接口超类型，但最多有一个限定是类。**如果有一个类作为限定，它必须是限定列表中的第一个**。

在 `pair2/PairTest2.java` 中，重新编写了一个泛型方法 `minmax` 。这个方法计算泛型数组的最大值和最小值，并返回 `Pair<T>` 。
```java
// pair2/PairTest2.java
package pair2;

import java.time.*;
public class PairTest2 {
	public static void main(String[] args) {
		LocalDate[] birthdays = {
			LocalDate.of(1906, 12, 9), // G. Hopper
			LocalDate.of(1815, 12, 10), // A. Lovelace
			LocalDate.of(1903, 12, 3), // J. von Neumann
			LocalDate.of(1910, 6, 22), // K. Zuse
		};
		Pair<LocalDate> mm = ArrayAlg.minmax(birthdays);
		System.out.println("min = " + mm.getFirst());
		System.out.println("max = " + mm.getSecond());
	}
}

class ArrayAlg {
	/**
	 * Gets the minimum and maximum of an array of objects of type T
	 * @param a an array of objects of type T
	 * @return a pair with the min and max values, or null if a is null or empty
	 */
	public static <T extends Comparable> Pair<T> minmax(T[] a) {
		if (a == null || a.length == 0) return null;
		T min = a[0];
		T max = a[0];
		for (int i = 1; i < a.length; ++i) {
			if (min.compareTo(a[i]) > 0) min = a[i];
			if (max.compareTo(a[i]) < 0) max = a[i];
		}
		return new Pair<>(min, max);
	}
}
```
---
# 8.5 泛型代码和虚拟机
**虚拟机没有泛型类型对象——所有对象都属于普通类**。在泛型实现的早期版本中，甚至能够将使用泛型的程序编译为在1.0虚拟机上运行的类文件！这个向后兼容性在Java泛型开发的后期被放弃了。下面会看到编译器如何擦除类型参数，以及这个过程对Java程序员有什么影响。
## 8.5.1 类型擦除
**无论何时定义一个泛型类型，都会自动提供一个相应的原始类型** `raw type` ，原始类型的名字就是「删去类型参数后的泛型类型名」*The name of the raw type is simply the name of the generic type...* 。**类型变量会被擦除 `erased` ，并替换为其限定类型 （无限定的变量用 `Object` ）**。

例如，`Pair<T>` 的原始类型如下所示，因为 `T` 是一个无限定的变量，所以直接用 `Object` 替换。结果是一个普通的类，就好像泛型引入Java语言之前实现的类一样。
```java
public class Pair {
	private Object first;
	private Object second;
	public Pair(Object first, Object second) {
		this.first = first;
		this.second = second;
	}
	public Object getFirst() { return first; }
	public Object getSecond() { return second; }
	public void setFirst(Object newValue) { first = newValue; }
	public void setSecond(Object newValue) { second = newValue; }
}
```
在程序中可以包含不同类型的 `Pair` ，例如 `Pair<String>` 或 `Pair<LocalDate>` 。不过擦除类型后，它们都会变成原始的 `Pair` 类型。
> C++注释：就这点而言，Java泛型与C++模板有很大的区别。**C++ 中每个模板的实例化产生不同的类型**，这一现象称为“模板代码膨胀 *template code bloat* ”。Java不存在这个问题的困扰。

**原始类型用第一个限定来替换类型变量 *The raw type replaces type variables with the first bound* 。或者，如果没有给定限定，就替换为 `Object`** 。例如，类 `Pair<T>` 中的类型变量没有显式的限定，因此原始类型用 `Object` 替换 `T` 。假定声明了一个稍有不同的类型。
```java
public class Interval <T extends Comparable & Serializable> implements Serializable {
	private T lower;
	private T upper;
	...
	public Interval (T first, T second) {
		if (first.compareTo(second) <= 0) { lower = first; upper = second; 
		} else { lower = second; upper = first; }
	}
}
```
原始类型 `Interval` 如下所示：
```java
public class Interval implements Serializable {
	private Comparable lower;
	private Comparable upper;
	...
	public Interval (Comparable first, Comparable second) { 
		... 
	}
}
```
> 注释：可能想知道限定切换为 `class Interval<T extends Serializable & Comparable>` 会发生什么。如果这样做，原始类型会用 `Serializable` 替换 `T` ，而编译器在必要时要向 `Comparable` 插入强制类型转换。**为了提高效率，应该将标签 *tagging* 接口（即没有方法的接口）放在限定列表的末尾**。

## 8.5.2 转换泛型表达式
当你编写了对一个泛型方法的调用时，**如果擦除了返回类型，编译器会插入强制类型转换**。例如，下面这个语句序列
```java
Pair<Employee> buddies = ...;
Employee buddy = buddies.getFirst();
```
 `getFirst` 擦除类型后将返回 `Object` 类型。编译器自动插入到 `Employee` 的强制类型转换。也就是说，编译器把这个方法调用翻译为两条虚拟机指令：
- 对原始方法 `Pair.getFirst` 的调用。
- 将返回的 `Object` 类型强制转换为 `Employee` 类型。

**存取一个泛型字段时，也要插入强制类型转换**。假设 `Pair` 类的 `first` 字段和 `second` 字段都是公有的（也许这不是一种好的编程风格，但在Java中是合法的）。表达式：
```java
Employee buddy = buddies.first;
```
也会在结果字节码中插入强制类型转换。
## 8.5.3 转换泛型方法
**类型擦除也会出现在泛型方法中**。程序员通常认为下述的泛型方法是整个一组方法：
```java
public static <T extends Comparable> T min(T[] a)
```
而擦除类型之后，只剩下一个方法。注意，**类型参数 `T` 已经被擦除了，只留下了限定类型 `Comparable`** ：
```java
public static Comparable min(Comparable[] a)
```
**方法的擦除带来了两个复杂问题**。看一看下面这个示例：
```java
class DateInterval extends Pair<LocalDate> {
	public void setSecond(LocalDate second) {
		if (second.compareTo(getFirst()) >= 0)
			super.setSecond(second);
	}
	...
}
```
一个日期区间是一对 `LocalDate` 对象，并且需要覆盖这个方法来确保第二个值永远不小于第一个值。这个类擦除后变成：
```java
class DateInterval extends Pair { // after erasure
	public void setSecond(LocalDate second) { ... }
	...
}
``` 
令人感到奇怪的是，存在另一个从 `Pair` 继承的 `setSecond` 方法，即：
```java
public void setSecond(Object second)
```
这显然是一个不同的方法，因为它有一个不同类型的参数 `Object` ，而不是 `LocalDate` 。然而，**不应该不一样**。考虑下面的语句序列：
```java
DateInterval interval = new DateInterval(...);
Pair<LocalDate> pair = interval; // OK--assignment to superclass
pair.setSecond(aDate);
```
这里，希望对 `setSecond` 的调用具有多态性、并调用最合适的那个方法。由于 `pair` 引用一个 `DateInterval` 对象，所以应该调用 `DateInterval.setSecond` 。问题在于类型擦除与多态发生了冲突 *the type erasure interferes with polymorphism* 。为解决这个问题，就需要编译器在 `DateInterval` 类中生成一个**桥方法** `bridge method` :
```java
public void setSecond(Object second) { 
	setSecond((Date) second);
}
```
要想了解它的工作过程，请仔细地跟踪下列语句的执行：
```java
pair.setSecond(aDate)
```
变量 `pair` 已经声明为类型 `Pair<LocalDate>`（擦除后为 `Pair` ），并且这个类型只有一个方法叫 `setSecond` ，即 `setSecond(Object)` 。虚拟机用 `pair` 引用的对象调用这个方法。这个对象是 `DateInterval` 类型的，因而将会调用 `DateInterval.setSecond(Object)` 方法。这个方法是合成的桥方法，它调用 `DateInterval.setSecond(Date)` ，这正是我们所期望的操作效果。

桥方法可能会变得十分奇怪。假设 `DateInterval` 方法也覆盖了 `getSecond` 方法：
```java
class Datelnterval extends Pair<LocalDate> {
	public LocalDate getSecond() { 
		return (LocalDate) super.getSecond(); 
	}
}
```
在 `DateInterval` 类中，有两个 `getSecond` 方法：
```java
LocalDate getSecond() // defined in DateInterval
Object getSecond() // overrides the method defined in Pair to call the first method
```
你不能像这样编写Java代码（在这里，具有相同参数类型的两个同名方法是不合法的，它们都没有参数）。但**在虚拟机中，用参数类型和返回类型共同指定一个方法**。因此，编译器可以为「两个仅返回类型不同的方法」生成字节码，虚拟机能正确处理这一情况。

> 注释：**桥方法不仅用于泛型类型**。第5章讲过，在一个方法覆盖另一个方法时，可以指定一个更严格的返回类型。例如：
> ```java
> public class Employee implements Cloneable {
> 	public Employee clone() throws CloneNotSupportedException { 
> 		... 
> 	}
> }
> ```
> `Object.clone` 和 `Employee.clone` 方法被称为**有协变的返回类型** `covariant return type` 。实际上，`Employee` 类有**两个**克隆方法：
> ```java
> Employee clone() // defined above
> Object clone() // synthesized bridge method, overrides Object.clone
> ```
> **合成的桥方法会调用新定义的方法**。

总之，对于**Java泛型的转换**，需要记住以下事实：
- **虚拟机中没有泛型，只有普通的类和方法**。
- 所有的类型参数都会**替换为它们的限定类型**。
- 为保持类型安全性，必要时会插入**强制类型转换**。
- 会**合成桥方法**来保持多态。

## 8.5.4 调用遗留代码
设计Java泛型类型时，主要目标是**允许泛型代码和遗留代码之间能够互操作**。下面看一个具体的示例。Swing用户界面工具包提供了一个 `JSlider` 类，它的刻度 `tick` 可以定制为包含文本或图像的标签，这些标签用以下调用设置：
```java
void setLabelTable(Dictionary table)
```
`Dictionary` 类将整数映射到标签。在Java 5之前，这个类实现为一个 `Object` 实例的映射 *a map of Object instances* 。Java 5把 `Dictionary` 实现为一个泛型类，不过 `JSlider` 从未更新。在这一点，没有类型参数的 `Dictionary` 是一个原始类型，这里就存在兼容性问题。

填充字典时，可以使用泛型类型。
```java
Dictionary<Integer, Component> labelTable = new Hashtable<>();
labelTable.put(0, new JLabel(new Imagelcon("nine.gif")));
labelTable.put(20, new JLabel(new ImageIcon("ten.gif")));
```
将 `Dictionary<Integer, Component>` 对象传递给 `setLabelTable` 时，编译器会发出一个警告。
```java
slider.setLabelTable(labelTable); // Warning
```
毕竟，编译器无法确定 `setLabelTable` 可能会对 `Dictionary` 对象做什么操作。这个方法可能会用字符串替换所有的键。这就打破了键类型必须为整型 `Integer` 的承诺，未来的操作有可能会产生强制类型转换异常。

要仔细考虑这个问题，考虑 `JSlider` 到底会用 `Dictionary` 对象做什
么。在这里十分清楚，`JSlider` 只阅读这个信息，因此可以忽略这个警告。

现在，看一个相反的情形，由一个遗留类得到一个原始类型的对象。可以将它赋给一个类型使用了泛型的变量，当然这样做会看到一个警告。例如：
```java
Dictionary<Integer, Components> labelTable = slider.getLabelTable(); // Warning
```
这就行了。再看一看警告，确保标签表已经包含了 `Integer` 和 `Component` 对象。当然，从来也不会有绝对的保证。恶意的编码者可能会在滑块中安装一个不同的 `Dictionary` 。然而，这种情况并不会比有泛型之前的情况更糟糕。最差的情况也就是程序抛出一个异常。

**考虑了这个警告之后，可以利用注解 `annotation` 使之消失**，如下所示：
```java
@SuppressWarnings("unchecked")
Dictionary<Integer, Components> labelTable = slider.getLabelTable(); // No warning
```
或者，**可以标注整个方法，这个注解会关闭对方法中所有代码的检査**。如下所示：
```java
@SuppressWarnings("unchecked")
public void configureSlider() { ... }
```
---
# 8.6 限制与局限性
在下面几节中，讨论**使用Java泛型时需要考虑的一些限制**。大多数限制都是由类型擦除引起的。
## 8.6.1 不能用基本类型实例化类型参数
不能用基本类型代替类型参数 *substitute a primitive type for a type parameter* 。因此，没有 `Pair<double>` ，只有 `Pair<Double>` 。当然，其原因是类型擦除。擦除之后，`Pair` 类含有 `Object` 类型的字段，而 `Object` 不能存储 `double` 值。

这的确令人烦恼。但是，这样做与Java语言中基本类型的独立状态相一致。这并不是一个致命的缺陷——只有8种基本类型，而且当包装类型 `wrapper type` 不是可接受的替代类型 *acceptable substitute* 时，我们也可以使用单独的类和方法来处理它们。
## 8.6.2 运行时类型查询只适用于原始类型
在虚拟机中的对象，总有一个特定的非泛型类型 *Objects in the virtual machine always have a specific nongeneric type* 。因此，**所有的类型查询只产生原始类型**。例如：
```java
if (a instanceof Pair<String>) // Error
```
仅测试 `a` 是否是任意类型的一个 `Pair` 。下面的测试同样如此：
```java
if (a instanceof Pair<T>) // Error
```
或强制类型转换：
```java
Pair<String> p = (Pair<String>) a; // Warning--can only test that a is a Pair
```
为提醒这一风险，如果试图查询一个对象是否属于某个泛型类型，会得到一个编译器错误（使用 `instanceof` 时），或者得到一个警告（使用强制类型转换时）。

同样的道理，**`getClass` 方法总是返回原始类型**。例如：
```java
Pair<String> stringPair = ...;
Pair<Employee> employeePair = ...;
if (stringPair.getClass() == employeePair.getClass()) // they are equal
```
其比较的结果是 `true` ，这是因为两次调用 `getClass` 都将返回 `Pair.class` 。
## 8.6.3 不能创建参数化类型的数组
不能实例化参数化类型 *cannot instantiate arrays of Parameterized Types* 的数组，例如：
```java
// var 
Pair<String>[] table = new Pair<String>[10]; // Error
```
这有什么问题呢？擦除之后，`table` 的类型是 `Pair[]` ，可以把它转换为 `Object[]` :
```java
Object[] objarray = table;
```
**数组会记住它的元素类型** *An array remembers its component type* ，如果试图存储其他类型的元素，就会抛出一个 `ArrayStoreException` 异常：
```java
objarray[0] = "Hello"; // Error--component type is Pair
```
不过**对于泛型类型，擦除会使这种机制无效**。以下赋值能通过数组存储检査，不过仍会导致一个类型错误。**出于这个原因，不允许创建参数化类型的数组**。
```
objarray[0] = new Pair<Employee>();
```
需要说明的是，**只是不允许创建这些数组，而声明类型为 `Pair<String>[]` 的变量仍是合法的**。不过不能用 `new Pair<String>[10]` 初始化这个变量。

此外，我们可以声明通配类型的数组，然后进行强制类型转换：
```java
Pair<String>[] table = (Pair<String>[]) new Pair<?>[10];
```
结果将是不安全的。如果在 `table[0]` 中存储一个 `Pair<Employee>` ，然后对 `table[0].getFirst()` 调用一个 `String` 方法，会得到一个 `ClassCastException` 异常。

如果需要收集参数化类型对象，只有一种安全而有效的方法：使用 `ArrayList<Pair<String>>` 。
## 8.6.4 `Varargs` 警告
上一节中已经了解到，**Java不支持泛型类型的数组**。这一节中我们再来讨论一个**相关**的问题：向参数个数可变的方法传递一个泛型类型的实例。

考虑下面这个简单的方法，它的参数个数是可变的：
```java
public static <T> void addAll(Collections coll, T... ts) {
	for (t : ts) coll.add(t);
}
```
应该记得，**实际上参数 `ts` 是一个数组，包含提供的所有实参**。现在考虑以下调用：
```java
Collection<Pair<String>> table = ...;
Pair<String> pair1 = ...;
Pair<String> pair2 = ...;
addAll(table, pair1, pair2);
```
**为了调用这个方法，Java虚拟机必须建立一个 `Pair<String>` 数组，这就违反了前面的规则**。不过，对于这种情况，规则有所放松，你只会得到一个警告，而不是错误。

可以采用两种方法来抑制这个警告。一种方法是为包含 `addAll` 调用的方法增加注解 `@SuppressWarnings("unchecked")` 。或者在Java 7中，还可以用 `@SafeVarargs` 直接标注 `addAll` 方法：
```java
@SafeVarargs
public static <T> void addAll(Collection<T> coll, T... ts)
```
现在就可以提供泛型类型来调用这个方法了。对于任何只需要读取参数数组元素 *the elements of the parameter array* 的方法（这肯定是最常见的情况），都可以使用这个注解。

**`@SafeVarargs` 只能用于声明为 `static, final` 或（Java 9中）`private` 的构造器和方法**。所有其他方法都可能被覆盖，使得这个注解没有什么意义。

还可以**使用 `@SafeVarargs` 注解来消除创建泛型数组的有关限制**，方法如下：
```java
@SafeVarargs 
static <E> E[] array(E... array) { return array; }
```
现在可以调用：
```java
Pair<String>[] table = array(pair1, pair2);
```
这看起来很方便，不过隐藏着危险。以下代码能顺利运行而不会出现 `ArrayStoreException` 异常（因为数组存储只会检查擦除的类型 *checks the erased type* ），但在处理 `table[0]` 时你会在别处得到一个异常。
```java
Object[] objarray = table;
objarray[0] = new Pair<Employee>();
```
## 8.6.5 不能实例化类型变量 *Cannot Instantiate Type Variables*
**不能在类似 `new T(...)` 的表达式中使用类型变量**。例如，下面的 `Pair<T>` 构造器就是非法的，类型擦除将 `T` 改变成 `Object` ，而本意肯定不希望调用 `new Object()` ：
```java
public Pair() { first = new T(); second = new T(); } // Error
```

在Java 8之后，最好的解决办法是**让调用者提供一个构造器表达式**（方法引用）。例如：
```java
Pair<String> p = Pair.makePair(String::new);
```
`makePair` 方法接收一个 `Supplier<T>` ，这是一个函数式接口，表示一个无参数且返回类型为 `T` 的函数：
```java
public static <T> Pair<T> makePair(Supplier<T> constr) {
	return new Pair<>(constr.get(), constr.get());
}
```
比较传统的解决方法是，通过反射调用 `Constructor.newInstance` 方法来构造泛型对象。遗憾的是，细节有点复杂，不能调用以下方法：
```java
first = T.class.getConstructor().newInstance(); // Error
```
**表达式 `T.class` 是不合法的**，因为它会擦除为 `Object.class` 。必须像下面这样设计API、以得到一个 `Class` 对象：
```java
public static <T> Pair<T> makePair(Class<T> cl) {
	try { 
		return new Pair<>(cl.getConstructor().newInstance(), 
			cl.getConstructor().newInstance()
		); 
	} catch (Exception ex) { return null; }
}
```
这个方法可以按照下列方式调用：
```java
Pair<String> p = Pair.makePair(String.class);
```
注意，**`Class` 类本身是泛型的**。例如，**`String.class` 是一个 `Class<String>` 的实例**（事实上，它是唯一的实例）。因此，`makePair` 方法能推断出「所建立的 `pair` 」的类型。

## 8.6.6 不能构造泛型数组
就像**不能实例化一个泛型实例** *instantiate a single generic instance*（不能实例化一个类型变量？）一样，**也不能实例化数组** *cannot construct a generic array* 。不过原因有所不同，毕竟数组会填充 `null` 值，构造时看上去是安全的。不过，**数组本身也有类型，用来监控存储在虚拟机中的数组。这个类型会被擦除**。例如，考虑下面的例子，类型擦除会让这个方法永远构造 `Comparable[2]` 数组：
```java
public static <T extends Comparable> T[] minmax(T[] a) { 
	T[] mm = new T[2]; // Error
	... 
} 
```
**如果数组仅作为一个类的私有实例字段，就可以将这个数组的元素类型、声明为擦除的类型，并且在获取元素时强制类型转换**。例如，`ArrayList` 类可以这样实现：
```java
public class ArrayList<E> {
	private Object[] elements;
	...
	@SuppressWarnings("unchecked") 
	public E get(int n) { return (E) elements[n]; }
	public void set(int n, E e) { elements[n] = e; } // no cast needed
}
```
实际的实现没有这么清晰。这里，**强制类型转换 `E[]` 是一个假象，而类型擦除使其无法察觉**：
```java
public class ArrayList<E> {
	private E[] elements;
	...
	public ArrayList() { elements = (E[]) new Object[10]; }
}
```
**这个技术并不适用于我们的 `minmax` 方法，因为 `minmax` 方法返回 `T[]` 数组**，如果类型不对，就会得到运行时错误结果。假设实现以下代码：
```java
public static <T extends Comparable> T[] minmax(T... a) {
	var result = new Comparable[2]; // array of erased type
	...
	return (T[]) result; // compiles with warning
}
```
以下调用：
```java
String[] ss = ArrayAlg.minmax("Tom", "Dick", "Harry");
```
编译时不会有任何警告。当方法返回后 `Comparable[]` 引用强制转换为 `String[]` 变量时，将会发生 `ClassCastException` 异常。

**在这种情况下，最好让用户提供一个数组构造器表达式**。如下构造器表达式 `String[]::new` 指示一个函数，给定所需的长度，会构造一个指定长度的 `String` 数组。：
```java
String[] names = ArrayAlg.minmax(String[]::new, "Tom", "Dick", "Harry");
```
`minmax` 方法使用这个参数，生成一个有正确类型的数组：
```java
public static <T extends Comparable> T[] minmax(IntFunction<T[]> constr, T... a) {
	T[] result = constr.apply(2);
	...
}
```
**比较老式的方法是利用反射，调用 `Array.newInstance`** :
```java
public static <T extends Comparable> T[] minmax(T... a) {
	var result = (T[])Array.newInstance(a.getClass().getComponentType(), 2);
	...
}
```
**`ArrayList` 类的 `toArray` 方法就没有这么幸运。它需要生成一个 `T[]` 数组，但没有元素类型**。因此，有下面两种不同的形式：
```java
Object[] toArray()
T[] toArray(T[] result)
```
第二个方法接收一个数组参数。如果数组足够大，就使用这个数组 *If the array is large enough, it is used* 。否则，用 `result` 的元素类型构造一个足够大的新数组。
## 8.6.7 泛型类的静态上下文中类型变量无效
**不能在静态字段或方法中引用类型变量**。例如，下列高招看似聪明、但行不通：
```java
public class Singleton<T> {
	private static T singleInstance; // Error
	public static T getSingleInstance() { // Error 
		if (singleInstance == null) 
			construct new instance of T
		return singleInstance;
	}
}
```
如果这个程序能运行，就可以声明一个 `Singleton<Random>` 共享随机数生成器，声明一个 `Singleton<JFileChooer>` 共享文件选择器对话框。但是，这样是行不通的。类型擦除之后，只剩下 `Singleton` 类，它只包含一个 `singleInstance` 字段。因此，**禁止使用带有类型变量的静态字段和方法**。
## 8.6.8 不能抛出或捕获泛型类的实例
**既不能抛出也不能捕获泛型类对象**。实际上，甚至**泛型类扩展 `Throwable` 都是不合法的**。例如，以下定义就不能正常编译：
```java
public class Problem<T> extends Exception { /* ... */ }
	// ERROR--can't extend Throwable
```
**`catch` 子句中不能使用类型变量**。例如，以下方法将不能编译：
```java
public static <T extends Throwable> void doWork(Class<T> t) {
	try {
		do work
	} catch (T e) { // Error--can't catch type variable 
		Logger.global.info(...);
	}
}
```
不过，**在异常规范中使用类型变量是允许的**。以下方法是合法的：
```java
public static <T extends Throwable> void doWork(T t) throws T // OK
	try { 
		do work
	} catch (Throwable realCause) {
		t.initCause(realCause);
		throw t;
	}
}
```
## 8.6.9 可以消除对检查型异常的检查
==Java异常处理的一个基本原则是，必须为所有检查型异常提供一个处理器==。不过**可以利用泛型消除这个限制**。关键在于以下方法：
```java
@SuppressWamings("unchecked")
public static <T extends Throwable> 
void throwAs(Throwable e) throws T {
	throw (T) e;
}
```
假设这个方法包含在接口 `Task` 中，如果有一个检查型异常 `e` ，并调用
```java
Task.<RuntimeException>throwAs(t);
```
**编译器就会认为 `e` 是一个非检查型异常**（转换为 `RuntimeException` ）。以下代码会**把所有异常都转换为编译器所认为的非检查型异常**：
```java
try {
	do work
} catch (Throwable t) {
	Task.<RuntimeException>throwAs(t) ;
}
```
下面使用这个技术解决一个棘手的问题。**要在一个线程中运行代码，需要把代码放在一个「实现了 `Runnable` 接口的类」的 `run` 方法中，不过这个方法不允许抛出检查型异常**。我们将提供一个从 `Task` 到 `Runnable` 的适配器，它的 `run` 方法可以抛出任意异常。
```java
interface Task {
	void run() throws Exception;

	@SuppressWarnings("unchecked")
	static <T extends Throwable> void throwAs(Throwable t) throws T {
		throw (T) t;
	}

	static Runnable asRunnable(Task task) {
		return () -> {
			try {
				task.run();
			} catch (Exception e) {
				Task.<RuntimeException>throwAs(e);
			}
		};
	}
}
```
例如，以下程序运行了一个线程，它会抛出一个检查型异常。当你运行程序时，会得到一个堆栈轨迹：
```java
public class Test {
	public static void main(String[] args) {
		var thread = new Thread(Task.asRunnable(() -> {
				Thread.sleep(1000);
				System.out.println("Hello, World!");
				throw new Exception("Check this out!");
			}
		));
		thread.start();
	}
}
```
`Thread.sleep` 方法声明为抛出一个 `InterruptedException` ，我们不再需要捕获这个异常。由于我们没有中断这个线程 *interrupt the thread* ，这个异常不会被抛出。然而，程序抛出了一个检查型异常。

这有什么意义吗？**正常情况下，我们必须捕获一个 `Runnable` 的 `run` 方法中的所有检查型异常，把它们包装到 *wrap them* 非检查型异常中，因为 `run` 方法声明为不抛出任何检查型异常**。不过这里并没有做这种"包装"。我们只是抛出异常，并"哄骗"编译器，让它相信这不是个检查型异常。

通过使用泛型类、擦除和 `@SuppressWarnings` 注解，我们就能消除Java类型系统的部分基本限制。



## 8.6.10 注意类型擦除后的冲突
当泛型类型被擦除时，不允许创建引发冲突的条件 *it is illegal to create conditions that cause clashes* 。下面是一个示例。假定为 `Pair` 类增加一个 `equals` 方法： 
```java
public class Pair<T> {
	public boolean equals(T value) { 
		return first.equals(value) && second.equals(value); 
	}
	...
}
```
考虑一个 `Pair<String>` 。从概念上讲，它有两个 `equals` 方法:
```java
boolean equals(String) // defined in Pair<T>
boolean equals(Object) // inherited from Object
```
但是，直觉把我们引入歧途。方法 `boolean equals(T)` 擦除后就是 `boolean equals(Object)` ，这会与 `Object.equals` 方法发生冲突（这不算方法重写吗？）。当然，**补救的办法是重新命名引发错误的方法**。

泛型规范说明还提到另外一个原则：“为了支持擦除的转换，我们要施加一个限制——**如果两个接口类型是同一个接口的不同参数化，一个类或类型变量就不能同时作为这两个接口类型的子类** *To support translation by erasure, we impose the restriction that a class or type variable may not at the same time be a subtype of two interface types which are different parameterizations of the same interface*”。例如，下述代码是非法的：
```java
class Employee implements Comparable<Employee> { ... }
class Manager extends Employee implements Comparable<Manager> { ... } // Error
```
`Manager` 会实现 `Comparable<Employee>` 和 `Comparable<Manager>` ，这是同一接口的不同参数化。这一限制与类型擦除的关系并不十分明确。毕竟，下列非泛型版本是合法的。
```java
class Employee implements Comparable { ... }
class Manager extends Employee implements Comparable { ... }
```
其原因非常微妙，**有可能与合成的桥方法产生冲突**。实现了 `Comparable<X>` 的类可以获得一个桥方法：
```java
public int compareTo(Object other) { 
	return compareTo((X) other); 
}
```
不能对不同类型的 `X` 有两个这样的方法。

---
## 8.7 泛型类型的继承规则
在使用泛型类时，需要了解一些有关继承和子类型的准则。下面先从许多程序员感觉不太直观的情况开始。考虑一个类和一个子类，如 `Employee` 和 `Manager` 。`Pair<Manager>` 是 `Pair<Employee>` 的一个子类吗？或许会感到奇怪，答案是“不是”。例如，下面的代码将不能编译成功：
```java
Manager[] topHonchos = ...;
Pair<Employee> result = ArrayAlg.minmax(topHonchos); // Error
```
`minmax` 方法返回 `Pair<Manager>` ，而不是 `Pair<Employee>` ，并且这样的赋值是不合法的。

**无论 `S` 与 `T` 有什么联系**（如图8-1所示），**通常 `Pair<S>` 与 `Pair<T>` 都没有什么联系**。
![图8-1 pair类之间没有继承关系](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210211645300.png)
这一限制看起来过于严格，但对于类型安全非常必要。假设允许将 `Pair<Manager>` 转换为 `Pair<Employee>` 。考虑下面代码：
```java
Pair<Manager> managerBuddies = new Pair<>(ceo, cfo);
Pair<Employee> employeeBuddies = managerBuddies; // illegal, but suppose it wasn't
employeeBuddies.setFirst(lowlyEmployee);
```
显然，最后一句是合法的。但是 `employeeBuddies` 和 `managerBuddies` 引用了同样的对象。现在将CFO和一个普通员工组成一对，这对于 `Pair<Manager>` 来说应该是不可能的。
> 注释：必须注意泛型与Java数组之间的重要区别。**可以将一个 `Manager[]` 数组賦给一个类型为 `Employee[]` 的变量**：
> ```java
> Manager[] managerBuddies = { ceo, cfo };
> Employee[] employeeBuddies = managerBuddies; // OK
> ```
> 然而，**数组带有特别的保护**。如果试图将一个低级别的雇员存储到 `employeeBuddies[0]` ，虚拟机将会抛出 `ArrayStoreException` 异常。

**总是可以将参数化类型（泛型类型）转换为一个原始类型**。例如，`Pair<Employee>` 是**原始类型** `Pair` 的一个子类型。在与遗留代码交互时，这个转换非常必要。转换成原始类型会产生类型错误吗？很遗憾，会！看一看下面这个示例：
```java
var managerBuddies = new Pair<Manager>(ceo, cfo);
Pair rawBuddies = managerBuddies; // OK
rawBuddies.setFirst(new File("...")); // only a compile-time warning
```
听起来有点吓人。但记住，现在的状况不会再比旧版Java的情况糟糕。虚拟机的安全性还没有到生死攸关的程度。当使用 `getFirst` 获得外来对象（类似上面的那个 `File` ）、并赋给 `Manager` 变量时，与通常一样，会抛出 `ClassCastException` 异常。这里失去的只是泛型程序设计提供的附加安全性。

最后，**泛型类可以扩展或实现其他的泛型类**。就这一点而言，与普通的类没有什么区别。例如，`ArrayList<T>` 类实现了 `List<T>` 接口。这意味着，一个 `ArrayList<Manager>` 可以被转换为一个 `List<Manager>` 。但如前面所见，一个 `ArrayList<Manager>` 不是一个 `ArrayList <Employee>` 或 `List<Employee>` 。图8-2展示了它们之间的联系。
 ![图8-2 泛型列表类型中子类型间的联系|500x500](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210211656637.png)

---
# 8.8 通配符类型
严格的泛型类型系统使用起来并不那么令人愉快，类型系统的研究人员知道这一点已经有一段时间了。Java的设计者发明了一种巧妙的（仍然是安全的）“解决方案”：**通配符类型**。下面几小节会介绍如何处理通配符。
## 8.8.1 通配符概念
**通配符类型中，允许类型参数发生变化**。例如，通配符类型
```java
Pair<? extends Employee>
```
**表示任何泛型 `Pair` 类型，它的类型参数是 `Employee` 的子类**，如 `Pair<Manager>` ，但不是 `Pair<String>` 。

假设要编写一个打印雇员对的方法，像这样：
```java
public static void printBuddies(Pair<Employee> p) {
	Employee first = p.getFirst();
	Employee second = p.getSecond();
	System.out.println(first.getName() + " and " + second.getName() + " are buddies.");
}
```
如前讲的，**不能将 `Pair<Manager>` 传递给这个方法，这一点很受限制**。解决的方法很简单，使用通配符类型：
```java
public static void printBuddies(Pair<? extends Employee> p)
```
**类型 `Pair<Manager>` 是 `Pair<? extends Employee>` 的子类型**（如图8-3所示）。
![图8-3 使用通配符的子类型关系](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210211725746.png)

使用通配符会通过 `Pair<? extends Employee>` 的引用破坏 `Pair<Manager>` 吗？
```java
Pair<Manager> managerBuddies = new Pair<>(ceo, cfo);
Pair<? extends Employee> wildcardBuddies = managerBuddies; // OK
wildcardBuddies.setFirst(lowlyEmployee); // compile-time error
```
这不可能引起破坏。对 `setFirst` 的调用有一个类型错误。要了解其中的缘由，仔细看类型 `Pair<? extends Employee>` ，其方法似乎是这样的：
```java
? extends Employee getFirst()
void setFirst(? extends Employee)
```
这样将不可能去调用 `setFirst` 方法 *This makes it impossible to call the setFirst method* 。编译器只知道需要某个 `Employee` 的子类型，但不知道具体是什么类型（ `Manager` 之外的子类型肯定不行，`Employee` 也不行？）。它拒绝传递任何特定的类型，毕竟 `?` 可能不匹配 *It refuses to pass any specific type—after all, ? might not match it* 。使用 `getFirst` 就不存在这个问题：**将 `getFirst` 的返回值赋给一个 `Employee` 的引用完全合法**。
> 子类型限定：超类对象不能通过方法赋给子类对象，子类对象可以返回赋给超类对象。
> 超类型限定：子类对象可以通过方法赋给超类对象，超类对象返回赋给更超类对象 `Object` 。
> 两者分别指出了 `get` 的返回值可以赋给谁、`set` 的传递值应该是谁（或其子类）。

这就是引入**有限定的通配符** *bounded wildcards* 的关键之处。==现在已经有办法区分安全的访问器方法和不安全的更改器方法了==。
## 8.8.2 通配符的超类型限定
通配符限定与类型变量限定十分类似 *Wildcard bounds are similar to type variable bound* ，但还有一个附加的能力，即可以指定一个**超类型限定** `super type bound` ，如下所示：
```java
? super Manager
```
**这个通配符限制为 `Manager` 的所有超类型**（已有的 `super` 关键字十分准确地描述了这种联系，这一点令人感到非常欣慰）。

为什么要这样做呢？带有超类型限定的通配符的行为与8.8节介绍的相反。**可以为方法提供参数，但不能使用返回值**。例如，`Pair<? super Manager>` 有方法：
```java
void setFirst(? super Manager)
? super Manager getFirst()
```
这不是真正的Java语法，但可以看出编译器知道什么。编译器无法知道 `setFirst` 方法的具体类型，因此调用这个方法时不能接受类型为 `Employee` 或 `Object` 的参数，**只能传递 `Manager` 类型的对象，或者某个子类型（如 `Executive` ）对象**。另外，如果调用 `getFirst` ，不能保证返回对象的类型，**只能把它赋给一个 `Object`** 。
![图8-4 带有超类型限定的通配符](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210221224974.png)
下面是一个典型的示例。有一个经理的数组，并且想把奖金最高和最低的经理放在一个 `Pair` 对象中。`Pair` 的类型是什么？在这里，`Pair<Employee>` 是合理的，`Pair<Object>` 也是合理的（如图8-4所示，下面的方法将可以接受任何适当的 `Pair` ）：
```java
public static void minmaxBonus(Manager[] a, Pair<? super Manager> result) {
	if (a.length == 0) return;
	Manager min = a[0];
	Manager max = a[0];
	for (int i = 1; i < a.length; i++) {
		if (min.getBonus() > a[i].getBonus()) min = a[i];
		if (max.getBonus() < a[i].getBonus()) max = a[i];
	}
	result.setFirst(min);
	result.setSecond(max);
}
```
直观地讲，**带有超类型限定的通配符允许你写入一个泛型对象，而带有子类型限定的通配符允许你读取一个泛型对象**。

下面是超类型限定的另一种应用。`Comparable` 接口本身就是一个泛型类型。声明如下：
```java
public interface Comparable<T> {
	public int compareTo(T other);
}
```
在此，类型变量指示了 `other` 参数的类型。例如，`String` 类实现 `Comparable<String>` ，它的 `compareTo` 方法被声明为
```java
public int compareTo(String other)
```
很好，显式的参数有一个正确的类型。在接口是泛型接口之前 *Before the interface was generic* ，（我们要知道）`other` 是一个 `Object` ，并且这个方法的实现需要一个强制类型转换。

由于 `Comparable` 是一个泛型类型，也许可以把 `ArrayAlg` 类的 `min` 方法做得更好一些？可以这样声明：
```java
public static <T extends Comparable<T>> T min(T[] a)
```
看起来，这样写比只使用 `T extends Comparable` 更彻底，并且对许多类来讲，工作得更好。例如，如果计算一个 `String` 数组的最小值，`T` 就是 `String` 类型的，而 `String` 是 `Comparable<String>` 的子类型（因为 `String implements Comparable<String>` ）。但是，处理一个 `LocalDate` 对象的数组时，会出现一个问题—— `LocalDate` 实现了 `ChronoLocalDate` ，而 `ChronoLocalDate` 扩展了`Comparable<ChronoLocalDate>`。因此，`LocalDate` 实现的是 `Comparable<ChronoLocalDate>` 而不是 `Comparable<LocalDate>` 。

在这种情况下，可以用超类型来解决：
```java
public static <T extends Comparable<? super T>> T min(T[] a)
```
现在 `compareTo` 方法写成
```java
int compareTo(? super T)
```
它被声明为使用 `T` 类型的对象，或者有可能使用 `T` 的一个超类型的对象（当 `T` 是 `LocalDate` 时）。**无论如何，传递一个 `T` 类型的对象给 `compareTo` 方法都是安全的**。

对于初学者来说，类似 `<T extends Comparable<? super T>>` 这样的声明看起来有点吓人。很遗憾，因为这一声明的本意、是通过去除「对调用参数的不必要限制」 *removing unnecessary restrictions on the call parameters* 来帮助应用程序员。对泛型没有兴趣的应用程序员可能很快就学会略过这些声明，想当然地认为库程序员做的都是正确的。如果是一名库程序员，一定要熟悉通配符，否则就会受到用户的责备，他们还要在代码中随机地添加强制类型转换、直至代码可以编译。

> 注释：**子类型限定的另一个常见的用法，是作为一个函数式接口的参 数类型**。例如 `Collection` 接口有一个方法：
> ```java
> default boolean removeIf(Predicate< ? super E> filter)
> ```
> 这个方法会删除所有满足给定谓词条件的元素。例如，如果你不喜欢有奇怪散列码的员工，就可以如下将他们删除：
> ```java
> ArrayList< Employee> staff = ...;
> Predicate< Object> oddHashCode = obj -> obj.hashCode() % 2 != 0;
> staff.removelf(oddHashCode);
> ```
> 你希望传入一个 `Predicate<Object>` ，而不只是`Predicate<Employee>` 。`Super` 通配符可以使这个愿望成真。

## 8.8.3 无限定通配符
你还可以使用**无限定的通配符**，例如 `Pair<?>` 。初看起来，**这好像与原始的 `Pair` 类型一样。实际上有很大的不同**。类型 `Pair<?>` 有以下方法：
```java
? getFirst()
void setFirst(?)
```
**`getFirst` 的返回值只能赋给一个 `Object` 。`setFirst` 方法不能被调用，甚至不能用 `Object` 调用**。`Pair<?>` 和 `Pair` 本质的不同在于：**可以用任意 `Object` 对象调用原始 `Pair` 类的 `setFirst` 方法**。
> 注释：可以调用 `setFirst(null)` 。

为什么要使用这样一个脆弱的类型？**它对于许多简单操作非常有用**。例如，下面这个方法可用来测试一个 `pair` 是否包含一个 `null` 引用，**它不需要实际的类型**。
```java
public static boolean hasNulls(Pair<?> p) {
	return p.getFirst() == null || p.getSecond() == null;
}
```
**通过将 `hasNulls` 转换成泛型方法，可以避免使用通配符类型**：
```java
public static <T> boolean hasNulls(Pair<T> p)
```
**但是，带有通配符的版本可读性更强**。
## 8.8.4 通配符捕获
编写一个交换 `Pair` 中元素的方法：
```java
public static void swap(Pair<?> p)
```
**通配符不是类型变量，因此不能在编写代码中使用 `?` 作为一种类型**。即下述代码是非法的：
```java
? t = p.getFirst(); // Error
p.setFirst(p.getSecond());
p.setSecond(t);
```
这是一个问题，因为在交换时必须临时保存第一个元素。幸运的是，**这个问题有一个有趣的解决方案**。我们可以写一个辅助方法 `swapHelper` ，如下所示。注意，`swapHelper` 是一个泛型方法，而 **`swap` 不是，它具有固定的 `Pair<?>` 类型的参数**：
```java
public static <T> void swapHelper(Pair<T> p) {
	T t = p.getFirst();
	p.setFirst(p.getSecond());
	p.setSecond(t);
}
```
现在可以由 `swap` 调用 `swapHelper` :
```java
public static void swap(Pair<?> p) { swapHelper(p); }
```
在这种情况下，`swapHelper` 方法的参数 `T` **捕获通配符** *captures the
wildcard* 。它不知道是通配符指示哪种类型，但这是一个明确的类型，并且当 `T` 表示那个类型时，`<T>swapHelper` 的定义很有意义 *the definition of \<T>swapHelper makes perfect sense when T denotes that type* 。

当然，在这种情况下，并不是一定要使用通配符。我们已经直接实现了没有通配符的泛型方法 `<T> void swap(Pair<T> p)` 。然而考虑下面这个例子，这里的通配符类型自然地出现在计算中间：
```java
public static void maxminBonus(Manager[] a, Pair<? super Manager> result) {
	minmaxBonus(a, result);
	PairAlg.swapHelper(result); // OK--swapHelper captures wildcard type
}
```
**在这里，通配符捕获机制是不可避免的**。

==通配符捕获只有在非常限定的情况下才是合法的，编译器必须能保证，通配符表达的是单个、确定的类型 *a single, definite type* ==。例如，`ArrayList<Pair<T>>` 中的 `T` 永远不能捕获 `ArrayList<Pair<?>>` 中的通配符。`ArrayList`可以保存两个 `Pair<?>` ，其中的 `?` 分别有不同的类型。

`pair3/PairTest3.java`中的测试程序，将前几节讨论的各种方法综合在一起，从中可以看到它们彼此之间的关联、具体使用。
```java
// pair3/PairTest3.java
package pair3;

public class PairTest3 {
	public static void main(String[] args) {
		var ceo = new Manager("Gus Greedy", 800000, 2003, 12, 15);
		var cfo = new Manager("Sid Sneaky", 600000, 2003, 12, 15);
		var buddies = new Pair<Manager>(ceo, cfo);
		printBuddies(buddies);
	
		ceo.setBonus(1000000);
		cfo.setBonus(500000);
		Manager[] managers = { ceo, cfo };

		var result = new Pair<Employee>();
		minmaxBonus(managers, result);
		System.out.println("first: " + result.getFirst().getName()
			+ ", second: " + result.getSecond().getName());
		maxminBonus(managers, result);
		System.out.println("first: " + result.getFirst().getName()
			+ ", second: " + result.getSecond().getName());
	}

	public static void printBuddies(Pair<? extends Employee> p) {
		Employee first = p.getFirst();
		Employee second = p.getSecond();
		System.out.println(first.getName() + " and " + second.getName() + " are buddies.");	
	}

	public static void minmaxBonus(Manager[] a, Pair<? super Manager> result) {
		if (a.length == 0) return;
		Manager min = a[0];
		Manager max = a[0];
		for (int i = 1; i < a.length; ++i) {
			if (min.getBonus() > a[i].getBonus()) min = a[i];
			if (max.getBonus() < a[i].getBonus()) max = a[i];
		}
		result.setFirst(min);
		result.setSecond(max);
	}

	public static void maxminBonus(Manager[] a, Pair<? super Manager> result) {
		minmaxBonus(a, result);
		PairAlg.swapHelper(result); // OK--swapHelper captures wildcard types
	} // can't write public static <T super Manager> ...
}

class PairAlg {
	public static boolean hasNulls(Pair<?> p) {
		return p.getFirst() == null || p.getSecond() == null;	
	}

	public static void swap(Pair<?> p) { swapHelper(p); }

	public static <T> void swapHelper(Pair<T> p) {
		T t = p.getFirst();
		p.setFirst(p.getSecond());
		p.setSecond(t);
	}
}
```

---
# 8.9 反射和泛型
**反射允许你在运行时分析任意的对象**。==如果对象是泛型类的实例，关于泛型类型参数你将得不到太多信息，因为它们已经被擦除了==。在下面的小节中，了解利用反射可以获得泛型类的哪些信息。
## 8.9.1 泛型 `Class` 类
现在，`Class` 类是泛型的。例如，`String.class` 实际上是一个 `Class<String>` 类的对象（事实上，是唯一的对象）。

类型参数十分有用，这是因为它允许 `Class<T>` 方法的返回类型更加具有针对性。`Class<T>` 的以下方法就使用了类型参数：
```java
T newInstance()
T cast(Object obj)
T[] getEnumConstants()
Class<? super T> getSuperclass()
Constructors<T> getConstructor(C1ass... parameterTypes)
Constructors<T> getDeclaredConstructor(Class... parameterTypes)
```
`newInstance` 方法返回这个类的一个实例，由无参数构造器获得。它的返回类型目前被声明为 `T` ，其类型与 `Class<T>` 描述的类相同，这样就免除了类型转换。

如果给定对象的类型实际上是 `T` 的一个子类型，`cast` 方法就会返回这个给定对象（现在声明为类型 `T` ），否则会抛出一个 `BadCastException` 异常。

如果这个类不是 `enum` 类或「 `T` 类型枚举值的数组」，`getEnumConstants` 方法将返回 `null` 。

最后，`getConstructor` 与 `getDeclaredConstructor` 方法返回一个 `Constructor<T>` 对象。`Constructor` 类也已经变成泛型，从而使 `newInstance` 方法有一个正确的返回类型。

> [API] `java.lang.Class<T>` 1.0
> - `T newInstance()`
> 返回无参数构造器构造的一个新实例。
> - `T cast(Object obj)`
> 如果 `obj` 为 `null` 或有可能转换成类型 `T` ，则返回 `obj` ; 否 则 拋 出 `BadCastException` 异常。
> - `T[] getEnumConstants()` 5.0
> 如果 `T` 是枚举类型，则返回所有值组成的数组，否则返回 `null` 。
> - `Class<? super T> getSuperclass()`
> 返回这个类的超类。如果 `T` 不是一个类或 `Object` 类，则返回 `null` 。
> - `Constructor<T> getConstructor(Class... parameterTypes)` 1.1
> - `Constructor<T> getDeclaredConstructor(Class... parameterTypes)` 1.1
> 获得公有的构造器，或带有给定参数类型的构造器。

> [API] `java.lang.reflect.Constructor<T> 1.1
> - `T newInstance(Object... parameters)`
> 返回用指定参数构造的新实例。

## 8.9.2 使用 `Class<T>` 参数进行类型匹配
有时，匹配一个泛型方法中的「一个 `Class<T>` 参数的类型变量」很有用。下面是一个标准的示例：
```java
public static <T> Pair<T> makePair(Class<T> c) 
	throws InstantiationException, IllegalAccessException {
	return new Pair<>(c.newInstance(), c.newInstance());
}
```
如果调用 `makePair(Employee.class)` ，`Employee.class` 是类型 `Class<Employee>` 的一个对象。`makePair` 方法的类型参数 `T` 同 `Employee` 匹配，编译器可以推断出这个方法将返回一个 `Pair<Employee>` 。
## 8.9.3 虚拟机中的泛型类型信息
Java泛型的突出特性之一是在虚拟机中泛型类型的擦除 *the erasure of generic types in the virtual machine* 。令人感到奇怪的是，擦除的类仍然保留原先泛型 *their generic origin* 的微弱记忆。例如，原始的 `Pair` 类知道它源于泛型类 `Pair<T>` ，尽管一个 `Pair` 类型的对象无法区分它是构造为 `Pair<String>` 还是 `Pair<Employee>` 。

类似地，考虑以下方法：
```java
public static Comparable min(Comparable[] a)
```
这是擦除以下泛型方法得到的：
```java
public static <T extends Comparable<? super T>> T min(T[] a)
```
你可以使用反射API来确定：
- 这个泛型方法有一个叫做 `T` 的类型参数。
- 这个类型参数有一个子类型限定 *subtype bound* ，其自身又是一个泛型类型 *generic type*（类型变量）。
- 这个限定类型 *bounding type* 有一个通配符参数 *wildcard parameter* 。
- 这个通配符参数有一个超类型限定 *supertype bound* 。
- 这个泛型方法有一个泛型数组参数。

换句话说，我们可以重新构造关于「实现者声明的泛型类和方法」的所有内容 *everything about generic classes and methods that their implementors declared* 。但我们不会知道，对于特定的对象或方法调用，会如何解析类型参数。

**为了表达泛型类型声明，使用 `java.lang.reflect` 包中提供的接口 `Type`** 。这个接口包含下列子类型：
- `Class` 类，描述具体类型。
- `TypeVariable` 接口，描述类型变量（如 `T extends Comparable<? super T>` ）。
- `WildcardType` 接口，描述通配符（如 `? super T` ）。
- `ParameterizedType` 接口，描述泛型类或接口类型（如 `Comparable<? super T>` ）。
- `GenericArrayType` 接口，描述泛型数组（如 `T[]` ）。

图8-5给出了继承层次。注意，最后4个子类型是接口，虚拟机将实例化实现这些接口的适当的类。
 ![图8-5 Type接口及其子类型](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210241446648.png)
`genericReflection/GenericReflectionTest.java` 中使用泛型反射API，打印出给定类的有关内容。如果用 `Pair` 类运行这个程序，将会得到下列报告：
```java
class Pair<T> extends java.lang.Object
public T getFirst()
public T getSecond()
public void setFirst(T)
public void setSecond(T)
```
如果使用 `PairTest2` 目录下的 `ArrayAlg` 运行，将会得到下列报告：
```java
public static <T extends java.lang.Comparable> Pair<T> minmax(T[])
```

```java
// genericReflection/GenericR©flectionTest.java
package genericReflection;
import java.lang.reflect.*;
import java.util.*;

public class GenericReflectionTest {
	public static void main(String[] args) {
		// read class name from command line args or user input
		String name;
		if (args.length > 0) name = args[0];
		else {
			try (var in = new Scanner(System.in)) {
				System.out.println("Enter class name (e.g., java.util.Collections): ");
				name = in.next();
			}
		}
		try {
			// print generic info for class and public methods
			Class<?> cl = Class.forName(name);
			printClass(cl);
			for (Method m : cl.getDeclaredMethods()) 
				printMethod(m);
		} catch (ClassNotFoundException e) {
			e.printStackTrace();	
		}
	}

	public static void printClass(Class<?> cl) {
		System.out.print(cl);
		printTypes(cl.getTypeParameters(), "<", ", ", ">", true);
		Type sc = cl.getGenericSuperclass();
		if (sc != null) { // only one super class
			System.out.print(" extends ");
			printType(sc, false);
		}
		printTypes(cl.getGenericInterfaces, " implements ", ", ", "", false);
		System.out.println();
	}

	public static void printMethod(Method m) {
		String name = m.getName();
		System.out.print(Modifier.toString(m.getModifiers()));
		System.out.print(" ");
		printTypes(m.getTypeParameters(), "<", ", ", "> ", true);
		// left, middle, right
		printType(m.getGenericReturnType(), false);
		System.out.print(" ");
		System.out.print(name);
		System.out.print("(");
		printTypes(m.getGenericParameterTypes(), "", ", ", "", false);
		System.out.println(")");
	}

	public static void printTypes(Type[] types, String pre, String sep, String suf, boolean isDefinition) {
		if (pre.equals(" extends ") && Arrays.equals(types, new Type[] { Object.class })) return;
		if (types.length > 0) System.out.print(pre);
		for (int i = 0; i < types.length; ++i) {
			if (i > 0) System.out.print(sep);
			printType(types[i], isDefinition);
		}
		if (types.length > 0) System.out.print(suf);
	}

	public static void printType(Type type, boolean isDefinition) {
		if (type instanceof Class) {
			var t = (Class<?>) type;
			System.out.print(t.getName());
		} else if (type instanceof TypeVariable) { // 类型变量
			var t = (TypeVariable<?>) type;
			System.out.print(t.getName());
			if (isDefinition)
				printTypes(t.getBounds(), " extends ", " & ", "", false);
		} else if (type instanceof WildcardType) {
			var t = (WildcardType) type;
			System.out.print("?");
			printTypes(t.getUpperBounds(), " extends ", " & ", "", false);
			printTypes(t.getLowerBounds(), " super ", " & ", "", false);
		} else if (type instanceof ParameterizedType) {
			var t = (ParameterizedType) type;
			Type owner = t.getOwnerType();
			if (owner != null) {
				printType(owner, false);
				System.out.print(".");
			}
			printType(t.getRawType(), false);
			printTypes(t.getActualTypeArguments(), "<", ", ", ">", false);
		} else if (type instanceof GenericArrayType) {
			var t = (GenericArrayType) type;
			System.out.print("");
			printType(t.getGenericComponentType(), isDefinition);
			System.out.print("[]");
		}
	}
}
```

## 8.9.4 类型字面量
有时你会希望由值的类型来决定程序的行为。例如，在一种持久存储机制中，可能希望用户指定一种方法、来保存某个特定类的对象。通常的实现方法是，将 `Class` 对象与一个动作关联。

不过，如果有泛型类，擦除会带来问题。比如说，既然 `ArrayList<Integer>` 和 `ArrayList<String>` 都擦除为同一个原始类型 `ArrayList` ，如何让它们有不同的动作呢？

这里有一个技巧，在某些情况下可以解决这个问题。可以捕获 `Type` 接口（上节介绍过）的一个实例，然后构造一个匿名子类，如下所示：
```java
var type = new TypeLiteral<ArrayList<Integer>>(){} // note the {}
```
`TypeLiteral` 构造器会捕获泛型超类型 *generic supertype* ：
```java
class TypeLiteral {
	public TypeLiteral() {
		Type parentType = getClass().getGenericSuperclass();
		if (parentType instanceof ParameterizedType) {
			type = ((ParameterizedType) parentType).getActualTypeArguments()[0];
		} else
			throw new UnsupportedOperationException("Construct as new TypeLiteral<...>(){}");
	}
	...			
}
```
如果运行时有一个泛型类型，就可以将它与 `TypeLiteral` 匹配。我们无法从一个对象得到泛型类型（已经被擦除）。不过，正如上一节看到的，**字段和方法参数的泛型类型还留存在虚拟机中** *generic types of fields and method parameters survive in the virtual machine*  。

CDI和Guice等注入框架 `injection framework` 就使用类型字面量 *type literals* 来控制泛型类型的注入 *injection of generic types* 。`genericReflection/TypeLiterals.java` 给出了一个更简单的例子，==给定一个对象，我们可以罗列它的字段，哪些有泛型类型，并查找相关联的格式化动作==。

我们将对一个 `ArrayList<Integer>` 进行格式化，各个值之间用空格分隔；另外还会格式化一个 `ArrayList<Character>` ，将字符连接成一个字符串。所有其他数组列表都由 `ArrayList.toString` 格式化。
```java
package genericReflection;

import java.lang.reflect.*;
import java.util.*;
import java.util.function.*;

/**
 * A type literal describes a type that can be generic, such as ArrayList<String>.
 */
class TypeLiteral<T> {
	private Type type;

	/**
	 * This constructor must be invoked from an anonymous subclass
	 * as new TypeLiteral<...>(){}
	 */
	public TypeLiteral() { // 泛型超类型
		Type parentType = getClass().getGenericSuperclass();
		if (parentType instanceof ParameterizedType) {
			type = ((ParameterizedType) parentType).getActualTypeArgument()[0];
		} else {
			throw new UnsupportedOperationException(
				"Construct as new TypeLiteral<...>(){}")
			);
		}
	}

	private TypeLiteral(Type type) {
		this.type = type;
	}

	/** 
	 * Yields a type literal that describes the given type.
	 */
	public static TypeLiteral<?> of(Type type) { // like LocalDate.of
		return new TypeLiteral<Object>(type);
	}

	public String toString() {
		if (type instanceof Class) return ((Class<?>) type).getName();
		else return type.toString();
	}

	public boolean equals(Object otherObject) {
		return otherObject instanceof TypeLiteral
			&& type.equals(((TypeLiteral<?>) otherObject).type);
	}

	public int hashCode() {
		return type.hashCode();
	}
}

/**
 * Formats objects, using rules that associate types with formatting functions.
 */
class Formatter {
	private Map<TypeLiteral<?>, Function<?, String>> rules = new HashMap<>();

	/**
	 * Add a formatting rule to this formatter.
	 * @param type the type to which this rule applies
	 * @parem formatterForType the function that formats objects of this type
	 */
	public <T> void forType(TypeLiteral<T> type, Function<T, String> formatterForType) {
		rules.put(type, formatterForType);
	}

	/**
	 * Format all fields of an object using the rules of this formatter.
	 * @param obj an object
	 * @return a string with all field names and formatted values
	 */
	public String formatFields(Object obj) 
		throws IllegalArgumentException, IllegalAccessException {
		var result = new StringBuilder();
		for (Field f : obj.getClass().getDeclaredFields()) {
			result.append(f.getName());
			result.append("=");
			f.setAccessible(true);
			Function<?, String> formatterForType = rules.get(TypeLiteral.of(f.getGenericType()));
			if (formatterForType != null) {
				// formatterForType has parameter type ?. Nothing can be passed to its 
				// apply method. Cast makes the parameter type to Object so we can invoke it.
				@SuppressWarnings("unchecked")
				Function<Object, String> objectFormatter
					= (Function<Object, String>) formatterForType;
					// ? in Function<...> is ArrayList<...>
				result.append(objectFormatter.apply(f.get(obj)));
					// f.get(obj) : gets the value of the field
			} else 
				result.append(f.get(obj).toString());
			result.append("\n");
		}
		return result.toString();
	}
}

public class TypeLiterals {
	public static class Sample {
		ArrayList<Integer> nums;
		ArrayList<Character> chars;
		ArrayList<String> strings;
		public Sample() {
			nums = new ArrayList<>();
			nums.add(42); nums.add(1729);
			chars = new ArrayList<>();
			chars.add('H'); chars.add('i');
			strings = new ArrayList<>();
			strings.add("Hello"); strings.add("World");
		}
	}

	private static <T> String join(String separator, ArrayList<T> elements) {
		var result = new StringBuilder();
		for (T e : elements) {
			if (result.length() > 0) result.append(separator);
			result.append(e.toString());
		}
		return result.toString();
	}

	public static void main(String[] args) throws Exception {
		var formatter = new Formatter();
		formatter.forType(new TypeLiteral<ArrayList<Integer>>() {}, lst -> join(" ", lst));
		formatter.forType(new TypeLiteral<ArrayList<Character>>() {}, lst -> "\"" + join("", lst) + "\"");
		System.out.println(formatter.formatFields(new Sample()));
	}
}
```
> [API] `java.lang.Class<T>` 1.0
> - `TypeVariable[] getTypeParameters()` 5.0
> 如果**这个类型被声明为一个泛型类型**，则获得泛型类型变量，否则获得一个长度为0的数组。
> - `Type getGenericSuperclass()` 5.0
> 获得「这一类型声明的超类」的泛型类型； 如果这个类型是 `Object` 或不是一个类类型 *class type* ，则返回 `null` 。
> - `Type[] getGenericInterfaces()` 5.0
> 获得「这个类型声明的接口」的泛型类型（按照声明的次序)，否则，如果这个类型没有实现接口，返回长度为0的数组。

> [API] `java.lang.reflect.Method` 1.1
> - `TypeVariable[] getTypeParameters()` 5.0
> 如果**这个方法被声明为一个泛型方法**，则获得泛型类型变量，否则返回长度为0的数组。
> - `Type getGenericReturnType()` 5.0
> 获得这个方法声明的泛型返回类型。
> - `Type[] getGenericParameterTypes()` 5.0
> 获得这个方法声明的泛型参数类型。如果这个方法没有参数，返回长度为0的数组。

 > [API] `java.lang.reflect.TypeVariable` 5.0
 > - `String getName()`
 > 获得这个类型变量的名字。
 > - `Type[] getBounds()`
 > 获得这个类型变量的子类限定，否则如果该变量无限定，则返回长度为0的数组。

> [API] `java.lang.reflect.WildcardType` 5.0
> - `Type[] getUpperBounds()`
> 获得这个类型变量的子类 `extends` 限定，否则，如果没有子类限定，则返回长度为0的数组。
> - `Type[] getLowerBounds()`
> 获得这个类型变量的超类 `super` 限定，否则，如果没有超类限定，则返回长度为0的数组。

> [API] `java.lang.reflect.ParameterizedType` 5.0
> - `Type getRawType()`
> 获得这个参数化类型的原始类型。
> - `Type[] getActualTypeArguments()`
> 获得这个参数化类型声明时所使用的类型参数。
> - `Type getOwnerType()`
> 如果是内部类型，则返回其外部类型，如果是一个顶级类型，则返回 `null` 。

> [API] `java.lang.reflect.GenericAnrayType` 5.0
> - `Type getGenericComponentType()`
> 获得该数组类型声明的泛型元素类型。

现在已经学习了：如何使用泛型类、以及在必要时如何自定义泛型类和泛型方法。同样重要的是，学习了「**在API文档和错误消息中遇到泛型类型声明时要如何理解**」。要想了解有关Java泛型更加详尽的信息，可以查看[这里](http://angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html)，有一个很好的常见问题解答列表（也有一些不太常见的问题）。

下面学习Java集合框架如何使用泛型。