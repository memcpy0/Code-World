@[toc]

> 参考资料：
> - Java核心技术卷II第10版第4章 数据库编程，以及英文版的*Core Java, Volume II--Advanced Features, 11th Edition, Chapter 5 Database Programming* 。 

1996年，Sun公司发布了第1版的**Java数据库连接JDBC API**（定义了一套操作不同关系型数据库的规则即接口，Sun公司只定义了标准接口，众所周知接口是无法直接使用的，我们需要使用接口的实现类；而这套实现类即驱动，就由各自的数据库厂商给出，它们定义了自己的JDBC实现类、提供数据库驱动JAR包、操作自己的数据库），使开发人员能通过这个API连接到数据库，并使用结构化查询语言（即SQL，它是数据库访问的业界标准）完成对数据库的查找与更新。**JDBC自此成为Java类库中最常使用的API之一**。
> JDBC是一个注册了商标的术语 *trademarked term* ，而不仅是 `Java Database Connectivity` 的首字母缩写 *acronym* 。对它的命名体现了对ODBC的致敬 *reminiscent* ，后者是微软开创的标准数据库API，并因此而并入了SQL标准中。具体的 *JDBC specification* 可以参见[这个网址](https://jcp.org/aboutJava/communityprocess/mrel/jsr221/index3.html)。
> 
> JDBC的版本已更新过数次。作为Java SE 1.2的一部分，1998年发布了JDBC 2。JDBC 3已经被囊括到了Java SE 1.4和5.0中，而在 *Core Java, 11th Edition* 出版之际，最新版的JDBC 4.3也被囊括到了Java 9中。

这里学习JDBC幕后的关键思想，并复习结构化查询语言 *Structured Query Language, SQL* ，它是关系数据库的业界标准。这里有足够的细节和示例，足以将JDBC融入到日常的编程中。

---
# 17.1 JDBC的设计
从一开始，Java开发者就意识到了Java在数据库应用方面的巨大潜力。从1995年开始，他们就致力于扩展Java标准类库，使之可以应用SQL访问数据库。他们最初希望通过扩展Java、就可以用“纯”Java语言与任何数据库进行通信。但是，他们很快发现这是一项无法完成的任务：因为业界存在许多不同的数据库，使用太多种协议。此外，尽管数据库供应商都支持**Java提供一套数据库访问的标准网络协议**，但每家企业都希望Java使用自己的网络协议。

所有的数据库供应商和工具开发商都认为，==如果Java能够为SQL访问提供一套“纯”Java API，同时提供一个**驱动程序管理器**，以允许第三方驱动程序可以连接到特定的数据库，那它就会显得非常有用==。这样，数据库供应商就可以**提供自己的驱动程序**来插入到驱动程序管理器中。然后，将有一个简单的机制来向驱动程序管理器**注册第三方驱动程序**。

这种接口组织方式遵循了微软公司非常成功的ODBC模式，ODBC为数据库访问提供了一套C编程语言接口。**JDBC和ODBC都基于同一个思想**：==根据API编写的程序与驱动程序管理器通信，而驱动管理器则通过驱动程序与实际数据库进行通信==。

JDBC的好处在于：
- 数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发；
- 可随时替换底层数据库，访问数据库的Java代码基本不变；

以后编写操作数据库的代码只需要面向JDBC（接口），操作哪个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要在项目中导入MySQL数据库的驱动包。
> 注意：为什么Java没有采用ODBC模式？下面就是在1996年5月举行的JavaOne研讨会上给出的说法：
> - ODBC很难学会。
> - ODBC中有几个命令需要配置很多复杂的选项，而在Java编程语言中所采用的风格是要让方法简单而直观，但数量巨大 *have simple and intuitive methods, but to have lots of them* 。
> - ODBC依赖于 `void *` 指针和其他C语言特性，而这些特性并不适用于Java语言。
> - 与纯Java的解决方案相比，基于ODBC的解决方案天生就缺乏安全性，且难于部署。

所有这些都意味着JDBC API是大部分程序员不得不使用的接口 *the JDBC API is all that most programmers will ever have to deal with* 。

## 17.1.1 JDBC驱动程序类型
JDBC规范将驱动程序归结为以下几类：
- **第1类驱动程序将JDBC翻译成ODBC，然后使用一个ODBC驱动程序与数据库进行通信**。较早版本的Java包含了一个这样的驱动程序：JDBC/ODBC桥，不过在使用这个桥接器之前，需要对一个ODBC驱动程序进行相应的部署和正确的设置 *the bridge requires deployment and proper configuration of an ODBC driver* 。在JDBC面世之初，桥接器可以方便地用于测试，却不太适用于产品的开发。此时，**有许多更好的驱动程序可用，JDK不再提供JDBC/ODBC桥**。
- **第2类驱动程序是由部分Java程序和部分本地代码组成的** *written partly in Java and partly in native code* ，用于与数据库的客户端API进行通信。当使用这样的驱动程序时，客户端不仅需要安装Java类库，还必须安装一些与平台相关的代码。
- **第3类驱动程序是纯Java客户端类库** *a pure Java client library* ，它使用一种独立于数据库的协议、将数据库请求发送给服务器构件，然后该构件再将数据库请求翻译成数据库相关的协议。**这简化了部署，因为平台相关的代码只位于服务器端**。
- **第4类驱动程序是纯Java类库** *a pure Java library* ，它将JDBC请求直接翻译成数据库相关的协议。

**大部分数据库供应商都为他们的产品提供第3类或第4类驱动程序**。与数据库供应商提供的驱动程序相比，许多第三方公司专门开发了很多更符合标准的产品，它们支持更多的平台、运行性能也更佳，某些情况下甚至具有更高的可靠性。

总之，JDBC最终是为了实现以下目标：
- 通过使用标准的SQL语句，甚至是专门的SQL扩展，程序员就可以利用Java语言开发访问任何数据库的应用，同时还依旧遵守Java语言的相关约定。
- 数据库供应商和数据库工具开发商可以提供底层的驱动程序。因此，他们可以优化其特定产品的驱动程序。

## 17.1.2 JDBC的典型用法
在传统的客户端/服务器模式中，通常是**在服务器端部署数据库，而在客户端有一个内容丰富的GUI界面**（参见图5-1）。**在此模型中，一个JDBC驱动程序被部署在客户端**。大体来说，通过Java操作数据库的流程是：
- 第一步：编写Java代码  
- 第二步：Java代码通过JDBC将SQL发送到MySQL服务端  
- 第三步：MySQL服务端接收到SQL语句并执行该SQL语句  
- 第四步：将SQL语句执行的结果返回给Java代码
![图5-1 传统的客户端/服务器应用](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206291501100.png)

然而，现在更常见的是使用三层模型 *three-tier model* ，甚至更高级的“n层模型”。在三层模型中，==客户端应用程序不直接进行数据库调用，相反，它调用服务器上的中间件层 *middleware layer*== ，**最后由中间件层完成数据库查询操作**。这种三层应用模式有以下优点：它将**可视化表示** *visual presentation*（位于客户端）从**业务逻辑** *business logic*（位于中间层）和**原始数据** *raw data*（位于数据库）中**分离出来**。因此，我们就**可以从不同的客户端**（如Java桌面应用、Web浏览器或一个手机应用）**来访问相同的数据和相同的业务规则**。

客户端和中间层之间的通信可以通过HTTP（在将Web浏览器用作客户端时），或诸如远程方法调用 `RMI`（在使用应用或Applet时）这样的机制来完成。JDBC则负责管理中间层和后端数据库之间的通信。图5-2展示了这种通信模型的基本架构。
![图5-2 三层模型](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206291805526.png)

当然，这种模型有多种变体，尤其是Java企业版（Java EE）为应用服务器定义了一种结构，用于管理称为企业级Java Bean（EJB）的代码模块，并且提供了许多重要的服务，比如高安全性、负载平衡、访问请求的高速缓存以及**对象-关系映射**等。在此架构中，JDBC仍然扮演了重要的角色，即完成复杂的数据库查询（关于Java企业版的更多信息请参见[官网](http://www.oracle.com/technetwork/java/javaee/overivew)）。 
> 注意：可以在Applet和Web应用中使用JDBC，但是也许你并不想这样做。在默认情况下，**安全管理器只允许Applet与这个Applet的下载来源服务器**（即Applet是从此服务器下载的）**建立数据库连接**。这就意味着Web服务器和数据库服务器（或第3类驱动程序的中断构件）必须在同一台机器上，但是这种配置并不典型。因此，你需要通过对该Applet进行代码签名来解决这个问题。

---
# 17.2 结构化查询语言
SQL是对所有现代关系型数据库都至关重要的命令行语言，JDBC让我们通过SQL与数据库进行通信。桌面数据库通常都有一个图形用户界面，使用这种界面，用户可以直接操作数据。但是，**基于服务器的数据库只能使用SQL进行访问**。

可以将JDBC包看作是一个应用编程接口（API），用来将SQL语句传递给数据库。在本节中将简要介绍SQL。还可以参阅关于SQL的其他著作，包括 *Alan Beaulieu* 所著的 *Learning SQL*（2005年由OReilly出版社出版），或者 *C.J.Date, Hugh Darwen* 合著的 *A Guide to the SQL Standard*（1997年由Addison-Wesley出版社出版）。

我们可以将一个数据库想象成一组由行和列构成的具名表，其中每一列都有列名 `column name` ，而每一行则包含了一个相关的数据集。作为数据库示例，我们将使用一组数据库表来描述经典计算机科学著作的集合（参见表17-1到表17-4）。
![表5.1 Authors表](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206291838857.png)
![表5-2 Books表](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206291856137.png)
![表5-3 BooksAuthors表](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206291857907.png)
![表5-4 Publishers表](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206291858746.png)
![图5-3 包含图书信息的示例表格](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206291900780.png)
![图5-4 对两个表进行连接操作](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206291900850.png)

图17-3显示的是一个 `Books` 表的视图，而图17-4显示了对 `Books` 表和 `Publishers` 表执行连接操作后的结果。`Books` 表和 `Publishers` 表都包含了一个表示出版社ID的字段。当我们利用出版社编号对这两个表进行连接操作时，我们就得到了由连接后的表格的值所组成的查询结果。结果中的每一行都包含了图书的信息、出版社名称及其Web页的URL地址。注意，有的出版社名称和URL地址重复出现在数行中，因为这些行都对应于同一个出版社。

对表格进行连接操作的好处是，**能避免在数据库表中出现不必要的重复数据**。例如，有一种比较简陋的数据库设计，是在Books表中设置出版社名称和URL地址字段。但是这样一来，数据库本身、而不仅仅是查询结果，将出现许多重复数据。如果出版社的Web地址发生了改变，就需要更新所有的重复数据。显然，这在一定程度上很容易导致错误 `error-prone` 。

**在关系模型中，我们将数据分布到多个表格中，使得所有信息都不会出现不必要的重复**（3NF，BCNF，4NF）。例如，每个出版社的URL地址只在出版社表中出现一次。如果需要将此信息与其他信息组合，我们只需对表进行连接操作。

在上述两幅图中，可以看到一个用于查看和链接表的图形工具。许多数据库供应商都会提供工具、以简单的形式表达查询，其方法是将列名连接起来，并将信息填入各表单中，这种工具通常称为**实例查询** *Query by Example, QBE* 工具。相反，使用SQL的查询则是利用SQL语法、以文本方式编写的。例如，
```mysql
SELECT Books, Books.Publisher_Id, Books.Price, Publishers.Name, Publishers.URL
FROM Books, Publishers
WHERE Books.Publisher_Id = Publishers.Publisher_Id
```
在余下部分中将介绍如何编写这样的查询语句。按照惯例，**SQL关键字全部使用大写字母**。当然，也可以不这样做。

`SELECT` 语句相当灵活。仅使用下面这个查询语句，就可以查出 `Books` 表中的所有记录：
```sql
SELECT * FROM Books
```

在每一个SQL的 `SELECT` 语句中，`FROM` 子句都是必不可少的。**`FROM` 子句告知数据库应该在哪个表上查询数据**。我们还可以选择所需要的列：
```sql
SELECT ISBN, Price, Title
FROM Books
```
并且还可以在查询语句中使用WHERE子句、来限定所要选择的行：
```sql
SELECT ISBN, Price, Title
FROM Books
WHERE Price <= 29.95
```
**小心使用“相等”这个比较操作**。与Java不同，SQL使用 `=` 和 `<>` 而非 `==` 和 `!=` 来进行相等比较。
> 注意：有些数据库供应商的产品支持在进行不等于比较时使用 `!=` 。这不符合标准SQL的语法，所以我们建议不要使用这种方法。

**`WHERE` 子句也可以使用 `LIKE` 操作符来实现模式匹配**。不过，这里的通配符并不是通常所说的 `*` 和 `?` ，而是用 `%` 表示 $0$ 或 $0$ 以上个字符，用下划线表示单个字符。例如，下面这条语句排除了所有书名中包含Unix或者Linux的图书。
```sql
SELECT ISBN, Price, Title
FROM Books
WHERE Title NOT LIKE '%n_x%'
```
注意，**字符串都是用单引号括起来的**，而非双引号。**字符串中的单引号则需要用一对单引号代替** `A single quote inside a string is represented by a pair of single quotes` 。例如，下列语句返回所有包含单引号的书名。
```sql
SELECT Title
FROM Books
WHERE Title LIKE '%''%'
```

也可以**从多个表中选取数据**：
```sql
SELECT * FROM Books, Publishers
```
如果没有 `WHERE` 子句，这一查询语句就意义不大了，它只是罗列了两个表中所有记录的组合（**笛卡尔积**）。在我们这个例子中，`Books` 表有 $20$ 行记录，`Publishers` 表有 $8$ 行记录，合并的结果将产生 $20\times 8$ 条记录，其中不乏大量重复数据。实际上我们需要对查询结果进行限制，说明我们只对那些图书与出版社相匹配的数据感兴趣。
```sql
SELECT * FROM Books, Publishers
WHERE Books.Publisher_Id = Publishers.Publisher_Id
```
这条语句的查询结果共有 $20$ 行记录，每一条记录对应于一本书，因为每本书在 `Publisher` 表中只对应一个出版社。

每当查询语句涉及多个表时，相同的列名可能会出现在两个不同的地方。在例子中也存在这种情况，`Books` 表和 `Publishers` 表都拥有一个列名为 `Publisher_Id` 的列。**当出现歧义时，可以在每个列名前添加它所在表的表名作为前缀**，比如 `Books.Publisher_Id` 。

我们也可以**使用SQL来修改数据库中的数据**。例如，假设现在要将所有书名中包含“C++”的图书降价 $5$ 美元，可以执行以下语句：
```sql
UPDATE Books
SET price = price - 5.00
WHERE Title LIKE '%C++%'
```
类似地，要删除所有的C++图书，可以使用下面的 `DELETE` 语句：
```sql
DELETE FROM Books
WHERE Title LIKE '%C++%'
```
此外，SQL中还有许多内置函数，用于对某一列计算平均值、查找最大值和最小值以及其他许多功能（[这一站点](http://sqlzoo.net)提供了一套既风趣幽默又颇具交互性的SQL指南）。

通常，可以**使用 `INSERT` 语句向表中插入值**：
```sql
INSERT INTO Books
VALUES 
	('A Guide to the SQL Standard', '0-201-96426-0', '0201', 47.95)
```
我们必须为「每一条插入到表中的记录」使用一次 `INSERT` 语句。

当然，在查询、修改和插入数据之前，必须要有存储数据的空间。可以使用 `CREATE TABLE` 语句创建一个新表，还可以为每一列指定列名和数据类型。
```sql
CREATE TABLE Books (
	Title CHAR(60),
	ISBN CHAR(13),
	Publisher_Id CHAR(6),
	Price DECIMAL(10, 2)
)
```
表5-5给出了最常见的SQL数据类型。其中 `NUMERIC` 为 $m$ 位长的定点十进制数；`DATE, TIME, TIMESTAMP` 都与具体的实现相关；`BLOB` 为二进制大对象，`CLOB` 为字符大对象。
![表5-5 SQL数据类型](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206301910636.png)

在这里不再介绍更多的子句，比如可以应用于 `CREATE TABLE` 语句的主键子句和约束子句。

---
# 17.3 JDBC配置
当然，我们需要有一个可获得其JDBC驱动程序的数据库软件 *a database program for which a JDBC driver is available* 。目前这方面有许多出色的软件可供选择，比如IBM DB2、Microsoft SQL Server、MySQL、Oracle和PostgreSQL。这里我们使用MySQL+Navicat。

为了练习还需要创建一个数据库，假定将这个数据库命名为 `COREJAVA` 。可以自己创建，或者让数据库管理员创建这个数据库，并让我们拥有适当权限，对这个数据库进行创建、更新和删除表的权限。在编写第一个数据库程序之前，需要收集大量的信息，下面将讨论这些内容。
## 17.3.1 数据库URL
在连接数据库时，我们必须使用各种「与数据库类型相关的参数」，例如主机名、端口号和数据库名。**JDBC使用了一种「与普通URL相类似的语法」来描述数据源**。下面是这种语法的实例，这些JDBC URL指定了名为 `COREJAVA` 的一个Derby数据库、一个PostgreSQL数据库、一个MySQL数据库（都是**数据源**）：
```sql
jdbc:derby://localhost:1527/COREJAVA;create=true
jdbc:postgresql:COREJAVA
jdbc:mysql://localhost:3306/COREJAVA
```
JDBC URL的一般语法为：
```java
jdbc:subprotocol:other stuff
// example
jdbc:mysql://ip地址(域名):端口号/数据库名称?参数键值对1&参数键值对2...
```
> 提示：对于MySQL来说，如果连接的是本机MySql服务器，并且MySQL服务默认端口是3306，则URL可以简写为：`jdbc:mysql://数据库名称?参数键值对` 。配置 `useSSL=false` 参数，禁用安全连接方式，解决警告提示。

其中，**`subprotocol` 用于选择「连接到数据库的具体驱动程序」**。`other stuff` 参数的格式随所使用的 `subprotocol` 不同而不同。如果要了解具体格式，需要查阅数据库供应商提供的相关文档。
## 17.3.2 驱动程序JAR文件
此外，为了通过JDBC连接到相应数据库，我们还需要获得包含了「所使用的数据库的驱动程序」的JAR文件。
- 如果使用的是Derby，那么就需要 `derbeclient.jar` ；
- 如果使用的是其他的数据库，那么就需要去寻找恰当的驱动程序。例如，PostgreSQL的驱动程序可以在[这里](http://jdbc.postgresql.org)找到。
- 如果使用的是MySQL数据库，我们需要下载MySQL Connector/J驱动程序，帮助Java程序操作MySQL。[下载地址](https://downloads.mysql.com/archives/c-j/)指向的页面如下所示。我们要在 `Product Version` 一栏中选择与 `mysql --version` 匹配的版本，在 `Operating System` 一栏中选择 `Platform Independent` ，并下载 `Platform Independent (Architecture Independent), ZIP Archive` 这个文件包：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206302151494.png)
	解压后，（对于我下载的版本来说）得到一个 `mysql-connector-java-8.0.27.jar` 文件。

**在运行访问数据库的程序时，需要将驱动程序的JAR文件包括到类路径中**（编译时并不需要这个JAR文件）。在**从命令行启动程序**时，只需要使用下面的命令：
```bash
$ java -classpath driverPath:. ProgramName
```
在Windows上，可以使用分号将**当前路径**（即由 `.` 字符表示的路径）与**驱动程序JAR文件**分隔开。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301061438010.png)

## 17.3.3 启动数据库
**数据库服务器在连接之前需要先启动**，启动的细节取决于所使用的数据库。例如，在使用Derby数据库时，需要遵循下面的步骤：
1. 打开命令行Shell，并转到将来存有数据库文件的目录中。
2. 定位 `derbyrun.jar` 。对于某些JDK版本，它包含在 `jdk/db/lib` 目录中，而另一些版本则将其置于单独的 `JavaDB` 安装目录中。如果没有包含，那就安装 `Apache Derby` ，并定位安装目录的JAR文件。我们用 `derby` 来表示包含 `lib/derbyrun.jar` 的目录。
3.  运行下面的命令：
	```bash
	$ java -jar derby/lib/derbyrun.jar server start
	```
4.  仔细检查数据库是否正确工作了。然后创建一个名为 `ij.properties` 并包含下面各行的文件：
	```sql
	ij.driver=org.apache.derby.jdbc.ClientDriver
	ij.protocol=jdbc:derby://localhost:1527/
	ij.database=COREJAVA;create=true
	```
	在另一个命令行shell中，通过执行下面的命令来运行**Derby的交互式脚本工具**（称为 `ij` ）：
	```bash
	$ java -jar derby/lib/derbyrun.jar ij -p ij.properties
	```
	现在，可以发布像下面这样的SQL命令了：
	```sql
	CREATE TABLE Greetings (Message CHAR(20));
	INSERT INTO Greetings VALUES ('Hello, World!');
	SELECT * FROM Greetings;
	DROP TABLE Greetings;
	```
	注意，每条命令都需要以分号结尾，要退出编辑器，可以键入 `EXIT;` 。
5.  在使用完数据库之后，可以用下面的命令关闭服务器：
	```bash
	$ java -jar derby/lib/derbyrun.jar server shutdown
	```

在使用MySQL数据库时，需要遵循下面的步骤（验证安装配置是否成功，可以运行 `mysql --version` 查看MySQL的版本）：
1. 为了使用MySQL数据库，必须先启动MySQL服务。在命令行中，（以管理员身份）运行 `net start mysql` 命令来启动MySQL服务。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207011240085.png)
2. 运行命令 `mysql -u 用户名 -p 密码` 登录MySQL：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207011243045.png)
3. 实验结束后，需要输入 `net stop mysql` 命令，停止MySQL服务。

如果使用其他的数据库，则需要查看文档，以了解**如何启动和关闭数据库服务器**，以及**如何连接到数据库**和**发布SQL命令**。 
## 17.3.4 注册驱动程序类
==许多JDBC的JAR文件（例如包含在Java SE 7中的Derby驱动程序）将**自动注册驱动程序类**，在这种情况下，可以跳过本节所描述的手动注册步骤==。包含 `META-INF/services/java.sql.Driver` 文件的JAR文件可以自动注册**驱动程序类** `driver class`（驱动中的实现类会导入这个接口，然后如MySQL用一个 `static` 块注册驱动），解压缩驱动程序JAR文件，就可以检查其是否包含该文件。例如，解压 `mysql-connector-java-8.0.27.jar` 文件，得到的结果如下图所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202206302344128.png)
> 注意：这种注册机制使用的是JAR规范中几乎不为人知的特性，请参见[官网](http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider)。自动注册对于遵循JDBC4的驱动程序是必需具备的特性。

如果驱动程序JAR文件不支持自动注册，那就需要找出数据库提供商使用的「JDBC驱动程序类的名字」。典型的驱动器名字如下：
```java
org.apache.derby.jdbc.ClientDriver
org.postgresql.Driver
com.mysql.cj.jdbc.Driver
```
最后一个是我下载的 `mysql-connector-java-8.0.27.jar` 中JDBC驱动程序类的名字：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202207011219637.png)

有两种方法可以向 `DriverManager` 注册驱动程序 *There are two ways to register the driver with the DriverManager* 。一种方式是**在Java程序中加载驱动程序类**，例如==下面的语句将使得驱动程序类被加载，从而执行「注册驱动程序的静态初始化器==即一个 `static` 语句块」*a static initializer that registers the driver* 。
```java
Class.forName("org.postgresql.Driver"); // force loading of driver class
Class.forName("com.mysql.cj.jdbc.Driver");
```
> 注意：Loading class 'com.mysql.jdbc.Driver'. This is deprecated. The new driver class is 'com.mysql.cj.jdbc.Driver'.

事实上，注册驱动的方法是 `registerDriver` ，但上面并不是这样写的：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301061214843.png)
我们查询MySQL提供的 `Driver` 类，看它是如何实现的，源码如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301061235370.png)
在该类中的静态代码块中已经执行了 `DriverManager` 对象的 `registerDriver()` 方法进行驱动的注册了，那么我们**只需要加载 `Driver` 类，该静态代码块就会执行**。而 `Class.forName("com.mysql.cj.jdbc.Driver");` 就可以加载 `Driver` 类。这就是该语句的执行过程！
> 提示：MySQL 5之后的驱动包，可以省略注册驱动的步骤。程序会自动加载Jar包中 `META-INF/services/java.sql.Driver` 文件中的驱动类，从而注册驱动程序。

另一种方式是**设置 `jdbc.drivers` 属性**。可以用命令行参数来指定这个属性，例如：
```bash
$ java -Djdbc.drivers=org.postgresql.Driver ProgramName
```
或者，应用程序可以通过以下调用来设置系统属性：
```java
System.setProperty("jdbc.drivers", "org.postgresql.Driver");
```
在这种方式中可以提供多个驱动程序，用冒号将它们分隔开，例如：
```java
org.postgresql.Driver:org.apache.derby.jdbc.ClientDriver
```

## 17.3.5 连接到数据库
**向 `DriverManager` 注册驱动程序后**，在Java程序中，我们可以用下面的代码**打开一个数据库连接**：
```java
// 打开一个PostgreSQL连接
String url = "jdbc:postgresql:COREJAVA";
String username = "dbuser"; // 数据库用户名
String password = "secret"; // 数据库密码
Connection conn = DriverManager.getConnection(url, username, password);

// 打开一个MySQL连接
String url = "jdbc:mysql://localhost:3306/stu_info?useSSL=false&useUnicode=true&characterEncoding=utf-8";
String username = "root";
String password = "wdmysqlmm123";
Connection conn = DriverManager.getConnection(url, username, password);
```
> 注意：在默认情况下，Derby允许我们使用任何用户名进行连接，并且不检查密码。它会为每个用户生成一个单独的表集合，而默认的用户名是 `app` 。

**驱动管理器 `DriverManager` 遍历所有注册过的驱动程序**，以便找到一个能够使用「数据库URL中指定的子协议」的驱动程序 *find a driver that can use the subprotocol specified in the database URL* 。

`getConnection` 方法返回一个 `Connection` 对象，注意：**要连接到数据库，我们还需要知道数据库的名字和密码**。下一节将详细介绍，如何使用 `Connection` 对象来执行SQL语句。`Connection` 数据库连接对象的作用，包括获取执行SQL的对象和管理事务等：
- 普通执行SQL对象：`Statement createStatement()` ；
- 预编译SQL的执行SQL对象（防止SQL注入）：`PreparedStatement prepareStatement(sql)` 。**通过这种方式获取的 `PreparedStatement` SQL语句执行对象**是重点要进行讲解的，**可以防止SQL注入**。
- 执行存储过程的对象：`PreparedStatement prepareStatement(sql)` 。通过这种方式获取的 `CallableStatement` 执行对象是用来执行存储过程的，而存储过程在MySQL中不常用，所以这个不进行讲解。
- ...

`DatabaseProgramming/test/TestDB.java` 的测试程序将所有这些步骤放到了一起：**它从文件 `database.properties` 中加载连接参数，并连接到数据库**。代码中提供的`database.properties` 文件包含的是关于MySQL数据库的连接信息，如果使用其他的数据库，则需要将与数据库相关的连接信息放到这个文件中。下面是一个用于连接到PostgreSQL（还有MySQL）数据库的示例：
```java
jdbc.drivers=org.postgresql.Driver
jdbc.url=jdbc:postgresql:COREJAVA
jdbc.username=dbuser
jdbc.password=secret
// --------------------------------
jdbc.drivers=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/COREJAVA?useSSL=false&useUnicode=true&characterEncoding=utf-8
jdbc.username=root
jdbc.password=wdmysqlmm123
```
在连接到数据库之后，这个测试程序执行了下面的SQL语句：
```mysql
CREATE TABLE Greetings (Message CHAR(20))
INSERT INTO Greetings VALUES ('Hello, World!')
SELECT * FROM Greetings
```
`SELECT` 的结果将被打印出来，应该可以看到如下的输出：
```java
Hello, World!
```
然后，通过执行下面的语句移除了这张表：
```java
DROP TABLE Greetings
```
要运行这个测试程序，需要启动数据库，并像下面这样启动这个程序（Windows用户需要注意，用 `;` 代替 `:` 来分隔路径元素）：
```shell
$ java ­classpath .:driverJAR test.TestDB
```
> 提示：==调试与JDBC相关的问题时，有种方法是启用JDBC的跟踪特性==。调用 `DriverManager.setLogWriter` 方法可以将跟踪信息发送给 `PrintWriter` ，而 `PrintWriter` 将输出JDBC活动的详细列表。
> 
> 大多数JDBC驱动程序的实现都提供了用于跟踪的附加特性，例如，在使用Derby时，可以在JDBC的URL中添加 `traceFile` 选项，如 `jdbc:derby://localhost:1527/COREJAVA;create=true;traceFile=trace.out` 。

```java
// test/TestDB.java
package test;

import java.nio.file.*;
import java.sql.*;
import java.io.*;
import java.util.*;

/**
 * This program tests that the database and the JDBC driver are correctly configured.
 */
public class TestDB {
	public static void main(String args[]) throws IOException {
		try {
			runTest();
		} catch (SQLException ex) {
			for (Throwable t : ex) t.printStackTrace();
		}
	}

	/**
	 * Runs a test by creating a table, adding a value, 
	 * showing the table contents, and removing the table.
	 */
	public static void runTest() throws SQLException, IOException {
		try (Connection conn = getConnection();
			Statement stat = conn.createStatement()) {
			stat.executeUpdate("CREATE TABLE Greetings (Message CHAR(20))");
			stat.executeUpdate("INSERT INTO Greetings VALUES('Hello, World!')");
			try (ResultSet result = stat.executeQuery("SELECT * FROM Greetings")) {
				if (result.next())
					System.out.println(result.getString(1));
			}
			stat.executeUpdate("DROP TABLE Greetings");
		}
	}

	/**
	 * Gets a connection from the properties specified in the file database.properties.
	 * @return  the database connection
	 */
	public static Connection getConnection() throws SQLException, IOException {
		var props = new Properties();
		try (InputStream in = Files.newInputStream(Paths.get("./src/test/dnetatabase.properties"))) {
			props.load(in);
		}
		String drivers = props.getProperty("jdbc.drivers");
		if (drivers != null) System.setProperty("jdbc.drivers", drivers);
		String url = props.getProperty("jdbc.url");
		String username = props.getProperty("jdbc.username");
		String password = props.getProperty("jdbc.password");
		return DriverManager.getConnection(url, username, password);
	}
}
```
结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301061506180.png)

> [API] `java.sql.DriverManager` 1.1
> - `static Connection getConnection(String url, String user, String password)`
> 建立一个到指定数据库的连接，并返回一个 `Connection` 对象。

---
# 5.4 执行SQL语句
在执行SQL命令之前，首先需要创建一个 `Statement` 对象。要创建 `Statement` 对象，需要使用「调用 `DriverManager.getConnection` 方法获得的 `Connection` 对象」。
```java
Statement stat = conn.createStatement();
```
接着，将要执行的SQL语句放入字符串中，例如：
```java
String command = "UPDATE Books"
	+ " SET Price = Price ­ 5.00"
	+ " WHERE Title NOT LIKE '%Introduction%'";
```
然后，调用 `Statement` 接口中的 `executeUpdate` 方法：
```java
stat.executeUpdate(command);
```
**`executeUpdate` 方法将返回受SQL命令影响的行数，或对于不返回行数的语句返回0**（有可能影响0行，有可能没有行数）。例如，在先前的例子中调用 `executeUpdate` 方法将返回那些降价5美元的行数。

`executeUpdate` 方法既可以执行如 `INSERT, UPDATE, DELETE` 之类的DQL操作，也可以执行如 `CREATE TABLE, DROP TABLE` 之类的数据定义DDL语句（**开发很少使用Java代码操作DDL语句**）。但执行 `SELECT` 查询必须使用 `executeQuery` 方法。另外还有一个 `execute` 语句可以执行任意的SQL语句，此方法通常只用于由用户提供的交互式查询 *queries that a user supplies interactively* 。

当我们执行查询操作时，通常最感兴趣的是查询结果。`executeQuery` 方法返回一个`ResultSet` 类型的对象，可以通过它来**每次一行地迭代遍历**所有查询结果：
```java
ResultSet rs = stat.executeQuery("SELECT * FROM Books");
```
分析结果集时，通常可以使用类似如下循环语句的代码：
```java
while (rs.next()) {
	// look at a row of the result set
}
```
> 警告：`ResultSet` 接口的迭代协议与 `java.util.Iterator` 接口稍有不同。对于 `ResultSet` 接口，迭代器初始化时被设定在第一行之前的位置，**必须调用 `next` 方法将它移动到第一行**。另外，它没有 `hasNext` 方法，我们**需要不断地调用 `next` ，直至该方法返回 `false`** 。

==结果集中行的顺序是任意的==。除非使用 `ORDER BY` 子句指定行的顺序，否则不能为行序强加任何意义。

查看每一行时，可能希望知道其中每一列的内容，有许多访问器 *accessor* 方法可以用于获取这些信息。不同的数据类型有不同的访问器，比如 `getString, getDouble` 。==每个访问器都有两种形式，一种接受数字型参数，另一种接受字符串参数。当使用数字型参数时，我们指的是该数字所对应的列==。例如，`rs.getString(1)` 返回的是当前行中第一列的值。
> 警告：与数组的索引不同，数据库的列序号是从1开始计算的。

==当使用字符串参数时，指的是结果集中以该字符串为列名的列==。例如，`rs.getDouble("Price")` 返回列名为 `Price` 的列所对应的值。使用数字型参数效率更高一些，但使用字符串参数可以使代码易于阅读和维护。

**当 `get` 方法的类型和列的数据类型不一致时，每个 `get` 方法都会进行合理的类型转换**。例如，调用 `rs.getString("Price")` 时，该方法会将 `Price` 列的浮点值转换成字符串。

下面给出一个案例，说明一下如何处理结果集数据、并存储到Java对象中。需求是——查询 `account` 账户表数据，封装为 `Account` 对象中，并且存储到 `ArrayList` 集合中。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301120025774.png)
```java
/**  
 * 查询account账户表数据, 封装为Account对象中, 并且存储到ArrayList集合中
 * 1. 定义实体类Account
 * 2. 查询数据, 封装到Account对象中
 * 3. 将Account对象存入ArrayList集合中
 */
@Test
public void testResultSet2() throws  Exception {
   // 1. 注册驱动
   // Class.forName("com.mysql.jdbc.Driver");
   // 2. 获取连接：如果连接的是本机mysql并且端口是默认的3306, 可以简化书写
   String url = "jdbc:mysql:///db1?useSSL=false";
   String username = "root";
   String password = "1234";
   Connection conn = DriverManager.getConnection(url, username, password);
   // 3. 定义sql
   String sql = "select * from account";
   // 4. 获取statement对象
   Statement stmt = conn.createStatement();
   // 5. 执行sql
   ResultSet rs = stmt.executeQuery(sql);
   // 创建集合
   List<Account> list = new ArrayList<>();
   // 6.1 光标向下移动一行，并且判断当前行是否有数据
   while (rs.next()){
       Account account = new Account();
       // 6.2 获取数据 getXxx()
       int id = rs.getInt("id");
       String name = rs.getString("name");
       double money = rs.getDouble("money");
       //赋值
       account.setId(id);
       account.setName(name);
       account.setMoney(money);
       // 存入集合
       list.add(account);
   }
   System.out.println(list);
   // 7. 释放资源
   rs.close();
   stmt.close();
   conn.close();
}
```
> [API] `java.sql.Connection` 1.1
> - `Statement createStatement()`
> 创建一个 `Statement` 对象，用以执行不带参数的SQL查询和更新。
> - `void close()`
> 用于立即关闭当前的连接、以及释放由它所创建的JDBC资源。

> [API] `java.sql.Statement` 1.1
> - `ResultSet executeQuery(String sqlQuery)`
> 执行给定字符串中的SQL语句，并返回一个用于查看查询结果的 `ResultSet` 对象。
> - `int executeUpdate(String sqlStatement)`
> 执行字符串中指定的 `INSERT, UPDATE, DELETE` 等SQL语句。还可以执行数据定义语言的语句，如 `CREATE TABLE` 。返回受影响的行数，如果是没有更新计数的语句，则返回0。
> - `boolean execute(String sqlStatement)`
> 执行字符串中指定的SQL语句。**可能会产生多个结果集和更新计数**。如果第一个执行结果是结果集，则返回 `true` ；反之，返回 `false` 。调用 `getResultSet` 或 `getUpdateCount` 方法可以得到第一个执行结果。参见第17.5.4节中关于处理多结果集的详细信息。
> - `ResultSet getResultSet()`
> 返回前一条查询语句的结果集。如果前一条语句未产生结果集，则返回 `null` 值。对于每一条执行过的语句，该方法只能被调用一次。
> - `int getUpdateCount()`
> - `long getLargeUpdateCount()` 8
> 返回受前一条更新语句影响的行数。如果前一条语句未更新数据库，则返回-1。对于每一条执行过的语句，该方法只能被调用一次。
> - `void close()`
> 关闭 `Statement` 对象以及它所对应的结果集。
> - `boolean isClosed()` 6
> 如果语句被关闭，则返回 `true` 。
> - `void closeOn Compleion()` 7
> 使得一旦该语句的所有结果集都被关闭，则关闭该语句。

> [API] `java.sql.ResultSet` 1.1
> - `boolean next()`
> 将结果集中的当前行向前移动一行。如果已经到达最后一行的后面，则返回 `false` 。注意，初始情况下必须调用该方法才能转到第一行。
> - `Xxx getXxx(int columnNumber)`
> - `Xxx getXxx(String columnName)`
> Xxx指数据类型，例如 `int, double, String, Date` 等。
> - `<T> T getObject(int columnNumber, Class<T> type)` 7
> - `<T> T getObject(String columnLabel, Class<T> type)` 7 
> - `void updateObject(int columnIndex, Object x, SQLType targetSqlType)` 8
> - `void updateObject(String columnLabel, Object x, SQLType targetSqlType)` 8
> 用给定的列序号或列标签，返回或更新该列的值，并将值转换成指定类型。列标签是SQL的 `AS` 字句中指定的标签，在没有使用 `AS` 时就是列名。
> - `int findColumn(String columnName)`
> 根据给定的列名，返回该列的序号。
> - `void close()`
> 立即关闭当前的结果集。
> - `boolean isClosed()` 6
> 如果该语句被关闭，则返回 `true` 。

## 17.4.1 管理连接、语句和结果集
每个 `Connection` 对象都可以创建一个或多个 `Statement` 对象。同一个 `Statement` 对象**可以用于多个不相关的命令和查询**。但**一个 `Statement` 对象最多只能有一个打开的结果集**。如果需要执行多个查询操作，且**需要同时分析查询结果**，那么必须创建多个 `Statement` 对象。

需要说明的是，每个 `Connection` 上的语句数是有限制的。使用 `DatabaseMetaData` 接口中的 `getMaxStatements` 方法，可以获取JDBC驱动程序支持的、同时活动的语句对象的总数。

这看上去似乎很有局限性。但实际上，**我们通常并不需要同时处理多个结果集**。==如果结果集相互关联，我们就可以使用组合查询，这样就只需要分析一个结果==。对数据库进行组合查询，比使用Java程序遍历多个结果集要高效得多。

我们应确保，在一个 `Statement` 对象上触发新的查询或更新语句之前，结束对所有结果集的处理，因为**前序查询的所有结果集都会被自动关闭**。

使用完 `ResultSet, Statement, Connection` 对象后，应立即调用 `close` 方法。这些对象都使用了规模较大的数据结构，它们会占用数据库存服务器上的有限资源。

如果 `Statement` 对象上有一个打开的结果集，那么调用 `close` 方法将自动关闭该结果集。同样地，**调用 `Connection` 类的 `close` 方法将关闭该连接上的所有语句**。反过来的情况是，在使用Java 7时，可以在 `Statement` 上调用 `closeOnCompletion` 方法，**在其所有结果集都被关闭后，该语句会立即被自动关闭**。

==如果所用连接都是短时的，那么无需考虑关闭语句和结果集==。只需将 `close` 语句放在带资源 `try` 语句中，以便确保最终连接对象不可能继续保持打开状态。
```java
try (Connection conn = ...) {
	Statement stat = conn.createStatement();
	ResultSet result = stat.executeQuery(queryString);
	// process query result
}
```
 
## 17.4.2 分析SQL异常
每个 `SQLException` 都有一个由多个 `SQLException` 对象构成的链，这些对象可以通过 `getNextException` 方法获取。这个异常链是每个异常都具有的、由 `Throwable` 对象构成的“成因”链之外的异常链 *This exception chain is in addition to the “cause” chain of Throwable objects that every exception has*（参见卷I章7、以了解Java异常的详细信息），因此我们需要**用两个嵌套的循环来完整枚举所有的异常**。

幸运的是，Java 6改进了 `SQLException` 类，让其实现了 `Iterable<Throwable>` 接口，其 `iterator()` 方法可以产生一个 `Iterable<Throwable>` ，这个迭代器可以迭代这两个链，首先迭代第一个 `SQLException` 的成因链，然后迭代到下一个 `SQLException` ，以此类推。我们可以直接使用下面这个改进的for循环：
```java
for (Throwable t : sqlException) {
	// do something with t
}
```
可以在 `SQLException` 上调用 `getSQLState` 和 `getErrorCode` 方法来进一步分析它，其中第一个方法将产生符合 `X/Open` 或 `SQL:2003` 标准的字符串（调用 `DatabaseMetaData` 接口的 `getSQLStateType` 方法，可以查出驱动程序所使用的标准）。而错误代码是与具体的提供商相关的。

**SQL异常按照层次结构树的方式组织到了一起**（如图17-5所示），这使得我们可以按照提供商无关的方式 *vendor­independent way* 来捕获具体的错误类型。
![图17-5 SQL异常类型](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301062334364.png)

另外，数据库驱动程序可以将非致命问题作为警告 *warnings* 报告，我们可以从连接、语句和结果集中获取这些警告。`SQLWarning` 类是 `SQLException` 的子类（尽管 `SQLWarning` 不会被当作异常抛出），我们可以调用 `getSQLState` 和 `getErrorCode` 来获取有关警告的更多信息。**与SQL异常类似，警告也是串成链的**。要获得所有的警告，可以使用下面的循环：
```java
SQLWarning w = stat.getWarning();
while (w != null) {
	// do something with w
	w = w.nextWarning();
}
```
当数据从数据库中读出并意外被截断 *unexpectedly truncated* 时，`SQLWarning` 的 `DataTruncation` 子类就派上用场了。如果数据截断发生在更新语句中，那么 `DataTruncation` 将会被当作异常抛出。
> [API] `java.sql.SQLException` 1.1
> - `SQLException getNextException()`
> 返回链接到该SQL异常的下一个SQL异常，或者在到达链尾时返回 `null` 。
> - `Iterator<Throwable> iterator()` 6
> 获取迭代器，可以迭代链接的SQL异常和它们的成因。
> - `String getSQLState()`
> 获取“SQL状态”，即标准化的错误代码。
> - `int getErrorCode()`
> 获取提供商相关的错误代码。

> [API] `java.sql.SQLWarning` 1.1
> - `SQLWarning getNextWarning()`
> 返回链接到该警告的下一个警告，或者在到达链尾时返回 `null` 。

> [API] `java.sql.Connection` 1.1
> [API] `java.sql.Statement` 1.1
> [API] `java.sql.ResultSet` 1.1
> - `SQLWarning getWarnings()`
> 返回未处理警告中的第一个，或者在没有未处理警告时返回 `null` 。

> [API] `java.sql.DataTruncation` 1.1
> - `boolean getParameter()`
> 如果在参数上进行了数据截断 *if the data truncation applies to a parameter* ，则返回 `true` ；如果在列上进行了数据截断，则返回 `false` 。
> - `int getIndex()`
> 返回被截断的参数或列的索引。
> - `int getDataSize()`
> 返回应该被传输的字节数量，或者在该值未知的情况下返回-1。
> - `int getTransferSize()`
> 返回实际被传输的字节数量，或者在该值未知的情况下返回-1。

## 17.4.3 组装数据库
至此，大家也许都迫不及待地想编写一个真正实用的JDBC程序了。如果可以编写一段程序、来执行之前介绍的那些巧妙的查询，那当然很好。不过，在此之前还有一个问题没有解决：目前数据库中还没有数据。我们需要组装数据库，并且也确实存在一种简单方法可以实现此目的：用一系列的SQL指令来创建数据表、并向其中插入数据。大多数数据库程序都可以处理来自文本文件中的一系列SQL指令，但在语句终止符和其他一些文法问题上，这些数据库程序之间存在着令人讨厌的差异。

正由于这个原因，我们使用JDBC创建了一个简单的程序，它从文件中读取SQL指令，其中一条指令占据一行，然后执行它们。该程序专门用于从下列格式的文本文件中读取数据：
```mysql
CREATE TABLE Publishers (Publisher_Id CHAR(6), Name CHAR(30), URL CHAR(80));
INSERT INTO Publishers VALUES ('0201', 'Addison­Wesley', 'www.aw­bc.com');
INSERT INTO Publishers VALUES ('0471', 'John Wiley & Sons', 'www.wiley.com');
...
```
`DatabaseProgramming/exec/ExecSQL.java` 是用来读取SQL语句文件、以及执行这些语句的程序代码。通读这些代码并不重要，在这里只是提供了这样的程序，使你能够组装数据库 *populate your database* 、并运行剩余部分的代码。

请确认你的数据库服务器是在运行的，然后可以使用如下方法运行该程序：
```bash
$ java ­-classpath driverPath:. exec.ExecSQL Books.sql
$ java ­-classpath driverPath:. exec.ExecSQL Authors.sql
$ java ­-classpath driverPath:. exec.ExecSQL Publishers.sql
$ java ­-classpath driverPath:. exec.ExecSQL BooksAuthors.sql
```
在运行程序之前，检查 `database.properties` 文件是否已为你的运行环境进行了正确设置。
> 注意：**你的数据库可能也包含直接从SQL文件读取的工具**（这里可以用Navicat等等），例如在使用Derby时，可以运行下面的命令：`
> ```bash
> $ java ­jar derby/lib/derbyrun.jar ij ­p ij.properties Books.sql
> ```
>（`ij.properties` 文件在17.3.3节中描述过）。在用于ExecSQL命令的数据格式中，我们允许每行的结尾都可以有一个**可选的分号**，因为大多数数据库工具都希望使用这种格式。

下面简要介绍一下ExecSQL程序的操作步骤：
1. **连接数据库**。`getConnection` 方法读取 `database.properties` 文件中的属性信息，并将属性 `jdbc.drivers` 添加到系统属性中，驱动程序管理器使用属性 `jdbc.drivers` 加载相应的驱动程序。`getConnection` 方法使用 `jdbc.url, jdbc.username, jdbc.password` 等属性打开数据库连接。
2. 打开包含SQL语句的文件。如果未提供任何文件名，则在控制台中提示用户输入语句。
3. **使用泛化的 `execute` 方法执行每条语句。如果它返回 `true` ，则说明该语句产生了一个结果集**。为图书数据库提供的4个SQL文件都以一个 `SELECT *` 语句结束，这样就可以看到数据是否已成功插入到了数据库中。
4. **如果产生了结果集，则打印出结果**。因为这是一个泛化的结果集，所以必须使用元数据来确定该结果的列数。更多信息查看17.8节。
5. 如果运行过程中出现SQL异常，则打印出这个异常、以及所有可能包含在其中的与其链接在一起的相关异常。
6. 关闭数据库连接。

```java
// exec/ExecSQL.java
package exec;

import java.io.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;
import java.sql.*;

/**
 * Executes all SQL statements in a file. Call this program as <br>
 * java -classpath driverpath:. ExecSQL commandFile
 */
class ExecSQL {
	public static void main(String[] args) throws IOException {
		try (Scanner in = args.length == 0 ? new Scanner(System.in)
			: new Scanner(Paths.get(args[0]), StandardCharsets.UTF_8)) {
			try (Connection conn = getConnection();
				Statement stat = conn.createStatement()) {
				while (true) {
					if (args.length == 0) System.out.println("Enter command or EXIT to exit:");
					if (!in.hasNextLine()) return;
					
					String line = in.nextLine().trim();
					if (line.equalsIgnoreCase("EXIT")) return;
					if (line.endsWith(";")) // remove trailing semicolon
						line = line.substring(0, line.length() - 1);
					try {
						boolean isResult = stat.execute(line);
						if (isResult) {
							try (ResultSet rs = stat.getResultSet()) {
								showResultSet(rs);
							}
						} else {
							int updateCount = stat.getUpdateCount();
							System.out.println(updateCount + " rows updated");
						}
					} catch (SQLException e) {
						for (Throwable t : e) t.printStackTrace();
					}
				}
			}
		} catch (SQLException e) {
			for (Throwable t : e) t.printStackTrace();
		}
	}

	/**
	 * Gets a connection from the properties specified in the file database.properties
	 * @return the database connection
	 */
	public static Connection getConnection() throws SQLException, IOException {
		var props = new Properties();
		try (InputStream in = Files.newInputStream(Paths.get("./src/exec/database.properties"))) {
			props.load(in);
		}
		String drivers = props.getProperty("jdbc.drivers");
		if (drivers != null) System.setProperty("jdbc.drivers", drivers);

		String url = props.getProperty("jdbc.url");
		String username = props.getProperty("jdbc.username");
		String password = props.getProperty("jdbc.password");
		return DriverManager.getConnection(url, username, password);
	}

	/**
	 * Prints a result set.
	 * @param result the result set to be printed
	 */
	public static void showResultSet(ResultSet result) throws SQLException {
		ResultSetMetaData metaData = result.getMetaData();
		int columnCount = metaData.getColumnCount();
		for (int i = 1; i <= columnCount; ++i) {
			if (i > 1) System.out.print(", ");
			System.out.print(metaData.getColumnLabel(i));
		}
		System.out.println();
		while (result.next()) {
			for (int i = 1; i <= columnCount; ++i) {
				if (i > 1) System.out.print(", ");
				System.out.print(result.getString(i));
			}
			System.out.println();
		}
	}
}
```
```mysql
-- Authors.sql
CREATE TABLE Authors (Author_Id CHAR(4), Name CHAR(25), Fname CHAR(25));
INSERT INTO Authors VALUES ('ALEX', 'Alexander', 'Christopher');
INSERT INTO Authors VALUES ('BROO', 'Brooks', 'Frederick P.');
INSERT INTO Authors VALUES ('CORM', 'Cormen', 'Thomas H.');
INSERT INTO Authors VALUES ('DATE', 'Date', 'C. J.');
INSERT INTO Authors VALUES ('DARW', 'Darwen', 'Hugh');
INSERT INTO Authors VALUES ('FEIN', 'Feiner', 'Steven K.');
INSERT INTO Authors VALUES ('FLAN', 'Flanagan', 'David');
INSERT INTO Authors VALUES ('FOLE', 'Foley', 'James D.');
INSERT INTO Authors VALUES ('GAMM', 'Gamma', 'Erich');
INSERT INTO Authors VALUES ('GARF', 'Garfinkel', 'Simson');
INSERT INTO Authors VALUES ('HEIN', 'Hein', 'Trent R.');
INSERT INTO Authors VALUES ('HELM', 'Helm', 'Richard');
INSERT INTO Authors VALUES ('HOPC', 'Hopcroft', 'John E.');
INSERT INTO Authors VALUES ('HUGH', 'Hughes', 'John F.');
INSERT INTO Authors VALUES ('ISHI', 'Ishikawa', 'Sara');
INSERT INTO Authors VALUES ('JOHN', 'Johnson', 'Ralph');
INSERT INTO Authors VALUES ('KAHN', 'Kahn', 'David');
INSERT INTO Authors VALUES ('KERN', 'Kernighan', 'Brian');
INSERT INTO Authors VALUES ('KIDD', 'Kidder', 'Tracy');
INSERT INTO Authors VALUES ('KNUT', 'Knuth', 'Donald E.');
INSERT INTO Authors VALUES ('LEIS', 'Leiserson', 'Charles E.');
INSERT INTO Authors VALUES ('MOTW', 'Motwani', 'Rajeev');
INSERT INTO Authors VALUES ('NEME', 'Nemeth', 'Evi');
INSERT INTO Authors VALUES ('RAYM', 'Raymond', 'Eric');
INSERT INTO Authors VALUES ('RITC', 'Ritchie', 'Dennis');
INSERT INTO Authors VALUES ('RIVE', 'Rivest', 'Ronald R.');
INSERT INTO Authors VALUES ('SCHN', 'Schneier', 'Bruce');
INSERT INTO Authors VALUES ('SEEB', 'Seebass', 'Scott');
INSERT INTO Authors VALUES ('SILV', 'Silverstein', 'Murray');
INSERT INTO Authors VALUES ('SNYD', 'Snyder', 'Garth');
INSERT INTO Authors VALUES ('STEI', 'Stein', 'Clifford E.');
INSERT INTO Authors VALUES ('STOL', 'Stoll', 'Clifford');
INSERT INTO Authors VALUES ('STRA', 'Strassmann', 'Steven');
INSERT INTO Authors VALUES ('STRO', 'Stroustrup', 'Bjarne');
INSERT INTO Authors VALUES ('ULLM', 'Ullman', 'Jeffrey D.');
INSERT INTO Authors VALUES ('VAND', 'van Dam', 'Andries');
INSERT INTO Authors VALUES ('VLIS', 'Vlissides', 'John');
INSERT INTO Authors VALUES ('WEIS', 'Weise', 'Daniel');
SELECT * FROM Authors;
```
```sql
-- Books.sql
CREATE TABLE Books (Title CHAR(60), ISBN CHAR(13), Publisher_Id CHAR(6), Price DECIMAL(10,2));
INSERT INTO Books VALUES ('A Guide to the SQL Standard', '0-201-96426-0', '0201', 47.95);
INSERT INTO Books VALUES ('A Pattern Language: Towns, Buildings, Construction', '0-19-501919-9', '019', 65.00);
INSERT INTO Books VALUES ('Applied Cryptography', '0-471-11709-9', '0471', 60.00);
INSERT INTO Books VALUES ('Computer Graphics: Principles and Practice', '0-201-84840-6', '0201', 79.99);
INSERT INTO Books VALUES ('Cuckoo''s Egg', '0-7434-1146-3', '07434', 13.95);
INSERT INTO Books VALUES ('Design Patterns', '0-201-63361-2', '0201', 54.99);
INSERT INTO Books VALUES ('Introduction to Algorithms', '0-262-03293-7', '0262', 80.00);
INSERT INTO Books VALUES ('Introduction to Automata Theory, Languages, and Computation', '0-201-44124-1', '0201', 105.00);
INSERT INTO Books VALUES ('JavaScript: The Definitive Guide', '0-596-00048-0', '0596', 44.95);
INSERT INTO Books VALUES ('The Art of Computer Programming vol. 1', '0-201-89683-4', '0201', 59.99);
INSERT INTO Books VALUES ('The Art of Computer Programming vol. 2', '0-201-89684-2', '0201', 59.99);
INSERT INTO Books VALUES ('The Art of Computer Programming vol. 3', '0-201-89685-0', '0201', 59.99);
INSERT INTO Books VALUES ('The C Programming Language', '0-13-110362-8', '013', 42.00);
INSERT INTO Books VALUES ('The C++ Programming Language', '0-201-70073-5', '0201', 64.99);
INSERT INTO Books VALUES ('The Cathedral and the Bazaar', '0-596-00108-8', '0596', 16.95);
INSERT INTO Books VALUES ('The Codebreakers', '0-684-83130-9', '07434', 70.00);
INSERT INTO Books VALUES ('The Mythical Man-Month', '0-201-83595-9', '0201', 29.95);
INSERT INTO Books VALUES ('The Soul of a New Machine', '0-679-60261-5', '0679', 18.95);
INSERT INTO Books VALUES ('The UNIX Hater''s Handbook', '1-56884-203-1', '0471', 16.95);
INSERT INTO Books VALUES ('UNIX System Administration Handbook', '0-13-020601-6', '013', 68.00);
SELECT * FROM Books
```
```mysql
-- BooksAuthors.sql
CREATE TABLE BooksAuthors (ISBN CHAR(13), Author_Id CHAR(4), Seq_No INT);
INSERT INTO BooksAuthors VALUES ('0-201-96426-0', 'DATE', 1);
INSERT INTO BooksAuthors VALUES ('0-201-96426-0', 'DARW', 2);
INSERT INTO BooksAuthors VALUES ('0-19-501919-9', 'ALEX', 1);
INSERT INTO BooksAuthors VALUES ('0-19-501919-9', 'ISHI', 2);
INSERT INTO BooksAuthors VALUES ('0-19-501919-9', 'SILV', 3);
INSERT INTO BooksAuthors VALUES ('0-471-11709-9', 'SCHN', 1);
INSERT INTO BooksAuthors VALUES ('0-201-84840-6', 'FOLE', 1);
INSERT INTO BooksAuthors VALUES ('0-201-84840-6', 'VAND', 2);
INSERT INTO BooksAuthors VALUES ('0-201-84840-6', 'FEIN', 3);
INSERT INTO BooksAuthors VALUES ('0-201-84840-6', 'HUGH', 4);
INSERT INTO BooksAuthors VALUES ('0-7434-1146-3', 'STOL', 1);
INSERT INTO BooksAuthors VALUES ('0-201-63361-2', 'GAMM', 1);
INSERT INTO BooksAuthors VALUES ('0-201-63361-2', 'HELM', 2);
INSERT INTO BooksAuthors VALUES ('0-201-63361-2', 'JOHN', 3);
INSERT INTO BooksAuthors VALUES ('0-201-63361-2', 'VLIS', 4);
INSERT INTO BooksAuthors VALUES ('0-262-03293-7', 'CORM', 1);
INSERT INTO BooksAuthors VALUES ('0-262-03293-7', 'LEIS', 2);
INSERT INTO BooksAuthors VALUES ('0-262-03293-7', 'RIVE', 3);
INSERT INTO BooksAuthors VALUES ('0-262-03293-7', 'STEI', 4);
INSERT INTO BooksAuthors VALUES ('0-201-44124-1', 'HOPC', 1);
INSERT INTO BooksAuthors VALUES ('0-201-44124-1', 'ULLM', 2);
INSERT INTO BooksAuthors VALUES ('0-201-44124-1', 'MOTW', 3);
INSERT INTO BooksAuthors VALUES ('0-596-00048-0', 'FLAN', 1);
INSERT INTO BooksAuthors VALUES ('0-201-89683-4', 'KNUT', 1);
INSERT INTO BooksAuthors VALUES ('0-201-89684-2', 'KNUT', 1);
INSERT INTO BooksAuthors VALUES ('0-201-89685-0', 'KNUT', 1);
INSERT INTO BooksAuthors VALUES ('0-13-110362-8', 'KERN', 1);
INSERT INTO BooksAuthors VALUES ('0-13-110362-8', 'RITC', 2);
INSERT INTO BooksAuthors VALUES ('0-201-70073-5', 'STRO', 1);
INSERT INTO BooksAuthors VALUES ('0-596-00108-8', 'RAYM', 1);
INSERT INTO BooksAuthors VALUES ('0-684-83130-9', 'KAHN', 1);
INSERT INTO BooksAuthors VALUES ('0-201-83595-9', 'BROO', 1);
INSERT INTO BooksAuthors VALUES ('0-679-60261-5', 'KIDD', 1);
INSERT INTO BooksAuthors VALUES ('1-56884-203-1', 'GARF', 1);
INSERT INTO BooksAuthors VALUES ('1-56884-203-1', 'WEIS', 2);
INSERT INTO BooksAuthors VALUES ('1-56884-203-1', 'STRA', 3);
INSERT INTO BooksAuthors VALUES ('0-13-020601-6', 'NEME', 1);
INSERT INTO BooksAuthors VALUES ('0-13-020601-6', 'SNYD', 2);
INSERT INTO BooksAuthors VALUES ('0-13-020601-6', 'SEEB', 3);
INSERT INTO BooksAuthors VALUES ('0-13-020601-6', 'HEIN', 4);
SELECT * FROM BooksAuthors;
```
```mysql
-- Publishers.sql
CREATE TABLE Publishers (Publisher_Id CHAR(6), Name CHAR(30), URL CHAR(80));
INSERT INTO Publishers VALUES ('0201', 'Addison-Wesley', 'www.aw-bc.com');
INSERT INTO Publishers VALUES ('0471', 'John Wiley & Sons', 'www.wiley.com');
INSERT INTO Publishers VALUES ('0262', 'MIT Press', 'mitpress.mit.edu');
INSERT INTO Publishers VALUES ('0596', 'O''Reilly', 'www.ora.com');
INSERT INTO Publishers VALUES ('019', 'Oxford University Press', 'www.oup.co.uk');
INSERT INTO Publishers VALUES ('013', 'Prentice Hall', 'www.phptr.com');
INSERT INTO Publishers VALUES ('0679', 'Random House', 'www.randomhouse.com');
INSERT INTO Publishers VALUES ('07434', 'Simon & Schuster', 'www.simonsays.com');
SELECT * FROM Publishers;
```
以Eclipse为例，在Run Configurations中，分别填入 `./src/exec/Authors.sql, ./src/exec/Books.sql, ./src/exec/BooksAuthors.sql, ./src/exec/Publishers.sql` ：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301071318585.png)
运行结果分别如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301071319612.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301071320588.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301071321046.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301071323661.png)
Navicat中显示如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301071324346.png)

---
# 17.5 执行查询操作
这一节编写一段用于对 `COREJAVA` 数据库执行查询操作的程序。为了使程序可以正常运行，必须按照上一节中的说明，用表组装 *populated ... with tables* COREJAVA数据库。在查询数据库时，可以选择作者和出版社，或者将它们设置为“Any” *leave either of them as Any* 。

还可以修改数据库中的数据。选择一家出版社，然后输入数量。该出版社对应的所有价格都将按照填入的数量进行调整，同时程序将显示被修改的行数。修改完价格以后，可以运行一个查询操作，以核实新的价格。
## 17.5.1 预备语句与SQL注入
### 1. `PreparedStatement` 介绍
在这个程序中使用了一个新的特性，即**预备语句** *prepared statement* 。如果不考虑作者字段，我们要查询某个出版社的所有图书，那么该查询的SQL语句如下：
```sql
SELECT Books.Price, Books
FROM Books, Publishers
WHERE Books.Publisher_Id = Publishers.Publisher_Id
AND Publishers.Name = the name from the list box
```
我们没有必要在每次开始一个这样的查询时、都建立新的查询语句，而是**准备一个带有宿主变量的查询语句**，每次查询时只需为该变量填入不同的字符串、就可以反复多次使用该语句。==这一技术改进了查询性能==，它预先通过计算来确定查询策略、预编译SQL语句、以便高效地执行查询操作。==通过事先准备好查询、并多次重用它，我们就可以确保查询所需的准备步骤只被执行一次；关键还能预防SQL注入问题==。

在预备查询语句中，每个宿主变量都用 `?` 来表示。如果存在一个以上的变量，那么在设置变量值时必须注意 `?` 的位置。例如，如果我们的预备查询为如下形式：
```mysql
String publisherQuery =
"SELECT Books.Price, Books" +
" FROM Books, Publishers" +
" WHERE Books.Publisher_Id = Publishers.Publisher_Id AND Publishers.Name = ?"; 
PreparedStatement stat = conn.prepareStatement(publisherQuery);
```
在执行预备语句之前，必须使用 `set` 方法将变量绑定到实际的值上 *bind the host variables to actual values* 。和 `ResultSet` 接口中的 `get` 方法类似，针对不同的数据类型也有不同的 `set` 方法。在本例中，我们为出版社名称设置了一个字符串值。
```java
stat.setString(1, publisher);
```
第一个参数指的是需要设置的宿主变量的位置，位置1表示第一个 `?` 。第二个参数指的是赋予宿主变量的值。

如果想要重用已经执行过的预备查询语句，那么除非使用 `set` 方法或调用 `clearParameters` 方法，否则所有宿主变量的绑定都不会改变。这就意味着，**在从一个查询到另一个查询的过程中，只需使用 `setXxx` 方法重新绑定那些需要改变的变量即可**。

一旦为所有变量绑定了具体的值，就可以执行查询操作了：
```java
ResultSet rs = stat.executeQuery();
```
> 提示：通过连接字符串来手动构建查询显得非常枯燥乏味，而且存在潜在的危险。**你必须注意像引号这样的特殊字符**，而且==如果查询中涉及用户的输入，那就**还需要警惕注入攻击**==。因此，**只有查询涉及变量时，才应使用预备语句**。

价格更新操作可以由 `UPDATE` 语句实现。注意，我们调用的是 `executeUpdate` 方法，而非 `executeQuery` 方法，因为UPDATE语句不返回结果集。`executeUpdate` 的返回值为被修改过的行数。
> 注意：在相关的 `Connection` 对象关闭之后，`PreparedStatement` 对象也就变得无效了。不过，许多数据库通常都会自动缓存预备语句。如果相同的查询被预备两次，数据库通常会直接重用查询策略 *If the same query is prepared twice, the database simply reuses the query strategy* 。因此，无需过多考虑调用 `prepareStatement` 的开销。

下面简要说明示例程序的结构。
- 通过执行两个查询可以得到数据库中所有的作者和出版社名称，作者和出版社数组列表由此组装而成。
- 涉及作者的查询比较复杂。因为一本书可能有多个作者，`BooksAuthors` 表给出了作者和图书之间的对应关系。例如，ISBN号为0-201-96426-0的图书有两个作者，其代号为：DATE和DARW。以下为 `BooksAuthors` 表中的两行记录：
   ```java
0-­201-­96426-­0, DATE, 1 
0­-201-­96426­-0, DARW, 2
   ```
   `BooksAuthors` 表中第三列指的是作者的顺序（我们不能只使用表中记录的位置，在关系表中没有固定的行顺序）。因此，查询时需要连接 `Books` 表、`BooksAuthors` 表和 `Authors` 表，以便和用户所选的作者名进行比较。
   ```sql
SELECT Books.Price, Books.Title FROM Books, BooksAuthors, Authors, Publishers
WHERE Authors.Author_Id = BooksAuthors.Author_Id AND BooksAuthors.ISBN = Books.ISBN
AND Books.Publisher_Id = Publishers.Publisher_Id AND Authors.Name = ? AND Publishers.Name = ?
   ```
> 提示：许多程序员都不喜欢使用如此复杂的SQL语句。比较常见的方法是使用大量的Java代码来迭代多个结果集，但这种方法效率非常低。通常，**使用数据库的查询代码要比使用Java程序好得多**——这是数据库的一个重要优点。一般而言，**可以使用SQL解决的问题，就不要使用Java程序**。
- `changePrices` 方法执行UPDATE语句。注意，UPDATE语句中的WHERE子句需要使用出版社代码，而我们只知道出版社名称。这个问题可以使用嵌套子查询来解决。

`DatabaseProgramming/query/QueryTest.java` 给出了程序的完整代码。
```java
// query/QueryTest.java
package query;

import java.io.*;
import java.nio.file.*;
import java.sql.*;
import java.util.*;

/**
 * This program demonstrates several complex database queries.
 */
public class QueryTest {
	private static final String allQuery = "SELECT Books.Price, Books.Title FROM Books";
	private static final String authorPublisherQuery = "SELECT Books.Price, Books.Title"
		+ " FROM Books, BooksAuthors, Authors, Publishers"
		+ " WHERE Authors.Author_Id = BooksAuthors.Author_Id AND BooksAuthors.ISBN = Books.ISBN"
		+ " AND Books.Publisher_Id = Publishers.Publisher_Id AND"
		+ " Authors.Name = ? AND Publishers.Name = ?";
	private static final String authorQuery = "SELECT Books.Price, Books.Title FROM Books, BooksAuthors, Authors"
		+ " WHERE Authors.Author_Id = BooksAuthors.Author_Id"
		+ " AND BooksAuthors.ISBN = Books.ISBN"
		+ " AND Authors.Name = ?";
	private static final String publisherQuery = "SELECT Books.Price, Books.Title FROM Books, Publishers"
		+ " WHERE Books.Publisher_Id = Publishers.Publisher_Id AND Publishers.NAME = ?";
	private static final String priceUpdate = "UPDATE Books SET Price = Price + ? "
		+ " WHERE Books.Publisher_Id = (SELECT Publisher_Id FROM Publishers WHERE Name = ?)";

	private static Scanner in;
	private static ArrayList<String> authors = new ArrayList<>();
	private static ArrayList<String> publishers = new ArrayList<>();

	public static void main(String[] args) throws IOException {
		try (Connection conn = getConnection()) {
			in = new Scanner(System.in);
			authors.add("Any");
			publishers.add("Any");
			try (Statement stat = conn.createStatement()) {
				// Fill the authors array list
				var query = "SELECT Name FROM Authors";
				try (ResultSet rs = stat.executeQuery(query)) {
					while (rs.next()) 
						authors.add(rs.getString(1));
				}
				// Fill the publishers array list
				query = "SELECT Name FROM Publishers";
				try (ResultSet rs = stat.executeQuery(query)) {
					while (rs.next()) 
						publishers.add(rs.getString(1));
				}
			}
			var done = false;
			while (!done) {
				System.out.print("Q)uery C)hange prices E)xit: ");
				String input = in.next().toUpperCase();
				if (input.equals("Q")) executeQuery(conn);
				else if (input.equals("C")) changePrices(conn);
				else done = true;
			}
		} catch (SQLException e) {
			for (Throwable t : e) System.out.println(t.getMessage());
		}
	}

	/**
	 * Executes the selected query.
	 * @param conn the database connection
	 */
	private static void executeQuery(Connection conn) throws SQLException {
		String author = select("Authors:", authors);
		String publisher = select("Publishers:", publishers);
		PreparedStatement stat;
		if (!author.equals("Any") && !publisher.equals("Any")) {
			stat = conn.prepareStatement(authorPublisherQuery);
			stat.setString(1, author);
			stat.setString(2, publisher);
		} else if (!author.equals("Any") && publisher.equals("Any")) {
			stat = conn.prepareStatement(authorQuery);
			stat.setString(1, author);	
		} else if (author.equals("Any") && !publisher.equals("Any")) {
			stat = conn.prepareStatement(publisherQuery);
			stat.setString(1, publisher);
		} else stat = conn.prepareStatement(allQuery);

		try (ResultSet rs = stat.executeQuery()) {
			while (rs.next()) 
				System.out.println(rs.getString(1) + ", " + rs.getString(2));
		}
	}

	/**
	 * Executes an update statement to change prices.
	 * @param conn the database connection
	 */
	public static void changePrices(Connection conn) throws SQLException {
		String publisher = select("Publishers", publishers.subList(1, publishers.size()));
		System.out.print("Change prices by: ");
		double priceChange = in.nextDouble();
		PreparedStatement stat = conn.prepareStatement(priceUpdate);
		stat.setDouble(1, priceChange);
		stat.setString(2, publisher);
		int r = stat.executeUpdate();
		System.out.println(r + " records updated.");
	}

	/**
	 * Asks the user to select a string.
	 * @param prompt the prompt to display
	 * @param options the options from which the user can choose
	 * @return the option that the user chose
	 */
	public static String select(String prompt, List<String> options) {
		while (true) {
			System.out.println(prompt);
			for (int i = 0; i < options.size(); ++i)
				System.out.printf("%2d) %s%n", i + 1, options.get(i));
			int sel = in.nextInt();
			if (sel > 0 && sel <= options.size())
				return options.get(sel - 1);
		}
	}

	/**
	 * Gets a connection from the properties specified in the file database.properties
	 * @return the database connection
	 */
	public static Connection getConnection() throws SQLException, IOException {
		var props = new Properties();
		try (InputStream in = Files.newInputStream(Paths.get("./src/query/database.properties"))) {
			props.load(in);
		}

		String drivers = props.getProperty("jdbc.drivers");
		if (drivers != null) System.setProperty("jdbc.drivers", drivers);

		String url = props.getProperty("jdbc.url");
		String username = props.getProperty("jdbc.username");
		String password = props.getProperty("jdbc.password");
		return DriverManager.getConnection(url, username, password);
	}
}
```
运行结果如下（有两条记录，是因为作者名都是重复两条）：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301101725704.png)

### 2. SQL注入
特别地，这里多谈一下SQL注入——==SQL注入是通过操作输入、来修改事先定义好的SQL语句，用以执行代码对服务器进行攻击==。在 `17.DatabaseProgramming/src/sql注入演示` 的 `application.properties` 内容如下：
```java
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&useUnicode=true&characterEncoding=UTF-8
spring.datasource.username=root
spring.datasource.password=wdmysqlmm123
```
在MySQL中创建名为 `test` 的数据库：
```sql
create database test;
```
在命令提示符中运行sql注入演示中的 `sql.jar` 这个jar包。
```bash
$ java -jar ./sql.jar
```
此时我们就能在数据库中看到 `user` 表： 
![图|400x200](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301160114430.png)
接下来在浏览器的地址栏输入 `localhost:8080/login.html` ，就能看到如下页面。我们可以输入用户名和密码进行登陆。用户名和密码输入正确就登陆成功，跳转到首页。
![图|300x280](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301160114147.png)
用户名和密码输入错误则给出错误提示，如下图：
![图|300x280](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301160115931.png)
但可以通过输入一些特殊的字符登陆到首页。用户名随意写，密码写成 `' or '1' ='1` 。
![图|300x280](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301160116744.png)
这就是SQL注入漏洞，也是很危险的。当然现在市面上的系统都不会存在这种问题了，所以大家也不要尝试用这种方式去试其他的系统。那么该如何解决呢？这里将SQL执行对象 `Statement` 换成 `PreparedStatement` 对象就可以了。

用代码进行模拟，使用 `Statement` 对象：
```java
@Test
public void testLogin() throws  Exception {
   // 获取连接:如果连接的是本机mysql并且端口是默认的,可以简化书写
   String url = "jdbc:mysql:///db1?useSSL=false";
   String username = "root";
   String password = "1234";
   Connection conn = DriverManager.getConnection(url, username, password);
   // 接收用户输入 用户名和密码
   String name = "sjdljfld";
   String pwd = "' or '1' = '1";
   String sql = "select * from tb_user where username = '"+name+"' and password = '"+pwd+"'";
   // 获取stmt对象
   Statement stmt = conn.createStatement();
   // 执行sql
   ResultSet rs = stmt.executeQuery(sql);
   // 判断登录是否成功
   if (rs.next()) {
       System.out.println("登录成功~");
   } else {
       System.out.println("登录失败~");
   } 
   // 释放资源 
   rs.close(); 
   stmt.close(); 
   conn.close(); 
}
```
上面代码是将用户名和密码拼接到sql语句中，拼接后的sql语句如下
```sql
select * from tb_user where username = 'sjdljfld' and password = ''or '1' = '1'
```
从上面语句可以看出条件 `username = 'sjdljfld' and password = ''` 不管是否满足，`or` 后面的 `'1' = '1'` 是始终满足的，最终条件是成立的，就可以正常的进行登陆了。

使用 `PreparedStatement` 改进如下：
```java
@Test
public void testPreparedStatement() throws Exception {
   // 获取连接: 如果连接的是本机mysql并且端口是默认的,可以简化书写
   String url = "jdbc:mysql:///db1?useSSL=false";
   String username = "root";
   String password = "1234";
   Connection conn = DriverManager.getConnection(url, username, password);
   // 接收用户输入 用户名和密码
   String name = "zhangsan";
   String pwd = "' or '1' = '1";
   // 定义sql
   String sql = "select * from tb_user where username = ? and password = ?";
   // 获取pstmt对象
   PreparedStatement pstmt = conn.prepareStatement(sql);
   // 设置?的值
   pstmt.setString(1, name);
   pstmt.setString(2, pwd);
   // 执行sql
   ResultSet rs = pstmt.executeQuery();
   // 判断登录是否成功
   if(rs.next()) {
       System.out.println("登录成功~");
   } else {
       System.out.println("登录失败~");
   }
   // 释放资源
   rs.close();
   pstmt.close();
   conn.close();
}
```
执行上面语句就可以发现不会出现SQL注入漏洞问题了。那么 `PreparedStatement` 又是如何解决的呢？**它是将特殊字符进行了转义**，转义的SQL如下：
```sql
select * from tb_user where username = 'sjdljfld' and password = '\'or \'1\' = \'1'
```

### 3. `PreparedStatement` 原理
Java代码操作数据库的流程如图所示：
- 将SQL语句发送到MySQL服务器端
- MySQL服务端会对sql语句进行如下操作
	- 检查SQL语句：检查SQL语句的语法是否正确
	- 编译SQL语句：将SQL语句编译成可执行的函数
	- 执行SQL语句

**检查SQL和编译SQL花费的时间比执行SQL的时间还要长**。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行。这样就提高了性能。在**获取 `PreparedStatement` 对象时，将SQL语句发送给MySQL服务器进行检查与编译（这些步骤很耗时），执行时就不用再进行这些步骤了**。如果SQL模板一样，则只需要进行一次检查、编译，速度更快。接下来我们**通过查询日志来看一下原理**。

首先要开启预编译功能。在代码中编写URL时需要加上以下参数。而之前根本就没有开启预编译功能，只是解决了SQL注入漏洞（现在不知道要不要开）。
```java
useServerPrepStmts=true
```
配置MySQL执行日志（重启mysql服务后生效）——在mysql配置文件 `my.ini` 中添加如下配置（好像现在不用添加）：
```java
log-output=FILE
general-log=1
general_log_file="D:\mysql.log"
slow-query-log=1
slow_query_log_file="D:\mysql_slow.log"
long_query_time=2
```
Java测试代码如下：
```java
/**
   * PreparedStatement原理
   * @throws Exception
   */
@Test
public void testPreparedStatement2() throws Exception {
	// 获取连接：如果连接的是本机mysql并且端口是默认的3306,可以简化书写
    // useServerPrepStmts=true 参数开启预编译功能
    String url = "jdbc:mysql:///db1?useSSL=false&useServerPrepStmts=true";
    String username = "root";
    String password = "1234";
    Connection conn = DriverManager.getConnection(url, username, password);
    // 接收用户输入 用户名和密码
    String name = "zhangsan";
    String pwd = "' or '1' = '1";
    // 定义sql
    String sql = "select * from tb_user where username = ? and password = ?";
    // 获取pstmt对象
    PreparedStatement pstmt = conn.prepareStatement(sql);
    Thread.sleep(10000);
    // 设置?的值
    pstmt.setString(1,name);
    pstmt.setString(2,pwd);
    ResultSet rs = null;
    // 执行sql
    rs = pstmt.executeQuery();
    // 设置?的值
    pstmt.setString(1,"aaa");
    pstmt.setString(2,"bbb");
    // 执行sql
    rs = pstmt.executeQuery();
	// 判断登录是否成功
    if (rs.next()) {
        System.out.println("登录成功~");
    } else {
        System.out.println("登录失败~");
    }
    // 释放资源
    rs.close();
    pstmt.close();
    conn.close();
}
```
执行SQL语句，查看 `D:\mysql.log` 日志如下:
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301160127760.png)
上图中第三行中的 `Prepare` 是对SQL语句进行预编译。第四行和第五行是执行了两次SQL语句，而第二次执行前并没有对SQL进行预编译。

> [API] `java.sql.Connection` 1.1 
> - `PreparedStatement prepareStatement(String sql)`
> 返回一个含预编译语句的PreparedStatement对象。字符串sql代表一个SQL语句，该语句可以包含一个或多个由？字符指明的参数占位符。

> [API] `java.sql.PreparedStatement` 1.1
> - `void setXxx(int n, Xxx x)`
> `Xxx` 指 `int, double, String, Date` 之类的数据类型。设置第 `n` 个参数值为 `x` 。
> - `void clearParameters()`
> 清除预备语句中的所有当前参数。
> - `ResultSet executeQuery()`
> 执行预备SQL查询，并返回一个 `ResultSet` 对象。
> - `int executeUpdate()`
> 执行预备SQL语句 `INSERT, UPDATE, DELETE` ，这些语句由 `PreparedStatement` 对象表示。该方法返回在执行上述语句过程中、所有受影响的记录总数。如果执行的是数据定义语言DDL中的语句，如 `CREATE TABLE` ，则该方法返回0。

## 17.5.2 读写LOB
除了数字、字符串和日期之外，许多数据库还可以存储大对象，例如图片或其他数据。在SQL中，二进制大对象 *binary large objects* 称为BLOB，字符型大对象 *character large objects* 称为CLOB。

要读取LOB，需要执行 `SELECT` 语句，然后在 `ResultSet` 上调用 `getBlob` 或 `getClob` 方法，这样就可以获得 `Blob` 或 `Clob` 类型的对象。要从 `Blob` 中获取二进制数据，可以调用 `getBytes` 或 `getInputStream` 。例如，如果你有一张保存图书封面图像的表，那么就可以像下面这样获取一张图像：
```java
PreparedStatement stat = conn.prepareStatement("SELECT Cover FROM BookCovers WHERE ISBN=?"); 
...
stat.set(1, isbn);
try (ResultSet result = stat.executeQuery()) {
	if (result.next()) {
		Blob coverBlob = result.getBlob(1);
		Image coverImage = ImageIO.read(coverBlob.getBinaryStream());
	}
}
```
类似地，如果获取了 `Clob` 对象，那么就可以通过调用 `getSubString` 或 `getCharacterStream` 方法来获取其中的字符数据。

要将LOB置于数据库中，需要在 `Connection` 对象上调用 `createBlob` 或 `createClob` ，然后获取一个用于该LOB的输出流或写出器，写出数据，并将该对象存储到数据库中。例如，下面展示了如何存储一张图像：
```java
Blob coverBlob = connection.createBlob();
int offset = 0;
OutputStream out = coverBlob.setBinaryStream(offset);
ImageIO.write(coverImage, "PNG", out);
PreparedStatement stat = conn.prepareStatement("INSERT INTO Cover VALUES (?, ?)");
stat.set(1, isbn);
stat.set(2, coverBlob);
stat.executeUpdate();
```
> [API] `java.sql.ResultSet` 1.1
> - `Blob getBlob(int columnIndex)` 1.2
> - `Blob getBlob(String columnLabel)` 1.2
> - `Clob getClob(int columnIndex)` 1.2
> - `Clob getClob(String columnLabel)` 1.2
> 获取给定列的 `BLOB` 或 `CLOB` 。

> [API] `java.sql.Blob` 1.2
> - `long length()`
> 获取该 `BLOB` 的长度。
> - `byte[] getBytes(long startPosition, long length)
> 获取该 `BLOB` 中给定范围的数据。
> - `InputStream getBinaryStream()`
> - `InputStream getBinaryStream(long startPosition, long length)`
> 返回一个输入流，用于读取该 `BLOB` 中全部或给定范围的数据。
> - `OutputStream setBinaryStream(long startPosition)` 1.4
> 返回一个输出流，用于从给定位置开始写入该 `BLOB` 。

> [API] `java.sql.Clob` 1.4
> - `long length()`
> 获取该 `CLOB` 中的字符总数。
> - `String getSubString(long startPosition, long length)`
> 获取该 `BLOB` 中给定范围的字符。
> - `Reader getCharacterStream()`
> - `Reader getCharacterStream(long startPosition, long length)`
> 返回一个读入器（而不是流），用于读取 `CLOB` 中全部或给定范围的数据。
> - `Writer setCharacterStream(long startPosition)` 1.4
> 返回一个写出器（而不是流），用于从给定位置开始写入该 `CLOB` 。

> [API] `java.sql.Connection` 1.1
> - `Blob createBlob()` 6
> - `Clob createClob()` 6
> 创建一个空的 `BLOB` 或 `CLOB` 。

## 17.5.3 SQL转义
各种数据库普遍支持“转义*escape*”语法这一特性，但使用的是与数据库相关的语法变体 *use database­-specific syntax variations* ，因此，将转义语法转译为特定数据库的语法 *translate the escape syntax to the syntax of a particular database* 是JDBC驱动程序的任务之一。

转义主要用于下列特性：
- 日期和时间字面常量
- 调用标量函数
- 调用存储过程
- **外连接**
- 在 `LIKE` 子句中的转义字符

日期和时间字面常量随数据库的不同而变化很大。要嵌入日期或时间字面常量，需要按照[ISO 8601格式](http://www.cl.cam.ac.uk/~mgk25/iso-time.html)指定它的值，之后驱动程序会将其转译为本地格式。应该使用 `d, t, ts` 来表示 `DATE, TIME, TIMESTAMP` 值：
```java
{d '2008­01­24'}
{t '23:59:59'}
{ts '2008­01­24 23:59:59.999'}
```
**标量函数** *scalar function* 是指仅返回一个值的函数。在数据库中包含大量的函数，但不同的数据库中这些函数名存在着差异。**JDBC规范提供了标准的名字，并将其转译为数据库相关的名字**。在JDBC规范中可以找到它支持的函数名的完整列表。要调用函数，需要像下面这样嵌入标准的函数名和参数：
```java
{fn left(?, 20)}
{fn user()}
```
**存储过程** *stored procedure* 是在数据库中执行的、用数据库相关的语言编写的过程。要调用存储过程，需要使用 `call` 转义命令，其中在存储过程没有任何参数时，就不用加上括号。另外，应该用 `=` 来捕获存储过程的返回值：
```java
{call PROC1(?, ?)} 
{call PROC2}
{call ? = PROC3(?)}
```
**两个表的外连接** *outer join* 并不要求每个表的所有行、都要根据连接条件进行匹配，例如，假设有如下的查询：
```java
SELECT * FROM {oj Books LEFT OUTER JOIN Publishers ON Books.Publishers_Id = Publisher.Publisher_Id}
```
这个查询的执行结果中将包含有 `Publisher_Id` 在 `Publishers` 表中没有任何匹配的书，其中 `Publisher_ID` 为 `NULL` 值的行，就表示不存在任何匹配。如果应该使用 `RIGHT OUTER JOIN` ，就可以囊括没有任何匹配图书的出版商，而使用 `FULL OUTER JOIN` 可以同时返回这两类没有任何匹配的信息。由于并非所有的数据库对于这些连接都使用标准的写法，因此需要使用转义语法。

最后一种情况，`_` 和 `%` 字符在 `LIKE` 子句中具有特殊含义，用来匹配一个字符或一个字符序列。目前并不存在任何在字面上使用它们的标准方式 *There is no standard way to use them literally* ，所以如果想要匹配所有包含 `_` 字符的字符串，就必须使用下面的结构：
```java
... WHERE ? LIKE %!_% {escape '!'}
```
这里我们将 `!` 定义为转义字符，而 `!_` 组合表示字面常量下划线。
## 17.5.4 多结果集
在执行存储过程，或在使用允许在单个查询中提交多个 `SELECT` 语句的数据库时，一个查询有可能会返回多个结果集。下面是获取所有结果集的步骤：
1. 使用 `execute` 方法来执行SQL语句。
2. **获取第一个结果集或更新计数**。
3. 重复调用 `getMoreResults` 方法以移动到下一个结果集。
4. 当不存在更多的结果集或更新计数时，完成操作。

如果由多结果集构成的链中的下一项是结果集，`execute` 和 `getMoreResults` 方法将返回true，而如果在链中的下一项不是更新计数 *update count* ，`getUpdateCount` 方法将返回-1。

下面的循环可以遍历所有的结果：
```java
boolean isResult = stat.execute(command);
boolean done = false;
while (!done) {
	if (isResult) {
		ResultSet result = stat.getResultSet();
		// do something with result
	} else {
		int updateCount = stat.getUpdateCount();
		if (updateCount >= 0)
			// do something with updateCount
		else
			done = true;
	}
	if (!done) isResult = stat.getMoreResults();
}
```
> [API] `java.sql.Statement` 1.1
> - `boolean getMoreResults()`
> - `boolean getMoreResults(int current)` 6
> 获取该语句的下一个结果集，`Current` 参数是 `CLOSE_CURRENT_RESULT`（默认值），`KEEP_CURRENT_RESULT` 或 `CLOSE_ALL_RESULTS` 之一。如果存在下一个结果集，并且它确实是一个结果集，则返回 `true` 。

## 17.5.5 获取自动生成的键
大多数数据库都支持某种**在数据库中对行自动编号的机制**。但不同的提供商所提供的机制之间存在着很大的差异，而这些自动编号的值经常用作主键。尽管JDBC没有提供独立于提供商的、自动生成键的解决方案 *vendor­-independent solution for generating keys* ，但它提供了获取自动生成键的有效途径。当我们向数据表中插入一个新行，且其键自动生成时，可以实现下面的代码来获取这个键：
```java
stat.executeUpdate(insertStatement, Statement.RETURN_GENERATED_KEYS);
ResultSet rs = stat.getGeneratedKeys();
if (rs.next()) {
	int key = rs.getInt(1);
	...
}
```
> [API] `java.sql.Statement` 1.1
> - `boolean execute(String statement, int autogenerated)` 1.4
> - `int executeUpdate(String statement, int autogenerated)` 1.4
> 像前面描述的那样执行给定的SQL语句，如果 `autogenerated` 被设置为 `Statement.RETURN_GENERATED_KEYS` ，并且该语句是一条 `INSERT` 语句，那么**第一列中就是自动生成的键**。

---
# 17.6 可滚动和可更新的结果集
前面已经介绍过，使用 `ResultSet` 接口中的 `next` 方法可以迭代遍历结果集中的所有行。对于一个只需要分析数据的程序来说，这显然已经足够了。不过，==如果是用于显示一张表或查询结果的可视化数据显示==（参见图17-4），==我们通常会希望用户可以在结果集上前后移动。在可滚动结果集中，可以在其中向前或向后移动，甚至可以跳到任意位置==。

另外，一旦向用户显示了结果集中的内容，他们就可能希望编辑这些内容。**在可更新的结果集中，可以以编程方式来更新其中的项，使得数据库可以自动更新数据**。在下面小节讨论这些功能。
## 17.6.1 可滚动的结果集
默认情况下，结果集是不可滚动和不可更新的 *scrollable or updatable* 。为了从查询中获取可滚动的结果集，必须使用下面的方法得到一个不同的 `Statement` 对象：
```java
Statement stat = conn.createStatement(type, concurrency);
```
如果要获得预备语句，请调用下面的方法：
```java
PreparedStatement stat = conn.prepareStatement(command, type, concurrency);
```
![表17-6 ResultSet类的type值](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301080003887.png)
![表17-7 ResultSet类的Concurrency值](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301080003842.png)

表17-6和表17-7列出了 `type` 和 `concurrency` 的所有可能值，可以有以下几种选择：
- 是否希望结果集是可滚动的？如果不需要，则使用 `ResultSet.TYPE_FORWARD_ONLY` 。
- 如果结果集是可滚动的，且数据库在查询生成结果集之后发生了变化，那么是否希望结果集反映出这些变化？在我们的讨论中，假设将可滚动的结果集设置为 `ResultSet.TYPE_SCROLL_INSENSITIVE` 。**这个设置将使结果集“感应”不到查询结束后出现的数据库变化**。
- 是否希望通过编辑结果集就可以更新数据库？详细说明参见下节内容。

例如，如果只想滚动遍历结果集，而不想编辑它的数据，那么可以使用以下语句：
```java
Statement stat = conn.createStatement(
ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
```
现在，通过调用以下方法获得的所有结果集都将是可滚动的：
```java
ResultSet rs = stat.executeQuery(query);
```
**可滚动的结果集有一个游标，用以指示当前位置**。
> 注意：**并非所有的数据库驱动程序都支持可滚动和可更新的结果集**。使用 `DatabaseMetaData` 接口中的 `supportsResultSetType` 和 `supportsResultSetConcurrency` 方法，我们可以获知**在使用特定的驱动程序时，某个数据库究竟支持哪些结果集类型以及哪些并发模式**。
> 
> 即便是数据库支持所有的结果集模式，某个特定的查询也可能无法产生「带有你所请求的所有属性的结果集」。例如，一个复杂查询的结果集就有可能是不可更新的结果集。）在这种情况下，`executeQuery` 方法将返回一个功能较少的 `ResultSet` 对象，并添加一个 `SQLWarning` 到连接对象中（参见17.4.2节如何获取警告信息的内容）。或者，也可以使用 `ResultSet` 接口中的 `getType` 和 `getConcurrency` 方法查看结果集实际支持的模式。如果不检查结果集的功能就发起一个不支持的操作，比如对不可滚动的结果集调用 `previous` 方法，那么程序将抛出一个 `SQLException` 异常。

在结果集上的滚动是非常简单的，可以使用 `if (rs.previous()) ...` 向后滚动。如果游标位于一个实际的行上，那么该方法将返回 `true` ；如果游标位于第一行之前，那么返回 `false` 。

可以使用以下调用将游标向后或向前移动多行：
```java
rs.relative(n);
```
如果 `n` 为正数，游标将向前移动。如果 `n` 为负数，游标将向后移动。如果 `n` 为0，那么调用该方法将不起任何作用。如果试图将游标移动到当前行集的范围之外，即根据 `n` 值的正负号，游标需要被设置在最后一行之后或第一行之前，那么，该方法将返回 `false` ，且不移动游标。如果游标位于一个实际的行上，那么该方法将返回 `true` 。

或者，还可以将游标设置到指定的行号上：
```java
rs.absolute(n);
```
调用以下方法将返回当前行的行号：
```java
int currentRow = rs.getRow();
```
**结果集中第一行的行号为1**。如果返回值为0，那么当前游标不在任何行上，它要么位于第一行之前，要么位于最后一行之后。

`first, last, beforeFirst, afterLast` 这些简便方法用于将游标移动到第一行、最后一行、第一行之前或最后一行之后。最后，`isFirst, isLast, isBeforeFirst, isAfterLast` 用于测试游标是否位于这些特殊位置上。

**使用可滚动的结果集是非常简单的**，将查询数据放入缓存中的复杂工作，是由数据库驱动程序在后台完成的。
## 17.6.2 可更新的结果集
如果希望编辑结果集中的数据，并且将结果集上的数据变更自动反映到数据库中，那么就必须使用可更新的结果集。**可更新的结果集并非必须是可滚动的**，但**如果将数据提供给用户去编辑，那么通常也会希望结果集是可滚动的**。

如果要获得可更新的结果集，应该使用以下方法创建一条语句。这样，调用 `executeQuery` 方法返回的结果集就将是可更新的结果集：
```java
Statement stat = conn.createStatement(
ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
```
> 注意：==并非所有的查询都会返回可更新的结果集。如果查询涉及多个表的连接操作，那么它所产生的结果集将是不可更新的==。如果查询只涉及一个表，或在查询时是使用主键连接多个表的，那么它所产生的结果集将是可更新的结果集。可以调用 `ResultSet` 接口中的 `getConcurrency` 方法来确定结果集是否是可更新的。

例如，假设想提高某些图书的价格，但在执行 `UPDATE` 语句时又没有一个简单而统一的提价标准。此时，就可以根据任意的条件，迭代遍历所有的图书并更新它们的价格：
```java
String query = "SELECT * FROM Books";
ResultSet rs = stat.executeQuery(query);
while (rs.next()) {
	if (...) {
		double increase = ...;
		double price = rs.getDouble("Price");
		rs.updateDouble("Price", price + increase);
		rs.updateRow(); // make sure to call updateRow after updating fields
	}
}
```
所有对应于SQL类型的数据类型都配有 `updateXxx` 方法，比如 `updateDouble. updateString` 等。与 `getXxx` 方法相同，在使用 `updateXxx` 方法时必须指定列的名称或序号。然后，你可以给该字段设置新的值。
> 注意：在使用「第一个参数为列序号的 `updateXxx` 方法」时，注意==这里的列序号指的是该列在结果集中的序号，它的值可以与数据库中的列序号不同==。

`updateXxx` 方法改变的只是结果集中的行值，而非数据库中的值。**当更新完行中的字段值后，必须调用 `updateRow` 方法**，这个方法将当前行中的所有更新信息发送给数据库。如果没有调用 `updateRow` 方法、就将游标移动到其他行上，那么对此行所做的所有更新都将被丢弃，而且永远也不会被传递给数据库。还可以调用 `cancelRowUpdates` 方法来取消对当前行的更新。

在前面例子中已介绍过如何修改一个现有的行。**如果想在数据库中添加一条新的记录，首先需要使用 `moveToInsertRow` 方法将游标移动到特定的位置**，我们称之为插入行 *insert row* 。然后，**调用 `updateXxx` 方法在插入行的位置上创建一个新的行**。在上述操作全部完成之后，**还需要调用 `insertRow` 方法将新建的行发送给数据库**。完成插入操作后，**再调用 `moveToCurrentRow` 方法将游标移回到「调用 `moveToInsertRow` 方法之前的位置」**。下面是一段示例程序：
```java
rs.moveToInsertRow();
rs.updateString("Title", title);
rs.updateString("ISBN", isbn); 
rs.updateString("Publisher_Id", pubid);
rs.updateDouble("Price", price);
rs.insertRow();
rs.moveToCurrentRow();
```
注意，==你无法控制在结果集或数据库中添加新数据的位置==。

对于在插入行中没有指定值的列，将被设置为SQL的 `NULL` 。但是，如果这个列有 `NOT NULL` 约束，那么将会抛出异常，而这一行也无法插入。

最后需要说明的是，你可以使用以下方法删除游标所指的行，`deleteRow` 方法会立即将该行从结果集和数据库中删除：
```java
rs.deleteRow();
```

`ResultSet` 接口中的 `updateRow, insertRow, deleteRow` 方法的执行效果，等同于SQL命令中的 `UPDATE, INSERT, DELETE` 。不过，习惯于Java编程语言的程序员通常会觉得使用结果集来操控数据库、要比使用SQL语句自然得多。
> 警告：如果不小心处理的话，就很有可能在使用可更新的结果集时编写出非常低效的代码。**执行 `UPDATE` 语句，要比建立一个查询，然后一边遍历一边修改数据显得高效得多**。==对于用户能任意修改数据的交互式程序来说，使用可更新的结果集是非常有意义的。但对大多数程序性的修改而言，使用SQL的 `UPDATE` 语句更合适一些==。

> 注意：JDBC 2对结果集做了进一步的改进，例如，如果数据被其他的并发数据库连接所修改，那么它可以用最新的数据来更新结果集。JDBC 3添加了另一种优化，可以在事务提交时指定结果集的行为。但这些高级特性超出了范围。参考 *JDBC API Tutorial and Reference, Maydene Fisher, Jon Ellis, Jonathan Bruce* 和[JDBC规范](www.oracle.com/technetwork/java/javase/tech/index-jsp-136101.html)，以了解更多的信息。

> [API] `java.sql.Connection` 1.1
> - `Statement createStatement(int type, int concurrency)` 1.2
> - `PreparedStatement prepareStatement(String command, int type, int concurrency)` 1.2
> 创建一个语句或预备语句，且该语句可以产生指定类型和并发模式的结果集。`type` 是 `ResultSet` 接口中的下述常量之一：`TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, TYPE_SCROLL_SENSITIVE` 。`concurrency` 是 `ResultSet` 接口中的下述常量之一：`CONCUR_READ_ONLY, CONCUR_UPDATABLE` 。

> [API] `java.sql.ResultSet` 1.1
> - `int getType()` 1.2
> 返回结果集的类型。返回值为以下常量之一：`TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, TYPE_SCROLL_SENSITIVE` 。
> - `int getConcurrency()` 1.2
> 返回结果集的并发设置。返回值为以下常量之一：`CONCUR_READ_ONLY, CONCUR_UPDATABLE` 。
> - `boolean previous()` 1.2
> 将游标移动到前一行。如果游标位于某一行上，则返回 `true` ；如果游标位于第一行之前的位置，则返回 `false` 。
> - `int getRow()` 1.2
> 得到当前行的序号。**所有行从1开始编号**。
> - `boolean absolute(int r)` 1.2
> 移动游标到第 `r` 行。如果游标位于某一行上，则返回 `true` 。
> - `boolean relative(int d)` 1.2
> 将游标移动 `d` 行。如果 `d` 为负数，则游标向后移动。如果游标位于某一行上，则返回 `true` 。
> - `boolean first()` 1.2
> - `boolean last()` 1.2
> 移动游标到第一行或最后一行。如果游标位于某一行上，则返回 `true` 。
> - `void beforeFirst()` 1.2
> - `void afterLast()` 1.2
> 移动游标到第一行之前或最后一行之后的位置。
> - `boolean isFirst()` 1.2
> - `boolean isLast()` 1.2
> 测试游标是否在第一行或最后一行。
> - `boolean isBeforeFirst()` 1.2
> - `boolean isAfterLast()` 1.2
> 测试游标是否在第一行之前或最后一行之后的位置。
> - `void moveToInsertRow()` 1.2
> 移动游标到插入行。**插入行是一个特殊的行，可以在该行上使用 `updateXxx` 和 `insertRow` 方法来插入新数据**。
> - `void moveToCurrentRow()` 1.2
> 将游标从插入行移回到调用 `moveToInsertRow` 方法之前它所在的那一行。
> - `void insertRow()` 1.2
> 将插入行上的内容插入到数据库和结果集中。
> - `void deleteRow()` 1.2
> 从数据库和结果集中删除当前行。
> - `void updateXxx(int column, Xxx data)` 1.2
> - `void updateXxx(String columnName, Xxx data)` 1.2
> `Xxx` 指数据类型，比如 `int, double, String, Date` 等。更新结果中当前行上的某个字段值。
> - `void updateRow()` 1.2
> 将当前行的更新信息发送到数据库。
> - `void cancelRowUpdates()` 1.2
> 撤销对当前行的更新。

> [API] `java.sql.DatabaseMetaData` 1.1
> - `boolean supportsResultSetType(int type)` 1.2
> 如果数据库支持给定类型的结果集，则返回 `true` 。`type` 是 `ResultSet` 接口中的常量之一：`TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, TYPE_SCROLL_SENSITIVE` 。
> - `boolean supportsResultSetConcurrency(int type, int concurrency)` 1.2
> 如果数据库支持给定类型和并发模式的结果集，则返回 `true` 。`ResultSet` 接口中的下述常量之一：`TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, TYPE_SCROLL_SENSITIVE` 。`concurrency` 是 `ResultSet` 接口中的下述常量之一：`CONCUR_READ_ONLY, CONCUR_UPDATABLE` 

---
# 17.7 行集
==可滚动的结果集虽然功能强大，却有一个重要的缺陷：在与用户的整个交互过程中，必须始终与数据库保持连接==。用户也许会离开电脑旁很长一段时间，而在此期间却始终占有着数据库连接。这种方式存在很大的问题，因为数据库连接属于稀有资源。在这种情况下，我们可以使用行集。**`RowSet` 接口扩展自 `ResultSet` 接口，却无需始终保持与数据库的连接**。

**行集还适用于将查询结果移动到复杂应用的其他层**，或者是诸如手机之类的其他设备中。你可能从未考虑过移动一个结果集，因为它的数据结构非常庞大，且依赖于数据连接 *is tethered to the database connection* 。
## 17.7.1 构建行集
以下为 `javax.sql.rowset` 包提供的接口，它们都扩展了 `RowSet` 接口：
- **`CachedRowSet` 允许在断开连接的状态下执行相关操作**。关于被缓存的行集在下一节中讨论。
- **`WebRowSet` 对象代表了一个被缓存的行集**，该行集可以保存为XML文件。该文件可以移动到Web应用的其他层中，只要在该层中使用 `WebRowSet` 对象重新打开该文件即可。
- **`FilteredRowSet` 和 `JoinRowSet` 接口支持对行集的轻量级操作**，它们等同于SQL中的 `SELECT` 和 `JOIN` 操作。这两个接口的操作对象是存储在行集中的数据，因此**运行时无需建立数据库连接**。
- `JdbcRowSet` 是 `ResultSet` 接口的一个瘦包装器。它从 `RowSet` 接口中继承了均有用的 `get` 方法和 `set` 方法，从而将一个结果集转换成一个“bean”。 

在Java 7中，有一种获取行集的标准方式：
```java
RowSetFactory factory = RowSetProvider.newFactory();
CachedRowSet crs = factory.createCachedRowSet();
```
获取其他行集类型的对象也有类似的方法。

在Java 7之前，创建行集的方法都是与供应商相关的。另外，JDK在 `com.sun.rowset` 中还提供了参考实现，这些实现类的名字以 `Impl` 结尾，例如 `CachedRowSetImpl` 。
## 17.7.2 被缓存的行集
一个被缓存的行集包含了一个结果集中所有的数据。`CachedRowSet` 是 `ResultSet` 接口的子接口，所以**完全可以像使用结果集一样来使用被缓存的行集**。被缓存的行集有一个非常重要的优点：**断开数据库连接后仍然可以使用行集**。在示例程序 `DatabaseProgramming/view/ViewDB` 中看到，这种做法大大简化了交互式应用的实现。在执行每个用户命令时，我们只需打开数据库连接、执行查询操作、将查询结果放入被缓存的行集，然后关闭数据库连接即可。

我们**甚至可以修改被缓存的行集中的数据**。当然，这些修改不会立即反馈到数据库中。相反，**必须发起一个显式的请求，以便让数据库真正接受所有修改**。此时 `CachedRowSet` 类会重新连接到数据库，并通过执行SQL语句向数据库中写入所有修改后的数据。

可以**使用一个结果集来填充 `CachedRowSet` 对象**：
```java
ResultSet result = ...;
RowSetFactory factory = RowSetProvider.newFactory();
CachedRowSet crs = factory.createCachedRowSet();
crs.populate(result);
conn.close(); // now OK to close the database connection
```
或者，也可以让 `CachedRowSet` 对象自动创建一个数据库连接。首先，设置数据库参数：
```java
crs.setURL("jdbc:derby://localhost:1527/COREJAVA");
crs.setUsername("dbuser");
crs.setPassword("secret");
```
然后，设置查询语句和所有参数：
```java
crs.setCommand("SELECT * FROM Books WHERE Publisher_ID = ?");
crs.setString(1, publisherId);
```
最后，将查询结果填充到行集：
```java
crs.execute();
```
这个方法调用会建立数据库连接、执行查询操作、填充行集，最后断开连接。

==如果查询结果非常大，那我们肯定不想将其全部放入行集中。毕竟，用户可能只是想浏览其中的几行而已==。在这种情况下，可以指定每一页的尺寸，现在就能只获得20行了：
```java
CachedRowSet crs = ...;
crs.setCommand(command);
crs.setPageSize(20);
...
crs.execute();
```
要获取下一批数据，可以调用：
```java
crs.nextPage();
```

可以使用「与结果集中相同的方法 *the same methods you use for result sets* 」来查看和修改行集中的数据。如果修改了行集中的内容，那么必须调用以下方法将修改写回到数据库中：
```java
crs.acceptChanges(conn);
```
或：
```java
crs.acceptChanges();
```
只有在行集中设置了连接数据库所需的信息（如URL、用户名和密码）时，上述第二个方法调用才会有效。

在17.6.2节中曾经介绍过，**并非所有的结果集都是可更新的**。同样，==如果一个行集包含的是复杂查询的查询结果，那么我们就无法将对行集数据的修改写回到数据库中==。不过，如果行集上的数据都来自同一张数据库表，我们就可以安全地写回数据。
> 警告：如果是使用结果集来填充行集，那么行集就无从获知需要更新数据的数据库表名。此时，必须调用 `setTable` 方法来设置表名称。

另一个导致问题复杂化的情况是：==在填充了行集之后，数据库中的数据发生了改变，这显然容易造成数据不一致性==。为了解决这个问题，==参考实现会首先检查行集中的原始值（即，修改前的值）是否与数据库中的当前值一致。如果一致，那么修改后的值将覆盖数据库中的当前值==。否则，将抛出 `SyncProviderException` 异常，且不向数据库写回任何值。在实现行集接口时、其他实现也可以采用不同的同步策略。
> [API] `javax.sql.RowSet` 1.4
> - `String getURL()`
> - `void setURL(String url)`
> 获取或设置数据库的URL。
> - `String getUsername()`
> - `void setUsername(String username)`
> 获取或设置连接数据库所需的用户名。
> - `String getPassword()`
> - `void setPassword(String password)`
> 获取或设置连接数据库所需的密码。
> - `String getCommand()`
> - `void setCommand(String command)`
> 获取或设置需要执行的命令、以向行集中填充数据 *the command that is executed to populate this row set* 。
> - `void execute()`
> **通过执行使用 `setCommand` 方法设置的语句集来填充行集**。为了使驱动管理器可以获得连接，必须事先设定URL、用户名和密码。

> [API] `javax.sql.rowset.CachedRowSet` 5.0
> - `void execute(Connection conn)`
> 通过执行使用 `setCommand` 方法设置的语句集来填充行集。该方法使用给定的连接，并负责关闭它。
> - `void populate(ResultSet result)`
> 将指定的结果集中的数据填充到被缓存的行集中。
> - `String getTableName()`
> - `void setTableName(String tableName)`
> 获取或设置数据库表名称，填充被缓存的行集时所需的数据来自该表。
> - `int getPageSize()`
> - `void setPageSize(int size)`
> 获取和设置页的尺寸。
> - `boolean nextPage()`
> - `boolean previousPage()`
> 加载下一页或上一页，如果要加载的页存在，则返回 `true` 。
> - `void acceptChanges()`
> - `void acceptChanges(Connection conn)`
> 重新连接数据库，并将修改过的数据写回行集中。如果因为数据库中的数据已经被修改而导致无法写回行集中的数据，该方法可能会抛出 `SyncProviderException` 异常。

> [API] `javax.sql.rowset.RowSetProvider` 7
> - `static RowSetFactory newFactory()`
> 创建一个行集工厂。
> - `CachedRowSet createCachedRowSet()`
> - `FilteredRowSet createFilteredRowSet()`
> - `JdbcRowSet createJdbcRowSet()`
> - `JotnRowSet createJoinRowSet()`
> - `WebRowSet createWebRowSet()`
> 创建一个指定类型的行集。

---
# 17.8 元数据
前几节介绍了如何填充、查询和更新数据库表。其实，**JDBC还可以提供关于数据库及其表的结构的详细信息**。例如，可以获取某个数据库的所有表的列表，也可以获得某个表中所有列的名称及其数据类型。==如果是在开发业务应用时使用事先定义好的数据库，那么数据库结构和表信息就不是非常有用了。毕竟，在设计数据库表时，就已经知道了它们的结构==。但对于那些编写数据库工具的程序员来说，数据库的结构信息却是极其有用的。

**在SQL中，描述数据库或其组成部分的数据称为元数据**（区别于那些存在数据库中的实际数据）。我们可以获得三类元数据：关于数据库的元数据、关于结果集的元数据、以及关于预备语句参数的元数据。

如果要了解数据库的更多信息，可以从数据库连接中获取一个 `DatabaseMetaData` 对象：
```java
DatabaseMetaData meta = conn.getMetaData();
```
现在就可以获取某些元数据了。例如，以下调用将返回一个包含所有数据库表信息的结果集（要了解该方法的其他参数，参见本节末尾的API说明）：
```java
ResultSet mrs = meta.getTables(null, null, null, new String[] { "TABLE"  });
```
该结果集中的每一行都包含了数据库中一张表的详细信息，其中，第三列是表的名称（同样，要了解其他列的信息，参阅API说明）。下面的循环可以获取所有的表名：
```java
while (mrs.next())
	tableNames.addItem(mrs.getString(3));
```

数据库元数据还有第二个重要应用。数据库是非常复杂的，SQL标准为数据库的多样性提供了很大的空间。`DatabaseMetaData` 接口中有上百个方法可以用于查询数据库的相关信息，包括一些使用奇特的名字进行调用的方法，如：
```java
meta.supportsCatalogsInPrivilegeDefinitions()
```
和
```java
meta.nullPlusNonNullIsNull()
```
显然，这些方法主要是针对有特殊要求的高级用户的，尤其是那些需要编写涉及多个数据库、且具有高可移植性的代码的编程人员。

`DatabaseMetaData` 接口用于提供有关数据库的数据，第二个元数据接口 `ResultSetMetaData` 则用于提供结果集的相关信息。==每当通过查询得到一个结果集时，我们都可以获取该结果集的列数、以及每一列的名称、类型和字段宽度==。下面是一个典型的循环：
```java
ResultSet rs = stat.executeQuery("SELECT * FROM " + tableName);
ResultSetMetaData meta = rs.getMetaData();
for (int i = 1; i <= meta.getColumnCount(); i++) { 
	String columnName = meta.getColumnLabel(i);
	int columnWidth = meta.getColumnDisplaySize(i);
	...
}
```
在这一节中，我们将介绍如何编写一个简单的数据库工具，`view/ViewDB.java` 通过使用元数据来浏览数据库中的所有表，该程序还展示了如何使用带缓存的行集。
```java
// view/ViewDB.java
package view;

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.nio.file.*;
import java.sql.*;
import java.util.*;

import javax.sql.*;
import javax.sql.rowset.*;
import javax.swing.*;

/**
 * This program uses metadata to display arbitrary tables in a database.
 * 
 * @version 1.34 2018-05-01
 * @author Cay Horstmann
 */
public class ViewDB {
	public static void main(String[] args) {
		EventQueue.invokeLater(() -> {
			var frame = new ViewDBFrame();
			frame.setTitle("ViewDB");
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}
}

/**
 * The frame that holds the data panel and the navigation buttons.
 */
class ViewDBFrame extends JFrame {
	private JButton previousButton;
	private JButton nextButton;
	private JButton deleteButton;
	private JButton saveButton;
	private DataPanel dataPanel;
	private Component scrollPane;
	private JComboBox<String> tableNames;
	private Properties props;
	private CachedRowSet crs;
	private Connection conn;

	public ViewDBFrame() {
		tableNames = new JComboBox<String>();

		try {
			readDatabaseProperties();
			conn = getConnection();
			DatabaseMetaData meta = conn.getMetaData();
			try (ResultSet mrs = meta.getTables("corejava", null, null, new String[] { "TABLE" })) {
				while (mrs.next())
					tableNames.addItem(mrs.getString(3));
			}
		} catch (SQLException ex) {
			for (Throwable t : ex)
				t.printStackTrace();
		} catch (IOException ex) {
			ex.printStackTrace();
		}

		tableNames.addActionListener(event -> showTable((String) tableNames.getSelectedItem(), conn));
		add(tableNames, BorderLayout.NORTH);
		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent event) {
				try {
					if (conn != null)
						conn.close();
				} catch (SQLException ex) {
					for (Throwable t : ex)
						t.printStackTrace();
				}
			}
		});

		var buttonPanel = new JPanel();
		add(buttonPanel, BorderLayout.SOUTH);

		previousButton = new JButton("Previous");
		previousButton.addActionListener(event -> showPreviousRow());
		buttonPanel.add(previousButton);

		nextButton = new JButton("Next");
		nextButton.addActionListener(event -> showNextRow());
		buttonPanel.add(nextButton);

		deleteButton = new JButton("Delete");
		deleteButton.addActionListener(event -> deleteRow());
		buttonPanel.add(deleteButton);

		saveButton = new JButton("Save");
		saveButton.addActionListener(event -> saveChanges());
		buttonPanel.add(saveButton);
		if (tableNames.getItemCount() > 0)
			showTable(tableNames.getItemAt(0), conn);
	}

	/**
	 * Prepares the text fields for showing a new table, and shows the first row.
	 * 
	 * @param tableName the name of the table to display
	 * @param conn      the database connection
	 */
	public void showTable(String tableName, Connection conn) {
		try (Statement stat = conn.createStatement();
				ResultSet result = stat.executeQuery("SELECT * FROM " + tableName)) {
			// get result set

			// copy into cached row set
			RowSetFactory factory = RowSetProvider.newFactory();
			crs = factory.createCachedRowSet();
			crs.setTableName(tableName);
			crs.populate(result);

			if (scrollPane != null)
				remove(scrollPane);
			dataPanel = new DataPanel(crs);
			scrollPane = new JScrollPane(dataPanel);
			add(scrollPane, BorderLayout.CENTER);
			pack();
			showNextRow();
		} catch (SQLException ex) {
			for (Throwable t : ex)
				t.printStackTrace();
		}
	}

	/**
	 * Moves to the previous table row.
	 */
	public void showPreviousRow() {
		try {
			if (crs == null || crs.isFirst())
				return;
			crs.previous();
			dataPanel.showRow(crs);
		} catch (SQLException ex) {
			for (Throwable t : ex)
				t.printStackTrace();
		}
	}

	/**
	 * Moves to the next table row.
	 */
	public void showNextRow() {
		try {
			if (crs == null || crs.isLast())
				return;
			crs.next();
			dataPanel.showRow(crs);
		} catch (SQLException ex) {
			for (Throwable t : ex)
				t.printStackTrace();
		}
	}

	/**
	 * Deletes current table row.
	 */
	public void deleteRow() {
		if (crs == null)
			return;
		new SwingWorker<Void, Void>() {
			public Void doInBackground() throws SQLException {
				crs.deleteRow();
				crs.acceptChanges(conn);
				if (crs.isAfterLast())
					if (!crs.last())
						crs = null;
				return null;
			}

			public void done() {
				dataPanel.showRow(crs);
			}
		}.execute();
	}

	/**
	 * Saves all changes.
	 */
	public void saveChanges() {
		if (crs == null)
			return;
		new SwingWorker<Void, Void>() {
			public Void doInBackground() throws SQLException {
				dataPanel.setRow(crs);
				crs.acceptChanges(conn);
				return null;
			}
		}.execute();
	}

	private void readDatabaseProperties() throws IOException {
		props = new Properties();
		try (InputStream in = Files.newInputStream(Paths.get("./src/view/database.properties"))) {
			props.load(in);
		}
		String drivers = props.getProperty("jdbc.drivers");
		if (drivers != null)
			System.setProperty("jdbc.drivers", drivers);
	}

	/**
	 * Gets a connection from the properties specified in the file
	 * database.properties.
	 * 
	 * @return the database connection
	 */
	private Connection getConnection() throws SQLException {
		String url = props.getProperty("jdbc.url");
		String username = props.getProperty("jdbc.username");
		String password = props.getProperty("jdbc.password");

		return DriverManager.getConnection(url, username, password);
	}
}

/**
 * This panel displays the contents of a result set.
 */
class DataPanel extends JPanel {
	private java.util.List<JTextField> fields;

	/**
	 * Constructs the data panel.
	 * 
	 * @param rs the result set whose contents this panel displays
	 */
	public DataPanel(RowSet rs) throws SQLException {
		fields = new ArrayList<>();
		setLayout(new GridBagLayout());
		var gbc = new GridBagConstraints();
		gbc.gridwidth = 1;
		gbc.gridheight = 1;

		ResultSetMetaData rsmd = rs.getMetaData();
		for (int i = 1; i <= rsmd.getColumnCount(); i++) {
			gbc.gridy = i - 1;

			String columnName = rsmd.getColumnLabel(i);
			gbc.gridx = 0;
			gbc.anchor = GridBagConstraints.EAST;
			add(new JLabel(columnName), gbc);

			int columnWidth = rsmd.getColumnDisplaySize(i);
			var tb = new JTextField(columnWidth);
			if (!rsmd.getColumnClassName(i).equals("java.lang.String"))
				tb.setEditable(false);

			fields.add(tb);

			gbc.gridx = 1;
			gbc.anchor = GridBagConstraints.WEST;
			add(tb, gbc);
		}
	}

	/**
	 * Shows a database row by populating all text fields with the column values.
	 */
	public void showRow(ResultSet rs) {
		try {
			for (int i = 1; i <= fields.size(); i++) {
				String field = rs == null ? "" : rs.getString(i);
				JTextField tb = fields.get(i - 1);
				tb.setText(field);
			}
		} catch (SQLException ex) {
			for (Throwable t : ex)
				t.printStackTrace();
		}
	}

	/**
	 * Updates changed data into the current row of the row set.
	 */
	public void setRow(RowSet rs) throws SQLException {
		for (int i = 1; i <= fields.size(); i++) {
			String field = rs.getString(i);
			JTextField tb = fields.get(i - 1);
			if (!field.equals(tb.getText()))
				rs.updateString(i, tb.getText());
		}
		rs.updateRow();
	}
}
```
这里不知道为什么，使用 `getMetaData` 查询数据表元数据时，会将数据库管理系统中所有数据库的表都查询出来，为此做了限制，使用 `catalog` 指定数据库名称—— `catalog` : MySQL下就是数据库名称，Oracle下就是 `instance` 名；`schemaPattern` ：MySQL下就是数据库名称，Oracle中就是用户名。运行结果如下，打印出COREJAVA中的四张表名，可以调整数据库表：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301110048924.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301110052319.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301110121743.png)

> ==其实Java连接数据库时，可以不在URL中指定数据库==。建立连接时没有指定数据库，之后使用 `use db` 选择数据库，执行一样成功。

**顶部的组合框用于显示数据库中的所有表**。选中其中一个表，框中央就会显示出该表的所有字段名及其第一条记录的值，见图17-6。点击Next和Previous按钮可以滚动遍历表中的所有记录，还可以删除一行或编辑行的值，点击Save按钮可以将各种修改保存到数据库中。
![图17-6 ViewDB应用程序](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301081911447.png)
> 注意：许多数据库都配有非常成熟的工具，用于查看和编辑数据库表。如果你使用的数据库没有这样的工具，那么可以求助于[DBeaver](https://dbeaver.io)或者[SQuirreL](http://squirrel-sql.sourceforge.net)。这两个工具可以查看任何JDBC数据库中的表。我们编写示例程序并非为了取代这些工具，而是为了向你演示**如何编写工具来处理任意的数据库表**。

> [API] `java.sql.Connection` 1.1
> - `DatabaseMetaData getMetaData()`
> 返回一个 `DatabaseMetaData` 对象，该对象封装了有关数据库连接的元数据。

> [API] `java.sql.DatabaseMetaData` 1.1
> - `ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String types[])`
> 返回某个目录 *catalog* 中所有表的描述，该目录必须匹配给定的模式 *schema* 、表名字模式以及类型标准（==模式用于描述一组相关的表和访问权限，而目录描述的是一组相关的模式==，这些概念对组织大型数据库非常重要）。
> `catalog` 和 `schema` 参数可以为""，用于检索那些没有目录或模式的表。如果不想考虑目录和模式，也可以将上述参数设为 `null` 。
> `types` 数组包含了所需的表类型的名称，通常表类型有 `TABLE, VIEW, SYSTEM TABLE, GLOBAL TEMPORARY, LOCAL TEMPORARY, ALIAS, SYNONYM` 。如果 `types` 为 `null` ，则返回所有类型的表。
> 返回的结果集共有5列，均为 `String` 类型。
> ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301082248016.png)
> - `int getJDBCMajorVersion()` 1.4
> - `int getJDBCMinorVersion()` 1.4
> 返回建立数据库连接的JDBC驱动程序的主版本号和次版本号。例如，一个JDBC 3.0的驱动程序有一个主版本号3和一个次版本号0。
> - `int getMaxConnections()`
> 返回可同时连接到数据库的最大并发连接数。
> - `int getMaxStatements()`
> 返回单个数据库连接允许同时打开的最大并发语句数。如果对允许打开的语句数目没有限制或者不可知，则返回0。

> [API] `java.sql.ResultSet` 1.1
> - `ResultSetMetaData getMetaData()`
> 返回与当前 `ResultSet` 对象中的列相关的元数据。

> [API] `java.sql.ResultSetMetaData` 1.1
> - `int getColumnCount()`
> 返回当前 `ResultSet` 对象中的列数。
> - `int getColumnDisplaySize(int column)`
> 返回给定列序号的列的最大宽度。 
> - `String getColumnLabel(int column)`
> 返回该列所建议的名称。
> - `String getColumnName(int column)`
> 返回指定的列序号所对应的列名。

---
# 17.9 事务
我们可以将一组语句构建成一个事务 *transaction* 。当所有语句都顺利执行之后，事务可以被提交 *commit* 。否则，如果其中某个语句遇到错误，那么事务将被回滚，就好像没有任何语句被执行过一样。

**将多个语句组合成事务的主要原因，是为了确保数据库完整性** *database integrity* 。例如，假设我们需要将钱从一个银行账号转移到另一个账号。此时，一个非常重要的问题就是我们必须同时将钱从一个账号取出、并且存入另一个账号。如果在将钱存入其他账号之前系统发生崩溃，那么我们必须撤销取款操作。

如果将更新语句组合成一个事务，那么事务要么成功地执行所有操作并提交，要么在中间某个位置发生失败。==在这种情况下，可以执行回滚 *rollback* 操作，则数据库将自动撤销「上次提交事务以来的所有更新操作」产生的影响==。
## 17.9.1 用JDBC对事务编程
**默认情况下，数据库连接处于自动提交模式** *autocommit mode* ，==每个SQL语句一旦被执行便被提交给数据库。一旦命令被提交，就无法对它进行回滚操作==。在使用事务时，**需要关闭这个默认值**从而开启事务—— `autoCommit` 为 `true` 表示自动提交事务，`false` 表示手动提交事务：
```java
conn.setAutoCommit(false);
```
现在可以使用通常的方法创建一个语句对象：
```java
Statement stat = conn.createStatement();
```
然后任意多次地调用 `executeUpdate` 方法：
```java
stat.executeUpdate(command);
stat.executeUpdate(command);
stat.executeUpdate(command);
...
```
如果执行了所有命令之后没有出错，则调用 `commit` 方法：
```java
conn.commit();
```
如果出现错误，则调用：
```java
conn.rollback();
```
此时，程序将自动撤销自上次提交以来的所有语句。**当事务被 `SQLException` 异常中断时，典型的办法就是发起回滚操作**。

示例代码如下：
```java
package jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * JDBC API详解：Connection
 */
public class JDBCDemoConnection { 
    public static void main(String[] args) throws Exception {
        // 1. 注册驱动
        // Class.forName("com.mysql.jdbc.Driver");
        // 2. 获取连接：如果连接的是本机mysql并且端口是默认的3306, 可以简化书写
        String url = "jdbc:mysql:///db1?useSSL=false";
        String username = "root";
        String password = "1234";
        Connection conn = DriverManager.getConnection(url, username, password);
        // 3. 定义sql
        String sql1 = "update account set money = 3000 where id = 1";
        String sql2 = "update account set money = 3000 where id = 2";
        // 4. 获取执行sql的对象 Statement
        Statement stmt = conn.createStatement();
        try {
            // 开启事务
            conn.setAutoCommit(false);
            // 5. 执行sql
            int count1 = stmt.executeUpdate(sql1);//受影响的行数
            // 6. 处理结果
            System.out.println(count1);
            int i = 3/0;
            // 5. 执行sql
            int count2 = stmt.executeUpdate(sql2);//受影响的行数
            // 6. 处理结果
            System.out.println(count2);
            // 提交事务
            // 程序运行到此处，说明没有出现任何问题，则需求提交事务
            conn.commit();
        } catch (Exception throwables) {
            // 回滚事务
            // 程序在出现异常时会执行到这个地方，此时就需要回滚事务
            conn.rollback();
            throwables.printStackTrace();
        }
        //7. 释放资源
        stmt.close();
        conn.close();
    }
}
```
## 17.9.2 保存点
在使用某些驱动程序时，使用保存点 *save point* 可以更细粒度地控制回滚操作。**创建一个保存点意味着稍后只需返回到这个点，而非事务的开头**。例如，
```java
Statement stat = conn.createStatement(); // start transaction; rollback() goes here
stat.executeUpdate(command1);
Savepoint svpt = conn.setSavepoint(); // set savepoint; rollback(svpt) goes here
stat.executeUpdate(command2);
if (...) conn.rollback(svpt); // undo effect of command2
... conn.commit();
```
当不再需要保存点时，必须释放它：
```java
conn.releaseSavepoint(svpt);
```
## 17.9.3 批量更新
假设有一个程序需要执行许多 `INSERT` 语句，以便将数据填入数据库表中，此时可以使用批量更新的方法来提高程序性能。**在使用批量更新 *batch update* 时，一个语句序列作为一批操作将同时被收集和提交**。
> 注意：使用 `DatabaseMetaData` 接口中的 `supportsBatchUpdates` 方法，可以获知数据库是否支持这种特性。

处于同一批中的语句可以是 `INSERT, UPDATE, DELETE` 等操作，也可以是数据库定义语句，如 `CREATE TABLE, DROP TABLE` 。但**在批量处理中添加 `SELECT` 语句会抛出异常**（从概念上讲，批量处理中的 `SELECT` 语句没有意义，因为它会返回结果集，而并不更新数据库）。

为了执行批量处理，首先必须使用通常的办法创建一个 `Statement` 对象：
```java
Statement stat = conn.createStatement();
```
现在，应该调用 `addBatch` 方法，而非 `executeUpdate` 方法：
```java
String command = "CREATE TABLE ..."
stat.addBatch(command);
while (...) {
	command = "INSERT INTO ... VALUES (" + ... + ")";
	stat.addBatch(command);
}
```
最后，提交整个批量更新语句：
```java
int[] counts = stat. executeBatch();
```
调用 `executeBatch` 方法，将为所有已提交的语句返回一个记录数的数组。

为了在批量模式下正确地处理错误，**必须将批量执行的操作视为单个事务**。如果批量更新在执行过程中失败，那么**必须将它回滚到批量操作开始之前的状态**。

首先，关闭自动提交模式，然后收集批量操作，执行并提交该操作，最后恢复最初的自动提交模式：
```java
boolean autoCommit = conn.getAutoCommit();
conn.setAutoCommit(false);
Statement stat = conn.getStatement();
...
// keep calling stat.addBatch(...);
...
stat.executeBatch();
conn.commit(); 
conn.setAutoCommit(autoCommit);
```
> [API] `java.sql.Connection` 1.1
> - `boolean getAutoCommit()`
> - `void setAutoCommit(boolean b)`
> 获取该连接中的自动提交模式，或将其设置为 `b` 。如果自动更新为 `true` ，那么所有语句将在执行结束后立刻被提交。
> - `void commit()`
> 提交自上次提交以来所有执行过的语句。
> - `void rollback()`
> 撤销自上次提交以来所有执行过的语句所产生的影响。
> - `Savepoint setSavepoint()` 1.4
> - `Savepoint setSavepoint(String name)` 1.4
> 设置一个匿名或具名的保存点。
> - `void rollback(Savepoint svpt)` 1.4
> 回滚到给定保存点。
> - `void releaseSavepoint(Savepoint svpt)` 1.4
> 释放给定的保存点。

> [API] `java.sql.Savepoint` 1.4
> - `int getSavepointId()`
> 获取该匿名保存点的ID号。如果该保存点具有名字，则抛出一个 `SQLException` 异常。
> - `String getSavepointName()`
> 获取该保存点的名称。如果该对象为匿名保存点，则抛出一个 `SQLException` 异常。

> [API] `java.sql.Statement` 1.1
> - `void addBatch(String command)` 1.2
> 添加语句到当前批量命令中。
> - `int[] executeBatch()` 1.2
> 执行当前批量更新中的所有命令。返回一个记录数的数组，其中每一个元素都对应一条语句，如果其值非负，则代表受该语句影响的记录总数；如果其值为 `SUCCESS_NO_INFO` ，则表示该语句成功执行了，但没有记录数可用；如果其值为 `EXECUTE_FAILED` ，则表示该语句执行失败了。

> [API] `java.sql.DatabaseMetaData` 1.1
> - `boolean supportsBatchUpdates()` 1.2
> 如果驱动程序支持批量更新，则返回 `true` 。

## 17.9.3 高级SQL类型
表17-8列举了JDBC支持的SQL数据类型，以及它们在Java语言中对应的数据类型。
![表17-8 SQL数据类型及其对应的Java类型](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301090115084.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301090116732.png)

`SQL ARRAY`（SQL数组）指的是值的序列。例如，`Student` 表中通常都会有一个 `Scores` 列，这个列就应该是 `ARRAY OF INTEGER`（整数数组）。`getArray` 方法返回一个接口类型为 `java.sql.Array` 的对象，该接口中有许多方法可以用于获取数组的值。

从数据库中获得一个LOB或数组，并不等于获取了它的实际内容，==只有在访问具体的值时，它们才会从数据库中被读取出来==。这对改善性能非常有好处，因为通常这些数据的数据量都非常大。

某些数据库支持描述行位置的 `ROWID` 值，这样就可以非常快捷地获取某一行值。JDBC 4引入了 `java.sql.RowId` 接口，并提供了在查询中提供行ID、以及从结果中获取该值的方法。

国家属性字符串（ `NCHAR` 及其变体）按照本地字符编码机制存储字符串，并使用本地排序惯例对这些字符串进行排序。JDBC 4提供了方法，用于在查询和结果中进行「Java的 `String` 对象和国家属性字符串之间的双向转换」。

有些数据库可以存储用户自定义的结构化类型。JDBC 3提供了一种机制用于将SQL结构化类型自动映射成Java对象。

有些数据库提供用于XML数据的本地存储。JDBC 4引入了 `SQLXML` 接口，它可以在内部的XML表示、和 `DOM` 的 `Source/Result` 接口或二进制流之间起到中介作用。查看 `SQLXML` 类的API文档以了解详细信息。

不再更深入地讨论这些高级SQL类型了，可以在 *JDBC API Tutorial and Reference* 和JDBC 4的规范中，找到更多有关这些主题的信息。

---
# 17.10 Web与企业应用中的连接管理
前几节曾介绍过，使用 `database.properties` 文件可以对数据库连接进行非常简单的设置。这种方法适用于小型的测试程序，但不适用于规模较大的应用。

在Web或企业环境中部署JDBC应用时，**数据库连接管理与Java名字和目录接口 *JNDI* 是集成在一起的**。遍布企业的数据源的属性可以存储在一个目录中，采用这种方式使得我们可以集中管理用户名、密码、数据库名和JDBC URL。

在这样的环境中，可以使用下列代码创建数据库连接：
```java
var jndiContext = new InitialContext();
var source = (DataSource)jndiContext.lookup("java:comp/env/jdbc/corejava");
Connection conn = source.getConnection();
```
注意，**我们不再使用 `DriverManager` ，而是使用JNDI服务来定位数据源**。数据源 *A data source* 就是一个能提供简单的JDBC连接和更多高级服务的接口，比如执行涉及多个数据库的分布式事务。`javax.sql` 标准扩展包定义了 `DataSource` 接口。
> 注意：**在Java EE的容器中，甚至不必编程进行JNDI查找，只需在 `DataSource` 域上使用 `Resource` 注解**，当加载应用时，这个数据源引用将被设置：
> ```java
> @Resource(name="jdbc/corejava")
> private DataSource source;
> ```

当然，我们必须在某个地方配置数据源。如果你编写的数据库程序将在 `Servlet` 容器中运行，比如Apache Tomcat；或在应用服务器中运行，比如GlassFish，那么必须将数据库配置信息（包括JNDI名字、JDBC URL、用户名和密码）放置在配置文件中，或者在管理员GUI中进行设置。

==用户名管理和数据库登录只是众多需要特别关注的问题之一。另一个重要问题则涉及建立数据库连接所需的开销==。数据库程序使用了两种策略来获取数据库连接：可以在程序的开头建立了到数据库的单个连接，并在程序结尾处关闭它；而 `ViewDB` 程序在每次需要时都打开一个新连接。

但这两种方式都不令人满意：因为数据库连接是有限的资源，如果用户要离开应用一段时间，那么他占用的连接就不应该保持开放状态；另一方面，每次查询都获取连接、并在随后关闭它的代价，也是相当高的。

**解决上述问题的方法是建立数据库连接池** *pool* 。这意味着数据库连接在物理上并未被关闭，而是**保留在一个队列中并被反复重用**。连接池是一种非常重要的服务，JDBC规范为实现者提供了用以实现连接池服务的手段。不过，JDK本身并未实现这项服务，数据库供应商提供的JDBC驱动程序中通常也不包含这项服务。相反，**Web容器和应用服务器的开发商通常会提供连接池服务的实现**。

连接池的使用对程序员来说是完全透明的，可以通过获取数据源并调用 `getConnection` 方法来得到连接池中的连接。使用完连接后，需要调用 `close` 方法。==该方法并不在物理上关闭连接，而只是告诉连接池已经使用完该连接。连接池通常还会将池机制作用于预备语句上==。

至此已学会了JDBC的基本知识，并且知道如何实现简单的数据库应用。然而，正如在开头强调的那样，数据库的相关技术非常复杂；这里只是介绍，相当多的高级话题已超出了范围。如果要全面了解JDBC的高级功能，参阅 *JDBC API Tutorial and Reference* 或JDBC规范。

---
# 17.11 数据库连接池
## 17.11.1 数据库连接池简介
数据库连接池是个容器，负责分配、管理数据库连接 `Connection` ，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个——因为重复创建和销毁连接的过程，特别耗费计算机的性能和时间。**它会释放空闲时间超过最大空闲时间的数据库连接**、来避免因为没有释放数据库连接而引起的数据库连接遗漏。

连接池在一开始就创建好了一些连接对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以资源重用，也节省了频繁创建连接、销毁连接所花费的时间，提升了系统响应的速度；还能避免数据库连接遗漏：当所有的数据库连接都被使用，而新的用户进来发现没有连接可以使用，连接池就强制那些占用了连接、却没有进行使用的用户释放连接，归还给容器中。

## 17.11.2 数据库连接池实现
官方SUN提供的数据库连接池标准接口是 `DataSource` ，所有的连接池技术都要使用这个接口，一般由第三方组织（JDK官方和数据库供应商之外）实现此接口。该接口提供了获取连接的功能：
```java
Connection getConnection()
```
以后就不需要通过 `DriverManager` 对象获取 `Connection` 对象，而是通过连接池 `DataSource` 获取 `Connection` 对象。

常见的数据库连接池如下：
- DBCP
- C3P0
- Druid

我们现在使用更多的是Druid（德鲁伊），它的性能比其他两个会好一些。Druid连接池是阿里巴巴开源的数据库连接池项目，功能强大，性能优秀，是Java语言最好的数据库连接池之一。

## 17.11.3 Druid使用
使用步骤如下：
1. 导入Jar包 druid-1.1.12.jar
2. 定义配置文件
3. 加载配置文件
4. 获取数据库连接池对象
5. 获取连接

现在通过代码实现，首先需要先将Druid的Jar包放到项目下的 `lib` 下，并添加为库文件：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301170100914.png)
项目结构如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202301170101439.png)

编写配置文件 `druid.properties` 如下：
```java
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql:///db1?
useSSL=false&useServerPrepStmts=true
username=root
password=wdmysqlmm123
# 初始化连接数量
initialSize=5
# 最大连接数
maxActive=10
# 最大等待时间
maxWait=3000
```
代码如下所示：
```java
package com.itheima.druid;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.FileInputStream;
import java.sql.Connection;
import java.util.Properties;
/**
 * Druid数据库连接池演示
 */
public class DruidDemo {
    public static void main(String[] args) throws Exception {
        //1. 导入jar包
        //2. 定义配置文件
        //3. 加载配置文件
        Properties prop = new Properties();
        prop.load(new FileInputStream("jdbc-demo/src/druid.properties"));
        //4. 获取连接池对象
        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);
        //5. 获取数据库连接 Connection
        Connection connection = dataSource.getConnection();
        System.out.println(connection);
        //System.out.println(System.getProperty("user.dir"));
    }
}
```
### 17.11.4 druid配置详解
|                   属性                   |                             说明                             |          建议值           |
| :-------------- | :---------------------------- | :---------------  |
|                   url                    |   数据库的jdbc连接地址。一般为连接oracle/mysql。示例如下：   |                           |
|                                          |    mysql : jdbc:mysql://ip:port/dbname?option1&option2&…     |                           |
|                                          |        oracle : jdbc:oracle:thin:@ip:port:oracle_sid         |                           |
|                 username                 |                      登录数据库的用户名                      |                           |
|                 password                 |                     登录数据库的用户密码                     |                           |
|               initialSize                |            启动程序时，在连接池中初始化多少个连接            |        10-50已足够        |
|                maxActive                 |                连接池中最多支持多少个活动会话                |                           |
|                 maxWait                  | 程序向连接池中请求连接时,超过maxWait的值后,认为本次请求 |            100            |
|                                          | 失败,即连接池没有可用连接,单位毫秒,设置-1时表示无限等待         |                           |
|        minEvictableIdleTimeMillis        | 池中某个连接的空闲时长达到 N 毫秒后, 连接池在下次 |        见说明部分         |
|                                          | 检查空闲连接时,将回收该连接,要小于防火墙超时设置                |                           |
|                                          |   net.netfilter.nf_conntrack_tcp_timeout_established的设置   |                           |
|      timeBetweenEvictionRunsMillis       |    检查空闲连接的频率，单位毫秒, 非正整数时表示不进行检查    |                           |
|                keepAlive                 | 程序没有close连接且空闲时长超过minEvictableIdleTimeMillis,则会执 |           true            |
|                                          | 行validationQuery指定的SQL,以保证该程序连接不会池kill |                           |
|                                          |  掉,其范围不超过minIdle指定的连接个数。                   |                           |
|                 minIdle                  |   回收空闲连接时,将保证至少有minIdle个连接.          |     与initialSize相同     |
|             removeAbandoned              | 要求程序从池中get到连接后, N秒后必须close,否则druid 会强制回收该 |   false,当发现程序有未    |
|                                          | 连接,不管该连接中是活动还是空闲,以防止进程不会进行close而霸占连接。 | 正常close连接时设置为true |
|          removeAbandonedTimeout          | 设置druid 强制回收连接的时限,当程序从池中get到连接开始算起，超过此 |  应大于业务运行最长时间   |
|                                          |            值后，druid将强制回收该连接,单位秒。             |                           |
|               logAbandoned               |    当druid强制回收连接后,是否将stack trace 记录到日志中     |           true            |
|              testWhileIdle               | 当程序请求连接，池在分配连接时,是否先检查该连接是否有效。(高效) |           true            |
|             validationQuery              | 检查池中的连接是否仍可用的SQL语句,druid会连接到数据库执行该SQL, |                           |
|                                          | 如果正常返回,则表示连接可用,否则表示连接不可用         |                           |
|               testOnBorrow               |  程序 **申请** 连接时,进行连接有效性检查（低效,影响性能）   |           false           |
|               testOnReturn               |  程序 **返还** 连接时,进行连接有效性检查（低效,影响性能）   |           false           |
|          poolPreparedStatements          |                缓存通过以下两个方法发起的SQL:                |           true            |
|                                          |    public PreparedStatement prepareStatement(String sql)     |                           |
|                                          |    public PreparedStatement prepareStatement(String sql,     |                           |
|                                          |         int resultSetType, int resultSetConcurrency)         |                           |
| maxPoolPrepareStatementPerConnectionSize |                  每个连接最多缓存多少个SQL                   |            20             |
|                 filters                  |                这里配置的是插件,常用的插件有:                |      stat,wall,slf4j      |
|                                          |                    监控统计: filter:stat                     |                           |
|                                          |              日志监控: filter:log4j 或者 slf4j               |                           |
|                                          |                   防御SQL注入: filter:wall                   |                           |
|            connectProperties             |         连接属性。比如设置一些连接池统计方面的配置。         |                           |
|                                          |    druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000    |                           |
|                                          |                 比如设置一些数据库连接属性                 |                |

> 在实体类中，基本数据类型建议使用其对应的包装类型。