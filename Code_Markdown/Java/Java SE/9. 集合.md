▲ Java 集合框架
▲ 具体的集合
▲ 映射
▲ 视图与包装器
▲ 算法
▲ 遗留的集合

在正常实现方法、或者非常关注性能时，选择不同的数据结构会导致其实现风格以及性能存在着很大差异。需要快速地搜索成千上万个（甚至上百万）有序的数据项吗？需要快速在有序的序列中间插入元素或删除元素吗？需要建立键与值之间的关联吗？

这里讲述如何利用Java类库、帮助我们在程序设计中实现传统的数据结构，介绍如何使用标准库中的集合类。

---
# 9.1 Java集合框架
Java最初版本只为最常用的数据结构、提供了很少的一组类：`Vector, Stack, Hashtable, BitSet, Enumeration` 接口，其中的 `Enumeration` 接口提供了一种**用于访问任意容器中各个元素的抽象机制**。这是一种很明智的选择，但要想建立一个全面的集合类库、还需要大量的时间和高超的技能。

随着Java 1.2 的问世，设计人员感到是推出一组功能完善的数据结构的时机了。面对一大堆相互矛盾的设计策略，他们希望让类库规模小且易于学习，不希望像C++的“标准模版库”STL那样复杂，但却又希望能得到STL率先推出的“泛型算法”所具有的优点。

他们希望将传统的类融入新的框架中。与所有的集合类库设计者一样，他们必须做出一些艰难的选择，于是，在整个设计过程中，他们做出了一些**独具特色的设计决定**。本节将介绍**Java集合框架的基本设计**，展示使用它们的方法，并解释一些颇具争议的特性背后的考虑。
## 9.1.1 将集合的接口与实现分离
与现代的数据结构类库的常见情况一样，Java集合类库也将接口与实现分离。首先，看一下人们熟悉的数据结构——**队列** `queue` 是如何分离的。

**队列接口**指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以査找队列中元素的个数。当需要收集对象，并按照“先进先出”的规则检索对象时，就应该使用队列。

队列接口的最简形式可能类似下面这样：
```java
public interface Queue<E> { 
	// a simplified form of the interface in the standard library 
	void add(E element);
    E remove();
    int size();
}
```
这个接口并没有说明队列是如何实现的。队列通常有两种实现方式：一种是使用循环数组；另一种是使用链表（见图9-2）。
 ![图9-2 队列的实现](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210251849536.png)
每一个实现都可以用**一个实现了 `Queue` 接口的类**表示。
```java
// not an actual library class
public class CircularArrayQueue<E> implements Queue<E> { 
	private int head;
	private int tail;
	CircularArrayQueue(int capacity) { ... }
	public void add(E element) { ... }
	public E remove() { ... }
	public int size() { ... }
	private E[] elements;
}

// not an actual library class
public class LinkedListQueue<E> implements Queue<E>  {
	private Link head;
	private Link tail;
	LinkedListQueue() { ... }
	public void add(E element) { ... }
	public E remove() { ... }
	public int size() { ... }
}
```
> 注释：当然，Java类库没有名为 `CircularArrayQueue` 和 `LinkedListQueue` 的类，完整的一个实现见 `circularArrayQueue/CircularArrayQueueTest.java` 。这里以这些类作为示例，解释一下集合接口与实现在概念上的区分。**如果需要一个循环数组队列，就可以使用 `ArrayDeque` 类**。**如果需要一个链表队列，就直接使用 `LinkedList` 类**，这个类实现了 `Queue` 接口。
```java
package circularArrayQueue;

import java.util.*;

/**
 * This program demonstrates how to extend the collections framework.
 */
public class CircularArrayQueueTest {
	public static void main(String[] args) {
		var q = new CircularArrayQueue<String>(5);
		q.add("Amy"); q.add("Bob"); q.add("Carl");
		q.add("Deedee"); q.add("Emile"); q.remove();
		q.add("Fifi"); q.remove();
		for (String s : q) System.out.println(s);
	}
}

/**
 * A first-in, first-out bounded collection.
 */
class CircularArrayQueue<E> extends AbstractQueue<E> {
	private Object[] elements;
	private int head;
	private int tail;
	private int count;
	private int modcount; // modification count

	/**
	 * Constructs an empty queue.
	 * @param capacity the maximum capacity of the queue
	 */
	public CircularArrayQueue(int capacity) {
		elements = new Object[capacity];
		count = 0;
		head = 0;
		tail = 0;
	}

	public boolean offer(E newElement) {
		assert newElement != null;
		if (count <= elements.length) {
			elements[tail] = newElement;
			tail = (tail + 1) % elements.length;
			++count;
		    ++modcount;
		    return true;
		} else return false;
	}

	public E poll() {
		if (count == 0) return null;
		E r = peek();
		head = (head + 1) % elements.length;
		--count;
		++modcount;
		return r;
	}

	@SuppressWarnings("unchecked")
	public E peek() {
		if (count == 0) return null;
		return (E) elements[head];
	}

	public int size() { return count; }
	
	public Iterator<E> iterator() {
		return new QueueIterator();
	}

	private class QueueIterator implements Iterator<E> {
		private int offset;
		private int modcountAtConstruction;

		public QueueIterator() {
			modcountAtConstruction = modcount;
		}

		@SuppressWarnings("unchecked")
		public E next() {
			if (!hasNext()) 
				throw new NoSuchElementException();
			var r = (E) elements[(head + offset) % elements.length];
			++offset;
			return r;
		}

		public boolean hasNext() {
			if (modcount != modcountAtConstruction)
				throw new ConcurrentModificationException();
			return offset < count;
		}

		public void remove() {
			throw new UnsupportedOperationException();
		}
	}
}
```

当在程序中使用队列时，一旦已经构造了集合，就不需要知道究竟使用了哪种实现。因此，**只有在构造集合对象时，使用具体的类才有意义**。**可以使用接口类型存放集合的引用**。
```java
Queue<Customer> expressLane = new CircularArrayQueue<>(100);
expressLane.add(new Customer("Harry"));
```
==利用这种方式，一旦改变了想法，可以轻松地使用另外一种不同的实现。只需要对程序的一个地方做出修改，即调用构造器的地方==。如果觉得 `LinkedListQueue` 是个更好的选择，就将代码修改为：
```java
Queue<Customer> expressLane = new LinkedListQueue<>(100);
expressLane.add(new Customer("Harry"));
```
为什么选择这种实现，而不选择那种实现呢？**接口本身并不能说明哪种实现的效率究竟如何**。循环数组要比链表更高效，因此多数人优先选择循环数组。然而，通常这样做也需要付出一定的代价。

循环数组是一个**有界集合** *bounded collection* ，即容量有限。如果程序中要收集的对象数量没有上限，就最好使用链表来实现。

在研究API文档时，会发现另外一组名字以 `Abstract` 开头的类，例如，`AbstractQueue` 。这些类是为类库实现者而设计的。**如果想要实现自己的队列类（也许不太可能），会发现扩展 `AbstractQueue` 类要比实现 Queue 接口中的所有方法轻松得多**。

## 9.1.2 `Collection` 接口
**在Java类库中，集合类的基本接口是 `Collection` 接口**。这个接口有两个基本方法（除了这两个方法之外，还有几个方法，将在稍后介绍）：
```java
public interface Collection<E> {
	boolean add(E element);
	Iterator<E> iterator();
	...
}
```
`add` 方法用于向集合中添加元素。如果添加元素确实改变了集合就返回 `true` ，如果集合没有发生变化就返回 `false` 。例如，如果试图向集中添加一个对象，而这个对象在集中已经存在，这个 `add` 请求就没有实效，因为集中不允许有重复的对象。

**`iterator` 方法用于返回一个「实现了 `Iterator` 接口的对象」，可以使用这个迭代器对象依次访问集合中的元素**。下一节讨论迭代器。
## 9.1.3 迭代器
`Iterator` 接口包含4个方法：
```java
public interface Iterator<E> {
	E next();
	boolean hasNext();
	void remove();
	default void forEachRemaining(Consumer<? super E> action);
}
```
**通过反复调用 `next` 方法，可以逐个访问集合中的每个元素**。但是，如果到达了集合的末尾，`next` 方法将抛出一个 `NoSuchElementException` 。因此，**需要在调用 `next` 之前调用 `hasNext` 方法**。如果迭代器对象还有多个供访问的元素，这个方法就返回 `true` 。如果想要査看集合中的所有元素，就请求一个迭代器，并在 `hasNext` 返回 `true` 时反复地调用 `next` 方法。例如：
```java
Collection<String> c = ...;
Iterator<String> iter = c.iterator();
while (iter.hasNext()) {
	String element = iter.next();
	do something with element
}
```
**用 `foreach` 循环**可以更加简练地表示同样的循环操作，**编译器简单地将 `foreach` 循环翻译为带有迭代器的循环**：
```java
for (String element : c) {
	do something with element
}
```
**`foreach` 循环可以处理「任何实现了 `Iterable` 接口的对象」**（在类中提供一个实现 `Iterator` 接口的内部类，然后返回这个类的对象），这个接口只包含一个抽象方法：
```java
public interface Iterable<E>
	Iterator<E> iterator();
}
```
如前所见，`Collection` 接口扩展了 `Iterable` 接口。因此，**对于标准类库中的任何集合都可以使用 `foreach` 循环**。

在Java 8中，甚至不用写循环，而是**调用 `forEachRemaining` 方法并提供一个lambda表达式**（它会处理一个元素）。将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止。
```java
iterator.forEachRemaining(element -> do something with element);
```
**访问元素的顺序取决于集合类型**。如果对 `ArrayList` 进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1。然而，如果访问 `HashSet` 中的元素，会按照一种基本上随机的顺序获得元素，虽然可以确定在迭代过程中能遍历到集合中的所有元素，但却无法预知访问元素的次序。这通常并不是什么问题，因为对于计算总和或统计符合某个条件的元素个数这类操作来说，顺序并不重要。
> 注释：编程老手会注意到：`Iterator` 接口的 `next` 和 `hasNext` 方法与 `Enumeration` 接口的 `nextElement` 和 `hasMoreElements` 方法的作用一样。Java集合类库的设计者本可以选择使用 `Enumeration` 接口。但他们不喜欢这个接口累赘的方法名，于是引入了较短方法名的新接口。

Java集合类库中的迭代器，与其他类库中的迭代器在概念上有着重要区别。在传统的集合类库中，例如C++的标准模版库，迭代器是根据数组索引建模的。如果给定这样一个迭代器，就可以查看指定位置上的元素，就像知道数组索引 `i` 、就可以査看数组元素 `a[i]` 一样。不需要查找元素，也可以将迭代器向前移动一个位置，这与不需要执行査找操作、就可以通过 `i++` 将数组索引向前移动一样。但是，Java迭代器并不是这样处理的，**它的查找操作与位置变更紧密耦合**——查找一个元素的唯一方法是调用 `next` ，而在执行查找操作的同时，迭代器的位置随之向前移动。

因此，可以认为Java迭代器位于两个元素之间 *think of Java iterators as being between elements* 。当调用 `next` 时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用（见图9-3）。
![图9-3 向前移动迭代器](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210261001172.png)
> 注释：这里还有一个有用的推论 *useful analogy* 。可以将`Iterator.next` 与 `InputStream.read` 看作为等效的。从数据流中读取一个字节，就会自动地“消耗掉 *consume*” 这个字节。下一次调用 `read` 将会消耗并返回输入的下一个字节。用同样的方式，反复地调用 `next` 就可以读取集合中所有元素。

**`Iterator` 接口的 `remove` 方法，将会删除上次调用 `next` 方法时返回的元素**。在大多数情况下，在决定删除某个元素之前应该先看一下这个元素。然而，如果想要删除指定位置上的元素，仍然需要越过这个元素。例如，可以如下删除字符串集合中第一个元素：
```java
Iterator<String> it = c.iterator();
it.next(); // skip over the first element
it.remove(); // now remove it
```
更重要的是，**对 `next` 方法和 `remove` 方法的调用具有互相依赖性。如果调用 `remove` 之前没有调用 `next` 将是不合法的**。如果这样做，将会抛出一个 `IllegalStateException` 异常。如果想删除两个相邻的元素，不能直接地这样调用：
```java
it.remove()；
it.remove(); // Error!
```
相反地，必须先调用 `next` 越过将要删除的元素。
```java
it.remove();
it.next();
it.remove(); // OK
```
## 9.1.4 泛型实用方法
由于 `Collection` 与 `Iterator` 都是泛型接口，这意味着**我们可以编写处理任何集合类型的实用方法**。例如，下面是一个检测任意集合是否包含指定元素的泛型方法：
```java
public static <E> boolean contains(Collection<E> c, Object obj) {
	for (E element : c)
		if (element.equals(obj))
			return true;
	return false;
}
```
Java类库的设计者认为：这些实用方法中有一些非常有用，应该将它们提供给用户使用。这样，类库的使用者就不必自己重新构建这些方法了。`contains` 就是这样一个实用方法。

事实上，**`Collection` 接口声明了很多有用的方法，所有的实现类都必须提供这些方法**。在这些方法中，有许多方法的功能非常明确，不需要过多的解释。本节末尾API注释中，可以找到有关它们的完整文档说明。下面列举了其中的一部分:
```java
int size()
boolean isEmpty()
boolean contains(Object obj)
boolean containsAll(Collection<?> c)
boolean equals(Object other)
boolean addAll(Collection<? extends E> from)
boolean remove(Object obj)
boolean removeAll(Collection<?> c)
void clear()
boolean retainAll(Collection<?> c)
Object[] toArray()
<T> T[] toArray(T[] arrayToFill)
```

当然，如果实现 `Collection` 接口的每一个类都要提供如此多的例行方法 *routine methods* ，将是一件很烦人的事情。**为了能让实现者更容易地实现这个接口，Java类库提供了一个类 `AbstractCollection`** ，它保持基础方法 `size` 和 `iterator` 仍为抽象方法，但为实现者实现了其他例行方法。例如：
```java
public abstract class AbstractCollection<E> implements Collection<E> {
	...
	public abstract Iterator<E> iterator();
	public boolean contains(Object obj) {
		for (E element : this) // calls this.iterator()
			if (element.equals(obj))
				return true;
		return false;
	}
	...
}
```
这样一来，一个具体的集合类可以扩展 `AbstractCollection` 类了。**现在要由具体的集合类提供 `iterator` 方法**，而 `contains` 方法已由 `AbstractCollection` 超类提供了。**然而，如果子类有更加有效的方式实现 `contains` 方法，也完全可以由子类提供**。

这种做法有些过时了。如果这些方法是 `Collection` 接口的默认方法会更好 *It would be nicer if the methods were default methods of the Collection interface* ，但实际上并不是这样。不过，确实已经增加了很多默认方法。其中大部分方法都与流处理有关（有关内容在卷II中讨论）。另外，还有一个很有用的方法，这个方法用于删除满足某个条件的元素：
```java
default boolean removelf(Predicate<? super E> filter)
```

> [API] `java.util.Collection<E>` 1.2
> - `Iterator <E> iterator()`
> 返回一个用于访问集合中每个元素的迭代器。
> - `int size()`
> 返回当前存储在集合中的元素个数。
> - `boolean isEmpty()`
> 如果集合中没有元素，返回 `true` 。
> - `boolean contains(Object obj)`
> 如果集合中包含了一个与 `obj` 相等的对象，返回 `true` 。
> - `boolean containsAll(Collection<?> other)`
> 如果这个集合包含 `other` 集合中的所有元素，返回 `true` 。
> - `boolean add(Object element)`
> 将一个元素添加到集合中。如果由于这个调用改变了集合，返回 `true` 。
> - `boolean addAll(Collection<? extends E> other)`
> 将 `other` 集合中的所有元素添加到这个集合。如果由于这个调用改变了集合，返回 `true` 。
> - `boolean remove(Object obj)`
> 从这个集合中删除等于 `obj` 的对象。如果有匹配的对象被删除，返回 `true` 。
> - `boolean removeAll(Collection<?> other)`
> 从这个集合中删除 `other` 集合中存在的所有元素。如果由于这个调用改变了集合，返回 `true` 。
> - `default boolean removeIf(Predicate<? super E> filter)` 8
> 从这个集合删除 `filter` 返回 `true` 的所有元素。如果由于这个调用改变了集合，则返回 `true` 。
> - `void clear()`
> 从这个集合中删除所有的元素。
> - `boolean retainAll(Collection<?> other)`
> 从这个集合中删除所有与 `other` 集合中的元素不同的元素。如果由于这个调用改变了集合，返回 `true` 。
> - `Object[] toArray()`
> 返回这个集合中的对象的数组。
> - `<T> T[] toArray(T[] arrayToFill)`
> 返回这个集合中的对象的数组。如果 `arrayToFill` 足够大，就将集合中的元素填入这个数组中。剩余空间填补 `null` ；否则，分配一个新数组，其成员类型与 `arrayToFill` 的成员类型相同，其长度等于集合的大小，并填充集合元素。

> [API] `java.util.Iterator<E>` 1.2
> - `boolean hasNext()`
> 如果存在可访问的元素，返回 `true` 。
> - `E next()`
> 返回将要访问的下一个对象。如果已经到达了集合的尾部，将拋出一个 `NoSuchElementException` 。
 > - `void remove()`
 > 删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后集合已经被修改，这个方法将抛出一个 `IllegalStateException` 。
 > - `default void forEachRemaining(Consumer<? super E> action)` 8
 > 访问元素，并传递到指定的动作，直到再没有更多元素，或者这个动作抛出一个异常。

## 9.1.5 集合框架中的接口
Java集合框架为不同类型的集合定义了大量接口，如图9-4所示。
![图9-4 集合框架的接口](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210261357339.png)
**集合有两个基本接口：`Collection` 和 `Map`** 。我们已经看到，可以用以下方法在集合中插入元素：`boolean add(E element)` 。不过，由于映射包含键/值对，所以要用 `put` 方法来插入：
```java
V put(K key, V value)
```
要从集合读取元素，可以用迭代器访问元素。不过，从映射中读取值则要使用 `get` 方法：
```java
V get(K key)
```

**`List` 是一个有序集合 `ordered collection` ，元素会增加到容器中的特定位置**。可以采用两种方式访问元素：**使用迭代器访问，或者使用一个整数索引来访问**。后一种方法称为随机访问 `random access` ，因为这样可以按任意顺序访问元素。与之不同，使用迭代器访问时，必须顺序地访问元素。`List` 接口定义了多个用于随机访问的方法：
```java
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)
```

**`ListIterator` 接口是 `Iterator` 的一个子接口**。它定义了一个方法用于在迭代器位置前面增加一个元素：
```java
void add(E element)
```

坦率地讲，集合框架的这个方面设计得很不好。实际中有两种有序集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用 `List` 方法并提供一个整数索引来访问。与之不同，链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。如果原先提供两个接口就会容易一些了 *It would have been an easy matter to provide two interfaces* 。

> 注释：**为了避免对链表完成随机访问操作，Java 1.4引入了一个标记接口 `RandomAccess`** 。这个接口不包含任何方法，不过可以用它来**测试一个特定的集合是否支持高效的随机访问**：
> ```java
> if (c instanceof RandomAccess) {
> 	use random accessalgorithm
> } else {
> 	usesequential accessalgorithm
> }
> ```

**`Set` 接口等同于 `Collection` 接口 *The Set interface is identical to the Collection interface* ，不过其方法的行为有更严谨的定义**：
- 集 `set` 的 `add` 方法不允许增加重复的元素。
- 要适当地定义集的 `equals` 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。
- `hashCode` 方法的定义要保证包含相同元素的两个集会得到相同的散列码。

既然方法签名是一样的，为什么还要建立一个单独的接口呢？从概念上讲，并不是所有集合都是集 *Conceptually, not all collections are sets* 。**建立一个 `Set` 接口可以允许程序员编写只接受集 *set* 的方法**。

`SortedSet` 和 `SortedMap` 接口会提供用于排序的比较器对象 *comparator object* ，这两个接口定义了可以得到**集合子集视图** *views of subsets of the collections*  的方法。有关内容将在9.4节讨论。

最后，Java 6引入了**接口 `NavigableSet` 和 `NavigableMap`** ，其中**包含一些用于搜索和遍历有序集和映射的方法**。理想情况下，这些方法本应直接包含在 `SortedSet` 和 `SortedMap` 接口中。`TreeSet` 和 `TreeMap` 类实现了这些接口。

---
# 9.2 具体的集合
表9-1展示了Java类库中的集合，并简要描述了每个集合类的用途（为简单起见，省略了在第12章介绍的线程安全集合）。在表9-1中，**除以 `Map` 结尾的类之外，其他类都实现了 `Collection` 接口**，而以 `Map` 结尾的类实现了 `Map` 接口。映射的内容在9.3节介绍。
 ![表9-1 Java库中的具体集合](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210262117353.png)
图9-5显示了这些类之间的关系。
 ![图9-5 集合框架中的类](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210262112580.png)
## 9.2.1 链表
之前有很多示例，已经使用了数组以及动态的 `ArrayList` 类。然而，数组和数组列表都有一个重大的缺陷——从数组的中间位置删除一个元素开销很大，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动（见图9-6）。在数组中间位置上插入一个元素也是如此。
![图9-6 从数组中删除一个元素](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210262147503.png)
另外一个熟悉的数据结构——链表 `linked list` 解决了这个问题。数组是在连续的存储位置上存放对象引用，而链表却将每个对象存放在单独的结点/链接 `link` 中。每个结点还存放着序列中下一个结点的引用。**在Java语言中，所有链表实际上都是双向链接的** *doubly linked* ——即每个结点还存放着指向前驱结点的引用（见图9-7）。
![图9-7 双向链表](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210262151389.png)
从链表中间删除一个元素是一个很轻松的操作，只需要更新被删除元素附近的链接即可（见图9-8）。
![图9-8 从链表中删除一个元素](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210262152314.png)
在下面的代码示例中，先添加3个元素，然后再将第2个元素删除：
```java
var staff = new LinkedList<String>();
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
Iterator<String> iter = staff.iterator();
String first = iter.next(); // visit first element
String second = iter.next(); // visit second element
iter.remove(); // remove last visited element
```
但是，链表与泛型集合 *generic collections* 之间有一个重要的区别。链表是一个有序集合 *ordered collection* ，每个对象的位置十分重要。`LinkedList.add` 方法将对象添加到链表的尾部（和迭代器的 `add` 方法不同）。但是，常常需要将元素添加到链表的中间，**这种依赖于位置的 `add` 方法将由迭代器负责，因为迭代器描述了集合中的位置**。只有对自然有序的集合，使用迭代器来添加元素才有实际意义 *Using iterators to add elements makes sense only for collections that have a natural ordering* 。例如，下一节将要讨论的集 `set` 类型中，元素是完全无序的。**因此，在 `Iterator` 接口中就没有 `add` 方法**。相反地，集合类库**提供了子接口 `ListIterator` ，其中包含 `add` 方法**：
```java
interface ListIterator<E> extends Iterator<E> {
	void add(E element);
	...
}
```
与 `Collection.add` 不同，这个方法不返回 `boolean` 类型的值，它假定添加操作总会改变链表。

另外，**`ListIterator` 接口有两个方法，可以用来反向遍历链表**。与 `next` 方法一样，`previous` 方法返回越过的对象。
```java
E previous()
boolean hasPrevious()
```
`LinkedList` 类的 `listIterator` 方法，返回一个实现了 `ListIterator` 接口的迭代器对象。
```java
ListIterator<String> iter = staff.listIterator();
```
**`add` 方法在迭代器位置之前添加一个新对象**。例如，下面的代码将越过链表中的第一个元素，并在第二个元素之前添加 `"Juliet"`（见图9-9）:
```java
var staff = new LinkedList<String>();
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
ListIterator<String> iter = staff.listIterator();
iter.next(); // skip past first element
iter.add("Juliet");
```
![图9-9 将一个元素添加到链表中](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210262222034.png)
如果多次调用这个 `add` 方法，将按照提供的次序把元素添加到链表中。它们被依次添加到迭代器当前位置之前。

当用一个刚由 `Iterator` 方法返回、并且指向链表表头的迭代器调用 `add` 操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时（即 `hasNext` 返回 `false` ），添加的元素将变成列表的新表尾。如果链表有 $n$ 个元素，有 $n+1$ 个位置可以添加新元素。这些位置与迭代器的 $n+1$ 个可能的位置相对应。例如，如果链表包含3个元素 `A, B, C` ，就有4个位置（标有 `|` ）可以插入新元素：
```java
|ABC
A|BC
AB|C
ABC|
```
> 注释：在用“光标”类比 *analogy* 时要格外小心。`remove` 操作与 `BACKSPACE` 键的工作方式不太一样。在调用 `next` 之后，`remove` 方法确实与 `BACKSPACE` 键一样删除了迭代器左侧的元素。但是，如果调用 `previous` 就会将右侧的元素删除掉。不能连续调用两次 `remove` 。**`add` 方法只依赖于迭代器的位置，而 `remove` 方法依赖于迭代器的状态**。

最后需要说明，`set` 方法用一个新元素取代「调用 `next` 或 `previous` 方法返回的上一个元素」。例如，下面的代码将用一个新值取代链表的第一个元素：
```java
ListIterator<String> iter = list.listIterator();
String oldValue = iter.next(); // returns first element
iter.set(newValue); // sets first element to newValue
```
可以想象，**如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱**。例如，一个迭代器指向一个元素前面的位置，而另一个迭代器刚刚删除了这个元素，现在前一个迭代器就是无效的，并且不能再使用。链表迭代器设计为能够检测到这种修改 *The linked list
iterators have been designed to detect such modifications* 。

**如果一个迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的某个方法修改了，就会抛出一个 `ConcurrentModificationException` 异常**。例如，看一看下面这段代码，由于 `iter2` 检测出这个链表被从外部修改了，所以对 `iter2.next` 的调用抛出了一个 `ConcurrentModificationException` 异常：
```java
List<String> list = ...;
ListIterator<String> iter1 = list.listIterator();
ListIterator<String> iter2 = list.listIterator();
iter1.next();
iter1.remove();
iter2.next(); // throws ConcurrentModificationException
```

为了避免发生并发修改的异常，遵循下述简单规则：==可以根据需要给一个集合关联许多的迭代器，但这些迭代器只能读取集合。或者，可以单独关联一个既能读又能写的迭代器==。

有一种简单的方法可以检测到并发修改。**集合可以跟踪更改操作**（诸如添加或删除元素）**的次数** *the number of mutating operations* 。每个迭代器都会为「它负责的更改操作」维护一个单独的更改计数值。在每个迭代器方法的开始处，迭代器会检查「它自己更改操作的计数值」是否与「集合的更改操作数」一致。如果不一致，就抛出一个 `ConcurrentModificationException` 异常。
> 注释：不过，对于并发修改的检测有一个奇怪的例外。==链表只负责跟踪对列表的**结构性修改** *structural modifications* ，如添加元素、删除元素==。`set` 方法**不**被视为结构性修改。可以为一个链表关联多个迭代器，所有的迭代器都调用 `set` 方法修改现有结点的内容。后面介绍的 `Collections` 类的许多算法都需要使用这个功能。

现在介绍了 `LinkedList` 类的各种基本方法。可以使用 `ListIterator` 类从前后两个方向遍历链表中的元素，并可以添加、删除元素。

在上一节已经看到，`Collection` 接口中声明了许多操作链表的有用方法，其中**大部分方法都是在 `LinkedList` 类的超类 `AbstractCollection` 中实现的**。例如，`toString` 方法调用了所有元素的 `toString` ，并产生了一个格式为 `[A, B, C]` 的长字符串。这为调试工作提供了便利。可以使用 `contains` 方法检测某个元素是否出现在链表中。例如，如果链表中包含一个等于“Harry”的字符串，调用 `staff.contains("Harry")` 将会返回 `true` 。

在Java类库中，还提供了许多在理论上存在一定争议的方法。链表不支持快速地随机访问。如果要查看链表中第 $n$ 个元素，就必须从头开始越过 $n - 1$ 个元素，没有捷径可走。鉴于这个原因，在程序需要按整数索引访问元素时，程序员通常不选用链表。尽管如此，`LinkedList` 类还是提供了一个用来访问某个特定元素的 `get` 方法：
```java
LinkedList<String> list = ...;
String obj = list.get(n);
```
当然，这个方法的效率并不太高。==如果发现自己正在使用这个方法，说明对于要解决的问题，可能使用了错误的数据结构==。绝对不应该使用这个虚假的随机访问方法来遍历链表。下面这段代码的效率极低，每次査找一个元素都要从列表的头部重新开始搜索，`LinkedList` 对象根本不做任何缓存位置信息的操作：
```java
for (int i = 0; i < list.size(); i++)
	do something with list.get(i);
```
> 注释：`get` 方法做了微小的优化：如果索引大于 `size() / 2` 就从列表尾端开始搜索元素。

**`ListIterator` 接口还有一个方法，可以告知你当前位置的索引**。实际上，从概念上讲，由于Java迭代器指向两个元素之间的位置，所以可以同时产生两个索引：`nextIndex` 方法返回「下一次调用 `next` 方法时所返回元素」的整数索引；`previousIndex` 方法返回「下一次调用 `previous` 方法时所返回元素」的整数索引。当然，这个索引只比 `nextIndex` 返回的索引值小1。这两个方法的效率非常高，因为一个迭代器保持着当前位置的计数值 *an iterator keeps a count of its current position* 。

最后需要说明，如果有一个整数索引 `n` ，`list.listIterator(n)` 将返回一个迭代器，这个迭代器指向索引为 `n` 的元素前面的位置，也就是说，调用 `next` 与调用 `list.get(n)` 会产生同一个元素，只是获得这个迭代器的效率比较低。

如果链表中只有很少几个元素，就完全没有必要为 `get` 方法和 `set` 方法的开销而烦恼。但为什么要优先使用链表呢？**使用链表的唯一理由是，尽可能地减少在列表中间插入或删除元素所付出的代价**。如果列表只有少数几个元素，就完全可以使用 `ArrayList` 。

建议避免使用「以整数索引表示链表中位置的所有方法」。如果需要对集合进行随机访问，就使用数组或 `ArrayList` ，而不要使用链表。

程序 `Collections/linkedList/LinkedListTest.java` 使用的就是链表。它创建了两个链表，将它们合并在一起，然后从第二个链表中每间隔一个元素删除一个元素，最后测试 `removeAll` 方法。建议跟踪一下程序流程，要特别注意迭代器。可以绘制下面这样的迭代器位置示意图：
```java
|ACE |BDFG
A|CE |BDFG
AB|CE B|DFG
...
```
注意调用 `System.out.println(a);` ，通过调用 `AbstractCollection` 类中的 `toString` 方法，打印出链表 `a` 中的所有元素。
```java
package linkedList;

import java.util.*;

/**
 * This program demonstrates operations on linked lists.
 */
public class LinkedListTest {
	public static void main(String[] args) {
		var a = new LinkedList<String>();
		a.add("Amy");
		a.add("Carl");
		a.add("Erica");

		var b = new LinkedList<String>();
		b.add("Bob");
		b.add("Doug");
		b.add("Frances");
		b.add("Gloria");

		// merge the words from b into a
		ListIterator<String> aIter = a.listIterator();
		Iterator<String> bIter = b.iterator();
		while (bIter.hasNext()) {
			if (aIter.hasNext()) aIter.next();
			aIter.add(bIter.next());
		}
		System.out.println(a);

		// remove every second word from b
		bIter = b.iterator();
		while (bIter.hasNext()) {
			bIter.next(); // skip one element
			if (bIter.hasNext()) {
				bIter.next(); // skip next element
				bIter.remove(); // remove that element
			}
		}
		System.out.println(b);

		// bulk operation: remove all words in b from a 
		a.removeAll(b);
		System.out.println(a);
	}
}
```
运行结果如下：
```java
[Amy, Bob, Carl, Doug, Erica, Frances, Gloria]
[Bob, Frances]
[Amy, Carl, Doug, Erica, Gloria]
```
> [API] `java.util.List<E>` 1.2
> - `ListIterator<E> listIterator()`
> 返回一个列表迭代器，用来访问列表中的元素。
> - `ListIterator<E> listIterator(int index)`
> 返回一个列表迭代器，用来访问列表中的元素。第一次调用这个迭代器的 `next` ，会返回给定索引的元素。
> - `void add(int i, E element)`
> 在给定位置添加一个元素。
> - `void addAll(int i, Collection<? extends E> elements)`
> 将某个集合中的所有元素添加到给定位置。
> - `E remove(int i)`
> 删除并返回给定位置的元素。
> - `E get(int i)`
> 获取给定位置的元素。
> - `E set(int i, E element)`
> 用新元素取代给定位置的元素，并返回原来那个元素。
> - `int indexOf(Object element)`
> 返回与指定元素相等的元素在列表中第一次出现的位置，如果没有这样的元素将返回-1。
> - `int lastIndexOf(Object element)`
> 返回与指定元素相等的元素在列表中最后一次出现的位置，如果没有这样的元素将返回-1。

> [API] `java.util.ListIterator<E>` 1.2
> - `void add(E newElement)`
> 在当前位置前添加一个元素。
> - `void set(E newElement)`
> 用新元素取代 `next` 或 `previous` 上次访问的元素。如果在上一个 `next` 或 `previous` 调用之后列表结构被修改了，将拋出一个 `IllegalStateException` 异常。
> - `boolean hasPrevious()`
> 当反向迭代列表时，还有可供访问的元素，返回 `true` 。
> - `E previous()`
> 返回前对象。如果已经到达了列表的头部，就抛出一 个 `NoSuchElementException` 异常。
> - `int nextIndex()`
> 返回下一次调用 `next` 方法时将返回的元素索引。
> - `int previousIndex()`
> 返回下一次调用 `previous` 方法时将返回的元素索引。

> [API] `java.util.LinkedList<E>` 1.2
> - `LinkedList()`
> 构造一个空链表。
> - `LinkedList(Collection<? extends E> elements)`
> 构造一个链表，并将集合中所有的元素添加到这个链表中。
> - `void addFirst(E element)`
> - `void addLast(E element)`
> 将某个元素添加到列表的头部或尾部。
> - `E getFirst()`
> - `E getLast()`
> 返回列表头部或尾部的元素。
> - `E removeFirst()`
> - `E removeLast()`
> 删除并返回列表头部或尾部的元素。

## 9.2.2 数组列表
在上一节中，介绍了 `List` 接口和实现了这个接口（实际上实现的是其 `Abstract` 版本）的 `LinkedList` 类。`List` 接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用 `get, set` 方法随机访问每个元素。后者不适用于链表，但对数组却很有用。

集合类库还提供了熟悉的 **`ArrayList` 类，这个类也实现了 `List` 接口**。`ArrayList` 封装了一个动态再分配的对象数组。
> 注释：对于一个经验丰富的Java程序员来说，在需要动态数组时，可能会使用 `Vector` 类。为什么要用 `ArrayList` 取代 `Vector` 呢？原因很简单：**`Vector` 类的所有方法都是同步的。可以由两个线程安全地访问一个 `Vector` 对象**。但如果由一个线程访问 `Vector`（这种情况更为常见），代码要在同步操作上耗费大量的时间。与之不同，`ArrayList` 方法不是同步的。因此，**建议在不需要同步时使用 `ArrayList` ，而不要使用 `Vector`** 。

## 9.2.3 散列集
链表和数组允许你自行排列元素的次序。但如果想要査看某个指定的元素、却又忘记了它的位置，就需要访问所有元素，直到找到为止。如果集合中包含的元素很多，将会消耗很多时间。如果不在意元素的顺序，有几种能快速査找元素的数据结构。其缺点是无法控制元素出现的次序，它们将按照对自己最方便的形式组织数据。

有一种众所周知的数据结构，可以快速査找所需的对象，这就是散列表 `hash table` 。散列表为每个对象计算一个整数，称为**散列码** `hashcode` 。**散列码是由对象的实例字段产生的一个整数**。更准确地说，具有不同数据字段的对象将产生不同的散列码。

如果自定义类，就要负责实现这个类的 `hashCode` 方法。有关 `hashCode` 方法的详细内容参看第5章。注意，**自己实现的 `hashCode` 方法应该与 `equals` 方法兼容，即如果 `a.equals(b) = true` ，`a` 与 `b` 必须具有相同的散列码**。

现在最重要的问题是，要能快速地计算出散列码，并且这个计算只与「要散列的对象状态」有关，与散列表中的其他对象无关。

**在Java中，散列表用链表数组实现**。每个列表被称为**桶** `bucket`（参看图9-10）。要想査找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。例如，如果某个对象的散列码为76268，并且有128个桶，对象应该保存在第108 号桶中（ $76268 \bmod 128 = 108$ ）。或许会很幸运，在这个桶中没有其他元素，此时将元素直接插入到桶中就可以了。
![图9-10 散列表](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210271829697.png)

当然，**有时候会遇到桶已经被填充的情况，这也是不可避免的，这种现象被称为散列冲突** `hash collision` 。这时，需要用新对象与桶中的所有对象进行比较，査看这个对象是否已经存在。如果散列码是合理地随机分布，桶的数目也足够大，需要比较的次数就会很少。
> 注释：**在Java 8中，桶满时会从链表变为平衡二叉树** *the buckets change from linked lists into balanced binary trees when they get full* 。如果选择的散列函数不当，会产生很多冲突，或如果有恶意代码试图在散列表中填充多个有相同散列码的值，这样改为平衡二叉树就能提高性能。

**如果想更多地控制散列表的运行性能，可以指定一个初始的桶数** *the initial bucket count* 。桶数是指「用于收集具有相同散列值的桶」的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。**如果大致知道最终会有多少个元素要插入到散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的 $75\% \sim 150\%$** 。有些研究人员认为：最好将桶数设置为一个素数、以防键的集聚，尽管还没有确凿的证据。标准类库使用的桶数是 $2$ 的幂，默认值为 $16$（为表大小提供的任何值，都将被自动地转换为 $2$ 的下一个幂）。

当然，并不总是能知道需要存储多少个元素的，也有可能最初的估计过低。**如果散列表太满，就需要再散列 `rehashed`** ——如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。**装填因子 `load factor` 决定何时对散列表进行再散列**。例如，如果装填因子为0.75（默认值），而表中超过 $75\%$ 的位置已经填入元素，这个表就用双倍桶数自动地再散列。**对于大多数应用程序来说，装填因子为0.75是比较合理的**。

散列表可以用于实现几个重要的数据结构。其中最简单的是 `set` 类型。`set` 是没有重复元素的元素集合 *A set is a collection of elements without duplicates* 。`set` 的 `add` 方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。

Java集合类库提供了一个 `HashSet` 类，它实现了基于散列表的集 `set` 。可以用 `add` 方法添加元素。**`contains` 方法已被重新定义，用来快速查看某个元素是否已在集中，它只在某个桶中査找元素，而不必查看集合中的所有元素**。

散列集迭代器 *hash set iterator* 将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。**只有不关心集合中元素的顺序时才应使用 `HashSet`** 。

末尾示例程序 `set/SetTest.java` 将从 `System.in` 读取单词，然后将它们添加到集中，最后再打印出集中的前20个单词。可以输入*Alice in
Wonder-land*（从[这里](htttps:/www.gutenberg.org)获取）到这个程序中，并从命令行Shell运行：
```bash
$ java SetTest < alice30.txt
```
这个程序将读取输入的所有单词，并且将它们添加到散列集中。然后遍历散列集中的不同单词，最后打印出单词的数量（爱丽丝漫游仙境共有5909个不同的单词，包括开头的版权声明）。单词以随机的顺序出现。
> 警告：在更改集中的元素时要格外小心。**如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化**。

```java
package set;

import java.util.*;

/**
 * This program uses a set to print all unique words in System.in.
 */
public class SetTest {
	public static void main(String[] args) {
		var words = new HashSet<String>();
		long totalTime = 0;
		try (var in = new Scanner(System.in)) {
			while (in.hasNext()) {
				String word = in.next();
				long callTime = System.currentTimeMillis();
				words.add(word);
				callTime = System.currentTimeMillis() - callTime;
				totalTime += callTime;
			}
		}

		Iterator<String> iter = words.iterator();
		for (int i = 1; i <= 20 && iter.hasNext(); ++i) 
			System.out.println(iter.next());
		System.out.println("...");
		System.out.println(words.size() + " distinct words. " + totalTime + " milliseconds.");
	}
}
```
运行结果如下所示：
 ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211011529108.png)

> [API] `java.util.HashSet<E>` 1.2
> - `HashSet()`
> 构造一个空散列表。
> - `HashSet(Collection<? extends E> elements)`
> 构造一个散列集，并将集合中的所有元素添加到这个散列集中。
> - `HashSet(int initialCapacity)`
> 构造一个空的具有指定容量（桶数）的散列集。
> - `HashSet(int initialCapacity, float loadFactor)`
> 构造一个具有指定容量和装填因子（一个0.0~1.0之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列）的空散列集。

> [API] `java.lang.Object` 1.0
> - `int hashCode()`
> 返回这个对象的散列码。**散列码可以是任何整数，包括正数或负数**。`equals` 和 `hashCode` 的定义必须兼容，即如果 `x.equals(y)` 为 `true` ，`x.hashCode()` 必须等于 `y.hashCode()` 。

## 9.2.4 树集
`TreeSet` 类与散列集十分类似，不过它比散列集有所改进。**树集是一个有序集合** `sorted collection` ——可以以任意顺序将元素插入到集合中，而在对集合进行遍历时，每个值将自动按照排序后的顺序呈现。

例如，假设插入3个字符串，然后访问添加的所有元素。这时，每个值将按照顺序打印出来：`Amy Bob Carl` 。
```java
var sorter = new TreeSet<String>();
sorter.add("Bob");
sorter.add("Amy");
sorter.add("Carl");
for (String s : sorter) System.out.println(s);
```
正如 `TreeSet` 类名所示，排序是用树结构完成的（当前实现使用的是红黑树），每次将一个元素添加到树中时，都会将其放置在正确的排序位置上。因此，迭代器总是以有序的顺序访问每个元素。

将一个元素添加到树中要比添加到散列表中慢，参见表9-3中的比较，但与检查数组或链表中的重复元素相比还是快很多。如果树中包含 $n$ 个元素，査找新元素的正确位置平均需要 $\log_2 n$ 次比较。例如，如果一棵树包含了1000个元素，添加一个新元素大约需要比较10次。
 ![表9-3 将元素添加到散列集和树集](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210280017463.png)
> 注释：要使用树集，必须能比较元素。这些元素必须实现 `Comparable` 接口，或者构造集时必须提供一个 `Comparator`（参见第6章）。

回头看一看表9-3可能会有疑虑：是否总是应该用树集取代散列集。毕竟，添加一个元素所花费的时间看上去并不很长，而且元素是自动排序的。到底应该怎样做取决于所要收集的数据，如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，**对于某些数据来说，对其排序要比给出一个散列函数更加困难**。散列函数只需要将对象适当地打乱存放，而比较却要精确地区分每个对象。

要想具体地了解它们之间的差异，考虑收集一个矩形集的任务。如果使用 `TreeSet` ，就需要提供 `Comparator<Rectangle>` 。如何比较两个矩形呢？比较面积吗？这行不通。可能会有两个不同的矩形，它们的坐标不同，但面积却相同。**树的排序必须是全序** *total ordering* ——任意两个元素必须是可比的，并且只有在两个元素相等时结果才为0。确实，有一种矩形的排序（按照坐标的词典顺序排列）方式，但它的计算很牵强且很繁琐。相反地，`Rectangle` 类已经定义了散列函数，它直接对坐标进行散列。
> 注释：从Java 6起，`TreeSet` 类实现了 `NavigableSet` 接口。这个接口增加了几个查找元素以及反向遍历的便利方法。详细信息参看API注释。

程序 `treeSet/TreeSetTest.java` 中创建了 `Item` 对象的两个树集。第一个按照部件编号排序，这是 `Item` 对象的默认顺序。第二个通过使用一个定制的比较器来按照描述信息排序。
```java
// treeSet/TreeSetTest.java
package treeSet;

import java.util.*;

/**
 * This program sorts a set of Item objects by comparing their descriptions.
 */
public class TreeSetTest {
	public static void main(String[] args) {
		var parts = new TreeSet<Item>();
		parts.add(new Item("Toaster", 1234));
		parts.add(new Item("Widget", 4562));
		parts.add(new Item("Modem", 9912));
		System.out.println(parts);

		var sortByDescription = new TreeSet<Item>(Comparator.comparing(Item::getDescription));
		sortByDescription.addAll(parts);
		System.out.println(sortByDescription);
	}
}

// treeSet/Item.java
package treeSet;

import java.util.*;

/**
 * An item with a description and a part number.
 */
public class Item implements Comparable<Item> {
	private String description;
	private int partNumber;
	/**
	 * Constructs an item.
	 * @param aDescription the item's description
	 * @param aPartNumber the item's number
	 */
	public Item(String aDescription, int aPartNumber) {
		description = aDescription;
		partNumber = aPartNumber;
	}

	/**
	 * Gets the description of this item.
	 * @return the description
	 */
	public String getDescription() {
		return description;
	}

	public String toString() {
		return "[description=" + description + ", partNumber=" + partNumber + "]";
	}

	public boolean equals(Object otherObject) {
		if (this == otherObject) return true;
		if (otherObject == null) return false;
		if (getClass() != otherObject.getClass()) return false;
		var other = (Item) otherObject;
		return Objects.equals(description, other.description) &&
			partNumber == other.partNumber;
	}

	public int hashCode() {
		return Objects.hash(description, partNumber);
	}

	public int compareTo(Item other) {
		int diff = Integer.compare(partNumber, other.partNumber);
		return diff != 0 ? diff : description.compareTo(other.description);
	}
}
```
运行结果如下所示：
```java
[[description=Toaster, partNumber=1234], [description=Widget, partNumber=4562], [description=Modem, partNumber=9912]]
[[description=Modem, partNumber=9912], [description=Toaster, partNumber=1234], [description=Widget, partNumber=4562]]
```
> [API] `java.util.TreeSet<E>` 1.2
> - `TreeSet()`
> - `TreeSet(Comparator<? super E> comparator)`
> 构造一个空树集。
> - `TreeSet(Collection<? extends E> elements)`
> - `TreeSet(SortedSet<E> s)`
> 构造一个树集，并增加一个集合或有序集中的所有元素（对于后一种情况，要使用同样的顺序）。

> [API] `java.util.SortedSet<E>` 1.2
> - `Comparator<? super E> comparator()`
> 返回用于对元素进行排序的比较器。**如果元素用 `Comparable` 接口的 `compareTo` 方法进行比较则返回 `null`** 。
> - `E first()`
> - `E last()`
> 返回有序集中的最小元素或最大元素。

> [API] `java.util.NavigableSet<E>` 6
> - `E higher(E value)`
> - `E lower(E value)`
> 返回大于 `value` 的最小元素或小于 `value` 的最大元素，如果没有这样的元素则返回 `null` 。
> - `E ceiling(E value)`
> - `E floor(E value)`
> 返回大于等于 `value` 的最小元素或小于等于 `value` 的最大元素，如果没有这样的元素则返回 `null` 。
> - `E pollFirst()`
> - `E pollLast()`
> 删除并返回这个集中的最大元素或最小元素，这个集为空时返回 `null` 。
> - `Iterator<E> descendingIterator()`
> 返回一个按照递减顺序遍历集中元素的迭代器。

## 9.2.5 队列与双端队列
前面已经讨论过，队列可以让人们有效地在尾部添加一个元素，在头部删除一个元素。双端队列 `deque` 允许在头部和尾部都高效地添加或删除元素。不支持在队列中间添加元素。在Java 6中引入了 `Deque` 接口，并由 `ArrayDeque` 和 `LinkedList` 类实现。这两个类都可以提供双端队列，其大小可以根据需要扩展。在第12章将会看到限定队列和限定双端队列 *bounded queues and deques* 。

> [API] `java.util.Queue<E>` 5.0
> - `boolean add(E element)`
> - `boolean offer(E element)`
> 如果队列没有满，将给定的元素添加到这个双端队列的尾部并返回 `true` 。如果队列满了，第一个方法将拋出一个 `IllegalStateException` ，而第二个方法返回 `false` 。
> - `E remove()`
> - `E poll()`
> 假如队列不空，删除并返回这个队列头部的元素。如果队列是空的，第一个方法抛出 `NoSuchElementException` ，而第二个方法返回 `null` 。
> - `E element()`
> - `E peek()`
> 如果队列不空，返回这个队列头部的元素，但不删除。如果队列空，第一个方法将拋出一个 `NoSuchElementException` ，而第二个方法返回 `null` 。

> [API] `java.util.Deque<E>` 6
> - `void addFirst(E element)`
> - `void addLast(E element)`
> - `boolean offerFirst(E element)`
> - `boolean offerLast(E element)`
> 将给定的对象添加到双端队列的头部或尾部。如果双端队列满了，前两个方法将拋出一个 `IllegalStateException` ，而后两个方法返回 `false` 。
> - `E removeFirst()`
> - `E removeLast()`
> - `E pollFirst()`
> - `E pollLast()`
> 如果队列不空，删除并返回队列头部的元素。如果队列为空，前两个方法将拋出一个 `NoSuchElementException` ，而后两个方法返回 `null` 。
> - `E getFirst()`
> - `E getLast()`
> - `E peekFirst()`
> - `E peekLast()`
> 如果队列非空，返回队列头部的元素，但不删除。如果队列空，前面两个方法将拋出一个 `NoSuchElementException` ，而后面两个方法返回 `null` 。

> [API] `java.util.ArrayDeque<E>` 6
> - `ArrayDeque()`
> - `ArrayDeque(int initialCapacity)`
> 用初始容量16或给定的初始容量构造一个无限定双端队列 *unbounded deque* 。

## 9.2.6 优先级队列
**优先级队列** `priority queue` 中的元素可以按照任意的顺序插入，却总是按照有序的顺序进行检索。也就是说，**无论何时调用 `remove` 方法，总会获得当前优先级队列中最小的元素**。然而，优先级队列并没有对所有的元素进行排序。优先级队列使用了一个优雅且高效的数据结构，称为堆 `heap` 。堆是一个可以自我调整的二叉树，执行添加 `add` 和删除`remore` 操作可以让最小的元素移动到根，而不必花费时间对元素进行排序。

**与 `TreeSet` 一样，一个优先级队列既可以保存实现了 `Comparable` 接口的类对象，也可以保存在构造器中提供的 `Comparator` 对象** *a Comparator object you supply in the constructor* 。

优先级队列的典型用法是任务调度。每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除（由于习惯上将1设为“最高”优先级，所以 `remove` 会将最小的元素删除）。

程序 `priorityQueue/PriorityQueueTest.java` 显示了一个正在运行的优先级队列。与 `TreeSet` 中的迭代不同，这里的迭代并不是按照有序顺序来访问元素，不过删除操作却总是删掉剩余元素中优先级最小的那个元素。
```java
package priorityQueue;

import java.util.*;
import java.time.*;

/** 
 * This program demonstrates the use of a priority queue
 */
public class PriorityQueueTest {
	public static void main(String[] args) {
		var pq = new PriorityQueue<LocalDate>();
		pq.add(LocalDate.of(1906, 12, 9)); // G. Hopper
		pq.add(LocalDate.of(1815, 12, 10)); // A. Lovelace
		pq.add(LocalDate.of(1903, 12, 3)); // J. von Neumann
		pq.add(LocalDate.of(1910, 6, 22)); // K. Zuse

		System.out.println("Iterating over elements...");
		for (LocalDate date : pq)
			System.out.println(date);
		System.out.println("Removing elements...");
		while (!pq.isEmpty()) {
			System.out.println(pq.remove());
		}
	}
}
```
运行结果如下所示：
```java
Iterating over elements...
1815-12-10
1906-12-09
1903-12-03
1910-06-22
Removing elements...
1815-12-10
1903-12-03
1906-12-09
1910-06-22
```
> [API] `java.util.PriorityQueue`
> - `PriorityQueue()`
> - `PriorityQueue(int initialCapacity)`
> 构造一个用于存放 `Comparable` 对象的优先级队列。
> - `PriorityQueue(int initialCapacity, Comparator<? super E> c)`
> 构造一个优先级队列，并用指定的比较器对元素进行排序。
---
# 9.3 映射
集是一个集合，允许你快速查找现有的元素。但要查看一个元素，需要有要查找的那个元素的准确副本。这不是一种常见的査找方式。通常，我们知道某些键的信息，并想要查找与之关联的元素。**映射** `map` 数据结构就是为此设计的。**映射用来存放键/值对。如果提供了键，就能够查找到值**。例如，有一张关于员工信息的记录表，键为员工ID，值为
`Employee` 对象。在下面会学习使用映射。
## 9.3.1 基本映射操作
**Java类库为映射提供了两个通用的实现：`HashMap` 和 `TreeMap`** 。这两个类都实现了 `Map` 接口。散列映射对键进行散列，树映射根据键的整体顺序将元素组织成一个搜索树。**散列或比较函数只应用于键，与键关联的值不进行散列或比较**。

应该选择散列映射还是树映射呢？与集一样，散列稍微快一些，**如果不需要按照有序顺序访问键，就最好选择散列**。下列代码建立一个散列映射来存储员工信息：
```java
var staff = new HashMap<String, Employee>(); // HashMap implements Map
var harry = new Employee("Harry Hacker");
staff.put("987-98-9996", harry);
...
```
**每当往映射中添加一个对象时，必须同时提供一个键**。在这里，键是一个字符串，对应的值是 `Employee` 对象。**要想检索一个对象，必须使用（因此，必须记住）一个键**。
```java
var id = "987-98-9996";
Employee e = staff.get(id); // gets harry
```
如果在映射中没有与给定键对应的信息，`get` 将返回 `null` 。`null` 返回值可能并不方便。**有时对应没有出现在映射中的键，可以使用一个好的默认值，然后使用 `getOrDefault` 方法**。
```java
Map<String, Integer> scores = ...;
int score = scores.getOrDefault(id, 0); // gets 0 if the id is not p
```
**键必须是唯一的，不能对同一个键存放两个值**。如果对同一个键两次调用 `put` 方法，第二个值就会取代第一个值。实际上，`put` 将返回「与这个键参数关联的上一个值」。`remove` 方法从映射中删除给定键对应的元素。`size` 方法返回映射中的元素数。

**要迭代处理映射的键和值，最容易的是使用 `forEach` 方法**。可以提供一个接收键和值的lambda表达式。映射中的每一项会依序调用这个表达式。
```java
scores.forEach((k, v) -> 
	System.out.println("key=" + k + ", value=" + v));
```
`map/MapTest.java` 显示了映射的具体使用。首先将键/值对添加到映射中，然后从映射中删除一个键，同时与之对应的值也被删除。接下来，修改与某一个键对应的值，并调用 `get` 方法查看这个值。最后，迭代处理元素集。
```java
package map;

import java.util.*;

/**
 * This program demonstrates the use of a map with key type String and value type Employee.
 */
public class MapTest {
	public static void main(String[] args) {
		var staff = new HashMap<String, Employee>();
		staff.put("144-25-5464", new Employee("Amy Lee"));
		staff.put("567-24-2546", new Employee("Harry Hacker"));
		staff.put("157-62-7935", new Employee("Gary Cooper"));
		staff.put("456-62-5527", new Employee("Francesca Cruz"));

		// print all entries
		System.out.println(staff);
		// remove an entry
		staff.remove("567-24-2546");
		// replace an entry
		staff.put("456-62-5527", new Employee("Francesca Miller"));
		// look up a value
		System.out.println(staff.get("157-62-7935"));
		// iterate through all entries
		staff.forEach((k, v) ->
			System.out.println("key=" + k + ", value=" + v));
	}
}

class Employee {
	private String name;
	
	public Employee(String n) {
		name = n;
	}
	
	public String getName() {
		return name;
	} 
	
	public String toString() {
		return name;
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211011603445.png)

> [API] `java.util.Map<K, V>` 1.2
> - `V get(Object key)`
> 获取与键对应的值；返回与键关联的对象，如果在映射中没有这个对象则返回 `null` 。实现类可以禁止键为 `null` *Implementing classes may forbid null keys* 。
> - `default V getOrDefault(Object key, V defaultValue)`
> 获得与键关联的值；返回与键关联的对象，或者如果未在映射中找到这个键，则返回 `defaultValue` 。
> - `V put(K key, V value)`
> 将关联的一对键值插入到映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象。**这个方法将返回键关联的旧值**。如果之前没有这个键则返回 `null` 。实现类可以禁止键或值为 `null` *Implementing classes may forbid null keys or values* 。
> - `void putAll(Map<? extends K, ? extends V> entries)`
> 将给定映射中的所有条目添加到这个映射中。
> - `boolean containsKey(Object key)`
> 如果在映射中已经有这个键，返回 `true` 。
> - `boolean containsValue(Object value)`
> 如果映射中已经有这个值，返回 `true` 。
> - `default void forEach(BiConsumer<? super K, ? super V> action)` 8
> 对这个映射中的所有键/值对应用这个动作。

> [API] `java.util.HashMap<K, V>` 1.2
> - `HashMap()`
> - `HashMap(int initialCapacity)`
> - `HashMap(int initialCapacity, float loadFactor)` 
> 用给定的容量和装填因子构造一个空散列映射（装填因子是一个0.0 〜1.0 之间的数值。这个数值决定散列表填充的百分比。一旦到了这个比例，就要将其再散列到更大的表中）。默认的装填因子是0.75。

> [API] `java.util.TreeMap<K, V>` 
> - `TreeMap()`
> 为实现 `Comparable` 接口的键构造一个空的树映射。
> - `TreeMap(Comparator<? super K> c)
> 构造一个树映射，并使用一个指定的比较器对键进行排序。
> - `TreeMap(Map<? extends K, ? extends V> entries)
> 构造一个树映射，并将某个映射中的所有条目添加到树映射中。
> - `TreeMap(SortedMap<? extends K, ? extends V> entries)
> 构造一个树映射，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器。

> [API] `java.util.SortedMap<K, V>`
> - `Comparator<? super K> comparator()`
> 返回对键进行排序的比较器。如果键是用 `Comparable` 接口的 `compareTo` 方法进行比较的，返回 `null` 。
> - `K firstKey()`
> - `K lastKey()`
> 返回映射中最小或最大键。

## 9.3.2 更新映射条目
处理映射时的一个难点就是更新映射项。**正常情况下，可以得到与一个键关联的原值、完成更新、再放回更新后的值**。不过，必须考虑一个特殊情况，即键第一次出现。下面来看一个例子，使用一个映射统计一个单词在文件中出现的频度。看到一个单词时，我们将计数器增1，如下所示：
```java
counts.put(word, counts.get(word) + 1);
```
这是可以的，不过有一种情况除外：就是第一次看到 `word` 时。在这种情况下，`get` 会返回 `null` ，因此会出现一个 `NullPointerException` 异常。

作为一个简单的补救，**可以使用 `getOrDefault` 方法**：
```java
counts.put(word, counts.getOrDefault(word, 0) + 1);
```
另一种方法是**首先调用 `putIfAbsent` 方法，它只当键之前不存在（或者映射到 `null` ）时才会放入一个值**。
```java
counts.putIfAbsent(word, 0);
counts.put(word, counts.get(word) + 1); // Now we know that get will succeed
```
不过还可以做得更好。**`merge` 方法可以简化这个常见的操作**。如果键原先不存在，下面的调用将把 `word` 与1关联，否则使用 `Integer::sum` 函数组合原值和1（也就是将原值与1求和)。
```java
counts.merge(word, 1, Integer::sum);
```
API注释还描述了另外一些更新映射项的方法，不过这些方法不太常用。
> [API] `java.util.Map<K, V>` 1.2
> - `default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)` 8
> 如果 `key` 与一个非 `null` 值 `v` 关联，将函数应用到 `v` 和 `value` ，要么将 `key` 与结果关联，或者如果结果为 `null` 就删除这个键。否则，将 `key` 与 `value` 关联。返回 `get(key)` 。
>
> - `default V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)` 8
> 将函数应用到 `key` 和 `get(key)` ，将 `key` 与结果关联，或者如果结果为 `null` ，则删除这个键。返回 `get(key)` 。
> - `default V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)` 8
> 如果 `key` 与一个非 `null` 值 `v` 关联，将函数应用到 `key` 和 `v` ，将 `key` 与结果关联，或者如果结果为 `null` ，则删除这个键。返回 `get(key)` 。
> - `default V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)` 8
> 将函数应用到 `key` ，除非 `key` 与一个非 `null` 值关联。将 `key` 与结果关联，或者如果结果为 `null` ，则删除这个键。返回 `get(key)` 。
> - `default void replaceAll(BiFunction<? super K, ? super V, ?extends V> function)` 8
> 在所有映射项上应用函数。将键与非 `null` 结果关联，对于 `null` 结果，则将相应的键删除。
> - `default V putIfAbsent(K key, V value)` 8
> 如果 `key` 不存在或者与 `null` 关联，则将它与 `value` 关联，并返回 `null` 。否则返回关联的值。

## 9.3.3 映射视图
**集合框架不认为映射本身是一个集合** *The collections framework does not consider a map itself as a collection* （其他数据结构框架认为映射是一个键/值对集合，或者是由键索引的值集合）。不过，可以得到映射的视图 `View` ——这是实现了 `Collection` 接口或它的某个子接口的对象。

有3种视图：键集、值集合（不是一个集）以及键/值对集 *the set of keys, the collection of values (which is not a set), and the set of key/value pairs* 。**键和键/值对可以构成一个集，因为映射中一个键只能有一个副本**。下面的方法会分别返回这3个视图（键值对集/条目集 `entrySet` 的元素是一个「实现 `Map.Entry` 接口的类」的对象。）
```java
Set<K> keySet()
Collection<V> values()
Set<Map.Entry<K, V>> entrySet()
```
需要说明的是，**`keySet` 不是 `HashSet` 或 `TreeSet` ，而是实现了 `Set` 接口的另外某个类的对象**。`Set` 接口扩展了 `Collection` 接口。因此，可以像使用集合一样使用 `keySet` 。

例如，可以枚举一个映射的所有键：
```java
Set<String> keys = map.keySet();
for (String key : keys) {
	do something with key
}
```
**如果想同时查看键和值，可以通过枚举映射条目来避免查找值**。使用以下代码：
```java
for (Map.Entry<String, Employee> entry : staff.entrySet()) {
	String k = entry.getKey();
	Employee v = entry.getValue();
	do something with k, v
}
```
**可以使用 `var` 声明避免笨拙的 `Map.Entry`** 。原先这是访问所有映射条目的最高效的方法。如今，只需要使用 `forEach` 方法：
```java
map.forEach((k, v) -> {
	do something with k, v
});
```
如果在键集视图 *the key set view* 上调用迭代器的 `remove` 方法，实际上会从映射中删除这个键和**与它关联的值**。不过，**不能向键集视图增加元素**。另外，如果增加一个键而没有同时增加值也是没有意义的。如果试图调用 `add` 方法，它会抛出一个 `UnsupportedOperationException` 。

映射条目集视图有同样的限制，尽管理论上增加一个新的键/值对好像是有意义的。
> `java.util.Map<K, V>` 1.2
> - `Set<Map.Entry<K, V>> entrySet()`
> 返回 `Map.Entry` 对象（映射中的键/值对）的一个集视图。可以从这个集中删除元素，它们将从映射中删除，但是不能增加任何元素。
> - `Set<K> keySet()`
> 返回映射中所有键的一个集视图。可以从这个集中删除元素，键和相关联的值将从映射中删除，但是不能增加任何元素。
> - `Collection<V> values()`
> 返回映射中所有值的一个集合视图。可以从这个集合中删除元素，所删除的值及相应的键将从映射中删除，不过不能增加任何元素。

> [API] `java.util.Map.Entry<K, V>` 1.2
> - `K getKey()`
> - `V getValue()`
> 返回这一条目的键或值。
> - `V setValue(V newValue)`
> 将相关映射中的值改为新值，并返回原来的值。

## 9.3.4 弱散列映射
在集合类库中有几个专用的映射类，本节对它们做简要介绍。

设计 `WeakHashMap` 类是为了解决一个有趣的问题。如果有一个值，对应的键已经不再使用了，将会出现什么情况呢？假定对某个键的最后一次引用已经消亡，不再有任何途径可以引用这个值的对象了。但是，由于在程序中的任何部分不会再有这个键，所以无法从映射中删除这个键/值对。为什么垃圾回收器不能够删除它呢？难道删除无用的对象不是垃圾回收器的工作吗？

遗憾的是，事情没有这样简单。**垃圾回收器跟踪活动的对象** *live
objects* 。==只要映射对象是活动的，其中的所有桶也是活动的，它们不能被回收 *As long as the map object is live, all buckets in it are live and won't  be reclaimed*== 。因此，需要由程序负责从长期存活的映射表中删除那些无用的值。或者，可以使用 `WeakHashMap` 完成这件事情——==当对键的唯一引用来自散列条目时，这一数据结构将与垃圾回收器协同工作一起删除键值对==。

下面是这种机制的内部运行原理。`WeakHashMap` 使用**弱引用** `weak references` 保存键。**`WeakReference` 对象将包含另一个对象的引用** *A WeakReference object holds a reference to another object* ，**在这里就是一个散列表键**。对于这种类型的对象，垃圾回收器用一种特有的方式进行处理。

正常情况下，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象**只能**由 `WeakReference` 引用，垃圾回收器也会将它回收，但会将「引用这个对象的弱引用」放入一个队列中。**`WeakHashMap` 将周期性地检查队列，以便找出新添加的弱引用**。一个弱引用进入队列，意味着这个键不再被他人使用，并且已经被回收。于是，`WeakHashMap` 将删除相关联的映射条目。

## 9.3.5 链接散列集与映射
**`LinkedHashSet` 和 `LinkedHashMap` 类用来记住插入元素项的顺序**。这样就可以避免哈希表中条目的看似随机的顺序。**当条目插入到表中时，就会并入到双向链表中**（见图9-11）。
![图9-11 链接散列表](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210282106159.png)
例如，考虑 `map/MapTest.java` 中以下映射插入的处理:
```java
var staff = new LinkedHashMap<String, Employee>();
staff.put("144-25-5464", new Employee("Amy Lee"));
staff.put("567-24-2546", new Employee("Harry Hacker"));
staff.put("157-62-7935", new Employee("Gary Cooper"));
staff.put("456-62-5527", new Employee("Francesca Cruz"));
```
然后，`staff.keySet().iterator()` 以下面的次序枚举键：
```java
144-25-5464
567-24-2546
157-62-7935
456-62-5527
```
并且 `staff.values().iterator()` 以下列顺序枚举这些值：
```java
Amy Lee
Harry Hacker
Gary Cooper
Francesca Cruz
```
或者，**链接散列映射可以使用访问顺序 *access order* 、而不是插入顺序，对映射条目进行迭代**。每次调用 `get` 或 `put` ，受到影响的条目将从当前的位置删除，并放到条目链表的尾部（只影响条目在链表中的位置，而散列表中的桶不会受影响。映射条目总是位于与键散列码对应的桶中）。要构造这样一个的散列映射，需要调用：
```java
LinkedHashMap<K, V>(initialCapacity, loadFactor, true)
```
**访问顺序对于实现高速缓存的“最近最少使用”原则十分重要**。例如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取。当在表中找不到元素项、且表已经相当满 *already pretty full* 时，可以得到表的一个迭代器，并删除它枚举的前几个元素。这些是近期最少使用的几个元素。

甚至可以让这一过程自动化。即**构造一个 `LinkedHashMap` 的子类，然后覆盖下面这个方法**：
```java
protected boolean removeEldestEntry(Map.Entry<K, V> eldest)
```
每当方法返回 `true` 时，添加一个新条目就会导致删除 `eldest` 条目。例如，下面的高速缓存最多可以存放100个元素：
```java
var cache = new LinkedHashMap<K, V>(128, 0.75F, true) {
	protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
		return size() > 100;
	}
};
```
或者，还可以考虑 `eldest` 元素、以决定是否将它删除。例如，可以检査与这个条目一起存储的时间戳。
## 9.3.6 枚举集与映射
**`EnumSet` 是一个「枚举类型元素」集的高效实现** *an efficient set implementation with elements that belong to an enumerated type* 。由于枚举类型只有有限个实例，所以 `EnumSet` 内部用**位序列**实现。如果对应的值在集中，则相应的位被置为1。

**`EnumSet` 类没有公共的构造器**。要使用静态工厂方法构造这个集：
```java
enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY };

EnumSet<Weekday> always = EnumSet.allOf(Weekday.class);
EnumSet<Weekday> never = EnumSet.noneOf(Weekday.class);
EnumSet<Weekday> workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);
EnumSet<Weekday> mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);
```
可以使用 `Set` 接口的常用方法来修改 `EnumSet` 。

**`EnumMap` 是一个键类型为枚举类型的映射**。它可以直接且高效地实现为一个**值数组**。在使用时需要在构造器中指定键类型：
```java
var personInCharge = new EnumMap<Weekday, Employee>(Weekday.class);
```
> 注释：在 `EnumSet` 的API文档中，将会看到 `E extends Enum<E>` 这样奇怪的类型参数。简单地说，它的意思是“ `E` 是一个枚举类型。”**所有的枚举类型都扩展了泛型 `Enum` 类**。例如，`Weekday` 扩展了`Enum<Weekday>` 。

## 9.3.7 标识散列映射
类 `IdentityHashMap` 有特殊的作用。在这个类中，键的散列值不是用 `hashCode` 函数计算的，而是用 `System.identityHashCode` 方法计算的。这是 `Object.hashCode` 方法**根据对象的内存地址来计算一个散列码时**所使用的方式。而且在对两个对象进行比较时，`IdentityHashMap` 类使用 `==` ，而不使用 `equals` 。

也就是说，==不同的键对象，即使内容相同，也被视为是不同的对象。在实现对象遍历算法（如对象串行化）时，这个类非常有用，可以用来跟踪哪些对象已经遍历过==。
> [API] `java.util.WeakHashMap<K，V>1.2
> - `WeakHashMap()`
> - `WeakHashMap(int initialCapacity)`
> - `WeakHashMap(int initialCapacity, float loadFactor)`
> 用给定的容量和填充因子构造一个空的散列映射。

> [API] `java.util.LinkedHashSet<E>`
> - `LinkedHashSet()`
> - `LinkedHashSet(int initialCapacity)`
> - `LinkedHashSet(int initialCapacity, float loadFactor)`
> 用给定的容量和填充因子构造一个空链接散列集。

> [API] `java.util.LinkedHashMap<K, V>` 1.4
> - `LinkedHashMap()`
> - `LinkedHashMap(int initialCapacity)`
> - `LinkedHashMap(int initialCapacity, float loadFactor)`
> - `LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)`
> 用给定的容量、填充因子和顺序构造一个空的链接散列映射。`accessOrder` 参数为 `true` 时表示访问顺序，为 `false` 时表示插入顺序。
> - `protected boolean removeEldestEntry(Map.Entry<K, V> eldest)`
> 如果想删除 `eldest` 元素，就要覆盖为返回 `true` 。`eldest` 参数是预期可能要删除的条目。**这个方法在向映射中添加一个条目之后调用**。其默认的实现将返回 `false` ，即在默认情况下，旧元素不会被删除。然而，可以重新定义这个方法，以便有选择地返回 `true` 。例如，如果最旧的条目符合一个条件，或者映射超过了一定大小，则返回`true` 。

> [API] `java.util.EnumSet<E extends Enum<E>>` 5.0
> -  `static <E extends Enum<E>> EnumSet<E> allOf(Class<E> enumType)`
> 返回一个包含给定枚举类型的所有值的可变集。
> - `static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> enumType)`
> 返回一个空的可变集，并有足够的空间保存给定的枚举类型所有的值。
> - `static < E extends Enum<E>> EnumSet<E> range(E from, E to)`
> 返回一个包含 `from ~ to` 之间的所有值（包括两个边界元素）的可变集。
> - `static <E extends Enum<E>> EnumSet<E> of(E e)`
> - `static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4, E e5)`
> - `static <E extends Enum<E>> EnumSet<E> of(E first, E... rest)`
> 返回包括给定值的可变集。

> [API] `java.util.EnumMap<K extends Enum<K>, V>` 5
> - `EnumMap(Class<K> keyType)`
> 构造一个键为给定类型的空的可变映射。

> [API] `java.util.IdentityHashMap<K, V>` 5
> - `IdentityHashMap()`
> - `IdentityHashMap(int expectedMaxSize)`
> 构造一个空的标识散列映射集，其容量是大于 $1.5 \times expectedMaxSize$ 的 $2$ 的最小次幂（ `expectedMaxSize` 的默认值是21）。

> [API] `java.lang.System` 1.0
> - `static int identityHashCode(Object obj)` 1.1
> 返回与 `Object.hashCode` 计算相同的散列码（根据对象的内存地址产生），即使 `obj` 所属的类已经重新定义了 `hashCode` 方法也是如此。

---
# 9.4 视图与包装器
看一下图9-4和图9-5可能会感觉：用如此多的接口和抽象类来实现数量并不多的具体集合类似乎没有太大必要。然而，这两张图并没有展示出全部的情况。可以使用视图 `views` 获得「其他实现了 `Collection` 接口或 `Map` 接口的对象」。映射类的 `keySet` 方法就是一个示例。初看起来，好像这个方法创建了一个新集，并填入映射中的所有键，然后返回这个集。但是，情况并非如此。取而代之的是：**`keySet` 方法返回一个实现 `Set` 接口的类对象，这个类的方法对原映射进行操作**。这种集合称为**视图**。

视图技术在集合框架中有**许多非常有用的应用**。下面将讨论这些应用。
## 9.4.1 小集合
**Java 9引入了一些静态方法，可以生成给定元素的集或列表，以及给定键/值对的映射**。如下语句：
```java
List<String> names = List.of("Peter", "Paul", "Mary");
Set<Integer> numbers = Set.of(2, 3, 5);
```
会分别生成包含3个元素的一个列表和一个集。对于映射，需要指定键和值，如下所示：
```java
Map<String, Integer> scores = Map.of("Peter", 2, "Paul", 3, "Mary", 5);
```
元素、键或值不能为 `null` 。

`List` 和 `Set` 接口有11个 `of` 方法，分别有0到10个参数，另外还有一个参数个数可变的 `of` 方法。提供这种特定性是为了提高效率。

对于 `Map` 接口，则无法提供一个参数可变的版本，因为参数类型会在键和值类型之间交替 *since the argument types alternate between the key and value types* 。不过它有一个静态方法 `ofEntries` ，能接受任意多个 `Map.Entry<K, V>` 对象（可以用静态方法 `entry` 创建这些对象）。例如：
```java
import static java.util.Map.*;
...
Map<String, Integer> scores = ofEntries(
	entry("Peter", 2),
	entry("Paul", 3),
	entry("Mary", 5)
);
```
`of` 和 `ofEntries` 方法可以生成某些类的对象，这些类对每个元素会有一个实例变量，或者由一个数组支持 *produce objects of classes that have an instance variable for each element, or that are backed by an array* 。

这些集合对象是**不可修改的**，如果试图修改它们的内容，会抛出一个 `UnsupportedOperationException` 异常。**如果需要一个可更改的集合，可以把这个不可修改的集合传递到构造器**：
```java
var names = new ArrayList<>(List.of("Peter", "Paul", "Mary"));
```

以下方法调用会返回一个实现了 `List` 接口的不可变对象，给人一种错觉：就像有 $n$ 个元素，每个元素都是一个 `anObject` 。这样存储开销很小，对象只存储一次。这是视图技术的一种巧妙应用。
```java
Collections.nCopies(n, anObject)
```
例如下面的调用将创建一个包含100个字符串的 `List` ，每个串都设置为 `"DEFAULT"` ：
```java
List<String> settings = Collections.nCopies(100, "DEFAULT");
```

`of` 方法是Java 9引入的。之前有一个静态方法 `Arrays.asList` ，它会返回一个**可更改但是大小不可变的列表**（或者说返回一个包装了普通 Java数组的 `List` 包装器；**返回的对象不是 `ArrayList` ，是一个视图对象**），也就是在这个列表上可以调用（访问底层数组的）`get, set` ，但不能使用 `add` 或 `remove` 。这个方法可以将数组传递给一个「期望得到列表或集合参数」的方法。例如：
```java
Card[] cardDeck = new Card[52];
List<Card> cardList = Arrays.asList(cardDeck);
```
`asList` 方法可以接收可变数目的参数。例如：
```java
List<String> names = Arrays.asList("Alice", "Bob", "Carl");
```
 
> 注释：`Collections` 类包含很多实用方法，这些方法的参数和返回值都是集合。不要将它与 `Collection` 接口混淆起来。调用方法 `Collections.singleton(anObject)` 则将返回一个视图对象。这个对象实现了 `Set` 接口（与产生 `List` 的 `nCopies` 方法不同），实现了一个不可修改的单元素集，而不需要付出建立数据结构的开销。`singletonList` 方法与 `singletonMap` 方法类似。
> 
> 类似地，对于集合框架中的每一个接口，还有一些方法可以生成空集、列表、映射等等。特别是，集的类型可以推导得出：
> ```java
> Set< String> deepThoughts = Collections.emptySet();
> ```
> 不过 `emptySet, singleton` 等方法已经是 *legacy methods* 。

> 提升：Java没有 `Pair` 类，有些程序员可能使用 `Map.Entry` 作为 `pair` ，但这种做法并不好。在Java 9之前会很麻烦，必须使用 `new AbstractMap.SimpleImmutableEntry<>(first, second)` 构造对象，不过现在可以调用 `Map.entry(first, second)` 。
## 9.4.2 子范围
可以为很多集合建立**子范围 `subrange` 视图**。例如，假设有一个列表 `staff` ，想从中取出第10~19个元素。可以使用 `subList` 方法来获得一个列表的子范围视图，第一个索引包含在内，第二个索引则不包含在内。这与 `String` 类的 `substring` 操作中的参数情况相同。
```java
List group2 = staff.subList(10, 20);
```
**可以将任何操作应用于子范围，而且操作会自动反映到整个列表**。例如，可以删除整个子范围，现在元素自动地从 `staff` 列表中清除了，并且 `group2` 为空：
```java
group2.clear(); // staff reduction
```
**对于有序集和映射，可以使用排序顺序、而不是元素位置建立子范围**。`SortedSet` 接口声明了3个方法，这些方法将返回大于等于 `from` 且小于 `to` 的所有元素子集：
```java
SortedSet<E> subSet(E from, E to)
SortedSet<E> headSet(E to)
SortedSet<E> tailSet(E from)
```
有序映射也有类似的方法，返回映射视图，该映射包含**键落在指定范围内的所有元素**：
```java
SortedMap<K, V> subMap(K from, K to)
SortedMap<K, V> headMap(K to)
SortedMap<K, V> tailMap(K from)
```
Java 6引入的 `NavigableSet` 接口赋予子范围操作更多的控制能力。**可以指定是否包括边界**：
```java
NavigableSet<E> subSet(E from, boolean fromInclusive, E to, boolean toInclusive)
NavigableSet<E> headSet(E to, boolean toInclusive)
NavigableSet<E> tailSet(E from, boolean fromInclusive)
```
## 9.4.3 不可修改的视图
`Collections` 还有几个方法，用于产生**集合的不可修改视图**  `unmodifiable views` 。**这些视图对现有集合增加了一个运行时检查**。如果发现试图对集合进行修改，就抛出一个异常，同时这个集合将保持未修改的状态。可以使用下面8种方法获得不可修改视图：
```java
Collections.unmodifiableCollection
Collections.unmodifiableList
Collections.unmodifiableSet
Collections.unmodifiableSortedSet
Collections.unmodifiableNavigableSet
Collections.unmodifiableMap
Collections.unmodifiableSortedMap
Collections.unmodifiableNavigableMap
```
**每个方法都定义处理一个接口**。例如，`Collections.unmodifiableList` 处理 `ArrayList, LinkedList` 或任何实现了 `List` 接口的其他类。

例如，假设**想要查看（但不能修改）某个集合的内容**，就可以进行下列操作：
```java
var staff = new LinkedList<String>();
...
lookAt(Collections.unmodifiableList(staff));
```
`Collections.unmodifiableList` 方法将返回一个实现 `List` 接口的类对象。其访问器方法将从 `staff` 集合中获取值。当然，`lookAt` 方法可以调用 `List` 接口中的所有方法，而不只是访问器。但所有的更改器方法（例如 `add` ）已经被重新定义为抛出一个 `UnsupportedOperationException` 异常，而不是将调用传递给底层集合。

**不可修改视图并不是集合本身不可修改**。仍然可以通过集合的原始引用（在这里是 `staff` ）对集合进行修改，且仍然可以对集合的元素调用更改器方法。

**由于视图只是包装了接口而不是具体的集合对象，所以只能访问接口中定义的方法**。例如，`LinkedList` 类有一些非常方便的方法 `addFirst` 和 `addLast` ，它们都不是 `List` 接口的方法，不能通过不可修改的视图进行访问。
> 警告：`unmodifiableCollection` 方法（与本节稍后讨论的 `synchronizedCollection` 和 `checkedCollection` 方法一样）将返回一个集合，**它的 `equals` 方法不调用底层集合的 `equals` 方法**。相反，它继承了 `Object` 类的 `equals` 方法，这个方法只是检测两个对象是否是同一个对象。如果将集或列表转换成集合，就再也无法检测其内容是否相同了 *If you turn a set or list into just a collection, you can no longer test for equal contents* 。视图就采用这种工作方式，因为内容相等性检测在层次结构的这一层上没有明确定义 *not well defined at this level of the hierarchy* 。视图将以同样的方式处理 `hashCode` 方法。
> 
> 然而，`unmodifiableSet` 和 `unmodifiableList` 方法会使用底层集合 的 `equals` 方法和 `hashCode` 方法。

## 9.4.4 同步视图
如果从多个线程访问集合，就必须确保集合不会被意外地破坏。例如，如果一个线程试图将元素添加到散列表中，同时另一个线程正在对散列表进行再散列，其结果将是灾难性的。

==类库的设计者使用视图机制来确保常规集合是线程安全的，而不是实现线程安全的集合类==。例如，`Collections` 类的静态 `synchronizedMap` 方法，可以将任何一个映射转换成具有同步访问方法的 `Map` ：
```java
Map<String, Employee> map = Collections.synchronizedMap(new HashMap<String, Employee>());
```
现在，就可以从多线程访问这个 `map` 对象了。**像 `get` 和 `put` 等方法都是同步操作的，即每个方法调用必须完全结束、另一个线程才能调用另一个方法**。第12章会讨论数据结构的同步访问。
## 9.4.5 检查型视图
检查型视图 *checked views* 用来对泛型类型可能出现的问题、提供调试支持。如第8章所述，实际上将错误类型的元素混入泛型集合中的情况极有可能发生。例如：
```java
var strings = new ArrayList<String>();
ArrayList rawList = strings; // warning only, not an error, 
	// for compatibility with legacy code
rawList.add(new Date()); // now strings contains a Date object!
``` 
这个错误的 `add` 命令在运行时检测不到。相反，**只有在稍后的另一部分代码中调用 `get` 方法，并将结果转化为 `String` 时，这个类才会抛出异常**。

检查型视图可以探测到这类问题。下面定义了一个安全列表：
```java
List<String> safeStrings = Collections.checkedList(strings, String.class);
```
视图的 `add` 方法将检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个 `ClassCastException` 。**这样做的好处是错误可以在正确的位置得以报告**：
```java
ArrayList rawList = safeStrings;
rawList.add(new Date()); // checked list throws a ClassCastException
```
> 警告：检查型视图受限于虚拟机可以运行的运行时检查。例如，如果你有一个 `ArrayList<Pair<String>>` ，由于虚拟机有一个单独的“原始”Pair类，所以你无法阻止插入 `Pair<Date>` 。

## 9.4.6 关于可选操作的说明
通常一个视图有些限制 *A view usually has some restriction*，可能只可以读、可能无法改变大小、可能只支持删除而不支持插入（如映射的键视图）。如果试图进行不恰当的操作，受限制的视图就会抛出一个 `UnsupportedOperationException` 。

在集合和迭代器接口的API文档中，许多方法描述为“可选操作” *optional operations* 。这看起来与接口的概念有所抵触。毕竟，接口的设计目的不是负责给出一个类必须实现的方法吗？确实，从理论的角度看，这种安排很难令人满意。**一个更好的解决方案是为只读视图和不能改变集合大小的视图建立单独的接口** *design separate interfaces for read-only views and views that can’t change the size of a collection* 。不过，这将会使接口的数量翻至原来的三倍，这让类库设计者无法接受。

是否应将“可选”方法这一技术扩展到用户的设计中呢？我们认为**不应该**。尽管集合被频繁地使用，但实现集合的编码方式未必适用于其他问题领域。集合类库的设计者必须解决一组特别严格且又相互冲突的需求——用户希望类库应该易于学习、使用方便、彻底泛型化、面向通用性、同时又与手写算法一样高效。要同时达到所有目标的要求，或者尽量兼顾所有目标完全是不可能的。但在自己的编程问题中，很少遇到这样极端的局限性。你应该能找到一种合适的解决方案，不必依靠衡可选接口操作这种极端做法 *the extreme measure of “optional” interface operations* 。

> [API] `java.util.List` 1.2
> - `static <E> List<E> of()` 9
> - `static <E> List<E> of(E e1)` 9
> - ...
> - `static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)` 9
> - `static <E> List<E> of(E... elements)` 9
> 生成给定元素的一个**不可变列表**，元素不能为 `null` 。

> [API] `java.util.Set` 1.2
> - `static <E> Set<E> of()` 9
> - `static <E> Set<E> of(E e1)` 9
> ...
> - `static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)` 9
> - `static <E> Set<E> of(E... elements)` 9
> 生成给定元素的一个**不可变集**，元素不能为 `null` 。

> [API] `java.uti.Map` 1.2
> - `static <K, V> Map<K, V> of()` 9
> - `static <K, V> Map<K, V> of(K k1, V v1)` 9
> - ...
> - `static <K,V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10)` 9
> 生成给定键和值的一个**不可变映射**，键和值不能为 `null` 。
> - `static <K,V> Map.Entry<K, V> entry(K k, V v)`
> 生成给定键和值的一个**不可变映射条目**，键和值不能为 `null` 。
> - `static <K,V> Map<K,V> ofEntries(Map.Entry<? extends K, ? extends V>... entries)` 9
> 生成给定映射条目的一个**不可变映射**。

> [API] `java.util.Collections` 1.2
> - `static <E> Collection unmodifiableCollection(Collection<E> c)`
> - `static <E> List unmodifiableList(List<E> c)`
> - `static <E> Set unmodifiableSet(Set<E> c)`
> - `static <E> SortedSet unmodifiableSortedSet(SortedSet<E> c)`
> - `static <E> SortedSet unmodifiableNavigableSet(NavigableSet<E> c)` 8
> - `static <K, V> Map unmodifiableMap(Map<K, V> c)`
> - `static <K, V> SortedMap unmodifiableSortedMap(SortedMap<K, V> c)`
> - `static <K, V> SortedMap unmodifiableNavigableMap(NavigableMap<K, V> c)` 8
> 构造一个集合视图；视图的更改器方法抛出一个 `UnsupportedOperationException` 。 
> - `static <E> Collection<E> synchronizedCollection(Collection<E> c)`
> - `static <E> List synchronizedList(List<E> c)`
> - `static <E> Set synchronizedSet(Set<E> c)`
> - `static <E> SortedSet synchronizedSortedSet(SortedSet<E> c)`
> - `static <E> NavigableSet synchronizedNavigableSet(NavigableSet<E> c)` 8
> - `static <K, V> Map<K, V> synchronizedMap(Map<K, V> c)`
> - `static <K, V> SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> c)`
> - `static <K, V> NavigableMap<K, V>
> - `synchronizedNavigableMap(NavigableMap<K, V> c)` 8
> 构造一个集合视图；视图的方法同步。
> - `static <E> Collection checkedCollection(Collection<E> c, Class<E> elementType)`
> - `static <E> List checkedList(List<E> c, Class<E> elementType)`
> - `static <E> Set checkedSet(Set<E> c, Class<E> elementType)`
> - `static <E> SortedSet checkedSortedSet(SortedSet<E> c, Class<E> elementType)`
> - `static <E> NavigableSet checkedNavigableSet(NavigableSet<E> c, Class<E> elementType)` 8
> - `static <K, V> Map checkedMap(Map<K, V> c, Class<K> keyType, Class<V> valueType)`
> - `static <K, V> SortedMap checkedSortedMap(SortedMap<K, V> c, Class<K> keyType, Class<V> valueType)`
> - `static <K, V> NavigableMap checkedNavigableMap(NavigableMap<K, V> c, Class<K> keyType, Class<V> valueType)` 8
> - `static <E> Queue<E> checkedQueue(Queue<E> queue, Class<E> elementType)` 8
> 构造一个集合视图；如果插入一个错误类型的元素，视图的方法拋出一个 `ClassCastException` 。
> - `static <E> List<E> nCopies(int n, E value)`
> 生成一个不可变的列表，包含 $n$ 个相等的值。
> - `static <E> Set<E> singleton(E value)`
> - `static <E> List<E> singletonList(E value)`
> - `static <K, V> Map<K, V> singletonMap(K key, V value)` 
> 生成一个单例集、列表或映射。在Java 9中，要使用相应的 `of` 方法。
> - `static <E> List<E> emptyList()`
> - `static <T> Set<T> emptySet()`
> - `static <E> SortedSet<E> emptySortedSet()`
> - `static NavigableSet<E> emptyNavigableSet()`
> - `static <K,V> Map<K,V> emptyMap()`
> - `static <K,V> SortedMap<K,V> emptySortedMap()`
> - `static <K,V> NavigableMap<K,V> emptyNavigableMap()`
> - `static <T> Enumeration<T> emptyEnumeration()`
> - `static <T> Iterator<T> emptyIterator()`
> - `static <T> ListIterator<T> emptyListIterator()`
> 生成一个空集合、映射或迭代器。

> [API] `java.util.Arrays` 1.2
> - `static <E> List<E> asList(E... array)`
> 返回一个数组元素的列表视图。这个数组是可修改的，但其大小不可变。

> [API] `java.util.List<E>` 1.2
> - `List<E> subList(int firstIncluded, int firstExcluded)`
> 返回给定位置范围内的所有元素的列表视图。

> [API] `java.util.SortedSet<E>` 1.2
> - `SortedSet<E> subSet(E firstIncluded, E firstExcluded)`
> - `SortedSet<E> headSet(E firstExcluded)`
> - `SortedSet<E> tailSet(E firstIncluded)`
> 返回给定范围内的元素视图。

> [API] `java.util.NavigableSet<E>` 6
> - `NavigableSet<E> subSet(E from, boolean fromIncluded, E to, boolean toIncluded)`
> - `NavigableSet<E> headSet(E to, boolean toIncluded)`
> - `NavigableSet<E> tailSet(E from, boolean fromIncluded)`
> 返回给定范围内的元素视图。`boolean` 标志决定视图是否包含边界。

> [API] `java.util.SortedMap<K, V>` 1.2
> - `SortedMap<K, V> subMap(K firstIncluded, K firstExcluded)`
> - `SortedMap<K, V> headMap(K firstExcluded)`
> - `SortedMap<K, V> tailMap(K firstIncluded)` 
> 返回在给定范围内的键条目的映射视图。

> [API] `java.util.NavigableMap<K, V>` 6
> - `NavigableMap<K, V> subMap(K from, boolean fromIncluded, K to, boolean toIncluded)`
> - `NavigableMap<K, V> headMap(K from, boolean fromIncluded)`
> - `NavigableMap<K, V> tailMap(K to, boolean toIncluded)`
> 返回在给定范围内的键条目的映射视图。`boolean` 标志决定视图是否包含边界。

---
# 9.5 算法
除了实现集合类，Java集合框架还提供了一些有用的算法。下面了解如何使用它们、以及编写适用于集合框架的自己的算法。
## 9.5.1 为什么使用泛型算法
泛型集合接口有一个很大的优点，即算法只需要实现一次。例如，考虑一下计算集合中最大元素这样一个简单的算法。使用传统方式，程序设计人员可能会用循环实现这个算法。下面是找出数组中最大元素的代码。
```java
if (a.length == 0) throw new NoSuchElementException();
T largest = a[0];
for (int i = 1; i < a.length; i++)
	if (largest.compareTo(a[i]) < 0)
		largest = a[i];
```
当然，为找出数组列表中的最大元素所编写的代码会与此稍有差别。
```java
if (v.size() == 0) throw new NoSuchElementException();
T largest = v.get(0);
for (int i = 1; i < v.size(); i++)
	if (largest.compareTo(v.get(i)) < 0)
		largest = v.get(i);
```
链表应该怎么做呢？**对于链表来说，无法实施高效的随机访问，但却可以使用迭代器**。
```java
if (l.isEmpty()) throw new NoSuchElementException();
Iterator<T> iter = l.iterator();
T largest = iter.next();
while (iter.hasNext()) {
	T next = iter.next();
	if (largest.compareTo(next) < 0)
	largest = next;
}
```
编写这些循环代码有些乏味，并且很容易出错。是否存在差1错误 *off-by-one error* 吗？对于空容器循环能正常工作吗？对于只含有一个元素的容器又会发生什么情况呢？我们不希望每次都测试和调试这些代码，也不想实现下面这一系列的方法：
```java
static <T extends Comparable> T max(T[] a)
static <T extends Comparable> T max(ArrayList<T> v)
static <T extends Comparable> T max(LinkedList<T> l)
```
这里就可以使用集合接口。仔细考虑下，**为了高效地执行这个算法所需要的最小集合接口** *the minimal collection interface* 。采用 `get` 和 `set` 方法进行随机访问要比直接迭代层次髙。不过在计算链表中最大元素的过程中已经看到，这项任务并不需要随机访问，直接用迭代器遍历每个元素就可以计算最大元素。因此，可以将 `max` 方法实现为能接收**任何实现了 `Collection` 接口的对象**。
```java
public static <T extends Comparable> T max(Collection<T> c) {
	if (c.isEmpty()) throw new NoSuchElementException();
	Iterator<T> iter = c.iterator();
	T largest = iter.next();
	while (iter.hasNext()) {
		T next = iter.next();
		if (largest.compareTo(next) < 0)
			largest = next;
	}
	return largest;
}
```
现在就可以使用一个方法计算链表、数组列表或数组中最大元素了。

这是一个非常重要的概念。事实上，标准的C++类库已经有几十种非常有用的算法，每个算法都应用于泛型集合。Java类库中的算法没有如此丰富，但也包含了基本的排序、二分查找等实用算法。
## 9.5.1 排序与混排
如今，排序算法已成为大多数编程语言标准库中的一个组成部分，Java语言也不例外。

`Collections` 类中的 `sort` 方法，可以对实现了 `List` 接口的集合进行排序，这个方法假定列表元素实现了 `Comparable` 接口：
```java
var staff = new LinkedList<String>();
fill collection
Collections.sort(staff);
```

**如果想采用其他方式对列表进行排序，可以使用 `List` 接口的 `sort` 方法并传入一个 `Comparator` 对象**。可以如下按工资对一个员工列表排序：
```java
staff.sort(Comparator.comparingDouble(Employee::getSalary));
```
如果想按照降序对列表进行排序，可以使用一种非常方便的**静态方法**：`Collections.reverseOrder()` 。这个方法将返回一个比较器，比较器则返回 `b.compareTo(a)` ——即这个方法将根据元素类型的 `compareTo` 方法给定的排序顺序，按照逆序进行排序。如下所示：
```java
staff.sort(Comparator.reverseOrder())
```
如下语句将按工资逆序排序：
```java
staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed())
```

可能会对 `sort` 方法如何排序感到好奇。通常，在翻阅有关算法书籍中的排序算法时，会发觉介绍的都是有关数组的排序算法，而且使用的是随机访问方式。但对链表进行随机访问的效率很低。实际上，**可以使用一种归并排序对链表进行高效的排序**。然而，Java并不是这样实现的。它直接将所有元素转入一个数组，对数组进行排序，然后，再将排序后的序列复制回链表。
 
集合类库中使用的排序算法比快速排序要慢一些，快速排序是通用排序算法的传统选择。但归并排序有一个主要的优点：稳定，即不需要交换相同的元素。为什么要关注相同元素的顺序呢？ 下面是一种常见的情况。假设有一个已经按照姓名排列的员工列表。现在，要按照工资再进行排序。如果两个雇员的工资相等发生什么情况呢？如果采用稳定的排序算法，将会保留按名字排列的顺序。换句话说，排序的结果将会产生这样一个列表，首先按照工资排序、工资相同者再按照姓名排序。

==因为集合不需要实现所有的“可选”方法，因此，所有接受集合参数的方法必须描述什么时候可以安全地将集合传递给算法==。例如，显然不能将 `unmodifiableList` 列表传递给排序算法。可以传递什么类型的列表呢？根据文档说明，**列表必须是可修改的，但不必是可以改变大小的**。下面是有关的术语定义：
- 如果列表支持 `set` 方法，则是可修改的 *modifiable* 。
- 如果列表支持 `add` 和 `remove` 方法，则是可改变大小的 *resizable* 。

`Collections` 类有一个算法 `shuffle` ，其功能与排序刚好相反，即随机地混排列表中元素的顺序。例如：
```java
ArrayList<Card> cards = ...;
Collections.shuffle(cards);
```
**如果提供的列表没有实现 `RandomAccess` 接口，`shuffle` 方法会将元素复制到数组中**，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。

`shuffle/ShuffleTest.java` 程序用1~49之间的49个 `Integer` 对象填充数组。然后，随机地打乱列表，并从打乱后的列表中选前6个值。最后再将选择的数值进行排序和打印。
```java
package shuffle;

import java.util.*;

/**
 * This program demonstrates the random shuffle and sort algorithms.
 */
public class ShuffleTest {
	public static void main(String[] args) {
		var numbers = new ArrayList<Integer>();
		for (int i = 1; i <= 49; ++i)
			numbers.add(i);
		Collections.shuffle(numbers);
		List<Integer> winningCombination = numbers.subList(0, 6);
		Collections.sort(winningCombination);
		System.out.println(winningCombination);
	}
}
```
某次运行结果如下：
```java
[4, 5, 27, 28, 44, 48]
```
> `java.util.Collections` 1.2
> - `static <T extends Comparable<? super T>> void sort(List<T> elements)` 
> 使用稳定的排序算法，对列表中的元素进行排序。这个算法的时间复杂度是 $O(n\log n)$ ，其中 $n$ 为列表的长度。
> - `static void shuffle(List<?> elements)`
> - `static void shuffle(List<?> elements, Random r)`
> 随机地打乱列表中的元素。这个算法的时间复杂度是 $O(n\alpha(n))$ ，$n$ 是列表的长度，$\alpha(n)$ 是访问元素的平均时间。
> - `default void sort(Comparator<? super T> comparator)` 8
> 使用给定比较器对列表排序。

> [API] `java.util.Comparator<T>`
> - `static <T extends Comparable<? super T>> Comparator<T> reverseOrder()` 8
> 生成一个比较器，将逆置 `Comparable` 接口提供的顺序。
> - `default Comparator<T> reversed()` 8
> 生成一个比较器，将逆置这个比较器提供的顺序。

## 9.5.2 二分查找
要想在数组中査找一个对象，通常要依次访问数组中的每个元素，直到找到匹配的元素为止。然而，如果数组是有序的，就可以直接査看位于数组中间的元素，看一看是否大于要查找的元素。如果是，用同样的方法在数组的前半部分继续查找；否则，用同样的方法在数组的后半部分继续查找。这样就可以将查找范围缩减一半。一直用这种方式査找下去。例如，如果数组中有1024个元素，可以在10次比较后定位所匹配的元素（或者可以确认在数组中不存在这样的元素），而使用线性查找，如果元素存在，平均需要512次比较； 如果元素不存在，需要1024次比较才可以确认。

`Collections` 类的 `binarySearch` 方法实现了这个算法。注意，集合必须是排好序的，否则算法将返回错误的答案。**要想查找某个元素，必须提供集合**（这个集合要实现 `List` 接口，下面更加详细地介绍这个问题）**以及要查找的元素**。如果集合没有采用 `Comparable` 接口的
`compareTo` 方法进行排序，就还要提供一个比较器对象。
```java
i = Collections.binarySearch(c, element);
i = Collections.binarySearch(c, element, comparator);
```
如果 `binarySearch` 方法返回一个非负数值，则表示匹配对象的索引。也就是说，`c.get(i)` 等于在这个比较顺序下的 `element` 。如果返回负值，则表示没有匹配的元素。但可以利用返回值计算应该将 `element` 插入到集合的哪个位置，以保持集合的有序性。插入的位置是：
```java
insertionPoint = -i - 1;
```
并不是简单的 `-i` ，因为这样0值是二义的 *ambiguous* 。也就是说，下面这个操作将把元素插入到正确的位置上：
```java
if (i < 0) c.add(-i - 1, element);
```
只有采用随机访问，二分査找才有意义。如果必须利用迭代方式遍历链表的一半元素来找到中间位置的元素，二分査找就完全失去了优势。因此，如果为 `binarySearch` 算法提供一个链表，它将自动地变为线性查找。
> [API] `java.util.Collections` 1.2
> - `static <T extends Comparable<? super T>> int binarySearch(List<T> elements, T key)`
> - `static <T> int binarySearch(List<T> elements, T key, Comparator<? super T> c)`
> 从有序列表中搜索一个键，如果元素类型实现了 `RandomAccess` 接口，就采用二分查找；否则都将采用线性查找。这个方法的时间复杂度为 $O(n \alpha(n))$ ，$n$ 是列表的长度，$\alpha(n)$ 是访问一个元素的平均时间。这个方法将返回这个键在列表中的索引，如果在列表中不存在这个键将返回负值 $i$  。在这种情况下，应该将这个键插入到列表索引 $-i- 1$ 的位置上，以保持列表的有序性。

# 9.5.3 简单算法
在 `Collections` 类中包含了几个简单且很有用的算法。前面介绍的查找集合中最大元素的示例就在其中。另外还包括：将一个列表中的元素复制到另外一个列表中；用一个常量值填充容器；逆置一个列表的元素顺序。

为什么会在标准库中提供这些简单算法呢？大多数程序员肯定可以很容易地采用循环实现这些算法。**我们之所以喜欢这些算法，是因为它们可以让程序员更轻松地读代码**。当阅读由别人实现的循环时，必须要揣摩编程者的意图。而在看到诸如 `Collections.max` 这样的方法调用时，一定会立刻明白其用途。例如下面这个循环：
```java
for (int i = 0; i < words.size(); i++)
	if (words.get(i).equals("C++")) words.set(i, "Java");
```
现在将这个循环与以下调用比较，看到这个方法调用、马上就能知道这个代码要做什么：
```java
Collections.replaceAll("C++", "Java");
```

本节最后API注释描述了 `Collections` 类中的简单算法。

Java 8增加了默认方法 `Collection.removeIf` 和 `List.replaceAll` ，这两个方法稍有些复杂。要提供一个lambda表达式来测试或转换元素。例如，下面的代码将删除所有短词，并把其余单词改为小写：
```java
words.removeIf(w -> w.length() <= 3);
words.replaceAll(String::toLowerCase);
```

> [API] `java.util.Collections` 1.2
> - `static <T extends Comparable<? super T>> T min(Collection<T> elements)`
> - `static <T extends Comparable<? super T>> T max(Collection<T> elements)`
> - `static <T> min(Collection<T> elements, Comparator<? super T> c)`
> - `static <T> max(Collection<T> elements, Comparator<? super T> c)`
> 返回集合中最小的或最大的元素（为清楚起见，参数的边界有所简化）。
> - `static <T> void copy(List<? super T> to, List<T> from)`
> 将原列表中的所有元素复制到目前列表的相应位置上。目标列表的长度至少与原列表一样。
> - `static <T> void fill(List<? super T> l, T value)`
> 将列表中所有位置设置为相同的值。
> - `static <T> boolean addAll(Collection<? super T> c, T... values)` 5.0
> 将所有的值添加到集合中。如果集合改变了，则返回 `true` 。
> - `static <T> boolean replaceAll(List<T> l, T oldValue, T newValue)` 1.4
> 用 `newValue` 取代所有值为 `oldValue` 的元素。
> - `static int indexOfSubList(List<?> l, List<?> s)` 1.4
> - `static int 1astIndexOfSubList(List<?> l, List<?> s)` 1.4
> 返回 `l` 中第一个或最后一个等于 `s` 子列表的索引。如果 `l` 中不存在等于 `s` 的子列表，则返回-1。例如，`l=[s,t,a,r], s=[t,a,r]` ，两个方法都将返回索引1。
> - `static void swap(List<?> l, int i, int j)` 1.4
> 交换给定偏移量的两个元素。
> - `static void reverse(List<?> l)`
> 逆置列表中元素的顺序。例如逆置列表 `[t, a, r]` 后将得到列表 `[r, a, t]` 。这个方法的时间复杂度为 $O(n)$ ，$n$ 为列表的长度。
> - `static void rotate(List<?> l, int d)` 1.4
> 旋转列表中的元素，将索引 `i` 的条目移动到位置 `(i + d) % l.size()` 。例如，将列表 `[t,a,r]` 旋转移动2个位置后得到 `[a,r，t]` 。这个方法的时间复杂度为 $O(n)$ ，$n$ 为列表的长度。
> - `static int frequency(Collection<?> c, Object o)` 5.0
> 返回 `c` 中与对象 `o` 相同的元素个数。
> - `boolean disjoint(Collection<?> cl, Collection<?> c2)` 5.0
> 如果两个集合没有共同的元素，则返回 `true` 。

> [API] `java.util.Collection<T>` 1.2
> - `default boolean removeIf(Predicate<? super E> filter)` 8
> 删除所有匹配的元素。

> [API] `java.util.List<E>` 1.2
> - `default void replaceAll(UnaryOperator<E> op)` 8
> 对这个列表的所有元素应用这个操作。

## 9.5.4 批操作
很多操作会“成批”复制或删除元素。以下调用
```java
coll1.removeAll(coll2);
```
将从 `coll1` 中删除 `coll2` 中出现的所有元素。与之相反，
```java
coll1.retainAll(coll2);
```
会从 `coll1` 中删除所有未在 `co112` 中出现的元素。

下面是一个典型的应用。假设希望找出两个集的交集 `intersection` ，也就是两个集中共有的元素。首先建立一个新集来存放结果：
```java
var result = new HashSet<String>(a);
```
在这里利用了一个事实：每一个集合都有这样一个构造器，其参数是包含初始值的另一个集合 *every collection has a constructor whose parameter is another collection that holds the initialization values* 。现在来使用 `retainAll` 方法，这会保留恰好**也**在 `b` 中出现的所有元素。这样就构成了交集，而无需编写循环：
```java
result.retainAll(b);
```

可以把这个思路更进一步，对视图应用一个批操作。例如，假设有一个映射，将员工ID映射到员工对象，而且建立了一个将不再聘用的所有员工的ID。
```java
Map<String, Employee> staffMap = ...;
Set<String> terminatedIDs = ...;
```
**只需要建立一个键集，并删除终止聘用关系的所有员工的ID**。由于键集是映射的一个视图，所以键和相关联的员工名会自动从映射中删除：
```java
staffMap.keySet().removeAll(terminatedIDs);
```

**通过使用一个子范围视图，可以把批操作限制在子列表和子集上**。例如，假设希望把一个列表的前10个元素增加到另一个容器，可以建立一个子列表选出前10个元素：
```java
relocated.addAll(staff.subList(0, 10));
```
这个子范围还可以完成更改操作。
```java
staff.subList(0, 10).clear();
```
## 9.5.5 集合与数组的转换
由于Java平台API的大部分内容都是在集合框架创建之前设计的，所以，**有时候需要在传统的数组和比较现代的集合之间进行转换**。

如果需要把一个数组转换为集合，`Arrays.asList` 或 `List.of` 包装器可以达到这个目的。例如：
```java
String[] values = . . .;
var staff = new HashSet<>(List.of(values));
```
从集合得到数组会更困难一些。当然，可以使用 `toArray` 方法：
```java
Object[] values = staff.toArray();
```
不过，这样做的结果是一个对象数组。尽管你知道集合中包含一个特定类型的对象，但不能使用强制类型转换：
```java
String[] values = (String[]) staff.toArray(); // ERROR
```
**`toArray` 方法返回的数组是一个 `Object[]` 数组，不能改变它的类型**。实际上，**必须使用 `toArray` 方法的一个变体，提供一个指定类型而且长度为0的数组**。这样一来，返回的数组就会创建为相同的数组类型：
```java
String[] values = staff.toArray(new String[0]);
```
如果愿意，可以构造一个指定大小的数组，在这种情况下，不会创建新数组。
```java
staff.toArray(new String[staff.size()]);
```

> 注释：可能奇怪为什么不能直接将一个 `Class` 对象（如 `String.class` ）传递到 `toArray` 方法。原因是这个方法有“双重职责”，不仅要填充一个已有的数组（如果它足够长 *provided it is long enough*) ，还要创建一个新数组。

## 9.5.6 编写自己的算法
==如果编写自己的算法（实际上，是以集合作为参数的任何方法），应该尽可能地使用接口，而不要使用具体的实现==。例如，假设想用一组菜单项填充 `JMenu` 。传统上可能如下所示实现这种方法：
```java
void fillMenu(JMenu menu, ArrayList<JMenuItem> items) {
	for (JMenuItem item : items)
		menu.add(item);
}
```
但这样会限制方法的调用程序，即调用程序必须在 `ArrayList` 中提供选项。如果这些菜单项放在另一容器中，首先必须对它们重新包装，因此，最好接受一个更加通用的集合。

**要问自己：完成这项工作的最通用的集合接口是什么**？这里只需要访问所有的元素，这是 `Collection` 接口的基本功能。下面代码说明了如何重新编写 `fillMenu` 方法、使之接受任意类型的集合。
```java
void fillMenu(JMenu menu, Collection<JMenuItem> items) {
	for (JMenuItem item : items)
		menu.add(item);
}
```
现在任何人都可以用 `ArrayList` 或 `LinkedList` ，甚至用 `Arrays.asList` 或 `List.of` 包装器包装的数组调用这个方法。
> 注释：这里可以做得更好：接受一个 `Iterable<JMenuItem>` 。`Iterable` 有一个抽象方法 `iterator` ，增强的for循环在底层就使用了这个方法。`Collection` 接口扩展了 `Iterable` 。

> 注释：既然将集合接口作为方法参数是个很好的想法，为什么Java类库不更多地这样做呢？例如，`JComboBox` 有两个构造器：
> ```java
> JComboBox(Object[] items)
> JComboBox(Vector< ?> items)
> ```
> 之所以没有这样做，原因很简单：时间问题。Swing类库是在集合类库之前创建的。

反过来，**如果你的方法返回多个元素，肯定不希望限制将来的改进**——如果编写了一个返回集合的方法，可能还想要**一个返回接口、而不是返回类的方法**，因为这样做可以在日后改变想法，并用另一个集合重新实现这个方法。例如，编写一个返回所有菜单项的方法 `getAllItems` ，这里不承诺返回一个 `ArrayList` ，因为调用者并不关心它是什么类型的列表，取而代之的我们承诺并返回一个 `List` ，这样任何时候都可以添加一个分支——通过调用 `List.of` 返回一个空或单例列表 *at any time add a branch that returns an empty or singleton list by calling List.of* 。
```java
List<JMenuItem> getAllItems(JMenu menu) {
	List<JMenuItem> items = new ArrayList<>();
	for (int i = 0; i < menu.getItemCount(); ++i)
		items.add(menu.getItem(i));
	return items;
}
```
日后还可以做出这样的决定：不复制所有的菜单项，而**仅仅提供这些菜单项的视图。要做到这一点，只需要返回 `AbstractList` 的匿名子类**。
```java
List<JMenuItem> getAllItems(final JMenu menu) {
	return new AbstractList<>() {
		public JMenuItem get(int i) {
			return menu.getItem(i);
		}
		public int size() {
			return menu.getItemCount();
		}
	};
}
```
当然，这是一项高级技术。如果使用它，就应该将它支持的那些“可选” 操作准确地记录在文档中。**在这种情况下，必须提醒调用者返回的对象是一个不可修改的列表**。

---
# 9.6 遗留的集合
从Java第1版问世以来，在集合框架出现之前已经存在大量“遗留的”容器类。这些类已经集成到集合框架中，如图9-12所示。下面各节将简要介绍这些遗留的集合类。
![图9-12 集合框架中的遗留类](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202210311752774.png)
## 9.6.1 `Hashtable` 类
`Hashtable` 类与 `HashMap` 类的作用一样，实际上，它们拥有相同的接口。与 `Vector` 类的方法一样。`Hashtable` 的方法也是同步的。**如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用 `HashMap`** 。如果需要并发访问，则要使用 `ConcurrentHashMap` ，参见第12章。
## 9.6.2 `Enumeration`
**遗留集合使用 `Enumeration` 接口对元素序列进行遍历**。`Enumeration` 接口有两个方法，即 `hasMoreElements` 和 `nextElement` 。这两个方法与 `Iterator` 接口的 `hasNext` 方法和 `next` 方法十分类似 *entirely analogous* 。

例如，`Hashtable` 类的 `elements` 方法将产生一个用于描述表中各个枚举值的对象：
```java
Enumeration<Employee> e = staff.elements();
whi1e (e.HasMoreElements()) {
	Employee e = e.nextElement();
}
```
有时还会遇到遗留的方法、其参数是枚举类型的。静态方法`Collections.enumeration` 将产生一个枚举对象，枚举集合中的元素。例如：
```java
List<InputStream> streams = ...;
var in = new SequenceInputStream(Collections.enumeration(streams));
// the SequenceInputStream constructor expects an enumeration
```

**如果发现遗留的类实现了这个接口，可以使用 `Collections.list` 将元素收集到一个 `ArrayList` 中**。例如，`LogManager` 类只将登记者的名字提供为一个 `Enumeration` ，可以如下得到所有登陆者的名字：
```java
ArrayList<String> loggerNames = Collections.list(LogManager.getLoggerNames());
```
或者在Java 9中，可以将一个枚举转换为一个迭代器：
```
LogManager.getLoggerNames().asIterator().forEachRemaining(n -> { ... });
```

> 注释：在C++中，用迭代器作为参数十分普遍。幸好，在Java编程平台中，只有极少的程序员沿用这种习惯。**传递集合要比传递迭代器更为明智**。集合对象的用途更大；当接受方需要时，总是可以从集合中获得迭代器，且还可以随时使用集合的所有方法。不过，可能会在某些遗留代码中发现枚举接口，因为在Java 1.2的集合框架出现之前，它们是唯一可以使用的泛型集合机制。

> [API] `java.util.Enumeration<E>` 1.0
> - `boolean hasMoreElements()`
> 如果还有更多的元素可以査看，则返回 `true` 。
> - `E nextElement()`
> 返回被检测的下一个元素。如果 `hasMoreElements()` 返回 `false` ，则不要调用这个方法。
> - `default Iterator<E> asIterator()` 9
> 生成一个迭代器，可以迭代处理枚举的元素。

> [API] `java.util.Collections` 1.2
> - `static <T> Enumeration<T> enumeration(Collection<T> c)`
> 返回一个枚举，可以枚举 `c` 的元素。
> - `public static <T> ArrayList<T> list(Enumeration<T> e)`
> 返回一个数组列表，其中包含 `e` 枚举的元素。

## 9.6.3 属性映射
**属性映射** `property map` 是一个特殊类型的映射结构。它有下面3个特性：
- 键与值都是字符串。
- 这个映射可以容易地保存到文件中、以及从文件中加载。
- 有一个二级表存放默认值。

实现属性映射的Java平台类称为 `Properties` 。属性映射对于指定程序的配置选项很有用。
```java
var settings = new Properties();
settings.setProperty("width", "600.0");
settings.setProperty("filename", "/home/cay/books/cj11/code/v1ch11/raven.html");
```
使用 `store` 方法将属性映射表保存到一个文件中。这里我们将属性映射保存在文件 `program.properties` 中。第二个参数是包含在这个文件中的注释。
```java
var out = new FileOutputStream("program.properties");
settings.store(out, "Program Properties");
```
这个示例会给出以下输出：
```java
#Program Properties
#Sun Dec 31 12:54:19 PST 2017
top=227.0
left=1286.0
width=423.0
height=547.0
filename=/home/cay/books/cj11/code/v1ch11/raven.html
```
要从文件加载属性，可以使用如下方法：
```java
var in = new FileInputStream("program.properties");
settings.load(in);
```
**`System.getProperties` 方法会生成 `Properties` 对象描述系统信息**。例如，主目录包含键 `"user.home"` 。可以用 `getProperties` 方法读取这个信息，它将键作为一个字符串返回：
```java
String userDir = System.getProperty("user.home");
```
> 警告：处于历史方面的原因，`Properties` 类实现了 `Map<Object, Object>` 。因此，可以使用 `Map` 接口的 `get, put` 方法。不过，`get` 方法返回类型为 `Object` ，而 `put` 方法允许插入任意的对象。所以**最好坚持使用「处理字符串而不是对象的 `getProperty, setProperty` 方法」**。

要得到虚拟机的Java版本，可以查找 `"java.version"` 属性。会得到一个诸如"9.0.1"的字符串（或者对应Java 8为"1.8.0"）。因为**Java 9中版本编号发生了变化**，这个看起来很小的改变却让「大量依赖于老版本格式的工具」无法正常工作，如果要解析版本字符串，一定要看[JEP 322](http://openjdk.java.net/jeps/322)，了解将来（至少是版本编号机制再次改变之前）版本字符串会采用怎样的格式。

`Properties` 有两种提供默认值的机制。第一种方法是：只要查找一个字符串的值，可以指定一个默认值，这样当键不存在时就会自动使用这个默认值。如下，如果属性映射中有一个 `"filename"` 属性，`filename` 就会设置为相应的字符串。否则，`filename` 变量就被设置为空串。
```java
String filename = settings.getProperty("filename", "");
```
**如果觉得在每个 `getProperty` 调用中指定默认值太过麻烦，可以把所有默认值都放在一个二级属性映射中**，并在主属性映射的构造器中提供这个二级映射。
```java
var defaultSettings = new Properties();
defaultSettings.setProperty("width", "600");
defaultSettings.setProperty("height", "400");
defaultSettings.setProperty("filename", "");
...
var settings = new Properties(defaultSettings);
```
没错，如果为 `defaultSettings` 构造器提供另一个属性映射参数 *property
map parameter* ，甚至可以为默认值指定默认值 *specify defaults to defaults* ，不过一般不会这么做。

后面提供了一个示例程序，展示如何使用属性存储和加载程序状态。这个程序使用第2章的 `ImageViewer` 程序，可以记住帧窗口位置 *the frame position* 、大小和最后加载的文件。运行这个程序，加载一个文件，然后移动窗口和调整窗口大小。再关闭程序，然后重新打开，看它是否记住了你的文件和窗口的位置。还可以手动编辑目录中的 `ImageViewer.properties` 文件（**在Java 9之前属性文件使用7位ASCII编码，如今使用UTF-8**）。

**属性是没有层次结构的简单表格**。通常会用类似 `window.main.color, window.main.title` 等引入一个假想的层次结构。不过 `Properties` 类没有方法来帮忙组织这样一个层次结构。如果要存储复杂的配置信息，就应该改为使用 `Perferences` 类（第10章）。
```java
// properties/ImageViewer.java
package properties;

import java.awt.EventQueue;
import java.awt.event.*;
import java.io.*;
import java.util.Properties;
import javax.swing.*;

/**
 * A program to test properties. The program remembers the frame position, size,
 * and last selected file.
 * @version 1.10 2018-03-15
 * @author Cay Horstmann
 */
public class ImageViewer {
   public static void main(String[] args) {
      EventQueue.invokeLater(() -> {
         var frame = new ImageViewerFrame();
         frame.setTitle("ImageViewer");
         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         frame.setVisible(true);
      });
   }
}

/**
 * An image viewer that restores position and size from a properties file
 * and updates the properties upon exit.
 */
class ImageViewerFrame extends JFrame {
   private static final int DEFAULT_WIDTH = 300;
   private static final int DEFAULT_HEIGHT = 200;

   private File propertiesFile;
   private Properties settings;
   private String image;
   private JLabel label = new JLabel();

   public ImageViewerFrame() {
      // get position, size, title from properties

      String userDir = System.getProperty("user.home");
      var propertiesDir = new File(userDir, ".corejava");
      if (!propertiesDir.exists()) propertiesDir.mkdir();
      propertiesFile = new File(propertiesDir, "ImageViewer.properties");

      var defaultSettings = new Properties();
      defaultSettings.setProperty("left", "0");
      defaultSettings.setProperty("top", "0");
      defaultSettings.setProperty("width", "" + DEFAULT_WIDTH);
      defaultSettings.setProperty("height", "" + DEFAULT_HEIGHT);
      defaultSettings.setProperty("title", "");

      settings = new Properties(defaultSettings);

      if (propertiesFile.exists()) 
         try (var in = new FileInputStream(propertiesFile)) {         
            settings.load(in);
         }
         catch (IOException ex) {
            ex.printStackTrace();
         }

      int left = Integer.parseInt(settings.getProperty("left"));
      int top = Integer.parseInt(settings.getProperty("top"));
      int width = Integer.parseInt(settings.getProperty("width"));
      int height = Integer.parseInt(settings.getProperty("height"));
      setBounds(left, top, width, height);
      image = settings.getProperty("image");
      if (image != null) label.setIcon(new ImageIcon(image));

      addWindowListener(new WindowAdapter() {
         public void windowClosing(WindowEvent event) {
            settings.setProperty("left", "" + (int) getX());
            settings.setProperty("top", "" + (int) getY());
            settings.setProperty("width", "" + (int) getWidth());
            settings.setProperty("height", "" + (int) getHeight());
            if (image != null)
               settings.setProperty("image", image);
            try (var out = new FileOutputStream(propertiesFile)) {
               settings.store(out, "Program Properties");
            }
            catch (IOException ex) {
               ex.printStackTrace();
            }
            System.exit(0);
         }
      });

      // use a label to display the images
      add(label);

      // set up the file chooser
      var chooser = new JFileChooser();
      chooser.setCurrentDirectory(new File("."));

      // set up the menu bar
      var menuBar = new JMenuBar();
      setJMenuBar(menuBar);

      var menu = new JMenu("File");
      menuBar.add(menu);

      var openItem = new JMenuItem("Open");
      menu.add(openItem);
      openItem.addActionListener(event -> {
         // show file chooser dialog
            int result = chooser.showOpenDialog(null);

            // if file selected, set it as icon of the label
            if (result == JFileChooser.APPROVE_OPTION) {
               image = chooser.getSelectedFile().getPath();
               label.setIcon(new ImageIcon(image));
            }
         });

      var exitItem = new JMenuItem("Exit");
      menu.add(exitItem);
      exitItem.addActionListener(event -> System.exit(0));
   }
}
```
> [API] `java.util.Properties` 1.0
> - `Properties()`
> 创建一个空的属性映射。
> - `Properties(Properties defaults)`
> 用一组默认值创建一个空的属性映射。
> - `String getProperty(String key)`
> 获得一个属性。返回与键对应的字符串。如果在映射中不存在，则返回默认表中与这个键对应的字符串，或者如果键在默认值表中也未出现，则返回 `null` 。
> - `String getProperty(String key, String defaultValue)`
> 如果键没找到，获得一个有默认值的属性；它将返回与键对应的字符串，或者如果键在表中不存在，就返回默认字符串。
> - `void load(InputStream in)`
> 从一个输入流 `InputStream` 加载一个属性映射。
> - `void store(OutputStream out, String header)`
> 把一个属性映射存储到一个输出流 `OutputStream` 。`header` 是所存储文件的第一行。

> [API] `java.lang.System`
> - `Properties getProperties()`
> 获得所有系统属性。应用必须有权限获取所有属性，否则会抛出一个安全异常。
> - `String getProperty(String key)`
> 获取给定键名对应的系统属性。应用必须有权限获取这个属性，否则会抛出一个安全异常。以下属性总是允许获取：
>    ```java
> java.version 
> java.vendor
> java.vendor.url
> java.home
> java.class.path
> java.library.path
> java.class.version
> os.name
> os.version
> os.arch
> file.separator
> path.separator
> line.separator
> java.io.tempdir
> user.name
> user.home
> user.dir
> java.compiler
> java.specification.version
> java.specification.vendor
> java.specification.name
> java.vm.specification.version
> java.vm.specification.vendor
> java.vm.specification.name
> java.vm.version
> java.vm.vendor
> java.vm.name
>    ```

## 9.6.4 栈
从1.0版开始，标准类库中就包含了 `Stack` 类，其中有大家熟悉的 `push` 方法和 `pop` 方法。但 `Stack` 类扩展了 `Vector` 类，从理论角度看，这不太令人满意，你可以让栈使用不属于栈操作的 `insert` 和 `remove` 方法、在任何地方插入或删除值，而不只是在栈顶。
> [API] `java.util.Stack<E>` 1.0
> - `E push(E item)`
> 将 `item` 压入桟并返回 `item` 。
> - `E pop()`
> 弹出并返回栈顶的 `item` 。如果栈为空，不要调用这个方法。
> - `E peek()`
> 返回栈顶元素，但不弹出。如果栈为空，不要调用这个方法。

## 9.6.5 位集
Java平台的 `BitSet` 类用于存放一个位序列（它不是数学上的集，称为位向量或位数组更为合适）。如果需要高效地存储位序列（例如，标志）就可以使用位集。由于位集将位包装在字节里，所以使用位集要比使用 `Boolean` 对象的 `ArrayList` 更加高效。

**`BitSet` 类提供了一个便于读取、设置或清除各个位的接口**。使用这个接口可以避免掩码和其他调整位的操作。如果将这些位存储在 `int` 或 `long` 变量中就必须进行这些繁琐的操作。例如，对于一个名为 `bucketOfBits` 的 `BitSet` ，`bucketOfBits.get(i)` 如果第 `i` 位处于“开”状态，就返回 `true` ，否则返回 `false` 。同样地，`bucketOfBits.set(i)` 将第 `i` 位置为“开”状态。最后，`bucketOfBits.clear(1)` 将第 `i` 位置为“关”状态。

> C++注释：C++中的 `bitset` 模板与Java的 `BitSet` 功能一样。

> [API] `java.util.BitSet` 1.0
> - `BitSet(int initialCapacity)`
> 创建一个位集。
> - `int length()`
> 返回位集的“逻辑长度”，即1加上位集的最高设置位的索引。
> - `boolean get(int bit)`
> 获得一个位。
> - `void set(int bit)`
> 设置一个位。
> - `void clear(int bit)`
> 清除一个位。
> - `void and(BitSet set)`
> 这个位集与另一个位集进行逻辑“AND”。
> - `void or(BitSet set)`
> 这个位集与另一个位集进行逻辑“OR”。
> - `void xor(BitSet set)`
> 这个位集与另一个位集进行逻辑“XOR”。
> - `void andNot(BitSet set)`
> 对另一个位集中设置为1的所有位，将这个位集中相应的位清除为0。

作为位集应用的一个示例，这里给出一个采用“Eratosthenes”算法查找素数的实现（素数是指只能被1和本身整除的数，例如2, 3, 5。Eratosthenes算法是最早发现的用来枚举这些基本数字的方法之一)。这并不是查找素数的一种最好方法，但由于某种原因，它已经成为测试编译程序性能的一种流行的基准（这也不是一种最好的基准测试方法，它主要用于测试位操作）。

在此尊重这个传统，并给出实现。其程序将计算2~2 000 000之间的所有素数（一共有148 933个素数，可能不打算把它们全部打印出来）。这里并不深入程序的细节，==关键是要遍历一个拥有200万个位的位集。首先将所有的位置为“开”状态，然后将已知素数的倍数所对应的位都置为“关”状态。经过这个操作保留下来的位对应的就是素数==。`sieve/SieveTest.java` 用Java实现这个算法。
```java
// sieve/SieveTest.java
package sieve;

import java.util.*;

/** 
 * This program runs the Sieve of Erathostenes benchmark. It computes all primes
 * up to 2,000,000
 */
public class SieveTest {
	public static void main(String[] args) {
		int n = 2000000;
		long start = System.currentTimeMillis();
		var bitset = new BitSet(n + 1);
		int count = 0;
		int i;
		for (i = 2; i <= n; ++i)
			bitset.set(i); // true
		i = 2;
		while (i * i <= n) {
			if (bitset.get(i)) {
				++count;
				int k = 2 * i;
				while (k <= n) {
					bitset.clear(k);
					k += i;
				}
			}
			++i;
		}
		while (i <= n) {
			if (bitset.get(i)) ++count;
			++i;
		}
		long end = System.currentTimeMillis();
		System.out.println(count + " primes");
		System.out.println((end - start) + " milliseconds");
	}
}
```
运行结果如下所示：
```java
148933 primes
82 milliseconds
```