
▲从Java程序中调用C函数
▲数值参数与返回值
▲字符串参数
▲访问域
▲编码签名
▲调用Java方法
▲访问数组元素
▲错误处理
▲使用调用API
▲完整的示例：访问Windows注册表

原则上说，“100%纯Java”的解决方案是非常好的，但有时也会想要编写或使用其他语言的代码（这种代码通常称为**本地代码** *native code* ）。

特别是在Java的早期阶段，许多人都认为使用C或C++来加速Java应用中关键部分是个好主意。但实际上，这基本上是徒劳的。1996年JavaOne会议上有一个演讲很明确地说明了这一点，来自Sun Microsystems的密码系统类库的实现者，报告说他们的纯Java平台实现（带密码功能）已臻化境。他们的代码确实没有已有的C实现快，但事实证明这无关紧要。Java平台实现比网络I/O要快得多，而后者是真正的瓶颈 *bottleneck* ，这是案情。

当然，**求助于本地代码是有缺陷的**。如果应用的某个部分是用其他语言编写的，那么就必须**为需要支持的每个平台、都提供一个单独的本地类库**。用C或C++编写的代码没有对「通过使用无效指针造成的内存覆写 *overwriting
memory through invalid pointer usage* 」提供任何保护。编写本地代码很容易破坏你的程序，并感染操作系统。

因此，我们建议只有在必需的时候才使用本地代码。特别是在以下三种情况下，也许可以使用本地代码：
- 应用需要访问的系统特性和设备，无法通过Java平台访问。
- 你已经有了大量的测试过和调试过的、用另一种语言编写的代码，并且知道如何将其导出到所有的目标平台上。
- 通过基准测试，发现所编写的Java代码比用其他语言编写的等价代码要慢得多。

Java平台有一个用于和本地C代码进行互操作的API，称为Java本地接口 *Java Native Interface, JNI* 。这里讨论JNI编程。
> C++注意：可以使用C++代替C来编写本地方法。这样会有一些好处：类型检查会更严格一些，访问JNI函数会更便捷一些。然而，**JNI并不支持Java类和C++类之间的任何映射机制**。

# 24.1 从Java程序中调用C函数
假设有一个C函数，它能实现某个功能，因为某种原因，你不想费事使用Java重新实现它。为了方便说明问题，我们从一个很简单的打印问候语的C函数入手。==Java使用关键字native表示本地方法，而且很显然、你还需要在类中放置一个方法==。见 `helloNative/HelloNative.java` 。
```java
// helloNative/HelloNative.java
class HelloNative {
	public static native void greeting();
}
```
**关键字 `native` 提醒编译器该方法将在外部定义**。当然，**本地方法在Java编程语言中不包含代码** *native methods will contain no code in the Java programming language* ，它的方法头后直接跟着一个表示终结的分号。因此，本地方法声明看上去和抽象方法声明类似。
> 注意：为了保持样例的简单性，这里也不使用包。

在这个特定示例中，本地方法也被声明为 `static` 。**本地方法既可以是静态的也可以是非静态的**，使用静态方法是因为我们还不需要处理参数传递。

实际上可以编译这个类，但在程序中使用它时，虚拟机就会告诉你它不知道如何找到 `greeting` ，它会报告一个 `UnsatisfiedLinkError` 异常。为了实现本地代码，需要编写一个相应的C函数，你必须完全 *exactly* 按照Java虚拟机预期的那样来命名这个函数。其规则是：
1. 使用完整的Java方法名，比如：`HelloNative.greeting` 。如果类属于某个包，那么在前面添加包名，比如 `com.horstmann.HelloNative.greeting` 。
2. 用下划线替换掉所有的句号，并加上Java_前缀，例如`Java_HelloNative_greeting` 或 `Java_com_horstmann_HelloNative_greeting` 。
3. 如果类名含有非ASCII字母或数字，如：`'_', '$'` 或是大于 `'\u007F'` 的Unicode字符，用 `_0xxxx` 来替代它们，`xxxx` 是该字符的Unicode值的4个十六进制数序列。
4. 注意：如果你重载 *overload* 本地方法，也就是说用相同的名字提供多个本地方法，那么必须在名称后附加两个下划线，后面再加上已编码的参数类型。后面描述参数类型的编码方法。例如，如果有一个本地方法 `greeting` 和另一个本地方法 `greeting(int repeat)` ，那么第一个称为`Java_HelloNative_greeting__` ，第二个称为 `Java_HelloNative_greeting__I` 。

实际上，**没人会手工完成这些操作**。相反，**应用 `-h` 标志运行 `javac` ，并提供头文件应被放置在的目录**：
```bash
$ javac -h . HelloNative.java
```
这条命令在当前目录中创建了一个名为 `HelloNative.h` 的头文件，如 `helloNative/HelloNative.h` 所示：
```java
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloNative */

#ifndef _Included_HelloNative
#define _Included_HelloNative
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloNative
 * Method:    greeting
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloNative_greeting
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```
如你所见，这个文件包含了函数 `Java_HelloNative_greeting` 的声明（宏 `JNIEXPORT` 和 `JNICALL` 是在头文件 `jni.h` 中定义的，它们为那些「来自动态装载库 *dynamically loaded library* 的导出函数」标明了依赖于编译器的说明符 *compiler-dependent specifiers* ）。

现在，==需要将函数原型从头文件中复制到源文件中，并且给出函数的实现代码==，如 `helloNative/HelloNative.c` 所示。
```java
// helloNative/HelloNative.c
#include <stdio.h>
#include "HelloNative.h"

JNIEXPORT void JNICALL Java_HelloNative_greeting(JNIEnv* env, jclass cl) {
	printf("Hello Native World!\n");
}
```
在这个简单的函数中，我们忽略了 `env` 和 `cl` 参数。后面会看到它们的用处。
> C++注意：可以使用C++实现本地方法。然而，那样必须将「实现本地方法的函数」声明为 `extern "C"`（这可以阻止C++编译器混编 *mangling* 方法名）。例如：
> ```cpp
> extern "C"
> JNIEXPORT void JNICALL Java_HelloNative_greeting(JNIEnv* env, jclass cl) {
> 	cout << "Hello, Native World!" << endl;
> }
> ```

**将本地C代码编译到一个动态装载库中**，具体方法依赖于编译器。例如，Linux下的Gnu C编译器，使用如下命令：
```bash
$ gcc -fPIC -I jdk/include -I jdk/include/linux -shared -o libHelloNative.so HelloNative.c
```
用Windows下的微软编译器，命令是：
```bash
$ cl -I jdk\include -I jdk\include\win32 -LD HelloNative.c -FeHelloNative.dll
```
这里 `jdk` 是含有JDK的目录：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212141629450.png)
> 提示：如果你要从命令shell中使用微软的编译器，首先要运行批处理文件 `vcvars32.net` 或 `vsvars32.bat` 。这个批处理文件设置了编译器需要的路径和环境变量。你可以在目录 `c:\Program Files\Microsoft Visual Studio.14.0\Common7\Tools`（或类似位置）找到该文件，细节查看Visual Studio的文档。

也可使用[自由获取的Cygwin编程环境](http://www.cygwin.com)。它包含了Gnu C编译器和Windows下的UNIX风格编程的库。使用Cygwin时，用以下命令（整个命令应该键入在同一行中）：
```bash
$ gcc -mno-cygwin -D __int64="long long" -I jdk/include/ -I jdk/include/win32 \ 
-shared -Wl,--add-stdcall-alias -o HelloNative.dll HelloNative.c
```
我之前下载Ruby时安装过MSYS2，而且使用的是AdoptOpenJDK\jdk-11.0.11.9-hotspot，用的命令如下所示：
```bash
$ gcc -mno-clwb -D __int64="long long" -I "C:\
Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include" -I "C:\Program Files\
AdoptOpenJDK\jdk-11.0.11.9-hotspot\include\win32" -shared -Wl,--add-stdcall-alias -o HelloNative.dll HelloNative.c
```
编译结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212141644065.png)

> 注意：Windows版本的头文件 `jni_md.h` 含有类型声明 `typedef __int64 jlong;` ——它是专门用于微软编译器的。如果使用的是Gnu编译器，那么你可能需要修改这个文件，例如：
> ```cpp
> #ifdef __GNUC__
> 	typedef long long jlong;
> #else
> 	typedef __int64 jlong;
> #endif
> ```
> 或如编译器调用的示例那样，使用 `-D__int64="long long"` 进行编译。

最后，我们要在程序中添加一个对 `System.loadLibrary` 方法的调用。**为了确保虚拟机在第一次使用该类之前、就会装载这个库，需要使用静态初始化代码块** *static initialization block* ，如 `helloNative/HelloNativeTest.java` 所示。
```java
// helloNative/HelloNativeTest.java
class HelloNativeTest {
	public static void main(String[] args) {
		HelloNative.greeting();
	}

	static {
		System.loadLibrary("HelloNative");
	}
}
```
如果编译并运行该程序，终端窗口会显示消息 `"Hello, Native World!"` 。结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212141648384.png)

> 注意：如果运行在Linux下，必须把当前目录添加到**库路径**中。实现方式可以是设置 `LD_LIBRARY_PATH` 环境变量：
> ```bash
> export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
> ```
> 或设置 `java.library.path` 系统属性：
> ```bash
> java -Djava.library.path=. HelloNativeTest
> ```

当然，这个消息本身并不会给人留下深刻印象。然而，如果你记住这个信息是由C的 `printf` 命令产生、而不是由任何Java代码产生，就会明白：我们已经在连接两种语言上走出了第一步。图12-1给出了对本地代码处理的总结。
![图12-1 处理本地代码](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212140215619.png)

总之，遵循下面的步骤、就可以**将一个本地方法链接到Java程序中**：
1. 在Java类中声明一个本地方法。
2. 运行 `javac -h` 以获得包含该方法的C声明的头文件。
3. 用C实现该本地方法。
4. **将代码置于共享类库中** *shared library* 。
5. **在Java程序中加载该类库**。

> [API] `java.lang.System` 1.0
> - `void loadLibrary(String libname)`
> **装载指定名字的库**，该库位于库搜索路径中。定位该库的确切方法依赖于操作系统。

> 注意：一些本地代码的共享库必须先运行初始化代码。你可以把初始化代码放到 `JNI_OnLoad` 方法中。类似地，如果你提供该方法，当虚拟机关闭时，将会调用 `JNI_OnUnload` 方法。它们的原型是：
> ```c
> jint JNI_OnLoad(JavaVM* vm, void* reserved);
> void JNI_OnUnload(JavaVM* vm, void* reserved);
> ```
> `JNI_OnLoad` 方法要返回它所需的虚拟机的最低版本，例如：`JNI_VERSION_1_2` 。

---
# 12.2 数值参数与返回值
当在C和Java之间传递数字时，应该知道它们彼此之间的对应类型。例如，C也有 `int` 和 `long` 数据类型，但它们的实现却是取决于平台的。在一些平台上，`int` 类型是16位的，在另外一些平台上是32位的。然而，在Java平台上 `int` 类型总是32位的整数。**基于这个原因，Java本地接口定义了 `jint, jlong` 等类型**。表12-1显示了Java数据类型和C数据类型的对应关系。
![表12-1 Java数据类型和C数据类型](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212140228113.png)

在头文件 `jni.h` 中，这些类型被 `typedef` 语句声明为在目标平台上等价的类型。该头文件还定义了常量 `JNI_FALSE=0, JNI_TRUE=1` 。

直到Java 5.0，Java才有了与C语言的 `printf` 函数相类似的方法。在下面的示例中，我们假设你依然坚持使用古老版本的JDK，并且决定通过调用本地方法中的C的 `printf` 函数来实现同样的功能。

`printf1/Printf1.java` 给出了一个名为 `Printf1` 的类，它使用本地方法来打印给定域宽度和精度的浮点数。
```java
// printf1/Printf1.java
class Printf1 {
	public static native int print(int width, int precision, double x);
	static {
		System.loadLibrary("Printf1");
	}
}
```
注意，用C实现该方法时，所有的 `int` 和 `double` 参数都要转换成 `jint` 和  `jdouble` ，如 `printf1/Printf1.c` 所示。
```java
// printf1/Printf1.c
#include <stdio.h>
#include "Printf1.h"

JNIEXPORT jint JNICALL Java_Printf1_print
  (JNIEnv* env, jclass cl, jint width, jint precision, jdouble x) {
	char fmt[30];
	jint ret;
	sprintf(fmt, "%%%d.%df", width, precision);
	ret = printf(fmt, x);
	fflush(stdout);
	return ret;
}
```
该函数只是装配了变量 `fmt` 中的格式字符串 `"%w.pf"` *assembles a format string* ，然后调用 `printf` 函数，接着返回打印出的字符的个数。`printf1/Printf1Test.java` 给出了验证 `Printf1` 类的测试程序。
```java
// printf1/Printf1Test.java
class Printf1Test {
	public static void main(String[] args) {
		int count = Printf1.print(8, 4, 3.14);
		count += Printf1.print(8, 4, count);
		System.out.println();
		for (int i = 0; i < count; ++i)
			System.out.print("-");
		System.out.println();
	}
}
```
运行如下命令，将代码置于共享类库中：
```bash
$ gcc -mno-clwb -D __int64="long long" -I "C:\
Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include" -I "C:\Program Files\
AdoptOpenJDK\jdk-11.0.11.9-hotspot\include\win32" -shared -Wl,--add-stdcall-alias -o Printf1.dll Printf1.c
```
再编译运行 `Printf1Test.java` ：
```bash
$ javac Printf1Test.java
$ java Printf1Test
```
结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212141846400.png)

---
# 24.3 字符串参数
接着考虑怎样把字符串传入、传出本地方法。如你所知，Java语言中的字符串是UTF-16编码点的序列 *sequences of UTF-16 code points* ，而C的字符串则是以 `null` 结尾的字节序列 *null-terminated sequences of bytes* ，所以在这两种语言中的字符串是很不一样的。

Java本地接口有两组操作字符串的函数，一组把Java字符串转换成“改良的UTF-8 *modified UTF-8* ”字节序列，另一组将它们转换成UTF-16值的数组，也就是说转换成 `jchar` 数组。
> UTF-8、“改良的UTF-8”和UTF-16格式都在卷I第12章中讨论过，回忆一下，“改良的UTF-8”编码保持ASCII字符不变，但是其他所有Unicode字符被编码为多字节序列 *leave ASCII characters unchanged, but all other Unicode characters are encoded as multibyte sequences* 。

> 注意：标准UTF-8编码和“改良的UTF-8”编码的差别，仅在于编码大于0xFFFF的增补字符 *"supplementary" characters with codes higher than 0xFFFF* 。在标准UTF-8编码中，这些字符编码为4字节序列；然而，在改良编码中，这些字符首先被编码为一对UTF-16编码的“替代品” *a pair of “surrogates” in the UTF-16 encoding* ，然后再对每个替代品用UTF-8编码，总共产生6字节编码。这有点笨拙，但这是个由历史原因造成的意外，编写Java虚拟机规范的时候Unicode还局限在16位。

==如果你的C代码已经使用了Unicode，你可以使用第二组转换函数==。另一方面，==如果你的字符串都仅限于使用ASCII字符，你可以使用“改良的UTF-8”转换函数==。

带有 `String` 参数的本地方法，实际上都要接受一个 `jstring` 类型的值，而带有 `String` 参数返回值的本地方法，必须返回一个 `jstring` 类型的值。JNI函数将读入并构造出这些 `jstring` 对象。例如，`NewStringUTF` 函数从包含ASCII字符的字符数组、或更一般的“改良的UTF-8”编码的字节序列，创建一个新的 `jstring` 对象。

JNI函数有一个有些古怪的调用惯例。下面是对 `NewStringUTF` 函数的一个调用：
```c
JNIEXPORT jstring JNICALL Java_HelloNative_getGreeting(JNIEnv* env, jclass cl) {
	jstring jstr; 
	char greeting[] = "Hello, Native World\n";
	jstr = (*env)->NewStringUTF(env, greeting);
	return jstr;
}
```
> 注意：这里的所有代码都是C代码，除了指明为别的代码。

**所有对JNI函数的调用，都使用到了 `env` 指针**，该指针是每一个本地方法的第一个参数。**`env` 指针是指向函数指针表的指针**（参见图24-2）。所以，必须在每个JNI调用前面加上 `(*env)->` ，以便实际上解析对函数指针的引用 *dereference the function pointer* 。而且，`env` 是每个JNI函数的第一个参数。
![图24-2 env指针](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212141856914.png)
> C++注意：C++中对JNI函数的访问要简单一些。`JNIEnv` 类的C++版本有一个内联成员函数，它负责帮你查找函数指针。例如，你可以这样调用 `NewStringUTF` 函数：
> ```cpp
> jstr = env->NewStringUTF(greeting);
> ```
> 注意，这里忽略了该调用的参数列表里的 `JNIEnv` 指针。

**`NewStringUTF` 函数可以用来构造一个新的 `jstring` ，而读取现有 `jstring` 对象的内容，需要使用 `GetStringUTFChars` 函数**，该函数返回指向「描述字符串的“改良UTF-8”字符 *the “modified UTF-8” characters that describe the
character string* 」的一个 `const jbyte*` 指针。注意，一个具体的虚拟机可以为「其内部的字符串表示」自由选择编码机制。所以，你可以得到实际的Java字符串的字符指针。**因为Java字符串是不可变的，所以慎重处理 `const` 就显得非常重要，不要试图将数据写到该字符数组中**。另一方面，如果虚拟机使用UTF-16或UTF-32 characters、作为其内部字符串的表示，那么该函数会分配一个新的内存块、该内存块将填充等价的“改良UTF-8”编码字符 *the "modified UTF-8" equivalents* 。

==虚拟机必须知道你何时使用完字符串，这样它就能进行垃圾回收（垃圾回收器是在一个独立线程中运行的，它能够中断本地方法的执行）==。基于这个原因，你必须调用 `ReleaseStringUTFChars` 函数。

另外，可以通过调用 `GetStringRegion` 或 `GetStringUTFRegion` 方法来提供你自己的缓存，以存放字符串的字符。

最后 `GetStringUTFLength` 函数，返回字符串的“改良UTF-8”编码所需的字符个数。
> 注意：[这里](http://docs.oracle.com/javase/7/docs/technotes/guides/jni)可找到JNI API。

> [API] 从C代码访问Java字符串
> - `jstring NewStringUTF(JNIEnv* env, const char bytes[])`
> 根据以全0字节结尾的“改良UTF-8”字节序列，**返回一个新的Java字符串对象**，或当字符串无法构建时，返回NULL。
> - `jstring NewString(JNIEnv* env, const jchar chars[], jsize length)`
> **根据Unicode字符串，返回一个新的Java字符串对象**，或者在不能构建时返回 `NULL` 。`env` 是JNI接口指针，`chars` 是以 `null` 结尾的UTF-16字符串，`length` 是字符串中字符的个数。
> 
> - `jsize GetStringUTFLength(JNIEnv* env, jstring string)`
> 返回进行UTF-8编码所需的字节个数（作为终止符的全0字节不计入内）。
> - `jsize GetStringLength(JNIEnv* env, jstring string)`
> 返回字符串中字符的个数。
> 
> - `const jbyte* GetStringUTFChars(JNIEnv* env, jstring string, jboolean* isCopy)`
> 返回指向字符串的“改良UTF-8”编码的指针，或当不能构建字符数组时返回NULL。直到 `ReleaseStringUTFChars` 函数调用前，该指针一直有效。`isCopy` 指向一个 `jboolean` ，如果进行了复制，则填入 `JNI_TRUE` ，否则填入 `JNI_FALSE` 。
> - `const jchar* GetStringChars(JNIEnv* env, jstring string, jboolean* isCopy)`
> 返回指向字符串的Unicode编码的指针，或当不能构建字符数组时返回 NULL。直到 `ReleaseStringChars` 函数调用前，该指针一直有效。`isCopy` 要么为NULL；要么在进行了复制时，指向用 `JNI_TRUE` 填充的 `jboolean` ，否则指向用 `JNI_FALSE` 填充的 `jboolean` 。
> 
> - `void ReleaseStringUTFChars(JNIEnv* env, jstring string, const jbyte bytes[])`
> **通知虚拟机，本地代码不再需要通过 `bytes`（`GetStringUTFChars` 返回的指针）访问Java字符串**。
> - `void ReleaseStringChars(JNIEnv* env, jstring string, const jchar chars[])`
> 通知虚拟机，本地代码不再需要通过 `chars`（`GetStringChars` 返回的指针）访问Java字符串。
> 
> - `void GetStringRegion(JNIEnv* env, jstring string, jsize start, jsize length, jchar* buffer)`
> 将一个UTF-16双字节序列，从字符串复制到用户提供的尺寸至少大于2×length的缓存中。
> - `void GetStringUTFRegion(JNIEnv* env, jstring string, jsize start, jsize length, jbyte* buffer)`
> 将一个“改良UTF-8”字符序列，从字符串复制到用户提供的缓存中。为了存放要复制的字节，该缓存必须足够长。最坏情况下，要复制3×length个字节。

让我们使用这些函数、来编写一个调用C函数 `sprintf` 的类，我们要像 `printf2/Printf2Test.java` 那样调用函数。
```java
// printf2/Printf2Test.java
class Printf2Test {
	public static void main(String[] args) {
		double price = 44.95;
		double tax = 7.75;
		double amountDue = price * (1 + tax / 100);

		String s = Printf2.sprint("Amount due = %8.2f", amountDue);
		System.out.println(s);
	}
}
```
`printf2/Print2.java` 给出了带有本地 `sprint` 方法的类。因此，格式化浮点数的C函数原型如下：
```java
// printf2/Printf2.java
class Printf2 {
	public static native String sprint(String format, double x);
	static {
		System.loadLibrary("Printf2");
	}
}
```
`printf2/Printf2.c` 给出了C的实现代码。注意，我们通过调用 `GetStringUTFChars` 来读取格式参数，通过调用 `NewStringUTF` 来产生返回值，通过调用 `ReleaseStringUTFChars` 来通知虚拟机不再需要访问该字符串。
```c
#include <string.h>
#include <stdlib.h>
#include <float.h>
#include "Printf2.h"

/**
 * @param format a string containing a printf format specifier
 * (such as "%8.2f"). Substrings "%%" are skipped.
 * @return a pointer to the format specifier (skipping the "%")
 * or NULL if there wasn't a unique format specifier
 */
 char* find_format(const char format[]) {
	char *p;
	char *q;

	p = strchr(format, '%');
	while (p != NULL && *(p + 1) == '%') /* skip %% */
		p = strchr(p + 2, '%');
	if (p == NULL) return NULL;

	/* now check that % is unique */
	p++;
	q = strchr(p, '%');
	while (q != NULL && *(q + 1) == '%') /* skip %% */
		q = strchr(q + 2, '%');
	if (q != NULL) return NULL; /* % not unique */
	q = p + strspn(p, " -0+#"); /* skip past flags */
	q += strspn(q, "0123456789"); /* skip past field width */
	if (*q == '.') { q++; q += strspn(q, "0123456789"); }
		/* skip past precision */
	if (strchr("eEfFgG", *q) == NULL) return NULL;
		/* not a floating-point format */
	return p;
}

JNIEXPORT jstring JNICALL Java_Printf2_sprint(JNIEnv* env, jclass cl, jstring format, jdouble x) {
	const char* cformat;
	char *fmt;
	jstring ret;

	cformat = (*env)->GetStringUTFChars(env, format, NULL);
	fmt = find_format(cformat);
	if (fmt == NULL) ret = format;
	else {
		char* cret;
		int width = atoi(fmt);
		if (width == 0) width = DBL_DIG + 10;
		cret = (char*)malloc(strlen(cformat) + width);
		sprintf(cret, cformat, x);
		ret = (*env)->NewStringUTF(env, cret);
		free(cret);
	}
	(*env)->ReleaseStringUTFChars(env, format, cformat);
	return ret;
}
```
在本函数中，我们选择简化错误处理。如果打印浮点数的格式代码不是 `%w.pc` 形式的（其中 `c` 是 `e, E, f, g, G` 中的一个），那么我们将不对数字进行格式化。后面介绍如何让本地方法抛出异常。

运行如下命令：
```bash
$ javac -h . Printf2.java
$ gcc -mno-clwb -D __int64="long long" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include\win32" -shared -Wl,--add-stdcall-alias -o Printf2.dll Printf2.c
$ javac Printf2Test.java
$ java Printf2Test
```
结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212150308502.png)

---
# 24.4 访问域
目前为止看到的所有本地方法，都是带有数字或字符串参数的静态方法。下面，考虑**在对象上进行操作**的本地方法。作为一个练习，用本地方法实现卷I章4中的 `Employee` 类的一个方法。这通常情况下用不到，但这演示了当你需要时、可以**怎样从本地方法访问对象域**。
## 24.4.1 访问实例域
为了了解怎样从本地方法访问实例域，我们用Java重新实现了 `raiseSalary` 方法。其代码很简单：
```java
public void raiseSalary(double byPercent) {
	salary *= 1 + byPercent / 100;
}
```
重写代码，使其成为一个本地方法。与此前的本地方法不同，它并不是一个静态方法。运行 `javac -h` 给出以下原型：
```c
JNIEXPORT void JNICALL Java_Employee_raiseSalary(JNIEnv *, jobject, jdouble);
```
注意，**第二个参数不再是 `jclass` 类型而是 `jobject` 类型**。实际上，**它和 `this` 引用等价**。**静态方法得到的是类的引用**，而**非静态方法得到的是对隐式的 `this` 参数对象的引用**。

现在，我们访问隐式参数的 `salary` 域。在Java 1.0中“原生的”Java到C的绑定中，这很简单，程序员可以直接访问对象数据域。然而，直接访问要求虚拟机暴露它们的内部数据布局 *direct access requires all virtual machines to expose their internal data layout* 。基于这个原因，**JNI要求程序员通过调用特殊的JNI函数来获取和设置数据的值**。

在例子里，要使用 `GetdoubleField` 和 `SetDoubleField` 函数，因为 `salary` 是 `double` 类型的。对于其他类型，可以使用的函数有：`GetIntField/SetIntField, GetObjectField/SetObjectField` 等等。其通用语法是：
```c
x = (*env)->GetXxxField(env, this_obj, fieldID);
(*env)->SetXxxField(env, this_obj, fieldID, x);
```
这里，`fieldID` 是一个特殊类型 `jfieldID` 的值，`jfieldID` 标识结构中的一个域，而 `Xxx` 代表Java数据类型（ `Object, Boolean, Byte` 或其他）。**为了获得 `fieldID` ，必须先获得一个表示类 *class* 的值**，有两种方法可以实现此目的。`GetObjectClass` 函数可以返回任意对象的类。例如：
```c
jclass class_Employee = (*env)->GetObjectClass(env, this_obj);
```
`FindClass` 函数可以让你以字符串形式来指定类名（有点奇怪的是，要以 `/` 代替句号作为包名之间的分隔符）。
```c
jclass class_String = (*env)->FindClass(env, "java/lang/String");
```
之后，可以**使用 `GetFieldID` 函数来获得 `fieldID`** 。必须提供域的名字、它的签名以及它的类型的编码。例如，下面是从 `salary` 域得到域ID的代码：
```java
jfieldID id_salary = (*env)->GetFieldID(env, class_Employee, "salary", "D");
```
字符串"D"表示类型是 `double` 。下一节中学习到编码签名的全部规则。

可能会认为访问数据域相当令人费解。JNI的设计者不想把数据域直接暴露在外，所以他们不得不提供**获取和设置数据域值的函数**。==为了使这些函数的开销最小化，从域名计算域ID（代价最大的一个步骤）被分解出来作为单独的一步操作==。也就是说，==如果你反复地获取和设置一个特定的域，你计算域标识符的开销就只有一次==（ID就是域标识符）。

让我们把各部分汇总起来，下面的代码以本地方法形式重新实现了 `raiseSalary` 方法。
```c
JNIEXPORT void JNICALL Java_Employee_raiseSalary(JNIEnv* env, jobject this_obj, jdouble byPercent) {
	/* get the class */
	jclass class_Employee = (*env)->GetObjectClass(env, this_obj);
	/* get the field ID */
	jfieldID id_salary = (*env)->GetFieldID(env, class_Employee, "salary", "D");
	/* get the field value */
	jdouble salary = (*env)->GetDoubleField(env, this_obj, id_salary);
	salary *= 1 + byPercent / 100;
	/* set the field value */
	(*env)->SetDoubleField(env, this_obj, id_salary, salary);
}
```
> 警告：**类引用只在本地方法返回之前有效**。因此，不能在你的代码中缓存 `GetObjectClass` 的返回值。不要将类引用保存下来、以供以后的方法调用重复使用。必须在每次执行本地方法时，都调用 `GetObjectClass` 。如果你无法忍受这一点，必须调用 `NewGlobalRef` 来锁定该引用：
> ```java
> static jclass class_X = 0;
> static jfieldID id_a;
> ...
> if (class_X == 0) {
> 	jclass cx = (*env)->GetObjectClass(env, obj);
> 	class_X = (*env)->NewGlobalRef(env, cx);
> 	id_a = (*env)->GetFieldID(env, cls, "a", "...");
> }
> ```
> 现在，你可以在后面的调用中使用类引用和域ID了。当你结束对类的使用时，务必调用：`(*env)->DeleteGlobalRef(env, class_X);` 。

程序清单12-11和12-12给出了测试程序和Employee类的Java代码。程序清单12-13包含了本地raiseSalary方法的C代码。
```java
// employee/EmployeeTest.java
public class EmployeeTest {
	public static void main(String[] args) {
		var staff = new Employee[3];
		staff[0] = new Employee("Harry Hacker", 35000);
		staff[1] = new Employee("Carl Cracker", 75000);
		staff[2] = new Employee("Tony Tester", 38000);
		for (Employee e : staff) e.raiseSalary(5);
		for (Employee e : staff) e.print();
	}
}
```
```java
// employee/Employee.java
public class Employee {
	private String name;
	private double salary;
	public native void raiseSalary(double byPercent);
	public Employee(String n, double s) {
		name = n;
		salary = s;
	}
	public void print() {
		System.out.println(name + " " + salary);
	}
	static {
		System.loadLibrary("Employee");
	}
}
```
```c
// employee/Employee.c
#include <stdio.h>
#include "Employee.h"

JNIEXPORT void JNICALL Java_Employee_raiseSalary
  (JNIEnv *env, jobject this_obj, jdouble byPercent) {
	 /* get the class */
	 jclass class_Employee = (*env)->GetObjectClass(env, this_obj);
	 /* get the field ID */
	 jfieldID id_salary = (*env)->GetFieldID(env, class_Employee, "salary", "D");
	 /* get the field value */
	 jdouble salary = (*env)->GetDoubleField(env, this_obj, id_salary);
	 salary *= 1 + byPercent / 100;
	 /*set the field value */
	(*env)->SetDoubleField(env, this_obj, id_salary, salary);	  
}
```
运行如下命令：
```bash
$ javac -h . Employee.java
$ gcc -mno-clwb -D __int64="long long" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include\win32" -shared -Wl,--add-stdcall-alias -o Employee.dll Employee.c
$ javac EmployeeTest.java
$ java EmployeeTest
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212151510868.png)

## 24.4.2 访问静态域
访问静态域和访问非静态域类似。你要使用 `GetStaticFieldID` 和 `GetStaticXxxField/SetStaticXxxField` 函数。它们几乎与非静态的情形一样，只有两个区别：
- 由于没有对象，**必须使用 `FindClass` 代替 `GetObjectClass` 来获得类引用**。
- **访问域时，要提供类而非实例对象**。

例如，下面给出的是怎样得到一个 `System.out` 的引用的代码：
```c
/* get the class */
jclass class_System = (*env)->FindClass(env, "java/lang/System");
/* get the field ID */
jfieldID id_out = (*env)->GetStaticFieldID(env, class_System, "out", "Ljava/io/PrintStream;"); 
/* get the field value */
jobject obj_out = (*env)->GetStaticObjectField(env, class_System, id_out);
```
> [API] 访问实例域
> - `jfieldID GetFieldID(JNIEnv* env, jclass cl, const char name[], const char fieldSignature[])`
> 返回类中一个域的标识符。
> - `Xxx GetXxxField(JNIEnv* env, jobject obj, jfieldID id)`
> 返回域的值。域类型 `Xxx` 是 `Object, Boolean, Byte, Char, Short, Int, Long, Float, Double` 之一。
> - `void SetXxxField(JNIEnv* env, jobject obj, jfieldID id, Xxx value)`
> 把某个域设置为一个新值。域类型 `Xxx` 是 `Object, Boolean, Byte, Char, Short, Int, Long, Float, Double` 之一。
> 
> - `jfieldID GetStaticFieldID(JNIEnv* env, jclass cl, const char name[], const char fieldsignature[])`
> 返回某类型的一个静态域的标识符。
> - `Xxx GetStaticXxxField(JNIEnv* env, jclass cl, jfieldID id)`
> 返回某静态域的值。域类型 `Xxx` 是 `Object, Boolean, Byte, Char, Short, Int, Long, Float, Double` 之一。
> - `void SetStaticXxxField(JNIEnv* env, jclass cl, jfieldID id, Xxx value)`
> 把某个静态域设置为一个新值。域类型 `Xxx` 是 `Object, Boolean, Byte, Char, Short, Int, Long, Float, Double` 之一。

---
# 24.5 编码签名
为了**访问实例域**和**调用「用Java语言定义的方法」**，你必须学习**将数据类型的名称和方法签名进行“混编”的规则**（方法签名描述了参数和该方法返回值的类型）。下面是（数据类型的）编码方案：
```java
B           byte
C           char
D           double
F           float
I           int
J           long
Lclassname; a class type
S           short
V           void
Z           boolean
```
为了描述数组类型，要使用 `[` 。例如，一个字符串数组如下：
```java
[Ljava/lang/String;
```
一个 `float[][]` 可以描述为：
```java
[[F
```

**要建立一个方法的完整签名，需要把括号内的参数类型** *parameter types*（不是参数化的类型）**都列出来，然后列出返回值类型**。例如，一个接收两个整型参数、并返回一个整数的方法编码为：
```java
(II)I
```
24.3节中 `Sprintf` 方法有下面的混编签名，即接收一个 `String` 和一个 `double` ，返回值是一个 `String` ：
```java
(Ljava/lang/String;D)Ljava/lang/String;
```
注意，**在 `L` 表达式结尾处的分号是类型表达式的终止符，而不是参数之间的分隔符**。例如，构造器：
```java
Employee(java.lang.String, double, java.util.Date)
```
具有如下签名：
```java
(Ljava/lang/String;DLjava/util/Date;)V
```
注意，在 `D` 和 `Ljava/util/Date;` 之间没有分隔符。

另外要注意，在这个编码方案中，必须用 `/` 代替 `.` 来分隔包和类名。结尾的 `V` 表示返回类型为 `void` 。即使Java的构造器没有指定返回类型，也需要将 `V` 添加到虚拟机签名中。

注意，**可以使用带有选项 `-s` 的 `javap` 命令、来从类文件中产生方法签名**。例如，运行：
```bash
$ javap -s -private Employee
Compiled from "Employee.java"
public class Employee extends java.lang.Object{
private java.lang.String name;
  Signature: Ljava/lang/String;
private double salary;
  Signature: D
public Employee(java.lang.String, double);
  Signature: (Ljava/lang/String;D)V
public native void raiseSalary(double);
  Signature: (D)V
public void print();
  Signature: ()V
static {};
  Signature: ()V
}
```
> 注意：没有任何理由强迫程序员使用这种混编方案来描述签名。本地调用机制的设计者可以非常容易地编写一个函数、来读取Java编程语言风格的签名，比如 `void(int, java.lang.String)` ，并且将它们编码为他们喜欢的某种内部表示法。再者，使用混编签名使你能够体验接近虚拟机的编程奥秘 *using the mangled signatures lets you partake in the mystique of programming close to the virtual machine*。

---
# 24.6 调用Java方法
当然，**Java语言的函数可以调用C函数**，这正是本地方法要做的。我们能不能换一种方式呢？为什么我们要这么做？答案是，本地方法常需要从「传递给它的对象」那里得到某种服务。首先介绍非静态方法如何进行这种操作，然后介绍静态方法如何进行这种操作。
## 24.6.1 实例方法
作为**从本地代码调用Java方法**的一个例子，先增强 `Printf` 类，给它增加一个与C函数 `fprintf` 类似的方法。也就是说，它能够在任意 `PrintWriter` 对象上打印一个字符串。下面是用Java编写的该方法的定义：
```java
class Printf3 {
	public native static void fprint(PrintWriter out, String s, double x);
	...
}
```
首先把要打印的字符串组装成一个 `String` 对象 `str` ，就像在 `sprint` 方法中已经实现的那样。然后，我们从实现本地方法的C函数中调用 `PrintWriter` 类的 `print` 方法。

使用如下函数调用，你可以从C中调用任何Java方法：
```java
(*env)->CallXxxMethod(env, implicit parameter, methodID, explicit parameters)
```
根据方法的返回类型，用 `Void, Int, Object` 等来替换 `Xxx` 。就像需要一个 `fieldID` 来访问某个对象的一个域一样，也需要一个方法的ID来调用方法。**可以通过调用JNI函数 `GetMethodID` ，并且提供该类、方法的名字和方法签名来获得方法ID**。

在例子中，我们想要获得 `PrintWriter` 类的 `print` 方法的ID。如在卷I章12中看到的，`PrintWriter` 类有几个名为 `print` 的重载方法。==基于这个原因，还必须提供一个字符串，描述你想要使用的特定函数的参数和返回值==。例如，想要使用 `void print(java.lang.String)` ，正如前一节讲到的那样，我们必须把签名“混编”为字符串 `(Ljava/lang/String;)V` 。

下面是进行方法调用的完整代码，有以下几个步骤：
1. 获取隐式参数的类。
2. 获取方法ID。
3. 进行调用。

```java
/* get the class */
class_PrintWriter = (*env)->GetObjectClass(env, out);
/* get the method ID */
id_print = (*env)->GetMethodID(env, class_PrintWriter, "print", "(Ljava/lang/String;)V");
/* call the method */
(*env)->CallVoidMethod(env, out, id_print, str);
```

`printf3/Printf3Test.java` 和 `printf3/Printf3.java` 给出了测试程序和 `Printf3` 类的Java代码。`printf3/Printf3.c` 包含了本地 `fprintf` 方法的C代码。
> 注意：数值型的方法ID和域ID，在概念上和反射API中的 `Method` 和 `Field` 对象相似。可以使用以下函数在两者间进行转换：
> ```c
> jobject ToReflectedMethod(JNIEnv* env, jclass class, jmethodID methodID);
> 	// returns Method object
> methodID FromReflectedMethod(JNIEnv* env, jobject method);
> 
> jobject ToReflectedField(JNIEnv* env, jclass class, jfieldID fieldID);
> 	// returns Field object
> fieldID FromReflectedField(JNIEnv* env, jobject field);
> ```

```java
// printf3/Printf3Test.java
import java.io.*;

class Print3Test {
	public static void main(String[] args) {
		double price = 44.95;
		double tax = 7.75;
		double amountDue = price * (1 + tax / 100);
		var out = new PrintWriter(System.out);
		Printf3.fprint(out, "Amount due = %8.2f\n", amountDue);
		out.flush();
	}
}
```
```java
// printf3/Printf3.java
import java.io.*;
class Printf3 {
	public static native void fprint(PrintWriter out, String format, double x);
	static {
		System.loadLibrary("Printf3");
	}
}
```
```c
// printf3/Printf3.c
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include "Printf3.h"

/**
 * @param format a string containing a printf format specifier
 * (such as "%8.2f"). Substrings "%%" are skipped.
 * @return a pointer to the format specifier (skipping the "%")
 * or NULL if there wasn't a unique format specifier
 */
 char* find_format(const char format[]) {
	char *p;
	char *q;

	p = strchr(format, '%');
	while (p != NULL && *(p + 1) == '%') /* skip %% */
		p = strchr(p + 2, '%');
	if (p == NULL) return NULL;

	/* now check that % is unique */
	p++;
	q = strchr(p, '%');
	while (q != NULL && *(q + 1) == '%') /* skip %% */
		q = strchr(q + 2, '%');
	if (q != NULL) return NULL; /* % not unique */
	q = p + strspn(p, " -0+#"); /* skip past flags */
	q += strspn(q, "0123456789"); /* skip past field width */
	if (*q == '.') { q++; q += strspn(q, "0123456789"); }
		/* skip past precision */
	if (strchr("eEfFgG", *q) == NULL) return NULL;
		/* not a floating-point format */
	return p;
}

JNIEXPORT void JNICALL Java_Printf3_fprint
  (JNIEnv *env, jclass cl, jobject out, jstring format, jdouble x) {
	const char* cformat;
	char* fmt;
	jstring str;
	jclass class_PrintWriter;
	jmethodID id_print;

	cformat = (*env)->GetStringUTFChars(env, format, NULL);
	fmt = find_format(cformat);
	if (fmt == NULL) str = format;
	else {
		char* cstr;
		int width = atoi(fmt);
		if (width == 0) width = DBL_DIG + 10;
		cstr = (char*)malloc(strlen(cformat) + width);
		sprintf(cstr, cformat, x);
		str = (*env)->NewStringUTF(env, cstr);
		free(cstr);
	}
	(*env)->ReleaseStringUTFChars(env, format, cformat);

	/* now call ps.print(str) */
	/* get the class */
	class_PrintWriter = (*env)->GetObjectClass(env, out);
	/* get the method ID */
	id_print = (*env)->GetMethodID(env, class_PrintWriter, "print", "(Ljava/lang/String;)V");
	/* call the method */
	(*env)->CallVoidMethod(env, out, id_print, str);
}
```
运行如下命令：
```bash
$ javac -h . Printf3.java
$ gcc -mno-clwb -D __int64="long long" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include\win32" -shared -Wl,--add-stdcall-alias -o Printf3.dll  Printf3.c
$ javac Printf3Test.java
$ java Printf3Test
```
结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212151811345.png)

## 24.6.2 静态方法
从本地方法调用静态方法与调用非静态方法类似。两者的差别是：
- 要用 `GetStaticMethodID` 和 `CallStaticXxxMethod` 函数。
- **当调用方法时，要提供类对象，而不是隐式的参数对象**。

作为一个例子，让我们从本地方法调用以下静态方法，这个调用的返回值是给出了当前类路径的字符串：
```java
System.getProperty("java.class.path")
```
首先，我们必须找到要用的类。因为我们没有 `System` 类的对象可供使用，所以我们使用 `FindClass` 而非 `GetObjectClass` ：
```c
jclass class_System = (*env)->FindClass(env, "java/lang/System");
```
接着，我们需要静态 `getProperty` 方法的ID。该方法的编码签名是：
```java
"(Ljava/lang/String;)Ljava/lang/String;"
```
既然参数和返回值都是字符串。因此，我们这样获取方法ID：
```c
jmethodID id_getProperty = (*env)->GetStaticMethodID(env, class_System, "getProperty", "(Ljava/lang/String;)Ljava/lang/String;");
```
最后，我们进行调用。注意，类对象被传递给了 `CallStaticObjectMethod` 函数，该方法的返回值是 `jobject` 类型的：
```c
jobject obj_ret = (*env)->CallStaticObjectMethod(env, class_System, id_getProperty, (*env)->NewStringUTF(env, "java.class.path"));
```
如果我们想要把它当作字符串操作，必须把它转型为 `jstring` ：
```c
jstring str_ret = (jstring) obj_ret;
```
> C++注意：在C中，`jstring` 和 `jclass` 类型同后面将要介绍的数组类型一样，都是与 `jobject` 等价的类型 *type-equivalent* 。因此，在C语言中，前面例子中的转型并不是严格必需的。
> 
> 但在C++中，这些类型被定义为指向拥有正确继承层次关系的“哑类”的指针 *pointers to “dummy classes” that have the correct inheritance hierarchy*。例如，将一个 `jstring` 不经过转型便赋给 `jobject` 、在C++中是合法的，但将 `jobject` 赋给 `jstring` 必须先转型。

## 24.6.3 构造器
本地方法可以通过调用构造器来创建新的Java对象。可以调用 `NewObject` 函
数来调用构造器：
```c
jobject obj_new = (*env)->NewObject(env, class, methodID, construction parameters);
```
可以通过**指定方法名为 `"<init>"`** ，并**指定构造器（返回值为 `void` ）的编码签名**，从 `GetMethodID` 函数中获取该调用必需的方法ID。例如，下面是本地方法创建 `FileOutputStream` 对象的情形：
```java
const char[] fileName = "...";
jstring str_fileName = (*env)->NewStringUTF(env, fileName);
jclass class_FileOutputStream = (*env)->FindClass(env, 
	"java/io/FileOutputStream");
jmethodID id_FileOutputStream
	= (*env)->GetMethodID(env, class_FileOutputStream, "<init>", "(Ljava/lang/String;)V");

jobject obj_stream = (*env)->NewObject(env, class_FileOutputStream, id_FileOutputStream, str_filename);
```
注意，构造器的签名接受一个 `java.lang.String` 类型的参数，返回类型为 `void` 。
## 12.6.4　替代方法调用
有若干种JNI函数的变体，都可以从本地代码调用Java方法。它们没有我们已讨论过的那些函数那么重要，但偶尔也会很有用。

`CallNonvirtualXxxMethod` 函数接收一个隐式参数、一个方法ID、一个类对象（必须对应于隐式参数的超类）和一个显式参数。这个函数将调用指定的类中的指定版本的方法，而不使用常规的动态调度机制。

所有调用函数都有后缀"A"和"V"的版本，用于接收数组中或 `va_list` 中的显式参数（就像在C头文件中所定义的那样）。
> 执行Java方法：
> - `jmethodID GetMethodID(JNIEnv* env, jclass cl, const char name[], const char methodSignature[])`
> 返回类中某个方法的标识符。
> - `Xxx CallXxxMethod(JNIEnv* env, jobject obj, jmethodID id, args)`
> - `Xxx CallXxxMethodA(JNIEnv* env, jobject obj, jmethodID id, jvalue args[])`
> - `Xxx CallXxxMethodV(JNIEnv* env, jobject obj, jmethodID id, va_list args)`
> 调用一个方法。返回类型 `Xxx` 是 `Object, Boolean, Byte, Char, Short, Int, Long, Float, Double` 之一。第一个函数有可变数量参数，只要把方法参数附加到方法ID之后即可。第二个函数接受 `jvalue` 数组中的方法参数，其中 `jvalue` 是一个联合体 *union* ，定义如下：
>    ```c
> typedef union jvalue {
> 	jboolean z;
> 	jbyte b;
> 	jchar c;
> 	jshort s;
> 	jint i;
> 	jlong j;
> 	jfloat f;
> 	jdouble d;
> 	jobject l;
> } jvalue;
>    ```
> 第三个函数接收（C头文件 `stdarg.h` 中定义的）在一个 `va_list` 中的方法参数。
> 
> - `Xxx CallNonvirtualXxxMethod(JNIEnv* env, jobject obj, jclass cl, jmethodID id, args)`
> - `Xxx CallNonvirtualXxxMethodA(JNIEnv* env, jobject obj, jclass cl, jmethodID id, jvalue args[])`
> - `Xxx CallNonvirtualXxxMethodV(JNIEnv* env, jobject obj, jclass cl, jmethodID id, va_list args)`
> 调用一个方法，并绕过动态调度。返回类型 `Xxx` 是 `Object, Boolean, Byte, Char, Short, Int, Long, Float, Double` 之一。第一个函数有可变数量参数，只要把方法参数附加到方法ID之后即可。第二个函数接受 `jvalue` 数组中的方法参数。第三个函数接受（C头文件 `stdarg.h` 中定义的）`va_list` 中的方法参数。
> 
> - `jmethodID GetStaticMethodID(JNIEnv* env, jclass cl, const char name[], const char methodsignature[])`
> 返回类的某个静态方法的标识符。
> - `Xxx CallStaticXxxMethod(JNIEnv* env, jclass cl, jmethodID id, args)`
> - `Xxx CallStaticXxxMethodA(JNIEnv* env, jclass cl, jmethodID id, jvalue args[])`
> - `Xxx CallStaticXxxMethodV(JNIEnv* env, jclass cl, jmethodID id, va_list args)`
> 调用一个静态方法。返回类型 `Xxx` 是 `Object, Boolean, Byte, Char, Short, Int, Long, Float, Double` 之一。第一个函数有可变数量参数，只要把方法参数附加到方法ID之后即可。第二个函数接受 `jvalue` 数组中的方法参数。第三个函数接受（C头文件 `stdarg.h` 中定义的）`va_list` 中的方法参数。
> 
> - `jobject NewObject(JNIEnv* env, jclass cl, jmethodID id, args)`
> - `jobject NewObjectA(JNIEnv* env, jclass cl, jmethodID id, jvalue args[])`
> - `jobject NewObjectV(JNIEnv* env, jclass cl, jmethodID id, va_list args)`
> 调用构造器。函数ID从`GetMethodID` 获取——方法名为 `"<init>"` 、返回类型为 `void` 。第一个函数有可变数量参数，只要把方法参数附加到方法ID之后即可。第二个函数接收 `jvalue` 数组中的方法参数。第三个函数接收（C头文件 `stdarg.h` 中定义的）`va_list` 中的方法参数。

---
# 24.7 访问数组元素
Java的所有数组类型都有相对应的C语言类型，见表24-2。
![表24-2 Java数组类型和C数组类型之间的对应关系](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212151905060.png)
> C++注意：在C中，所有这些数组类型实际上都是 `jobject` 的同义类型。然而，在C++中它们被安排在如图24-3所示的继承层次结构中。`jarray` 类型表示一个通用数组。
> ![图24-3 数组类型的继承层次结构](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212151907696.png)

`GetArrayLength` 函数返回数组的长度：
```c
jarray array = ...; 
jsize length = (*env)->GetArrayLength(env, array);
```
怎样访问数组元素，取决于数组中存储的是对象还是基本类型的数据（如 `bool, char` 或数值类型）。可以通过 `GetObjectArrayElement` 和 `SetObjectArrayElement` 方法访问对象数组的元素。
```c
jobjectArray array = ...;
int i, j;
jobject x = (*env)->GetObjectArrayElement(env, array, i);
(*env)->SetObjectArrayElement(env, array, j, x);
```
这个方法虽然简单，但是效率明显低下，当你想要直接访问数组元素，特别是在进行向量或矩阵计算时更是如此。

`GetXxxArrayElements` 函数返回一个指向数组起始元素的C指针。与普通的字符串一样，当你不再需要该指针时，必须记得要调用 `ReleaseXxxArrayElements` 函数通知虚拟机。**这里类型 `Xxx` 必须是基本类型**，也就是说不能是 `Object` 。这样就可以直接读写数组元素了。另一方面，由于指针可能会指向一个副本，只有调用相应的 `ReleaseXxxArrayElements` 函数时，你所做的改变才能保证在源数组里得到反映。
> 注意：通过把一个指向 `jboolean` 变量的指针作为第三个参数、传递给 `GetXxxArrayElements` 方法，就可以发现一个数组是否是副本了。如果是副本，则该变量被 `JNI_TRUE` 填充。如果你对这个信息不感兴趣，传一个空指针即可。

下面是对 `double` 类型数组中的所有元素乘以一个常量的示例代码。我们获取一个Java数组的C指针 `a` ，并用 `a[i]` 访问各个元素。
```c
jdoubleArray array_a = ...;
double scaleFactor = ...;
double* a = (*env)->GetDoubleArrayElements(env, array_a, NULL);
for (i = 0; i < (*env)->GetArrayLength(env, array_a); i++)
	a[i] = a[i] * scaleFactor;
(*env)->ReleaseDoubleArrayElements(env, array_a, a, 0);
```
虚拟机是否确实需要对数组进行拷贝，取决于它是如何分配数组和进行垃圾回收的。有些“拷贝”型的垃圾回收器例行地移动对象，并更新对象引用。该策略与将数组锁定在特定位置 *"pinning" an array to a particular location* 是不兼容的，因为回收器不能更新本地代码中的指针值。
> 注意：Oracle公司的JVM实现中，`boolean` 数组是用包装的32位的字数组表示的。`GetBooleanArrayElements` 方法能将它们复制到拆包的 `jboolean` 值的数组中。

如果要访问一个大数组的多个元素，可以用 `GetXxxArrayRegion` 和 `SetXxxArrayRegion` 方法，它能把一定范围内的元素，从Java数组复制到C数组中或从C数组复制到Java数组中。

可以用 `NewXxxArray` 函数在本地方法中创建新的Java数组。要创建新的对象数组，需要指定长度、数组元素的类型和所有元素的初始值（典型的是NULL）。下面是一个例子。
```c
jclass class_Employee = (*env)->FindClass(env, "Employee");
jobjectArray array_e = (*env)->NewObjectArray(env, 100, class_Employee, NULL);
```
基本类型的数组要简单一些。只需提供数组长度。该数组被0填充。
```java
jdoubleArray array_d = (*env)->NewDoubleArray(env, 100);
```
注意：下面的方法用来操作“直接缓存”：
```java
jobject NewDirectByteBuffer(JNIEnv* env, void* address, jlong capacity)
void* GetDirectBufferAddress(JNIEnv* env, jobject buf)
jlong GetDirectBufferCapacity(JNIEnv* env, jobject buf)
```
`java.nio` 包中使用了直接缓存、来支持更高效的输入输出操作，并**尽可能减少本地和Java数组之间的复制操作**。

> 操作Java数组
> - `jsize GetArrayLength(JNIEnv* env, jarray array)`
> 返回数组中的元素个数。
> - `jobject GetObjectArrayElement(JNIEnv* env, jobjectArray array, jsize index)`
> 返回数组元素的值。
> - `void SetObjectArrayElement(JNIEnv* env, jobjectArray array, jsize index, jobject value)`
> 将数组元素设为新值。
> - `Xxx* GetXxxArrayElements(JNIEnv* env, jarray arraym jboolean* isCopy)`
> 产生一个指向Java数组元素的C指针。域类型 `Xxx` 是 `Boolean, Byte, Char, Short, Int, Long, Float, Double` 之一。指针不再使用时，该指针必须传递给 `ReleaseXxxArrayElements` 。`iscopy` 可能是NULL，或者在进行了复制时，指向用 `JNI_TRUE` 填充的 `jboolean` ；否则，指向用 `JNI_FALSE` 填充的 `jboolean` 。
> - `void ReleaseXxxArrayElements(JNIEnv* env, jarray array, Xxx elems[], jint mode)`
> 通知虚拟机通过 `GetXxxArrayElements` 获得的一个指针已经不再需要了。 `Mode` 是0（更新数组元素后释放 `elems` 缓存）、`JNI_COMMIT`（更新数组元素后不释放 `elems` 缓存）或 `JNI_ABORT`（不更新数组元素便释放 `elems` 缓存）之一。
> - `void GetXxxArrayRegion(JNIEnv* env, jarray array, jint start, jint length, Xxx elems[])`
> 将Java数组的元素复制到C数组中。域类型 `Xxx` 是 `Boolean, Byte, Char, Short, Int, Long, Float, Double` 之一。
> - `void SetXxxArrayRegion(JNIEnv* env, jarray array, jint start, jint length, Xxx elems[])`
> 将C数组的元素复制到Java数组中。域类型 `Xxx` 是 `Boolean, Byte, Char, Short, Int, Long, Float, Double` 之一。

---
# 12.8　错误处理
==在Java语言中，使用本地方法对于程序来说是要冒很大的安全风险的==。C的运行期系统对数组越界错误、不良指针造成的间接错误等，不提供任何防护。所以，==对于本地方法的程序员来说，处理所有的出错状况、以保持Java平台的完整性显得格外重要==。尤其是，当你的本地方法诊断出一个它无法解决的问题时，那么它应该将此问题报告给Java虚拟机。然后，在这种情况下，很自然地会抛出一个异常。然而C语言没有异常，必须调用 `Throw` 或 `ThrowNew` 函数来创建一个新的异常对象。**当本地方法退出时，Java虚拟机就会抛出该异常**。

要使用 `Throw` 函数，需要调用 `NewObject` 来创建一个 `Throwable` 子类的对象。例如，下面我们分配了一个 `EOFException` 对象，然后将它抛出。
```java
jclass class_EOFException = (*env)->FindClass(env, "java/io/EOFException");
jmethodID id_EOFException = (*env)->GetMethodID(env, class_EOFException, "<init>", "()V");
	/* ID of no-argument constructor */
jthrowable obj_exc = (*env)->NewObject(env, class_EOFException, id_EOFException);
(*env)->Throw(env, obj_exc);
```
通常调用 `ThrowNew` 会更加方便，因为只需提供一个类和一个“改良UTF-8”字节序列，该函数就会构建一个异常对象。
```java
(*env)->ThrowNew(env, (*env)->FindClass(env, "java/io/EOFException"));
```
`Throw` 和 `ThrowNew` 都仅仅只是发布异常，它们不会中断本地方法的控制流。只有当该方法返回时，Java虚拟机才会抛出异常。所以，**每一个对 `Throw` 和 `ThrowNew` 的调用语句之后、总是紧跟着 `return` 语句**。
> C++注意：如果用C++实现本地方法，那么就无法用你的C++代码抛出Java异常。在C++绑定中，是可以实现一个在C++异常和Java异常之间的转换的。然而，到目前为止还没有实现这个功能。需要在本地方法中使用 `Throw` 或 `ThrowNew` 函数来抛出Java异常，并且要确保你的本地方法不抛出C++异常。

通常，本地代码不需要考虑捕获Java异常。但当本地方法调用Java方法时，该方法可能会抛出异常。而且，一些JNI函数也会抛出异常。例如，如果索引越界，`SetObjectArrayElement` 方法会抛出一个 `ArrayIndexOutOfBoundsException` 异常，如果所存储的对象的类不是数组元素类的子类，该方法会抛出一个 `ArrayStoreException` 异常。在这类情况下，本地方法应该调用 `ExceptionOccurred` 方法来确认是否有异常抛出。如果没有任何异常等待处理，则下面的调用：
```c
jthrowable obj_exc = (*env)->ExceptionOccurred(env);
```
将返回NULL。否则，返回一个当前异常对象的引用。如果只要检查是否有异常抛出，而不需要获得异常对象的引用，那么应使用：
```c
jboolean occurred = (*env)->ExceptionCheck(env);
```
==通常有异常出现时，本地方法应该直接返回。那样虚拟机就会将该异常传送给Java代码==。但本地方法也可以分析异常对象，确定它是否能够处理该异常。如果能够处理，那么下面的函数必须被调用、来关闭该异常：
```c
(*env)->ExceptionClear(env);
```

在例子中实现了 `fprint` 本地方法，这是基于「该方法适合编写为本地方法」的假设而实现的。下面是我们抛出的异常：
- 如果格式字符串是NULL，则抛出 `NullPointerException` 异常。
- 如果格式字符串不含适合打印 `double` 所需的 `%` 说明符，则抛出 `IllegalArgumentException` 异常。
- 如果调用 `malloc` 失败，则抛出 `OutOfMemoryError` 异常。

最后，为了说明**本地方法调用Java方法**时怎样检查异常，我们将一个字符串发送给数据流，一次一个字符，并且在每次调用Java方法后调用 `ExceptionOccurred` 。`printf4/Printf4.c` 给出了本地方法的代码； `printf4/Printf4.java` 展示了含有本地方法的类的定义。
**注意，在调用 `PrintWriter.print` 出现异常时，本地方法并不会立即终止执行，它会首先释放 `cstr` 缓存。当本地方法返回时，虚拟机再次抛出异常**。测试程序 `printf4/Printf4Test.java` 说明了当格式字符串无效时，本地方法是如何抛出异常的。
```c
// printf4/Printf4.c
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include "Printf4.h"

/**
 * @param format a string containing a printf format specifier
 * (such as "%8.2f"). Substrings "%%" are skipped.
 * @return a pointer to the format specifier (skipping the "%")
 * or NULL if there wasn't a unique format specifier
 */
 char* find_format(const char format[]) {
	char *p;
	char *q;

	p = strchr(format, '%');
	while (p != NULL && *(p + 1) == '%') /* skip %% */
		p = strchr(p + 2, '%');
	if (p == NULL) return NULL;

	/* now check that % is unique */
	p++;
	q = strchr(p, '%');
	while (q != NULL && *(q + 1) == '%') /* skip %% */
		q = strchr(q + 2, '%');
	if (q != NULL) return NULL; /* % not unique */
	q = p + strspn(p, " -0+#"); /* skip past flags */
	q += strspn(q, "0123456789"); /* skip past field width */
	if (*q == '.') { q++; q += strspn(q, "0123456789"); }
		/* skip past precision */
	if (strchr("eEfFgG", *q) == NULL) return NULL;
		/* not a floating-point format */
	return p;
}

JNIEXPORT void JNICALL Java_Printf4_fprint
  (JNIEnv *env, jclass cl, jobject out, jstring format, jdouble x) {
	const char* cformat;
	char* fmt;
	char* cstr; 
	jclass class_PrintWriter;
	jmethodID id_print;
	int width;
	int i;

	if (format == NULL) {
		(*env)->ThrowNew(env,
			(*env)->FindClass(env, "java/lang/NullPointerException"), 
				"Printf4.fprint: format is null");
		return;
	}

	cformat = (*env)->GetStringUTFChars(env, format, NULL);
	fmt = find_format(cformat);
	if (fmt == NULL) {
		(*env)->ThrowNew(env,
			(*env)->FindClass(env, "java/lang/IllegalArgumentException"), 
				"Printf4.fprint: format is invalid");
		return;
	} 
	width = atoi(fmt);
	if (width == 0) width = DBL_DIG + 10;
	cstr = (char*)malloc(strlen(cformat) + width);
	if (cstr == NULL) {
		(*env)->ThrowNew(env,
			(*env)->FindClass(env, "java/lang/OutOfMemoryError"), 
				"Printf4.fprint: malloc failed");
		return;
	}

	sprintf(cstr, cformat, x);
	(*env)->ReleaseStringUTFChars(env, format, cformat);

	/* now call ps.print(str) */
	/* get the class */
	class_PrintWriter = (*env)->GetObjectClass(env, out);
	/* get the method ID */
	id_print = (*env)->GetMethodID(env, class_PrintWriter, "print", "(C)V");
	/* call the method */
	for (i = 0; cstr[i] != 0 && !(*env)->ExceptionOccurred(env); ++i) {
		(*env)->CallVoidMethod(env, out, id_print, cstr[i]);
	}
	free(cstr);
}
```
```java
// printf4/Printf4.java
import java.io.*;
class Printf4 {
	public static native void fprint(PrintWriter ps, String format, double x);
	static {
		System.loadLibrary("Printf4");
	}
}
```
```java
// printf4/Printf4Test.java
import java.io.*;
class Printf4Test {
	public static void main(String[] args) {
		double price = 44.95;
		double tax = 7.75;
		double amountDue = price * (1 + tax / 100);
		var out = new PrintWriter(System.out);
		/* This call will throw an exception--note the %% */
		Printf4.fprint(out, "Amount due = %%8.2f\n", amountDue);
		out.flush();
	}
}
```
运行如下命令：
```bash
$ javac -h . Printf4.java
$ gcc -mno-clwb -D __int64="long long" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include\win32" -shared -Wl,--add-stdcall-alias -o Printf4.dll  Printf4.c
$ javac Printf4Test.java
$ java Printf4Test
```
结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212160046734.png)
> [API] 处理Java异常
> - `jint Throw(JNIEnv* env, jthrowable obj)`
> 准备一个在本地代码退出时抛出的异常。成功时返回0，失败时返回一个负值。
> - `jint ThrowNew(JNIEnv* env, jclass cl, const char msg[])`
> 准备一个在本地代码退出时抛出的类型为 `cl` 的异常。成功时返回0，失败时返回一个负值。`msg` 是表示「异常对象的 `String` 构造参数」的“改良UTF-8”字节序列。
> - `jthrowable ExceptionOccurred(JNIEnv* env)`
> 如果有异常挂起，则返回该异常对象，否则返回NULL。
> - `jboolean ExceptionCheck(JNIEnv* env)`
> 如果有异常挂起，则返回 `true` 。
> - `void ExceptionClear(JNIEnv* env)`
> 清除挂起的异常。

---
# 24.9 使用调用API
到现在主要讨论的，都是进行了一些C调用的、用Java语言编写的程序，这大概是因为C的运行速度更快一些，或允许访问一些Java平台无法访问的功能。假设在相反的情况下，有一个C或者C++的程序，且想要调用一些Java代码。**调用API *invocation API* 使你能把Java虚拟机嵌入到C或C++程序中**。下面是初始化虚拟机所需的基本代码：
```java
JavaVMOption options[1];
JavaVMInitArgs vm_args;
JavaVM *jvm;
JNIEnv *env;

options[0].optionString = "-Djava.class.path=.";
memset(&vm_args, 0, sizeof(vm_args));
vm_args.version = JNI_VERSION_1_2;
vm_args.nOptions = 1;
vm_args.options = options;

JNI_CreateJavaVM(&jvm, (void**) &env, &vm_args);
```
**对 `JNI_CreateJavaVM` 的调用将创建虚拟机，并且使指针 `jvm` 指向虚拟机，使指针 `env` 指向执行环境**。

可以给虚拟机提供任意数目的选项，这只需增加选项数组的大小和 `vm_args.nOptions` 的值。例如，
```java
options[i].optionString = "-Djava.compiler=NONE";
```
可以 *deactivates* 即时编译器 *just-in-time compiler* 。
> 提示：当你陷入麻烦导致程序崩溃，从而不能初始化JVM、或不能装载你的类时，打开JNI调试模式。设置一个选项如下：
> ```c
> options[i].optionString = "-verbose:jni";
> ```
> 会看到一系列说明JVM初始化进程的消息。如果看不到你装载的类，请检查你的路径和类路径的设置。

一旦设置完虚拟机，就可以如前面介绍的调用Java方法了。**只要按常规方法使用 `env` 指针即可**。只有在调用invocation API中的其他函数时，才需要 `jvm` 指针。目前，只有四个这样的函数。最重要的一个是终止虚拟机的函数：
```c
(*jvm)->DestroyJavaVM(jvm);
```
遗憾的是，在Windows下，动态链接到 `jre/bin/client/jvm.dll` 中的 `JNI_CreateJavaVM` 函数变得非常困难，因为Vista改变了链接规则，而Oracle的类库仍旧依赖于旧版本的C运行时类库。==示例程序通过手工加载该类库解决了这个问题，这种方式与Java程序所使用的方式一样==，参阅JDK中的 `src.jar` 文件里的 `launcher/java_md.c` 文件。

C程序 `invocation/InvocationTest.c` 设置了虚拟机，然后调用了 `Welcome` 类的 `main` 方法，这个类在卷I第2章中讨论过了（在开始启用测试程序之前，务必编译 `Welcome.java` 文件），下面的代码改了一些：
```c
// invocation/InvocationTest.c
#include <jni.h>
#include <stdlib.h>

#ifdef _WINDOWS
#include <windows.h>
static HINSTANCE loadJVMLibrary(void);
typedef jint (JNICALL *CreateJavaVM_t)(JavaVM **, void **, JavaVMInitArgs *);
#endif

int main() {
	JavaVMOption options[2];
	JavaVMInitArgs vm_args;
	JavaVM *jvm;
	JNIEnv *env;
	long status;

	jclass class_Welcome;
	jclass class_String;
	jobjectArray args;
	jmethodID id_main;

#ifdef _WINDOWS
	HINSTANCE hjvmlib;
	CreateJavaVM_t createJavaVM;
#endif

	options[0].optionString = "-Djava.class.path=.";
	memset(&vm_args, 0, sizeof(vm_args));
	vm_args.version = JNI_VERSION_1_2;
	vm_args.nOptions = 1;
	vm_args.options = options;

#ifdef _WINDOWS
	hjvmlib = loadJVMLibrary();
	createJavaVM = (CreateJavaVM_t) GetProcAddress(hjvmlib, "JNI_CreateJavaVM");
	status = (*createJavaVM)(&jvm, (void **)&env, &vm_args);
#else
	status = JNI_CreateJavaVM(&jvm, (void **)&env, &vm_args);
#endif

	if (status == JNI_ERR) {
		fprintf(stderr, "Error creating VM\n");
		return 1;
	}

	class_Welcome = (*env)->FindClass(env, "Welcome");
	id_main = (*env)->GetStaticMethodID(env, class_Welcome, "main", "([Ljava/lang/String;)V");
	class_String = (*env)->FindClass(env, "java/lang/String");
	args = (*env)->NewObjectArray(env, 0, class_String, NULL);
	(*env)->CallStaticVoidMethod(env, class_Welcome, id_main, args);
	(*jvm)->DestroyJavaVM(jvm);
	return 0;
}

#ifdef _WINDOWS
static int GetStringFromRegistry(HKEY key, const char *name, char *buf, jint bufsize) {
	DWORD type, size;

	return RegQueryValueEx(key, name, 0, &type, 0, &size) == 0
		&& type == REG_SZ
		&& size < (unsigned int) bufsize
		&& RegQueryValueEx(key, name, 0, 0, buf, &size) == 0;
}

static void GetPublicJREHome(char *buf, jint bufsize) {
	HKEY key, subkey;
	char version[MAX_PATH];

	/* Find the current version of the JRE */
	// char *JRE_KEY = "Software\\JavaSoft\\Java Runtime Environment"; // old code
	char *JRE_KEY = "Software\\AdoptOpenJDK\\JDK\\11.0.11.9\\hotspot\\MSI";
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, JRE_KEY, 0, KEY_READ, &key) != 0) {
		fprintf(stderr, "Error opening registry key '%s'\n", JRE_KEY);
		exit(1);
	}
	/*
	if (!GetStringFromRegistry(key, "CurrentVersion", version, sizeof(version))) {
		fprintf(stderr, "Failed reading value of registry key:\n\t%s\\CurrentVersion\n", 
			JRE_KEY);
		RegCloseKey(key);
		exit(1);
	}
	*/
	if (!GetStringFromRegistry(key, "Path", buf, bufsize)) {
		fprintf(stderr, "Failed reading value of registry key:\n\t%s\\Path\n", 
			JRE_KEY);
		RegCloseKey(key);
		exit(1);
	}
	/* Find directory where the current version is installed. */
	/*
	if (RegOpenKeyEx(key, version, 0, KEY_READ, &subkey) != 0) {
		fprintf(stderr, "Error opening registry key '%s\\%s'\n", JRE_KEY, version);
		RegCloseKey(key);
		exit(1);
	}	

	if (!GetStringFromRegistry(subkey, "JavaHome", buf, bufsize)) {
		fprintf(stderr, "Failed reading value of registry key:\n\t%s\\%s\\JavaHome\n", 
	        JRE_KEY, version);
	    RegCloseKey(key);
	    RegCloseKey(subkey);
	    exit(1);
	}
	*/
	RegCloseKey(key);
	// RegCloseKey(subkey);	
}

static HINSTANCE loadJVMLibrary(void) {
	HINSTANCE h1, h2;
	char msvcdll[MAX_PATH];
	char javadll[MAX_PATH];
	GetPublicJREHome(msvcdll, MAX_PATH);   
	strcpy(javadll, msvcdll);
	// strncat(msvcdll, "\\bin\\msvcr71.dll", MAX_PATH - strlen(msvcdll));
	strncat(msvcdll, "\\bin\\msvcp140.dll", MAX_PATH - strlen(msvcdll));
	msvcdll[MAX_PATH - 1] = '\0';
   
	strncat(javadll, "\\bin\\client\\jvm.dll", MAX_PATH - strlen(javadll));
	javadll[MAX_PATH - 1] = '\0';

	h1 = LoadLibrary(msvcdll);
	if (h1 == NULL) {
		fprintf(stderr, "Can't load library msvcp140.dll\n");
	    exit(1);
	}

	h2 = LoadLibrary(javadll);
	if (h2 == NULL) {
		fprintf(stderr, "Can't load library jvm.dll\n");
		exit(1);
	}
	return h2;
}
#endif
```
```java
// invocation/Welcome.java
public class Welcome {
	public static void main(String[] args) {
		var greeting = new String[3];
		greeting[0] = "Welcome to Core Java";
	    greeting[1] = "by Cay Horstmann";
	    greeting[2] = "and Gary Cornell";

	    for (String g : greeting)
	        System.out.println(g);
	}
}
```

要在Linux下编译该程序，请用：
```bash
$ gcc -I jdk/include -I jdk/include/linux -o InvocationTest
-L jdk/jre/lib/i386/client -ljvm InvocationTest.c
```
在Windows下用微软的C编译器时，用下面的命令行（需要确保 `INCLUDE` 和 `LIB` 环境变量包含了「Windows API头文件和库文件的路径」）：
```bash
$ cl -D_WINDOWS -I jdk\include -I jdk\include\win32 InvocationTest.c jdk\lib\jvm.lib advapi32.lib
```
用Cygwin时，用下面的语句进行编译：
```bash
$ gcc -D_WINDOWS -mno-cygwin -I jdk\include -I jdk\include\win32 -D __int64="long long" -I c:\cygwin\usr\include\w32api -o InvocationTest InvocationTest.c
```
在Linux/UNIX下运行该程序之前，需要确保 `LD_LIBRARY_PATH` 包含了共享类库的目录。例如，如果使用Linux上的bash命令行，则需要执行下面的命令：
```bash
export LD_LIBRARY_PATH=jdk/jre/lib/i386/client:$LD_LIBRARY_PATH
```

本机的编译命令如下所示，由于注册表中个人使用JDK版本的不同（AdoptOpenJDK），且使用的是MYSY2，命令也不同：
```bash
$ gcc -D_WINDOWS -mno-clwb -D __int64="long long" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include\win32" -I "C:\Program Files\mingw64\x86_64-w64-mingw32\include" -o InvocationTest InvocationTest.c
$ InvocationTest.exe
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212161918956.png)

> 调用API函数
> - `jint JNI_CreateJavaVM(JavaVM** p_jvm, void** p_env, JavaVMInitArgs* vm_args)`
> 初始化Java虚拟机。如果成功，则返回0，否则返回 `JNI_ERR` 。`p_jvm` 填入指向调用API函数表的指针，`p_env` 填入指向JNI函数表的指针，`vm_args` 　虚拟机参数。
> - `jint DestroyJavaVM(JavaVM* jvm)`
> 销毁虚拟机。如果成功，则返回0，否则返回一个负值。该函数必须通过一个虚拟机指针调用。例如，`(*jvm)->DestroyJavaVM(jvm)` 。

---
# 24.10 完整的示例：访问Windows注册表
本节介绍一个完整的可运行的例子，涵盖了讨论的所有内容：**使用带有字符串、数组、对象、构造器调用和错误处理的本地方法**，展示如何用Java平台包装器来包装普通的基于C的API子集 *put a Java platform wrapper around a subset of the ordinary C-based APIs* ，用于进行Windows注册表操作。当然，==由于Windows的具体特性，使用Windows注册表的程序天生就不可移植。基于这个原因，标准的Java库不支持注册表，所以使用本地方法访问注册表是有意义的==。
## 24.10.1 Windows注册表概述
**Windows注册表是一个存放「Windows操作系统和应用程序的配置信息」的数据仓库**。它提供了对系统和应用程序参数 *preferences* 的单点管理和备份。其不足的方面是，注册表的错误也是单点的。如果你弄乱了注册表，你的电脑就会出故障，甚至无法启动。

我们==不建议你使用注册表来存储Java程序的配置参数，Java配置API *preferences API* 是一个更好的解决方案==（更多信息参见卷I章10）。我们使用注册表只是为了说明，怎样把重要的本地API包装成Java类。

检查注册表的主要工具是注册表编辑器。由于可能存在 *naive but enthusiastic* 的用户，所以Windows没有配备任何图标来启动注册表编辑器。必须启动DOS shell（或打开“开始”→“运行”对话框）然后键入 `regedit` 。图24-4给出了一个运行中的注册表编辑器。
![图24-4 注册表编辑器](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212160137275.png)

左边是树形结构排列的注册表键。请注意，每个键都以 `HKEY` 节点开始，如：
```java
HKEY_CLASSES_ROOT
HKEY_CURRENT_USER
HKEY_LOCAL_MACHINE
...
```
右边是与特定键关联的名/值对。例如，如果安装了Java 11，那么键 `HKEY_LOCAL_MACHINE\Software\JavaSoft\Java Runtime Environment `
就包含名值对 `CurrentVersion="11.0_10"` 。 

在本例中，值是字符串。值也可以是整数或字节数组。
## 24.10.2 访问注册表的Java平台接口
我们创建了一个从Java代码访问注册表的简单接口，然后用本地代码实现这个接口。我们的接口只允许几个注册表操作，为了保持较小的代码规模，我们省略了其他重要的操作，如：添加、删除和枚举注册表键（添加剩余的这些注册表API函数是很容易的）。即使使用我们提供的受限的子集，也可以：
- 枚举某个键中存储的所有名字。
- 读出用某个名字存储的值。
- 设置用某个名字存储的值。

下面是封装注册表键的Java类：
```java
public class Win32RegKey {
	public Win32RegKey(int theRoot, String thePath) { ... }
	public Enumeration names() { ... }
	public native Object getValue(String name);
	public native void setValue(String name, Object value);
	public static final int HKEY_CLASSES_ROOT = 0×80000000;
	public static final int HKEY_CURRENT_USER = 0×80000001;
	public static final int HKEY_LOCAL_MACHINE = 0×80000002;
	...
}
```
`names` 方法返回与该键存放在一起的所有名字的一个枚举，可以用你熟悉的 `hasMoreElements/nextElement` 方法获取它们。`getValue` 方法返回一个对象，该对象可以是字符串、`Integer` 对象或字节数组。`setValue` 方法的 `value` 参数也必须是上述三种类型之一。
## 24.10.3 以本地方法方式实现注册表访问函数
我们需要实现三个操作：
- 获取某个键的值。
- 设置某个键的值。
- 迭代键的名字。

幸运的是，基本上已经看到了所有必须的工具，如Java字符串和数组到C的字符串和数组的转换，还了解了如何在出错时抛出异常。但有两个问题使得这些本地方法比之前的例子更加复杂——`getValue, setValue` 方法处理的是 `Object` 类型，它可以是 `String, Integer, byte[]` 之一；枚举对象需要用来存放对 `hasMoreElements` 和 `nextElement` 的连续调用之间的状态 *The enumeration object stores the state between successive calls to hasMoreElements and nextElement* 。

先看一下 `getValue` 方法，该方法（`Win32RegKey.c` 所示）经历了以下几个步骤：
1. 打开注册表键。**为了读取它们的值，注册表API要求这些键是开放的**。
2. 查询与名字关联的值的类型和大小。
3. **把数据读到缓存**。
4. 如果类型是 `REG_SZ`（字符串），调用 `NewStringUTF` 用该值来创建一个新的字符串。
5. 如果类型是 `REG_DWORD`（32位整数），调用 `Integer` 构造器。
6. 如果类型是 `REG_BINARY` ，调用 `NewByteArray` 来创建一个新的字节数组，并调用 `SetByteArrayRegion` ，把值数据复制到该字节数组中。
7. 如果不是以上类型、或调用API函数时出现错误，那就抛出异常，并小心地释放到此为止获得的所有资源。
8. 关闭键，并返回创建的对象（ `String, Integer, byte[]` ）。

如你所见，这个例子很好地说明了怎样产生不同类型的Java对象。在这个本地方法中，处理泛化的返回类型 *generic return type* 并不困难， `jstring, jobject, jarray` 引用都可以直接作为一个 `jobject` 返回。

但 `setValue` 方法接受的是一个对 `Object` 的引用，并且，为了把该 `Object` 保存为字符串、整数或字节数组，必须确定该 `Object` 的确切类型。**我们可以通过查询 `value` 对象的类，找出对 `java.lang.String, java.lang.Integer, byte[]` 的 *class* 引用，将其与 `IsAssignableFrom` 函数进行比较**，从而确定它的确切类型。如果 `class1` 和 `class2` 是两个类引用，那么调用：
```java
(*env)->IsAssignableFrom(env, class1, class2)
```
当 `class1` 和 `class2` 是同一个类或 `class1` 是 `class2` 的子类时，返回 `JNI_TRUE` 。在这两种情况下，`class1` 对象的引用都可以转型到 `class2` 。例如，当：
```java
(*env)->IsAssignableFrom(env, (*env)->GetObjectClass(env, value), (*env)->FindClass(env, "[B"))
```
为 `true` 时，那么我们就知道该值是一个字节数组。

下面是对 `setValue` 方法中的步骤的概述：
1. 打开注册表键以便写入。
2. **找出要写入的值的类型**。
3. 如果类型是 `String` ，调用 `GetStringUTFChars` 获取一个指向这些字符的指针。
4. 如果类型是 `Integer` ，调用 `intValue` 方法获取该包装器对象中存储的整数。
5. 如果类型是 `byte[]` ，调用 `GetByteArrayElements` 获取指向这些字节的指针。
6. 把数据和长度传递给注册表。
7. 关闭键。
8. 如果类型是 `String` 或 `byte[]` ，那么还要释放指向数据的指针。

最后，我们介绍枚举键 *enumerate keys* 的本地方法。这些方法属于 `Win32RegKeyNameEnumeration` 类。当枚举过程开始时，我们必须打开键。==在枚举过程中，我们必须保持该键的句柄。也就是说，该键的句柄必须与枚举对象存放在一起==。键的句柄是 `DWORD` 类型的，它是一个32位数，所以可以存放在一个Java的整数中。它被存放在枚举类的 `hkey` 域中，当枚举开始时，`SetIntField` 初始化该域，而后续的调用用 `GetIntField` 来读取其值。

在这个例子里，我们用枚举对象存放了另外三个数据项。当枚举一开始，我们可以从注册表中查询到名/值对的个数和最长名字的长度，我们需要这些信息、来分配C字符数组以保存这些名字。这些值存放在枚举对象的 `count` 和 `maxsize` 域中。最后，`index` 域被初始化为–1，表示枚举的开始。一旦其他实例域被初始化，`index` 域就被置为0，在完成每个枚举步骤之后，都会进行递增。

让我们简要介绍一下支持枚举的本地方法。`hasMoreElements` 方法很简单：
1. 获取 `index` 和 `count` 域。
2. 如果 `index` 是-1，调用 `startNameEnumeration` 函数打开键，查询数量和最大长度，初始化 `hkey, count, maxsize, index` 域。
3. 如果 `index` 小于 `count` ，则返回 `JNI_TRUE` ，否则返回 `JNI_FALSE` 。
 
`nextElement` 方法要复杂一些。
1. 获取 `index` 和 `count` 域。
2. 如果 `index` 是-1，调用 `startNameEnumeration` 函数打开键，查询数量和最大长度，初始化 `hkey, count, maxsize, index` 域。
3. 如果 `index` 等于 `count` ，抛出一个 `NoSuchElementException` 异常。
4. 从注册表中读入下一个名字。
5. 递增 `index` 。
6. 如果 `index` 等于 `count` ，则关闭键。
```java
// win32reg/Win32RegKey.java
import java.util.*;

/**
 * A Win32RegKey object can be used to get and set values of a registry key in the Windows registry.
 */
public class Win32RegKey {
	public static final int HKEY_CLASSES_ROOT = 0x80000000;
	public static final int HKEY_CURRENT_USER = 0x80000001;
	public static final int HKEY_LOCAL_MACHINE = 0x80000002;
	public static final int HKEY_USERS = 0x80000003;
	public static final int HKEY_CURRENT_CONFIG = 0x80000005;
	public static final int HKEY_DYN_DATA = 0x80000006;

	private int root;
	private String path;

	/**
	 * Gets the value of a registry entry.
	 * @param name the entry name
	 * @return the associated value
	 */
	public native Object getValue(String name);

	/**
	 * Sets the value of a registry entry.
	 * @param name the entry name
	 * @param value the new value
	 */
	public native void setValue(String name, Object value);

	/**
	 * Construct a registry key object.
	 * @param theRoot one of 
	 * @return the associated value HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE,
	 * HKEY_USERS, HKEY_CURRENT_CONFIG, HKEY_DYN_DATA
	 * @param thePath the registry key path
	 */
	public Win32RegKey(int theRoot, String thePath) {
		root = theRoot;
		path = thePath;
	}

	/**
	 * Enumerates all names of registry entries under the path that this object describes.
	 * @return an enumeration listing all entry names
	 */
	public Enumeration<String> names() {
		return new Win32RegKeyNameEnumeration(root, path);
	}

	static {
		System.loadLibrary("Win32RegKey");
	}
}

class Win32RegKeyNameEnumeration implements Enumeration<String> {
	public native String nextElement();
	public native boolean hasMoreElements(); 

	private int root;
	private String path;
	private int index = -1;
	private int hkey = 0;
	private int maxsize;
	private int count;

	Win32RegKeyNameEnumeration(int theRoot, String thePath) {
		root = theRoot;
		path = thePath;
	}
}

class Win32RegKeyException extends RuntimeException {
	public Win32RegKeyException() {}
	public Win32RegKeyException(String why) { super(why); }
}
```
```c
// win32reg/Win32RegKey.c
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include "Win32RegKey.h"
#include "Win32RegKeyNameEnumeration.h"

JNIEXPORT jobject JNICALL Java_Win32RegKey_getValue(
      JNIEnv* env, jobject this_obj, jobject name) {
	const char* cname;
	jstring path;
	const char* cpath;
	HKEY hkey;
	DWORD type;
	DWORD size;
	jclass this_class;
	jfieldID id_root;
	jfieldID id_path;
	HKEY root;
	jobject ret;
	char* cret;

	/* get the class */
	this_class = (*env)->GetObjectClass(env, this_obj);

	/* get the field IDs */
	id_root = (*env)->GetFieldID(env, this_class, "root", "I");
	id_path = (*env)->GetFieldID(env, this_class, "path", "Ljava/lang/String;");

	/* get the fields */
	root = (HKEY) (*env)->GetIntField(env, this_obj, id_root);
	path = (jstring) (*env)->GetObjectField(env, this_obj, id_path);
	cpath = (*env)->GetStringUTFChars(env, path, NULL);

	/* open the registry key */
	if (RegOpenKeyEx(root, cpath, 0, KEY_READ, &hkey) != ERROR_SUCCESS) {
		(*env)->ThrowNew(env, (*env)->FindClass(env, "Win32RegKeyException"),
			"Open key failed");
		(*env)->ReleaseStringUTFChars(env, path, cpath);
		return NULL;
	}

	(*env)->ReleaseStringUTFChars(env, path, cpath);
	cname = (*env)->GetStringUTFChars(env, name, NULL);

	/* find the type and size of the value */
	if (RegQueryValueEx(hkey, cname, NULL, &type, NULL, &size) != ERROR_SUCCESS) {
		(*env)->ThrowNew(env, (*env)->FindClass(env, "Win32RegKeyException"),
			"Query value key failed");
		RegCloseKey(hkey);
		(*env)->ReleaseStringUTFChars(env, name, cname);
		return NULL;
	}

	/* get memory to hold the value */
	cret = (char*)malloc(size);

	/* read the value */
	if (RegQueryValueEx(hkey, cname, NULL, &type, &cret, &size) != ERROR_SUCCESS) {
		(*env)->ThrowNew(env, (*env)->FindClass(env, "Win32RegKeyException"),
			"Query value key failed");
		free(cret);
		RegCloseKey(hkey);
		(*env)->ReleaseStringUTFChars(env, name, cname);
		return NULL;
	}

	/* depending on the type, store the value in a string, integer, or byte array */
	if (type == REG_SZ) {
		ret = (*env)->NewStringUTF(env, cret);
	} else if (type == REG_DWORD) {
		jclass class_Integer = (*env)->FindClass(env, "java/lang/Integer");
		/* get the method ID of the constructor */
		jmethodID id_Integer = (*env)->GetMethodID(env, class_Integer, "<init>", "(I)V");
		int value = *(int*)cret;
		/* invoke the constructor */
		ret = (*env)->NewObject(env, class_Integer, id_Integer, value);
	} else if (type == REG_BINARY) {
		ret = (*env)->NewByteArray(env, size);
		(*env)->SetByteArrayRegion(env, (jarray) ret, 0, size, cret);
	} else {
		(*env)->ThrowNew(env, (*env)->FindClass(env, "Win32RegKeyException"),
			"Unsupported value type");
		ret = NULL;
	}
	
	free(cret);
	RegCloseKey(hkey);
	(*env)->ReleaseStringUTFChars(env, name, cname);
	return ret;
}

JNIEXPORT void JNICALL Java_Win32RegKey_setValue(JNIEnv* env, jobject this_obj, 
      jstring name, jobject value) {  
   const char* cname;
   jstring path;
   const char* cpath;
   HKEY hkey;
   DWORD type;
   DWORD size;
   jclass this_class;
   jclass class_value;
   jclass class_Integer;
   jfieldID id_root;
   jfieldID id_path;
   HKEY root;
   const char* cvalue;
   int ivalue;

	/* get the class */
	this_class = (*env)->GetObjectClass(env, this_obj);

	/* get the field IDs */
	id_root = (*env)->GetFieldID(env, this_class, "root", "I");
	id_path = (*env)->GetFieldID(env, this_class, "path", "Ljava/lang/String;");

	/* get the fields */
	root = (HKEY) (*env)->GetIntField(env, this_obj, id_root);
	path = (jstring) (*env)->GetObjectField(env, this_obj, id_path);
	cpath = (*env)->GetStringUTFChars(env, path, NULL);

	/* open the registry key */
	if (RegOpenKeyEx(root, cpath, 0, KEY_WRITE, &hkey) != ERROR_SUCCESS) {
		(*env)->ThrowNew(env, (*env)->FindClass(env, "Win32RegKeyException"),
			"Open key failed");
		(*env)->ReleaseStringUTFChars(env, path, cpath);
		return NULL;
	}

	(*env)->ReleaseStringUTFChars(env, path, cpath);
	cname = (*env)->GetStringUTFChars(env, name, NULL);

	class_value = (*env)->GetObjectClass(env, value);
	class_Integer = (*env)->FindClass(env, "java/lang/Integer");

	/* determine the type of the value object */
	if ((*env)->IsAssignableFrom(env, class_value, (*env)->FindClass(env, "java/lang/String"))) {
		/* it is a string--get a pointer to the characters */
		cvalue = (*env)->GetStringUTFChars(env, (jstring) value, NULL);
		type = REG_SZ;
		size = (*env)->GetStringLength(env, (jstring) value) + 1;
	} else if ((*env)->IsAssignableFrom(env, class_value, class_Integer)) {
		/* it is an integer--call intValue to get the value */
		jmethodID id_intValue = (*env)->GetMethodID(env, class_Integer, "intValue", "()I");
		ivalue = (*env)->CallIntMethod(env, value, id_intValue);
		type = REG_DWORD;
		cvalue = (char*)&ivalue;
		size = 4;
	} else if ((*env)->IsAssignableFrom(env, class_value, (*env)->FindClass(env, "[B"))) {
		/* it is a byte array--get a pointer to the bytes */
		type = REG_BINARY;
		cvalue = (char*)(*env)->GetByteArrayElements(env, (jarray) value, NULL);
		size = (*env)->GetArrayLength(env, (jarray) value);
	} else {
		/* we don't know how to handle this type */
		(*env)->ThrowNew(env, (*env)->FindClass(env, "Win32RegKeyException"), "Unsupported value type");
		RegCloseKey(hkey);
		(*env)->ReleaseStringUTFChars(env, name, cname);
		return;
	}

	/* set the value */
	if (RegSetValueEx(hkey, cname, 0, type, cvalue, size) != ERROR_SUCCESS) {
		(*env)->ThrowNew(env, (*env)->FindClass(env, "Win32RegKeyException"), "Set value failed");
	}

	RegCloseKey(hkey);
	(*env)->ReleaseStringUTFChars(env, name, cname);
	/* if the value was a string or a byte array, release the pointer */
	if (type == REG_SZ) {
		(*env)->ReleaseStringUTFChars(env, (jstring) value, cvalue);
	} else if (type == REG_BINARY) {
		(*env)->ReleaseByteArrayElements(env, (jarray) value, (jbyte*) cvalue, 0);
	}
}

/* helper function to start enumeration of names */
static int startNameEnumeration(JNIEnv* env, jobject this_obj, jclass this_class) {
	jfieldID id_index;
	jfieldID id_count;
	jfieldID id_root;
	jfieldID id_path;
	jfieldID id_hkey;
	jfieldID id_maxsize;
	
	HKEY root;
	jstring path;
	const char* cpath;
	HKEY hkey;
	DWORD maxsize = 0;
	DWORD count = 0;

	/* get the field IDs */
	id_root = (*env)->GetFieldID(env, this_class, "root", "I");
	id_path = (*env)->GetFieldID(env, this_class, "path", "Ljava/lang/String;");
	id_hkey = (*env)->GetFieldID(env, this_class, "hkey", "I");
	id_maxsize = (*env)->GetFieldID(env, this_class, "maxsize", "I");
	id_index = (*env)->GetFieldID(env, this_class, "index", "I");
	id_count = (*env)->GetFieldID(env, this_class, "count", "I");

	/* get the field values */
	root = (HKEY) (*env)->GetIntField(env, this_obj, id_root);
	path = (jstring) (*env)->GetObjectField(env, this_obj, id_path);
	cpath = (*env)->GetStringUTFChars(env, path, NULL);

	/* open the registry key */
	if (RegOpenKeyEx(root, cpath, 0, KEY_READ, &hkey) != ERROR_SUCCESS) {
		(*env)->ThrowNew(env, (*env)->FindClass(env, "Win32RegKeyException"),
			"Open key failed");
		(*env)->ReleaseStringUTFChars(env, path, cpath);
		return -1;
	}
	(*env)->ReleaseStringUTFChars(env, path, cpath);

	/* query count and max length of names */
	if (RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &count, &maxsize, 
          NULL, NULL, NULL) != ERROR_SUCCESS) {
	    (*env)->ThrowNew(env, (*env)->FindClass(env, "Win32RegKeyException"),
		    "Query info key failed");
		RegCloseKey(hkey);
		return -1;      
    }

	/* set the field values */
	(*env)->SetIntField(env, this_obj, id_hkey, (DWORD) hkey);
	(*env)->SetIntField(env, this_obj, id_maxsize, maxsize + 1);
	(*env)->SetIntField(env, this_obj, id_index, 0);
	(*env)->SetIntField(env, this_obj, id_count, count);
	return count;
}

JNIEXPORT jboolean JNICALL Java_Win32RegKeyNameEnumeration_hasMoreElements(JNIEnv* env, 
      jobject this_obj) {
	jclass this_class;
	jfieldID id_index;
	jfieldID id_count;
	int index;
	int count;
	/* get the class */
	this_class = (*env)->GetObjectClass(env, this_obj);
	
	/* get the field IDs */
	id_index = (*env)->GetFieldID(env, this_class, "index", "I");
	id_count = (*env)->GetFieldID(env, this_class, "count", "I");

	index = (*env)->GetIntField(env, this_obj, id_index);
	if (index == -1) { /* first time */
		count = startNameEnumeration(env, this_obj, this_class);
		index = 0;
	} else 
		count = (*env)->GetIntField(env, this_obj, id_count);
	return index < count;
}

JNIEXPORT jobject JNICALL Java_Win32RegKeyNameEnumeration_nextElement(JNIEnv* env, 
      jobject this_obj) {
	jclass this_class;
	jfieldID id_index;
	jfieldID id_hkey;
	jfieldID id_count;
	jfieldID id_maxsize;
	
	HKEY hkey;
	int index;
	int count;
	DWORD maxsize;
	
	char* cret;
	jstring ret;

	/* get the class */
	this_class = (*env)->GetObjectClass(env, this_obj);

	/* get the field IDs */
	id_index = (*env)->GetFieldID(env, this_class, "index", "I");
	id_count = (*env)->GetFieldID(env, this_class, "count", "I");
	id_hkey = (*env)->GetFieldID(env, this_class, "hkey", "I");
	id_maxsize = (*env)->GetFieldID(env, this_class, "maxsize", "I");

	index = (*env)->GetIntField(env, this_obj, id_index);
	if (index == -1) { /* first time */
		count = startNameEnumeration(env, this_obj, this_class);
		index = 0;
	} else
		count = (*env)->GetIntField(env, this_obj, id_count);

	if (index >= count) { /* already at end */
		(*env)->ThrowNew(env, (*env)->FindClass(env, "java/util/NoSuchElementException"),
            "past end of enumeration");
        return NULL;
    }

	maxsize = (*env)->GetIntField(env, this_obj, id_maxsize);
	hkey = (HKEY)(*env)->GetIntField(env, this_obj, id_hkey);
	cret = (char*)malloc(maxsize);

	/* find the next name */
	if (RegEnumValue(hkey, index, cret, &maxsize, NULL, NULL, NULL, NULL) != ERROR_SUCCESS) {
		(*env)->ThrowNew(env, (*env)->FindClass(env, "Win32RegKeyException"),
            "Enum value failed");
        free(cret);
        RegCloseKey(hkey);
        (*env)->SetIntField(env, this_obj, id_index, count);
        return NULL;
	}

	ret = (*env)->NewStringUTF(env, cret);
	free(cret);

	/* increment index */
	++index;
	(*env)->SetIntField(env, this_obj, id_index, index);
	if (index == count) { /* at end */
		RegCloseKey(hkey);
	}
	return ret;
}
```
`win32reg/Win32RegKeyTest.java` 给出了测试我们新的注册表函数的程序。我们在键中添加了三个名值对：一个字符串、一个整数和一个字节数组。
```java
HKEY_CURRENT_USER\Software\JavaSoft\Java Runtime Environment // x
```
然后，枚举该键的所有名字并获取它们的值。该程序应该打印如下信息：
```c
Default user=Harry Hacker
Lucky number=13
Small primes=2 3 5 7 11 13
```
虽然在该键中添加这些名值对不会有什么危害，但在运行该程序后，可能还是想使用注册表编辑器去移除它们。
```java
// win32reg/Win32RegKeyTest.java
import java.util.*;

public class Win32RegKeyTest {
	public static void main(String[] args) {
		// var key = new Win32RegKey(
		//	Win32RegKey.HKEY_CURRENT_USER, "Software\\JavaSoft\\Java Runtime Environment");
		var key = new Win32RegKey(
			Win32RegKey.HKEY_LOCAL_MACHINE, "Software\\AdoptOpenJDK\\JDK\\11.0.11.9\\hotspot\\MSI");
		
		key.setValue("Default user", "Harry Hacker");
		key.setValue("Lucky number", 13);
		key.setValue("Small primes", new byte[] {2, 3, 5, 7, 11});
		
		Enumeration<String> e = key.names();
		while (e.hasMoreElements()) {
			String name = e.nextElement();
			System.out.print(name + "=");
			Object value = key.getValue(name);
			if (value instanceof byte[])
				for (byte b : (byte[]) value)
					System.out.print((b & 0xFF) + " ");
			else 
				System.out.print(value);
		}
		System.out.println();
	}
}
```

在编译之前，记得在 `Win32RegKey` 和 `Win32RegKeyNameEnumeration` 上都要运行 `javac -h` 。微软编译器的完整命令行如下：
```bash
$ cl -I jdk\include -I jdk\include\win32 -LD Win32RegKey.c advapi32.lib
```
Cygwin系统上，请使用：
```bash
$ gcc -mno-cygwin -D __int64="long long" -I jdk\include -I jdk\include\win32 -I c:\cygwin\usr\include\w32api -shared -Wl,--add-stdcall-alias -o Win32RegKey.dll Win32RegKey.c
```
**因为注册表API是针对Windows的，所以这个程序不能在其他操作系统上运行**。

本机上编译如下：
```bash
$ javac -h . Win32RegKey.java 
$ gcc -mno-clwb -D __int64="long long" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include" -I "C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot\include\win32" -I "C:\Program Files\mingw64\x86_64-w64-mingw32\include" -shared -Wl,--add-stdcall-alias -o Win32RegKey.dll Win32RegKey.c
$ javac Win32RegKeyTest.java
```
特别注意的是，原代码使用了过时的API：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212161934538.png)
一开始运行，如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212162026255.png)
但在该项的权限处勾选完全控制，就可以写入了：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212162028397.png)
写入的结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212162029351.png)
但控制台报错，也没有打印出各项，懒得调试了，也不会：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212162030799.png)

> 类型质询函数
> - `jboolean IsAssignableFrom(JNIEnv* env, jclass cl1, jclass cl2)`
> 如果第一个类的对象可以赋给第二个类的对象，则返回 `JNI_TRUE` ，否则返回 `JNI_FALSE` 。这个函数可以测试：两个类是否相同，`cl1` 是否是 `cl2` 的子类，`cl2` 是否表示一个由 `cl1` 或它的一个超类实现的接口。
> - `jclass GetSuperClass(JNIEnv* env, jclass cl)`
> 返回某个类的超类。如果 `cl` 表示 `Object` 类或一个接口，则返回NULL。

一路走来，已经学习了许多高级API，现在终于结束了。从每位Java程序员都应该了解的主题开始，即：**流、XML、网络、数据库、时间和国际化**，又阐述了图形和GUI编程，最后用非常技术性的几章结尾：安全、远程方法、注解处理和本地方法。==我们希望你能真正享受这个旅程，掌握这些涉及领域广泛的Java API，并能将这些新知识应用到你的项目中==。