@[toc]

▲ 类、超类和子类
▲ Object：所有类的超类
▲ 泛型数组列表
▲ 对象包装器与自动装箱
▲ 参数数量可变的方法
▲ 枚举类
▲ 反射
▲ 继承的设计技巧

第4章主要阐述了类和对象的概念，本章学习**面向对象程序设计的另外一个基本概念**：继承 `inheritance` 。利用继承，可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和字段。在此基础上，还可以添加一些新的方法和字段，以满足新的需求。这是Java程序设计中的一项核心技术。

另外，还阐述了反射 `reflection` 的概念。==反射是指**在程序运行期间发现更多的类及其属性的能力**== *the ability to find out more about classes and their properties in a running program* 。这是一个功能强大的特性，使用起来也比较复杂。由于主要是 *tool builders* 而不是 *application programmers* 对这项功能感兴趣，因此对这部分内容要认真学习。

---
# 5.1 类、超类和子类
现在重新回忆在前一章中讨论的 `Employee` 类。假设你在某个公司工作，这个公司中经理的待遇与普通雇员的待遇存在着一些差异。他们之间也存在很多相同点，例如都领取薪水。只是普通雇员在完成本职任务之后仅领取薪水，而经理在完成了预期业绩之后还能得到奖金。这种情形就需要使用继承。为什么呢？——因为需要为经理定义一个新类 `Manager` ，以便增加一些新功能。但可以重用 `Employee` 类中已经编写的部分代码，并将其中的所有字段保留下来。从理论上讲，在 `Manager` 与 `Employee` 之间存在着明显的“is-a”（是）关系，每个经理都是一名雇员，**"is-a"关系是继承的一个明显特征**。

> 注释：这里使用员工和经理的传统示例，不过必须提醒对这个例子要有所保留。在真实世界里，员工也可能会成为经理，所以建模时可能希望经理也是员工，而不是一个子类。不过，在我们的例子中，假设公司里只有两类人：一些人一直是员工，另一些人一直是经理。

## 5.1.1 定义子类
如下继承 `Employee` 类来定义 `Manager` 类，关键字 `extends` 表示继承。
```java
public class Manager extends Employee {
	// 添加方法和域
}
```

> C++注释：Java与C++定义继承类的方式十分相似。Java用关键字 `extends` 代替了C++中的冒号（ `:` ）。**在Java中，所有的继承都是公有继承，而没有C++的私有继承和保护继承**。

关键字 `extends` 表明**正在构造的新类派生于一个已存在的类**。已存在的类称为超类 `superclass` 、基类 `base class` 或父类 `parent class` ；新类称为子类 `subclass` 、派生类 `derived class` 或孩子类 `child class` 。超类和子类是Java程序员最常用的两个术语，而了解其他语言的程序员可能更加偏爱使用父类和子类，这些都是继承时使用的术语。

尽管 `Employee` 类是一个超类，但并不是因为它优于子类或者拥有比子类更多的功能。实际上恰恰相反，**子类比超类拥有的功能更加丰富**。例如，读过 `Manager` 类的源代码之后会发现，`Manager` 类比超类 `Employee` 封装了更多的数据，拥有更多的功能。
> 注释：前缀“超”和“子”来源于计算机科学和数学理论中的集合语言的术语。所有雇员组成的集合包含所有经理组成的集合。可以这样说，雇员集合是经理集合的超集，也可以说，经理集合是雇员集合的子集。

在 `Manager` 类中，增加了一个用于存储奖金信息的字段，以及一个用于设置这个字段的新方法：
```java
public class Manager extends Employee {
	private double bonus;
	public void setBonos(double bonus) {
		this.bonus = bonus;
	}
}
```
这里定义的方法和字段并没有什么特别之处。如果有一个 `Manager` 对象，就可以使用 `setBonus` 方法。
```java
Manager boss = ...;
boss.setBonus(5000);
```
当然，由于 `setBonus` 方法不是在 `Employee` 类中定义的，所以**属于 `Employee` 类的对象不能使用它**。然而，尽管在 `Manager` 类中没有显式地定义 `getName` 和 `getHireDay` 等方法，但**属于 `Manager` 类的对象却可以使用它们**，这是因为 `Manager` 类自动地继承了超类 `Employee` 中的这些方法。同样，从超类中还继承了 `name, salary, hireDay` 这3个字段。这样一来，每个 `Manager` 类对象就包含了4个字段：`name, salary, hireDay, bonus` 。

通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，==应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中==，这种将通用功能抽取到超类的做法，在面向对象程序设计中十分普遍。

## 5.1.2 覆盖方法
然而，**超类中的有些方法对子类 `Manager` 并不一定适用**。具体来说，`Manager` 类中的`getSalary` 方法应该返回薪水和奖金的总和。为此，**需要提供一个新的方法来覆盖 `override` 超类中的这个方法**：
```java
public class Manager extends Employee {
	public double getSalary() {
		...
	}
}
```
应该如何实现这个方法呢？乍看起来似乎很简单，只要返回 `salary` 和 `bonus` 字段的总和就
可以了：
```java
public double getSalary() {
	return salary + bonus; // won't work
}
```
然而，这个方法并不能运行。这是因为 `Manager` 类的 `getSalary` 方法不能够直接地访问超类的私有字段。也就是说，尽管每个 `Manager` 对象都拥有一个名为 `salary` 的字段，但在 `Manager` 类的 `getSalary` 方法中并不能够直接地访问 `salary` 字段。**只有 `Employee` 类的方法才能够访问 `Employee` 的私有部分**。如果 `Manager` 类的方法一定要访问私有字段，就必须借助于公有的接口，`Employee` 类中的公共方法 `getSalary` 正是这样一个接口。

现在，再试一下。将对 `salary` 字段的访问替换成调用 `getSalary` 方法。
```java
public double getSalary() {
	double baseSalary = getSalary(); // still won't work
	return baseSalary + bonus;
}
```
上面这段代码仍然不能运行。问题出现在调用 `getSalary` 的语句上，这是因为 `Manager` 类也有一个 `getSalary` 方法（就是正在实现的这个方法），所以这条语句将会导致无限次地调用
自己，直到整个程序崩溃为止。

这里需要指出：**我们希望调用超类 `Employee` 中的 `getSalary` 方法**，而不是当前类的这个方法。为此，可以使用特定的关键字 `super` 解决这个问题：
```java
super.getSalary()
```
上述语句调用的是 `Employee` 类中的 `getSalary` 方法。下面是 `Manager` 类中 `getSalary` 方法的正确书写格式：
```java
public double getSalary() {
	double baseSalary = super.getSalary();
	return baseSalary + bonus;
}
```
> 注释：有些人认为 `super` 与 `this` 引用是类似的概念，实际上，这样比较并不太恰当。这是因为 **`super` 不是一个对象的引用 *super is not a reference to an object* ，不能将 `super` 赋给另一个对象变量**，它只是一个指示编译器调用超类方法的特殊关键字。

正像前面所看到的那样，==在子类中可以增加字段、增加方法或覆盖超类的方法，然而绝对
不能删除继承的任何字段和方法==。
> C++注释：在Java中使用关键字 `super` 调用超类的方法，而在C++中则采用超类名加上 `::` 操作符的形式。例如，在 `Manager` 类的 `getSalary` 方法中，应该将 `super.getSalary` 替换为 `Employee::getSalary` 。

## 5.1.3 子类构造器
在例子的最后，我们来提供一个构造器。
```java
public Manager(String name, double salary, int year, int month, int day) {
	super(name, salary, year, month, day);
	bonus = 0;
}
```
这里的关键字 `super` 具有不同的含义。语句 `super(n, s, year, month, day);` 是“调用超类 `Employee` 中含有 `n, s, year, month, day` 参数的构造器”的简写形式。

**由于 `Manager` 类的构造器不能访问 `Employee` 类的私有字段，所以必须利用 `Employee` 类的构造器对这部分私有字段进行初始化**，我们可以通过 `super` 实现对超类构造器的调用。**使用 `super` 调用构造器的语句，必须是子类构造器的第一条语句**。

==如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器==。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告一个错误。
> 注释：回忆一下，关键字 `this` 有两个用途：一是**指示隐式参数的引用**，二是**调用该类其他的构造器**，同样，`super` 关键字也有两个用途：一是**调用超类的方法**，二是**调用超类的构造器**。在调用构造器的时候，这两个关键字的使用方式很相似。==调用构造器的语句只能作为另一个构造器的第一条语句出现==。构造参数既可以传递给本类 `this` 的其他构造器，也可以传递给超类 `super` 的构造器。

> C++注释：在C++的构造函数中，使用初始化列表语法调用超类的构造函数，而不调用
`super` 。在C++中，`Manager` 的构造函数如下所示：
> ```cpp
> Manager::Manager(String name, double salary, int year, int month, int day) // C++
> : Employee(name, salary, year, month, day) {
>     bonus = 0;
> }
> ```

重新定义 `Manager` 对象的 `getSalary` 方法之后，奖金就会自动地添加到经理的薪水中。下面给出一个例子，其功能为创建一个新经理，并设置他的奖金：
```java
Manager boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);
boss.setBonus(5000);
```
下面定义一个包含3个雇员的数组：
```java
Employee[] staff = new Employee[3];
```
将经理和雇员都放到数组中：
```java
staff[0] = boss;
staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
staff[2] = new Employee("Tony Tester", 40000, 1990, 3, 15);
```
输出每个人的薪水：
```java
for (Employee e : staff)
	System.out.println(e.getName() + " " + e.getSalary());
```
运行这条循环语句将会输出下列数据：
```java
Carl Cracker 85000.0
Harry Hacker 50000.0
Tommy Tester 40000.0
```
这里的 `staff[1]` 和 `staff[2]` 仅输出了基本薪水，这是因为它们对应的是 `Employee` 对象，而 `staff[0]` 对应的是 `Manager` 对象，它的 `getSalary` 方法将奖金与基本薪水加在了一起。需要提到的是，`e.getSalary()` 调用能够确定应该执行哪个 `getSalary` 方法。请注意，**尽管这里将 `e` 声明为 `Employee` 类型，但实际上 `e` 既可以引用 `Employee` 类型的对象，也可以引用 `Manager` 类型的对象**。

当 `e` 引用 `Employee` 对象时，`e.getSalary()` 调用的是 `Employee` 类中的 `getSalary` 方法；当 `e` 引用 `Manager` 对象时，`e.getSalary()` 调用的是 `Manager` 类中的 `getSalary` 方法。**虚拟机知道 `e` 实际引用的对象类型，因此能够正确地调用相应的方法**。

**一个对象变量**（例如，变量 `e` ）**可以指示多种实际类型的现象，被称为多态** `polymorphism` 。**在运行时能够自动地选择适当方法的现象，称为动态绑定** `dynamic binding` 。在本章中将详细地讨论这两个概念。
> C++注释：**在C++中，如果希望实现动态绑定，需要将成员函数声明为 `virtual`** 。而在Java中，不需要将方法声明为虚拟方法，**动态绑定是默认的处理方式**。如果不希望让一个方法是虚拟的，可以将它标记为 `final`（稍后将介绍关键字 `final` ）。

程序 `Inheritance/inheritance/ManagerTest` 展示了 `Employee` 对象与 `Manager` 对象在薪水计算上的区別。
```java
package inheritance;

/**
 * This program demonstrates inheritance.
 */
public class ManagerTest {
	public static void main(String[] args) {
		// construct a Manager object
		var boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);
		boss.setBonus(5000);
		
		var staff = new Employee[3];
		// file the staff array with Manager and Employee objects
		staff[0] = boss;
		staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
		staff[2] = new Employee("Tommy Tester", 40000, 1990, 3, 15);
		
		// print out information about all Employee objects
		for (Employee e : staff) 
			System.out.println("name=" + e.getName() + ", salary=" + e.getSalary());
	}
}
```
对上述代码的运行结果如下：
```java
name=Carl Cracker, salary=85000.0
name=Harry Hacker, salary=50000.0
name=Tommy Tester, salary=40000.0
```
下面是 `Manager` 对象：
```java
package inheritance;

public class Manager extends Employee {
	private double bonus;
	
	/**
	 * @param name the employee's name
	 * @param salary the salary
	 * @param year the hire year
	 * @param month the hire month
	 * @param day the hire day
	 */
	public Manager(String name, double salary, int year, int month, int day) {
		super(name, salary, year, month, day);
		bonus = 0;
	}
	
	public double getSalary() {
		double baseSalary = super.getSalary();
		return baseSalary + bonus;
	}
	
	public void setBonus(double b) {
		bonus = b;
	}
}
```
对其运用 `javadoc` 得到的结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209151851740.png)

## 5.1.4 继承层次
**继承并不仅限于一个层次**。例如，可以由 `Manager` 类派生 `Executive` 类。**由一个公共超类派生出来的所有类的集合，称为继承层次** `inheritance hierarchy` ，如图5-1所示。在继承层次中，从某个特定的类到其祖先的路径称为该类的**继承链** `inheritance chain` 。
![图5.1 Employee继承层次|500x400](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209142046567.png)

通常，一个祖先类可以拥有多个子孙继承链。例如，可以由 `Employee` 类派生出子类`Programmer` 或 `Secretary` ，它们与 `Manager` 类没有任何关系（有可能它们彼此之间也没有任何关系）。必要的话，可以将这个过程一直延续下去。
> C++注释：在C++中，一个类可以有多个超类。而**Java不支持多继承**。有关Java中多继承功能的实现方式，参看章6.1节有关接口的讨论。

## 5.1.5 多态
有一个简单规则，用来判断是否应该将类设计为继承关系，这就是"is-a"规则，它表明**子类的每个对象也是超类的对象**。例如，每个经理都是员工，因此将 `Manager` 类设计为 `Employee` 类的子类是有道理的；反之则不然，并不是每一名员工都是经理。

"is-a"规则的另一种表述法是**置换法则** `substitution principle` 。它指出，**程序中出现超类对象的任何地方都可以用子类对象置换**。例如，可以将一个子类对象赋给超类变量。
```java
Employee e;
e = new Employee(...);
// Employee object expected
e = new Manager(...); // OK，Manager can be used as well
```
**在Java程序设计语言中，对象变量是多态的**。一个 `Employee` 变量既可以引用一个 `Employee` 类对象，也可以引用一个 `Employee` 类的任何一个子类的对象（例如，`Manager, Executive, Secretary` 等）。

从之前的代码中，已经利用了置换法则。在下面的例子中，变量 `staff[0]` 与 `boss` 引用同一个对象。但编译器**只**将 `staff[0]` 看成 `Employee` 对象。
```java
Manager boss = new Manager(...);
Employee[] staff = new Employee[3];
staff[0] = boss;
```
这意味着，可以这样调用：
```java
boss.setBonus(5000); // OK
```
但不能这样调用：
```java
staff[0].setBonus(5000); // Error
```
这是因为 `staff[0]` 声明的类型是 `Employee` ，而 `setBonus` 不是 `Employee` 类的方法。

不过，**不能将一个超类的引用赋给子类变量**。例如，下面的赋值是非法的：
```java
Manager m = staff[i]; // Error
```
原因很清楚：不是所有的雇员都是经理。如果赋值成功，`m` 有可能引用了一个不是经理的 `Employee` 对象，当在后面调用 `m.setBonus(...)` 时就有可能发生运行时错误。

> 警告：**在Java中，子类引用的数组可以转换成超类引用的数组**，而不需要采用强制类型转换。例如，下面是一个经理数组：
> ```java
> Manager[] managers = new Manager[10];
> ```
> 将它转换成 `Employee[]` 数组完全是合法的：
> ```java
> Employee[] staff = managers; // OK
> ```
> 这样做肯定不会有问题，思考一下其中的缘由。毕竟，如果 `manager[i]` 是一个`Manager` ，也一定是一个 `Employee` 。不过实际上，**将会发生一些令人惊讶的事情**。要切记 `managers` 和 `staff` 引用的是同一个数组。现在看一下这条语句：
> ```java
> staff[0] = new Employee("Harry Hacker", ...);
> ```
> **编译器竟然接纳了这个赋值操作**。但在这里，`staff[0]` 与 `manager[0]` 引用的是同一个对象，似乎我们把一个普通雇员擅自归入经理行列中了。这是一种很不好的情形，当调用 `managers[0].setBonus(1000)` 的时候，将会试图调用一个不存在的实例字段，进而搅乱相邻存储空间的内容。
> 
> ==为了确保不发生这类错误，所有数组都要牢记创建时的元素类型，并负责监督仅将类型兼容的引用存储到数组中==。例如，使用 `new managers[10]` 创建的数组是一个经理数组。如果试图存储一个 `Employee` 类型的引用，就会引发 `ArrayStoreException` 异常。

## 5.1.6 理解方法调用
准确地理解「如何在对象上应用方法调用」非常重要。下面假设要调用 `x.f(args)` ，隐式参数 `x` 声明为类 `C` 的一个对象。下面是调用过程的详细描述：
1. **编译器査看对象的声明类型和方法名**。需要注意的是：有可能存在多个名字为 `f` 、但参数类型不一样的方法。例如，可能存在方法 `f(int)` 和方法 `f(String)` 。编译器将会一一枚举「 `C` 类中所有名为 `f` 的方法」和「其超类中访问属性为 `public` 且名为 `f` 的方法」（**超类的私有方法不可访问**）。至此，编译器已获得**所有可能被调用的候选方法**。
2. 接下来，编译器要确定「方法调用中提供的参数类型」。如果在所有名为 `f` 的方法中，存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析** ` overloading resolution` 。例如，对于调用 `x.f("Hello")` 来说，编译器将会挑选 `f(String)` ，而不是 `f(int)` 。
	由于允许类型转换（ `int` 可以转换成 `double` ，`Manager` 可以转换成 `Employee` 等等)，所以这个过程可能很复杂。==如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误==。至此，编译器已知道**需要调用的方法的名字和参数类型**。
> 注释：前面曾说，**方法的名字和参数列表称为方法的签名**。例如，`f(int)` 和 `f(String)` 是两个具有相同名字、不同签名的方法。==如果在子类中，定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法==。
> 
> 不过，**返回类型不是签名的一部分**，因此==在覆盖方法时，一定要保证返回类型的兼容性。允许子类将「覆盖方法的返回类型」定义为「原返回类型的子类型」==。例如，假设`Employee` 类有 `public Employee getBuddy() { ... }` ，而经理不会想找地位低下的员工。为了反映这一点，在后面的子类 `Manager` 中，可以按照如下所示方式、覆盖这个方法：
> ```java
> public Manager getBuddy() { . . . } // OK to change return type
> ```
> 我们说，这两个 `getBuddy` 方法具有可协变的返回类型 *covariant return types* 。

3. **如果是 `private` 方法、`static` 方法、`final` 方**法（有关 `final` 修饰符的含义，将在下一节讲述）**或者构造器，那么编译器将可以准确地知道应该调用哪个方法**，我们将这种调用方式称为**静态绑定** `static binding` 。与此对应的是，==调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定==。在我们列举的示例中，编译器采用动态绑定生成一条调用 `f(String)` 的指令。
4. 当程序运行、且采用**动态绑定**调用方法时，虚拟机必须调用「与 `x` 所引用对象的实际类型最合适的那个类」的方法。假设 `x` 的实际类型是 `D` ，它是 `C` 类的子类。如果 `D` 类定义了方法 `f(String)` ，就直接调用它；否则，将在 `D` 类的超类中寻找 `f(String)` ，以此类推。

每次调用方法都要进行搜索，时间开销相当大。因此，**虚拟机预先为每个类创建了一个
方法表** `method table` ，其中列出了所有方法的签名和实际要调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中，虚拟机搜索 `D` 类的方法表，以便寻找与调用 `f(Sting)` 相匹配的方法。这个方法既有可能是 `D.f(String)` ，也有可能是 `X.f(String)` ，这里的 `X` 是 `D` 的超类。这里需要提醒一点，**如果调用 `super.f(param)` ，编译器将对「隐式参数超类的方法表」进行搜索**。

现在，查看一下程序 `Inheritance/inheritance/ManagerTest` 中调用 `e.getSalary()` 的详细过程。`e` 声明为 `Employee` 类型。`Employee` 类只有一个名叫 `getSalary` 的方法，这个方法没有参数。因此，在这里不必担心重载解析的问题。

**由于 `getSalary` 不是 `private, static, final` 方法，所以将采用动态绑定**。虚拟机为 `Employee` 和 `Manager` 两个类生成方法表。在 `Employee` 的方法表中，列出了这个类定义的
所有方法：
```java
Employee:
	getName() -> Employee.getName()
	getSalary() -> Employee.getSalary()
	getHireDay() -> Employee.getHireDay()
	raiseSalary(double) -> Employee.raiseSalary(double)
```
实际上，上面列出的方法并不完整，稍后会看到 `Employee` 类有一个超类 `Object` ，`Employee` 类从这个超类中还继承了许多方法，在此，我们略去了 `Object` 的方法。

`Manager` 的方法表稍微有些不同。其中有三个方法是继承而来的，一个方法是重新定义的，还有一个方法是新增加的。
```java
Manager:
	getName() -> Employee.getName()
	getSalary() -> Manager.getSalary()
	getHireDay() -> Employee.getHireDay()
	raiseSalary(double) -> Employee.raiseSalary(double)
	setBonus(double) -> Manager.setBonus(double)
```
在运行时，调用 `e.getSalary()` 的解析过程为：
1. 首先，虚拟机获取「 `e` 的实际类型」的方法表。既可能是 `Employee` 、`Manager` 的方法表，也可能是 `Employee` 类的其他子类的方法表。
2. 接下来，虚拟机搜索定义了 `getSalary()` 签名的类。此时，虚拟机已经知道应该调用哪个
方法。
3. 最后，虚拟机调用方法。

**动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展**。假设增加一个新类 `Executive` ，并且变量 `e` 有可能引用这个类的对象，我们不需要对包含调用 `e.getSalary()` 的代码进行重新编译。如果 `e` 恰好引用一个 `Executive` 类的对象，就会自动地调用 `Executive.getSalary()` 方法。
> 警告：==在覆盖一个方法的时候，子类方法不能低于超类方法的可见性==。特别是，如果超类方法是 `public` ，子类方法一定要声明为 `public` 。经常会发生这类错误：在声明子类方法的时候，遗漏了 `public` 修饰符。此时，编译器将会报错，指出你试图提供更严格的访问权限。

## 5.1.7 阻止继承：`final` 类和方法
有时候，我们可能希望阻止人们利用某个类定义子类。**不允许扩展的类被称为 `final` 类。如果在定义类的时候，使用了 `final` 修饰符就表明这个类是 `final` 类**。例如，假设希望阻止人们定义 `Executive` 类的子类，就可以在定义这个类的时候使用 `final` 修饰符声明。声明格式如下所示：
```java
public final class Executive extends Manager {
	...
}
```
**类中的特定方法也可以被声明为 `final` 。如果这样做，子类就不能覆盖这个方法**（ `final` 类中的所有方法自动地成为 `final` 方法）。例如：
```java
public class Employee {
	public final String getName() {
		...
	}
}
```
> 注释：前面曾经说过，字段也可以被声明为 `final` 。**对于 `final` 字节来说，构造对象之后就不允许改变它们的值了** *A final field cannot be changed after the object has been constructed* 。不过，**如果将一个类声明为 `final` ，只有其中的方法自动地成为 `final` ，而不包括字段**。

将方法或类声明为 `final` 的主要目的是：**确保它们不会在子类中改变语义**。例如，`Calendar` 类中的 `getTime` 和 `setTime` 方法都声明为 `final` 。这表明 `Calendar` 类的设计者负责实现 `Date` 类与日历状态之间的转换，而不允许子类处理这些问题。同样地，`String` 类也是 `final` 类，这意味着不允许任何人定义 `String` 的子类。换言之，如果有一个 `String` 的引用，它引用的一定是一个 `String` 对象，而不可能是其他类的对象。

有些程序员认为：除非有足够的理由使用多态性，否则应该将所有的方法都声明为 `final` 。事实上，在C++和C#中，如果没有特别地说明，所有的方法都不具有多态性。这两种做法可能都有些偏激。我们提倡在设计类层次时，**仔细地思考应该将哪些方法和类声明为 `final`** 。

在早期的Java中，有些程序员为了避免动态绑定带来的系统开销、而使用 `final` 关键字。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为称为**内联** `inlining` 。例如，内联调用 `e.getName()` 将被替换为访问 `e.name` 字段。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用分支转移会扰乱预取指令的策略，所以，CPU不喜欢分支。然而，如果 `getName` 在另外一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。

幸运的是，**虚拟机中的即时编译器比传统编译器的处理能力强得多**。这种编译器可以准确地知道类之间的继承关系，并能检测出是否有类确实覆盖了给定的方法。==如果方法很简短、被频繁调用、且确实没有被覆盖，那么即时编译器就会将这个方法进行内联处理==。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖，那么将会发生什么情况呢？ 优化器将取消对覆盖方法的内联。这个过程很慢，但却很少发生。
## 5.1.8 强制类型转换
第3章曾经讲过，将一个类型强制转换成另外一个类型的过程被称为**强制类型转换**。Java为强制类型转换提供了一种特殊的表示法。例如，下面将表达式 `x` 的值转换成整数类型，舍弃了小数部分：
```java
double x = 3.405;
int nx = (int) x;
```
正像有时候需要将浮点数转换成整型数值一样，有时候也可能需要将某个类的对象引用转换成另外一个类的对象引用。要完成对象引用的强制类型转换，转换语法与数值表达式的强制 类型转换类似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。例如：
```java
Manager boss = (Manager) staff[0]:
```
**进行强制类型转换的唯一原因是：要在暂时忽视对象的实际类型之后，使用对象的全部功能**。例如，在 `managerTest` 类中，由于某些元素是普通雇员，所以 `staff` 数组必须是 `Employee` 对象的数组。我们需要将数组中引用经理的元素复原成 `Manager` 对象，以便能够访问新增加的所有变量（需要注意，在第一节示例代码中，为了避免强制类型转换，我们做了一些特别的处理，即将 `boss` 变量存入数组之前，先将它初始化为一个 `Manager` 对象。为了设置经理的奖金，必须使用正确的类型）。

大家知道，==在Java中，每个对象变量都有一个类型。类型描述了这个变量所引用的、以及能够引用的对象类型==。例如，`staff[i]` 引用一个 `Employee` 对象（因此它还可以引用 `Manager` 对象。

将一个值存入变量时，编译器将检查是否允许该操作（检查是否承诺过多）。**将一个子类的引用赋给一个超类变量，编译器是允许的**。但将一个超类的引用赋给一个子类变量，就承诺过多了，必须进行强制类型转换，这样才能通过运行时的检査。如果试图在继承链上进行向下的类型转换，并且“谎报”有关对象包含的内容，会发生什么情况呢？
```java
Manager boss = (Manager)staff[1]; // Error
```
运行这个程序时，Java运行时系统将报告这个错误（它注意到你的承诺不符），并产生一个 `ClassCastException` 异常。如果没有捕获这个异常，那么程序就会终止。因此，应该养成这样一个良好的程序设计习惯：**在进行类型转换之前，先查看是否能成功地转换。为此只需要简单地使用 `instanceof` 操作符就可以实现**。例如：
```java
if (staff[1] instanceof Manager) {
	boss = (Manager) staff[1]:
}
```
最后，**如果这个类型转换不可能成功，编译器就不会让你完成这个转换**。例如，下面这个类型转换将会产生编译错误，这是因为 `String` 不是 `Employee` 的子类。
```java
String c = (String) staff[1];
```
综上所述：
- 只能在继承层次内进行类型转换。
- 在将超类转换成子类之前，应该使用 `instanceof` 进行检查。

> 注释：如果 `x` 为 `null` ，进行下列测试 `x instanceof C` 不会产生异常，只是返回 `false` 。之所以这样处理是因为 `null` 没有引用任何对象，当然也不会引用 `C` 类型的对象。

实际上，通过强制类型转换来调整对象的类型、通常并不是一种好的做法。在我们的示例中，大多数情况并不需要将 `Employee` 对象强制转换成 `Manager` 对象，两个类的对象都能够正确地调用 `getSalary` 方法，这是因为**实现多态性的动态绑定机制能够自动地找到相应的方法**。

只有在使用 `Manager` 中特有的方法时，才需要进行强制类型转换，例如 `setBonus` 方法。如果鉴于某种原因，发现需要在 `Employee` 对象上调用 `setBonus` 方法，那么就应该自问超类的设计是否合理。可能需要重新设计一下超类、并添加 `setBonus` 方法，这才是正确的选择。请记住，只要没有捕获 `ClassCastException` 异常，程序就会终止执行。**一般情况下，最好尽量少用强制类型转换和 `instanceof` 运算符**。
> C++注释：Java使用的强制类型转换语法来源于C语言“以往糟糕的日子”，但处理过程却有些像C++的 `dynamic_cast` 操作。例如，
> ```java
> Manager boss = (Manager) staff[1]; // Java
> ```
> 等价于：
> ```cpp
> Manager* boss = dynamic_cast<Manager*>(staff[1]); // C++
> ```
> 它们之间只有一点重要的区别：当强制类型转换失败时，Java不会生成一个 `null` 对象，而是抛出一个异常。从这个意义上讲，有点像C++中的**引用 `reference` 转换**。真是令人生厌。在C++中，可以在一个操作中完成类型测试和类型转换。
> ```cpp
> Manager* boss = dynamic_cast<Manager*>(staff[1]); // C++
> if (boss != NULL) ...
> ```
> 而在Java中，需要将 `instanceof` 运算符和强制类型转换组合起来使用：
> ```java
> if (staff[1] instanceof Manager) {
>     Manager boss = (Manager) staff[1];
> }
> ```

## 5.1.9 抽象类
如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更具一般性，人们只将它作为派生其他类的基类，而不是用来构造想使用的特定的实例。例如，考虑扩展 `Employee` 类层次结构。员工是一个人，学生也是一个人。下面将类 `Person` 和类 `Student` 添加到类的层次结构中。图5-2是这三个类之间的继承关系层次图。
![图5-2 Person与子类的继承图](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209162203680.png)
为什么要花费精力进行这样高层次的抽象呢？每个人都有一些诸如姓名这样的属性。学生与员工都有姓名属性，因此可以将 `getName` 方法放在位于继承关系较高层次的通用超类中。

现在，再增加一个 `getDescription` 方法，它可以返回对一个人的简短描述。例如：
```java
an employee with a salary of $50,000.00
a student majoring in computer science
```
在 `Employee` 类和 `Student` 类中实现这个方法很容易。但是在 `Person` 类中应该提供什么内容呢？ 除了姓名之外，`Person` 类一无所知。当然，可以让 `Person.getDescription()` 返回一个空字符串。然而，还有一个更好的方法，就是**使用 `abstract` 关键字，这样就完全不需要实现这个方法了**。
```java
public abstract String getDescription();
// no implementation required
```
==为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的==。
```java
public abstract class Person {
	public abstract String getDescription();
}
```
**除了抽象方法之外，抽象类还可以包含具体字段和具体方法**。例如，`Person` 类还保存着姓名和一个返回姓名的具体方法。
```java
public abstract class Person {
	private String name;
	
	public Person(String name) {
		this.name = name;
	}
	
	public abstract String getDescription();

	public String getName() {
		return name;
	}
}
```

> 提示：许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的字段和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中。

抽象方法充当着占位方法的角色，它们在子类中具体实现。**扩展抽象类可以有两种选择**。一种是在子类中保留「抽象类中的部分或所有抽象方法」仍未定义，这样就必须将子类也标记为抽象类；另一种是定义全部的方法，这样一来，子类就不是抽象的了。

例如，通过扩展抽象 `Person` 类，并实现 `getDescription` 方法来定义 `Student` 类。由于在`Student` 类中不再含有抽象方法，所以不必将这个类声明为抽象类。**类即使不含抽象方法，也可以将类声明为抽象类**。

**抽象类不能被实例化**。也就是说，如果将一个类声明为 `abstract` ，就不能创建这个类的对
象。例如，下列表达式是错误的，但可以创建一个具体子类的对象。
```java
new Person("Vinee Vu")
```
需要注意，==可以定义一个抽象类的**对象变量**，但它只能引用非抽象子类的对象==。例如，
```java
Person p = new Student("Vinee Vu" ，"Economics");
```
这里的 `p` 是一个抽象类 `Person` 的变量，它引用了一个非抽象子类 `Student` 的实例。
> C++注释：**在C++中，有一种在尾部用 `=0` 标记的抽象方法，称为纯虚函数**。例如：
> ```cpp
> class Person { // C++
> public:
>     virtual string getDescription() = 0;
> }
> ```
> 如果至少有一个纯虚函数，这个C++类就是抽象类。**在C++中，没有提供用于表示抽象类的特殊关键字**。

下面定义一个扩展抽象类 `Person` 的具体子类 `Student` ：
```java
public class Student extends Person {
	private String major;
	public Student(String name, String major) {
		super(name);
		this.major = major;
	}
	public String getDescription() {
		return "a student majoring in " + major;
	}
}
```
在 `Student` 类中定义了 `getDescription` 方法。因此，在 `Student` 类中的全部方法都是具体的，这个类不再是抽象类。

在程序 `Inheritance/abstractClasses/PersonTest.java` 中定义了抽象超类 `Person` 和两个具体子类 `Employee` 和 `Student` 。下面将雇员和学生对象填充到 `Person` 引用数组。
```java
Person[] people = new Person[2];
people[0] = new Enp1oyee(...);
people[1] = new Student(...);
```
然后，输出这些对象的姓名和信息描述：
```java
for (Person p : people)
	System.out.println(p.getName() + ", " + p.getDescription());
```
有些人可能对 `p.getDescription()` 这个调用感到困惑——这不是调用了一个没有定义的方法吗？请牢记，**由于不能构造抽象类 `Person` 的对象，所以变量 `p` 永远不会引用 `Person` 对象**，而是引用诸如 `Employee` 或 `Student` 这样的具体子类对象，而这些对象中都定义了 `getDescription` 方法。
```java
// Inheritance/abstractClasses/PersonTest.java
package abstractClasses;

/**
 * This program demonstrates abstract classes.
 */
public class PersonTest {
	public static void main(String[] args) {
		var people = new Person[2];
		
		// file the people array with Student and Employee objects
		people[0] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
		people[1] = new Student("Maria Morris", "computer science");
		
		// print out names and demonstrates of all Person objects
		for (Person p : people)
			System.out.println(p.getName() + ", " + p.getDescription());
	}
}
```
```java
// Inheritance/abstractClasses/Person.java
package abstractClasses;

public abstract class Person {
	public abstract String getDescription();
	private String name;
	
	public Person(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}
}
```
```java
// Inheritance/abstractClasses/Employee.java
package abstractClasses;

import java.time.*;

public class Employee extends Person {
	private double salary;
	private LocalDate hireDay;
	
	public Employee(String name, double salary, int year, int month, int day) {
		super(name);
		this.salary = salary;
		hireDay = LocalDate.of(year, month, day);
	}
	
	public double getSalary() {
		return salary;
	}
	
	public LocalDate getHireDay() {
		return hireDay;
	}
	
	public String getDescription() {
		return String.format("an employee with a salary of $%.2f", salary);
	}
	
	public void raiseSalary(double byPercent) {
		double raise = salary * byPercent / 100;
		salary += raise;
	}
}
```
```java
// Inheritance/abstractClasses/Student.java
package abstractClasses;

public class Student extends Person {
	private String major;
	
	/**
	 * @param name the student's name
	 * @param major the student's major
	 */
	public Student(String name, String major) {
		// pass name to superclass constructor
		super(name);
		this.major = major;
	}
	
	public String getDescription() {
		return "a student majoring in " + major;
	}
}
```
运行结果如下所示：
```java
Harry Hacker, an employee with a salary of $50000.00
Maria Morris, a student majoring in computer science
```
是否可以省略 `Person` 超类中的抽象方法，而仅在 `Employee` 和 `Student` 子类中定义`getDescription` 方法呢？ 如果这样的话，就不能通过变量 `p` 调用 `getDescription` 方法了。**编译器只允许调用在类中声明的方法**。

在Java中，抽象方法是一个重要的概念。在接口 `interface` 中将会看到更多的抽象方法。有关接口的详细介绍参看第6章。
## 5.1.10 受保护访问
大家都知道，最好将类中的字段标记为 `private` 、而将方法标记为 `public` 。**任何声明为 `private` 的内容对其他类都是不可见的**。前面已经看到，**这对于子类来说也完全适用，即子类也不能访问超类的私有字段**。

然而有些时候，我们可能==希望超类中的某些方法只允许被子类访问，或更少见的、可能希望允许子类的方法访问超类的某个字段==。为此，需要将这些类方法或字段声明为受保护的 `protected` 。例如，如果将超类 `Employee` 中的 `hireDay` 声明为 `proteced` ，而不是私有的，`Manager` 中的方法就可以直接地访问它。

**在Java中，保护字段只能由同一个包中的类访问** *a protected field is accessible by any class in the same package* 。现在考虑一个 `Administrator` 子类，这个子类在另一个不同的包中，**`Administrator` 类中的方法只能查看 `Administrator` 对象自己的 `hireDay` 字段，而不能访问其他 `Employee` 对象中的这个字段**。这种限制有助于避免滥用受保护机制，使得子类只能获得访问受保护字段的权利。

**在实际应用中，要谨慎使用 `protected` 字段**。假设你设计的类要提供给其他程序员使用，而在设计这个类时设置了一些受保护字段。你不知道的是，其他程序员可能会由这个类再派生出新类，并开始访问你的受保护字段。在这种情况下，如果你需要修改这个类的实现，就必须通知所有使用这个类的程序员。这违背了OOP提倡的数据封装原则。

**受保护的方法更具有实际意义**。如果需要限制某个方法的使用，就可以将它声明为 `protected` 。这表明子类（可能很熟悉**祖先类**）得到信任，可以正确地使用这个方法，而其他类则不行。

这种方法的一个最好的示例，就是 `Object` 类中的 `clone` 方法，有关的详细内容参看第6章。
> C++注释：事实上，**Java中的受保护部分对所有子类及同一个包中的所有其他类都可见**。这与C++中的保护机制稍有不同，Java 中的 protected 概念要比 C++ 中的安全性差。

下面归纳一下，Java控制可见性的4个访问控制修饰符（可见性由高到低）：
1. 仅对本类可见 `private`（最确定的）。
2. 对本包可见（更别说本包中的子类）——默认（很遗憾），不需要修饰符。
3. 对本包和所有子类可见 `protected` *Accessible in the package and all subclasses* 。
4. 对所有类可见 `public` 。

对于 `protected` ，我的实验是：
1. 它对本包的类（包括子类）可见（涵盖了包访问），其中子类可以访问自己的 `protected` 部分，还能访问其祖先类对象的 `protected` 部分；其他类也可访问子类和其祖先类的 `protected` 部分。
2. 它对其他包的所有子类可见，但子类不能访问其**祖先类对象**的 `protected` 部分（即字段）。

---
# 5.2 `Object` ：所有类的超类
`Object` 类是Java中所有类的始祖，**在Java中每个类都是由它扩展而来的**。但是并不需要这样写：
```java
public class Employee extends Object
```
**如果没有明确地指出超类，`Object` 就被认为是这个类的超类**。由于在Java中每个类都是由 `Object` 类扩展而来的，所以，熟悉这个类提供的所有服务十分重要。本章介绍一些基本的内容，没有提到的部分参看后面章节或在线文档（ `Object` 中有几个方法只在处理并发时才会用到，有关内容参见12章)。
## 5.2.1 `Object` 类型的变量
可以**使用 `Object` 类型的变量引用任何类型的对象**：
```java
Object obj = new EmployeeC'Harry Hacker"，35000);
```
当然，`Object` 类型的变量只能用于作为各种值的一个泛型容器 *generic holder* 。==要想对其中的内容进行具体操作，还需要清楚对象的原始类型，并进行相应的强制类型转换==：
```java
Employee e = (Employee) obj;
```
在Java中，只有基本类型 `primitive types` 不是对象。例如，数值、字符和布尔类型的值都不是对象。**所有的数组类型，不管是对象数组还是基本类型的数组，都扩展了 `Object` 类**。
```java
Employee[] staff = new Employee[10];
obj = staff; // OK
obj = new int[10]; // OK
```
> C++注释：在C++中没有所有类的根类，不过每个指针都可以转换成 `void*` 指针。

## 5.2.1 `equals` 方法
`Object` 类中的 `equals` 方法，用于检测一个对象是否等于另外一个对象。**`Object` 类中实现的 `equals` 方法，将判断两个对象是否具有相同的引用**。如果两个对象具有相同的引用，它们一定是相等的。从这点上看，将其作为默认操作也是合乎情理的。

然而，对于多数类来说，这种判断并没有什么意义。如用这种方式比较两个 `PrintStream` 对象是否相等，并没有多大意义。不过，经常需要基于状态检测对象的相等性 *state-based equality testing* ，如果两个对象有相同的状态，就认为这两个对象是相等的。

例如，如果两个雇员对象的姓名、薪水和雇佣日期都一样，就认为它们是相等的（在实
际的雇员数据库中，比较ID更有意义。主要是利用下面这个示例，演示 `equals` 方法的实现机制）。
```java
public class Employee {
	...
	public boolean equals(Object otherObject) {
		// a quick test to see if the objects are identical
		if (this == otherObject) return true;
		// must return false if the explicit parameter is null
		if (otherObject == null) return false;
		// if the classes don't match, they can't be equal
		if (getClass() != otherObject.getClass()) return false;
	
		// now we know otherObject is a non-null Employee
		Employee other = (Employee) otherObject;
		// test whether the fields have identical values
		return name.equals(other.name) && salary == other.salary
			&& hireDay.equals(other.hireDay);
	}
}
```
**`getClass` 方法将返回一个对象所属的类**，有关这个方法的详细内容稍后介绍。**在检测中，只有在两个对象属于同一个类时，才有可能相等**。
> 提示：**为了防备 `name` 或 `hireDay` 可能为 `null` 的情况，需要使用 `Objects.equals` 方法**。如果两个参数都为 `null` ，`Objects.equals(a, b)` 调用将返回 `true` ；如果其中一个参数为 `null` ，则返回 `false` ；否则，如果两个参数都不为 `null` ，则调用 `a.equals(b)` 。
>  
> 利用这个方法，`Employee.equals` 方法的最后一条语句要改写为：
> ```java
	return Objects.equals(name, other.name) && salary == other.salary
>     && Object.equals(hireDay, other.hireDay);
> ``` 

**在子类中定义 `equals` 方法时，首先调用超类的 `equals`** 。如果检测失败，对象就不可能相等。如果超类中的字段都相等，就需要比较子类中的实例字段。
```java
public class Manager extends Employee
	public boolean equals(Object otherObject) {
		if (!super.equals(otherObject)) return false;
		// super.equals checked that this and otherObject belong to the same class
		Manager other = (Manager) otherObject;
		return bonus == other.bonus;
	}
}
```

## 5.2.2 相等测试与继承
==如果隐式和显式的参数 *implicit and explicit parameters* 不属于同一个类，`equals` 方法将如何处理呢？这是一个很有争议的问题==。在前面的例子中，如果发现类不匹配，`equals` 方法就返冋 `false` 。但是，许多程序员却喜欢使用 `instanceof` 进行检测：
```java
if (!(otherObject instanceof Employee)) return false;
```
这样就允许 `otherObject` 属于一个子类的情况 *This leaves open the possibility that otherObject can belong to a subclass* ，但是这种方法可能招致一些麻烦。**建议不要使用这种处理方式**。Java语言规范要求 `equals` 方法具有下面的特性：
1. **自反性** *reflexive* ：对于任何**非空引用** `x` ，`x.equals(x)` 应该返回 `true` ；
2. **对称性** *symmetric* ：对于任何引用 `x` 和 `y` ，当且仅当 `y.equals(x)` 返回 `true` ，`x.equals(y)` 返回 `true` 。
3. **传递性** *transitive* ：对于任何引用 `x, y, z` ，如果 `x.equals(y)` 返回 `true` ，`y.equals(z)` 返回 `true` ，`x.equals(z)` 也应该返回 `true` 。
4. **一致性** *consistent* ：如果 `x` 和 `y` 引用的对象没有发生变化，反复调用 `x.equals(y)` 应该返回同样的结果。
5. 对于任意**非空引用** `x` ，`x.equals(null)` 应该返回 `false` 。

这些规则十分合乎情理，从而避免了类库实现者在查找数据结构中的一个元素时、还要考虑
调用 `x.equals(y)` ，还是调用 `y.equals(x)` 的问题。

然而，==就对称性规则来说，当参数不属于同一个类的时候会有一些微妙的结果==。请看这个调用：`e.equals(m)` ——这里的 `e` 是一个 `Employee` 对象，`m` 是一个 `Manager` 对象，并且两个对象具有相同的姓名、薪水和雇佣日期。如果在 `Employee.equals` 中用 `instanceof` 进行检测，这个调用将返回 `true` ，然而这意味着反过来调用：`m.equals(e)` ——也需要返回 `true` 。对称性规则不允许这个方法调用返回 `false` ，或者抛出异常。

这就使得 `Manager` 类受到了束缚。这个类的 `equals` 方法必须愿意将自己与任何一个 `Employee` 对象进行比较，而不考虑经理特有的那部分信息！ 猛然间这让人感觉 `instanceof`  测试并不是那么好。

**某些作者还认为 `getClass` 检测是有问题的，因为它违反了替换原则**。有一个经常提到的例子，就是 `AbstractSet` 类的 `equals` 方法，它将检测两个集合是否有相同的元素。`AbstractSet` 类有两个具体子类：`TreeSet` 和 `HashSet` ，它们分别使用不同的算法实现查找集合元素的操作。**但无论集合采用何种方式实现，你肯定希望能比较任意的两个集合**。

然而，**集合是相当特殊的一个例子，应该将 `AbstractSet.equals` 声明为 `final` ，这是因为没有任何一个子类需要重定义集合相等的语义**（事实上，这个方法并没有被声明为 `final` 。这样做是为了让子类实现更有效的算法、来对集合完成相等性检测）。

就现在看来，有两种完全不同的情形：
- **如果子类可以有自己的相等性概念**，则对称性需求将强制采用 `getClass` 进行检测；
- **如果由超类决定相等性概念**，那么就可以使用 `instanceof` 进行检测，这样可以**在不同子类的对象之间进行相等的比较**。

在雇员和经理的例子中，只要对应的字段相等，就认为两个对象相等。如果两个 `Manager` 对象所对应的姓名、薪水和雇佣日期均相等，而奖金不相等，就认为它们是不相同的，因
此，我们使用 `getClass` 检测。

但是，假设使用雇员的 `ID` 作为相等的检测标准，并且这个相等的概念适用于所有的子类，就可以使用 `instanceof` 进行检测，并**应该将 `Employee.equals` 声明为 `final`** 。
> 注释：在标准Java库中包含150多个 `equals` 方法的实现，包括使用 `instanceof` 检测、调用 `getClass` 检测、捕获 `ClassCastException` 或者什么也不做。可以查看 `java.sql.Timestamp` 类的API文档，在这里实现人员不无尴尬地指出，他们使自己陷入了困境。`Timestamp` 类继承自 `java.util.Date` ，而后者的 `equals` 方法使用了一个 `instanceof` 测试，这样一来就无法覆盖实现 `equals` ，使之同时做到对称且正确。

下面给出编写一个完美的 `equals` 方法的建议：
1. 显式参数命名为 `otherObject` ，稍后需要将它强制转换成另一个叫做 `other` 的变量。
2. 检测 `this` 与 `otherObject` 是否引用同一个对象：
   ```java
   if (this == otherObject) return true;
   ```
这条语句只是一个优化。实际上，这是一种经常采用的形式。因为检查身份要比逐个比较字段开销小。
3. 检测 `otherObject` 是否为 `null` ，如果为 `null` ，返回 `false` 。这项检测是很必要的。
	```java
	if (otherObject == null) return false;
	```
4. 比较 `this` 与 `otherObject` 是否属于同一个类。**如果 `equals` 的语义在每个子类中有所改变，就使用 `getClass` 检测**：
   ```java
   if (getClass() != otherObject.getClass()) return false;
   ```
	**如果所有的子类都拥有统一的相等性语义，就使用 `instanceof` 检测**：
   ```java
   if (!(otherObject instanceof ClassName)) return false;
   ```
5. 将 `otherObject` 转换为相应的类类型变量：
   ```java
   ClassName other = (ClassName) otherObject;
   ```
6. 现在根据相等性概念的要求、来比较字段。**使用 `==` 比较基本类型字段，使用 `Objects.equals` 比较对象字段**。如果所有的字段都匹配，就返回 `true` ；否则返回 `false` 。
   ```java
   return field1 == other.field1 && Objects.equals(field2, other.field2)
	   && ...;
   ```
  **如果在子类中重新定义 `equals` ，就要在其中包含一个调用 `super.equals(other)`** 。

> 提示：对于数组类型的字段，可以使用静态的 `Arrays.equals` 方法检测相应的数组元素是否相等。

> 警告：下面是实现 `equals` 方法时的一种常见的错误。可以找到其中的问题吗？
> ```java
> public class Employee {
> 	public boolean equals(Employee other) {
> 		return other != null 
> 			&& getClass() == other.getClass()
> 			&& Objects.equals(name, other.name)
> 			&& salary == other.salary
> 			&& Objects.equals(hireDay, other.hireDay);
> 	}
> }
> ```
> **这个方法声明的显式参数类型是 `Employee` 。因此，它并没有覆盖 `Object` 类的 `equals` 方法，而是定义了一个完全无关的方法**。
> 
> 为了避免发生这种错误，可以**使用 `@Override` 标记「要覆盖超类方法的那些子类方法」**：
> ```java
> @Override 
> public boolean equals(Object other)
> ```
> 如果出现了错误，并且正在定义一个新方法，编译器就会报告一个错误。例如，假设将下面的声明添加到 `Employee` 类中：
> ```java
> @Override 
> public boolean equals(Employee other)
> ```
> 就会看到一个错误报告，因为这个方法并没有覆盖超类 `Object` 中的任何方法。

> [API] `java.util.Arrays` 1.2
> - `static Boolean equals(xxx[] a, xxx[] b)` 5.0
> 如果两个数组长度相同，并且在对应的位置上数据元素也相同，将返回 `true` 。数组的元素类型可以是 `Object, int, long, short, char, byte, boolean, float, double` 。

> [API] `java.util.Objects` 7
> - `static boolean equals(Object a, Object b)`
> 如果 `a` 和 `b` 都为 `null` ，返回 `true` ；如果只有其中之一为 `null` ，则返回 `false` ；否则返回 `a.equals(b)` 。

## 5.2.3 `hashCode` 方法
散列码 `hash code` 是由对象导出的一个整型值。散列码是没有规律的。如果 `x` 和 `y` 是两个不同的对象，`x.hashCode()` 与 `y.hashCode()` 基本上不会相同。在表5-1中列出了几个通过调用 `String` 类的 `hashCode` 方法得到的散列码。
![表5-1 hashCode方法得到的散列码](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209191114875.png)

`String` 类使用下列算法计算散列码：
```java
int hash = 0;
for (int i = 0; i < length(); i++)
	hash = 31 * hash + charAt(i);
```

由于 `hashCode` 方法定义在 `Object` 类中，因此**每个对象都有一个默认的散列码，其值为对象的存储地址**。来看下面这个例子。
```java
String s = "Ok";
StringBuilder sb = new StringBuilder(s);
System.out.println(s.hashCode() + " " + sb.hashCode());
String t = new String("Ok");
StringBuilder tb = new StringBuilder(t);
System.out.println(t.hashCode() + " " + tb.hashCode());
```
表5-2列出了结果。
![表5-2 String和String Builder的散列码](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209191402288.png)

注意，字符串 `s` 与 `t` 拥有相同的散列码，这是因为字符串的散列码是由**内容**导出的。而字符串构建器 `sb` 与 `tb` 却有着不同的散列码，这是因为在 `StringBuilder` 类中没有定义 `hashCode` 方法，它的散列码是由 `Object` 类的默认 `hashCode` 方法导出的对象存储地址。

如果重新定义了 `equals` 方法，就必须为用户重新定义 `hashCode` 方法，以便用户可以将对象插入到散列表中（有关散列表的内容将在9章中讨论）。

`hashCode` 方法应该返回一个整型数值（也可以是负数）。**要合理地组合实例字段的散列码，以便能够让各个不同的对象产生的散列码更加均匀**。例如，下面是 `Employee` 类的 `hashCode` 方法。
```java
public class Employee {
	public int hashCode() {
		return 7 * name.hashCode()
			+ 11 * new Double(salary).hashCode()
			+ 13 * hireDay.hashCode();
		}
	}
	...
}
```
不过，还可以做得更好。首先，**最好使用 `null` 安全的方法 `Objects.hashCode`** 。如果其参数为 `null` ，这个方法会返回0，否则返回对参数调用 `hashCode` 的结果。另外，**使用静态方法 `Double.hashCode` 来避免创建 `Double` 对象**：
```java
public int hashCode() {
	return 7 * Objects.hashCode(name)
		+ 11 * Double.hashCode(salary)
		+ 13 * Objects.hashCode(hireDay);
}
```
还有更好的做法是，**需要组合多个散列值时，可以调用 `Objects.hash` 并提供多个参数**。这个方法会对各个参数调用 `Objects.hashCode` ，并组合这些散列值。这样 `Employee.hashCode` 方法可以简单地写为：
```java
public int hashCode() {
	return Objects.hash(name, salary, hireDay);
}
```
**`equals` 与 `hashCode` 的定义必须相容**：如果 `x.equals(y)` 返回 `true` ，那么 `x.hashCode()`  就必须与 `y.hashCode()` 具有相同的值。例如，如果用定义的 `Employee.equals` 比较雇员的ID，那么 `hashCode` 方法就需要散列 ID，而不是雇员的姓名或存储地址。
> 提示：如果存在数组类型的字段，那么可以使用静态的 `Arrays.hashCode` 方法计算一个散列码，这个散列码由数组元素的散列码组成。

> [API] `java.util.Object` 1.0
> - `int hashCode()`
> 返回对象的散列码。散列码可以是任意的整数，包括正数或负数。**两个相等的对象要求返回相等的散列码**。

> [API] `java.util.Objects` 7
> - `static int hash(Object... objects)`
> 返回一个散列码，由提供的所有对象的散列码组合而得到。
> - `static int hashCode(Object a)`
> 如果 `a` 为 `null` 则返回0，否则返回 `a.hashCode()` 。

> [API] `java.lang.(Integer|Long|Short|Byte|Double|Float|Character|Boolean)` 1.0
> - `static int hashCode(xxx value) 8
> 返回给定值的散列码，这里的 `xxx` 是对应给定包装器类型的基本类型。

> [API] `java.util.Arrays` 1.2
> - `static int hashCode(xxx[] a)` 5.0
> 计算数组 `a` 的散列码。组成这个数组的元素类型可以是 `Object, int, long, short, char, byte, boolean, float, double` 。

## 5.2.4 `toString` 方法
在 `Object` 中还有一个重要的方法，就是 `toString` 方法，它用于返回「表示对象值的一个字符串」。下面是一个典型的例子。`Point` 类的 `toString` 方法将返回下面这样的字符串：
```java
java.awt.Point[x=10,y=20]
```
绝大多数（但不是全部）的 `toString` 方法都遵循这样的格式：类的名字，随后是一对方括号括起来的字段值。下面是 `Employee` 类中的 `toString` 方法的实现：
```java
public String toString() {
	return "Employee[name=" + name
		+ ",salary=" + salary
		+ ",hireDay=" + hireDay
		+ "]";
}
```
实际上，还可以设计得更好一些。**最好通过调用 `getClass().getName()` 获得类名的字符串，而不要将类名硬加到 `toString`** ，这样的 `toString` 方法也可以供子类调用。
```java
public String toString() {
	return getClass().getName()
		+ "[name=" + name
		+ ",salary=" + salary
		+ ",hireDay=" + hireDay
		+ "]";
}
```
当然，设计子类的程序员也应该定义自己的 `toString` 方法，并将子类字段的描述添加进去。**如果超类使用了 `getClass().getName()` ，那么子类只要调用 `super.toString()` 就可以了**。如下面是 `Manager` 类中的 `toString` 方法：
```java
public class Manager extends Employee {
	public String toString() {
		return super.toString() +
			"[bonus=" + bonus + "]";
	}
}
```
现在，Manager 对象将打印输出如下所示的内容：
```java
Manager[name=...,salary=...,hireDay=...][bonus=...]
```
随处可见 `toString` 方法的主要原因是：只要对象与一个字符串通过操作符“+”连接起来，Java编译器就会自动地调用 `toString` 方法，以便获得这个对象的字符串描述。例如，
```java
Point p = new Point(10，20);
String message = "The current position is " + p;
// automatically invokes p.toStringO
```

> 提示：在调用 `x.toString()` 的地方可以用 `"" + x` 替代。这条语句将一个空串与 `x` 的字符串表示（也就是 `x.toString()` ）相连接。与 `toString` 不同的是，如果 `x` 是基本类型，这条语句照样能够执行。

如果 `x` 是任意一个对象，并调用 
```java
System.out.println(x);
```
`println` 方法就会直接地调用 `x.toString()` ，并打印输出得到的字符串。

**`Object` 类定义了 `toString` 方法，用来打印对象所属的类名和散列码**。例如，调用
```java
System.out.println(System.out)
```
将输出下列内容：
```java
java.io.PrintStream@2f6684
```
之所以得到这样的结果，是因为 `PrintStream` 类的设计者没有覆盖 `toString` 方法。

> 警告：令人烦恼的是，**数组继承了 `Object` 类的 `toString` 方法。更有甚者，数组类型将按照旧的格式打印**。例如：
> ```java
> int[] luckyNumbers = {2, 3, 5, 7, 13};
> String s = "" + luckyNumbers;
> ```
> 会生成字符串 `"[I@la46e30"` （前缀 `[I` 表明是一个整型数组）。修正的方法是**调用静态方法 `Arrays.toString`** 。代码：
> ```java
> String s = Arrays.toString(luckyNumbers);
> ```
> 将生成字符串 `"[2,3,5,7,11,13]"` 。
> 
> **要想打印多维数组（即数组的数组）则需要调用 `Arrays.deepToString` 方法**。

**`toString` 方法是一种非常有用的调试工具**。在标准类库中，许多类都定义了 `toString` 方法，以便用户能获得一些有关对象状态的必要信息。像下面这样显示日志信息非常有益：
```java
System.out.println("Current position = " + position);
```
在第7章中将可以看到，更好的解决方法是：
```java
Logger.global.info("Current position = " + position);
```

> 提示：强烈建议为「自定义的每一个类」增加 `toString` 方法。这样做不仅自己受益，而且所有使用这个类的程序员也会从这个日志记录支持中受益匪浅。

程序 `Inheritance/equals/EqualsTest.java` 实现了 `Employee` 类和 `Manager` 类的 `equals, hashCode, toString` 方法。
```java
// Inheritance/equals/EqualsTest.java
package equals;

/**
 * This program demonstrates the equals method.
 */
public class EqualsTest {
	public static void main(String[] args) {
		var alice1 = new Employee("Alice Adams", 75000, 1987, 12, 15);
		var alice2 = alice1;
		var alice3 = new Employee("Alice Adams", 75000, 1987, 12, 15);
		var bob = new Employee("Bob Brandson", 50000, 1989, 10, 1);
		
		System.out.println("alice1 == alice2: " + (alice1 == alice2));
		System.out.println("alice1 == alice3: " + (alice1 == alice3));
		System.out.println("alice1.equals(alice3): " + alice1.equals(alice3));
		System.out.println("alice1.equals(bob): " + alice1.equals(bob));
		
		System.out.println("bob.toString(): " + bob);
		
		var carl = new Manager("Carl Cracker", 80000, 1987, 12, 15);
		var boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);
		boss.setBonus(5000);
		System.out.println("boss.toString(): " + boss);
		System.out.println("carl.equals(boss): " + carl.equals(boss));
		
		// the answer of equals() must be compatible with hashCode()
		System.out.println("alice1.hashCode(): " + alice1.hashCode());
		System.out.println("alice3.hashCode(): " + alice3.hashCode());
		
		System.out.println("bob.hashCode(): " + bob.hashCode());
		
		System.out.println("carl.hashCode(): " + carl.hashCode());
	}
}
```
```java
// Inheritance/equals/Employee.java
package equals;

import java.time.*;
import java.util.Objects;

public class Employee {
	private String name;
	private double salary;
	private LocalDate hireDay;
	
	public Employee(String name, double salary, int year, int month, int day) {
		this.name = name;
		this.salary = salary;
		hireDay = LocalDate.of(year, month, day);
	}
	
	public String getName() {
		return name;
	}
	
	public double getSalary() {
		return salary;
	}
	
	public LocalDate getHireDay() {
		return hireDay;
	}
	
	public void raiseSalary(double byPercent) {
		double raise = salary * byPercent / 100;
		salary += raise;
	}
	
	public boolean equals(Object otherObject) {
		// a quick test to see if the objects are identical
		if (this == otherObject) return true;
		
		// must return false if the explicit parameter is null
		if (otherObject == null) return false;
		
		// if the classes don't match, they can't be equal
		System.out.println(getClass() + " " + otherObject.getClass());
		if (getClass() != otherObject.getClass()) return false;
		
		// now we know otherObject is a non-null Employee
		var other = (Employee) otherObject;
		
		// test whether the fields have identical values
		return Objects.equals(name, other.name) && salary == other.salary
			&& Objects.equals(hireDay, other.hireDay);
	}
	
	public int hashCode() {
		return Objects.hash(name, salary, hireDay);
	}
	
	public String toString() {
		return getClass().getName() + "[name=" + name + ",salary=" + salary 
			+ ",hireDay=" + hireDay + "]";
	}
}
```
```java
// Inheritance/equals/Manager.java
package equals;

public class Manager extends Employee {
	private double bonus;
	
	public Manager(String name, double salary, int year, int month, int day) {
		super(name, salary, year, month, day);
		bonus = 0;
	}
	
	public double getSalary() {
		double baseSalary = super.getSalary();
		return baseSalary + bonus;
	}
	
	public void setBonus(double bonus) {
		this.bonus = bonus;
	}
	
	public boolean equals(Object otherObject) {
		if (!super.equals(otherObject)) return false;
		var other = (Manager) otherObject;
		// super.equals checked that this and other belong to the same class
		return bonus == other.bonus;
	}
	
	public int hashCode() {
		return java.util.Objects.hash(super.hashCode(), bonus);
	}
	
	public String toString() {
		return super.toString() + "[bonus=" + bonus + "]";
	}
}
```
运行结果如下，也可知 **`getClass` 方法只会返回当前类的 `Class` 对象、而非超类**：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209231308367.png)

> [API] `java.lang.Object` 1.0
> - `Class getClass()`
> 返回包含对象信息的类对象。稍后看到Java提供了**类的运行时表示**，它的内容被封装在 `Class` 类中。
> - `boolean equals(Object otherObject)`
> 比较两个对象是否相等，如果两个对象指向同一块存储区域，方法返回 `true` ；否则方法返回 `false` 。在自定义的类中，应该覆盖这个方法。
> - `String toString()`
> 返冋表示该对象值的字符串。在自定义的类中，应该覆盖这个方法。

> [API] `java.lang.Class` 1.0
> - `String getName()`
> 返回这个类的名字。
> - `Class getSuperclass()`
> 以 `Class` 对象的形式返回这个类的超类。

---
# 5.3 泛型数组列表
~~在许多程序设计语言中，特别在C++中，必须在编译时就确定整个数组的大小。程序员对此十分反感，因为这样做将迫使程序员做出一些不情愿的折中。例如，在一个部门中有多少雇员？ 肯定不会超过100人。一旦出现一个拥有150名雇员的大型部门呢？ 愿意为那些仅有10名雇员的部门浪费90名雇员占据的存储空间吗？（这点反驳的不是很好！）~~

在Java中，情况就好多了。它允许在运行时确定数组的大小。
```java
int actualSize = ...;
Employee[] staff = new Employee[actualSize];
```
当然，这段代码并没有完全解决「运行时动态更改数组」的问题。一旦确定了数组的大小，改变它就不太容易了。在Java中，解决这个问题最简单的方法是使用Java中另外一个类，名为 `ArrayList` 。它类似数组，但在添加或删除元素时，它能自动地调整数组容量，而不需要为此编写任何代码。

**`ArrayList` 是一个有类型参数 `type parameter` 的泛型类 `generic class`** 。为了指定 `ArrayList` 保存的元素对象的类型，需要用一对尖括号将类名括起来加在后面，例如 `ArrayList<Employee>` 。第8章将看到如何自定义一个泛型类，这里不需要了解技术细节，就可以使用 `ArrayList` 类型。

## 5.3.1 声明数组列表
声明和构造一个保存 `Employee` 对象的 `ArrayList` ：
```java
ArrayList<Employee> staff = new ArrayList<Employee>();
```
两边都使用类型参数 `Employee` ，有些繁琐。**在Java 10中，最好使用 `var` 关键字以避免重复写类名**：
```java
var staff = new ArrayList<Employee>();
```
如果没有使用 `var` 关键字，可以省去右边的类型参数：
```java
ArrayList<Employee> staff = new ArrayList<>();
``` 
这被称为“菱形”语法，因为空尖括号就像是一个菱形。**可以结合 `new` 操作符使用菱形语法**。编译器会检查新值要做什么。如果赋值给一个变量，或传递到某个方法，或从某个方法返回，编译器会检査这个变量、参数或方法的泛型类型，然后将这个类型放在 `<>` 中。在这个例子中，`new ArrayList<>()` 将赋值给一个类型为 `ArrayList<Employee>` 的变量，所以泛型类型为 `Employee` 。

> 警告：如果使用 `var` 声明 `ArrayList` ，就**不要**使用菱形语法。以下声明会生成一个 `ArrayList<Object>` ：
> ```java
> var elements = new ArrayList<>();
> ```

> 注释：Java 5以前的版本没有提供泛型类，而是有一个保存 `Object` 类型元素的 `ArrayList` 类，它是一个“自适应大小” *one-size-fits-all* 的集合。如果一定要使用老版本的Java，则需要将所有的后缀 `<...>` 删掉；在Java SE 5以后的版本中，仍然可以使用没有后缀 `<...>` 的 `ArrayList` ，它被认为是一个删去了类型参數的“原始”类型。

> 注释：在Java的老版本中，程序员使用 `Vector` 类实现动态数组。不过，**`ArrayList` 类更加高效，没有任何理由再使用 `Vector` 类**。

使用 `add` 方法可以将元素添加到数组列表中。例如，下面展示了如何将雇员对象添加进去的方法：
```java
staff.add(new Employee("Harry Hacker"，...));
staff.add(new Employee("Tony Tester"，...));
```
数组列表管理着一个内部的对象引用数组。最终，数组的全部空间有可能被用尽。这就显现出数组列表的魅力：如果调用 `add` 而内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。

**如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用 `ensureCapacity` 方法**：
```java
staff.ensureCapacity(100);
```
这个方法调用将分配一个包含100个对象的内部数组。这样一来，调用前100次 `add` 不会带来开销很大的重新分配空间。

另外，还可以把初始容量传递给 `ArrayList` 构造器：
```java
ArrayList<Employee> staff = new ArrayList<>(100);
```
> 警告：如下分配数组列表：
> ```java
> new ArrayList<>(100) // capacity is 100
> ```
> 它与为新数组分配空间有所不同：
> ```java
> new Employee[100] // size is 100
> ```
> **数组列表的容量与数组的大小有一个非常重要的区别**。如果为数组分配100个元素的存储空间，数组就有100个空位置可以使用。而容量为100个元素的数组列表只是拥有保存100个元素的潜力（实际上也可以超过100，不过要以重新分配空间为代价），但是在最初，甚至完成初始化构造之后，数组列表不含有任何元素。

`size` 方法将返回数组列表中包含的实际元素数目。例如，`staff.size()` 将返回 `staff` 数组列表的当前元素个数，它等价于数组 `a` 的 `a.length` 。

一旦能够确认数组列表的大小不再发生变化，就可以调用 `trimToSize` 方法。这个方法将
存储块的大小调整为保存当前元素数量所需要的存储空间。垃圾回收器将回收多余的存储
空间。一旦消减了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该**在确认不会添加任何元素时，再调用 `trimToSize`** 。

> C++注释：`ArrayList` 类似于C++的 `vector` 模板。`ArrayList` 与 `vector` 都是泛型类型。但C++的 `vector` 模板为了便于访问元素，重载了 `[]` 运算符。由于Java没有运算符重载，所以必须调用显式的方法。
> 
> 此外，**C++向量是值拷贝**。如果 `a` 和 `b` 是两个 `vector` ，赋值操作 `a = b` 将会构造一个与 `b` 长度相同的新向量 `a` ，并将所有的元素由 `b` 拷贝到 `a` 。而**在Java中，这条赋值语句的操作结果是让 `a` 和 `b` 引用同一个数组列表**。

> [API] `java.util.ArrayList<E>` 1.2
> - `ArrayList<E>()`
> 构造一个空数组列表。
> - `ArrayList<E>(int initialCapacity)`
> 用指定容量构造一个空数组列表。
> - `boolean add(E obj)`
> 在数组列表的尾端添加一个元素。永远返回 `true` 。
> - `int size()`
> 返回当前存储在数组列表中的元素数量（这个值将小于或等于数组列表的容量）。
> - `void ensureCapacity(int capacity)`
> 确保数组列表在不重新分配存储空间的情况下，就能够保存给定数量的元素。
> - `void trimToSize()`
> 将数组列表的存储容量削减到当前尺寸。

## 5.3.1 访问数组列表元素
很遗憾，天下没有免费的午餐。`ArrayList` 自动扩展容量的便利，增加了访问元素语法的复
杂程度。其原因是 `ArrayList` 类并不是Java语言的一部分；它只是一个由某些人编写、且被放在标准库中的一个实用工具类。

**不能使用我们喜爱的 `[]` 语法格式访问或改变数组的元素，而要使用 `get` 和 `set` 方法**。例如，要设置第 `i` 个元素，可以使用：
```java
staff.set(i, harry);
```
它等价于对数组 `a` 的元素赋值（下标一样从0开始)：
```java
a[i] = harry;
```
> 警告：只有 `i` 小于数组列表的大小时，才能够调用 `list.set(i, x)` 。例如，下面这段代码是错误的：
> ```java
> ArrayList<Employee\> list = new ArrayList<Employee\>(100); // capacity 100, size 0
> list.set(0, x); // no element 0 yet 
> ```
> 要使用 `add` 方法为数组添加新元素，而不是 `set` 方法，它只能替换数组中已经存在的元素。

使用下列格式获得数组列表的元素:
```java
Employee e = staff.get(i);
```
等价于：
```java
Employee e = a[i];
```

> 注释：没有泛型类时，原始的 `ArrayList` 类提供的 `get` 方法，别无选择只能返回 `Object` ,因此，`get` 方法的调用者必须对返回值进行强制类型转换：
> ```java
> Employee e = (Employee) staff.get(i);
> ```
> 原始的 `ArrayList` 存在一定的危险性。它的 `add` 和 `set` 方法允许接受任意类型的对象。对于下面这个调用
> ```java
> staff.set(i, "Harry Hacker");
> ```
> 编译不会给出任何警告，只有在检索对象并试图对它进行强制类型转换时，才会发现有问题。如果使用 `ArrayList<Employee>` ，编译器就会检测到这个错误。

下面这个技巧可以一举两得，既可以灵活地扩展数组，又可以方便地访问数组元素。首先，创建一个数组，并添加所有的元素。
```java
var list = new ArrayList<X>();
while (...) {
	x = ...;
	list.add(x);
}
```
执行完上述操作后，使用 `toArray` 方法将数组元素拷贝到一个数组中。
```java
X[] a = new X[list.size()];
list.toArray(a);
```
除了在数组列表的尾部追加元素之外，还可以在数组列表的中间插入元素，使用带索引参数的 `add` 方法。
```java
int n = staff.size() / 2;
staff.add(n, e);
```
为给新元素留出空间，位于 `n` 之后的所有元素都要向后移动一个位置。如果插入新元素后，数组列表的大小超过了容量，`ArrayList` 就会重新分配它的存储数组。

同样地，可以从数组列表中间删除一个元素。位于这个位置之后的所有元素都向前移动一个位置，并且数组的大小减1。
```java
Employee e = staff.remove(n);
```
对数组实施插入和删除元素的操作其效率比较低。对于小型数组来说，这一点不必担心。但如果存储的元素数比较多，又经常需要在中间插入、删除元素，就应该考虑使用链表了。有关链表操作在第9章中讲述。

可以使用 `foreach` 循环遍历数组列表：
```java
for (Employee e : staff)
	do something with e
```
这个循环和下列代码具有相同的效果
```java
for (int i = 0; i < staff.size(); ++i) {
	Employee e = staff.get(i);
	do something with e
}
```
`arrayList/ArrayListTest` 是对第4章中 `EmployeeTest` 做出修改后的程序。在这里，将 `Employee[]` 数组替换成了 `ArrayList<Employee>` 。请注意下面的变化：
- 不必指定数组的大小。
- 使用 `add` 将任意多的元素添加到数组中。
- 使用 `size()` 替代 `length` 计算元素的数目。
- 使用 `a.get(i)` 替代 `a[i]` 访问元素。

```java
// Inheritance/arrayList/ArrayListTest.java
package arrayList;
import java.util.*;

/**
 * This program demonstrates the ArrayList class.
 */
public class ArrayListTest {
	public static void main(String[] args) {
		// fill the staff array list with three Employee objects
		var staff = new ArrayList<Employee>();
	
		staff.add(new Employee("Carl Cracker", 75000, 1987, 12, 15));
		staff.add(new Employee("Harry Hacker", 50000, 1989, 10, 1));
		staff.add(new Employee("Tony Tester", 40000, 1990, 3, 15));
		
		// raise everyone's salary by 5%
		for (Employee e : staff)
			e.raiseSalary(5);
		// print out information about all Employee objects
		for (Employee e : staff)
			System.out.println("name=" + e.getName() + ",salary=" + e.getSalary() + ",hireDay="
				+ e.getHireDay());
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209231316071.png)

> [API] `java.util.ArrayList<T>` 1.2
> - `E set(int index, E obj)`
> 设置数组列表指定位置的元素值，这个操作将覆盖这个位置的原有内容，并返回之前的内容。
> - `E get(int index)`
> 获得指定位置存储的元素值。
> - `void add(int index, E obj)`
> 向后移动元素，以便插入元素 `obj` 到合适的位置。
> - `E remove(int index)`
> 删除指定索引位置的元素，并将后面的元素向前移动。被删除的元素由返回值返回。

## 5.3.2 类型化与原始数组列表的兼容性 *Compatibility between Typed and Raw Array Lists*
在自己的代码中，可能更愿意使用类型参数来增加安全性。这一节中，会了解如何与没有使用类型参数的遗留代码交互操作。假设有下面这个遗留下来的类：
```java
public class EmployeeDB {
	public void update(ArrayList list) { ... }
	public ArrayList find(String query) { ... }
}
```
**可以将一个类型化的 `ArrayList` 传递给 `update` 方法，而并不需要进行任何强制类型转换 *without any casts*** 。
```java
ArrayList<Employee> staff = ...;
employeeDB.update(staff);
```
> 警告：尽管编译器没有给出任何错误信息或警告，但是这样调用并不太安全。在 `update` 方法中，添加到 `ArrayList` 中的元素可能不是 `Employee` 类型。访问这些元素时就会出现异常。听起来似乎很吓人，但思考一下就会发现，这与在Java中增加泛型之前是一样的，虚拟机的完整性并没有受到威胁。在这种情形下，没有降低安全性，但也未从编译时检查受益。

相反地，**将一个原始 `ArrayList` 赋给一个类型化 `ArrayList` 会得到一个警告**。
```java
ArrayList<Employee> result = employeeDB.find(query); // yields warning
```
> 注释：为了能够看到警告的文字信息，要将编译选项置为 `-Xlint:unchecked` 。

使用强制类型转换并不能避免出现警告。这样将会得到另外一个警告信息，指出类型转换有误。
```java
ArrayList<Employee> result = (ArrayList<Employee>) employeeDB.find(query); 
	// yields another warning
```
这就是Java中不尽如人意的**参数化类型/泛型类型**限制所带来的结果。鉴于兼容性的考虑，编译器在检査之后，如果没有发现违反规则的现象，就将所有的类型化 `ArrayList` 转换成原始 `ArrayList` 对象。**在程序运行时，所有的数组列表都是一样的，即没有虚拟机中的类型参数**。因此，强制类型转换 `(ArrayList)` 和 `(ArrayList<Employee>)` 将执行相同的运行时检查。

在这种情形下，你不必做什么。只要在与遗留代码交互时，研究一下编泽器的警告性提示，并确保这些警告不太严重就行了。

一旦能确保不会造成严重的后果，可以用 `@SuppressWamings("unchecked")` 标注来标记「接受强制类型转换的变量 *the variable that receives the cast* 」，如下所示：
```java
@SuppressWarnings("unchecked") 
ArrayList<Employee> result = (ArrayList<Employee>) employeeDB.find(query); 
	// yields another warning
```

---
# 5.4 对象包装器与自动装箱
有时，需要将 `int` 这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。例如，`Integer` 类对应基本类型 `int` 。通常，这些类称为**包装器** `wrapper` 。这些包装器类拥有很明显的名字：`Integer, Long, Float, Double, Short, Byte, Character, Void, Boolean`（前6个类派生于公共超类 `Number` ）。

**包装器类是不可变的**，即一旦构造了包装器，就不允许更改包装在其中的值。同时，**包装器类还是 `final` ，因此不能定义它们的子类**。

假设想定义一个整型 `ArrayList` 。**遗憾的是，尖括号中的类型参数不允许是基本类型**，即不允许写成 `ArrayList<int>` 。这里就用到了 `Integer` 包装器类。我们可以声明一个 `Integer`
对象的 `ArrayList` 。
```java
ArrayList<Integer> list = new ArrayList<>();
```
> 警告：由于每个值分别包装在对象中，所以 `ArrayList<Integer>` 的效率远远低于 `int[]` 数组。因此，==应该用它构造小型集合，其原因是此时程序员操作的方便性要比执行效率更加重要==。

幸运的是，有一个很有用的特性，更加便于添加 `int` 类型的元素到 `ArrayList<Integer>` 中。调用 `list.add(3);` 将自动地变换成 `list.add(Integer.value0f(3));` 。这种变换被称为**自动装箱** `autoboxing` 。
> 注释：大家可能认为**自动打包** `autowrapping` 更加合适，而**装箱** `boxing` 这个词源自于 C#。

相反地，当将一个 `Integer` 对象赋给一个 `int` 值时，将会自动拆箱。也就是说，编译器将语句 `int n = list.get(i);` 翻译成 `int n = list.get(i).intValue();` 。自动装箱和拆箱也适用于算术表达式中。例如，可以将自增操作符应用于一个包装器引用：
```java
Integer n = 3;
n++;
```
编译器将自动地插入一条对象拆箱的指令，然后进行自增计算，最后再将结果装箱。

大多数情况下容易有一种假象，认为基本类型与它们的对象包装器是一样的。但它们有一点有很大不同：同一性 *identity* 。大家知道，**`==` 运算符也可以应用于包装器对象，只不过检测的是对象是否有相同的内存位置**，因此，下面的比较**通常**不会成立：
```java
Integer a = 1000;
Integer b = 1000;
if (a == b) ...
```
然而，Java实现却有**可能** `may` 让它成立，如果它选择将经常出现的值包装到相同对象中，这种比较就有可能成立 *a Java implementation may, if it chooses, wrap commonly occurring values into identical objects, and thus the comparison might succeed* 。这种不确定的结果并不是我们所希望的。解决这个问题的办法是，在两个包装器对象比较时调用 `equals` 方法。
> 注释：自动装箱规范要求 `boolean, byte, char <= 127` ，介于 `-128 ~ 127` 之间的 `short` 和 `int` 被包装到固定的对象中。例如，如果在前面的例子中将 `a` 和 `b` 初始化为100，对它们进行比较的结果一定成立。

关于自动装箱还有几点需要说明。首先，**由于包装器类引用可以为 `null` ，所以自动装箱有可能会抛出一个 `NullPointerException` 异常**：
```java
Integer n = null;
System.out.println(2 * n); // Throws NullPointerException
```
另外，**如果在一个条件表达式中混合使用 `Integer` 和 `Double` 类型，`Integer` 值就会拆箱，提升为 `double` ，再装箱为 `Double`** ：
```java
Integer n = 1;
Double x = 2.0;
System.out.println(true ? n ：x); // Prints 1.0
```
最后强调一下，==装箱和拆箱是编译器要做的工作，而不是虚拟机。编译器在生成类的字节码时插入必要的方法调用。虚拟机只是执行这些字节码==。

使用数值包装器通常还有另一个好处。**Java设计者发现，可以将某些基本方法放置在包装器中，这会很方便**。例如，将一个数字字符串转换成数值。要想将字符串转换成整型，可以使用下面这条语句：
```java
int x = Integer.parselnt(s);
```
这里与 `Integer` 对象没有任何关系，`parseInt` 是一个静态方法。但 `Integer` 类是放置这个方法的一个好地方。

API注释说明了 `Integer` 类中包含的一些重要方法。其他数值类也实现了相应的方法。

> 警告：有些人认为包装器类可以用来实现修改数值参数的方法，然而这是错误的。在第4章中曾经讲到，由于**Java方法总是值传递**，所以不可能编写一个能够增加整型参数值的Java方法。
> ```java
> public static void triple(int x) { // won't work
>     x = 3 * x; // modifies local variable
> }
> ```
> 将 `int` 替换成 `Integer` 又会怎样呢？
> ```java
> public static void triple(Integer x) // won't work
> ```
> 问题是 **`Integer` 对象是不可变的**：包含在包装器中的内容不会改变：**不能使用这些包装器类创建「会修改数值参数的方法」**。
> 
> 如果确实想编写一个修改数值参数值的方法，可以使用在 `org.omg.CORBA` 包中定义的某个持有者 `holder` 类型，包括 `IntHolder, BooleanHolder` 等。每个持有者类型都包含一个公有 （！）字段 `value` ，通过它可以访问存储在其中的值。
> ```java
> public static void triple(IntHolder x) {
>     x.value = 3 * x.value;
> }
> ```

> [API] `java.lang.Integer` 1.0
> - `int intValue()`
> 以 `int` 的形式返回 `Integer` 对象的值（覆盖了 `Number` 类中的 `intValue` 方法）。
> - `static String toString(int i)`
> 以一个新 `String` 对象的形式，返回给定数值 `i` 的十进制表示。
> - `static String toString(int i, int radix)`
> 返回数值 `i` 的基于给定 `radix` 参数进制的表示。
> 
> - `static int parseInt(String s)`
> - `static int parseInt(String s, int radix)`
> **返回字符串 `s` 表示的整型数值**，给定字符串表示的是十进制的整数（第一种方法)，或者是 `radix` 参数进制的整数（第二种方法）。
> - `static Integer valueOf(String s)`
> - `static Integer valueOf(String s, int radix)`
> 返回用 `s` 表示的整数初始化后的一个新 `Integer` 对象，给定字符串表示的是十进制的整数（第一种方法），或者是 `radix` 参数进制的整数（第二种方法）。

> `java.text.NumberFormat` 1.1
> - `Number parse(String s)
> 返回数字值，假设给定的 `String` 表示了一个数值。

---
# 5.5 参数数量可变的方法
在Java 5.0以前的版本中，每个Java方法都有固定数量的参数。然而，现在的版本可以提供参数数量可变的方法（有时这些方法称为“变参 *varargs*”方法）。

前面已经看到过这样的方法：`printf` 。例如，下面的方法调用：
```java
System.out.printf("%d", n);
```
和
```java
System.out.printf("%d %s", n, "widgets");
```
尽管一个调用有两个参数，另一个调用有三个参数，但它们调用的都是同一个方法。

`printf` 方法是这样定义的：
```java
public class PrintStream {
	public PrintStream printf(String fmt, Object... args) { 
		return format(fmt, args); 
	}
}
```
这里的**省略号 `...` 是 Java代码的一部分，它表明这个方法可以接收任意数量的对象**（除 `fmt` 参数之外）。实际上，`printf` 方法接收两个参数，一个是格式字符串，另一个是 `Object[]` 数组，其中保存着所有其他参数（如果调用者提供的是整型，或者其他基本类型的值，自动装箱功能将把它们转换成对象）。现在将扫描 `fmt` 字符串，并将第 `i` 个格式说明符与 `args[i]` 的值匹配起来。

换句话说，**对于 `printf` 的实现者来说，`Object...` 参数类型与 `Object[]` 完全一样**。编译器需要转换每个 `printf` 调用，将参数绑定到数组上，并在必要的时候进行自动装箱：
```java
System.out.printf("%d %s", new Object[]{ new Integer(n), "widgets" });
```

用户也可以自定义可变参数的方法，并将参数指定为任意类型，甚至是基本类型。下面是一个简单的示例：其功能为计算若干个数值中的最大值（个数可变）。
```java
public static double max(double... values) {
	double largest = Double.NEGATIVE_INFINITY;
	for (double v : values) if (v > largest) largest = v;
	return largest;
}
```
可以像下面这样调用这个方法，编译器将 `new double[] {3.1, 40.4, -5}` 传递给 `max` 方法：
```java
double m = max(3.1, 40.4, -5);
```
> 注释：允许将数组作为最后一个参数，传递给可变参数方法 *pass an array as the last parameter of a method with variable parameters* 。例如：
> ```java
> System.out.printf("%d %s", new Object[] { new Integer(1), "widgets" } );
> ```
> 因此，==可以将「已存的且最后一个参数是数组的方法」，重新定义为可变参数的方法，而不会破坏任何已有的代码==。例如，在Java SE 5.0就采用这种方式增强了`MessageFormat.format` 。甚至可以将 `main` 方法声明为下列形式：
> ```java
> public static void main(String... args)
> ```

---
# 5.6 枚举类
在第3章已经看到如何定义枚举类型。下面是一个典型的例子：
```java
public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE };
```
实际上，**这个声明定义的类型是一个类，它刚好有4个实例，不可以构造新的对象**。

因此，**在比较两个枚举类型的值时，永远不需要调用 `equals` ，而直接使用 `==` 就可以了**。

如果需要的话，可以为枚举类型添加一些构造器、方法和字段。当然，**构造器只是在构造枚举常量的时候被调用**。下面是一个示例：
```java
public enum Size {
	SMALL("S"), MEDIUM("M"), LARGE("L"), EXTRA_LARGE("XL");
	private String abbreviation;
	private Size(String abbreviation) { this.abbreviation = abbreviation; }
	public String getAbbreviation() { return abbreviation; }
}
```
**枚举的构造器总是私有的**。可以像前例一样省略 `private` 修饰符。如果声明一个 `enum` 构造器为 `public` 或 `protected` ，会出现语法错误。

**所有的枚举类型都是 `Enum` 类的子类**。它们继承了这个类的许多方法。其中最有用的一个是 **`toString` ，这个方法能够返回枚举常量名**。例如，`Size.SMALL.toString()` 将返回字符串
 `"SMALL"` 。

**`toString` 的逆方法是静态方法 `valueOf`** 。例如，下列语句将 `s` 设置成 `Size.SMALL` ：
```java
Size s = Enum.valueOf(Size.class, "SMALL");
```
**每个枚举类型都有一个静态的 `values` 方法，它将返回一个包含全部枚举值的数组**。例如调用 `Size[] values = Size.values();` 返回包含元素 `Size.SMALL, Size.MEDIUM, Size.LARGE, Size.EXTRA_LARGE` 的数组。

**`ordinal` 方法返冋 `enum` 声明中枚举常量的位置**，位置从 `0` 开始计数。例如：`Size.MEDIUM. ordinal()` 返回1。`Inheritance/enums/EnumTest.java` 演示了枚举类型的工作方式。
> 注释：`Enum` 类有一个类型参数，为简单起见我们省略了它。例如，实际上枚举类型 `Size` 扩展了 `Enum<Size>` *the enumerated type Size actually extends Enum\<Size\>* 。类型参数在 `compareTo` 方法中使用（在第6章中介绍，类型参数在第8章中介绍）。

```java
// Inheritance/enums/EnumTest.java
package enums;

import java.util.*;

/**
 * This program demonstrates enumerated types.
 */
public class EnumTest {
	public static void main(String[] args) {
		var in = new Scanner(System.in);
		System.out.print("Enter a size: (SMALL, MEDIUM, LARGE, EXTRA_LARGE) ");
		String input = in.next().toUpperCase();
		
		Size size = Enum.valueOf(Size.class, input);
		System.out.println("size=" + size);
		System.out.println("abbreviation=" + size.getAbbreviation());
		if (size == size.EXTRA_LARGE) 
			System.out.println("Good job--you paid attention to the _.");	
	}
}

enum Size {
	SMALL("S"), MEDIUM("M"), LARGE("L"), EXTRA_LARGE("XL");
	
	private Size(String abbreviation) { this.abbreviation = abbreviation; }
	public String getAbbreviation() { return abbreviation; }
	
	private String abbreviation;
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209231323888.png)

> [API] `java.lang.Enum<E>` 5.0
> - `static Enum valueOf(Class enumClass, String name)`
> 返回给定类中指定名字的枚举常量。
> - `String toString()`
> 返回枚举常量名。
> - `int ordinal()`
> 返回枚举常量在 `enum` 声明中的位置，位置从0开始计数。
> - `int compareTo(E other)`
> 如果枚举常量出现在 `other` 之前，则返回一个负值；如果 `this==other` ，则返回0；否则，返回正值。枚举常量的出现次序在 `enum` 声明中给出。

---
# 5.7 反射
**反射库** `reflection library` 提供了一个非常丰富且精心设计的工具集，以便**编写能够动态操纵Java代码的程序**。这项功能被大量地应用于JavaBeans中。使用反射，Java可以支持用户界面生成器、对象关系映射器以及很多其他**需要动态查询类能力的开发工具**（特别是在设计或运行中添加新类时，能够快速地应用开发工具、动态地查询新添加类的能力）。

**能够分析类能力的程序** *A program that can analyze the capabilities of classes* 称为反射 `reflective` 。反射机制的功能极其强大 *extremely powerful* ，在下面可以看到，反射机制可以用来：
- 在运行时分析类的能力。
- 在运行时查看对象 *Inspect objects at runtime* ，例如，编写一个适用于所有类的 `toString` 方法。
- 实现泛型数组操作代码 *Implement generic array manipulation code* 。
- 利用 `Method` 对象，这个对象很像C++中的函数指针。

反射是一种功能强大且复杂的机制。使用它的主要人员是开发工具的程序员，而不是应用程序员。如果仅对设计应用程序感兴趣、而对「为其他Java程序员构造工具」不感兴趣，可以跳过剩余部分，稍后再返回来学习。
## 5.7.1 `Class` 类
==在程序运行期间，Java运行时系统始终为所有的对象维护一个**运行时类型标识** *runtime type identification*== 。这个信息会跟踪每个对象所属的类。虚拟机利用运行时类型信息，选择要执行的正确的方法。

然而，可以使用一个特殊的Java类访问这些信息。保存这些信息的类名为 `Class` ，这个名字有些让人困惑。**`Object` 类中的 `getClass()` 方法将会返回一个 `Class` 类型的实例**。
```java
Employee e;
...
Class cl = e.getClass();
```
如同用一个 `Employee` 对象描述一个特定雇员的属性一样，**一个 `Class` 对象将表示一个特定类的属性**。**最常用的 `Class` 方法是 `getName` ，这个方法将返回类的名字**。例如，下面这条
语句：
```java
System.out.println(e.getClass().getName() + " " + e.getName());
```
如果 `e` 是一个雇员，则会打印输出：
```java
Employee Harry Hacker
```
如果 `e` 是经理，则会打印输出：
```java
Manager Harry Hacker
```
如果类在一个包里，包的名字也作为类名的一部分：
```java
var generator = new Random();
Class cl = generator.getClass();
String name = cl.getName(); // name is set to "java.util.Random"
```
还可以**调用静态方法 `forName` 获得类名对应的 `Class` 对象**。
```java
String className = "java.util.Random";
Class cl = Class.forName(className);
```
==如果类名保存在一个字符串中，并可在运行中改变，就可以使用这个方法==。当然，**这个方法只有在 `className` 是类名或接口名时才能够执行**。否则，`forName` 方法将抛出一个 `checked exception`（检查型异常）。无论何时使用这个方法，都应该提供一个异常处理器 `exception handler` 。如何提供一个异常处理器，参看下一节。
> 提示：**在启动时，包含 `main` 方法的类被加载。它会加载所有需要的类。这些被加载的类又要加载它们需要的类**，以此类推。对于一个大型的应用程序来说，这将会消耗很多时间，用户会因此感到不耐烦。可以使用下面这个技巧，给用户一种启动速度比较快的幻觉。不过，要确保包含 `main` 方法的类没有显式地引用其他的类。首先，显示一个启动画面；然后，通过调用 `Class.forName` 手工地强制加载其他的类。

获得 `Class` 类对象的第三种方法是一个很方便的快捷方式 *shorthand* 。如果 `T` 是任意的Java类型（或 `void` 关键字），**`T.class` 将代表匹配的类对象**。例如：
```java
Class cl1 = Random.class; // if you import java.util
Cass cl2 = int.class;
Class cl3 = Double[].class;
```
请注意，一个 `Class` 对象实际上表示的是一个**类型** *type* ，可能是类、也可能不是类 *class* 。例如，`int` 不是类，但 `int.class` 是一个 `Class` 类型的对象。
> 注释：**`Class` 类实际上是一个泛型类**。例如，`Employee.class` 的类型是 `Class<Employee>` 。我们没有深究这个问题的原因是：它将已经抽象的概念更加复杂化了。在大多数实际问题中，可以忽略类型参数，而使用原始的 `Class` 类。有关这个问题更详细的论述参看第8章。

> 警告：鉴于历史原因，`getName` 方法在应用于数组类型的时候，会返回有些奇怪的名字：
> - `Double[].class.getName()` 返回 `[Ljava.lang.Double;` 
> - `int[].class.getName()` 返回 `[I`

**虚拟机为每个类型管理一个唯一的 `Class` 对象**。因此，可以利用 `==` 运算符实现两个类对象的比较。例如：
```java
if (e.getClass() == Employee.class) ...
```
如果 `e` 是一个 `Employee` 实例，这个测试将通过，与条件 `e instanceof Employee` 不同，如果 `e` 是某个子类（如 `Manager` ）的实例，这个测试将失败。

**如果有一个 `Class` 类型的对象，可以用它构造类的实例**。调用 `getConstructor` 方法将得到一个 `Constructor` 类型的对象，然后使用 `newInstance` 方法来动态构造一个实例：
```java
var className = "java.util.Random"; // or any other name of a class with
									// a no-arg constructor
Class cl = Class.forName(className);
Object obj = cl.getConstructor().newInstance();
```
如果这个类没有无参数构造器，那么 `getConstructor` 方法会抛出一个异常。参见5.7.7节了解如何调用其他构造器。

此外，直接将 `forName` 与 `newInstance` 配合起来使用，也能根据存储在字符串中的类名创建一个对象：
```java
String s = "java.util.Random";
Object m = Class.forName(s).newInstance();
```
> 注释：如果需要以这种方式，给按名称创建的类的构造器提供参数，就不要使用上面那条语句，而必须使用 `Constructor` 类中的 `newInstance` 方法。

> 注释：有一个已经废弃的 `Class.toInstance` 方法，它也可以用无参数构造器构造一个实例，不过，如果构造器抛出一个检查型异常，这个异常将不做任何检查重新抛出。这违反了编译时异常检查的原则。与之不同，`Constructor.newInstance` 会把任意构造器异常包装在一个 `InvocationTargetException` 。

> C++注释：`newInstance` 方法对应C++中虚拟构造器 *virtual constructor* 概念。然而，**C++中的虚拟构造器不是一种语言特性，而是需要一个专业库支持的习惯用法**。`Class` 类与C++中的 `type_info` 类相似，`getClass` 方法则等价于 `typeid` 运算符。但Java中的 `Class` 比C++中的 `type_info` 功能更全面。C++中的 `type_info` 只能给出「表示类型名的一个字符串」，而不能创建那个类型的新对象。

> [API] `java.lang.Class` 1.0
> - `static Class forName(String className)`
> 返回一个 `Class` 对象，表示名为 `className` 的类。
> - `Constructor getConstructor(Class... parameterTypes)` 1.1
> 生成一个对象，描述有指定参数类型的构造器。参见5.7.7节更多了解如何提供参数类型。

> [API] `java.lang.reflect.Constructor`
> - `Object newInstance(Object... params)`
> 将 `params` 传递到构造器来构造 *constructor’s declaring class* 的一个新实例。参见5.7.7节了解如何提供参数。

> [API] `java.lang.Throwable` 1.0
> - `void printStackTrace()`
> 将 `Throwable` 对象和堆栈轨迹打印到标准错误流。

## 5.7.2 声明异常入门
在第7章中全面讲述异常处理机制，但现在时常遇到一些可能抛出异常的方法。当程序运行中发生错误时，就会“抛出异常”。抛出异常比终止程序要灵活得多，这是因为可以提供一个**处理器** `handler` 捕获这个异常并进行处理。

==如果没有提供处理器，程序就会终止，并在控制台上打印出一条信息，给出异常的类型==。可能在前面已经看到过一些异常报告，例如，偶然使用了 `null` 引用或者数组越界等。

异常有两种类型：**非检查型 `unchecked` 和检查型 `checked` 异常**。==对于检查型异常，编译器将会检查你（程序员）是否知道这个异常、并做好准备来处理后果（是否提供了处理器）==。然而，有很多常见的异常，例如访问 `null` 引用，都属于非检查型异常。编译器并不期望你为这些异常提供处理器。毕竟，你应该集中精力避免这些错误的发生，而不要将精力花在编写异常处理器上。

并不是所有的错误都是可以避免的。**如果竭尽全力还是可能发生异常，大多数Java API都会抛出一个检查型异常**。`Class.forName` 方法就是一个抛出检查型异常的例子，没有办法确保有指定名字的类一定存在。在第7章中，会看到几种异常处理的策略。现在只介绍最简单的一个策略。

**如果一个方法包含一条可能抛出检查型异常的语句，则在方法名上增加一个 `throws` 子句**。
```java
public static void doSomethingWithClass(String name) 
	throws ReflectiveOperationException {
	Class cl = Class.forName(name); // might throw exception
	do something with cl	
}
```
**调用这个方法的任何方法，也都需要一个 `throws` 声明**。这也包括 `main` 方法。如果一个异常确实出现，`main` 方法将终止，并提供一个堆栈轨迹（第7章了解如何捕获异常、而非因异常终止程序）。

**只要为检查型异常提供一个 `throws` 子句**。我们很容易找出哪些方法会抛出检查型异常——如果调用了一个可能抛出检查型异常的方法、而没有提供相应的异常处理器，编译器就会报错。

## 5.7.3 资源
类通常有一些关联的数据文件。例如：图像和声音文件；包含消息字符串和按钮标签的文本文件等。在Java中，这些关联的文件被称为**资源** `resource` 。例如，考虑一个显示如下消息的对话框，如图5-3所示。当然，在面板中的书名和版权年限会在出版下一版图书时发生变化。为了追踪这个变化，我们希望将文本放在一个文件中，而不是以字符串的形式硬编码到代码中。
![图5-3 显示图像和文本资源](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209221626547.png)

但是应该将 `about.txt` 这样的文件放到哪里呢？当然，**将它与其他程序文件一起放在JAR文件中是最方便的**。`Class` 类提供了一个很有用的服务，可以查找资源文件。下面给出必要的步骤：
1. 获得拥有资源的类的 `Class` 对象。例如，`ResourceTest.class` 。
2. 有些方法如 `ImageIcon` 类的 `getImage` 方法，接受描述资源位置的URL。则要调用：
   ```java
   URL url = cl.getResource("about.gif");
   ```
3. 否则，使用 `getResourceAsStream` 方法得到一个输入流来读取文件中的数据。

这里的重点在于，Java虚拟机知道如何查找一个类，所以它能搜索相同位置上的关联资源 *the associated resource in the same location* 。例如，假设类 `ResourceTest` 在一个 `resources` 包中。`ResourceTest.class` 文件就位于 `resources` 目录中，可以把一个图标文件放在一个目录下。

除了**可以把资源文件和类文件放到同一个目录中**，还可以提供一个相对或绝对路径。如：
```java
data/about.txt
/corejava/title.txt
```
文件的自动装载是利用资源加载特性完成的。**但没有标准的方法来解释资源文件的内容，每个程序必须有自己的方法来解释它的资源文件**。

**另一个经常使用资源的地方是程序的国际化**。与语言相关的字符串，如消息和用户界面标签都存放在资源文件中，每种语言对应一个文件。**国际化API**在卷II第7章讨论。**这些API支持一种标准方法来组织和访问本地化文件**。

下列程序展示了资源加载（先不用担心读取文本和显示对话框的代码，稍后详细介绍）。
```java
// Inheritance/resources/ResourceTest.java
package resources;

import java.io.*;
import java.net.*;
import java.nio.charset.*;
import javax.swing.*;

public class ResourceTest {
	public static void main(String[] args) throws IOException {
		Class cl = ResourceTest.class;
		URL aboutURL = cl.getResource("about.gif");
		var icon = new ImageIcon(aboutURL);
	
		InputStream stream = cl.getResourceAsStream("data/about.txt");
		var about = new String(stream.readAllBytes(), "UTF-8");

		InputStream stream2 = cl.getResourceAsStream("data/about.txt");
		var about = new String(stream.readAllBytes(), "UTF-8");
	}
}
```
编译、构建一个JAR文件并执行（注意，要在目录 `resources` 的父文件夹即 `src` 下工作）：
```bash
$ javac resources/ResourceTest.java
$ jar cvfe ResourceTest.jar resources.ResourceTest \
	resources/*.class resources/*.gif resources/data/*.txt corejava/*.txt
$ java -jar ResourceTest.jar
```
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209232345893.png)

==将JAR文件移到另外一个不同的目录中、再运行它，以确认程序是从JAR文件、而非从当前目录中读取资源==（注意，`ResourceTest.jar` 解压后会得到 `resources` 包和 `corejava` 文件夹）。得到的结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209232357296.png)


> [API] `java.lang.Class` 1.0
> - `URL getResource(String name)` 1.1
> - `InputStream getResourceAsStream(String name)` 1.1
> 找到与类位于同一位置的资源，返回一个可以用来加载资源的URL或输入流。如果没有找到资源，则返回 `null` ，所以不会抛出异常或I/O错误。


## 5.7.4 利用反射分析类的能力
下面简要介绍**反射机制最重要的内容—检查类的结构** *examine the structure of a class* 。

**在 `java.lang.reflect` 包中有三个类 `Field, Method, Constructor` 分别用于描述类的字段、方法和构造器**。
- 这三个类都有一个叫做 `getName` 的方法，用来返回字段、方法或构造器的名字。
- **`Field` 类有一个 `getType` 方法，用来返回描述字段类型的一个 `Class` 对象**。
- `Method` 和 `Constructor` 类有能够报告参数类型的方法，`Method` 类还有一个报告返回类型的方法。
- 这三个类还都有一个叫做 `getModifiers` 的方法，它将返回一个整型数值，用不同的位开关描述所使用的修饰符，如 `public` 和 `static` 等。另外，还可以**利用 `java.lang.reflect` 包中的 `Modifier` 类的静态方法，分析 `getModifiers` 返回的这个整型数值**。例如，可以使用 `Modifier` 类中的 `isPublic, isPrivate, isFinal` ，判断方法或构造器是否是 `public, private, final` 。我们需要做的全部工作，就是调用 `Modifier` 类的相应方法，并对返回的整型数值进行分析。另外，还可以利用 `Modifier.toString` 方法将修饰符打印出来。

`Class` 类中的 `getFields, getMethods, getConstructors` 方法，将分别返回**这个类支持的 `public` 字段、方法和构造器的数组，其中包括超类的公有成员**。`Class` 类的 `getDeclareFields, getDeclareMethods, getDeclaredConstructors` 方法，将分别返回类中声明的全部字段、方法和构造器的数组，**其中包括私有成员、包成员和受保护成员，但不包括超类的成员**。

程序 `Inheritance/reflection/ReflectionTest.java` 显示了**如何打印一个类的全部信息**。这个程序将提醒用户输入类名，然后输出类中所有的方法和构造器的签名，以及全部实例字段名。假如输入 `java.lang.Double` ，程序将会输出：
```java
public final class java.lang.Double extends java.lang.Number
{
    public java.lang.Double(double);
    public java.lang.Double(java.lang.String);

    public boolean equals(java.lang.Object);
    public static java.lang.String toString(double);
    public java.lang.String toString();
    public static int hashCode(double);
    public int hashCode();
    public static double min(double, double);
    public static double max(double, double);
    public static native long doubleToRawLongBits(double);
    public static long doubleToLongBits(double);
    public static native double longBitsToDouble(long);
    public int compareTo(java.lang.Double);
    public volatile int compareTo(java.lang.Object);
    public static int compare(double, double);
    public byte byteValue();
    public short shortValue();
    public int intValue();
    public long longValue();
    public float floatValue();
    public double doubleValue();
    public static java.lang.Double valueOf(java.lang.String);
    public static java.lang.Double valueOf(double);
    public static java.lang.String toHexString(double);
    public volatile java.lang.Object resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup);
    public java.lang.Double resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup);
    public java.util.Optional describeConstable();
    public boolean isNaN();
    public static boolean isNaN(double);
    public static double sum(double, double);
    public boolean isInfinite();
    public static boolean isInfinite(double);
    public static boolean isFinite(double);
    public static double parseDouble(java.lang.String);

    public static final double POSITIVE_INFINITY;
    public static final double NEGATIVE_INFINITY;
    public static final double NaN;
    public static final double MAX_VALUE;
    public static final double MIN_NORMAL;
    public static final double MIN_VALUE;
    public static final int MAX_EXPONENT;
    public static final int MIN_EXPONENT;
    public static final int SIZE;
    public static final int BYTES;
    public static final java.lang.Class TYPE;
    private final double value;
    private static final long serialVersionUID;
}
```
值得注意的是：==这个程序可以分析Java解释器能加载的任何类，而不仅仅是编译程序时可以使用的类==。在下一章，还将使用这个程序查看**Java编译器自动生成的内部类**。
```java
package reflection;

import java.util.*;
import java.lang.reflect.*;

/**
 * This program uses reflection to print all features of a class
 */
public class ReflectionTest {
	public static void main(String[] args) throws ReflectiveOperationException {
		// read class name from command line args or user input
		String name;
		if (args.length > 0) name = args[0];
		else {
			var in = new Scanner(System.in);
			System.out.println("Enter class name (e.g. java.util.Date): ");
			name = in.next();
		}
		
		// print class name and superclass name (if != Object)
		Class cl = Class.forName(name);
		Class supercl = cl.getSuperclass();
		String modifiers = Modifier.toString(cl.getModifiers());
		if (modifiers.length() > 0) System.out.print(modifiers + " ");
		System.out.print("class " + name);
		if (supercl != null && supercl != Object.class) 
			System.out.print(" extends " + supercl.getName());
	
		System.out.print("\n{\n");
		printConstructors(cl); // print constructors of the class
		System.out.println();
		printMethods(cl); // print methods of the class
		System.out.println();
		printFields(cl); // print fields of the class
		System.out.println("}");
	}
	
	/**
	 * Prints all constructors of a class
	 * @param cl a class
	 */
	public static void printConstructors(Class cl) {
		Constructor[] constructors = cl.getDeclaredConstructors();
		
		for (Constructor c : constructors) {
			String name = c.getName();
			System.out.print("    ");
			String modifiers = Modifier.toString(c.getModifiers());
			if (modifiers.length() > 0) System.out.print(modifiers + " ");
			System.out.print(name + "(");
			
			// print parameter types
			Class[] paramTypes = c.getParameterTypes();
			for (int j = 0; j < paramTypes.length; ++j) {
				if (j > 0) System.out.print(", ");
				System.out.print(paramTypes[j].getName());
			}
			System.out.println(");");
		}
	}
	
	/**
	 * Prints all methods of a class
	 * @param cl a class
	 */
	public static void printMethods(Class cl) {
		Method[] methods = cl.getDeclaredMethods();
		for (Method m : methods) {
			Class retType = m.getReturnType();
			String name = m.getName();
			System.out.print("    ");
			// print modifiers, return type and method name
			String modifiers = Modifier.toString(m.getModifiers());
			if (modifiers.length() > 0) System.out.print(modifiers + " ");
			System.out.print(retType.getName() + " " + name + "(");
			
			// print parameter types
			Class[] paramTypes = m.getParameterTypes();
			for (int j = 0; j < paramTypes.length; ++j) {
				if (j > 0) System.out.print(", ");
				System.out.print(paramTypes[j].getName());
			}
			System.out.println(");");
		}
	}
	/**
	 * Prints all fields of a class
	 * @param cl a class
	 */
	public static void printFields(Class cl) {
		Field[] fields = cl.getDeclaredFields();
		for (Field f : fields) {
			Class type = f.getType();
			String name = f.getName();
			System.out.print("    ");
			String modifiers = Modifier.toString(f.getModifiers());
			if (modifiers.length() > 0) System.out.print(modifiers + " ");
			System.out.println(type.getName() + " " + name + ";");
		}
	}
}
```

> [API] `java.lang.Class` 1.0
> - `Field[] getFields()` 1.1
> - `Filed[] getDeclaredFie1ds()` 1.1
> `getFields` 方法将返回一个包含 `Field` 对象的数组，这些对象记录了**这个类或其超类的公有字段**。`getDeclaredFields` 方法也将返回包含 `Field` 对象的数组，这些对象记录了这个类的全部字段（但不包括超类成员）。**如果类中没有字段，或者 `Class` 对象描述的是基本类型或数组类型，这些方法将返回一个长度为0的数组**。
> - `Method[] getMethods()` 1.1
> - `Method[] getDeclaredMethods()` 1.1
> 返回包含 `Method` 对象的数组：`getMethods` 将返回所有的公有方法，包括从超类继承来的公有方法；`getDeclaredMethods` 返回这个类或接口的全部方法，但不包括由超类继承了的方法。
> - `Constructor[] getConstructors()` 1.1
> - `Constructor[] getDeclaredConstructors()` 1.1
> 返回包含 `Constructor` 对象的数组，其中包含了 `Class` 对象所描述的类的所有公有构造器 `getConstructors` 或所有构造器 `getDeclaredConstructors` 。
> - `String getPackageName()` 9
> 得到包含这个类型的包的包名，如果这个类型是一个数组类型，则返回元素类型所属的包，或者如果这个类型是一个基本类型，则返回 `"java.lang"` 。

> [API] `java.lang.reflect.Field` 1.1
> [API] `java.lang.reflect.Method` 1.1
> [API] `java.lang.reflect.Constructor` 1.1
> - `Class getDeclaringClass()`
> 返冋一个描述类中定义的构造器、方法或字段的 `Class` 对象。
> - `Class[] getExceptionTypes()`（在 `Constructor` 和 `Method` 类中）
> 返回一个描述方法抛出的异常类型的 `Class` 对象数组。
> - `int getModifiers()`
> 返回一个描述构造器、方法或字段的修饰符的整型数值。使用 `Modifier` 类中的这个方法分析这个返回值。
> - `String getName()`
> 返冋一个描述构造器、方法或字段名的字符串。
> - `Class[] getParameterTypes()`（在 `Constructor` 和 `Method` 类中）
> 返回一个描述参数类型的 `Class` 对象数组。
> - `Class getReturnType()`（在 `Method` 类中）
> 返回一个描述返回类型的 `Class` 对象。

> [API] `java.lang.reflect.Modifier` 1.1
> - `static String toString(int modifiers)`
> 返回一个字符串，包含对应 `modifiers` 中位设置的修饰符。
> - `static boolean isAbstract(int modifiers)`
> - `static boolean isFinal(int modifiers)`
> - `static boolean isInterface(int modifiers)`
> - `static boolean isNative(int modifiers)`
> - `static boolean isPrivate(int modifiers)`
> - `static boolean isProtected(int modifiers)`
> - `static boolean isPublic(int modifiers)`
> - `static boolean isStatic(int modifiers)`
> - `static boolean isStrict(int modifiers)`
> - `static boolean isSynchronized(int modifiers)`
> - `static boolean isVolative(int modifiers)`
> 这些方法将检测 `modffiers` 值中与「方法名中修饰符」对应的二进制位。

## 5.7.4 在运行时使用反射分析对象
从前面一节中，我们已经知道如何查看「任意对象的数据字段的名称和类型」:
- 获得对应的 `Class` 对象。
- 通过 `Class` 对象调用 `getDeclaredFields` 。

本节进一步查看字段的具体内容。==当然，在编写程序时，如果知道想要査看的字段的名称和类型，查看对象中指定字段的内容是一件很容易的事情==。而**利用反射机制可以查看在编译时还不清楚的对象字段**。

要做到这一点，关键在 `Field` 类中的 `get` 方法。如果 `f` 是一个 `Field` 类型的对象（例如，通过 `getDeclaredFields` 得到的对象；代表某个字段），`obj` 是某个包含 `f` 字段的类的对象，`f.get(obj)` 将返回一个对象，其值为 `obj` 的当前字段值。这样说起来显得有点抽象，看一看示例。当然，**不仅可以获得值，还可以设置值**，调用 `f.set(obj, value)` 将把对象 `obj` 的 `f` 表示的字段设为新值。
```java
Employee harry = new Employee("Harry Hacker", 35000, 10, 1, 1989);
Class cl = harry.getClass();
	// the class object representing Employee
Field f = cl.getDeclaredField('name");
	// the name field of the Employee class
Object v = f.get(harry);
	// the value of the name field of the harry object,
	// i.e., the String object "Harry Hacker"
```
实际上，这段代码存在一个问题。由于 `name` 是一个私有字段，所以 `get` 方法将会抛出一个 `IllegalAccessException` 。**只能对可以访问的字段使用 `get, set` 方法**。==Java安全机制允许查看一个对象有哪些字段，但除非拥有访问权限，否则不允许读写这些字段的值==。

`get` 方法还有一个需要解决的问题。`name` 字段是一个 `String` ，因此把它作为 `Object` 返回没有什么问题。但假定我们想要查看 `salary` 字段，它属于 `double` 类型，而Java中数值类型不是对象。要想解决这个问题，可以使用 `Field` 类中的 `getDouble` 方法，此时反射机制将会自动将这个字段值、打包到相应的对象包装器中。

**反射机制的默认行为受限于Java的访问控制**。不过，可以调用 `Field, Method` 或 `Constructor` 对象的 `setAccessible` 方法、覆盖Java的访问控制。例如：
```java
f.setAtcessible(true); // now OK to call f.get(harry);
```
`setAccessible` 方法是 `AccessibleObject` 类中的一个方法，它是 `Field, Method, Constructor` 类的公共超类。这个特性是为调试、持久存储和类似机制 *debuggers, persistent storage, and similar mechanisms* 提供的。稍后将利用它编写一个通用的 `toString` 方法。如果不允许访问，`setAccessible` 调用会抛出一个异常。**访问可以被模块系统 *the module system*（卷II第9章）或安全管理器（卷II第10章）拒绝**，后者并不常用，不过在Java 9中，由于Java API是模块化的，每个程序都包含模块。

==由于太多的库都使用了反射，所以当你使用反射访问一个模块中的非公有特性时，Java 9和10只会给出一个警告==。例如，本节最后示例会查看 `ArrayList` 和 `Integer` 对象的内部。运行这个程序时，控制台上会出现以下看起来不太妙的消息。
```
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by objectAnalyzer.ObjectAnalyzer (file:/home/cay
	/books/cj11/code/v1ch05/bin/) to field java.util.ArrayList.serialVersionUID
WARNING: Please consider reporting this to the maintainers of
	objectAnalyzer.ObjectAnalyzer
WARNING: Use --illegal-access=warn to enable warnings of further illegal
	reflective access operations
WARNING: All illegal access operations will be denied in a future release
```
**目前而言，可以禁用这些警告**。需要把 `java.base` 模块中的 `java.util` 和 `java.lang` 包“打开”为无名模块 *unnamed module* 。参见卷II第9章。语法如下：
```bash
$ java --add-opens java.base/java.util=ALL-UNNAMED \
	--add-opens java.base/java.lang=ALL-UNNAMED \
	objectAnalyzer.ObjectAnalyzerTest
```
或者，也可以运行以下命令、来查看这个程序在将来的Java版本中有何表现。这个程序将以一个 `IllegalAccessException` 异常而失败。
```bash
$ java --illegal-access=deny objectAnalyzer/ObjectAnalyzerTest
```
> 注释：将来的库有可能使用**可变句柄** `variable handles` 而不是反射来读写字段。`VarHandle` 和 `Field` 类似。可以用它读写一个特定类任意实例的特定字段 *read or write a specific field of any instance of a specific class* 。不过，要得到一个 `VarHandle` ，库代码需要一个 `Lookup` 对象。
> ```java
> public Object getFieldValue(Object obj, String fieldName, Lookup lookup)
> 	throws NoSuchFieldException, IllegalAccessException {
> 	Class\<?> cl = obj.getClass();
> 	Field field = cl.getDeclaredField(fieldName);
> 	VarHandle handle = MethodHandles.privateLookupIn(cl,
> 		lookup).unreflectVarHandle(field);
> 	return handle.get(obj);
> } 
> ```
> 如果生成这个 `Lookup` 对象的模块有访问这个字段的权限，那么这种做法是可行的。模块中有些方法会直接调用 `MethodHandles.lookup()` ，这会得到封装了调用者访问权限的一个对象（？）。采用这种方式，一个模块可以为另一个模块提供权限，允许访问私有成员。实际问题是，如何能在提供这些权限的同时、尽量减少麻烦。

尽管仍然可以这么做，不过我们来看一个**可用于任意类的通用 `toString` 方法**（见 `objectAnalyzer/ObjectAnalyzerTest.java` ）。这个泛型 `toString` 方法使用 `getDeclaredFields` 获取所有的数据字段，然后使用 `setAccessible` 便利方法将所有的字段设置为可访问的。对于每个字段，将获得名字和值。通过递归调用 `toString` 方法，将每个值转换为字符串。

这个泛型 `toString` 方法需要解决几个复杂的问题。**循环引用将有可能导致无限递归**。因此，`ObjectAnalyzer` 将跟踪已被访问过的对象。另外，为了能够査看数组内部，需要采用一种不同的方式。有关这种方式的具体内容，在下一节详细论述。

可以使用这个 `toString` 方法，查看任意对象的内部信息。例如，下面这个调用：
```java
var squares = new ArrayList<Integer>();
for (int i = 1; i <= 5; ++i) squares.add(i * i);
	System.out.println(new ObjectAnalyzer().toString(squares));
```
将会产生下时的打印结果（整理了一下）：
```java
java.util.ArrayList[elementData=class 
java.lang.Object[]{java.lang.Integer[value=1][][],
java.lang.Integer[value=4][][],
java.lang.Integer[value=9][[],
java.lang.Integer[value=16][][],
java.lang.Integer[value=25][][],null,null,null,null,null},size=5][modCount=5][][]
```
还可以使用通用的 `toString` 方法，实现自定义类中的 `toString` 方法，如下所示：
```java
public String toString() {
	return new ObjectAnalyzer().toString(this);
}
```
这样可以轻松 *hassle-free* 提供一个通用 `toString` 方法，无疑也很有用。不过先不要高兴地太早，不要以为再也不用实现 `toString` 了，记住：能够不受控地访问类内部的日子已经屈指可数 *the days of uncontrolled access to internals are numbered* 。
```java
// Inheritance/objectAnalyzer/ObjectAnalyzerTest.java
package objectAnalyzer;

import java.util.*;

/**
 * This program uses reflection to spy on objects.
 */
public class ObjectAnalyzerTest {
	public static void main(String[] args) throws ReflectiveOperationException {
		var squares = new ArrayList<Integer>();
		for (int i = 1; i <= 5; ++i)
			squares.add(i * i);
		System.out.println(new ObjectAnalyzer().toString(squares));
	}
}
```
```java
// Inheritance/objectAnalyzer/ObjectAnalyzer.java
package objectAnalyzer;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;

public class ObjectAnalyzer {
	private ArrayList<Object> visited = new ArrayList<>();
	
	/**
	 * Converts an object to a string representation that lists all fields.
	 * @param obj an object
	 * @return a string with the object's class name and all field names and values
	 */
	 public String toString(Object obj) throws ReflectiveOperationException {
		 if (obj == null) return "null";
		 if (visited.contains(obj)) return "..."; // ends recursion
		 visited.add(obj);
		 
		 Class cl = obj.getClass();
		 if (cl == String.class) return (String) obj; // String type
		 if (cl.isArray()) { // Array type
			 String r = cl.getComponentType() + "[]{";
			 for (int i = 0; i < Array.getLength(obj); ++i) {
				 if (i > 0) r += ",";
				 Object val = Array.get(obj, i);
				 if (cl.getComponentType().isPrimitive()) r += val;
				 else r += toString(val);
			 }
			 return r + "}";
		 }
		 
		 String r = cl.getName();
		 // inspect the fields of this class and all superclasses
		 do {
			 r += "[";
			 Field[] fields = cl.getDeclaredFields();
			 AccessibleObject.setAccessible(fields, true); // set together !!
			 // get the names and values of all fields
			 for (Field f : fields) {
				if (!Modifier.isStatic(f.getModifiers())) {
					if (!r.endsWith("[")) r += ",";
					r += f.getName() + "=";
					Class t = f.getType();
					Object val = f.get(obj);
					if (t.isPrimitive()) r += val;
					else r += toString(val);
				}
			 }
			 r += "]";
			 cl = cl.getSuperclass();
		 } while (cl != null);
		 
		 return r;
	 }
}
```
在Eclipse中直接运行时，报错：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209261228555.png)
按照如下命令运行，出现结果—— `elementData` 是 `ArrayList` 类中的一个 `Object[]` 字段：
```bash
$ $ java --add-opens java.base/java.util=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED objectAnalyzer.ObjectAnalyzerTest
java.util.ArrayList[elementData=class java.lang.Object[]{java.lang.Integer[value=1][][],java.lang.Integer[value=4][][],java.lang.Integer[value=9][][],java.lang.Integer[value=16][][],java.lang.Integer[value=25][][],null,null,null,null,null},size=5][modCount=5][][]
```

> [API] `java.Iang.reflect.AccessibleObject` 1.2
> - `void setAccessible(boolean flag)`
> 设置或取消这个反射对象的可访问标志 *sets or clears the accessibility flag for this accessible object* 。如果拒绝访问则抛出一个 `IllegalAccessException` 异常。
> - `boolean trySetAccessible()` 9
> 为这个可访问对象设置可访问标志，如果访问被拒绝则返回 `false` 。
> - `boolean isAccessible()`
> 返回这个可访问对象的可访问标志的值。
> - `static void setAccessible(AccessibleObject[] array, boolean flag)`
> 一个便利方法，用于设置一个对象数组的可访问标志。

> [API] `java.lang.Class` 1.1
> - `Field getField(String name)`
> - `Field[] getFields()`
> 返回指定名称的公有字段，或包含所有这些字段的数组。
> - `Field getDeclaredField(String name)`
> - `Field[] getDeclaredFields()`
> 返回类中声明的给定名称的字段，或者包含声明的全部字段的数组。

> [API] `java.lang.reflect.Field` 1.1
> - `Object get(Object obj)`
> 返回 `obj` 对象中用这个 `Field` 对象描述的字段的值。
> - `void set(Object obj, Object newValue)`
> 将 `Obj` 对象中这个 `Field` 对象描述的字段设置为一个新值。

## 5.7.5 使用反射编写泛型数组代码
**`java.lang.reflect` 包中的 `Array` 类允许动态地创建数组**。例如，`Arrays` 类中的 `copyOf` 方法实现中就使用了这个类。应该记得这个方法可以用于扩展一个已经填满的数组。
```java
var a = new Employee[100];
...
// array is full
a = Arrays.copyOf(a, 2 * a.length);
```
如何编写这样一个通用的方法呢？好在 `Employee[]` 数组能转换为 `Object[]` 数组，这让人感觉很有希望。下面进行第一次尝试。
```java
public static Object[] badCopyOf(Object[] a, int newLength) { // not useful
	Object[] newArray = new Object[newlength];
	System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));
	return newArray;
}
```
然而，在实际使用得到的数组时、会遇到一个问题。这段代码返回的数组类型是一个**对象**数组（ `Object[]` ），这是由于我们使用了下面这行代码创建数组：
```java
new Object[newLength]
```
一个对象数组**不能**强制转换成雇员数组 `Employee[]` 。如果这样做，则Java虚拟机在运行时将会产生一个 `ClassCastException` 异常。关键是，前面已经看到，**Java数组会记住每个元素的类型，即创建数组时 `new` 表达式中使用的元素类型**。将一个 `Employee[]` 临时地转换成 `Object[]` 数组，然后再把它转换回来是可以的，但**一个从开始就是 `Object[]` 的数组却永远不能转换成 `Employe[]` 数组**。

**为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组**。为此，需要 `java.lang.reflect` 包中 `Array` 类的一些方法。其中最关键的是 `Array` 类中的静态方法 `newInstance` ，它能够构造一个新数组。在调用这个方法时必须提供两个参数，一个是数组的元素类型，一个是数组的长度。
```java
Object newArray = Array.newInstance(componentType, newLength);
```
为了能够具体实现，我们需要获得新数组的长度和元素类型。可以通过**调用 `Array.getLength(a)` 获得数组的长度**——`Array` 类的静态 `getLength` 方法，会返回一个数组的长度。而要获得新数组的元素的类型 *get the component type of the new array* ，就需要进行以下工作：
1. 首先获得 `a` 数组的 `Class` 对象。
2. 确认它确实是一个数组。
3. 使用 `Class` 类（定义这个方法只是为了「表示数组的类对象」）的 `getComponentType` 方法，确定数组的正确类型。

为什么 `getLength` 是 `Array` 的方法，而 `getComponentType` 是 `Class` 的方法呢？ 我们也不清楚。反射方法的分布有时确实显得有点古怪。下面是这段代码：
```java
public static Object goodCopyOf(Object a, int newLength) {
	Class cl = a.getClass();
	if (!cl.isArray()) return null;
	Class componentType = cl.getComponentType();
	int length = Array.getLength(a);
	Object newArray = Array.newInstance(componentType, newLength);
	System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));
	return newArray;
}
```
注意，**这个 `CopyOf` 方法可以用来扩展任意类型的数组，而不仅是对象数组**。
```java
int[] a = {1, 2, 3, 4, 5};
a = (int[])goodCopyOf(a, 10);
```
为了能够实现上述操作，**应将 `goodCopyOf` 的参数声明为 `Object` 类型**，.而不要声明为对象型数组（ `Object[]` ）。如整型数组类型 `int[]` 可以被转换成 `Object` ，但不能转换成对象数组（包括 `Object[]` ）；**对象数组类型可以转换为 `Object[]` 并再转换回来；一开始就是 `Object[]` 就不能转换为其他对象数组类型**。
 
程序 `Inheritance/arrays/CopyOfTest.java` 显示了两个方法的具体使用。请注意，将 `badCopyOf` 的返回值进行类型转换将会抛出一个异常。
```java
//  Inheritance/arrays/CopyOfTest.java
package arrays;

import java.lang.reflect.*;
import java.util.*;

/**
 * This program demonstrates the use of reflection for manipulating arrays.
 */
public class CopyOfTest {
	public static void main(String[] args) {
		int[] a = {1, 2, 3};
		a = (int[]) goodCopyOf(a, 10);
		System.out.println(Arrays.toString(a));
		
		String[] b = {"Tom", "Dick", "Harry"};
		b = (String[]) goodCopyOf(b, 10);
		System.out.println(Arrays.toString(b));
		
		System.out.println("The following call will generate an exception.");
		b = (String[]) badCopyOf(b, 10);
	}
	
	/**
	 * This method attempts to grow an array by allocating a new array and copying all elements.
	 * @param a the array to grow
	 * @param newLength the new length
	 * @return a larger array that contains all elements of a. However, the returned
	 * array has type Object[], not the same type as a
	 */
	public static Object[] badCopyOf(Object[] a, int newLength) { // not useful
		var newArray = new Object[newLength];
		System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));
		return newArray;
	}
	/**
	 * This method grows an array by allocating a new array of the same type and
	 * copying all elements
	 * @param a the array to grow. This can be an object array or a primitive
	 * type array
	 * @return a larger array that contains all elements of a.
	 */
	public static Object goodCopyOf(Object a, int newLength) {
		Class cl = a.getClass();
		if (!cl.isArray()) return null;
		Class componentType = cl.getComponentType();
		int length = Array.getLength(a);
		Object newArray = Array.newInstance(componentType, newLength);
		System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));
		return newArray;
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209261716475.png)

> [API] `java.lang.reflect.Array` 1.1
> - `static Object get(Object array, int index)`
> - `static xxx getXxx(Object array, int index)`
> `xxx` 是 `boolean, byte, char, double, float, int, long, short` 之中的一种基本类型。这些方法将返回存储在给定数组中给定索引位置上的值。
> - `static void set(Object array, int index, Object newValue)`
> - `static setXxx(Object array, int index, xxx newValue)`
> `xxx` 是 `boolean, byte, char, double, float, int, long, short` 之中的一种基本类型。这些方法将一个新值存储到给定数组中的给定位置上。
> - `static int getLength(Object array)
> 返回给定数组的长度。
> - `static Object newInstance(Class componentType, int length)
> - `static Object newInstance(Class componentType, int[] lengths)
> 返回一个具有给定类型、给定维数的新数组。

## 5.7.7 调用任意方法
**在C和C++中，可以通过一个函数指针执行任意函数**。从表面上看，Java没有提供方法指针，即Java没有提供途径、将一个方法的存储地址传给另外一个方法，以便第二个方法能够随后调用它。事实上，Java设计者曾说过：方法指针是很危险的，并且常常会带来隐患。他们认为**Java提供的接口和lambda表达式**（在下一章讨论）**是一种更好的解决方案**。然而，**反射机制允许你调用任意的方法**。
> 注释：微软公司为自己的非标准Java语 言（以及后来的C#）增加了另一种被称为委托 `delegate` 的方法指针类型，它与本节讨论的 `Method` 类不同。然而，在下一章中讨论的内部类比委托更加有用。

为了能够看到方法指针的工作过程，先回忆一下利用 `Field` 类的 `get` 方法查看对象字段的过程。与之类似，**`Method` 类中有一个 `invoke` 方法，允许你调用包装在当前 `Method` 对象中的方法**。`invoke` 方法的签名是：
```java
Object invoke(Object obj, Object... args)
```
第一个参数是隐式参数，其余的对象提供了显式参数（在Java SE 5.0以前的版本中，必须传递一个对象数组，如果没有显式参数就传递一个 `null` ）。

**对于静态方法，第一个参数可以被忽略，即可以将它设置为 `null`** 。例如，假设用 `m1` 代表 `Employee` 类的 `getName` 方法，下面这条语句显示了如何调用这个方法：
```java
String n = (String)m1.invoke(harry);
```
**如果返回类型是基本类型，`invoke` 方法会返回其包装器类型**。例如，假设 `m2` 表示 `Employee` 类的 `getSalary` 方法，那么返回的对象实际上是一个 `Double` ，必须相应地完成强制类型转换，再使用自动拆箱将它转换为一个 `double` ：
```java
double s = (Double)m2.invoke(harry);
```

如何得到 `Method` 对象呢？当然，可以通过调用 `getDeclaredMethods` 方法，然后对返回的 `Method` 对象数组进行查找，直到发现想要的方法为止。也可以**通过调用 `Class` 类中的 `getMethod` 方法得到想要的方法**。它与 `getField` 方法类似，`getField` 方法根据表示字段名的字符串，返回一个 `Field` 对象。然而，**有可能存在若干个同名方法，因此要格外小心**。有鉴于此，还必须提供想要的方法的参数类型，以确保能准确地得到想要的那个方法。`getMethod` 的签名是：
```java
Method getMethod(String name, Class... parameterTypes)
```
例如，下面说明了如何获得 `Employee` 类的 `getName` 方法和 `raiseSalary` 方法的方法指针。
```java
Method m1 = Employee.class.getMethod("getName");
Method m2 = Employee.class.getMethod("raiseSalary", double.class);
```
可以使用类似的方式调用任意的构造器。**将构造器的参数类型提供给 `Class.getConstructor` 方法，并将参数值提供给 `Constructor.newInstance` 方法**：
```java
Class cl = Random.class; // or any other class with a constructor that
	// accepts a long parameter
Constructor cons = cl.getConstructor(long.class);
Object obj = cons.newInstance(42L);
```
到此为止，已经学习了使用 `Method` 对象的规则。下面来看如何具体使用。程序 `Inheritance/methods/MethodTableTest.java` 会打印诸如 `Math.sqrt, Math.sin` 这样的数学函数的值表。打印的结果如下所示：
 ![结果表|500x200](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209252017358.png)
当然，这段打印数学函数值表的代码与具体的数学函数无关。在这里，`f` 是一个 `Method` 类型的对象。由于正在调用的方法是一个静态方法，所以 `invoke` 的第一个参数是 `null` 。
```java
double dx = (to - from) / (n - 1);
for (double x = from; x <= to; x += dx) {
	double y = (Double)f.invoke(null, x);
	System.out.printf("X10.4f | %10.4f%n", x, y);
}
```
为了将 `Math.sqrt` 函数（ `Math` 类中的一个方法，有一个 `double` 类型的参数）表格化，需要将 `f` 设置为：
```java
Math.class.getMethod("sqrt", double.class)
```

`Inheritance/methods/MethodTableTest.java` 给出了通用制表程序和两个测试程序的全部代码。
```java
package methods;

import java.lang.reflect.*;

/**
 * This program shows how to invoke methods through reflection.
 */
public class MethodTableTest {
	public static void main(String[] args) throws ReflectiveOperationException {
		// get method pointers to the square and sqrt methods
		Method square = MethodTableTest.class.getMethod("square", double.class);
		Method sqrt = Math.class.getMethod("sqrt", double.class);
		// print tables of x- and y- values
		printTable(1, 10, 10, square);
		printTable(1, 10, 10, sqrt);
	}
	
	/**
	 * Returns the square of a number
	 * @param x a number
	 * @return x squared
	 */
	public static double square(double x) {
		return x * x;
	}
	
	/**
	 * Prints a table with x- and y- values for a method
	 * @param from the lower bound for the x-values
	 * @param to the upper bound for the x-values
	 * @param n the number of rows in the table
	 * @param f a method with a double parameter and double return value
	 */
	public static void printTable(double from, double to, int n, Method f) 
		throws ReflectiveOperationException {
		// print out the method as table header
		System.out.println(f);
		double dx = (to - from) / (n - 1);
		for (double x = from; x <= to; x += dx) {
			double y = (Double) f.invoke(null, x);
			System.out.printf("%10.4f | %10.4f%n", x, y);
		}
	}
}
``` 
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209261720112.png)
上述程序清楚地表明，使用 `Method` 对象可实现C中函数指针（或C#中的委派）能完成的所有操作。**同C一样，这种程序设计风格不太简便，出错的可能性也比较大**。如果在调用方法时提供了一个错误的参数，那么 `invoke` 方法将会抛出一个异常。

另外，**`invoke` 的参数和返回值必须是 `Object` 类型**。这就意味着必须来回进行多次的强制类型转换。这样做，编译器将会丧失检查代码的机会，以至于等到测试阶段才会发现错误，而这时找到并改正它们会麻烦得多。不仅如此，**使用反射获得方法指针的代码，要比直接调用方法的代码慢得多**。

有鉴于此，建议**仅在绝对必要时才在你自己的程序中使用 `Method` 对象**。通常更好的做法是，**使用接口以及Java SE 8引入的 `lambda` 表达式**（第6章介绍）。特别要重申：我们建议Java开发者**不要使用回调函数的 `Method` 对象**。可以使用回调的接口 *interfaces for the callbacks* ，使得代码的执行速度更快，更易于维护。
 > [API] `java.lang.reflect.Method` 1.1
> - `public Object invoke(Object implicitParameter, Object[] explicitParamenters)`
> 调用这个对象所描述的方法，传递给定参数，并返回方法的返回值。对于静态方法，把 `null` 作为隐式参数传递。使用包装器传递基本类型的值。基本类型的返回值必须拆包 `Primitive type return values must be unwrapped` 。
---
# 5.8 继承的设计技巧
在最后，给出一些对设计继承关系很有帮助的建议。
1. **将公共操作和字段放在超类中**
这就是为什么将姓名字段放在 `Person` 类中，而没有将它放在 `Employee` 和 `Student` 类中的原因。
2. **不要使用受保护的字段**
有些程序员认为，将大多数的实例字段定义为 `protected` 是一个不错的主意，这样子类就能在需要的时候直接访问它们。然而，**`protected` 机制并不能够带来更好的保护**，其原因主要有两点。第一，**子类集合是无限制的**，任何一个人都能由你的类派生一个子类，然后编写代码以直接访问 `protected` 实例字段，从而破坏了封装性。第二，在Java语言中，在同一个包中的所有类都可以访问 `proteced` 字段，而不管它是否为这个类的子类。
不过，`protected` 方法对于指示「那些不提供一般用途而应在子类中重新定义 *are not ready for general use and should be redefined in subclasses* 的方法」很有用。
3. **使用继承实现“is-a”关系**
使用继承很容易达到节省代码的目的，但有时候也被人们滥用。例如，假设需要定义一个 `Contractor` 钟点工类。钟点工有姓名和雇佣日期，但没有工资。他们按小时计薪，并不会因为拖延时间而获得加薪。这似乎在诱导人们由 `Employee` 派生出子类 `Contractor` ，然后再增加一个 `hourlyWage` 字段。 
   ```java
   public class Contractor extends Employee {
	   private double hourlyWage;
	   ...
   }
   ```
这并不是一个好主意。因为这样一来，每个钟点工对象中都包含了工资和时薪这两个字段。在实现打印支票或税单的方法时，会带来无穷的麻烦。与不采用继承相比，使用继承来实现最后反而会写很多代码。钟点工与雇员之间不属于"is-a"关系。钟点工不是特殊的雇员。
4. **除非所有继承的方法都有意义，否则不要使用继承**
假设想编写一个 `Holiday` 类。毫无疑问，每个假日也是一天，并且一天可以用 `GregorianCalendar` 类的实例表示，因此可以使用继承。
   ```java
   class Holiday extends CregorianCalendar { ... }
   ```
很遗憾，在继承的操作中，假日集合不是**封闭**的 *not closed* 。在 `GregorianCalendar` 中有一个公有方法`add` ，可以将假日转换成非假日：
   ```java
   Holiday Christmas;
   Christmas.add(Calendar.DAY_OF_MONTH, 12);
   ```
因此，继承对于这个例子来说并不太适宜。需要指出，如果扩展 `LocalDate` 就不会出现这个问题。由于这个 `LocalDate` 类是不可变的，所以没有任何方法会把假日变成非假日。
5. **在覆盖方法时，不要改变预期的行为**
**替换原则不仅适用于语法，也适用于行为**，这似乎更加重要。**在覆盖一个方法时，不应该毫无原由地改变它的行为**。就这一点而言，**编译器不会提供任何帮助，即编译器不会检查重新定义的方法是否有意义**。例如，可以重定义 `Holiday` 类中的 `add` 方法来“修正”这个方法的问题，或什么也不做，或抛出一个异常，或前进到下一个假日。然而这些都违反了替换原则。对于以下语句序列，不管 `x` 的类型是 `GregorianCalendar` 还是 `Holiday` ，执行语句后都应该得到**预期行为**：
   ```java
   int d1 = x.get(Calendar.DAY_OF_MONTH);
   x.add(Calendar.DAY_OF_MONTH, 1);
   int d2 = x.get(Calendar.DAY_OF_HONTH);
   System.out.println(d2 - dl);
   ```
当然，这是个难题。人们可能就预期行为的含义争论不休。例如，有些人争论说，替换原则要求 `Manager.equals` 忽略 `bonus` 字段，因为 `Employee.equals` 没有它（就忽略了这个字段）。实际上，凭空讨论这些问题毫无意义。归根结底，关键在于**在子类中覆盖方法时，不要偏离最初的设计想法**。
6. **使用多态，而非类型信息**
只要看到类似下面的代码，都应考虑使用多态。
   ```java
   if (x is of type 1) action1(x);
   else if (x is of type 2) action2(x);
   ```
`action1` 与 `action2` 表示的是相同的概念吗？如果是相同的概念，就应为这个概念定义一个方法，并将其放置在两个类的超类或接口中，然后，就可以调用 `X.action()` 。以使用「多态性提供的动态分派机制」执行正确的动作。
==使用多态方法或接口实现的代码，比使用对多个类型进行检测的代码更加易于维护和扩展==。
7. **不要过多地使用反射**
反射机制使人们可以在运行时查看字段和方法，从而编写出更具有通用性的程序。这种功能对于编写系统程序极其实用，但**通常不适于编写应用程序**。反射是很脆弱的，即编译器很难帮助你查找程序中的错误，因此只有在运行时才会发现错误并导致异常。

现在了解了「Java如何支持面向对象编程」的基础内容：类、继承和多态。后面介绍两个髙级主题：**接口和lambda表达式，它们对于有效地使用Java非常重要**。