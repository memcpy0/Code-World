第11章　分布式对象
▲客户与服务器的角色
▲远程方法中的参数与返回值
▲远程方法调用
▲远程对象激活
▲RMI编程模型
每过一段时间，程序员社区就会开始考虑将“无所不在的对象”作为所有问题的解决之道。其思想是所有相互协作的对象就像一个和睦的家庭，彼此都知道对方在哪里。当在一台计算机上的某个对象需要调用在另一台计算机上的某个对象时，它就会发送一个包含这个请求的详细信息的网络消息。这个远程对象可能通过访问数据库也可能通过与其他对象通信来计算出响应。一旦该远程对象得到了客户端请求的东西，就将它送回客户端。在概念上讲，这个过程显得十分简单，但是你不能停留在表面，应该深入理解如何有效地利用分布式对象。
在本章，我们将聚焦用于两个Java虚拟机（可以运行在不同的计算机上）之间通信的远程方法调用（RMI）协议。曾几何时，RMI被认为是应用开发者可依赖的行之有效的开发技术。但是，现在RMI更多的只是被当作简单分布式对象系统的案例研究工具。11.1　客户与服务器的角色
所有分布式编程技术的基本思想都很简单：客户计算机产生一个请求，然后将这个请求通过网络发送到服务器。服务器处理这个请求，并发送回一个针对该客户端的响应，供客户端进行分析。图11-1展示了这个过程。
图11-1　在客户端与服务器之间传递对象
一开始我们就必须要声明：这些请求和响应并不是在Web应用程序中看到的请求和响应。这里的客户端并非是Web浏览器，它可以是执行具有任意复杂度的业务规则的任何应用程序。客户端应用程序可以与人类用户之间进行交互，但也可以没有这种交互。如果有这种交互，它可以拥有一个命令行或Swing用户界面。用于请求和响应数据的协议允许传递任意对象，而传统的Web应用程序只限于对请求使用HTTP协议，对响应使用HTML。
我们真正想要的是这样一种机制，客户端程序员以常规的方式进行方法调用，而无需操心将数据发送到网络上或者解析响应之类的问题。解决的办法是，在客户端为远程对象安装一个代理（proxy）。代理是位于客户端虚拟机中的一个对象，它对于客户端程序来说，看起来
就像是要访问的远程对象一样。客户调用此代理时，只需进行常规的方法调用。而客户端代理则负责使用网络协议与服务器进行联系。
同样，实现服务的程序员也不希望因与客户端之间的通信被绊住。解决方法是在服务器端安装第二个代理对象。该服务器代理与客户端代理进行通信，并且它将以常规方式调用服务器对象上的方法（参见图11-2）。
图11-2　使用代理的远程方法调用
代理之间是如何通信的呢？这要看以什么技术来实现它们。通常有三种选择：
·CORBA，通用对象请求代理架构，支持任何编程语言编写的对象之间的方法调用。CORBA使用二进制的Internet Inter-ORB协议（IIOP）来实现对象间的通信。
·Web服务架构是一个协议集，有时统一描述为WS-*。它也是独立于编程语言的，不过它使用基于XML的通信格式。用于传输对象的格式则是简单对象访问协议（SOAP）。
·RMI，Java的远程方法调用技术，支持Java的分布式对象之间的方法调用。
CORBA与SOAP都是完全独立于语言的。客户端与服务器程序可以由C、C++、C#、Java或者其他语言编写。你只需要提供一个接口描述，以说明你的对象的方法的签名以及能够处理的数据类型。该接口描述是用一种特殊的语言编写的，对于CORBA来说是接口定义语言（IDL），对于Web服务而言则是Web服务描述语言（WSDL）。
多年来，很少有人相信CORBA就是未来的对象模型。但是，到目前为止，CORBA的声誉只是：对于复杂实现与互操作性问题，有时值得用，并且也只取得了一定程度的成功。
Web服务在首次出现时喧噪一时，因为它承诺会更加简单，而且建立在WWW和XML的精华之上。但是，随着时间的推移和许多委员会工作的推进，其协议栈已经变得不简单了，因为它被要求具备越来越多CORBA一直具有的特性。XML协议具有可阅读性的优点（其实也只是一点点），这有助于查错。另一方面，处理XML是很大的性能瓶颈。最近，WS-*栈的光环已经褪去了许多，并且它也获得了相同的声誉，即对于复杂实现和互操作问题，有时值得用。
如果互相通信的程序都是由Java实现的，那么，CORBA与WS-*的通用性与复杂性就统统都是不需要的。Sun开发了一个更简单的机制，称为远程方法调用（RMI），专门针对Java应用之间的通信。
即使你在自己的应用程序中不打算使用RMI，学习它也是很值得的。通过一个直观的架构，你将会学到用于分布式应用程序编程的精髓。11.2　远程方法调用
分布式计算的关键是远程方法调用。在一台机器（称为客户端）上的某些代码希望调用在另一台机器（远程对象）上的某个对象的一个方法。要实现这一点，方法的参数必须以某种方式传递到另一台机器上，而服务器必须得到通知，去定位远程对象并执行要调用的方法，并且必须将返回值传递回去。
在详细浏览整个过程之前，我们需要指出，客户端/服务器这一术语用法只适用于单个的方法调用。调用远程方法的计算机对于这个调用来说是客户端，而处理这个调用的对象的宿主计算机对于这个调用来说是服务器。在某些情况下这两个角色完全有可能会颠倒过来，前一个调用的服务器在调用驻留在另一台计算机上的对象的某个远程方法时，它自己就变成了客户端。
存根与参数编组
当客户代码要在远程对象上调用一个远程方法时，实际上调用的是代理对象上的一个普通的方法，我们称此代理对象为存根（stub）。例如，
存根位于客户端机器上，而非服务器上，它知道如何通过网络与服务器联系。存根会将远程方法所需的参数打包成一组字节。对参数编码的过程称作参数编组（parameter marshalling），参数编组的目的是将参数转换成适合在虚拟机之间进行传递的格式。在RMI协议中，对象是使用序列化机制进行编码的，第1章描述了这种机制。在SOAP协议中，对象被编码为XML。
总的来说，客户端的存根方法构造了一个信息块，它由以下几部分组成：
·被使用的远程对象的标识符。
·被调用的方法的描述。
·编组后的参数。
然后，存根将此信息发送给服务器。在服务器一端，接收器对象执行以下动作：
1）定位要调用的远程对象。
2）调用所需的方法，并传递客户端提供的参数。
3）捕获返回值或该调用产生的异常。
4）将返回值编组，打包送回给客户端存根。
客户端存根对来自服务器端的返回值或异常进行反编组，其结果就成为调用存根的返回值。如果远程方法抛出了一个异常，那么存根就在客户端的虚拟机中重新抛出该异常。图11-3展示了一次远程方法调用的信息流。
图11-3　参数编组
这个过程显然很复杂，不过好消息是，这一切都是完全自动的，而且在很大程度上它对程序员是透明的。
实现远程对象和获取客户端存根的细节有赖于分布式对象采用的技术。在下面的小节中，我们将深入学习RMI。11.3　RMI编程模型
为了介绍RMI编程模型，我们从一个简单的实例入手。远程对象表示的是一个仓库，而客户端程序向仓库询问某个产品的价格。在下面的小节中，你将看到如何实现和启动服务器与客户端程序。11.3.1　接口与实现
远程对象的能力是由在客户端和服务器之间共享的接口所表示的。例如，程序清单11-1中的接口描述了远程仓库对象所提供的服务。
程序清单11-1　warehousel/Warehouse.java
注意：在本章中，我们不使用包。正如你将要看到的，远程应用的部署很复杂，我们想避免因包目录而带来的额外的复杂性。
远程对象的接口必须扩展Remote接口，它位于java.rmi包中。接口中的所有方法还必须声明抛出RemoteException异常，这是因为远程方法调用与生俱来就缺乏本地调用的可靠性，远程调用总是存在失败的可能。例如，服务器或者网络连接可能暂时不可用，或者可能出现网络故障。客户端代码必须时刻准备好处理这些问题。基于这些原因，Java编程语言要求每一次远程方法调用都必须捕获RemoteException，并且指明当调用不成功时应执行的相应的处理操作。
接下来，在服务器端必须提供这样的类，它真正实现了在远程接口中声明的工作。参见程序清单11-2。
程序清单11-2　warehouse1/WarehouseImpl.java
注意：WarehouseImpl的构造器声明了会抛出RemoteException异常，因为其超类的构造器会抛出这个异常，在无法连接到跟踪远程对象的网络服务时会抛出这个异常。
你可以看出这个类是远程方法调用的目标，因为它扩展自UnicastRemoteObject，这个类的构造器使得它的对象可供远程访问。“最小阻抗路径”是从UnicastRemoteObject中导出的，本章中的所有服务实现类也都是如此。
有时候可能不希望服务器类扩展UnicastRemoteObject，也许是因为实现类已经扩展了其他的类。在这种情况下，读者需要手动实例化远程对象，并将它们传给静态的exportObject方法。如果不扩展UnicastRemoteObject，可以在远程对象的构造器中像下面这样调用exportObject方法：
其中，第二个参数是0，表明任何合适的端口都可用来监听客户连接。
注意：Unicast这个术语是指我们通过产生对单一的IP地址和端口的调用来定位远程对象这一事实。这是Java SE中惟一支持的机制。更复杂的分布式对象系统（诸如JINI）会考虑到对在多个不同的服务器上的远程对象的“Multicast”查找。11.3.2　RMI注册表
要访问服务器上的一个远程对象时，客户端首先需要一个本地的存根对象。可是客户端如何请求得到该存根呢？最普通的方法是调用另一个服务对象上的一个远程方法，以返回值的方式取得存根对象。然而，这就成了先有鸡还是先有蛋的问题。第一个远程对象总要通过某种方式进行定位。为此，JDK提供了自举注册服务（bootstrap registry service）。
服务器程序应该使用自举注册服务来注册至少一个远程对象。要注册一个远程对象，需要一个RMI URL和一个对实现对象的引用。
RMI的URL以rmi：开头，后接服务器以及一个可选的端口号，接着是远程对象的（希望是）唯一的名字。例如：
默认情况下，主机名是localhost，端口号为1099。服务器告诉注册表在给定位置将这个名字关联或“绑定”到该对象。
下面的代码将一个WarehouseImpl对象注册到同一个服务器上的RMI注册表中：
程序清单11-3中的程序直接构造并注册了一个WarehouseImpl对象。
程序清单11-3　warehouse1/WarehouseServer.java
注意：基于安全原因，一个应用只有当它与注册表运行在同一个服务器时，该应用才可以绑定、取消绑定，或重绑定注册对象的引用。这可以防止有恶意的客户端修改注册表信息。但是，任何客户端都可以查找对象。
客户端可以通过下面的调用来枚举所有注册过的RMI对象：
NameClassPair是一个助手类，它包含绑定对象的名字和该对象所属类的名字。例如，下面的代码可以显示所有注册对象的名字：
客户端可以通过下面的方式，来指定服务器和远程对象的名字，以此获得访问远程对象所需的存根。
注意：在一个全局注册表中，想保持一个名字的惟一性非常困难，因此不应该将此技术作为定位服务器端对象的通用方法。相反，自举服务只应该用来注册非常少的远程对象。然后使用这些对象来定位其他的对象。
程序清单11-4展示了客户端如何获得远程仓库对象的存根，并调用远程的getPrice方法。图11-4展示了其控制流。客户端获得了一个Warehouse存根，并在其上调用了getPrice方法。在后台，存根与服务器联系，并在WarehouseImpl对象上调用getPrice方法。
图11-4　调用远程的getPrice方法
程序清单11-4　warehouse1/WarehouseClient.java
javax.naming.InitialContext 1.3
·InitialContext（）
构建一个命名上下文，用来访问RMI注册表。
javax.naming.Context 1.3
·static Object lookup（String name）
返回给定名字的对象。如果该名字尚未绑定则抛出NamingException异常。
·static void bind（String name，Object obj）
将name与obj对象绑定。如果该对象已经绑定则抛出NameAlreadyBoundException异常。
·static void unbind（String name）
解除该名字的绑定。解除一个不存在的绑定是合法的。
·static void rebind（String name，Object obj）
将name与obj对象绑定。替换掉以前的绑定。
·NamingEnumeration<NameClassPair>list（String name）
返回一个枚举列表，其中列出了所有匹配的绑定对象。使用“rmi：”调用该方法可以列出所有RMI对象。
javax.naming.NameClassPair 1.3
·String getName（）
获取已命名对象的名字。
·String getClassName（）
获取已命名对象所属的类名。
java.rmi.Naming 1.1
·static Remote lookup（String url）
返回URL对应的远程对象。如果该名字尚未绑定，则抛出NotBoundException异常。
·static void bind（String name，Remote obj）
将name与远程对象obj绑定。如果该对象已经绑定则抛出AlreadyBoundException异常。
·static void unbind（String name）
解除对该名字的绑定。如果该名字没有绑定则抛出NotBound异常。
·static void rebind（String name，Remote obj）
将name与远程对象obj绑定。替换掉以前的绑定。
·static String[]list（String url）
参数url指定了某个注册表的位置，返回由该注册表中所有URL组成的字符串数组。此数组代表注册表中当前所有名字的一个快照。11.3.3　部署程序
部署一个使用RMI的应用是比较棘手的。因为很多事情都有可能出错，而一旦出错，可以得到的错误信息又相当匮乏。我们发现，按照客户端和服务器将类进行分隔，从而在真实条件下对部署进行测试是很有价值的。
创建两个目录，分别存放用于启动服务器和客户端的类。
当部署RMI应用时，通常需要动态地将类交付给运行程序，其中一个例子就是RMI注册表。请记住注册表的一个实例要服务许多不同的RMI应用。RMI注册表需要有权限访问注册的服务接口的类文件，但是，当注册表启动时，无法预测将来会产生的所有注册请求。因此，RMI注册表会动态地加载之前从未遇到过的所有远程接口的类文件。
动态交付的类文件是通过标准的Web服务器发布的。在我们所举的情况中，服务器程序需要使Warehouse.class文件对于RMI注册表来说是可获得的，因此我们将这个文件放到了第三个称为download的目录中：
我们使用Web服务器来服务这个目录中的内容。
当应用被部署时，服务器、RMI注册表、Web服务器和客户端可以位于四台不同的计算机上，参见图11-5。但是，出于测试的目的，我们将只使用一台计算机。
图11-5　在仓库应用中的服务器调用
注意：由于安全的原因，作为JDK一部分的rmiregistry服务只允许来自同一台主机的绑定调用。也就是说，服务器和rmiregistry进程需要位于同一台计算机上。但是，RMI架构允许更通用的支持多台服务器的RMI注册表实现。
为了测试这个示范应用，需要使用NanoHTTPD Web服务器，可以从http://elonen.iki.fi/code/nanohttpd处得到这个服务器。这个小型的Web服务器是在单个Java源文件中实现的。打开一个新的控制台窗口，转到download目录，然后将NanoHTTPD.java复制到这个目录中。使用下面的命令来编译该源文件并启动这个Web服务器：
其中，命令行参数是端口号。如果你的机器上的8080端口已被占用，可以使用任何其他可用的端口。
接下来，打开另一个控制台窗口，转到不包含任何类文件的某个目录，并启动RMI注册表：
警告：在启动RMI注册表之前，请确保CLASSPATH环境变量没有进行任何设置，并仔细检查当前目录是否确实不包含任何类文件。否则，RMI注册表可能会找到一些假冒的类文件，这使得在注册表需要从另一个不同的来源下载额外的类文件时会产生混淆。这种行为的原因，可以查看http://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html。简单地讲，每个存根对象都有一个代码基项，指出了它是从何处加载的。这个代码基用来加载它所依赖的类。如果RMI注册表在本地找到了这样的类，那么它的代码基就会被设置为错误的值。
现在已经准备好启动服务器了。打开第三个控制台窗口，转到server目录，并执行下面的命令：
java.rmi.server.codebase属性指出了服务类文件的URL。服务器程序将这个URL传递给RMI注册表。
看一眼运行NanoHTTPD的控制台窗口，你就会发现一条消息，它在说明Warehouse.class文件已经注册到了RMI注册表中。
警告：确保代码基URL以斜杠“/”结尾非常重要。
注意，服务器程序并没有退出。这看起来有些奇怪，毕竟这个程序只是创建并注册了一个WarehouseImpl对象。实际上，main方法在注册完之后并没有像你预料的那样立即退出。当你创建了一个扩展自UnicastRemoteObject的类的对象时，将会启动一个单独的线程，它将保持该程序无限地存活下去。因此，该程序仍旧在那里允许客户端连接它。
最后，打开第四个控制台窗口，转到client目录，运行：
你将会看到一条短消息，表示运行方法被成功调用（参见图11-6）。
注意：如果你只想测试基本的程序逻辑，那么可以将客户端和服务器的类文件放在同一个目录下。然后在这个目录中启动RMI注册表、服务器和客户端。但是，因为RMI类的加载很容易造成失败和混淆，所以我们觉得最好还是向你展示正确的用于动态类加载的设置。11.3.4　记录RMI活动的日志
如果用下面的选项启动服务器：
图11-6　测试一个RMI应用
那么服务器会在其控制台上将所有的远程方法调用记录到日志中。试着运行一下，你会对RMI的通信量有深刻的印象。
如果想查看额外的日志信息，就必须用标准的Java日志API来配置日志记录器。（参见第1卷第11章以了解有关日志记录的更多信息。）
可以用下面的内容创建一个logging.properties文件。
我们可以对设置进行调整，方法是为每一个日志记录器设置单独的等级而不是设置全局等级。表11.1列出了所有的RMI日志记录器。例如，要跟踪类的加载行为，可以设置为：
用以下选项启动RMI注册表：
表11-1　RMI日志记录器
用以下选项启动客户端与服务器：
下面代码为一个消息记录的例子，展示了类加载时的一个问题：RMI注册表找不到Warehouse类，因为Web服务器已经关闭了。
11.4　远程方法中的参数和返回值
在开始进行远程方法调用时，调用参数需要从客户端的虚拟机中移动到服务器的虚拟机中。在调用完成之后，返回值需要进行反方向传递。对于从一个虚拟机向另一个虚拟机传值，我们将其区分成两种情况：传递远程对象和传递非远程对象。例如，假设WarehouseServer的客户端将一个对Warehouse的引用（即，通过它可以调用远程的仓库对象的一个存根）传递给了另一个远程方法，这就是传递远程对象的实例。但是，大多数的方法参数都是普通的Java对象，而不是远程对象的存根。在我们的第一个示范应用中的getPrice方法的String参数就是这样的一个实例。11.4.1　传递远程对象
当一个对远程对象的引用从一个虚拟机传递到另一个虚拟机时，该远程对象的发送者和接收者都将持有一个对同一个实体的引用。这个引用并非是一个内存位置（内存位置在单个虚拟机内才有意义），而是由网络地址和该远程对象的惟一标识符构成的。这个信息封装在存根对象中。
从概念上讲，传递远程引用与在虚拟机内部传递本地对象引用很相似。但是，需要始终牢记的是在远程引用上的方法调用明显比在本地引用上的方法调用执行得慢，并且潜在地也更不可靠。11.4.2　传递非远程对象
考虑一下getPrice方法的String参数。这个字符串值需要从客户端复制到服务器上，我们不难想象字符串的副本是如何经由网络传输的。RMI机制也可以生成更复杂的对象的副本，只要这些对象是可序列化的。RMI使用第1章中描述的序列化机制来经由网络连接发送对象，这意味着任何实现了Serializable接口的类都可以用作参数和返回类型。
通过序列化来传递参数对远程方法的语义会产生很微妙的影响。当我们将对象传递给一个本地方法时，传递的是对象引用。如果该方法用某个修改方法对这个参数对象进行了操作，那么调用者会观察到这个变化。但是如果远程方法修改了某个序列化的参数，它修改的只是传递给它的副本，而调用者不会看到这种修改。
总结一下，在虚拟机之间传递值有两种机制：
·实现了Remote接口的类的对象将作为远程引用传递。
·实现了Serializable接口，但是没有实现Remote接口的类的对象将使用序列化进行复制。
这两种机制都是自动化的，而且不需要任何程序员的干预。请记住，序列化对于大型对象来说会比较慢，而且远程方法不能改变被序列化的参数。当然，你可以通过传递远程引用来避免这些问题。但是这么做代价太大：在远程引用上调用方法与调用本地方法相比，代价高得多。意识到这些开销有助于在设计远程服务时进行选择。
注意：远程对象是被自动垃圾回收的，就像本地对象一样。但是，分布式的垃圾收集器明显要复杂得多。当本地垃圾收集器发现对某个远程引用没有更多的本地使用时，它会通知分布式收集器这个服务器不再被该客户端所引用。当一个服务器不再被任何客户端所使用时，它就会被标记成垃圾。
我们的下一个示例程序将展示远程和可序列化对象的传递。我们将Warehouse接口修改为程序清单11-5的样子，如果给定关键词列表，这个仓库将返回最佳匹配的Product。
程序清单11-5　warehouse2/Warehouse.java
getProduct方法的参数具有List<String>类型。因此，参数值必须属于实现了List<String>接口的可序列化的类，例如ArrayList<String>。（我们的示范客户端传递了一个通过调用Arrays.asList方法而获得的值。幸运的是，这个方法也可以保证返回一个可序列化的列表。）
返回类型Product封装了产品的描述、价格和位置，参见程序清单11-6。
注意，Product类是可序列化的，服务器构建了一个Product对象，而客户端获取了它的一个副本（参见图11-7）。
图11-7　复制本地参数和结果对象
程序清单11-6　warehouse2/Product.java
有些细节值得注意。Product类有一个实例域，类型为远程接口Warehouse。仓库对象不是可序列化的，而它又包含大量的状态。因此，客户端接收了一个远程Warehouse对象的存根。这个存根可能与getProduct方法被调用的那个centralWarehouse存根会有所不同。在我们的实现中，有两种产品，烤箱和书，它们位于不同的仓库中。11.4.3　动态类加载
在下一个样例程序中，还有另一个微妙之处。关键词列表发送到了服务器，而且仓库也返回了Product类的一个实例。当然，客户端程序在编译时需要Product.class类文件。但是，只要我们的服务器程序无法找到关键词的匹配，它就会返回一件肯定让每个人都很高兴的产品：《Java核心技术》这本书。这个对象是Book类的实例，而Book类是Product的子类。
当客户端编译时，它也许从未看到过Book类。但是在运行时，它需要能够执行覆盖了Product方法的Book方法，这说明客户端需要拥有在运行时加载额外类的能力。客户端使用了与RMI注册表相同的机制，即类由Web服务器提供服务，RMI服务器类将URL传递给客户端，客户端创建要求下载这些类的HTTP请求。
只要一个程序从网络位置加载新的代码，就会涉及安全问题。正是由于这个原因，我们需要在动态加载类的RMI应用中使用安全管理器。（参见第9章有关类加载器和安全管理器的更多信息。）
使用RMI的程序应该安装一个安全管理器，去控制动态加载类的行为。可以用下面的指令安装：
注意：如果所有的类在本地都可以获得，那么实际上就不需要安全管理器。如果你在部署时就了解程序中所有的类文件，那么你就可以全部在本地部署它们。但是，经常发生的情况是，客户端或服务器程序会随时间的推移而不断地演化，并添加进新的类。这时你就能够从动态类加载中受益。只要你从其他来源加载代码，就需要安全管理器。
默认情况下，SecurityManager会限制程序中所有的代码去建立网络连接，但是，我们的程序需要建立到三个远程位置的网络连接：
·加载远程类的Web服务器
·RMI注册表
·远程对象
为了允许这些操作，需要提供一个策略文件。（我们在第9章中十分详细地介绍过策略文件。）下面的策略文件允许一个应用建立任何到端口号至少为1024的某个端口的网络连接。（RMI端口默认为1099，远程对象使用的端口也大于等于1024。我们使用8080端口来下载类。）
需要通过将java.security.policy属性设置为这个策略文件名，来指示安全管理器去读取该策略文件。可以使用下面这个调用。
或者，可以在命令行指定系统属性设置。
为了运行样例程序，请确保已经关闭了在前面的样例程序中启动的RMI注册表、Web服务器和服务器程序。打开四个控制台窗口，然后执行下面的步骤：
1）编译接口、实现、客户端和服务器类的源文件。
2）创建三个目录：client、server和download，然后按下面这样组装它们：
3）在第一个控制台窗口中，转到不包含任何类文件的某个目录，启动RMI注册表。
4）在第二个控制台窗口中，转到download目录下，启动NanoHTTP。
5）在第三个控制台窗口中，转到server目录下，启动服务器
6）在第四个控制台窗口中，转到client目录下，运行客户端
程序清单11-7展示了Book类的代码。注意，getDescription方法被覆盖为显示ISBN。当客户端程序运行时，它显示了《Java核心技术》这本书的ISBN，这证明Book类被动态加载了。程序清单11-8展示了仓库的实现。仓库拥有一个对备份仓库的引用。如果在这个仓库中找不到某个物品，就会搜索备份仓库。程序清单11-9展示了服务器程序。只有中心仓库进入了RMI注册表。注意，对备份仓库的远程引用可以传递给客户端，尽管它没有包括在RMI注册表中。当没有任何关键词匹配，并且《Java核心技术》这本书（其location域引用的是备份仓库）被发送给客户端时，就属于这种情况。
程序清单11-7　warehouse2/Book.java
程序清单11-8　warehouse2/WarehouseImpl.java
程序清单11-9　warehouse2/WarehouseServer.java
11.4.4　具有多重接口的远程引用
一个远程类可以实现多个接口。考虑远程接口ServiceCenter。
现在假设WarehouseImpl类实现了这个接口与Warehouse接口。当一个对ServiceCenter的引用被传递到另一个虚拟机时，接收者会获得一个可以访问在ServiceCenter与Warehouse接口中的所有远程方法的存根。可以使用instanceof操作符来查看一个特定的远程对象是否实现了某个接口。假设我们通过一个类型为Warehouse的变量得到了一个远程对象：
这个远程对象可能是一个ServiceCenter，但也可能不是。要确定到底是不是，可以使用下面的测试：
如果测试通过，就可以将location转型为ServiceCenter，并调用getReturn-Authorization方法。11.4.5　远程对象与equals、hashCode和clone方法
插入集（set）中的对象必须覆写equals方法。如果是散列集或散列映射表，则需定义hashCode方法。然而，比较远程对象时有一个问题。如果要比较两个远程对象是否具有相同的内容，调用equals则必须联系包含这些对象的服务器，然后比较它们的内容，而该调用可能会失败。但是，Object类中的equals方法并未声明会抛出RemoteException异常，而远程接口中的所有方法都必须抛出该异常。因为子类的方法不能比它覆写的父类的方法抛出更多的异常，所以不能在远程接口中定义equals方法。hashCode也是这样。
相反，存根对象的equals和hashCode方法只是查看远程对象的位置。只要它们指向相同的远程对象，equals方法就认为两个存根相同。指向不同远程对象的存根绝不可能相同，即使那两个对象有一样的内容。相似地，散列码只能通过对象的标识符来计算。
由于相同的技术上的原因，远程引用也没有clone方法。如果真的可以调用clone方法，让服务器克隆出一个远程对象，那么clone方法就有可能抛出RemoteException异常。然而，在根类Object中定义clone方法时，就已经保证绝不会抛出CloneNotSupported-Exception之外的任何异常。
总之，可以使用集与散列表中的远程引用，但是必须记住，对它们进行等价测试以及散列计算并不会考虑远程对象的内容。不能直接克隆远程引用。11.5　远程对象激活
在前面的例子中，我们使用了一个服务器程序来实例化和注册对象，以便客户端能够对它们进行远程调用。然而，在某些情况下，实例化大量的远程对象是一种浪费，因为无论客户端是否使用它们，它们都在一直等待连接。激活机制（activation）允许延迟构造远程对象，仅当至少有一个客户端调用远程对象上的远程方法时，才真正去构造该远程对象。
要享用激活机制的好处，客户端代码完全无需改动。客户端只是简单地请求一个远程引用，然后通过它进行调用而已。
然而，服务器程序则需由一个激活程序来代替。该程序构造了对象的激活描述符（activation descriptor），这样的对象可以延迟构造，并且该程序通过命名服务为远程方法调用绑定了接收者。第一次对这样的对象进行方法调用时，激活描述符中的信息将会用来构造该对象。
这样的远程对象必须继承Activatable类而不是UnicastRemoteObject类，当然，还需实现一个或多个远程接口。例如，
因为对象的构造是延迟进行的，所以它必须以标准方式实现。因此，构造器必须包含以下两个参数：
·一个激活ID（只需直接传递给父类的构造器）。
·一个包含所有构造信息的对象，包装为MarshalledObject。
如果需要多个构造参数，必须将它们打包为一个对象。通常可以使用一个Object[]数组或一个ArrayList来达到此目的。
在构建激活描述符时，需要像下面这样从构造信息中构造一个MarshalledObject：
在实现对象的构造器中，使用MarshalledObject类的get方法来获得反序列化之后的构造信息：
为了演示激活，我们修改了WarehouseImpl类，使得构造信息是一个由描述和价格构成的映射表。这个信息被封装到MarshalledObject中，并且在构造器中拆包出来：
将0作为父类构造器的第二个参数，代表RMI类库应该分配一个合适的端口号作为监听器端口。
构造器会打印一个消息，这样就可以看到仓库对象是按需激活的。
注意：其实远程对象不是一定要扩展Activatable类，例如，可以将下面的静态方法调用放在服务器类的构造器中：
现在，我们来看看激活程序。首先，需要定义一个激活组。一个激活组描述了启动远程对象所在的虚拟机所需的公共参数，其中最重要的参数是安全策略。
然后如下构造一个激活组描述符：
第二个参数描述了一个特殊的命令选项，在这个例子中不需要任何选项，所以我们传递了一个null引用。
接下来，创建一个组ID
现在就可以构造一个激活描述符了。对于应该按需构造的每一个对象，都应该包括：
·激活组ID，对象将在与其对应的虚拟机上被构造。
·类的名字（例如“WarehouseImpl”或“com.mycompany.MyClassImpl”）。
·URL字符串，类文件将从该URL处加载。这应该是基本URL，不含包的路径。
·编组后的构造信息。
例如，
将此描述符传递给静态的Activatable.register方法。它返回一个类的对象，该对象实现了实现类的远程接口。可以使用命名服务绑定该对象：
与前例的服务器程序不同，激活程序在注册与绑定激活接收者之后就会退出。仅当远程方法调用第一次发生时，才会构造远程对象。
程序清单11-10与11-11展示了激活程序和可激活的仓库实现。仓库接口与客户端程序不用改变。
要启动该程序，可按以下步骤进行：
1）编译所有源文件。
2）像下面这样发布类文件：
3）在rmi目录（它不包含任何类文件）中启动RMI注册表。
4）在rmi目录中启动RMI激活守护程序。
rmid程序监听激活请求，并且激活另一个虚拟机中的对象。要启动一个虚拟机，rmid程序需要一定的权限。这些权限都在一个策略文件中说明了（参见程序清单11-12）。使用-J，可以传递一个选项给运行激活守护程序的虚拟机。
5）在download目录中启动NanoHTTPD Web服务器。
6）从server目录运行激活程序。
在使用命名服务对激活接收者进行注册之后，该程序就会退出。（你可能想知道为什么需要指定代码基，因为在激活描述符的构造器中已经提供了代码基。然而，由于在激活描述符中的这个信息只是由RMI激活守护程序处理的，RMI注册表仍旧需要代码基去加载远程接口类。）
7）从client目录运行客户端程序。
该客户端程序会打印熟悉的产品描述。第一次运行客户端程序时，在激活守护程序所在的shell窗口中还可以看到构造器的消息。
程序清单11-10　activation/WarehouseActivator.java
程序清单11-11　activation/WarehouseImpl.java
程序清单11-12　activation/rmid.policy
java.rmi.activation.Activatable 1.2
·protected Activatable（ActivationID id，int port）
构造一个可激活对象，并在给定端口设立一个监听器。端口为0表示自动分配一个端口。
·static Remote exportObject（Remote obj，ActivationID id，int port）
使一个远程对象成为可激活的对象。该方法返回一个可供远程调用的发起者使用的激活接收者。端口为0代表一个自动分配的端口。
·static Remote register（ActivationDesc desc）
为一个可激活对象注册其描述符，做好接收远程调用的准备。该方法返回一个可供远程调用的发起者使用的激活接收者。
java.rmi.MarshalledObject 1.2
·MarshalledObject（Object obj）
构造一个对象，它包含给定对象序列化后的数据。
·Object get（）
将存储的对象数据反序列化，然后返回该对象。
java.rmi.activation.ActivationGroupDesc 1.2
·ActivationGroupDesc（Properties props，ActivationGroupDesc.CommandEnvironment env）
构造一个激活组的描述符，设置被激活对象所在虚拟机的一些属性。参数env包含启动虚拟机的路径和命令行选项，如果不需要特别设置，可以使用null。
java.rmi.activation.ActivationGroup 1.2
·static ActivationSystem getSystem（）
返回一个对激活系统的引用。
java.rmi.activation.ActivationSystem 1.2
·ActivationGroupID registerGroup（ActivationGroupDesc group）
注册一个激活组，并返回该组的ID。
java.rmi.activation.ActivationDesc 1.2
·ActivationDesc（ActivationGroupID id，String className，String classFileURL，MarshalledObject data）
构造一个激活描述符。
你已经看到了RMI机制，这是一种用于Java程序的分布式对象模型。在最后一章，我们将转向Java编程的另一个完全不同的方面：与同一台机器上用不同编程语言编写的“本地”代码进行交互。
