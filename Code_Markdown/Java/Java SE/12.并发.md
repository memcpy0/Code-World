▲ 什么是线程
▲ 线程状态
▲ 线程属性
▲ 同步
▲ 线程安全的集合
▲ 任务和线程池
▲ Callable 与 Future
▲ 阻塞队列
▲ 执行器
▲ 同步器
▲ 异步计算
▲ 线程与Swing
▲ 进程

可能已经很熟悉**多任务** `multitasking` ，这是操作系统的一种能力，**看起来可以在同一时刻运行多个程序**。例如，在编辑或下载邮件的同时可以打印文件。今天，人们都有单台拥有多个CPU的计算机，但**并发执行的进程数目并不受限于CPU数目**。操作系统会为每个进程分配CPU时间片，给人并行处理的感觉。

多线程程序在较低层次上扩展了多任务的概念：**单个程序看起来在同时执行多个任务**。每个任务在一个线程 `thread` 中执行，线程是控制线程 *thread of control* 的简称。如果一个程序可以同时运行多个线程，则称这个程序是**多线程的** `multithreaded` 。

那么，==多进程与多线程有哪些区别呢？本质的区别在于每个进程都拥有自己的一整套变量，而线程则共享数据==。这听起来似乎有些风险，的确也是这样，稍后将看到这个问题。然而，==共享变量使线程之间的通信比进程之间的通信更有效、更容易==。此外，在有些操作系统中，==与进程相比较，线程更“轻量级”，创建、 撤销一个线程比启动新进程的开销要小得多==。

在实际应用中，多线程非常有用。例如，一个浏览器可以同时下载几幅图片。一个Web服务器需要同时服务几个并发的请求。**图形用户界面程序用一个独立的线程从宿主操作环境中收集用户界面事件**。这里介绍如何为Java应用程序添加多线程能力。

温馨提示：多线程编程可能会变得相当复杂。**这里涵盖了应用程序员可能需要的所有工具**。尽管如此，对于更复杂的系统级程序设计，参看更高级的参考文献，例如：*Brian Goetz* 等编写的 *Java Concurrency in Practice (Addison-Wesley Professional, 2006)*（即Java并发编程实战）。

---
# 12.1 什么是线程
## 12.1.1 转账程序
看一个使用了两个线程的简单程序。这个程序可以在银行账户之间完成资金转账。我们使用了一个 `Bank` 类，它可以存储给定数目的账户的余额，`transfer` 方法将一定金额从一个账户转移到另一个账户，具体实现见程序12-2。在第一个线程中，我们将钱从账户0转移到账户1，第二个线程将钱从账户2转移到账户3。

下面是**在一个单独的线程中运行一个任务 *running a task* 的简单过程**。
1. 将执行这个任务的代码，放在一个类的 `run` 方法中，这个类要实现 `Runnable` 接口（非常简单，只有一个方法）：
	```java
	public interface Runnable {
		  void run();
	}
	```
   由于 `Runnable` 是一个**函数式接口**，因此可以用一个lambda表达式创建一个实例：
	```java
	Runnable r = () -> { task code };
	```
2. **从这个 `Runnable` 构造一个 `Thread` 对象**。
	```java
	var t = new Thread(r);
	```
3. 启动线程。注意：不要调用 `Thread` 类或 `Runnable` 对象的 `run` 方法，直接调用 `run` 方法只会在同一个线程中执行这个任务、而没有启动新的线程。实际上**应当调用 `Thread` 对象的 `start` 方法，这会创建一个执行 `run` 方法的新线程**。
	```java
	t.start();
	```

> 还可以**通过建立 `Thread` 类的一个子类来定义线程**。如下：
> ```java
> class MyThread extends Thread {
> 	public void run() {
> 		...
> 	}
> }
> ```
> **然后可以构造这个子类的一个对象，并调用它的 `start` 方法**。不过，现在**不再推荐这种方法**——<bold><font color="red">应当把「要并行运行的任务」与运行机制解耦合</font></bold> *decouple the task that is to be run in parallel from the mechanism of running it* 。
> 
> 如果有多个任务，为每个任务分别创建一个单独的线程开销会太大。实际上可以使用一个线程池（12.6.2节介绍）。

为了建立单独的线程来完成转账，只需要把转账代码放在一个 `Runnable` 的 `run` 方法中，然后启动一个线程即可。代码 `threads/ThreadTest.java` 对于给定的步骤数，这个线程会转账一个随机金额，然后休眠一个随机的延迟时间：
```java
// threads/ThreadTest.java
package threads;

public class ThreadTest {
	public static final int DELAY = 10;
	public static final int STEPS = 100;
	public static final double MAX_AMOUNT = 1000;

	public static void main(String[] args) {
		var bank = new Bank(4, 100000);
		Runnable task1 = () -> {
			try {
				for (int i = 0; i < STEPS; ++i) {
					double amount = MAX_AMOUNT * Math.random();
					bank.transfer(0, 1, amount);
					Thread.sleep((int) (DELAY * Math.random()));
				}
			} catch (InterruptedException e) {}
		};
		Runnable task2 = () -> {
			try {
				for (int i = 0; i < STEPS; ++i) {
					double amount = MAX_AMOUNT * Math.random();
					bank.transfer(2, 3, amount);
					Thread.sleep((int) (DELAY * Math.random()));
				} 
			} catch (InterruptedException e) {}
		};
		new Thread(task1).start();
		new Thread(task2).start();
	}
}

// threads/Bank.java
package threads;
import java.util.*;

/**
 * A bank with a number of bank accounts.
 */
public class Bank {
	private final double[] accounts;

	/**
	 * Constructs the bank.
	 * @param n the number of accounts
	 * @param initialBalance the initial balance for each account
	 */
	public Bank(int n, double initialBalance) {
		accounts = new double[n];
		Arrays.fill(accounts, initialBalance);
	}

	/**
	 * Transfers money from one account to another.
	 * @param from the account to transfer from
	 * @param to the account to transfer to
	 * @param amount the amount to transfer
	 */
	public void transfer(int from, int to, double amount) {
		if (accounts[from] < amount) return;
		System.out.print(Thread.currentThread());
		accounts[from] -= amount;
		System.out.printf(" %10.2f from %d to %d", amount, from, to);
		accounts[to] += amount;
		System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
	}

	/**
	 * Gets the sum of all account balances.
	 * @return the total balance
	 */
	public double getTotalBalance() {
		double sum = 0;
		for (double a : accounts) sum += a;
		return sum;
	}

	/**
	 * Gets the number of accounts in the bank.
	 * @return the number of accounts
	 */
	public int size() { return accounts.length; }
}
```
调用 `Thread.sleep` 不会创建一个新线程，**`sleep` 是 `Thread` 类的静态方法，用于暂停当前线程的活动**。我们还要捕获 `sleep` 方法有可能抛出的 `InterruptedException` 异常（12.3.1节）。**一般来说，中断用来请求终止一个线程，相应地出现 `InterruptedException` 时 `run` 方法会退出**。

程序还会启动第二个线程，它从账户2向账户3转账，运行这个程序时可以得到类似这样的输出：
```java
Thread[Thread-1,5,main] 606.77 from 2 to 3 Total Balance: 400000.00
Thread[Thread-0,5,main] 98.99 from 0 to 1 Total Balance: 400000.00
Thread[Thread-1,5,main] 476.78 from 2 to 3 Total Balance: 400000.00
Thread[Thread-0,5,main] 653.64 from 0 to 1 Total Balance: 400000.00
Thread[Thread-1,5,main] 807.14 from 2 to 3 Total Balance: 400000.00
Thread[Thread-0,5,main] 481.49 from 0 to 1 Total Balance: 400000.00
Thread[Thread-0,5,main] 203.73 from 0 to 1 Total Balance: 400000.00
Thread[Thread-1,5,main] 111.76 from 2 to 3 Total Balance: 400000.00
Thread[Thread-1,5,main] 794.88 from 2 to 3 Total Balance: 400000.00
```
可以看到这两个线程的输出是交错的，这说明它们在并发执行。实际上两个输出行交错显示时，输出有时会有些混乱。

==要了解的就是这些！现在已经知道了如何并发地运行任务==！余下的部分介绍**如何控制线程之间的交互**。
## 12.1.2 弹球程序
这里再看一个复杂的例子，从一个没有使用多线程的程序开始，用户很难让它执行多个任务。在对其进行剖析之后将发现，让这个程序运行几个彼此独立的多个线程是很容易的。这个程序采用不断移动位置的方式、实现球跳动的动画效果，如果发现球碰到墙壁，将进行重绘。

当点击Start按钮时，程序将从屏幕的左上角弹出一个球，这个球便开始弹跳。Start按钮的处理程序将调用 `addBall` 方法。这个方法循
环运行1000次 `move` 。每调用一次 `move` ，球就会移动一点，当碰到墙壁时，球将调整方向，并重新绘制面板。在发生异常时，我们简单地终止弹跳：
```java
Ball ball = new Ball();
comp.add(ball);

for (int i = 1; i <= STEPS; ++i) {
	ball.move(comp.getBounds());
	comp.paint(comp.getGraphics());
	Thread.sleep(DELAY);
}
```
如果运行这个程序，球就会自如地来回弹跳，但这个程序完全控制了整个应用程序。如果你在球完成1000次弹跳（应该是移动，每次移动一下）之前已经感到厌倦了，并点击Close按钮（或右上角的×）会发现球仍然还在弹跳。**在球自己结束弹跳之前无法与程序进行交互**（原因在于，点击Start按钮的事件触发 `addBall` 方法，主线程运行这一方法、使球弹跳，这时点击Close按钮，稍后才会被主线程运行）。

> 注释：如果仔细地阅读本节末尾的代码，会看到 `BounceFrame` 类的 `addBall` 方法中有调用 `comp.paint(comp.getGraphics())` 。
> 
> 这一点很奇怪。**一般来说，应该调用 `repaint` 方法让AWT获得图形上下文并负责绘制**。但是，如果试图在这个程序中调用 `comp.repaint()` ，在 `addBall` 方法返回以后才会重画画板。
> 
> 另外，还要注意 **`ball` 组件扩展于 `JPanel` ；这会让擦除背景变得非常容易**。接下来的程序将使用一个专门的线程计算球的位置，并会重新使用大家熟悉的 `repaint` 和 `JComponent` 。

显然，这个程序 `bounce/Bounce.java, bounce/Ball.java, bounce/BallComponent.java` 的性能相当糟糕。人们肯定不愿意让程序用这种方式完成一个非常耗时的工作。毕竟，当通过网络连接读取数据时，阻塞其他任务是经常发生的，有时确实想要中断读取操作。例如，假设下载一幅大图片。当看到一部分图片后，决定不需要或不想再看剩余的部分了，此时肯定希望能够点击Stop按钮或Back按钮中断下载操作。下一节介绍，如何通过**运行一个线程中的关键代码**来保持用户对程序的控制权。
```java
// bounce/Bounce.java
package bounce;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** 
 * Shows an animated bouncing ball.
 */
public class Bounce {
	public static void main(String[] args) {
		EventQueue.invokeLater(() -> {
			JFrame frame = new BounceFrame();
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}
}

/**
 * The frame with ball component and buttons.
 */
class BounceFrame extends JFrame {
	private BallComponent comp;
	public static final int STEPS = 1000;
	public static final int DELAY = 3;

	/**
	 * Constructs the frame with the component for showing the bouncing ball and
	 * Start and Close buttons.
	 */
	public BounceFrame() {
		setTitle("Bounce");
		comp = new BallComponent();
		add(comp, BorderLayout.CENTER);
		JPanel buttonPanel = new JPanel();
		addButton(buttonPanel, "Start", event -> addBall()); 
		addButton(buttonPanel, "Close", event -> System.exit(0));
		add(buttonPanel, BorderLayout.SOUTH);
		pack();
	}

	/**
	 * Adds a button to a container.
	 * @param c the container
	 * @param title the button title
	 * @param listener the action listener for the button
	 */
	public void addButton(Container c, String title, ActionListener listener) {
		JButton button = new JButton(title);
		c.add(button);
		button.addActionListener(listener);
	}

	/**
	 * Adds a bouncing ball to the panel and makes it bounce 1000 times.
	 */
	public void addBall() { // Start button
		try {
			Ball ball = new Ball();
			comp.add(ball);

			for (int i = 1; i <= STEPS; ++i) {
				ball.move(comp.getBounds());
				comp.paint(comp.getGraphics());
				Thread.sleep(DELAY);
			}
		} catch (InterruptedException e) {}
	}
}
							   
// bounce/Ball.java
package bounce;

import java.awt.geom.*;

/**
 * A ball that moves and bounces off the edges of a rectangle
 */
public class Ball {
	private static final int XSIZE = 15;
	private static final int YSIZE = 15;
	private double x = 0;
	private double y = 0;
	private double dx = 1;
	private double dy = 1;

	/**
	 * Moves the ball to the next position, reversing direction if it hits one of the edges.
	 */
	public void move(Rectangle2D bounds) {
		x += dx;
		y += dy;
		if (x < bounds.getMinX()) {
			x = bounds.getMinX();
			dx = -dx;
		}
		if (x + XSIZE >= bounds.getMaxX()) {
			x = bounds.getMaxX() - XSIZE;
			dx = -dx;
		}
		if (y < bounds.getMinY()) {
			y = bounds.getMinY();
			dy = -dy;
		}
		if (y + YSIZE >= bounds.getMaxY()) {
			y = bounds.getMaxY() - YSIZE;
			dy = -dy;
		}
	}

	/**
	 * Gets the shape of the ball at its current position.
	 */
	public Ellipse2D getShape() {
		return new Ellipse2D.Double(x, y, XSIZE, YSIZE);
	}
}
							   
// bounce/BallComponent.java
package bounce;

import java.awt.*;
import java.util.*;
import javax.swing.*;

/**
 * The component that draws the balls.
 */
public class BallComponent extends JPanel {
	private static final int DEFAULT_WIDTH = 450;
	private static final int DEFAULT_HEIGHT = 350;
	private java.util.List<Ball> balls = new ArrayList<>();

	/**
	 * Add a ball to the component.
	 * @param b the ball to add
	 */
	public void add(Ball b) {
		balls.add(b);
	}

	public void paintComponent(Graphics g)  {
		super.paintComponent(g); // erase background
		Graphics2D g2 = (Graphics2D) g;
		for (Ball b : balls) {
			g2.fill(b.getShape());
		}
	}

	public Dimension getPreferredSize() {
		return new Dimension(DEFAULT_WIDTH, DEFAULT_HEIGHT);
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211021848606.png)

## 12.1.3 使用线程给其他任务提供机会
可以将移动球的代码放置在一个独立的线程中，运行这段代码可以**提高弹跳球的响应能力**。实际上，可以发起多个球，每个球都在自己的线程中运行。另外，**AWT的事件分派线程 `event dispatch thread` 将一直地并行运行，以处理用户界面的事件**。由于每个线程都有机会得以运行，所以在球弹跳期间，当用户点击Close按钮时，事件调度线程将有机会关注到这个事件，并处理“关闭”这一动作。

这里用球弹跳代码作为示例，让大家对并发处理有一个视觉印象。人们总会提防长时间的计算。这个计算很可能是某个大框架的一个组成部分，例如GUI或web框架。无论何时框架调用自身的方法都会很快地返回一个异常。如果需要执行一个比较耗时的任务，应当并发地运行任务。

要想将弹跳球代码放在一个独立的线程中，只需要实现一个类`BallRunnable` ，然后将动画代码放在 `run` 方法中，如同下面这段代码。现在无论何时点击 `Start` 按钮，球都会移入一个新线程：
```java
Runnable r = () -> {
	try {
		for (int i = 1; i <= STEPS; ++i) {
			ball.move(comp.getBounds());
			comp.repaint();
			Thread.sleep(DELAY);
		} 
	} catch (InterruptedException e) {}
}
Thread t = new Thread(r);
t.start();
```
同样地，需要捕获 `sleep` 方法可能抛出的异常 `InterruptedException` 。下一节将讨论这个异常。**在一般情况下，线程在中断（即终止请求）时被终止**。因此，当发生 `InterruptedException` 异常时，`run` 方法将结束执行。
```java
// bounceThread/BounceThread.java
package bounceThread;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;

/**
 * Shows animated bouncing balls.
 */
public class BounceThread {
	public static void main(String[] args) {
		EventQueue.invokeLater(() -> {
			JFrame frame = new BounceFrame();
			frame.setTitle("BounceThread");
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}
}

/**
 * The frame with panel and buttons.
 */
class BounceFrame extends JFrame {
	private BallComponent comp;
	public static final int STEPS = 1000;
	public static final int DELAY = 3;

	/**
	 * Constructs the frame with the component for showing the bouncing ball and
	 * Start and Close buttons.
	 */
	public BounceFrame() {
		comp = new BallComponent();
		add(comp, BorderLayout.CENTER);
		JPanel buttonPanel = new JPanel();
		addButton(buttonPanel, "Start", event -> addBall()); 
		addButton(buttonPanel, "Close", event -> System.exit(0));
		add(buttonPanel, BorderLayout.SOUTH);
		pack();
	}

	/**
	 * Adds a button to a container.
	 * @param c the container
	 * @param title the button title
	 * @param listener the action listener for the button
	 */
	public void addButton(Container c, String title, ActionListener listener) {
		JButton button = new JButton(title);
		c.add(button);
		button.addActionListener(listener);
	}

	/**
	 * Adds a bouncing ball to the canvas and starts a thread to make it bounce 1000 times.
	 */
	public void addBall() { // Start button
		Ball ball = new Ball();
		comp.add(ball);
		Runnable r = () -> {	
			try {
				for (int i = 1; i <= STEPS; ++i) {
					ball.move(comp.getBounds());
					comp.repaint();
					Thread.sleep(DELAY);
				}
			} catch (InterruptedException e) {}
		};
		Thread t = new Thread(r);
		t.start();
	}
}

// bounceThread/Ball.java
package bounceThread;
import java.awt.geom.*;

/**
 * A ball that moves and bounces off the edges of a rectangle
 */
public class Ball {
	private static final int XSIZE = 15;
	private static final int YSIZE = 15;
	private double x = 0;
	private double y = 0;
	private double dx = 1;
	private double dy = 1;

	/**
	 * Moves the ball to the next position, reversing direction if it hits one of the edges.
	 */
	public void move(Rectangle2D bounds) {
		x += dx;
		y += dy;
		if (x < bounds.getMinX()) {
			x = bounds.getMinX();
			dx = -dx;
		}
		if (x + XSIZE >= bounds.getMaxX()) {
			x = bounds.getMaxX() - XSIZE;
			dx = -dx;
		}
		if (y < bounds.getMinY()) {
			y = bounds.getMinY();
			dy = -dy;
		}
		if (y + YSIZE >= bounds.getMaxY()) {
			y = bounds.getMaxY() - YSIZE;
			dy = -dy;
		}
	}

	/**
	 * Gets the shape of the ball at its current position.
	 */
	public Ellipse2D getShape() {
		return new Ellipse2D.Double(x, y, XSIZE, YSIZE);
	}
}

// bounceThread/BallComponent.java
package bounceThread;

import java.awt.*;
import java.util.*;
import javax.swing.*;

/**
 * The component that draws the balls.
 */
public class BallComponent extends JPanel {
	private static final int DEFAULT_WIDTH = 450;
	private static final int DEFAULT_HEIGHT = 350;
	private java.util.List<Ball> balls = new ArrayList<>();

	/**
	 * Add a ball to the component.
	 * @param b the ball to add
	 */
	public void add(Ball b) {
		balls.add(b);
	}

	public void paintComponent(Graphics g)  {
		super.paintComponent(g); // erase background
		Graphics2D g2 = (Graphics2D) g;
		for (Ball b : balls) {
			g2.fill(b.getShape());
		}
	}

	public Dimension getPreferredSize() {
		return new Dimension(DEFAULT_WIDTH, DEFAULT_HEIGHT);
	}
}
```
运行结果如下所示，点击Start按钮添加一个球后还能再点、或者直接Close（之前都做不到）：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211022257028.png)

> [API] `java.lang.Thread` 1.0
> - `Thread(Runnable target)`
> 构造一个新线程，用于调用给定目标的 `run()` 方法。
> - `void start()`
> 启动这个线程，将调用 `run()` 方法。`start` 方法将立即返回，并且新线程将并发运行。
> - `void run()`
> 调用关联 `Runnable` 的 `run` 方法。

> [API] `java.lang.Runnable` 1.0
> - `void run()`
> 必须覆盖这个方法，并在这个方法中提供所要执行的任务指令。

---
# 12.2 线程状态
线程可以有如下6种状态（新建，就绪，运行，阻塞，挂起，终止）：
- New（新建）
- Runnable（可运行）
- Blocked（阻塞）
- Waiting（等待）
- Timed waiting（计时等待）
- Terminated（终止）

下一节解释每一种状态。**要确定一个线程的当前状态，只需调用 `getState` 方法**。
## 12.2.1 新建线程
**当用 `new` 操作符创建一个新线程时，如 `new Thread(r)` ，该线程还没有开始运行。这意味着它的状态是新建 `new`** 。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。
## 12.3.2 可运行线程
**一旦调用 `start` 方法，线程处于可运行 `runnable` 状态**。在任何时刻，**一个可运行的线程可能正在运行、也可能没有运行**（这就是为什么将这个状态称为可运行而不是运行），这取决于操作系统给线程提供时间来运行 *It is up to the operating system to give the thread time to run*（不过，==Java的规范没有将正式运行作为一个单独的状态。一个正在运行中的线程仍然处于可运行状态==）。

**一旦一个线程开始运行，它不一定始终保持运行**。事实上，运行中的线程有时需要暂停，目的是让其他线程有机会运行。**线程调度的细节依赖于操作系统提供的服务**。**抢占式调度系统** *preemptive scheduling systems* 给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺 *preempts* 该线程的运行权，并给另一个线程运行机会（见图12-2）。当选择下一个线程时，操作系统考虑线程的优先级（见第12.3.5节）。

现在所有的桌面以及服务器操作系统都使用抢占式调度。但像手机这样的小型设备可能使用**协作式调度** *cooperative scheduling* 。在这样的设备中，**一个线程只有在调用 `yield` 方法、或者被阻塞或等待时，线程才失去控制权**。

在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目，调度器依然采用时间片机制。
> [API] `java.lang.Thread` 1.0
> - `static void yield()`
> 使当前正在执行的线程向另一个线程交出运行权。注意这是一个静态方法。
## 12.2.3 阻塞和等待线程
==当线程处于阻塞或等待状态时，它暂时是不活动的。它不运行任何代码、且消耗最少的资源。直到线程调度器重新激活这个线程==。具体细节取决于它是怎样达到非活动状态的。
- **当一个线程试图获取一个内部的对象锁** *intrinsic object lock*（而不是 `java.util.concurrent` 库中的锁），**而该锁被其他线程持有，则该线程进入阻塞状态**（在12.4.3节讨论 `java.util.concurrent` 锁，在12.4.5节讨论内部对象锁）。当所有其他线程都释放了该锁，并且线程调度器允许该线程持有这个锁的时候，它将变成非阻塞状态。
- **当线程等待另一个线程通知调度器出现一个条件 *notify the scheduler of a condition* 时，它自己进入等待状态**（在12.4.4节讨论条件）。在调用 `Object.wait` 方法或 `Thread.join` 方法，或等待 `java.util.concurrent` 库中的 `Lock` 或 `Condition` 时，就会出现这种情况。实际上，**阻塞状态与等待状态并没有很大不同** *the difference between the blocked and waiting state is not significant* 。
- **有几个方法有一个超时参数。调用这些方法会让线程进入计时等待状态**。这一状态将一直保持到超时期满 *the timeout expires* 、或接收到适当的通知。带有超时参数的方法有 `Thread.sleep` 和 `Object.wait, Thread.join, Lock.tryLock` 以及 `Condition.await` 。

图12-1展示了线程可以具有的状态、以及从一个状态到另一个状态可能的转换。当一个线程阻塞或等待时（或终止时），可以调度另一个线程为运行状态。==当一个线程被重新激活（例如，因为超时期满或成功地获得了一个锁），调度器检查它是否具有比当前运行线程更高的优先级。如果是这样，调度器会剥夺某个当前运行线程的运行权，选择一个新线程运行==。
![图12-1 线程状态](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211020810741.png)
## 12.2.4 终止的线程
线程因如下两个原因之一而被终止：
- 因为 `run` 方法正常退出，线程自然终止。
- 因为一个没有捕获的异常终止了 `run` 方法，使线程意外死亡。

特别是，可以调用线程的 `stop` 方法杀死一个线程。该方法抛出一个 `ThreadDeath` 错误对象，这会杀死线程。但是，`stop` 方法已废弃，不要在自己的代码中调用这个方法。
> [API] `java.iang.Thread` 1.0
> - `void join()`
> 等待终止指定的线程。
> - `void join(long millis)`
> 等待指定的线程终止、或者等待经过指定的毫秒数。
> - `Thread.State getState()` 5.0
> 得到这一线程的状态；取值为：`NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING` 或 `TERMINATED` 之一。
> - `void stop()`
> 终止该线程。这一方法已废弃。
> - `void suspend()`
> 暂停这一线程的执行。这一方法已废弃。
> - `void resume()`
> 恢复线程。这一方法只能在调用 `suspend()` 之后调用。这一方法已废弃。

## 12.3 线程属性
下面将讨论线程的各种属性，其中包括：线程优先级、中断的状态、守护线程、未捕获异常的处理器、不应使用的一些遗留特性。
## 12.3.1 中断线程
一个线程将终止——当线程的 `run` 方法执行方法体中最后一条语句后、再执行 `return` 语句返回时，或者出现了方法中没有捕获的异常时。在Java的早期版本中，还有一个 `stop` 方法，其他线程可以调用这个方法来终止一个线程。但这个方法现在已经被弃用了（12.4.13节讨论它被弃用的缘由）。

**除了已经废弃的 `stop` 方法，没有办法可以强制线程终止**。然而，`interrupt` 方法可以用来**请求**终止一个线程。当对一个线程调用 `interrupt` 方法时，就会设置线程的中断状态 *interrupted status* 。这是每个线程都具有的 `boolean` 标志。**每个线程都应不时地检査这个标志，以判断线程是否被中断**。

要想弄清中断状态是否被设置，首先调用静态的 `Thread.currentThread` 方法获得当前线程，然后调用 `isInterrupted` 方法：
```java
while (!Thread.currentThread().isInterrupted() && more work to do {
	do more work
}
```
**但如果线程被阻塞，就无法检测中断状态**。这里就要引入 `InterruptedException` 异常。**当在一个被 `sleep` 或 `wait` 调用阻塞的线程上调用 `interrupt` 方法时，那个阻塞调用**（即 `sleep` 或 `wait` 调用）**将会被一个 `InterruptedException` 异常中断**（存在不能被中断的阻塞I/O调用 *blocking I/O calls* ，应该考虑选择可中断的调用 *interruptible alternatives* 。有关细节参看卷II的第2、4章）。

没有任何语言方面的要求、一个被中断的线程应当终止。==中断一个线程只是要引起它的注意 *Interrupting a thread simply grabs its attention* 。**被中断的线程可以决定如何响应中断**==。某些线程是如此重要，以至于应该处理完异常后继续执行、而不理会中断。但更普遍的情况是，线程简单地将中断解释为一个终止请求。这种线程的 `run` 方法具有如下形式：
```java
Runnable r = () -> {
	try {
		...
		while (!Thread.currentThread().isInterrupted() && more work to do) {
			// do more work
		}
	} catch (InterruptedException e) {
		// thread was interrupted during sleep or wait
	} finally {
		// cleanup, if required. or try-with-resources
	} 
	// exiting the run method terminates the thread
}
```
如果在每次工作迭代之后都调用 `sleep` 方法（或者其他的可中断方法 *interruptible method* ），`isInterrupted` 检测既没有必要也没有用处。**如果在中断状态被置位时调用 `sleep` 方法，它不会休眠，相反它将清除这一状态（！）并拋出 `InterruptedException`** 。因此，如果你的循环调用了 `sleep` ，**不要检测中断状态**。相反，要如下所示捕获 `InterruptedException` 异常： 
```java
Runnable r = () -> {
	try {
		...
		while (more work to do) {
			// do more work
			Thread.sleep(delay);
		}
	} catch (InterruptedException e) {
		// thread was interrupted during sleep
	} finally {
		// cleanup, if required
	}
	// exiting the run method terminates the thread
}
```
> 注释：有两个非常类似的方法，`interrupted` 和 `isInterrupted` 。**`interrupted` 方法是一个静态方法，它检测当前线程是否被中断**。而且，调用 `interrupted` 方法会**清除该线程的中断状态**。另一方面，**`isInterrupted` 方法是一个实例方法，用来检验是否有线程被中断。调用这个方法不会改变中断状态**。

在很多发布的代码中，会发现 `InterruptedException` 异常被抑制在很低的层次上，像这样：
```java
void mySubTask() {
	...
	try { sleep(delay); }
	catch (InterruptedException e) {} // don't ignore!
}
```
不要这样做！如果想不出在 `catch` 子句中可以做什么有意义的工作，仍然有两种合理的选择：
- 在 `catch` 子句中调用 `Thread.currentThread().interrupt()` 来设置中断状态。这样一来调用者可以检测中断状态。
	```java
	void mySubTask() {
		...
		try { sleep(delay); }
		catch (InterruptedException e) { Thread.currentThread().interrupted(); }
	}
	```
- 或者，更好的选择是，用 `throws InterruptedException` 标记你的方法，不采用 `try` 语句块捕获异常。这样一来调用者（或者最终的 `run` 方法）可以捕获这一异常。
	```java
	void mySubTask() throws InterruptedException {
		...
		sleep(delay);
		...
	}
	```

> [API] `java.lang.Thread` 1.0
> - `void interrupt()`
> 向线程发送中断请求。线程的中断状态将被设置为 `true` 。如果目前该线程被一个 `sleep` 调用阻塞，那么，`InterruptedException` 异常被抛出。
> - `static boolean interrupted()`
> 测试当前线程（即正在执行这一命令的线程）是否被中断。注意，这是一个静态方法。这一调用有一个副作用——它将当前线程的中断状态重置为 `false` 。
> - `boolean isInterrupted()`
> 测试线程是否设置中断状态。不像静态的中断方法，这一调用不改变线程的中断状态。
> - `static Thread currentThread()`
> 返回表示当前正在执行的线程的 `Thread` 对象。

## 12.3.2 守护线程
可以通过调用
```java
t.setDaemon(true);
```
将线程转换为守护线程 `daemon thread` 。这样一个线程没有什么魔力。**守护线程的唯一用途是为其他线程提供服务**。计时线程就是一个例子，它定时地发送“计时器嘀嗒”信号给其他线程，另外清空过时的高速缓存项的线程也是守护线程。**当只剩下守护线程时，虚拟机就会退出，因为如果只剩下守护线程，就没必要继续运行程序了**。

守护线程有时会被初学者错误地使用，他们不打算考虑关机 `shutdown` 动作。但这是很危险的。**守护线程应该永远不去访问固有资源**，如文件、 数据库，因为它会在任何时候甚至在一个操作的中间发生中断。
> [API] `java.lang.Thread` 1.0
> - `void setDaemon(boolean isDaemon)`
> 标识该线程为守护线程或用户线程。这一方法必须在线程启动之前调用。

## 12.3.3 线程名
默认情况下，线程有容易记住的名字，如 `Thread-2` 。可以用 `setName` 方法为线程设置任何名字：
```java
var t = new Thread(runnable);
t.setName("Web crawler");
```
这在线程转储 *thread dumps* 时可能很有用。
# 12.3.4 未捕获异常的处理器
**线程的 `run` 方法不能抛出任何检查型异常**，但非检查型异常可能导致线程终止。在这种情况下，线程就死亡了。

不过，对于可以传播的异常，并没有任何 `catch` 子句。实际上，在线程死亡之前，异常会被传递到一个用于**处理未捕获异常的处理器** *handler for uncaught exceptions* 。该处理器必须属于一个实现 `Thread.UncaughtExceptionHandler` 接口的类。这个接口只有一个方法。
```java
void uncaughtException(Thread t, Throwable e)
```
可以用 `setUncaughtExceptionHandler` 方法为任何线程安装一个处理器。也可以用 `Thread` 类的静态方法 `setDefaultUncaughtExceptionHandler` 为所有线程安装一个默认的处理器。一个替换处理器 *a replacement handler* 可以使用日志API发送未捕获异常的报告到日志文件。

如果不安装默认的处理器，默认处理器为 `null` 。但**如果你没有为一个独立的线程 *individual thread* 安装一个处理器，此时的处理器就是该线程的 `ThreadGroup` 对象**。
> 注 释：线程组 `thread group` 是一个可以统一管理的线程集合。==默认情况下，创建的所有线程属于相同的线程组，但是也可以建立其他的组==。现在引入了更好的特性来处理线程集合，所以**建议不要在自己的程序中使用线程组**。

`ThreadGroup` 类实现了 `Thread.UncaughtExceptionHandler` 接口。它的 `uncaughtException` 方法做如下操作：
1. 如果该线程组有父线程组，那么调用父线程组的 `uncaughtException` 方法。
2. 否则，如果 `Thread.getDefaultExceptionHandler` 方法返回一个非空的处理器，则调用该处理器。
3. 否则，如果 `Throwable` 是 `ThreadDeath` 的一个实例，什么都不做。
4. 否则，线程的名字以及 `Throwable` 的栈轨迹被输出到 `System.err` 上。

在程序中肯定看到过许多次这样的栈轨迹。

> [API] `java.lang.Thread` 1.0
> - `static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)` 5.0
> - `static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()` 5.0
> 设置或获取未捕获异常的默认处理器。
> - `void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)` 5.0
> - `Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()` 5.0
> 设置或获取未捕获异常的处理器。如果没有安装处理器，则将线程组对象作为处理器。

> [API] `java.lang.Thread.UncaughtExceptionHandler` 5.0
> - `void UncaughtException(Thread t, Throwable e)`
> 当一个线程因未捕获异常而终止时，按规定要将一个定制报告记录到日志中。

> [API] `java.lang.ThreadGroup` 1.0
> - `void UncaughtException(Thread t, Throwable e)`
> 如果有父线程组，调用父线程组的这一方法；或者，如果 `Thread` 类有默认处理器，就调用该处理器。否则，输出栈轨迹到标准错误流上（不过，如果 `e` 是一个 `ThreadDeath` 对象，则会抑制栈轨迹。`ThreadDeath` 对象由已经废弃的 `stop` 方法产生）。


## 12.3.5 线程优先级
在Java中，每一个线程有一个优先级。**默认情况下，一个线程会继承构造它的父线程的优先级**。可以用 `setPriority` 方法提高或降低任何一个线程的优先级。可以将优先级设置为在 `MIN_PRIORITY`（在 `Thread` 类中定义为1）与 `MAX_PRIORITY`（定义为10）之间的任何值。`NORM_PRIORITY` 被定义为5。

每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。**但线程优先级高度依赖于系统**。当虚拟机依赖于宿主机平台的线程实现机制时，Java线程的优先级会被映射到宿主机平台的优先级上，平台的线程优先级个数也许更多，也许更少。

例如，Windows有7个优先级别。Java的一些优先级会映射到同一个操作系统优先级。在Oracle为Linux提供的Java虚拟机中，会完全忽略线程的优先级——所有线程都有相同的优先级。

在没有使用操作系统线程的Java早期版本中，线程优先级可能很有用。不过**现在不要使用线程优先级了**。
> 警告：如果确实要使用优先级，应该避免初学者常犯的一个错误。如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，尽管这样会使低优先级的线程完全饿死。

> [API] `java.lang.Thread` 
> - `void setPriority(int newPriority)`
> 设置线程的优先级。优先级必须在 `Thread.MIN_PRIORITY` 与 `Thread.MAX_PRIORITY` 之间。一般使用 `Thread.NORM_PRIORITY` 优先级。
> - `static int MIN_PRIORITY`
> 线程的最小优先级。最小优先级的值为1。
> - `static int NORM_PRIORITY`
> 线程的默认优先级。默认优先级为5。
> - `static int MAX_PRIORITY`
> 线程的最高优先级。最高优先级的值为10。
> - `static void yield()`
> 导致当前执行线程处于让步状态。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。注意，这是一个静态方法。

---
# 14.5 同步
在大多数实际的多线程应用中，两个或两个以上的线程需要**共享对同一数据的存取**。如果两个线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？ 可以想象，这两个线程会彼此覆盖。根据各线程访问数据的次序，可能会导致对象被破坏。这种情况通常称为**竞争条件** `race condition` 。

## 14.5.1 竞争条件的一个例子
为了避免多线程破坏共享数据，必须学习如何**同步存取**。在本节中，你会看到如果没有使用同步会发生什么。在下一节中，将会看到如何同步数据存取。

在下面的测试程序中，模拟一个有若干账户的银行。随机地选择从哪个源账户转移到哪个目标账户。每一个账户有一个线程。由于这会产生问题，所以下面再来仔细查看 `Bank` 类 `transfer` 方法的代码。
```java
public void transfer(int from, int to, double amount) { // CAUTION: unsafe when called from multiple threads
	System.out.print(Thread.currentThread());
	accounts[from] -= amount;
	System.out.printf(" %10.2f from %d to %d", amount, from, to);
	accounts[to] += amount;
	System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
}
```
下面是 `Runnable` 类的代码。它的 `run` 方法不断地从一个给定银行账户取出钱款。在每次迭代中，`run` 方法随机选择一个目标账户和一个随机金额，调用 `bank` 对象的 `transfer` 方法，然后休眠。
```java
Runnable r = () -> {
	try {
		while (true) {
			int toAccount = (int) (bank.size() * Math.random());
			double amount = MAX_AMOUNT * Math.random();
			bank.transfer(fromAccount, toAccount, amount);
			Thread.sleep((int) (DELAY * Math.random()));
		}
	} catch (InterruptedException e) {}
};
```
这个模拟程序运行时，不清楚在某一时刻某银行账户中有多少钱。但是，知道所有账户的总金额应保持不变，因为所做的一切不过是从一个账户转移钱款到另一个账户。在每一次交易结束时，`transfer` 方法重新计算总金额并打印出来。且本程序永远不会结束。只能按CTRL+C来终止这个程序。下面是典型的输出:
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211031008210.png)
如前所示，出现了错误。在最初的交易中，银行的余额保持在$100000，这是正确的，因为共100个账户，每个账户$1000。但是，过一段时间，余额总量有轻微的变化。运行这个程序时，可能很快就能发现出错了，有时可能需要很长的时间才能发现余额不对。这样的状态不会带来信任感，人们可能不愿意将辛苦挣来的钱存到这个银行。

完整的源代码见 `threads/Bank.java, unsynch/UnsynchBankTest.java` 。看看是否能从代码中找出问题：
```java
// threads/Bank.java
package threads;
import java.util.*;

/**
 * A bank with a number of bank accounts.
 */
public class Bank {
	private final double[] accounts;

	/**
	 * Constructs the bank.
	 * @param n the number of accounts
	 * @param initialBalance the initial balance for each account
	 */
	public Bank(int n, double initialBalance) {
		accounts = new double[n];
		Arrays.fill(accounts, initialBalance);
	}

	/**
	 * Transfers money from one account to another.
	 * @param from the account to transfer from
	 * @param to the account to transfer to
	 * @param amount the amount to transfer
	 */
	public void transfer(int from, int to, double amount) {
		if (accounts[from] < amount) return;
		System.out.print(Thread.currentThread());
		accounts[from] -= amount;
		System.out.printf(" %10.2f from %d to %d", amount, from, to);
		accounts[to] += amount;
		System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
	}

	/**
	 * Gets the sum of all account balances.
	 * @return the total balance
	 */
	public double getTotalBalance() {
		double sum = 0;
		for (double a : accounts) sum += a;
		return sum;
	}

	/**
	 * Gets the number of accounts in the bank.
	 * @return the number of accounts
	 */
	public int size() { return accounts.length; }
}
```
```java
// unsynch/UnsynchBankTest.java
package unsynch;

import threads.Bank;

/**
 * This program shows data corruption when multiple threads access a data structure.
 */
public class UnsynchBankTest {
	public static final int NACCOUNTS = 100;
	public static final double INITIAL_BALANCE = 1000;
	public static final double MAX_AMOUNT = 1000;
	public static final int DELAY = 10;

	public static void main(String[] args) {
		var bank = new Bank(NACCOUNTS, INITIAL_BALANCE);
		for (int i = 0; i < NACCOUNTS; ++i) {
			int fromAccount = i;
			Runnable r = () -> {
				try {
					while (true) {
						int toAccount = (int) (bank.size() * Math.random());
						double amount = MAX_AMOUNT * Math.random();
						bank.transfer(fromAccount, toAccount, amount);
						Thread.sleep((int) (DELAY * Math.random()));
					}
				} catch (InterruptedException e) {}
			};
			var t = new Thread(r);
			t.start();
		}
	}
}
```

## 14.5.2 竞争条件详解
上一节中运行了一个程序，其中有几个线程更新银行账户余额。一段时间之后，错误不知不觉地出现了，可能有些钱会丢失、可能几个账户同时有钱进账。当两个线程试图同时更新同一个账户时，就会出现这个问题。假定两个线程同时执行指令 `accounts[to] += amount;` ，**问题在于这不是原子操作**。该指令可能被处理如下：
1. 将 `accounts[to]` 加载到寄存器。
2. 增加 `amount` 。
3. 将结果写回 `accounts[to]` 。

现在，假定第1个线程执行步骤1和2，然后它被剥夺了运行权。假定第2个线程被唤醒并修改了 `accounts` 数组中的同一个元素。然后，第1个线程被唤醒、并完成其第3步。这一动作擦去了第2个线程所做的更新（**丢失修改**）。于是，总金额不再正确（见图 12-2）。
![图12-2 同时被两个线程访问](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211031600037.png)
我们的测试程序检测到这种错误（当然，如果线程在运行这一测试时被中断，也有轻微的可能会出现假警告 *there is a slight chance
of false alarms* ）。
> 注释：可以具体查看执行这个类中每个语句的虚拟机字节码。运行命令：
> ```bash
> $ javap -c -v Bank
> ```
> 对 `Bank.class` 文件进行反编译。例如，代码行 `accounts[to] += amount;` 被转换为下面的字节码：
> ```java
> aload_0
> getfield #2; //Field accounts:[D
> iload_2
> dup2
> daload
> dload_3
> dadd
> dastore
> ```
> 这些代码的含义无关紧要。重要的是这个增加命令是由多条指令组成的，执行这些指令的线程可以在任何一条指令上被中断。

出现这种破坏的可能性有多大呢？在一个有多个内核的现代处理器上，出问题的风险相当高。我们将打印语句和更新余额的语句交替执行，提高观察到这种问题的概率。

如果删除打印语句，出问题的风险会降低，因为每个线程在再次睡眠之前所做的工作很少，调度器不大可能在线程的计算过程中剥夺它的运行权。但是，产生破坏的风险并没有完全消失。如果在负载很重的机器上运行许多线程，那即使删除了打印语句，程序依然会出错。这种错误可能会几分钟、几小时或几天出现一次。坦白地说，对程序员而言，很少有比无规律出现错误更糟的事情了 *an error that only manifests itself irregularly* 。

真正的问题是，`transfer` 方法可能会在执行到中间时被中断。如果能确保线程失去控制之前方法运行完成，那么银行账户对象的状态就不会出现讹误。
 
## 12.4.3 锁对象
有两种机制可**防止代码块受并发访问的干扰**。Java提供一个 `synchronized` 关键字达到这一目的，并且Java 5.0引入了 `ReentrantLock` 类。**`synchronized` 关键字会自动提供一个锁以及相关的“条件”**，对于大多数需要显式锁的情况，这种机制功能很强大、也很便利。不过，我们相信在分別了解锁和条件的内容之后，理解 `synchronized` 关键字是很轻松的事情。**`java.util.concurrent` 框架为这些基础机制提供了单独的类**，在此以及12.4.4节解释。一旦理解了这些基础，在12.4.5节介绍 `synchronized` 关键字。

用 `ReentrantLock` 保护代码块的基本结构如下：
```java
myLock.lock(); // a ReentrantLock object
try {
	// critical section
} finally {
	myLock.unlock(); // make sure the lock is unlocked even if an exception is thrown
}

```
==这一结构确保任何时刻只有一个线程进入临界区。一旦一个线程锁定了锁对象，其他任何线程都无法通过 `lock` 语句==。当其他线程调用 `lock` 时，它们被阻塞，直到第一个线程释放锁对象。
> 警告：**要把 `unlock` 操作包含在 `finally` 子句中**，这点至关重要。如果在临界区的代码抛出一个异常，锁必须被释放。否则，其他线程将永远阻塞。

> 注释：**使用锁时，就不能使用 `try-with-resources` 语句**。首先，解锁方法名不是 `close` 。不过，即使将它重命名，`try-with-resources` 语句也无法正常工作。它的首部希望声明一个新变量，但当你使用一个锁时，可能想继续使用线程间共享的相同变量 *the same variable that is shared among threads*（而不是新变量）。

下面使用一个锁来保护 `Bank` 类的 `transfer` 方法。
```java 
public class Bank {
	private var bankLock = new ReentrantLock();
	...
	public void transfer(int from, int to, int amount) {
		bankLock.lock();
		try {
			System.out.print(Thread.currentThread());
			accounts[from] -= amount;
			System.out.printf(" %10.2f from %d to %d", amount, from, to);
			accounts[to] += amount;
			System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
		} finally {
			bankLock.unlock();
		}
	}
} 
```
假定一个线程调用了 `transfer` ，在执行结束前被剥夺了运行权。假定第二个线程也调用 `transfer` ，由于第二个线程不能获得锁，将在调用 `lock` 方法时被阻塞。它必须等待第一个线程执行完 `transfer` 方法，才能再度被激活。当第一个线程释放锁时，第二个线程才能开始运行（见图12-3）。
![图14-5 非同步线程与同步线程的比较](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211032353480.png)

尝试一下。把加锁代码添加到 `transfer` 方法并且再次运行程序。这个程序可以一直运行下去，银行余额绝对不会有错误。注意，每一个 `Bank` 对象都有自己的 `ReentrantLock` 对象。如果两个线程试图访问同一个
`Bank` 对象，那么锁可以用来保证串行化访问。不过，如果两个线程访问不同的 `Bank` 对象，每个线程会得到不同的锁对象，两个线程都不会阻塞。本该如此，因为线程在操纵不同的 `Bank` 实例的时候，线程之间不会相互影响。

这个锁称为**可重入 *reentrant* 锁** ，因为线程可以反复获得已持有的锁 *a thread can repeatedly acquire a lock that it already owns* 。锁有一个**持有计数** `hold count` 来跟踪对 `lock` 方法的嵌套调用。线程在每一次调用 `lock` 后为了解除锁定 *relinquish the lock* 都要调用 `unlock` 来释放锁。由于这一特性，**被一个锁保护的代码可以调用另一个使用相同锁的方法**。

例如，`transfer` 方法调用 `getTotalBalance` 方法，这也会封锁 `bankLock` 对象 *locks the bankLock object* ，此时 `bankLock` 对象的持有计数为2。当 `getTotalBalance` 方法退出的时候，持有计数变回1。当 `transfer` 方法退出的时候，持有计数变为0。线程释放锁。

通常，我们可能希望==保护「要若干个操作来更新或检查共享对象的代码块」，从而确保这些操作完成后，其他线程才能使用相同对象==。
> 警告：要注意**确保临界区中的代码不要因为抛出异常而跳出临界区**。如果在临界区代码结束之前抛出了异常，`finally` 子句将释放锁，但是对象可能处于被破坏的状态。

> [API] `java.util.concurrent.locks.Lock` 5.0
> - `void lock()`
> 获取这个锁；如果锁当前被另一个线程占有，则发生阻塞。
> - `void unlock()`
> 释放这个锁。

> [API] `java.util.concurrent.locks.ReentrantLock` 5.0
> - `ReentrantLock()`
> 构建一个可以用来保护临界区的可重入锁。
> - `ReentrantLock(boolean fair)`
> **构建一个采用公平策略的锁**，一个公平锁偏爱等待时间最长的线程，但（这一公平的保证使得）公平锁要比常规锁慢很多。所以，默认情况下，锁没有被强制为公平的。只有当你确实了解自己要做什么，而且对于要解决的问题有一个特定的理由、确实要考虑公平性时，才应使用公平锁。**即使使用公平锁，也无法确保线程调度器是公平的**。如果线程调度器选择忽略「一个已经为锁等待很长时间的线程」，它就没有机会得到公平处理。

## 12.4.4 条件对象
通常，线程进入临界区后，结果发现它在满足某个条件之前无法继续。==可以使用一个条件对象来管理那些「已经获得了一个锁却不能做有用工作的线程」==。这一节里，介绍Java库中条件对象的实现（由于历史原因，条件对象经常被称为**条件变量** `conditional variable` ）。

现在优化银行的模拟程序。我们避免选择没有足够资金的账户作为转出账户。注意不能使用类似下面的代码：
```java
if (bank.getBalance(from) >= amount)
	bank.transfer(from, to, amount);
```
在成功地通过了这个测试之后，但在调用 `transfer` 方法之前，当前线程完全可能被中断。
```java
if (bank.getBalance(from) >= amount)
	// thread might be deactivated at this point
	bank.transfer(from, to, amount);
```
在线程再次运行前，账户余额可能已经低于提款金额。**必须确保没有其他线程在本检査余额与转账活动之间修改余额**。为此，可以使用一个锁来保护这个检査与转账动作：
```java
public void transfer(int from, int to, int amount) {
	bankLock.lock();
	try {
		while (accounts[from] <= amount) {
			// wait
			...
		}
		// transfer funds
		...
	} finally {
		bankLock.unlock();
	}
}
```
现在，当账户中没有足够的余额时，应该做什么呢？我们要等待，直到另一个线程向账户中增加了资金。但这一线程刚刚获得了对 `bankLock` 的排它性访问，因此别的线程没有存款操作的机会。这就是为什么我们需要引入条件对象。

**一个锁对象可以有一个或多个相关联的条件对象**。可以用 `newCondition` 方法获得一个条件对象。习惯上会给每个条件对象一个合适的名字、来反映它表示的条件。例如，在这里我们建立了一个条件对象来表达“余额充足”条件。
```java
class Bank {
	private Condition sufficientFunds;
	...
	public Bank() {
		...
		sufficientFunds = bankLock.newCondition();
	}
}
```
如果 `transfer` 方法发现余额不足，它会调用
```java
sufficientFunds.await();
```
==当前线程现在被阻塞，并放弃锁。这就允许另一个线程执行==，我们希望它能增加账户余额。

**一个等待获得锁的线程和调用 `await` 方法的线程** *a thread that is waiting to acquire a lock and a thread that has called await* **存在本质上的不同**。一旦一个线程调用了 `await` 方法，它就进入这个条件的**等待集** `wait set` 。==当锁可用 *available* 时，该线程并不会马上解除阻塞、变为可运行状态==（所以必须调用 `signalAll` 方法，也必须等待锁释放）。==相反，它仍保持非活动状态==，直到另一个线程在同一条件上调用 `signalAll` 方法。

当另一个线程完成转账时，它应该调用
```java
sufficientFunds.signalAll();
```
==这一调用会重新激活「等待这一条件的所有线程」。当这些线程从等待集当中移出时，它们再次成为可运行的线程，调度器最终将再次激活它们==。同时，它们会试图重新进入该对象。**一旦锁可用，它们中的某个线程将从 `await` 调用返回，获得该锁、并从之前被阻塞的地方继续执行**。

此时，**线程应当再次测试该条件**。由于无法确保现在一定满足该条件—— `signalAll` 方法仅是通知正在等待的线程：**此时有可能满足条件，值得再次检测该条件**。
> 注释：通常，`await` 调用应放在如下形式的循环体中：
> ```java
> while (!(OK to proceed))
> 	condition.await();
> ```

至关重要的是，最终需要有某个其他线程调用 `signalAll` 方法。**当一个线程调用 `await` 时，它没有办法重新激活自身**。它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不再运行了。这将导致令人不快的死锁 `deadlock` 现象。如果所有其他线程都被阻塞，最后一个活动线程在解除另外某个线程的阻塞之前、就调用 `await` 方法，那么它也被阻塞。此时没有线程可以解除其他线程的阻塞，该程序就永远挂起了。

应该何时调用 `signalAll` 呢？经验上讲，**只要一个对象的状态有变化、且可能有利于等待的线程时，就可以调用 `signalAll`** 。例如，当一个账户余额发生改变时，就应再给等待的线程一个机会来检查余额。在例子中，完成了转账时我们就会调用 `signalAll` 方法。
```java
public void transfer(int from, int to, int amount) {
	bankLock.lock();
	try {
		while (accounts[from] < amount)
			sufficientFunds.await();
		// transfer funds
		...
		sufficientFunds.signalAll();
	} finally {
		bankLock.unlock();
	}
}
```
注意，`signalAll` 调用不会立即激活一个等待的线程。它只是解除等待线程的阻塞，**使这些线程可以在当前线程释放锁之后，通过竞争实现对对象的访问**。

另一个方法 `signal` ，只是随机解除「等待集中某个线程」的阻塞状态。**这比解除所有线程的阻塞更高效、但也存在危险**。如果随机选择的线程发现自己仍然不能运行（锁不可用；或者锁可用，线程从 `await` 调用返回、获得锁、但测试条件时无法满足），它就会再次被阻塞。如果没有其他线程再次调用 `signal` ，那么系统就死锁了。
> 警告：只有当一个线程拥有某个条件的锁时，它才能在该条件上调用 `await, signalAll, signal` 方法。

如果运行 `synch/Bank.java` ，会注意到没有出现任何错误。总余额永远是$100000；没有任何账户曾出现负的余额（但还是需要按下CTRL+C来终止程序）。可能还注意到，这个程序运行起来慢一些——这是为实现同步机制中的簿记操作 *the added bookkeeping involved in the synchronization mechanism* 所付出的代价。

实际上，正确使用条件富有挑战性。开始实现自己的条件对象之前，应该考虑使用12.5节Thread-Safe Collections中描述的某个结构。
```java
// synch/Bank.java
package synch;

import java.util.*;
import java.util.concurrent.locks.*;

/**
 * A bank with a number of bank accounts that uses locks for serializing access.
 */
public class Bank {
	private final double[] accounts;
	private Lock bankLock;
	private Condition sufficientFunds;

	/**
	 * Constructs the bank.
	 * @param n the number of accounts
	 * @param initialBalance the initial balance for each account
	 */
	public Bank(int n, double initialBalance) {
		accounts = new double[n];
		Arrays.fill(accounts, initialBalance);
		bankLock = new ReentrantLock();
		sufficientFunds = bankLock.newCondition();
	}

	/**
	 * Transfers money from one account to another.
	 * @param from the account to transfer from
	 * @param to the account to transfer to
	 * @param amount the amount to transfer
	 * @throws InterruptedException 
	 */
	public void transfer(int from, int to, double amount) throws InterruptedException {
		bankLock.lock();
		try {
			while (accounts[from] < amount)
				sufficientFunds.await(); // InterruptedException
			System.out.print(Thread.currentThread());
			accounts[from] -= amount;
			System.out.printf(" %10.2f from %d to %d", amount, from, to);
			accounts[to] += amount;
			System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
			sufficientFunds.signalAll();
		} finally {
			bankLock.unlock();
		}
	}

	/**
	 * Gets the sum of all account balances.
	 * @return the total balance
	 */
	public double getTotalBalance() {
		bankLock.lock();
		try {
			double sum = 0;
			for (double a : accounts) {
				sum += a;
			}
			return sum;
		} finally {
			bankLock.unlock();
		}
	}

	/**
	 * Gets the number of accounts in the bank.
	 * @return the number of accounts
	 */
	public int size() {
		return accounts.length;
	}
}
```
在 `synch/SynchBankTest.java` 中运行后，结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211042244322.png)

> [API] `java.util.concurrent.locks.Lock` 5.0
> - `Condition newCondition()`
> 返回一个与该锁相关联的条件对象。

> [API] `java.util.concurrent.locks.Condition` 5.0
> - `void await()`
> 将该线程放到这个条件的等待集中。
> - `void signalAll()`
> 解除该条件的等待集中所有线程的阻塞状态。
> - `void signal()`
> 从该条件的等待集中随机地选择一个线程，解除其阻塞状态。

## 12.4.5 `synchronized` 关键字
在上节中，介绍了如何使用 `Lock` 和 `Condition` 对象。在进一步深入之前，总结锁和条件的要点：
- 锁用来保护代码片段，一次只能有一个线程执行被保护的代码。
- 锁可以管理试图进入被保护代码段的线程。
- **一个锁可以拥有一个或多个相关联的条件对象**。
- 每个条件对象管理那些「已经进入被保护的代码段、但还不能运行的线程」。

`Lock` 和 `Condition` 接口允许程序员充分控制锁定 *a high degree of
control over locking* 。==然而大多数情况下，并不需要那样的控制，完全可以使用Java内置的一种机制==。从1.0版开始，**Java中的每一个对象都有一个内部锁**。如果一个方法声明时有 `synchronized` 关键字，那么对象的锁将保护整个方法。也就是说，**要调用该方法，线程必须获得内部的对象锁**。换句话说，
```java
public synchronized void method() {
	method body
}
```
等价于：
```java
public void method() {
	this.intrinsicLock.lock();
	try {
		method body
	} finally { this.intrinsicLock.unlock(); }
}
```
例如，可以简单地声明 `Bank` 类的 `transfer` 方法为 `synchronized` ，而不必使用一个显式的锁。

==内部对象锁只有一个关联条件 *The intrinsic object lock has a single associated condition*== 。`wait` 方法添加一个线程到等待集中，`notifyAll /notify` 方法可以解除等待线程的阻塞。换句话说，调用 `wait` 或 `notifyAll` 等价于：
```java
intrinsicCondition.await();
intrinsicCondition.signalAll(); 
```
> 注释：`wait, notifyAll` 以及 `notify` 方法是 `Object` 类的 `final` 方法。`Condition` 方法必须被命名为 `await, signalAll, signal` ，从而不会与那些方法发生冲突。

例如，可以用Java实现 `Bank` 类如下：
```java
class Bank {
	private double[] accounts;
	public synchronized void transfer(int from, int to, int amount)
	throws InterruptedException {
		while (accounts[from] < amount)
			wait(); // wait on intrinsic object lock's single condition
		accounts[from] -= amount;
		accounts[to] += amount;
		notifyAll(); // notify all threads waiting on the condition
	}
	public synchronized double getTotalBalance() { ... }
}
```
可以看到，使用 `synchronized` 关键字编写代码要简洁得多。当然，要理解这一代码，就必须了解**每个对象都有一个内部锁，并且该锁有一个内部条件**——这个锁会管理那些试图进入 `synchronized` 方法的线程，这个条件管理那些调用 `wait` 的线程。
> 提示：`Synchronized` 方法是相对简单的。但初学者常常对条件 *condition* 感到困惑。**在使用 `wait/notifyAll` 之前，应该考虑使用12.5节Thread-Safe Collections描述的结构之一**。

**将静态方法声明为 `synchronized` 也是合法的**。如果调用这样一个方法，该方法会获得**相关类对象的内部锁**。例如，如果 `Bank` 类有一个静态同步的方法，那么当该方法被调用时，`Bank.class` 对象的锁会被锁住。因此，没有其他线程可以调用这个类的该方法、或**任何其他的同步静态方法** *any other synchronized static method of the same class* 。

内部锁和条件存在一些限制。包括：
- 不能中断一个正在尝试获得锁的线程。
- 不能指定线程尝试获得锁时的超时时间 *cannot specify a timeout when trying to acquire a lock* 。
- 每个锁仅有一个条件，可能是不够的。

在代码中应该使用哪一种做法呢？`Lock` 和 `Condition` 对象还是同步方法？下面是一些建议：
- **最好既不使用 `Lock/Condition` 也不使用 `synchronized` 关键字**。在许多情况下可以使用 `java.util.concurrent` 包中的某种机制，它会为你处理所有的加锁。如在12.5.1节会看到如何使用阻塞队列来同步「完成一个共同任务的线程」。还应当研究一下**并行流** *parallel streams* ，内容参见卷II章1。
- **如果 `synchronized` 关键字适合你的程序，那么尽量使用这种做法**，这样可以减少编写的代码数量、减少出错的几率。`synch2/Bank.java` 给出了用同步方法实现的银行实例。
- 如果特别需要 `Lock/Condition` 结构提供的额外能力时，则使用 `Lock/Condition` 。

```java
// synch2/Bank.java
package synch2;
import java.util.*;

/**
 * A bank with a number of bank accounts that uses synchronization primitives.
 */
public class Bank {
	private final double[] accounts;

	/**
	 * Constructs the bank.
	 * @param n the number of accounts
	 * @param initialBalance the initial balance for each account
	 */
	public Bank(int n, double initialBalance) {
		accounts = new double[n];
		Arrays.fill(accounts, initialBalance);
	}

	/**
	 * Transfers money from one account to another.
	 * @param from the account to transfer from
	 * @param to the account to transfer to
	 * @param amount the amount to transfer
	 * @throws InterruptedException 
	 */
	public synchronized void transfer(int from, int to, double amount) 
			throws InterruptedException {
		while (accounts[from] < amount) wait();
		System.out.print(Thread.currentThread());
		accounts[from] -= amount;
		System.out.printf(" %10.2f from %d to %d", amount, from, to);
		accounts[to] += amount;
		System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
		notifyAll();
	}

	/**
	 * Gets the sum of all account balances.
	 * @return the total balance
	 */
	public synchronized double getTotalBalance() {
		double sum = 0;
		for (double a : accounts)
			sum += a;
		return sum;
	}

	/**
	 * Gets the number of accounts in the bank
	 * @return the number of accounts
	 */
	public int size() {
		return accounts.length;
	}
}
```
> [API] `java.lang.Object` 1.0
> - `void notifyAll()`
> 解除「那些在该对象上调用 `wait` 方法的线程」的阻塞状态。**该方法只能在同步方法或同步块中调用**。如果当前线程不是对象锁的持有者，该方法拋出一个 `IllegalMonitorStateException` 异常。
> - `void notify()`
> 随机选择一个「在该对象上调用 `wait` 方法的线程」解除其阻塞状态。**该方法只能在一个同步方法或同步块中调用**。如果当前线程不是对象锁的持有者，该方法抛出一个 `IllegalMonitorStateException` 异常。
> - `void wait()`
> 导致一个线程进入等待状态、直到它被通知 *notified* 。**该方法只能在一个同步方法或同步块中调用**。如果当前线程不是对象锁的持有者，该方法拋出一个 `IllegalMonitorStateException` 异常。
> - `void wait(long millis)`
> - `void wait(long millis, int nanos)`
> 导致一个线程进入等待状态、直到它被通知或者经过了指定的时间。**这些方法只能在一个同步方法或同步块中调用**。如果当前线程不是对象锁的持有者，该方法拋出一个 `IllegalMonitorStateException` 异常。

## 12.4.6 同步块
正如刚刚讨论的，==每个Java对象都有一个锁。线程可以通过调用同步方法获得锁==。还有==另一种机制可以获得锁：即进入一个同步块==。当线程进入如下形式的块时，它会获得 `Obj` 的锁：
```java
synchronized (obj) { // this is the syntax for a synchronized block
	// critical section
}
```
有时我们会发现一些 *ad hoc locks* ，例如（在此 `lock` 对象被创建，仅是为了使用每个Java对象持有的锁 *only to use the lock that every Java object possesses* ）：
```java
public class Bank {
	private double[] accounts;
	private var lock = new Object();
	...
	public void transfer(int from, int to, int amount) {
		synchronized (lock) { // an ad-hoc lock
			accounts[from] -= amount;
			accounts[to] += amount;
		}
		System.out.println(...);
	}
}
```
有时，程序员**使用一个对象的锁、来实现额外的原子操作**——这种做法称为**客户端锁定** `client-side locking` 。例如考虑 `Vector` 类，一个「方法是同步的」的列表 *a list whose methods are synchronized* 。现在，假定我们在一个 `Vector<Double>` 中存储银行余额。这里有一个 `transfer` 方法的原始实现：
```java
public void transfer(Vector<Double> accounts, int from, int to, int amount) { // ERROR
	accounts.set(from, accounts.get(from) - amount);
	accounts.set(to, accounts.get(to) + amount);
	System.out.println(...);
}
```
`Vector` 类的 `get` 和 `set` 方法是同步的，但这对于我们并没有什么帮助。在第一次对 `get` 的调用完成后，一个线程完全可能在 `transfer` 方法中被剥夺运行权（抢占）。然后另一个线程可能在相同位置存入不同的值。不过，我们可以截获这个锁：
```java
public void transfer(Vector<Double> accounts, int from, int to, int amount) {
	synchronized (accounts) {
		accounts.set(from, accounts.get(from) - amount);
		accounts.set(to, accounts.get(to) + amount);
	}
	System.out.println(...);
}
```
这个方法可以工作，但它完全依赖于这样一个事实：**`Vector` 类会对自己的所有更改方法都使用内部锁**。然而，这是真的吗？`Vector` 类的文档没有给出这样的承诺。必须仔细研究源代码、并希望将来的版本不会引入非同步的更改方法 *do not introduce unsynchronized mutators* 。如你所见，**客户端锁定是非常脆弱的，通常不推荐使用**。
> 注释：Java虚拟机对同步方法提供了内置支持，不过同步块会被编译为很长的字节码序列来管理内部锁。

## 12.4.7 监视器概念
**锁和条件是实现线程同步的强大工具**，但严格地讲，它们不是面向对象的。多年来研究员努力寻找一种方法，希望不需要程序员考虑如何加锁的情况下、就可以保证多线程的安全性。最成功的解决方案之一是监视器 *monitor* ，这一概念最早由 *Per Brinch Hansen* 和 *Tony Hoare* 在20世纪70年代提出的。用Java的术语来讲，监视器具有如下特性：
- **监视器是只包含私有字段的类**。
- 监视器类的每个对象有一个关联的锁。
- 所有方法都由该锁锁定。换句话说，**如果客户端调用 `obj.method()` ，那么 `obj` 对象的锁在方法调用开始时自动获得，并且当方法返回时自动释放该锁**。因为所有的字段是私有的，这样的安排可以确保一个线程在操作对象、处理字段时，没有其他线程能访问这些字段。
- 该锁可以有任意多个相关联的条件。

监视器的早期版本只有一个单独的条件，使用一种很优雅的语法。可以简单地调用 `await accounts[from] >= balance` 、而不使用任何显式的条件变量。然而研究表明，盲目地重新测试条件是低效的。可以利用显式的条件变量 *explicit condition variable* 解决这一问题，**每一个条件变量管理一个独立的线程集**。

Java设计者以不太严格的方式采用了监视器概念，Java中的每个对象都有一个内部锁和一个内部条件。**如果一个方法用 `synchronized` 关键字声明，那么它表现得就像是一个监视器方法**。通过调用 `wait/notifyAll/notify` 来访问条件变量。

然而，在下述3个重要方面Java对象不同于监视器，这削弱了线程的安全性：
- 字段不要求是 `private` 。
- 方法不要求是 `synchronized` 。
- 内部锁对客户 *clients* 是可用的。

这种对安全性的轻视激怒了 *Per Brinch Hansen* 。在一次对Java中多线程原语的严厉评论中，写道：“这实在是令我震惊，在监视器和并发Pascal出现四分之一个世纪后，Java的这种不安全的并行机制被编程社区接受。这没有任何益处。”[Java ’ s Insecure Parallelism, ACM SIGPLAN Notices 34:38-45，April 1999.]

## 12.4.8 `Volatile `字段
有时，如果仅为了读写一两个实例字段就使用同步，显得开销过大了。毕竟，什么地方能出错呢？遗憾的是，使用现代的处理器与编译器，出错的可能性很大。
- 多处理器的计算机能暂时在寄存器或本地内存缓存中保存内存值 *hold memory values in registers or local memory caches* 。结果是，运行在不同处理器上的线程可能看到同一个内存位置有不同值。
- 编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义，但编译器假定：内存值只在代码中有显式的修改指令时才会改变。然而，内存值可能被另一个线程改变！

如果使用锁来保护「可能被多个线程访问的代码」，那么不存在这种问题。编译器被要求在必要时刷新本地缓存来支持锁，并且不能不适当地重新排序指令。详细解释见[JSR 133的Java内存模型和线程规范](http://www.jcp.org/en/jsr/detail?id=133) ，该规范的大部分很复杂且技术性强，但文档中也包含了很多解释得很清晰的例子。在http://www.ibm.com/developerworks/library/j-jtp02244有 *Brian Goetz* 写的一个更易懂的概要介绍。
> 注释：*Brian Goetz* 给出了下述“同步格言”：“如果向一个变量写入值，而这个变量接下来可能会被另一个线程读取，或者如果读一个变量，而这个变量可能已经被另一个线程写入值，此时必须使用同步”。

`volatile` 关键字为实例字段的同步访问提供了一种免锁机制。**如果声明一个字段为 `volatile` ，那么编译器和虚拟机就知道该字段可能被另一个线程并发更新**。例如，假定一个对象有一个标记 `done` ，它的值由一个线程设置、而由另一个线程査询，如同讨论过的那样，你可以使用锁：
```java
private boolean done;
public synchronized boolean isDone() { return done; }
public synchronized void setDone() { done = true; }
```
或许使用内部对象锁不是个好主意。如果另一个线程已经对该对象加锁，`isDone` 和 `setDone` 方法可能会阻塞。如果这是个问题，可以只为这个变量使用一个单独的 `Lock` 。但是，这会很麻烦。

在这种情况下，将字段声明为 `volatile` 很合适。编译器会插入适当的代码、以确保如果一个线程对 `done` 变量做了修改，这个修改对读取这个变量的所有其他线程都可见：
```java
private volatile boolean done;
public boolean isDone() { return done; }
public void setDone() { done = true; }
```
> 警告：**`volatile` 变量不能提供原子性** *atomicity* 。例如，方法：
> ```java
> public void flipDone() { done = !done；} // not atomic
> ```
> 不能确保翻转字段值。不能保证读取、翻转和写入不被中断。

## 12.4.9 `final` 变量
上一节已经了解到，**除非使用锁或 `volatile` 修饰符，否则无法从多个线程安全地读取一个字段**。

还有一种情况可以安全地访问一个共享字段，即这个字段声明为 `final` 时。考虑以下声明，其他线程会在这个构造器方法完成构造之后，才看到这个 `accounts` 变量：
```java
final var accounts = new HashMap<String, Double>();
```
如果不使用 `final` ，就不能保证其他线程看到的是 `accounts` 更新后的值，它们可能都只是看到 `null` ，而不是新构造的 `HashMap` 。

当然，对这个映射的操作并不是线程安全的。如果多个线程读写这个映射，仍然需要进行同步。
## 12.4.10 原子性
假设对共享变量除了赋值外、并不完成其他操作，那么可以将这些共享变量声明为 `volatile` 。

`java.util.concurrent.atomic` 包中有很多类**使用了很高效的机器级指令（而不是使用锁） 来保证其他操作的原子性**。例如，`AtomicInteger` 类提供了方法 `incrementAndGet` 和 `decrementAndGet` ，它们分别以原子方式将一个整数自增或自减。例如，可以安全地生成一个数值序列，如下所示：
```java
public static AtomicLong nextNumber = new AtomicLong();
// in some thread ...
long id = nextNumber.incrementAndGet();
```
`incrementAndGet` 方法以原子方式将 `AtomicLong` 自增，并返回自增后的值。也就是说，获得值、增1、设置值、生成新值的操作不会中断。可以保证即使是多个线程并发地访问同一个实例，也会计算并返回正确的值。

有很多方法可以以原子方式设置和增减值，不过如果希望完成更复杂的更新，就必须使用 `compareAndSet` 方法。例如，假设希望跟踪不同线程观察的最大值 *keep track of the largest value that is observed by different threads* 。下面的代码是不可行的：
```java
public static AtomicLong largest = new AtomicLong();
// in some thread ...
largest.set(Math.max(largest.get(), observed)); // ERROR--race condition!
```
这个更新不是原子的。实际上应当在一个循环中计算新值和使用 `compareAndSet` ——如果另一个线程也在更新 `largest` ，就可能阻止这个线程更新。这样一来，`compareAndSet` 会返回 `false` 、而不会设置新值。这种情况下，循环会再次尝试、读取更新后的值、并尝试修改。最终，它会成功地用新值替换原来的值。听上去麻烦，不过 **`compareAndSet` 方法会映射到一个处理器操作，比使用锁速度更快**。
```java
do {
	oldValue = largest.get();
	newValue = Math.max(oldValue, observed);
} while (!largest.compareAndSet(oldValue, newValue));
```
在Java 8中，**不再需要编写这样的循环样板代码**，实际上可以提供一个lambda表达式更新变量，它会为你完成更新。对于这个例子，我们可以调用：
```java
largest.updateAndGet(x -> Math.max(x, observed));
// or
largest.accumulateAndGet(observed, Math::max);
```
`accumulateAndGet` 方法利用一个二元操作符来合并原子值和所提供的参数。还有 `getAndUpdate` 和 `getAndAccumulate` 方法可以返回原值。
> 注释：类 `AtomicInteger, AtomicIntegerArray, AtomicIntegerFieldUpdater, AtomicLongArray, AtomicLongFieldUpdater, AtomicReference, AtomicReferenceArray, AtomicReferenceFieldUpdater` 也提供了这些方法。

如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新 *optimistic updates* 需要太多次重试。Java 8提供了 `LongAdder` 和 `LongAccumulator` 类来解决这个问题。`LongAdder` 包括多个变量（加数），它们的总和就是当前值。多个线程可以更新不同的加数，线程个数增加时会自动提供新的加数。==只有当所有工作都完成之后才需要总和的值，对于这种情况，这种方法会很高效，性能有显著提升==。

如果认为可能存在大量竞争，只需要使用 `LongAdder` 而非 `AtomicLong` 。方法名稍有区别。调用 `increment` 让计数器自增，或者调用 `add` 来增加一个量，或者调用 `sum` 来获取总和。
```java
var adder = new LongAdder();
for (...) {
	pool.submit(() -> {
		while (...) {
			...
			if (...) adder.increment();
		}
	});
}
...
long total = adder.sum();
```
> 注释：当然，`increment` 方法不会返回原值，这样做会消除将求和分解到多个加数所带来的性能提升。

`LongAccumulator` 将这种思想推广到任意的累加操作。在构造器中，可以提供这个操作以及它的零 *neutral* 元素。要加入新的值，可以调用 `accumulate` 。调用 `get` 来获得当前值。下面的代码可以得到与 `LongAdder` 同样的效果：
```java
LongAccumulator adder = new LongAccumulator(Long::sum, 0);
// In some thread...
adder.accumulate(value);
```
在内部，这个累加器包含变量 $a_1,a_2,\dots,a_n$ 。每个变量初始化为零元素（这个例子中零元素为0）。调用 `accumulate` 并提供值 $v$ 时，其中一个变量会以原子方式更新为 $a_i =a_i\ op\ v$ ，这里 $op$ 是中缀形式的累加操作。在我们这个例子中，调用 `accumulate` 会对某个 $i$ 计算 $a_i = a_i +v$ 。`get` 的结果是 $a_1\ op\ a_2\ op\ \dots\ op\ a_n$ 。在我们的例子中，这就是累加器的总和：$a_1 + a_2 + … +a_n$ 。

==如果选择一个不同的操作，可以计算最小值或最大值。一般地，这个操作必须满足结合律和交换律==。这说明，最终结果必须独立于（不依赖）以什么顺序结合这些中间值。

`DoubleAdder` 和 `DoubleAccumulator` 也采用同样的方式，只不过处理的是 `double` 值。
## 12.4.11 死锁
锁和条件不能解决多线程中可能出现的所有问题。考虑下面的情况：
1. 账户1：$200
2. 账户2：$300
3. 线程1：从账户1转移$300到账户2
4. 线程2：从账户2转移$400到账户1
![图12-4](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211071218138.png)

如图12-4所示，线程1和线程2都被阻塞了。因为账户1以及账户2中的余额都不足以进行转账，两个线程都无法执行下去（这个例子举得不好，其实它们都可以先检查账户余额是否足以转账）。

有可能会因为每一个线程要等待更多的钱款存入而导致所有线程都被阻塞。这样的状态称为死锁 `deadlock` 。

在我们的程序里，死锁不会发生，原因很简单。每一次转账至多$1000。因为有100个账户，而且所有账户的总金额是$100000，在任意时刻，至少有一个账户的余额高于$1000。从该账户取钱的线程可以继续运行。

但如果修改 `run` 方法，把每次转账至多$1000 的限制去掉，死锁很快就会发生。试试看。将 `NACCOUNTS` 设为10。每次交易的金额上限设置为 `2 * INITIAL_BALANCE` ，然后运行该程序。程序将运行一段时间后就会挂起。
![图12-5 发生死锁的情况|600x450](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211071231735.png)

> 提示：当程序挂起时，键入CTRL+\，将得到一个所有线程的列表。每个线程有一个栈踪迹，告诉你线程被阻塞的位置。像第7章所述，运行 `jconsole` 并参考线程面板（见图12-5）。

导致死锁的另一种途径是，让第 `i` 个线程负责向第 `i` 个账户存钱，而不是从第 `i` 个账户取钱。这样一来，有可能所有的线程都集中到一个账户上，每一个线程都试图从这个账户中取出大于该账户余额的钱。试试看。在 `SynchBankTest` 程序中，转用 `TransferRunnable` 类的 `run` 方法。
在调用 `transfer` 时，交换 `fromAccount` 和 `toAccount` 。运行该程序并查看它为什么会立即死锁。

还有一种很容易导致死锁的情况：在 `SynchBankTest` 程序中，将 `signalAll` 方法转换为 `signal` ，会发现该程序最终会挂起（将 `NACCOUNTS` 设为10可以更快地看到结果）。`signalAll` 通知所有等待增加资金的线程，与此不同的是 `signal` 方法只解锁一个线程的阻塞。如果该线程不能继续运行，所有的线程可能都被阻塞。考虑下面这个会发生死锁的例子。
1. 账户1：$1990
2. 所有其他账户：每一个$990
3. 线程1：从账户1转移$995到账户2
4. 所有其他线程：从他们的账户转移$995到另一个账户

显然，除了线程1，所有的线程都被阻塞，因为他们的账户中没有足够的余额。线程1继续执行，运行后出现如下状况：
1. 账户1：$995
2. 账户2：$1985
3. 所有其他账户：每个 $990

然后，线程1调用 `signal` 。`signal` 方法随机选择一个线程为它解锁。假定它选择了线程3。该线程被唤醒，发现在它的账户里没有足够的金额，它再次调用 `await` 。但线程1仍在运行，将随机地产生一个新的交易，例如，
1. 线程1：从账户1转移$997到账户2

现在，线程1也调用 `await` ，所有的线程都被阻塞。系统死锁。问题的起因在于调用 `signal` 。它仅仅为一个线程解锁，而它很可能选择一个不能继续运行的线程（在我们的例子中，线程2必须把钱从账户2中取出）。

遗憾的是，**Java语言中没有任何东西可以避免或打破这种死锁**。必须仔细设计程序，以确保不会出现死锁。
## 12.4.12 线程局部变量
前面几节中，我们讨论了在线程间共享变量的风险。有时可能要**避免共享变量，使用 `ThreadLocal` 辅助类为各个线程提供各自的实例**。例如，`SimpleDateFormat` 类不是线程安全的。假设有一个静态变量：
```java
public static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
```
如果两个线程都执行以下操作，结果可能很混乱，因为 `dateFormat` 使用的内部数据结构可能会被并发的访问所破坏。当然可以使用同步，但开销很大；或者也可以在需要时构造一个局部 `SimpleDateFormat` 对象，不过这也太浪费了：
```java
String dateStamp = dateFormat.format(new Date());
```
要为每个线程构造一个实例，可以使用以下代码：
```java
public static final ThreadLocal<SimpleDateFormat> dateFormat 
	= ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
```
要访问具体的格式化方法 *formatter* ，可以调用：
```java
String dateStamp = dateFormat.get().format(new Date());
```
在一个给定线程中首次调用 `get` 时，会调用构造器中的lambda表达式。在此之后，`get` 方法会返回「属于当前线程的那个实例」。

在多个线程中生成随机数也存在类似的问题。**`java.util.Random` 类是线程安全的**。但如果多个线程需要等待一个共享的随机数生成器，这会很低效。可以使用 `ThreadLocal` 辅助类为各个线程提供一个单独的生成器，不过Java 7还另外提供了一个便利类。只需要做以下调用，`ThreadLocalRandom.current()` 调用会返回特定于当前线程的 `Random` 类实例：
```java
int random = ThreadLocalRandom.current().nextInt(upperBound);
```

> [API] `java.lang.ThreadLocal<T>`
> - `T get()`
> 得到这个线程的当前值。如果是首次调用 `get` ，会调用 `initialize` 来得到这个值。
> - `void set(T t)`
> 为这个线程设置一个新值。
> - `void remove()`
> 删除对应这个线程的值。
> - `static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier)` 8
> 创建一个线程局部变量 *thread local variable* ，其初始值通过调用给定的 `supplier` 生成。

> [API] `java.util.concurrent.ThreadLocalRandom` 7
> - `static ThreadLocalRandom current()`
> 返回特定于当前线程的 `Random` 类实例。

## 锁测试与超时
线程在调用 `lock` 方法来获得另一个线程所持有的锁的时候，很可能发生阻塞。**应该更加谨慎地申请锁**。`tryLock` 方法试图申请一个锁，在成功获得锁后返回 `true` ，否则立即返回 `false` ，而且线程可以立即离开去做其他事情。
```java
if (myLock.tryLock()) {
	// now the thread owns the lock
	try { ... }
	finally { myLock.unlock(); }
} else 
	// do something else
```
调用 `tryLock` 时，可以使用超时参数，像这样（`TimeUnit` 是一个枚举类型，可以取的值包括 `SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS` ）：
```java
if (myLock.tryLock(100, TimeUnit.MILLISECONDS)) ...
```
`lock` 方法不能被中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁，那么 `lock` 方法就无法终止。然而，**如果调用带有超时参数的 `tryLock` ，那么如果线程在等待期间被中断，将抛出 `InterruptedException` 异常**。这是一个非常有用的特性，因为允许程序打破死锁。

也可以调用 `lockInterruptibly` 方法。它就相当于一个超时设为无限的 `tryLock` 方法。

在等待一个条件时，也可以提供一个超时：
```java
myCondition.await(100, TimeUnit.MILLISECONDS));
```
**如果一个线程被另一个线程通过调用 `signalAll` 或 `signal` 激活，或者超时时限已达到，或者线程被中断，那么 `await` 方法将返回**。

如果等待的线程被中断，`await` 方法将抛出一个 `InterruptedException` 异常。在你希望出现这种情况时、线程继续等待直到 `signal/signalAll`（可能不太合理），可以使用 `awaitUninterruptibly` 方法代替 `await` 。

> [API] `java.util.concurrent.locks.Lock` 5.0
> - `boolean tryLock()`
> 尝试获得锁而没有发生阻塞；如果成功返回真。这个方法会抢夺可用的锁，即使该锁有公平加锁策略，即便其他线程已经等待很久也是如此。
> - `boolean tryLock(long time, TimeUnit unit)`
> 尝试获得锁，阻塞时间不会超过给定的值；如果成功返回 `true` 。
> - `void lockInterruptibly()`
> 获得锁，但是会不确定地发生阻塞。如果线程被中断，抛出一个 `InterruptedException` 异常。

> [API] `java.util.concurrent.locks.Condition` 5.0
> - `boolean await(long time, TimeUnit unit)`
> 进入该条件的等待集，直到线程从等待集中移出、或等待了指定的时间之后才解除阻塞。如果因为等待时间到了而返回就返回 `false` ，否 则返回 `true` 。
> - `void awaitUninterruptibly()`
> 进入该条件的等待集，直到线程从等待集移出才解除阻塞。如果线程被中断，该方法不会抛出 `InterruptedException` 异常（而是继续等待）。

## 读/写锁
`java.util.concurrent.locks` 包定义了两个锁类，已讨论 `ReentrantLock` 类和 `ReentrantReadWriteLock` 类。**如果很多线程从一个数据结构读取数据、而很少线程修改其中数据的话，后者是十分有用的**。在这种情况下，允许对读者线程共享访问是合适的。当然，写者线程依然必须是互斥访问的。

下面是使用读/写锁的必要步骤：
1. 构造一个 `ReentrantReadWriteLock` 对象：
```java
private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
```
2. 抽取读锁和写锁：
```java
private Lock readLock = rwl.readLock();
private Lock writeLock = rwl.writeLock();
```
3. 对所有的获取方法加读锁：
```java
public double getTotalBalance() {
	readLock.lock();
	try { ... }
	finally { readLock.unlock(); }
}
```
4. 对所有的修改方法加写锁：
```java
public void transfer(...) {
	writeLock.lock();
	try { ... }
	finally { writeLock.unlock(); }
}
```

> [API] `java.util.concurrent.locks.ReentrantReadWriteLock` 5.0
> - `Lock readLock()`
> 得到一个可以被多个读操作共用的读锁，但会排斥所有写操作。
> - `Lock writeLock()`
> 得到一个写锁，排斥所有其他的读操作和写操作。

## 12.4.13 为什么弃用 `stop` 和 `suspend` 方法
初始的Java版本定义了一个 `stop` 方法来终止一个线程，以及一个 `suspend` 方法来阻塞一个线程、直至另一个线程调用 `resume` 。**`stop` 和 `suspend` 方法有一些共同点：都试图控制一个给定线程的行为，而没有线程的互操作** *without the thread’s cooperation* 。

`stop, suspend, resume` 方法已被弃用。`stop` 方法天生就不安全，经验证明 `suspend` 方法经常会导致死锁。本节看到这些方法为什么有问题，以及怎样避免这些问题的出现。

首先看 `stop` 方法，该方法终止所有未结束 *pending* 的方法，包括 `run` 方法。**当线程被终止，它会立即释放「被它锁定的所有对象」的锁。这会导致对象处于不一致的状态**。例如，假定一个 `TransferRunnable` 在从一个账户向另一个账户转账的过程中被终止，钱款已经转出，却没有转入目标账户，现在银行对象就被**破坏**了。因为锁已经被释放，其他尚未停止的线程也会观察到这种破坏。

==当一个线程要终止另一个线程时，它无法知道什么时候调用 `stop` 方法是安全的，什么时候会导致对象被破坏==。因此，该方法被废弃了。**在希望停止一个线程时应中断该线程，被中断的线程可以在安全时停止**。
> 注释：一些作者声称 `stop` 方法被弃用，是因为它会导致对象被一个已停止的线程 *stopped thread* 永久锁定。但这一说法是错误的。从技术上讲，被停止的线程通过抛出 `ThreadDeath` 异常、从而退出它调用的所有同步方法。结果是，**该线程释放它持有的内部对象锁**。

接下来看 `suspend` 方法有什么问题。与 `stop` 不同，`suspend` 不会破坏对象。但**如果用 `suspend` 挂起一个持有一个锁的线程，那在线程恢复 *resumed* 之前该锁是不可用的**。如果调用 `suspend` 方法的线程试图获得同一个锁，那么程序死锁：被挂起的线程等着被恢复，而将其挂起的线程等待获得锁 *The suspended thread waits to be resumed, and the
suspending thread waits for the lock* 。

在图形用户界面中经常出现这种情况。假定有一个图形化的银行模拟程序。`Pause` 按钮用来挂起转账线程，而 `Resume` 按钮用来恢复线程。
```java
pauseButton.addActionListener(event -> {
	for (int i = 0; i < threads.length; ++i)
		threads[i].suspend(); // don't do this
}); 
resumeButton.addActionListener(event -> {
	for (int i = 0; i < threads.length; ++i)
		threads[i].resume();
});
```
假设有一个 `paintComponent` 方法，通过调用 `getBalances` 方法获得一个余额数组，从而为每一个账户绘制一个图表。就像在12.7.3节看到的，**按钮动作和重绘动作出现在同一个线程中** *both the button actions and the repainting occur in the same thread* ，**即事件分配线程** `event dispatch thread` 。考虑下面的情况：
1. 某个转账线程获得 `bank` 对象的锁。
2. 用户点击 `Pause` 按钮。
3. 所有转账线程被挂起；其中之一仍然持有 `bank` 对象上的锁。
4. 因为某种原因，该账户图表需要重新绘制。
5. `paintComponent` 方法调用 `getBalances` 方法。
6. 该方法试图获得 `bank` 对象的锁。

现在程序被冻结了。**事件分配线程不能继续运行**，因为锁由一个被挂起的线程所持有。因此，用户不能点击 `Resume` 按钮，并且这些线程无法恢复。

如果想安全地挂起线程，可以引入一个变量 `suspendRequested` 、并在 `run` 方法的某个安全的地方测试它，安全的地方是指**在这里该线程没有锁定其他线程需要的对象**。当该线程发现 `suspendRequested` 变量已经设置，应该保持等待状态、直到再次可用。

---
# 12.5 线程安全的集合
现在，已经看到了**形成Java并发程序设计基础的底层构建块**。然而，对于实际编程来说，应尽可能远离底层结构。==使用「由并发处理的专业人士实现的较高层次的结构」要方便得多、安全得多==。

==另一个顾虑是，如果多个线程要并发修改一个数据结构（如散列表），那么很容易破坏这个数据结构==，例如一个线程可能开始向表中插入一个新元素。假定在调整散列表中各个桶之间的链接关系的过程中 *in the middle of rerouting the links between the hash table's buckets* ，这个线程的控制权被抢占，如果另一个线程开始遍历同一个表，可能使用无效的链接并造成混乱 *follow invalid links and create havoc* ，可能会抛出异常或陷入无限循环。==我们可以通过提供锁来保护共享的数据结构，但选择线程安全的实现可能更容易==。下面讨论Java类库提供的另外一些线程安全的集合。
## 12.5.1 阻塞队列
许多线程问题可以使用一个或多个队列、以优雅且安全的方式形式化 *formulated* 。生产者线程向队列插入元素，消费者线程则取出它们。**使用队列，可以安全地从一个线程向另一个线程传递数据**。例如，考虑银行转账程序，转账线程将转账指令对象插入一个队列中，而不是直接访问银行对象。另一个线程从队列中取出指令执行转账。只有该线程可以访问该银行对象的内部。因此不需要同步（当然，**线程安全的队列类的实现者必须考虑锁和条件**，但那是他们的问题、而不是你的问题。）

当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，**阻塞队列** *blocking queue* 将导致一个线程阻塞。==在协调多个线程之间的合作时，阻塞队列是一个有用的工具==。工作线程可以周期性地将中间结果存储在阻塞队列中。其他的工作线程移出中间结果、并进一步修改。**队列会自动地平衡负载** *balances the workload* ——如果第一个线程集运行得比第二个慢，第二个线程集在等待结果时会阻塞。如果第一个线程集运行得快，队列会填满它，直到第二个队列集赶上来。表12-1给出了阻塞队列的方法。
![表12-1 阻塞队列方法](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211071643402.png)
阻塞队列方法分为以下3类，这取决于当队列满或空时它们的响应方式。**如果将队列当作线程管理工具来使用，要用到 `put` 和 `take` 方法**。当试图向满队列中添加、或从空队列中移出元素时，`add, remove, element` 操作抛出异常。当然，在一个多线程程序中，队列会在任何时候空或满，因此**应当使用 `offer, peek, poll` 方法作为替代**。这些方法如果不能完成任务，只是给出一个错误提示而不会抛出异常。
> 注释：`poll, peek` 方法返回空来指示失败。因此**向这些队列中插入 `null` 值是非法的**。

还有带有超时时间的 `offer` 方法和 `poll` 方法。例如，下面的调用尝试在100毫秒内在队列的尾部插入一个元素，如果成功返回 `true` ；否则返回 `false` ：
```java
boolean success = q.offer(x, 100, TimeUnit.MILLISECONDS);
```
类似地，下面的调用尝试用100毫秒的时间移除队列的头元素；如果成功则返回头元素，否则如果超时，则返回 `null` ：
```java
Object head = q.poll(100，TimeUnit.MILLISECONDS);
```
如果队列满，则 `put` 方法阻塞；如果队列空，则 `take` 方法阻塞。它们与不带超时参数的 `offer` 和  `poll` 方法等效。

`java.util.concurrent` 包提供了阻塞队列的几个变种。默认情况下，`LinkedBlockingQueue` 的容量没有上界，但也可以选择指定一个最大容量。`LinkedBlockingDeque` 是一个双端队列。`ArrayBlockingQueue` 在构造时需要指定容量，并有一个可选参数来指定是否需要公平性。若设置了公平参数，那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能，只有在确实非常需要时才使用它。

`PriorityBlockingQueue` 是一个带优先级的队列，元素按照它们的优先级顺序移除。该队列没有容量上限，但如果队列是空的，取元素的操作会阻塞。

最后，`DelayQueue` 包含实现 `Delayed` 接口的对象，`getDelay` 方法返回对象的残留延迟。负值表示延迟已经结束。**元素只有在延迟用完的情况下，才能从 `DelayQueue` 移除**。**还必须实现 `compareTo` 方法**。`DelayQueue` 使用该方法对元素进行排序。：
```java
interface Delayed extends Comparable<Delayed> {
	long getDelay(TimeUnit unit);
}
```
Java 7增加了一个 `TransferQueue` 接口，允许生产者线程等待，直到消费者准备就绪、能接收一个元素。如果生产者调用 `q.transfer(item);` ，这个调用会阻塞，直到另一个线程将元素（`item`）删除。`LinkedTransferQueue` 类实现了这个接口。

程序 `blockingQueue/BlockingQueueTest.java` 展示了如何使用阻塞队列来控制一组线程。程序在「一个目录及它的所有子目录下」搜索所有文件，打印出包含指定关键字的行。

生产者线程枚举「所有子目录下的所有文件」、并把它们放到一个阻塞队列中。这个操作很快，如果队列没有上限的话，很快就会包含所有找到的文件。我们同时启动了大量搜索线程，每个搜索线程从队列中取出一个文件、打开它、打印所有包含该关键字的行，然后取出下一个文件。==我们使用一个小技巧，在工作结束后终止这个应用程序——为了发出完成信号，枚举线程会在队列中放置一个虚拟对象==（这就像在行李输送带上放一个写着“最后一个包”的虚拟包）。当搜索线程取到这个虚拟对象时，将其放回并终止该搜索线程。

注意，**这里不需要显式的线程同步**。在这个应用程序中，我们使用队列数据结构作为一种同步机制。
```java
// blockingQueue/BlockingQueueTest.java
package blockingQueue;

import java.io.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class BlockingQueueTest {
	private static final int FILE_QUEUE_SIZE = 10;
	private static final int SEARCH_THREADS = 100;
	private static final Path DUMMY = Path.of("");
	private static BlockingQueue<Path> queue = new ArrayBlockingQueue<>(FILE_QUEUE_SIZE);

	public static void main(String[] args) {
		try (var in = new Scanner(System.in)) {
			System.out.print("Enter base directory (e.g. /opt/jdk-9-src): ");
			String directory = in.nextLine();
			System.out.print("Enter keyword (e.g. volatile): ");
			String keyword = in.nextLine();

			Runnable enumerator = () -> { // producer
				try {
					enumerate(Path.of(directory));
					queue.put(DUMMY); // dummy node
				} catch (IOException e) {
					e.printStackTrace();
				} catch (InterruptedException e) {
				}
			};
			new Thread(enumerator).start();

			for (int i = 1; i <= SEARCH_THREADS; ++i) {
				Runnable searcher = () -> { // consumers
					try {
						var done = false;
						while (!done) {
							Path file = queue.take();
							if (file == DUMMY) {
								queue.put(file);
								done = true;
							} else search(file, keyword);
						}
					} catch (IOException e) {
						e.printStackTrace();
					} catch (InterruptedException e) {
					
					}
				};
				new Thread(searcher).start();
			}
		}
	}
	
	/**
	 * Recursively enumerates all files in a given directory and its subdirectories.
	 * @param directory the directory in which to start
	 */
	public static void enumerate(Path directory) throws IOException, InterruptedException {
		try (Stream<Path> children = Files.list(directory)) {
			for (Path child : children.collect(Collectors.toList())) {
				if (Files.isDirectory(child)) enumerate(child);
				else queue.put(child);
			}
		}
	}

	/**
	 * Searches a file for a given keyword and prints all matching lines.
	 * @param file the file to search
	 * @param keyword the keyword to search for
	 */
	public static void search(Path file, String keyword) throws IOException {
		try (var in = new Scanner(file, StandardCharsets.UTF_8)) {
			int lineNumber = 0;
			while (in.hasNextLine()) {
				++lineNumber;
				String line = in.nextLine();
				if (line.contains(keyword))
					System.out.printf("%s:%d:%s%n", file, lineNumber, line);
			}
		}
	}
}
```
输入 `./src/blockingQueue` ，结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211102342516.png)

> [API] `java.util.concurrent.ArrayBlockingQueue<E>` 5.0
> - `ArrayBlockingQueue(int capacity)`
> - `ArrayBlockingQueue(int capacity, boolean fair)`
> 构造一个带有指定容量和公平性设置的阻塞队列。该队列用循环数组实现。

> [API] `java.util.concurrent.LinkedBlockingQueue<E>` 5.0
> [API] `java.util.concurrent.LinkedBlockingDeque<E>` 6
> - `LinkedBlockingQueue()`
> - `LinkedBlockingDeque()`
> 构造一个无上限的阻塞队列或双向队列，用链表实现。
> - `LinkedBlockingQueue(int capacity)`
> - `LinkedBlockingDeque(int capacity)`
> 根据指定容量构建一个有限的阻塞队列或双向队列，用链表实现。

> [API] `java.util.concurrent.DelayQueue<E extends Delayed>` 5.0
> - `DelayQueue()`
> 构造一个包含 `Delayed` 元素的无上限阻塞队列。只有那些延迟已超时的元素可以从队列中移出。

> [API] `java.util.concurrent.Delayed` 5.0
> - `long getDelay(TimeUnit unit)`
> 得到该对象的延迟，用给定的时间单位进行度量。

> [API] `java.util.concurrent.PriorityBlockingQueue<E>` 5.0
> - `PriorityBlockingQueue()`
> - `PriorityBlockingQueue(int initialCapacity)`
> - `PriorityBlockingQueue(int initialCapacity, Comparator<? super E> comparator)`
> 构造一个无边界阻塞优先队列，用堆实现。优先队列的初始容量默认值是11。`comparator` 是用来对元素进行比较的比较器，如果没有指定比较器，则元素必须实现 `Comparable` 接口。

> [API] `java.util.concurrent.BlockingQueue<E>` 5.0
> - `void put(E element)`
> 添加元素，在必要时阻塞。
> - `E take()`
> 移除并返回头元素，必要时阻塞。
> - `boolean offer(E element, long time, TimeUnit unit)`
> 添加给定的元素，如果成功返回 `true` ，必要时阻塞，直至元素已经被添加或超时。
> - `E poll(long time, TimeUnit unit)`
> 移除并返回头元素，必要时阻塞，直至元素可用或超时。失败时返回 `null` 。

> [API] `java.util.concurrent.BlockingDeque<E>` 6
> - `void putFirst(E element)`
> - `void putLast(E element)`
> 添加元素，必要时阻塞。
> - `E takeFirst()`
> - `E takeLast()`
> 移除并返回头元素或尾元素，必要时阻塞。
> - `boolean offerFirst(E element, long time, TimeUnit unit)`
> - `boolean offerLast(E element, long time, TimeUnit unit)`
> 添加给定的元素，成功时返回 `true` ，必要时阻塞，直至元素被添加或超时。
> - `E pollFirst(long time, TimeUnit unit)`
> - `E pollLast(long time, TimeUnit unit)`
> 移动并返回头元素或尾元素，必要时阻塞，直至元素可用或超时。失败时返回 `null` 。

 > [API] `java.util.concurrent.TransferQueue<E>` 7
 > - `void transfer(E element)`
 > - `boolean tryTransfer(E element, long time, TimeUnit unit)`
 > 传输一个值，或者尝试在给定的超时时间内传输这个值，**这个调用将阻塞，直到另一个线程将元素删除**。第二个方法会在调用成功时返回 `true` 。

## 12.5.2 高效的映射、集和队列
`java.util.concurrent` 包提供了映射、有序集和队列的高效实现：`ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, ConcurrentLinkedQueue` 。这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分尽可能减少竞争 *contention* 。与大多数集合不同，**这些类的 `size` 方法不一定在常量时间内完成操作**。确定这些集合的当前大小通常需要遍历。
> 注释：有些应用使用庞大的 *humongous* 并发散列映射，这些映射太过庞大，以至于无法用 `size` 方法得到它的大小，因为这个方法只能返回 `int` 。对于一个包含超过20亿条目的映射该如何处理？Java 8引入了一个 `mappingCount` 方法，可以把大小作为 `long` 返回。

集合返回**弱一致性迭代器** *weakly consistent iterators* 。这意味着**迭代器不一定能反映出它们被构造之后的所有修改** *all modifications that are made after they were constructed*，但它们不会将同一个值返回两次，也不会拋出 `ConcurrentModificationException` 异常。
> 注释：与之形成对照的是，对于 `java.util` 包中的集合，如果集合在迭代器构造之后发生改变，`java.util` 包中的迭代器将抛出一个 `ConcurrentModificationException` 异常。

并发散列映射表可高效支持大量读者和一定数量的写者。默认情况下可以有多达16个写者线程同时执行。当然，可以有更多的写者线程，但如果同一时间多于16个，其他线程将暂时被阻塞。可以在构造器中指定更大数目，不过通常都没有这种必要。
> 注释：散列映射将有相同散列码的所有条目放在同一个“桶”中。有些应用使用的散列函数不当，以至于所有条目最后都放在很少的桶中，这会严重降低性能。即使是一般意义上还算合理的散列函数，如 `String` 类的散列函数，也可能存在问题。例如，攻击者可能会制造大量有相同散列值的字符串，让程序速度减慢。在Java 8中，并发散列映射将桶组织为树，而不是列表，键类型实现了 `Comparable` ，从而可以保证性能为 $O(\log (n))$ 。

> [API] `java.util.concurrent.ConcurrentLinkedQueue<E>` 5.0
> - `ConcurrentLinkedQueue<E>()`
> 构造一个可以被多线程安全访问的无边界非阻塞的队列。

> [API] `java.util.concurrent.ConcurrentSkipListSet<E>` 6
> - `ConcurrentSkipListSet<E>()`
> - `ConcurrentSkipListSet<E>(Comparator<? super E> comp)`
> 构造一个可以被多线程安全访问的有序集。第一个构造器要求元素实现 `Comparable` 接口。

> [API] `java.util.concurrent.ConcurrentHashMap<K, V>` 5.0
> [API] `java.util.concurrent.ConcurrentSkipListMap<K, V>` 6
> - `ConcurrentHashMap<K, V>()`
> - `ConcurrentHashMap<K, V>(int initialCapacity)`
> - `ConcurrentHashMap<K, V>(int initialCapacity, float loadFactor, int concurrencyLevel)`
> 构造一个可以被多线程安全访问的散列映射表。集合的初始容量默认为16。如果每一个桶的平均负载超过装载因子，表的大小会被重新调整。默认值为0.75。`concurrencyLevel` 是并发写者线程的估计数目。
> - `ConcurrentSkipListMap<K, V>()`
> - `ConcurrentSkipListSet<K, V>(Comparator<? super K> comp)`
> 构造一个可以被多线程安全访问的有序映像表。第一个构造器要求键实现 `Comparable` 接口。

## 12.5.3 映射条目的原子更新
`ConcurrentHashMap` 原来的版本只有为数不多的方法可以实现原子更新，这使得编程多少有些麻烦。假设我们希望统计观察到的某些特性的频度。作为一个简单的例子，假设多个线程会遇到单词，我们想统计它们的频率。

可以使用 `ConcurrentHashMap<String, Long>` 吗？考虑让计数自增的代码。显然，下面的代码不是线程安全的，可能会有另一个线程在同时更新同一个计数：
```java
Long oldValue = map.get(word);
Long newValue = oldValue == null ? 1 : oldValue + 1;
map.put(word, newValue); // ERROR--might not replace
```
> 注释：有些程序员很奇怪**为什么原本线程安全的数据结构会允许非线程安全的操作**。有两种完全不同的情况。如果多个线程修改一个普通的 `HashMap` ，它们会破坏内部结构 （一个链表数组）。有些链接可能丢失，或者甚至会构成循环，使得这个数据结构不再可用。对于 `ConcurrentHashMap` 绝对不会发生这种情况。在上面的例子中，`get` 和 `put` 代码不会破坏数据结构。不过，由于操作序列不是原子的，所以结果不可预知。

**在旧版本的Java中，必须使用 `replace` 操作**，它会以原子方式用一个新值替换原值，前提是之前没有其他线程把原值替换为其他值。必须一直这么做，直到 `replace` 成功：
```java
do {
	oldValue = map.get(word);
	newValue = oldValue == null ? 1 : oldValue + 1;
} while (!map.replace(word, oldValue, newValue));
```
或者可以用一个 `ConcurrentHashMap<String, AtomicLong>` ，或者在Java 8中还可以用 `ConcurrentHashMap<String, LongAdder>` 。更新代码如下，第一个语句确保有一个 `LongAdder` 可以完成原子自增：
```java
map.putIfAbsent(word, new LongAdder());
map.get(word).increment();
//
map.putIfAbsent(word, new AtomicLong());
map.get(word).incrementAndGet();
```
由于 `putIfAbsent` 返回映射的的值（可能是原来的值，或者是新设置的值)，所以可以组合这两个语句：
```java
map.putIfAbsent(word, new LongAdder()).increment();
```
不过这会为每个自增构造一个新的 `AtomicLong/LongAdder` ，而不管是否需要。如今，**Java提供了一些更方便地完成原子更新的方法**。调用 `compute` 方法时可以提供一个键和一个计算新值的函数。这个函数接收键和相关联的值（如果没有值则为 `null` ），它会计算新值。例如，可以如下更新一个整数计数器的映射：
```java
map.compute(word, (k, v) -> v == null ? 1 : v + 1);
```
> 注释：**`ConcurrentHashMap` 中不允许有 `null` 值**。有很多方法都使用 `null` 值来指示映射中某个给定的键不存在。

另外还有 `computeIfPresent` 和 `computeIfAbsent` 方法，它们分别只在已有原值/没有原值的情况下计算新值。可以如下更新一个 `LongAdder` 计数器映射：
```java
map.computeIfAbsent(word, k -> new LongAdder()).increment();
```
这与之前看到的 `putIfAbsent` 调用几乎是一样的，不过 `LongAdder` 构造器只在**确实需要一个新的计数器**时才会调用。

首次增加一个键时，通常需要做些特殊的处理。利用 `merge` 方法能非常方便地做到这一点。这个方法有一个参数，表示键不存在时使用的初始值。否则就会调用你提供的函数来结合原值与初始值（与 `compute` 不同，这个函数不处理键）。
```java
map.merge(word, 1L, (existingValue, newValue) -> existingValue + newValue);
```
或者，更简单地可以写为（再不能比这更简洁了）：
```java
map.merge(word, 1L, Long::sum);
```
> 注释：如果「传入 `compute` 或 `merge` 的函数」返回 `null` ，将从映射中删除现有的条目。
> 
> 警告：使用 `compute` 或 `merge` 时，要记住提供的函数不能做太多工作。**这个函数运行时，可能会阻塞对映射的其他更新**。当然，这个函数也不能更新映射的其他部分。

`concurrentHashMap/CHMDemo.java` 使用了一个并发散列映射，统计一个目录树的Java文件中的所有单词。
```java
// concurrentHashMap/CHMDemo.java
package concurrentHashMap;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

/**
 * This program demonstrates concurrent hash maps.
 */
public class CHMDemo {
	public static ConcurrentHashMap<String, Long> map = new ConcurrentHashMap<>();

	/**
	 * Adds all words in the given file to the concurrent hash map.
	 * @param file a file
	 */
	public static void process(Path file) {
		try (var in = new Scanner(file)) {
			while (in.hasNext()) {
				String word = in.next();
				map.merge(word, 1L, Long::sum);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Returns all descendants of a given directory
	 * @param rootDir the root directory
	 * @return a set of all descendants of the root directory
	 */
	public static Set<Path> descendants(Path rootDir) throws IOException {
		try (Stream<Path> entries = Files.walk(rootDir)) {
			return entries.collect(Collectors.toSet());
		}
	}

	public static void main(String[] args) 
		throws InterruptedException, ExecutionException, IOException {
		int processors = Runtime.getRuntime().availableProcessors(); // processors number
		ExecutorService executor = Executors.newFixedThreadPool(processors);
		Path pathToRoot = Path.of(".");
		for (Path p : descendants(pathToRoot)) {
			if (p.getFileName().toString().endsWith(".java")) 
				executor.execute(() -> process(p));
		}
		executor.shutdown();
		executor.awaitTermination(10, TimeUnit.MINUTES);
		map.forEach((k, v) -> {
			if (v >= 10)
				System.out.println(k + " occurs " + v + " times");
		});
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211102345544.png)

## 12.5.4 对并发散列映射的批操作
Java API为并发散列映射提供了批操作 *bulk operation* ，即使有其他线程在处理映射，这些操作也能安全地执行。批操作会遍历映射，处理遍历过程中找到的元素。这里不用冻结当前映射的快照 *No effort is made to freeze a snapshot of the map in time* 。除非你恰好知道一个批操作运行时映射不会被修改，否则就要把结果看作是映射状态的一个近似 *treat its result as an approximation of the map’s state* 。

有3种不同的操作：
- 搜索 `search` ：为每个键或值应用一个函数，**直到函数生成一个非 `null` 的结果**。然后搜索终止，返回这个函数的结果。
- 归约 `reduce` ：组合所有键或值，这里要使用所提供的一个累加函数。
- `forEach` ：为所有键或值应用一个函数。

每个操作都有4个版本：
- `operationKeys` ：处理键。
- `operationValues` ：处理值。
- `operation` ：处理键和值。
- `operationEntries` ：处理 `Map.Entry` 对象。

对于上述各个操作，需要指定一个参数化阈值 `parallelism threshold` 。**如果映射包含的元素多于这个阈值，就会并行完成批操作**。如果希望批操作在一个线程中运行，可以使用阈值 `Long.MAX_VALUE` 。如果希望用尽可能多的线程运行批操作，可以使用阈值1。

下面首先来看 `search` 方法。有以下版本：
```java
U searchKeys(long threshold, BiFunction<? super K, ? extends U> f)
U searchValues(long threshold, BiFunction<? super V, ? extends U> f)
U search(long threshold, BiFunction<? super K, ? super V, ? extends U> f)
U searchEntries(long threshold, BiFunction<Map.Entry<K, V>, ? extends U> f)
```
例如，假设我们希望找出第一个出现次数超过1000次的单词。需要搜索键和值，下面的 `result` 会设置为第一个匹配的单词，如果搜索函数对所有输入都返回 `null` ，则返回 `null` ：
```java
String result = map.search(threshold, (k, v) -> v > 1000 ? k ：null);
```

**`forEach` 方法有两种形式**。第一个只为各个映射条目应用一个**消费者函数** *consumer function* ，例如：
```java
map.forEach(threshold,
	(k, v) -> System.out.println(k + " -> " + v));
```
第二种形式还有一个额外的**转换器函数** *transformer function* 作为参数，要先应用这个函数，其结果会传递到消费者：
```java
map.forEach(threshold,
	(k, v) -> k + " -> " + v, // transformer
	System.out::println); // consumer
```
**转换器能被作为一个过滤器。只要转换器返回 `null` ，这个值就会被悄无声息地跳过**。例如，下面只打印有大值的条目：
```java
map.forEach(threshold,
	(k, v) -> v > 1000 ? k + " -> " + v : null, // filter and transformer
	System.out::println); // the nulls are not passed to the consumer
```

**`reduce` 操作用一个累加函数组合其输入**。例如，可以如下计算所有值的总和：
```java
Long sum = map.reduceValues(threshold, Long::sum);
```
与 `forEach` 类似，也可以提供一个转换器函数。可以如下计算最长的键的长度：
```java
Integer maxlength = map.reduceKeys(threshold,
	String::length, // Transformer
	Integer::max); // Accumulator
```
**转换器可以作为一个过滤器，通过返回 `null` 来排除不想要的输入**。在这里，我们要统计多少个条目的值>1000：
```java
Long count = map.reduceValues(threshold,
	v -> v > 1000 ? 1L : null,
	Long::sum);
```
> 注释：如果映射为空，或所有条目都被过滤掉，`reduce` 操作就会返回 `null` 。如果只有一个元素，则返回其转换结果，不会应用累加器 *accumulator* 。

对于 `int, long, double` 输出，还有相应的特殊化操作，分别有后缀`ToInt, ToLong, ToDouble` 。**你需要把输入转换为一个基本类型值，并指定一个默认值和一个累加器函数**。映射为空时返回默认值。
```java
long sum = map.reduceValuesToLong(threshold,
	Long::longValue, // transformer to primitive type
	0, // default value for empty map
	Long::sum); // primitive type accumulator
```
> 警告：这些特殊化操作与对象版本的操作有所不同，对于对象版本的操作，只需要考虑一个元素。这里不是返回转换得到的元素，而是要与默认值累加。因此，默认值必须是累加器的零元素 *the neutral element of the accumulator* 。

## 12.5.5 并发集视图
假设你想要的是一个大的线程安全的集、而不是映射。并没有一个`ConcurrentHashSet` 类，而且你肯定不想自己创建这样一个类。当然，可以使用 `ConcurrentHashMap`（包含“假”值 *bogus values* ），不过这会得到一个映射而不是集，而且不能应用 `Set` 接口的操作。

**静态 `newKeySet` 方法会生成一个 `Set<K>` ，这实际上是`ConcurrentHashMap<K, Boolean>` 的一个包装器**（所有映射值都为 `Boolean.TRUE` ，不过因为只是要把它用作一个集，所以并不关心具体的映射值）：
```java
Set<String> words = ConcurrentHashMap.<String>newKeySet();
```
当然，如果原来有一个映射，`keySet` 方法可以生成这个映射的键集。==这个集是可变的。如果删除这个集的元素，这个键（以及相应的值）会从映射中删除。不过，向键集增加元素没有意义，因为没有相应的值可以增加==。

Java 8为 `ConcurrentHashMap` 增加了第二个 `keySet` 方法，它包含一个默认值，为集增加元素时可以使用这个方法。如果 `"Java"` 在 words 中不存在，现在它会有一个值1：
```java
Set<String> words = map.keySet(1L);
words.add("Java");
```
## 12.5.6 写数组的拷贝
`CopyOnWriteArrayList` 和 `CopyOnWriteArraySet` 是**线程安全的集合，其中所有修改线程会建立底层数组的一个副本**。如果迭代访问集合的线程数超过更改集合的线程数，这样的安排是很有用的。

当构建一个迭代器时，它包含一个对当前数组的引用。如果数组后来被修改了，迭代器仍然引用旧数组，但集合的数组已经被替换了。因而，原来的迭代器可以访问一致的（但可能过时的）视图，而且无须任何同步开销。
## 12.5.7 并行数组算法
在Java 8中，`Arrays` 类提供了大量并行化操作。静态 `Arrays.parallelSort` 方法可以对一个基本类型值或对象的数组排序。例如，
```java
var contents = new String(Files.readAllBytes(
	Path.of("alice.txt")), StandardCharsets.UTF_8); // read file into string
String[] words = contents.split("[\\P{L}]+"); // split along nonletters
Arrays.parallelSort(words);
```
对对象排序时，可以提供一个 `Comparator` 。
```java
Arrays.parallelSort(words, Comparator.comparing(String::length));
```
对于所有方法都可以提供一个范围的边界，如：
```java
values.parallelSort(values.length / 2, values.length); // Sort the upper half
```
> 注释：乍一看，这些方法名中的 `parallel` 可能有些奇怪，因为用户不用关心排序具体怎样完成。不过，API设计者希望清楚指出排序是并行化的。这样一来，用户就会**注意避免使用有副作用的比较器**。

`parallelSetAll` 方法会用「由一个函数计算得到的值 *values that are computed from a function* 」填充一个数组。这个函数接收元素索引，然后计算相应位置上的值。显然，**并行化对下面的操作很有好处**。这个操作对于所有基本类型数组和对象数组都有相应的版本：
```java
Arrays.parallelSetAll(values, i -> i % 10);
	// fills values with 0 1 2 3 4 5 6 7 8 9 0 1 2 . . .
```

最后还有一个 `parallelPrefix` 方法，它会用「一个给定结合操作的前缀累加结果 *the accumulation of the prefix for a given associative operation* 」替换各个数组元素。这是什么意思？这里给出一个例子。考虑数组 `[1, 2, 3, 4, ...]` 和 `x` 操作。执行 `Arrays.parallelPrefix(values, (x, y) -> x * y)` 之后，数组将包含：
```java
[1, 1 x 2, 1 x 2 x 3, 1 x 2 x 3 x 4, ...]
```
可能很奇怪，不过这个计算确实可以并行化。首先结合相邻元素，如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211091051550.png)
灰值保持不变。显然，**可以在不同的数组区中并行完成这个计算**。下一步中，通过将所指示的元素与下面一个或两个位置上的元素相乘来更新这些元素：
```java
[1, 1 × 2
	, 1 × 2 × 3, 1 × 2 × 3 × 4, 5, 5 × 6, 5 × 6 × 7, 5 × 6 × 7 × 8]
```
这同样可以并行完成。$\log(n)$ 步之后，这个过程结束。如果有足够多的处理器，这会远远胜过直接的线性计算。这个算法在特殊用途硬件上很常用，使用这些硬件的用户很有创造力，会相应地调整算法来解决各种不同的问题。
## 12.5.8 较早的线程安全集合
从Java初始版本开始，`Vector` 和 `Hashtable` 类就提供了线程安全的动态数组和散列表的实现。**现在这些类被弃用了** *obsolete* ，取而代之的是 `ArrayList` 和 `HashMap` 类。不过，这些类不是线程安全的，==实际上集合库中提供了一种不同的机制。任何集合类都可以通过使用**同步包装器** *synchronization wrapper* 变成线程安全的==。结果集合的方法使用锁加以保护，提供了线程安全访问：
```java
List<E> synchArrayList = Collections.synchronizedList(new
ArrayList<E>());
Map<K, V> synchHashMap = Collections.synchronizedMap(new
HashMap<K, V>());
```
应确保，没有任何线程通过「原始的非同步方法」访问数据结构。要确保这一点，最容易的就是**确定不保存任何指向原始对象的引用**，简单地构造一个集合、并立即传递给包装器，像例子中所做的那样。

如果希望迭代访问一个集合，同时另一个线程仍有机会更改这个集合，那么仍需要使用 **“客户端”锁定**：
```java
synchronized (synchHashMap) {
	Iterator<K> iter = synchHashMap.keySet().iterator();
	while (iter.hasNext()) 
		...;
}
```
如果使用“foreach”循环，就必须使用同样的代码，因为循环使用了迭代器。注意：如果在迭代过程中别的线程修改了集合，迭代器会失效，抛出 `ConcurrentModificationException` 异常。同步仍然是需要的，因此并发的修改可以被可靠地检测出来。

通常，**最好使用 `java.util.Concurrent` 包中定义的集合，不使用同步包装器中的**。特别是，`ConcurrentHashMap` 经过了精心实现，假如多个线程访问的是不同的桶，它们都能访问 `ConcurrentHashMap` 而且不会彼此阻塞。有一个例外是经常被修改的数组列表 *One exception is an array list
that is frequently mutated* ，在那种情况下，同步的 `ArrayList` 要胜过 `CopyOnWriteArrayList` 。
> [API] `java.util.Collections` 1.2
> - `static <E> Collection<E> synchronizedCollection(Collection<E> c)`
> - `static <E> List synchronizedList(List<E> c)`
> - `static <E> Set synchronizedSet(Set<E> c)`
> - `static <E> SortedSet synchronizedSortedSet(SortedSet<E> c)`
> - `static <K, V> Map<K, V> synchronizedMap(Map<K, V> c)`
> - `static <K, V> SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> c)`
> 构建集合视图，该集合的方法是同步的。

---
# 12.6 任务和线程池
构造一个新的线程开销有些大，因为这涉及到与操作系统的交互。==如果程序中创建了大量的生命期很短的线程，那么不应该把每个任务映射到一个单独的线程，而应该使用**线程池**== `thread pool` 。一个线程池中包含许多准备运行的线程。**为线程池提供一个 `Runnable` ，就会有一个线程调用 `run` 方法**。当 `run` 方法退出时，这个线程不会死亡，而是留在池中、准备为下一个请求提供服务。

另一个使用线程池的理由是**减少并发线程的数目**。创建大量线程会大大降低性能、甚至使虚拟机崩溃。如果有一个会创建许多线程的算法，应该使用一个线程数“固定的”线程池、以限制并发线程的总数。

下面了解Java并发框架为协调并发任务提供的一些工具。
## 12.6.1 `Callable` 与 `Future`
`Runnable` 封装一个异步运行的任务，可以把它想象为一个没有参数和返回值的异步方法。**`Callable` 与 `Runnable` 类似，但有返回值。接口`Callable` 是一个参数化类型，只有一个方法 `call`** ，类型参数是返回值的类型。例如，`Callable<Integer>` 表示一个最终返回 `Integer` 对象的异步计算。
```java
public interface Callable<V> {
	V call() throws Exception;
}
```
**一个 `Future` 保存异步计算的结果**。可以启动一个计算，将 `Future` 对象交给某个线程，然后忘掉它。**在结果计算好之后，`Future` 对象的所有者就可以获得它**。`Future<V>` 接口具有下面的方法：
```java
V get()
V get(long timeout, TimeUnit unit)
void cancel(boolean mayInterrupt)
boolean isCancelled()
boolean isDone()
```
- 第一个 `get` 方法的调用被阻塞，直到计算完成。第二个 `get` 方法也会阻塞，不过如果在计算完成之前，第二个方法的调用超时，则拋出一个 `TimeoutException` 异常。如果运行该计算的线程被中断，两个方法都将拋出 `InterruptedException` 。如果计算已经完成，那么 `get` 方法立即返回。
- 如果计算还在进行，`isDone` 方法返回 `false` ；如果完成了，则返回 `true` 。
- 可以用 `cancel` 方法取消该计算。如果计算还没有开始，它被取消且不再开始；如果计算处于运行之中，那么如果 `mayInterrupt` 参数为 `true` ，它就被中断。
> 警告：取消一个任务涉及两个步骤。**底层线程必须被定位并中断** *located and interrupted* 。另外，**任务实现（在 `call` 方法中）必须感知到中断，并放弃它的工作**。如果一个 `Future` 对象不知道任务在哪个线程中执行，或者如果任务没有监视「执行该任务的线程的中断状态」，那么取消任务没有任何效果。

`FutureTask` 包装器是一种非常便利的机制，**执行 `Callable` 的一种方法是使用 `FutureTask` ，它同时实现了 `Future` 和 `Runnable` 的接口**。例如：
```java
Callable<Integer> task = ...;
var futureTask = new FutureTask<Integer>(task);
var t = new Thread(futureTask); // it's a Runnable
t.start();
...
Integer result = futureTask.get(); // it's a Future
```
**更常见的情况是**，将一个 `Callable` 传递给一个执行器 `executor` 。下一节介绍。

程序 `future/FutureTest.java` 使用了这些概念。这个程序与前面那个「寻找包含指定关键字的文件」的例子相似。然而现在，我们只计算匹配的文件数目。因此，我们有了一个需要长时间运行的任务，它产生一个整数值，一个 `Callable<Integer>` 的例子。
```java
class MatchCounter implements Callable<Integer> {
	public MatchCounter(File directory, String keyword) { ... }
	public Integer call() { ... } // returns the number of matching files
}
```
然后我们利用 `MatchCounter` 创建一个 `FutureTask` 对象，并用来启动一个线程。
```java
FutureTask<Integer> task = new FutureTask<Integer>(counter);
Thread t = new Thread(task);
t.start();
```
最后，我们打印结果。当然，对 `get` 的调用会发生阻塞，直到有可获得的结果为止：
```java
System.out.println(task.get() + " matching files.");
```
在 `call` 方法内部，使用相同的递归机制。对于每一个子目录，我们产生一个新的 `MatchCounter` 并为它启动一个线程。此外，把 `FutureTask` 对象隐藏在 `ArrayList<Future<Integer>>` 中（why?）。最后，把所有结果加起来：
```java
for (Future<Integer> result ：results)
	count += result.get();
```
每一次对 `get` 的调用都会发生阻塞直到结果可获得为止。当然，线程是并行运行的，因此，很可能在大致相同的时刻所有的结果都可获得。
```java
// future/FutureTest.java
package future;

import java.io.*;
import java.util.*;
import java.util.concurrent.*;

public class FutureTest {
	public static void main(String[] args) {
		try (Scanner in = new Scanner(System.in)) {
			System.out.print("Enter base directory (e.g. /opt/jdk-9-src): ");
			String directory = in.nextLine();
			System.out.print("Enter keyword (e.g. volatile): ");
			String keyword = in.nextLine();

			MatchCounter counter = new MatchCounter(new File(directory), keyword);
			FutureTask<Integer> task = new FutureTask<>(counter);
			Thread t = new Thread(task);
			t.start();
			try {
				System.out.println(task.get() + " matching files.");
			} catch (ExecutionException e) {
				e.printStackTrace();
			} catch (InterruptedException e) {
			
			}
		}
	}
}

/**
 * This task counts the files in a directory and its subdirectories that contain a given keyword
 */
class MatchCounter implements Callable<Integer> {
	private File directory;
	private String keyword;

	/**
	 * Constructs a MatchCounter
	 * @param director the directory in which to start the search
	 * @param keyword the keyword to look for
	 */
	public MatchCounter(File directory, String keyword) {
		this.directory = directory;
		this.keyword = keyword;
	}

	public Integer call() {
		int count = 0;
		try {
			File[] files = directory.listFiles();
			List<Future<Integer>> results = new ArrayList<>();

			for (File file : files) {
				if (file.isDirectory()) {
					MatchCounter counter = new MatchCounter(file, keyword);
					FutureTask<Integer> task = new FutureTask<>(counter);
					results.add(task);
					Thread t = new Thread(task);
					t.start();
				} else {
					if (search(file)) ++count;
				}
			}

			for (Future<Integer> result : results) {
				try {
					count += result.get();
				} catch (ExecutionException e) {
					e.printStackTrace();
				}
			}
		} catch (InterruptedException e) {
		
		} 
		return count;
	}

	/**
	 * Searches a file for a given keyword
	 * @param file the file to search
	 * @return true if the keyword is contained in the file
	 */
	public boolean search(File file) {
		try {
			try (Scanner in = new Scanner(file, "UTF-8")) {
				boolean found = false;
				while (!found && in.hasNextLine()) {
					String line = in.nextLine();
					if (line.contains(keyword)) found = true;
				}
				return found;
			}
		} catch (IOException e) {
			return false;
		}
	}
}
```
运行结果如下所示：
```java
Enter base directory (e.g. /opt/jdk-9-src): ./src
Enter keyword (e.g. volatile): System
8 matching files.
```
> [API] `java.util.concurrent.Callable<V>` 5.0
> - `V call()`
> 运行一个将产生结果的任务。

> [API] `java.util.concurrent.Future<V>` 5.0
> - `V get()`
> - `V get(long time, TimeUnit unit)`
> 获取结果，这个方法会阻塞，直到结果可用、或超过指定的时间为止。如果不成功，第二个方法会拋出 `TimeoutException` 异常。
> - `boolean cancel(boolean mayInterrupt)`
> 尝试取消这一任务的运行。如果任务已经开始，并且 `mayInterrupt` 参数值为 `true` ，它就会被中断。如果成功执行了取消操作，返回 `true` 。
> - `boolean isCancelled()`
> 如果任务在完成前被取消了，则返回 `true` 。
> - `boolean isDone()`
> **如果任务结束，无论是正常结束、 中途取消或发生异常，都返回 `true`** 。

> [API] `java.util.concurrent.FutureTask<V>` 5.0
> - `FutureTask(Callable<V> task)`
> - `FutureTask(Runnable task, V result)`
> 构造一个既是 `Future<V>` 又是 `Runnable` 的对象。

## 12.6.2 执行器
执行器 `Executor` 类有许多静态工厂方法、用来构建线程池，表12-2中对这些方法进行了汇总。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211111733245.png)
下面这3个方法返回实现了 `ExecutorService` 接口的 `ThreadPoolExecutor` 类的对象。
- `newCachedThreadPool` 方法构建一个线程池，对于每个任务，如果有空闲线程可用，立即让它执行任务；如果没有可用的空闲线程，则创建一个新线程。
- `newFixedThreadPool` 方法构建一个具有固定大小的线程池。如果提交的任务数多于空闲的线程数，那么把得不到服务的任务放置到队列中。当其他任务完成以后再运行它们。
- `newSingleThreadExecutor` 是一个退化了的大小为1的线程池：由一个线程执行提交的任务，一个接着一个。

==如果线程生存期很短、或者大量时间都在阻塞，那么可以使用一个 *cached thread pool*== 。不过，如果线程工作量很大、而且并不阻塞，你肯定不希望运行太多线程。

为了得到最优的运行速度，并发线程数等于处理器内核数 *processor cores* 。这种情况下应当使用固定线程池 *fixed thread pool* ，即并发线程总数有一个上限。

单线程执行器 *single-thread executor* 对于性能分析很有帮助。如果临时用一个单线程池替换缓存或固定线程池，就能测试不使用并发的情况下、应用的运行速度会慢多少。
> 注释：Java EE提供了一个 `ManagedExecutorService` 子类，适用于Java EE环境中的并发任务。类似地，诸如Play这样的Web框架也提供了适用于该框架内任务的执行器服务 *executor services* 。 

可用下面的方法之一，将一个 `Runnable` 对象或 `Callable` 对象提交给 `ExecutorService` ：
```java
Future<?> submit(Runnable task)
Future<T> submit(Runnable task, T result)
Future<T> submit(Callable<T> task)
```
该池会在方便时尽早执行提交的任务。调用 `submit` 时，会得到一个 `Future` 对象，可用来查询该任务的状态。
- 第一个 `submit` 方法返回一个奇怪样子的 `Future<?>` 。**可以使用这样一个对象来调用 `isDone, cancel, isCancelled` 。但 `get` 方法在完成时只是简单地返回 `null`** 。
- 第二个版本的 `submit` 提交一个 `Runnable` ，并且 `Future` 的 `get` 方法在完成时返回指定的 `result` 对象。
- 第三个版本的 `submit` 提交一个 `Callable` ，并且返回的 `Future` 对象将在计算结果准备好时得到它。

使用完一个线程池时，调用 `shutdown` 。该方法启动该池的关闭序列 *initiates the shutdown sequence* 。==被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡==。另一种方法是调用 `shutdownNow` ，该池取消尚未开始的所有任务，并试图中断正在运行的线程。

下面总结了在使用连接池时应做的事：
1. 调用 `Executors` 类中静态的方法 `newCachedThreadPool` 或 `newFixedThreadPool` 。
2. 调用 `submit` 提交 `Runnable` 或 `Callable` 对象。
3. 保存好返回的 `Future` 对象，以便得到结果、或者取消任务。
4. 当不想再提交任何任务时，调用 `shutdown` 。

`ScheduledExecutorService` 接口为调度执行或重复执行任务，提供了一些方法。这是对允许使用线程池机制的 `java.util.Timer` 的泛化。`Executors` 类的 `newScheduledThreadPool, newSingleThreadScheduledExecutor` 方法返回实现 `ScheduledExecutorService` 接口的对象。可以调度 `Runnable` 或 `Callable` 在一个初始延迟后运行一次，也可以调度 `Runnable` 定期运行（见API注释）。

前面的 `future/FutureTest.java` 产生了大量的生命期很短的线程，它对每个目录产生一个线程，而程序 `threadPool/ThreadPoolTest.java` 使用了一个线程池来运行任务。出于信息方面的考虑，**这个程序打印出执行时池中最大的线程数**。但不能通过 `ExecutorService` 这个接口得到这一信息。因此，**必须将该 `pool` 对象强制转换为 `ThreadPoolExecutor` 类对象**。
```java
package threadPool;

import java.io.*;
import java.util.*;
import java.util.concurrent.*;

public class ThreadPoolTest {
	public static void main(String[] args) {
		try (Scanner in = new Scanner(System.in)) {
			System.out.print("Enter base directory (e.g. /opt/jdk-9-src): ");
			String directory = in.nextLine();
			System.out.print("Enter keyword (e.g. volatile): ");
			String keyword = in.nextLine();

			/** key point **/
			ExecutorService pool = Executors.newCachedThreadPool();
			MatchCounter counter = new MatchCounter(new File(directory), keyword, pool); // thread pool is passed into
			/** key point **/
			
			Future<Integer> result = pool.submit(counter);
			try {
				System.out.println(result.get() + " matching files.");
			} catch (ExecutionException e) {
				e.printStackTrace();
			} catch (InterruptedException e) {
			
			}
			
			pool.shutdown();
			int largestPoolSize = ((ThreadPoolExecutor) pool).getLargestPoolSize();
			System.out.println("largest pool size=" + largestPoolSize);
		}
	}
}

/**
 * This task counts the files in a directory and its subdirectories that contain a given keyword
 */
class MatchCounter implements Callable<Integer> {
	private File directory;
	private String keyword;
	private ExecutorService pool;
	private int count;

	/**
	 * Constructs a MatchCounter
	 * @param director the directory in which to start the search
	 * @param keyword the keyword to look for
	 */
	public MatchCounter(File directory, String keyword, ExecutorService pool) {
		this.directory = directory;
		this.keyword = keyword;
		this.pool = pool;
	}

	public Integer call() {
		count = 0;
		try {
			File[] files = directory.listFiles();
			List<Future<Integer>> results = new ArrayList<>();

			for (File file : files) {
				if (file.isDirectory()) {
					/** key point **/
					MatchCounter counter = new MatchCounter(file, keyword, pool);
					Future<Integer> result = pool.submit(counter); // thread in pool
					/** key point **/
					
					results.add(result);
				} else {
					if (search(file)) ++count;
				}
			}

			for (Future<Integer> result : results) {
				try {
					count += result.get();
				} catch (ExecutionException e) {
					e.printStackTrace();
				}
			}
		} catch (InterruptedException e) {
		
		} 
		return count;
	}

	/**
	 * Searches a file for a given keyword
	 * @param file the file to search
	 * @return true if the keyword is contained in the file
	 */
	public boolean search(File file) {
		try {
			try (Scanner in = new Scanner(file, "UTF-8")) {
				boolean found = false;
				while (!found && in.hasNextLine()) {
					String line = in.nextLine();
					if (line.contains(keyword)) {
						found = true;
					}
				}
				return found;
			}
		} catch (IOException e) {
			return false;
		}
	}
}
```
这时的运行结果如下所示：
```java
Enter base directory (e.g. /opt/jdk-9-src): ./src
Enter keyword (e.g. volatile): System
9 matching files.
largest pool size=11
```
> [API] `java.util.concurrent.Executors`
> - `ExecutorService newCachedThreadPool()`
> 返回一个带缓存的线程池，该池在必要的时候创建线程，在线程空闲60秒后终止线程。
> - `ExecutorService newFixedThreadPool(int threads)`
> 返回一个线程池，该池中的线程数由参数指定，用给定数目的线程执行任务。
> - `ExecutorService newSingleThreadExecutor()`
> 返回一个执行器，在一个单独的线程中依次执行各个任务
> - `ScheduledExecutorService newScheduledThreadPool(int threads)`
> 返回一个线程池，使用给定数目的线程调度任务。
> - `ScheduledExecutorService newSingleThreadScheduledExecutor()`
> 返回一个执行器，在一个单独的线程中调度任务。

> [API] `java.util.concurrent.ExecutorService` 5.0
> - `Future<T> submit(Cal1able<T> task)`
> - `Future<T> submit(Runnable task, T result)`
> - `Future<?> submit(Runnable task)`
> 提交指定的任务去执行。
> - `void shutdown()`
> 关闭服务，会先完成已经提交的任务，但不再接收新的任务。

> [API] `java.util.concurrent.ScheduledExecutorService`
> - `ScheduledFuture<V> schedule(Callable<V> task, long time, TimeUnit unit)`
> - `ScheduledFuture<?> schedule(Runnable task, long time, TimeUnit unit)`
> 调度在指定的时间后执行任务。
> - `ScheduledFuture<?> scheduleAtFixedRate(Runnable task, long initialDelay, long period, TimeUnit unit)`
> 调度在初始延迟之后，周期性地运行给定的任务，周期长度是 `period` 个单位。
> - `ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, long initialDelay, long delay, TimeUnit unit)`
> 调度在初始延迟之后，周期性地运行给定的任务，在一次调用完成和下一次调用开始之间有长度为 `delay` 个单位的延迟。

> [API] `java.util.concurrent.ThreadPoolExecutor` 5.0
> - `int getLargestPoolSize()`
> 返回在该执行器生命周期中线程池的最大尺寸。

## 12.6.3 控制任务组
已经了解了**如何使用一个执行器服务作为线程池**、以提高执行任务的效率。有时，**使用执行器有更具实际意义的原因：需要控制一组相关任务**。例如，可以在执行器中使用 `shutdownNow` 方法取消所有的任务。

**`invokeAny` 方法提交一个 `Callable` 对象集合中的所有对象，并返回某个已完成任务的结果**。我们不知道返回的究竟是哪个任务的结果，这往往是最先完成的那个任务的结果。==对于搜索问题，如果我们愿意接受任何一种答案，就可以使用这个方法==。例如，假定需要对一个大整数进行因数分解计算来解码RSA密码。可以提交很多任务，每个任务尝试对不同范围内的数来进行分解。只要其中一个任务得到了答案，计算就可以停止了。

**`invokeAll` 方法提交一个 `Callable` 对象集合中的所有对象，这个方法会阻塞、直到所有任务都完成，并返回一个 `Future` 对象列表、表示所有任务的答案**。得到计算结果后，还可以像下面这样对结果进行处理：
```java
List<Callable<T>> tasks = ...;
List<Future<T>> results = executor.invokeAll(tasks);
for (Future<T> result : results)
	processFurther(result.get());
```
在for循环中，第一个 `result.get()` 调用会阻塞，直到第一个结果可用。如果所有任务几乎同时完成，这不会有问题。不过，很有必要按计算出结果的顺序、得到这些结果。可以用 `ExecutorCompletionService` 来进行排列。

首先，用常规方式获得一个执行器。然后构建一个 `ExecutorCompletionService` ，**提交任务给这个完成服务** *completion service* 。该服务会管理 `Future` 对象的一个阻塞队列，其中包含已提交任务的执行结果（当这些结果成为可用时）。这样一来，要完成前面的计算，一个更有效的组织形式如下：
```java
var service = new ExecutorCompletionService<T>(executor);
for (Callable<T> task : tasks) service.submit(task);
for (int i = 0; i < tasks.size(); i++)
	processFurther(service.take().get());
```

程序 `executors/ExecutorDemo.java` 中展示了**如何使用 `Callable` 和执行器**。在第一个计算中，我们统计了「一个目录树中包含一个给定单词的文件的个数」。为每个文件建立了一个单独的任务：
```java
Set<Path> files = descendants(Path.of(start));
var tasks = new ArrayList<Callable<Long>>();
for (Path file : files) {
	Callable<Long> task = () -> occurrences(word, file);
	tasks.add(task);
}
```
然后把这些任务传递到一个执行器服务：
```java
ExecutorService executor = Executors.newCachedThreadPool();
List<Future<Long>> results = executor.invokeAll(tasks);
```
==为了得到组合后的统计结果，要将所有结果相加，这个工作会阻塞，直到所有结果都可用==：
```java
long total = 0;
for (Future<Long> result : results)
	total += result.get();
```
这个程序还会显示搜索过程所花费的时间。将JDK源代码解压缩并放在某个位置，然后运行这个搜索。再用一个单线程执行器替换执行器服务，再次尝试运行，看看并发计算是否更快。

在程序的第二部分，要搜索包含指定单词的第一个文件，我们使用 `invokeAny` 来并行化这个搜索。这里更要注意任务的建立 *formulating the tasks* ，一旦有任务返回，`invokeAny` 方法就会终止，所以**我们不能让搜索任务返回一个 `boolean` 来指示成功或失败**。我们不希望一个任务失败时就停止搜索。实际上，失败的任务要抛出一个 `NoSuchElementException` 异常（成功则返回 `path` ）。另外，**当一个任务成功时，其他任务就要取消（`invokeAny`），因此我们要监视中断状态**。如果底层线程被中断，搜索任务在终止之前要打印一个消息，使我们能看到其他任务确实已经取消。
```java
public static Callable<Path> searchForTask(String word, Path path) {
	return () -> {
		try (var in = new Scanner(path)) {
			while (in.hasNext()) {
				if (in.next().equals(word)) return path;
				if (Thread.currentThread().isInterrupted()) {
					System.out.println("Search in " + path + " canceled.");
					return null;
				}
			}
			throw new NoSuchElementException();
		}
	};
}
```
> 提示：读这个程序时，会发现执行器服务非常有用。==在自己的程序中，应该使用执行器服务来管理线程、而不要单个地启动线程==。

```java
package executors;

import java.io.*;
import java.nio.file.*;
import java.time.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

/**
 * This program demonstrates the Callable interface and executors
 */
public class ExecutorDemo {
	/**
	 * Counts occurrences of a given word in a file
	 * @return the number of times the word occurs in the given file
	 */
	public static long occurrences(String word, Path path) {
		try (var in = new Scanner(path)) {
			int count = 0;
			while (in.hasNext()) 
				if (in.next().equals(word)) ++count;
			return count;
		} catch (IOException e) {
			return 0;
		}
	}
	
	/**
	 * Returns all descendants of a given directory.
	 * @param rootDir the root directory
	 * @return a set of all descendants of the root directory
	 */
	public static Set<Path> descendants(Path rootDir) throws IOException {
		try (Stream<Path> entries = Files.walk(rootDir)) {
			return entries.filter(Files::isRegularFile).collect(Collectors.toSet());
		}
	}
	
	/**
	 * Yields a task that searches for a word in a file
	 * @param word the word to search
	 * @param path the file in which to search
	 * @return the search task that yields the path upon success
	 */
	public static Callable<Path> searchForTask(String word, Path path) {
		return () -> {
			try (var in = new Scanner(path)) {
				while (in.hasNext()) {
					if (in.next().equals(word)) return path;
					if (Thread.currentThread().isInterrupted()) {
						System.out.println("Search in " + path + " canceled.");
						return null;
					}
				}
			}
			throw new NoSuchElementException();
		};
	}
	
	public static void main(String[] args) 
		throws InterruptedException, ExecutionException, IOException {
		try (var in = new Scanner(System.in)) {
			System.out.print("Enter base directory (e.g. /opt/jdk-9-src): ");
			String start = in.nextLine();
			System.out.print("Enter keyword (e.g. volatile): ");
			String word = in.nextLine();
			
			Set<Path> files = descendants(Path.of(start));
			var tasks = new ArrayList<Callable<Long>>();
			for (Path file : files) {
				Callable<Long> task = () -> occurrences(word, file);
				tasks.add(task);
			}
			
			ExecutorService executor = Executors.newCachedThreadPool();
			// can use a single thread executor instead to see if multiple threads
			// speed up the search 
			// ExecutorService executor = Executors.newSingleThreadExecutor();
			
			Instant startTime = Instant.now();
			List<Future<Long>> results = executor.invokeAll(tasks);
			long total = 0;
			for (Future<Long> result : results)
				total += result.get();
			Instant endTime = Instant.now();
			System.out.println("Occurrences of " + word + ": " + total);
			System.out.println("Time elapsed: "
				+ Duration.between(startTime, endTime).toMillis() +" ms");
			
			// second part
			var searchTasks = new ArrayList<Callable<Path>>();
			for (Path file : files)
				searchTasks.add(searchForTask(word, file));
			Path found = executor.invokeAny(searchTasks);
			System.out.println(word +" occurs in: " + found);
			
			
			if (executor instanceof ThreadPoolExecutor) // the single thread executor isn't
				System.out.println("Largest pool size: " +
					((ThreadPoolExecutor) executor).getLargestPoolSize());
			executor.shutdown();
		}
	}
}
```
运行结果如下所示（只能搜索文件中前后有空格的单词）：
```java
Enter base directory (e.g. /opt/jdk-9-src): ./src
Enter keyword (e.g. volatile): return
Occurrences of return: 23
Time elapsed: 76 ms
Search in .\src\future\FutureTest.java canceled.
return occurs in: .\src\bounceThread\BallComponent.java
Largest pool size: 18
Search in .\src\threads\Bank.java canceled.
```

> [API] `java.util.concurrent.ExecutorService` 5
> - `T invokeAny(Collection<Callable<T>> tasks)`
> - `T invokeAny(Collection<Callable<T>> tasks, long timeout, TimeUnit unit)`
> 执行给定的任务，返回其中一个任务的结果。第二个方法若发生超时，抛出一个 `TimeoutException` 异常。
> - `List<Future<T>> invokeAll(Collection<Callable<T>> tasks)`
> - `List<Future<T>> invokeAll(Collection<Callable<T>> tasks, long timeout, TimeUnit unit)`
> 执行给定的任务，返回所有任务的结果。第二个方法若发生超时，拋出一个 `TimeoutException` 异常。

> [API] `java.util.concurrent.ExecutorCompletionService<V>` 5.0
> - `ExecutorCompletionService(Executor e)`
> 构建一个执行器完成服务来收集给定执行器的结果。
> - `Future<V> submit(Callable<V> task)`
> - `Future<V> submit(Runnable task, V result)`
> 提交一个任务给底层的执行器。
> - `Future<V> take()`
> 移除下一个已完成的结果，如果没有任何可用的已完成结果，则阻塞。
> - `Future<V> poll()`
> - `Future<V> poll(long time, TimeUnit unit)`
> 移除并返回下一个已完成的结果，如果没有任何已完成结果可用，则返回 `null` 。第二个方法会等待给定的时间。

## 12.6.4 `Fork-Join` 框架
**有些应用使用了大量线程，但其中大多数都是空闲的**。举例来说，一个Web服务器可能会为每个连接分别使用一个线程。另外一些应用可能对每个处理器内核分别使用一个线程，来完成计算密集型任务，如图像或视频处理。Java 7中新引入了 `fork-join` 框架，专门用来支持后一类应用。假设有一个处理任务，它可以很自然地分解为子任务，如下所示：
```java
if (problemSize < threshold)
	// solve problem directly
else {
	// break problem into subproblems
	// recursively solve each subproblem
	// combine the results
}
```
图像处理就是这样一个例子。要增强一个图像，可以变换上半部分和下部部分。如果有足够多空闲的处理器，这些操作可以并行运行（除了分解为两部分外，还需要做一些额外的工作，不过这属于技术细节，不做讨论）。

在这里讨论更简单的例子。假设想统计一个数组中有多少元素满足某个特定属性。可以将这个数组一分为二，分别对这两部分进行统计，再将结果相加。

要采用框架可用的一种方式 *a form that is usable by the framework* 完成这种递归计算，需要**提供一个扩展 `RecursiveTask<T>` 的类**（如果计算会生成一个类型为 `T` 的结果）或者**提供一个扩展 `RecursiveAction` 的类**（如果不生成任何结果）。**再覆盖 `compute` 方法来生成并调用子任务，然后合并其结果**。
```java
class Counter extends RecursiveTask<Integer> {
	...
	protected Integer compute() {
		if (to - from < THRESHOLD) {
			// solve problem directly
		} else {
			int mid = (from + to) / 2;
			var first = new Counter(values, from, mid, filter);
			var second = new Counter(values, mid, to, filter);
			invokeAll(first, second);
			return first.join() + second.join();
		}
	}
}
```
在这里，**`invokeAll` 方法接收到很多任务并阻塞，直到所有这些任务都已完成**。`join` 方法将生成结果。我们对每个子任务应用了 `join` ，并返回其总和。
> 注释：还有一个 `get` 方法可以得到当前结果，不过一般不太使用，因为它可能抛出检查型异常，而**在 `compute` 方法中不允许抛出这种异常**。

`forkJoin/ForkJoinTest.java` 给出了完整的示例代码。
```java
package forkJoin;

import java.util.concurrent.*;
import java.util.function.*;

/**
 * This program demonstrates the fork-join framework.
 */
public class ForkJoinTest {
	public static void main(String[] args) {
		final int SIZE = 10000000;
		var numbers = new double[SIZE];
		for (int i = 0; i < SIZE; ++i) numbers[i] = Math.random();
		var counter = new Counter(numbers, 0, numbers.length, x -> x > 0.5);
		var pool = new ForkJoinPool();
		pool.invoke(counter);
		System.out.println(counter.join());
	}
}

class Counter extends RecursiveTask<Integer> {
	public static final int THRESHOLD = 1000;
	private double[] values;
	private int from;
	private int to;
	private DoublePredicate filter;
	
	public Counter(double[] values, int from, int to, DoublePredicate filter) {
		this.values = values;
		this.from = from;
		this.to = to;
		this.filter = filter;
	}
	
	protected Integer compute() {
		if (to - from < THRESHOLD) {
			int count = 0;
			for (int i = from; i < to; ++i)
				if (filter.test(values[i])) ++count;
			return count;
		} else {
			int mid = (from + to) / 2;
			var first = new Counter(values, from, mid, filter);
			var second = new Counter(values, mid, to, filter);
//			invokeAll(first, second);
//			return first.join() + second.join();
			first.fork();
			return second.compute() + first.join();
		}
	}
}
```

在后台，`fork-join` 框架使用了一种有效的智能方法 *heuristic* 来平衡可用线程的工作负载 *balancing the workload among available threads* ，这种方法称为**工作密取** `work stealing` 。每个工作线程都有一个双端队列 `deque` 来完成任务。一个工作线程将子任务压入它自己双端队列的队头（只有一个线程可以访问队头，所以不需要加锁）。当一个工作线程空闲时，它会从另一个双端队列的队尾“密取” *steals* 一个任务。由于大的子任务都在队尾，这种密取很少出现 *Since large subtasks are at the tail, such stealing is rare*（？）。
> 注释：`fork-join` 池是针对非阻塞工作负载 *nonblocking workloads* 优化的。如果向一个 `fork-join` 池增加很多阻塞任务，会让它无法有效工作，可以让任务实现 `ForkJoinPool.ManagedBlocker` 接口来解决这个问题，不过这是一种高级技术，这里不作讨论。

---
# 12.7 异步计算
到目前为止，我们的并发计算方法都是先分解一个任务，然后等待，直到所有部分都已完成。不过等待并不总是个好主意，接下来几节中，了解**如何实现无等待或异步的计算**。

## 12.7.1 可完成 `Future`
当用一个 `Future` 对象时，需要调用 `get` 来获得值，这个方法会阻塞，直到值可用。Java 8的 `CompletableFuture` 类实现了 `Future` 接口，提供了获得结果的另一种机制。**我们要注册一个回调，一旦结果可用，就会（在某个线程中）利用该结果调用这个回调**。通过这种方式，无需阻塞就可以在结果可用时对结果进行处理。
```java
CompletableFuture<String> f = ...;
f.thenAccept(s -> Process the result string s);
```
有些API方法会返回一个 `CompletableFuture` 对象。例如，可以用试验性的 `HttpClient` 类异步地获取一个网页（卷II第4章）。
```java
HttpClient client = HttpClient.newHttpClient();
HttpRequest request = 
    HttpRequest.newBuilder(URI.create(urlString)).GET().build();
CompletableFuture<HttpResponse<String>> f = client.sendAsync(
	request, BodyHandler.asString());
```

如果有方法生成一个现成 *ready-made* 的 `CompletableFuture` 就好了。不过大多数情况下，都需要建立自己的 `CompletableFuture` 。**要想异步运行任务、并获得 `CompletableFuture` ，就不要把它（任务）直接提交给执行器服务，而应当调用静态方法 `CompletableFuture.supplyAsync`** 。如果不利用 `HttpClient` 类，可以如下读取网页：
```java
public CompletableFuture<String> readPage(URL url) {
	return CompletableFuture.supplyAsync(() -> {
		try {
			return new String(url.openStream().readAllBytes(), "UTF-8");
		} catch (IOException e) {
			throw new UncheckedIOException(e);
		}
	}, executor);
}
```
如果你省略执行器，任务会在一个默认执行器（具体是 `ForkJoinPool.commonPool()` 返回的执行器）上运行，通常可能并不希望这样做。
> 警告：注意 `supplyAsync` 方法的第一个参数是一个 `Supplier<T>` ，而不是 `Callable<T>` 。**这两个接口都描述了无参数且返回值类型为 `T` 的函数，不过 `Supplier` 函数不能抛出检查型异常**。从上面的代码可以看到，这不是一个令人鼓舞的选择。

`CompletableFuture` 可以采用两种方式完成：得到一个结果，或者有一个未捕获的异常。要处理这两种情况，可以使用 `whenComplete` 方法。**要对结果（或者如果没有就为 `null`）和异常（或者如果没有就为 `null`）调用所提供的函数**。
```java
f.whenComplete((s, t) -> {
	if (t == null) { Process the result s; }
	else { Process the Throwable t; }
});
```
`CompletableFuture` 之所以称为可完成的，是因为我们可以手动设置一个完成值 *completion value*（在其他并发库中，这样的对象称为**承诺** *promise*）。当然，**用 `supplyAsync` 创建一个 `CompletableFuture` 时，任务完成时就会隐式设置完成值**。不过，显式设置结果，可以提供更大的灵活性。例如，两个任务可以同时计算一个答案：
```java
var f = new CompletableFuture<Integer>();
executor.execute(() -> {
	int n = workHard(arg);
	f.complete(n);
});
executor.execute(() -> {
	int n = workSmart(arg);
	f.complete(n);
});
```
要对一个异常完成 `future` ，需要调用：
```java
Throwable t = ...;
f.completeExceptionally(t);
```
> 注释：可以在多个线程中，在同一个 `future` 上安全地调用 `complete` 或 `completeExceptionally` 。如果这个 `future` 已完成，这些调用没任何作用 *have no effect* 。

`isDone` 方法指出一个 `Future` 对象是否已经完成（正常完成或产生一个异常）。前面的例子中，如果结果已经由另一个方法得出，`workHard` 和 `workSmart` 方法可以使用这个信息停止工作。
> 警告：**与普通的 `Future` 不同，调用 `cancel` 方法时 `CompletableFuture` 的计算不会中断**。取消只会把这个 `Future` 对象设置为「以异常方式完成 *completed exceptionally* 」以及一个 `CancellationException` 异常。一般来说，这是有道理的，因为 `CompletableFuture` 可能没有一个线程负责它的完成 *completion* 。不过这个限制也适用于 `supplyAsych` 等方法返回的 `CompletableFuture` 实例，而这些对象原则上是可以中断的。

## 12.7.2 组合可完成 `Future`
**非阻塞调用 *nonblocking calls* 通过回调来实现**，程序员为「任务完成之后应出现的动作」注册一个回调。当然，如果下一个动作 *the next action* 也是异步的，在这个动作之后的下一个动作 *the next action after that* 会在一个不同的回调中。尽管程序员会认为“先做步骤1，然后是步骤2，再完成步骤3”， 但实际上程序逻辑会分散到不同的回调中。 如果必须增加错误处理，情况会更糟糕。假设步骤2是“用户登录”。可能需要重复这个步骤，因为用户输入凭据时可能会出错。==要尝试在一组回调中实现这样一个控制流， 或者想要理解所实现的这样一组控制流， 会很有难度==。

`CompletableFuture` 提供了一种机制来解决这个问题。==可以把异步任务**组合**为一个处理管线== *composing asynchronous tasks into a processing pipeline* 。例如，假设我们希望（建立一个网络爬虫）从一个Web页面抽取所有图像。下面假设有这样一个方法：
```java
public void CompletableFuture<String> readPage(URL url)
```
Web页面可用时，这会生成这个页面的文本。如果方法：
```java
public static List<URL> getImageURLs(String page)
```
可以生成一个HTML页面中图像的URL，我们能调度它 *schedule it* ——当页面可用时调用这个方法：
```java
CompletableFuture<String> contents = readPage(url);
CompletableFuture<List<URL>> imageURLs =
	contents.thenApply(this::getImageURLs);
```
**`thenApply` 方法不会阻塞，它会返回另一个 `future`** 。第一个 `future`（这里是 `content` ）完成时，其结果会提供给 `getImageURLs` 方法，这个方法的返回值就是最终的结果（是一个 `CompletableFuture` ）。<u>由于 `thenApply` 要求作为参数的函数必须返回一个非 `Future` 的值，所以与 `thenCompose` 用途不同</u>。

**利用可完成 `future` ，可以指定你希望做什么，以及希望以什么顺序执行这些工作**。当然，这不会立即发生，不过重要的是所有代码都放在一处。

从概念上讲，`CompletableFuture` 是一个简单API，不过有很多不同方法可以用来组成可完成 `future` *for composing completable futures* 。下面先来看处理单个 `future` 的方法（如表12-3所示，**有 `void` 结果的方法，通常都在处理管线的最后使用**），对于这里所示的每个方法，还有相应的两个 `Async` 形式，没有给出，其中一种形式使用一个共享 `ForkJoinPool` ，另一种形式有一个 `Executor` 参数。在这个表中使用了简写记法来表示复杂的函数式接口，会把 `Function<? super T, U>` 写为 `T -> U` 。当然这并不是真正的Java类型。
![表12-3 为CompletableFuture\<T>对象增加一个动作](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211132046335.png)

已经见过 `thenApply` 方法。假设 `f` 是一个函数、接收类型为 `T` 的值、并返回类型为 `U` 的值。**以下调用**会返回一个 `future` ，该 `future` 在之前 `future` 的结果可用时会对这一结果应用 `f` *applies the function f to the result of future when it is available* 。第二个调用会在另一个线程中运行 `f` ：
```java
CompletableFuture<U> future.thenApply(f);
CompletableFuture<U> future.thenApplyAsync(f);
```

`thenCompose` 方法没有取函数 `T -> U` ，而是取函数 `T -> CompletableFuture<U>` 。这听上去相当抽象，不过实际上也很自然。考虑**从一个给定URL读取一个Web页面**的动作。不用提供以下方法：
```java
public String blockingReadPage(URL url)
```
更精巧的做法是让方法返回一个 `future`（这里缺一个URL）：
```java
public CompletableFuture<String> readPage(URL url)
```
现在，假设**还有一个方法可以从用户输入得到URL**，这可能从一个对话框得到，而在用户点击OK按钮之前我们不会得到答案。这也是将来的一个事件：
```java
public CompletableFuture<URL> getURLInput(String prompt)
```
这里我们有两个函数 `T -> CompletableFuture<U>` 和 `U -> CompletableFuture<V>` 。显然，**如果第二个函数在第一个函数完成时调用，它们就可以组合为一个函数 `T -> CompletableFuture<V>`。这正是 `thenCompose` 所做的**。

上一节中我们已经了解 `whenComplete` 方法用于处理异常。还有一个 `handle` 方法，它需要一个函数处理结果或异常，并计算一个新结果。很多情况下，更简单的做法是调用 `exceptionally` 方法。出现一个异常时，这个方法会计算一个假值 *dummy value*：
```java
CompletableFuture<List<URL>> imageURLs = readPage(url)
	.exceptionally(ex -> "<html></html>")
	.thenApply(this::getImageURLs);
```
可以用同样的方式处理超时：
```java
CompletableFuture<List<URL>> imageURLs = readPage(url)
	.completeOnTimeout("<html></html>", 30, TimeUnit.SECONDS)
	.thenApply(this::getImageURLs);
```
或者也可以在超时时抛出一个异常：
```java
CompletableFuture<String> = readPage(url).orTimeout(30, TimeUnit.SECONDS)
```

下面看组合多个 `future`的方法（表12-4）。
![表12-4 组合多个对象](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211132131216.png)

前3个方法并发运行一个 `CompletableFuture<T>` 和一个 `CompletableFuture<U>` 动作，并组合结果。接下来3个方法并发运行两个 `CompletableFuture<T>` 动作。一旦其中一个动作完成，就传递它的结果，并忽略另一个结果。

最后的静态 `allOf, anyOf` 方法取一组可完成 `future`（数目可变），并生成一个 `CompletableFuture<Void>` ，它会在所有这些 `future` 都完成时、或其中任意一个 `future` 完成时结束。`allOf` 方法不会生成任何结果，`anyOf` 方法**不会终止**其余的任务。
> 注释：理论上讲，这一节介绍的方法接受 `CompletionStage` 类型的参数（这个接口有几乎40个抽象方法，只由 `CompletableFuture` 实现。提供这个接口是为了让第三方框架可以实现这个接口），而不是 `CompletableFuture` 。这个 `CompletionStage` 接口描述了如何组合异步计算，而 `Future` 接口强调的是计算的结果。**一个`CompletableFuture` 既是 `CompletionStage` ，也是 `Future`** 。

`completableFutures/CompletableFutureDemo.java` 会读取一个Web页面、扫描页面得到其中的图像，并保存在本地。注意，所有耗费时间的方法都返回一个 `CompletableFuture` 。为了启动异步计算，我们使用了一个小技巧。这里没有直接调用 `readPage` 方法，而是用URL参数建立了一个完成的 `future` ，然后将这个 `future` 与 `this::readPage` 组合。这样一来，**这个管线看起来很统一**：
```java
CompletableFuture.completedFuture(url)
	.thenComposeAsync(this::readPage, executor)
	.thenApply(this::getImageURLs)
	.thenCompose(this::getImages)
	.thenAccept(this::saveImages);
```
```java
// completableFutures/CompletableFutureDemo.java
package completableFutures;

import java.awt.image.*;
import java.io.*;
import java.net.*;
import java.nio.charset.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.regex.*;

import javax.imageio.*;

public class CompletableFutureDemo {
	private static final Pattern IMG_PATTERN = Pattern.compile(
		"[<]\\s*[iI][mM][gG]\\s*[^>]*[sS][rR][cC]\\s*[=]\\s*['\"]([^'\"]*)['\"][^>]*[>]");
	private ExecutorService executor = Executors.newCachedThreadPool();
	private URL urlToProcess;

	public CompletableFuture<String> readPage(URL url) {
		return CompletableFuture.supplyAsync(() -> {
		try {
	            var contents = new String(url.openStream().readAllBytes(),
	              StandardCharsets.UTF_8);
				System.out.println("Read page from " + url);
				return contents;
			} catch (IOException e) {
				throw new UncheckedIOException(e);
			}
		}, executor);
	}

	public List<URL> getImageURLs(String webpage) { // not consuming
		try {
			var result = new ArrayList<URL>();
			Matcher matcher = IMG_PATTERN.matcher(webpage);
			while (matcher.find()) {
				var url = new URL(urlToProcess, matcher.group(1));
				result.add(url);
			}
			System.out.println("Found URLs: " + result);
			return result;
		} catch (IOException e) {
			throw new UncheckedIOException(e);
		}
	}

	public CompletableFuture<List<BufferedImage>> getImages(List<URL> urls) {
		return CompletableFuture.supplyAsync(() -> {
			try {
				var result = new ArrayList<BufferedImage>();
				for (URL url : urls) {
					result.add(ImageIO.read(url));
					System.out.println("Loaded " + url);
				}
				return result;
			} catch (IOException e) {
				throw new UncheckedIOException(e);
			}
		}, executor);
	}

	public void saveImages(List<BufferedImage> images) {
		System.out.println("Saving " + images.size() + " images");
		try {
			for (int i = 0; i < images.size(); ++i) {
				String filename = "/tmp/image" + (i + 1) + ".png";
				ImageIO.write(images.get(i), "PNG", new File(filename));
			}
		} catch (IOException e) {
			throw new UncheckedIOException(e);
		}
		executor.shutdown();
	}

	public void run(URL url)
		throws IOException, InterruptedException {
		urlToProcess = url;
		CompletableFuture.completedFuture(url)
			.thenComposeAsync(this::readPage, executor) // use another thread to execute asynchronously in thread pool 
			.thenApply(this::getImageURLs)
			.thenCompose(this::getImages)
			.thenAccept(this::saveImages);
		/*
		// or use the experimental HTTP client:
		HttpClient client = HttpClient.newBuilder().	executor(executor).build();
		HttpRequest request = HttpRequest.newBuilder(urlToProcess.toURI()).GET().build();
		client.sendAsync(request, BodyProcessor.asString()).thenApply(HttpResponse::body).thenApply(this::getImageURLs).thenCompose(this::getImages).thenAccept(this::saveImages);
		 */
	}
	
	public static void main(String[] args) 
		throws IOException, InterruptedException {
		new CompletableFutureDemo().run(new URL("http://horstmann.com/index.html"));
	}
}
```
运行结果如下所示（虽然没看到图片，不知道为什么）：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211160031557.png)

---
# 12.8 同步器
`java.util.concurrent` 包包含了几个能帮助管理**相互合作的线程集**的类（下表）。这些机制具有为「线程之间的共用集结点模式 *common rendezvous patterns* 」提供的“预置功能” *canned functionality* 。如果有一个相互合作的线程集满足这些行为模式之一，那么应该直接重用合适的库类、而不要试图提供手工的锁与条件的集合。
![表 同步器](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211141451798.png)

## 12.8.1 信号量
概念上讲，==一个信号量管理许多的许可证 *permit*== 。为了通过信号量，线程通过调用 `acquire` 请求许可。==其实没有实际的许可对象，信号量仅维护一个计数。许可的数目是固定的，由此限制了通过的线程数量==。其他线程可以通过调用 `release` 释放许可。而且，许可不是必须由获取它的线程释放。事实上，任何线程都可以释放任意数目的许可，这可能会增加许可数目以至于超出初始数目。

信号量在1968年由 *Edsger Dijkstra* 发明，作为同步原语 `synchronization primitive` 。*Dijkstra*指出信号量可以被有效地实现，并且有足够的能力解决许多常见的线程同步问题。在几乎任何一本操作系统教科书中，都能看到使用信号量实现的有界队列。当然，应用程序员不必自己实现有界队列。通常，信号量不必直接映射到通用应用场景。
## 12.8.2 倒计时门栓
**一个倒计时门栓 `CountDownLatch` 让一个线程集等待直到计数变为0**。倒计时门栓是一次性的。一旦计数为0，就不能再重用了。

一个有用的特例是计数值为1的门栓，实现一个只能通过一次的门。线程在门外等候，直到另一个线程将计数器值置为0。

举例来讲，假定一个线程集需要一些初始的数据来完成工作。工作器线程被启动并在门外等候。另一个线程准备数据。当数据准备好的时候，调用 `countDown` ，所有工作器线程就可以继续运行了。

然后可以使用第二个门栓，检査什么时候所有工作器线程完成工作。用线程数初始化门栓。每个工作器线程在结束前将门栓计数减1。另一个获取工作结果的线程在门外等待，一旦所有工作器线程终止，该线程继续运行。
## 12.8.3 障栅
`CyclicBarrier` 类实现了一个集结点 `rendezvous` ，称为**障栅** *barrier* 。考虑大量线程运行在一次计算的不同部分的情形，当所有部分都准备好时，需要把结果组合在一起。==当一个线程完成了它的那部分任务后，我们让它运行到障栅处。一旦所有的线程都到达了这个障栅，障栅就撤销，线程就可以继续运行==。

下面是其细节。首先，构造一个障栅，并给出参与的线程数：
```java
CyclicBarrier barrier = new CydicBarrier(nthreads);
```
每一个线程做一些工作，完成后在障栅上调用 `await` ：
```java
public void run() {
	doWork();
	barrier.await();
}
```
`await` 方法有一个可选的超时参数：
```java
barrier.await(100, TimeUnit.MILLISECONDS);
```
**如果任何一个在障栅上等待的线程离开了障栅，那么障栅就被破坏了**（线程可能离开是因为它调用 `await` 时设置了超时，或者因为它被中断了）。在这种情况下，所有其他线程的 `await` 方法抛出 `BrokenBarrierException` 异常。那些已经在等待的线程立即终止 `await` 的调用。

可以提供一个可选的障栅动作 `barrier action` ，当所有线程到达障栅的时候就会执行这一动作。该动作可以收集那些单个线程的运行结果。
```java
Runnable barrierAction = ...;
CyclicBarrier barrier = new CyclicBarrier(nthreads, barrierAction);
```
障栅被称为是循环的 *cyclic* ，因为可以在所有等待线程被释放后被重用。在这一点上，有别于 `CountDownLatch` ，`CountDownLatch` 只能被使用一次。`Phaser` 类增加了更大的灵活性，允许改变不同阶段中参与线程的个数。

## 12.8.4 交换器
当两个线程在同一个数据缓冲区的两个实例上工作的时候，就可以使用交换器 `Exchanger` 。典型的情况是，一个线程向缓冲区填入数据，另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区。

## 12.8.5 同步队列
**同步队列是一种将生产者与消费者线程配对的机制**。当一个线程调用 `SynchronousQueue` 的 `put` 方法时，它会阻塞直到另一个线程调用 `take` 方法为止，反之亦然。与 `Exchanger` 的情况不同，数据仅仅沿一个方向传递，从生产者到消费者。

即使 `SynchronousQueue` 类实现了 `BlockingQueue` 接口，概念上讲，它依然不是一个队列。它没有包含任何元素，它的 `size` 方法总是返回0。

---
# 12.9 线程和用户界面（Swing）
在程序中使用线程的理由之一是，提高程序的响应性能。当应用程序有用户界面时，这一点尤其重要。==当程序需要做某些耗时的工作时，不能在用户界面线程完成这些工作，否则用户界面会冻结。应该启动另一个工作线程==。但必须认真考虑工作线程在做什么，令人惊讶的是Swing不是线程安全的，如果试图在多个线程中操作用户界面的元素，那么用户界面可能崩溃。

例如，当你希望用户点击一个按钮时就读取一个文件，不要这么做：
```java
var open = new JButton("Open");
open.addActionListener(event -> { 
	// BAD--long-running action is executed on UI thread
	var in = new Scanner(file);
	while (in.hasNextLine()) {
		String line = in.nextLine();
		...
	}
});
```
而应该在一个单独的线程中完成这个工作：
```java
open.addActionListener(event -> { 
	// GOOD--long-running action in separate thread
	Runnable task = () -> {
		var in = new Scanner(file);
		while (in.hasNextLine()) {
			String line = in.nextLine();
			...
		}
	};
	executor.execute(task);
});
```
关键是，**不能直接从「执行长时间运行任务的工作线程」更新用户界面**。包括Swing在内，JavaFx或Android等用户界面都不是线程安全的。**不能从多个线程操纵用户界面元素，否则它们会被破坏**。因此，我们**需要调度所有UI更新都在UI线程中执行** *schedule any UI updates to happen on the UI thread* 。实际上，JavaFx和Android会检查这一点，如果试图从UI线程以外的某个线程访问用户界面，会抛出一个异常。

实际了解这一问题，运行 `swing/SwingThreadTest.java` 测试程序。当点击Bad按钮时，**一个新的线程将启动**，它的 `run` 方法操作一个组合框，持续随机地添加值和删除值。
```java
public void run() {
	try {
		while (true) {
			int i = Math.abs(generator.nextInt());
			if (i % 2 == 0)
				combo.insertItemAt(new Integer(i), 0);
			else if (combo.getItemCount() > 0)
				combo.removeItemAt(i % combo.getItemCount());
			sleep(1);
		} 
	} catch (InterruptedException e) {}
}
```
试试看。点击Bad按钮。点击几次组合框，移动滚动条，再次点击Bad按钮，不断点击组合框。最终，你会看到一个异常报告（见下图）。
![图 控制台的异常报告](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211141917238.png)
发生了什么？当把一个元素插入组合框时，组合框将产生一个事件来更新显示。然后，显示代码开始运行，读取组合框的当前大小并准备显示这个值。但工作器线程保持运行，有时候会造成组合框中值的数目减少。显示代码认为组合框中的值比实际的数量多，于是会访问不存在的值，触发 `ArrayIndexOutOfBounds` 异常。

在显示时对组合框加锁，可以避免这种情况出现。但==Swing的设计者决定不再付出更多的努力实现Swing线程安全==，有两个原因。首先，同步需要时间，而且已经没有人想要降低Swing的速度。更重要的是，Swing小组调查了其他小组在线程安全的用户界面工具包方面的经验。他们的发现并不令人鼓舞。使用线程安全包的程序员被同步命令搞昏了头，常常编写出容易造成死锁的程序。

## 12.10.1 运行耗时的任务（两个原则）
将线程与Swing一起使用时，必须遵循两个简单的原则。
1. ==如果一个动作需要花费很长时间，在一个独立的工作器线程中做这件事，不要在事件分配线程中做==。
2. 除了事件分配线程，不要在任何线程中接触Swing组件。

制定第一条规则的理由易于理解。如果花很多时间在事件分配线程上，应用程序像“死了”一样，因为它不响应任何事件。特别是，**事件分配线程应该永远不要进行 `input/output` 调用**，这有可能会阻塞，并且**应该永远不要调用 `sleep`**（如果需要等待指定的时间，使用定时器事件）。

第二条规则在Swing编程中通常称为**单一线程规则** `single-thread rule`。后面进一步讨论。

这两条规则看起来彼此冲突。==假定要启动一个独立的线程运行一个耗时的任务。线程工作的时候，通常要更新用户界面中指示执行的进度。任务完成时，要再一次更新GUI界面。但不能从自己的线程接触Swing组件==。例如，如果要更新进度条或标签文本，不能从线程中设置它的值。

要解决这一问题，**在任何线程中，可以使用两种有效的方法、向事件队列添加任意的动作**。例如，假定想在一个线程中周期性地更新标签来表明进度，不可以从自己的线程中调用 `label.setText` ，而（在Swing中）应使用 `EventQueue` 类的 `invokeLater` 方法和 `invokeAndWait` 方法使「所调用的方法」在事件分配线程中执行。实际上，每个用户界面库都提供了一些机制，可用来调度一个 `Runnable` 在UI线程中执行。

这里应将Swing代码放置到**实现 `Runnable` 接口的类的 `run` 方法**中，然后**创建该类的一个对象，将其传递给静态的 `invokeLater` 或 `invokeAndWait` 方法**。例如，下面是如何更新标签内容的代码：
```java
EventQueue.invokeLater(()-> {
	label.setText(percentage + "56 complete");
});
```
当事件放入事件队列时，**`invokeLater` 方法立即返回，而 `run` 方法被异步执行**。而 **`invokeAndWait` 方法等待，直到 `run` 方法确实被执行过为止**。在更新进度标签时，`invokeLater` 方法更适宜。用户更希望让工作器线程更快完成工作、而不是得到更加精确的进度指示器。**这两种方法，都是在事件分配线程中执行 `run` 方法**。没有新的线程被创建。

`swing/SwingThreadTest.java` 演示了如何使用 `invokeLater` 方法安全地修改组合框的内容。如果点击Good按钮，线程插入或移除数字。但实际的修改发生在事件分配线程。
```java
// swing/SwingThreadTest.java
package swing;

import java.awt.*;
import java.util.*;

import javax.swing.*;

/**
 * This program demonstrates that a thread that runs in parallel with the event
 * dispatch thread can cause errors in Swing components.
 */
public class SwingThreadTest {
	public static void main(String[] args) {
		EventQueue.invokeLater(() -> {
			JFrame frame = new SwingThreadFrame();
			frame.setTitle("SwingThreadTest");
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}
}

/**
 * This frame has two buttons to fill a combo box from a separate thread.
 * The "Good" button uses the event queue, the "Bad" button modifies 
 * the combo box directly.
 */
class SwingThreadFrame extends JFrame {
	public SwingThreadFrame() {
		final JComboBox<Integer> combo = new JComboBox<>();
		combo.insertItemAt(Integer.MAX_VALUE, 0);
		combo.setPrototypeDisplayValue(combo.getItemAt(0));
		combo.setSelectedIndex(0);

		JPanel panel = new JPanel();
		
		JButton goodButton = new JButton("Good");
		goodButton.addActionListener(event ->
			new Thread(new GoodWorkerRunnable(combo)).start());
		panel.add(goodButton);
		
		JButton badButton = new JButton("Bad");
		badButton.addActionListener(event ->
			new Thread(new BadWorkerRunnable(combo)).start());
		panel.add(badButton);

		panel.add(combo);
		add(panel);
		pack();
	}
}

/**
 * This runnable modifies a combo box by randomly adding and removing numbers.
 * This can result in errors because the combo box methods are not synchronized
 * and both the worker thread and the event dispatch thread access the combo box.
 */
class BadWorkerRunnable implements Runnable {
	private JComboBox<Integer> combo;
	private Random generator;

	public BadWorkerRunnable(JComboBox<Integer> aCombo) {
		combo = aCombo;
		generator = new Random();
	}

	public void run() {
		try {
			while (true) {
				int i = Math.abs(generator.nextInt());
				if (i % 2 == 0)
					combo.insertItemAt(i, 0);
				else if (combo.getItemCount() > 0)
					combo.removeItemAt(i % combo.getItemCount());
				Thread.sleep(1);
			}
		} catch (InterruptedException e) {}
	}
}

/**
 * This runnable modifies a combo box by randomly adding and removing numbers.
 * In order to ensure that the combo box is not corrupted, the editing
 * operations are forwarded to the event dispatch thread.
 */
class GoodWorkerRunnable implements Runnable {
	private JComboBox<Integer> combo;
	private Random generator;

	public GoodWorkerRunnable(JComboBox<Integer> aCombo) {
		combo = aCombo;
		generator = new Random();	
	}

	public void run() {
		try {
			while (true) {
				EventQueue.invokeLater(() -> {
					int i = Math.abs(generator.nextInt());
					if (i % 2 == 0)
						combo.insertItemAt(i, 0);
					else if (combo.getItemCount() > 0)
						combo.removeItemAt(i % combo.getItemCount());
				});
				Thread.sleep(1);
			}
		} catch (InterruptedException e) {}
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211152138613.png)
点击Good按钮很久都没事，点击Bad按钮的结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211152141058.png)

> [API] `java.awt.EventQueue` 1.1
> - `static void invokeLater(Runnable runnable)` 1.2
> 在待处理的线程被处理后，让 `runnable` 对象的 `run` 方法在事件分配线程中执行。
> - `static void invokeAndWait(Runnable runnable)` 1.2
> 在待处理的线程被处理后，让 `runnable` 对象的 `run` 方法在事件分配线程中执行。该调用会阻塞，直到 `run` 方法终止。
> - `static boolean isDispatchThread()` 1.2
> 如果执行这一方法的线程是事件分配线程，返回 `true` 。

## 12.10.2 使用Swing工作线程
当用户发布一条处理过程很耗时的命令时，可能打算启动一个新的线程来完成这个工作。如同介绍的那样，线程应使用`EventQueue.invokeLater` 方法来更新用户界面。

在一个工作者线程中实现反馈很繁琐，所以每个用户界面库都提供了某种辅助类来管理有关细节，如Swing的 `SwingWorker` 、JavaFX的 `Task` 和Android的 `AsyncTask` 。==你要为长时间运行任务 *long-running task*（在一个单独的线程中运行）指定动作，还要指定进度更新 *progress updates* 以及最终的布局（这在UI线程中运行）==。不过总的来说，`SwingWorker` 类使后台任务的实现不那么繁琐。

`swingWorker/SwingWorkerTest.java` 有加载文本文件的命令、和取消加载过程的命令。应该用一个长文件来测试这个程序，例如 *The Count of Monte Cristo* 的全文。该文件在一个单独的线程中加载。在读取文件的过程中，Open菜单项被禁用，Cancel菜单项为可用（图12-6）。读取每一行后，状态栏中的行计数器会更新。读取过程完成后，Open菜单项重新变为可用，Cancel项被禁用，状态栏文本置为Done。
```java
// swingWorker/SwingWorkerTest.java
package swingWorker;

import java.awt.*;
import java.io.*;
import java.nio.charset.*;
import java.util.*;
import java.util.List;
import java.util.concurrent.*;

import javax.swing.*;

/**
 * This program demonstrates a worker thread that runs a potentially time-consuming task.
 */
public class SwingWorkerTest {
	public static void main(String[] args) throws Exception {
		EventQueue.invokeLater(() -> {
			var frame = new SwingWorkerFrame();
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}
}

/**
 * This frame has a text area to show the contents of a text file, a menu to open a file
 * and cancel the opening process, and a status line to show the file loading progress.
 */
class SwingWorkerFrame extends JFrame {
	private JFileChooser chooser;
	private JTextArea textArea;
	private JLabel statusLine;
	private JMenuItem openItem;
	private JMenuItem cancelItem;
	private SwingWorker<StringBuilder, ProgressData> textReader;

	public static final int TEXT_ROWS = 20;
	public static final int TEXT_COLUMNS = 60;

	public SwingWorkerFrame() {
		chooser = new JFileChooser();
		chooser.setCurrentDirectory(new File("."));

		textArea = new JTextArea(TEXT_ROWS, TEXT_COLUMNS);
		add(new JScrollPane(textArea));

		statusLine = new JLabel(" ");
		add(statusLine, BorderLayout.SOUTH);

		var menuBar = new JMenuBar();
		setJMenuBar(menuBar);

		var menu = new JMenu("File");
		menuBar.add(menu);

		openItem = new JMenuItem("Open");
		menu.add(openItem);
		openItem.addActionListener(event -> {
			// show file chooser dialog
			int result = chooser.showOpenDialog(null);
			// if file selected, set it as icon of the label
			if (result == JFileChooser.APPROVE_OPTION) {
				textArea.setText("");
				openItem.setEnabled(false); //
				/** key point--create a worker object **/
				textReader = new TextReader(chooser.getSelectedFile());
				textReader.execute();
				/** key point **/
				cancelItem.setEnabled(true); //
			}
		});

		cancelItem = new JMenuItem("Cancel");
		menu.add(cancelItem);
		cancelItem.setEnabled(false);
		cancelItem.addActionListener(event -> textReader.cancel(true));
		pack();
	}

	private class ProgressData {
		public int number;
		public String line;
	}

	private class TextReader extends SwingWorker<StringBuilder, ProgressData> {
		private File file;
		private StringBuilder text = new StringBuilder();

		public TextReader(File file) {
			this.file = file;
		}

		// the following method executes in the worker thread; it doesn't touch Swing component
		public StringBuilder doInBackground() throws IOException, InterruptedException {
			int lineNumber = 0;
			try (var in = new Scanner(new FileInputStream(file), StandardCharsets.UTF_8)) {
				while (in.hasNextLine()) {
					String line = in.nextLine();
					++lineNumber;
					text.append(line).append("\n");
					var data = new ProgressData();
					data.number = lineNumber;
					data.line = line;
					publish(data);
					// Thread.sleep(1); // to test cancellation; // no need to do this in programs
				}
			}
			return text;
		}
		
		// the following methods execute in the event dispatch thread
		public void process(List<ProgressData> data) {
			if (isCancelled()) return;
			var builder = new StringBuilder();
			statusLine.setText("" + data.get(data.size() - 1).number); // show progress data in gui; set text another time
			for (ProgressData d : data) 
				builder.append(d.line).append("\n");
			textArea.append(builder.toString());
		}

		public void done() {
			try {
				StringBuilder result = get(); // 
				textArea.setText(result.toString());
				statusLine.setText("Done");
			} catch (InterruptedException ex) {
			
			} catch (CancellationException ex) {
			
			} catch (ExecutionException ex) {
				statusLine.setText("" + ex.getCause());
			}

			cancelItem.setEnabled(false);
			openItem.setEnabled(true);
		}
	}
}
```
开始时如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211152218086.png)
![图12-6 在独立线程中加载文件](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202211152241893.png)

这个例子展示了后台任务的典型UI活动：
- 在每一个工作单元完成后，更新UI来显示进度。
- 整个工作完成之后，对UI做最后的更新。

`SwingWorker` 类使实现这一任务轻而易举。**覆盖 `doInBackground` 方法来完成耗时的工作，不时地调用 `publish` 来报告工作进度**，这一方法在工作器线程中执行。而 `publish` 方法会使得 **`process` 方法在事件分配线程中执行**、来处理进度数据。**当工作完成时，`done` 方法在事件分配线程中被调用、以完成UI的更新**。

无论何时，==**当你想在工作器线程 *worker thread* 中做一些工作时，构建一个新的工作器 *worker***==（每一个工作器对象只能被使用一次），**然后调用 `execute` 方法**。通常**在事件分配线程中调用 `execute` ，但没有严格的要求**。

假定工作器产生某种类型的结果；因此，`SwingWorker<T, V>` 实现 `Future<T>` 。这一结果可以通过 `Future` 接口的 `get` 方法获得。由于 `get` 方法阻塞、直到结果成为可用，因此不要在调用 `execute` 之后马上调用它。一个好主意是：只有当你知道工作完成时，再调用它是最为明智的。一般来说，可以从 `done` 方法调用 `get` （没有要求必须调用 `get` ，有时只需要处理进度数据）。

中间的进度数据、以及最终的结果，可以是任何类型。`SwingWorker` 类有这些类型作为类型参数。**`SwingWorker<T, V>` 产生类型为 `T` 的结果以及类型为 `V` 的进度数据**。

要取消正在进行的工作，使用 `Future` 接口的 `cancel` 方法。当该工作被取消的时候，`get` 方法抛出 `CancellationException` 异常。

正如前面已经提到的，工作器线程中的 `publish` 调用，会导致在事件分配线程中调用 `process` 。为了提高效率，几个 `publish` 的调用结果可以用一个 `process` 调用成批处理。`process` 方法接收一个 `List<V>` ，其中包含所有中间结果。

下面用这一机制读取文本文件。正如所看到的，`JTextArea` 相当慢。在一个长的文本文件（如 *The Count of Monte Cristo* ）中追加行会花费相当长的时间。为了向用户展示进度，要在状态行中显示读入的行数。因此，进度数据包含当前行号以及文本的当前行。将它们打包到一个普通的内部类中：
```java
private class ProgressData {
	public int number;
	public String line;
}
```
最后的结果是读入 `StringBuilder` 的文本。因此，需要一个 `SwingWorker<StringBuilder, ProcessData>` 。在 `doInBackground` 方法中，读取一个文件，每次一行。在读取每一行之后，调用
`publish` 方法发布行号和当前行的文本。
```java
@Override 
public StringBuilder doInBackground() throws IOException, InterruptedException {
	int lineNumber = 0;
	var in = new Scanner(new FileInputStream(file), StandardCharsets.UTF_8);
	while (in.hasNextLine()) {
		String line = in.nextLine();
		lineNumber++;
		text.append(line).append("\n");
		var data = new ProgressData();
		data.number = lineNumber;
		data.line = line;
		publish(data);
		Thread.sleep(1); 
		// to test cancellation; no need to do this in your programs
	}
	return text;
}
```
在读取每一行之后休眠1毫秒，以便检测取消动作、而不会太紧张，不过，你肯定不希望使用休眠减慢程序的执行速度。如果对这一行加注解，会发现 *The Count of Monte Cristo* 的加载相当快，==只有几次批量的用户界面更新== *user interface updates* 。
> 注释：从工作器线程来更新文本区可以使这个程序的处理相当顺畅，但是，对大多数Swing组件来说不可能做到这一点。这里，给出一种通用的方法，其**中所有组件的更新都出现在事件分配线程中**。

在这个 `process` 方法中，忽略除最后一行行号之外的所有行号，然后，我们把**所有的行**拼接在一起来**完成文本区的一次更新**。
```java
@Override 
public void process(List<ProgressData> data) {
	if (isCancelled()) return;
	var b = new StringBuilder();
	statusLine.setText("" + data.get(data.size() - 1).number);
	for (ProgressData d : data)
		b.append(d.line).append("\n");
	textArea.append(b.toString());
}
```
在 `done` 方法中，文本区被更新为完整的文本，并且Cancel菜单项被禁用。注意，如何在Open菜单项的事件监听器中启动工作器。

**利用这一简单的技术，就能在执行耗时任务的同时，保持用户界面的正常响应**。
> [API] `javax.swing.SwingWorker<T, V>` 6
> - `abstract T doInBackground()`
> 覆盖这一方法来执行后台任务，并返回这一工作的结果。
> - `void process(List<V> data)`
> 覆盖这一方法，在事件分配线程中处理中间进度数据 *intermediate progress data* 。
> - `void publish(V... data)`
> **传递中间进度数据到事件分配线程**。从 `doInBackground` 调用这一方法。
> - `void execute()`
> **调度此工作器在工作线程上执行** *schedules this worker for execution on a worker thread* 。
> - `SwingWorker.StateValue getState()`
> 得到这个工作器线程的状态，值为 `PENDING, STARTED, DONE` 之一。

## 12.10.3 单一线程规则
每一个Java应用程序都开始于主线程中的 `main` 方法。**在Swing程序中，`main` 方法的生命周期是很短的。它在事件分配线程中规划用户界面的构造、然后退出**。在用户界面构造后，事件分配线程会处理事件通知，例如调用 `actionPerformed` 或 `paintComponent` 。其他线程在后台运行，例如将事件放入事件队列的进程，但那些线程对应用程序员是不可见的。

前面介绍了单一线程规则：除了事件分配线程，不要在任何线程中接触Swing组件。本节进一步研究此规则。对于单一线程规则 ，存在一些例外情况。
- ==可在任一个线程里添加或移除事件监听器==。当然，==该监听器的方法会在事件分配线程中被触发==。
- 只有很少的Swing方法是线程安全的。在API文档中用这样的句子特别标明：“尽管大多数Swing方法不是线程安全的，但这个方法是。”在这些线程安全的方法中最有用的是：
	```java
	JTextComponent.setText
	JTextArea.insert
	JTextArea.append
	JTextArea.replaceRange
	JComponent.repaint
	JComponent.revalidate
	```

> 注释：多次使用 `repaint` 方法，但 `revalidate` 方法不怎么常见。这样做的目的是，在内容改变之后强制执行组件布局。传统的AWT有一个 `validate` 方法强制执行组件布局。**对于Swing组件，应该调用 `revalidate` 方法**（但是，要强制执行 `JFrame` 的布局，仍然要调用 `validate` 方法，因为 `JFrame` 是一个 `Component` 不是一个 `JComponent` 。）

历史上，单一线程规则是更加随意的。任何线程都可以构建组件，设置优先级，将它们添加到容器中，只要这些组件没有一个是已经被实现的 *realized* 。如果组件可以接收 `paint` 事件或 `validation` 事件，组件被实现。一旦调用组件的 `setVisible(true)` 或 `pack(!)` 方法、或者组件被添加到已经被实现的容器中，就会出现这样的情况。

单一线程规则的这一版本是便利的，它允许在 `main` 方法中创建GUI，然后在应用程序的顶层框架调用 `setVisible(true)` 。在事件分配线程上没有令人讨厌的 `Runnable` 的安排。

遗憾的是，一些组件的实现者没有注意原来的单一线程规则的微妙之处。他们在事件分配线程启动活动，而没有检査组件是否是被实现的。例如，如果在 `JTextComponent` 上调用`setSelectionStart` 或 `setSelectionEnd` ，在事件分配线程中安排了一个插入符号的移动，即使该组件不是可见的。

检测并定位这些问题可能会好些，但是Swing的设计者没有走这条轻松的路。他们认定==除了使用事件分配线程之外，从任何其他线程访问组件永远都是不安全的==。因此，你需要在事件分配线程构建用户界面，像程序示例中那样调用`EventQueue.invokeLater` 。

当然，有不少程序使用旧版的单一线程规则，在主线程初始化用户界面。那些程序有一定的风险，某些用户界面的初始化会引起事件分配线程的动作与主线程的动作发生冲突。不要让自己成为少数不幸的人之一，为时有时无的线程bug烦恼并花费时间。因此，**一定要遵循严谨的单一线程规则**。

---
# 12.10 进程
现在了解了如何**在同一个程序的不同线程中执行Java代码**。有时**还需要执行另一个程序**。为此，可以使用 `ProcessBuilder` 类的 `Process` 类。`Process` 类在一个单独的操作系统进程中执行一个命令，允许我们与标准输入、输出和错误流交互。`ProcessBuilder` 类则允许我们配置 `Process` 对象。
> 注释：`ProcessBuilder` 类可以取代 `Runtime.exec` 调用，且更为灵活。

## 12.10.1 建立一个进程
首先指定想要执行的命令。可以提供一个 `List<String>` ，或者直接提供命令字符串。
```java
var builder = new ProcessBuilder("gcc", "myapp.c");
```
> 警告：第一个字符串必须是一个可执行的命令，而不是一个Shell内置命令。例如，要在Windows中运行 `dir` 命令，需要提供字符串"cmd.exe"和"dir"来建立进程。

**每个进程都有一个工作目录，用来解析相对目录名**。默认情况下，进程的工作目录与虚拟机相同，通常是启动Java程序的那个目录。可以用 `directory` 方法改变工作目录：
```java
builder = builder.directory(path.toFile());
```
> 注释：**配置 `ProcessBuilder` 的各个方法都返回其自身**，所以可以把命令串起来。最终会调用：
> ```java
> Process p = new ProcessBuilder(command).directory(file).…start();
> ```

接下来，要指定如何处理进程的标准输入、输出和错误流。默认情况下它们分别是一个管道，可以用如下方法访问：
```java
OutputStream processIn = p.getOutputStream();
InputStream processOut = p.getInputStream();
InputStream processErr = p.getErrorStream();
```
注意，**进程的输入流是JVM的一个输出流**！==我们会写入这个流，而我们写的内容会成为进程的输入==。与之相反，==我们会读取进程写入输出和错误流的内容，对我们来说，它们都是输入流==。

可以指定新进程的输入、输出和错误流与JVM相同。如果用户在一个控制台运行JVM，所有用户输入都会转发到进程，而进程的输出将显示在控制台上。可以调用 `builder.redirectIO()` 为这3个流建立这个设置。如果只想继承某些流，可以把值 `ProcessBuilder.Redirect.INHERIT` 传入 `redirectInput, redirectOutput, redirectError` 方法。例如：
```java
builder.redirectOutput(ProcessBuilder.Redirect.INHERIT);
```
通过提供 `File` 对象，可以将进程流重定向到文件：
```java
builder.redirectInput(inputFile)
	.redirectOutput(outputFile)
	.redirectError(errorFile);
```
进程启动时，会创建或删除输出和错误文件。要**追加到现有的文件**，可以使用：
```java
builder.redirectOutput(ProcessBuilder.Redirect.appendTo(outputFile))
```
合并输出和错误流通常很有用，这样就能按进程生成这些消息的顺序、显示输出和错误消息。可以调用：
```java
builder.redirectErrorStream(true)
```
启用合并。如果这样做，就不能再在 `ProcessBuilder` 上调用 `redirectError` ，也不能在 `Process` 上调用 `getErrorStream` 。

可能还想修改进程的环境变量。在这里构建器的串联语法就不能用了。你需要得到 `builder` 的环境（由运行JVM的那个进程的环境变量初始化），然后加入或删除环境变量条目：
```java
Map<String, String> env = builder.environment();
env.put("LANG", "fr_FR");
env.remove("JAVA_HOME");
Process p = builder.start();
```
如果希望利用管道，将一个进程的输出作为另一个进程的输入（类似于Shell中的 `|` 操作符），Java 9提供了一个 `startPipeline` 方法，可以传入一个进程构建器列表 *a list of process builders* ，并从最后一个进程读取结果。下面给出一个例子，这里会枚举一个目录树中的各个扩展 *extensions* ：
```java
List<Process> processes = ProcessBuilder.startPipeline(List.of(
	new ProcessBuilder("find", "/opt/jdk-9"),
	new ProcessBuilder("grep", "-o", "\\.[^./]*$"),
	new ProcessBuilder("sort"),
	new ProcessBuilder("uniq")
));
Process last = processes.get(processes.size() - 1);
var result = new String(last.getInputStream().readAllBytes());
```
当然对于这个特定的任务，用Java建立目录遍历 *directory walk* 来解决、要比运行4个进程更高效。

## 12.10.2 运行一个进程
配置了构建器之后，要调用 *invoke* 它的 `start` 方法启动进程。如果把输入、输出和错误流配置为管道，现在可以写输入流，并读取输出和错误流。
```java
Process process = new ProcessBuilder("/bin/ls", "-l")
	.directory(Path.of("/tmp").toFile())
	.start();
try (var in = new Scanner(process.getInputStream())) { // JVM's input stream
	while (in.hasNextLine())
		System.out.println(in.nextLine());
}
```
> 警告：**进程流的缓冲空间是有限的**。不能写入太多输入，而且要及时读取输出。如果有大量输入和输出，可能需要在单独的线程 *separate threads* 中生产和消费这些输入输出。

要等待进程完成，可以调用：
```java
int result = process.waitFor();
```
或者，如果不想无限期等待，可以这样做：
```java
long delay = ...;
if (process.waitfor(delay, TimeUnit.SECONDS)) {
	int result = process.exitValue();
	...
} else {
	process.destroyForcibly();
}
```
上一个 `waitFor` 调用返回过程的退出值（惯例，0表示成功，或返回一个非0的错误码）。第二个调用在进程没有超时时返回 `true` ，然后需要调用 `exitValue` 方法获取退出值。

与其等待进程结束，你可能只是让它继续运行、并不时调用 `isAlive` 来查看进程是否仍存活。要杀死这个进程，可以调用 `destroy` 或 `destroyForcibly` 。这两个调用之间的区别取决于平台——UNIX上前者以 `SIGTERM` 终止进程，后者以 `SIGKILL` 终止进程（如果 `destroy` 方法可以正常终止进程，`supportsNormalTermination` 方法将返回 `true` ）。

最后，你会在进程完成时接收到一个异步通知。调用 `process.onExit()` 会得到一个 `CompletableFuture<Process>` ，可以用来调度任何动作。
```java
process.onExit().thenAccept(p -> 
	System.out.println("Exit value: " + p.exitValue())
);
```
## 12.10.3 进程句柄
要获得程序启动的一个进程的更多信息，或者更多地了解你的计算机上正在运行的任何其他进程，可以使用 `ProcessHandle` 接口。可用4种方式得到一个 `ProcessHandle` ：
1. 给定一个 `Process` 对象 `p` ，`p.toHandle()` 会生成它的 `ProcessHandle` 。
2. 给定一个 `long` 类型的操作系统进程ID，`ProcessHandle.of(id)` 可以生成这个进程的句柄。
3. `Process.current()` 是运行这个Java虚拟机的进程的句柄。
4. `ProcessHandle.allProcesses()` 可以生成对当前进程可见的所有操作系统进程的 `Stream<ProcessHandle>` 。

给定一个进程句柄，可以得到它的进程ID、父进程、子进程和后代进程：
```java
long pid = handle.pid();
Optional<ProcessHandle> parent = handle.parent();
Stream<ProcessHandle> children = handle.children();
Stream<ProcessHandle> descendants = handle.descendants();
```
> 注释：**`allProcesses, children, descendants` 方法返回的 `Stream<ProcessHandle>` 实例只是当时的快照**。流中的任何进程在你看到它们时可能已经终止了，而且可能已经启动了其他进程，而那些新启动的进程不在流中。

`info` 方法可以生成一个 `ProcessHandle.Info` 对象，它提供了一些方法来获得进程的有关信息，所有这些方法都返回 `Optional` 值，因为可能某个特定的操作系统不能报告这个信息：
```java
Optional<String[]> arguments()
Optional<String> command()
Optional<String> commandLine()
Optional<String> startInstant()
Optional<String> totalCpuDuration()
Optional<String> user()
```
要监视或强制进程终止，与 `Process` 类一样，`ProcessHandle` 接口也有 `isAlive, supportsNormalTermination, destroy, destroyForcibly, onExit` 方法，不过没有对应 `waitFor` 的方法。

> [API] `java.lang.ProcessBuilder` 5
> - `ProcessBuilder(String... command)`
> - `ProcessBuilder(List<String> command)`
> 用给定的命令和参数，构造一个进程构建器。
> - `ProcessBuilder directory(File directory)`
> 设置进程的工作目录。
> - `ProcessBuilder inheritIO()`
> 让进程使用虚拟机的标准输入、输出和错误流。
> - `ProcessBuilder redirectErrorStream(boolean redirectErrorStream)`
> 如果 `redirectErrorStream` 为 `true` ，这个进程的标准错误流会与标准输出流合并。
> - `ProcessBuilder redirectInput(File file)` 7
> - `ProcessBuilder redirectOutput(File file)` 7
> - `ProcessBuilder redirectError(File file)` 7
> 将进程的标准输入、输出和错误流重定向到给定的文件。
> - `ProcessBuilder redirectInput(ProcessBuilder.Redirect source)` 7
> - `ProcessBuilder redirectOutput(ProcessBuilder.Redirect destination)`
> - `ProcessBuilder redirectError(ProcessBuilder.Redirect destination)`
> 重定向进程的标准输入、输出和错误流，目标可以是：
> 	- `Redirect.PIPE`——默认行为，通过 `Process` 对象访问。
> 	- `Redirect.INHERIT`——虚拟机的流。
> 	- `Redirect.DISCARD`
> 	- `Redirect.from(file)`
> 	- `Redirect.to(file)`
> 	- `Redirect.appendTo(file)`
> - `Map<String,String> environment()` 
> 生成一个可更改的映射，用于为进程设置环境变量。
> - `Process start()`
> 启动进程，并生成它的 `Process` 对象。
> - `static List<Process> startPipeline(List<ProcessBuilder> builders)` 9
> 启动一个进程管线，将各个进程的标准输出连接到下一个进程的标准输入。

> [API] `java.lang.Process` 1.0
> - `abstract OutputStream getOutputStream()`
> 得到一个流，用于写「进程的输入流」。
> - `abstract InputStream getInputStream()`
> - `abstract InputStream getErrorStream()`
> 得到一个输入流，用于读取进程的输出或错误流。
> - `abstract int waitFor()`
> 等待进程完成并生成退出值。
> - `boolean waitFor(long timeout, TimeUnit unit)` 8
> 等待进程完成，不过不能超过给定的超时时间。如果进程退出，则返回 `true` 。
> - `abstract int exitValue()` 
> 返回进程的退出值。按照惯例，非0的退出值表示一个错误。
> - `boolean isAlive()`
> 检查这个进程是否仍存活。
> - `abstract void destroy()`
> - `Process destroyForcibly()` 8
> 终止这个进程，要么正常终止，要么强制终止。
> - `boolean supportsNormalTermination()` 9
> 检查这个进程是否可以正常终止，或者是否必须强制销毁。
> - `ProcessHandle toHandle()` 9
> 生成描述这个进程的 `ProcessHandle` 。
> - `CompletableFuture<Process> onExit()`
> 生成一个 `CompletableFuture` ，会在这个进程退出时执行。

> [API] `java.lang.ProcessHandle`
> - `static Optional<ProcessHandle> of(long pid)`
> - `static Stream<ProcessHandle> allProcesses()`
> - `static ProcessHandle current()`
> 生成有给定PID的进程、所有进程或虚拟机进程的进程句柄。
> - `Stream<ProcessHandle> children()`
> - `Stream<ProcessHandle> descendants()`
> 生成这个进程的子进程或后代进程的进程句柄。
> - `long pid()`
> 生成这个进程的PID。
> - `ProcessHandle.Info info()`
> 生成这个进程的详细信息。

> [API] `java.lang.ProcessHandle.Info` 9
> - `Optional<String[]> arguments()`
> - `Optional<String> command()`
> - `Optional<String> commandLine()`
> - `Optional<Instant> startInstant()`
> - `Optional<Instant> totalCpuDuration()`
> - `Optional<String> user()`
> 生成给定的详细信息（如果可用）。