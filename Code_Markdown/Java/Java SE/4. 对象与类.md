@[toc]

▲ 面向对象程序设计概述
▲ 使用预定义类
▲ 用户自定义类
▲ 静态字段与静态方法
▲ 方法参数
▲ 对象构造
▲ 包
▲ 类路径
▲ 文档注释
▲ 类设计技巧

这里主要介绍如下内容：
- 面向对象程序设计的入门知识；
- 如何创建标准Java类库中的类对象；
- 如何编写自己的类。

面向对象程序设计与面向过程程序设计在思维方式上存在着很大的差别。**改变一种思维方式并不是一件很容易的事情**，且为了继续学习Java也要清楚对象的概念。

---
# 4.1 面向对象程序设计概述
面向对象程序设计 `Object-oriented programming, or OOP for short` 是当今主流的程序设计范型，它已经取代了20世纪70年代的**结构化或过程化** `structured or procedural` 编程技术。**由于Java是面向对象的，必须熟悉OOP才能编写Java程序**。

面向对象的程序是由对象组成的，每个对象包含「对用户公开的特定功能部分」和「隐藏的实现部分」。程序中的很多对象来自标准库，还有一些是自定义的 `custom-designed` 。究竟是自己构造对象、还是从外界购买对象，完全取决于开发项目的预算和时间。但是，从根本上说，只要对象能够满足要求，就不必关心其功能的具体实现过程。

传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了这些
过程，就要开始考虑存储数据的方式。这就是Pascal语言的设计者 *Niklaus Wirth* 将其著作命名为 *Algorithms + Data Structures = Programs, Prentice Hall, 1975* 的原因。需要注意的是，在 *Wirth* 命名的书名中，算法是第一位的，数据结构是第二位的，这就明确地表述了程序员的操作方式：先要确定如何操作数据，然后再决定如何组织数据，以便于数据操作。而**OOP**却调换了这个次序，**将数据放在第一位，然后再考虑操作数据的算法**。

对于一些规模较小的问题，将其分解为过程的开发方式比较理想。而面向对象更加适用
于解决规模较大的问题。耍想实现一个简单的Web浏览器，可能需要大约 $2000$ 个过程，这些过程可能需要对一组全局数据进行操作 `all of which manipulate a set of global data` 。采用面向对象的设计风格，可能只需要大约 $100$ 个类，每个类平均包含 $20$ 个方法 （如图4-1所示）。**后者更易于程序员掌握，也容易找到bug**——假设一个特定对象的数据出错了，在访问过这个数据项的 $20$ 个方法中查找错误 `culprit` ，要比在 $2000$ 个过程中查找容易得多。
![图4-1 面向过程与面向对象的程序设计对比](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209012225560.png)

## 4.1.1 类
类 `class` 是构造对象的模板或蓝图。**由类构造 `construct` 对象的过程，称为创建类的实例 `instance`** 。正如前示，用Java编写的所有代码、都位于某个类的内部: 标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。尽管如此，还是需要在Java程序中创建一些自己的类，以便描述应用程序所对应的问题领域中的对象。

封装 `encapsulation`（有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，**封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式**。对象中的数据称为**实例字段** `instance field` , 操纵数据的过程称为**方法** `method` 。作为一个类的实例，一个特定对象会有一组特定的实例字段值，**这些值的集合就是这个对象的当前状态** `state` 。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。

实现封装的关键在于，**绝对不能让类中的方法直接地访问其他类的实例字段** `have methods never directly access instance fields in a class other than their own` 。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了“黑盒” 特征，这是提高重用性和可靠性的关键。这意味着==一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化==。

OOP的另一个基本原则 `tenet` ，会让用户自定义Java类变得轻而易举，这就是：**可以通过扩展一个类来建立另外一个新的类**。事实上，在Java中，所有的类都源自于一个“神通广大的超类”，它就是 `Object` 。所有其他类都扩展自这个 `Object` 类。有关 `Object` 类的详细介绍，见下一章。

在扩展一个已有的类时，这个扩展后的新类具有「被扩展的类的全部属性和方法」。在新类中，只需提供「适用于这个新类的新方法和数据字段」就可以了。通过扩展一个类来建立另外一个类的过程称为**继承** `inheritance` ，有关继承的详细内容参看下一章。

## 4.1.2 对象
要想使用 OOP，—定要清楚对象的三个主要特性：
- 对象的行为 `behavior` ——可以用对象施加哪些操作，或可以对对象应用哪些方法？
- 对象的状态  `state` ——当调用 `invoke` 那些方法时，对象如何响应？
- 对象的标识 `identity` ——如何区分具有相同行为与状态的不同对象？

同一个类的所有对象实例，由于支持相同的行为、而具有家族式的相似性 `a family resemblance` 。**一个对象的行为是用可调用的方法定义的** `The behavior of an object is defined by the methods that you can call` 。

其次，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会
随着时间而发生改变，但这种改变不会是自发的 `not spontaneously` 。**对象状态的改变必须通过调用方法实现** `A change in the state of an object must be a consequence of method calls`（如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏）。

但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的标识 `identity` 。例如，在一个订单处理系统中，任何两个订单都存在着不同之处，即使所订购的货物完全相同也是如此。需要注意，==作为同一个类的实例，每个对象的标识总是不同的，状态也常常存在着差异==。

**对象的这些关键特性会彼此相互影响**。例如，对象的状态影响它的行为（如果一个订单“已送货”或“已付款”，就应该拒绝调用「要求增删订单中条目的方法」。反过来，如
果订单是“空的”，即还没有预订任何商品，这个订单就不应该进人“已送货”状态)。

## 4.1.3 识别类
传统的过程化程序设计中，必须从顶部的 `main` 函数开始编写程序。在面向对象程序设计时没有所谓的“顶部”。学习OOP的初学者常会感觉无从下手。答案是：**首先从识别类开始，然后再往每个类中添加方法** `Identify your classes and then add methods to each class` 。

识别类的一条简单指导规则 `a simple rule of thumb` 是，**在分析问题的过程中寻找名词，而方法对应着动词**。例如，在订单处理系统中，有这样一些名词：
- 商品 `Item`
- 订单 `Order`
- 送货地址 `Shipping address` 
- 付款 `Payment`
- 账户 `Account`
从这些名词，就可以得到类 `Item` 、`Order` 等。

接下来，查看动词：商品被添加 *added* 到订单中，订单被发送 *shipped* 或取消 *canceled* ，订单货款被支付 *applied* 。对于每一个动词如：“添加”、“发送”、“取消” 以及“支付”，都要标识出「主要负责完成相应动作的对象」。例如，当一个新的商品添加到订单中时，那个订单对象就是要负责的对象，因为它知道如何存储商品以及如何对商品进行排序。也就是说，`add` 应该是 `Order` 类的一个方法，它要取一个 `Item` 对象作为参数。

当然，这种“找名词与动词”原则只是一种经验，在创建类的时候，哪些名词和动词是重要的，只取决于个人的开发经验。

## 4.1.4 类之间的关系
在类之间，最常见的关系有
- 依赖 `Dependence "uses-a"`
- 聚合 `Aggregation "has-a"`
- 继承 `Inheritance "is-a"`

依赖即"uses-a"关系，是一种最明显的、最常见的关系。例如，`Order` 类使用 `Account` 类，是因为 `Order` 对象需要访问 `Account` 对象、来查看信用状态。但是 `Item` 类不依
赖于 `Account` 类，这是因为 `Item` 对象与客户账户无关。因此，**如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类**。

==应该尽可能地将相互依赖的类减至最少==。如果类A不知道B的存在，它就不会关心B的任何改变（这意味着B的改变不会导致A产生任何bug)。用软件工程的术语来说，就是
让类之间的耦合度最小 `minimize the coupling between classes` 。

聚合即"has-a"关系，是一种具体且易于理解的关系。例如，一个 `Order` 对象包含一些 `Item` 对象。聚合关系意味着类A的对象包含类B的对象。
> 注释：有些方法学家 `methodologists` 不喜欢 `disdain` 聚合这个概念，而更加喜欢使用“关联” `association` 这个术语。从建模的角度看，这是可以理解的。但对于程序员来说，"has-a"显得更加形象。喜欢使用聚合的另一个理由是，关联的标准符号不易区分，请参看表4-1。
![表4-1 表达类关系的UML符号](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209031541511.png)

继承即"is-a"关系，表示一个更特殊的类与一个更一般的类之间的关系。例如，一个 `RushOrder` 类继承自 `Order` 类。在具有特殊性的 `RushOrder` 类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法；而其他的方法，如添加商品、生成账单等都是从 `Order` 类继承来的。一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能（下一章详细讨论继承，其中用较多的篇幅讲述这个重要的概念）。

很多程序员采用 `UML (Unified Modeling Language)` 即统一建模语言来绘制类图，用来描
述类之间的关系。图4-2就是这样一个例子。类用矩形表示，类之间的关系用带有各种修饰
的箭头 `arrows with various adornments` 表示。表4-1给出了UML中最常见的箭头样式。
![图4-2 类图](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209031545148.png)

---
# 4.2 使用预定义类
在Java中，没有类就无法做任何事情，我们前面曾经接触过几个类。然而，**并不是所有
的类都表现出「面向对象的典型特征」**。例如，`Math` 类。在程序中，可以使用 `Math` 类的方法，如 `Math.random` ，并只需要知道方法名和参数（如果有的话)，而不必了解它的具体实现过程。这正是封装的关键所在，当然所有类都是这样。但是 `Math` 类只封装了功能，它不需要也不必隐藏数据 `it neither needs nor hides data`。由于没有数据，因此也不必担心生成对象、以及初始化它们的实例字段，因为根本没有实例字段！

下一节将会给出一个更典型的类— `Date` 类，从中可以看到如何构造对象，以及如何调
用类的方法。
## 4.2.1 对象与对象变量
**要想使用对象，就必须首先构造对象，并指定其初始状态。然后，对对象应用方法**。

在Java中，使用**构造器** `constructor` 构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。下面看一个例子。在标准Java库中包含一个 `Date` 类。它的对象将描述一个时间点，例如："December 31, 1999, 23:59:59 GMT" 。

> 注释：可能会感到奇怪——为什么用类描述时间，而不像其他语言那样用一个内置
的 `built-in` 类型？ 例如，在Visual Basic中有一个内置的 `date` 类型，程序员可以采用
 `#6/1/1995#` 格式指定日期。从表面上看 `on the surface` ，这似乎很方便，因为程序员只需要使用内置的 `date` 类型，而不必为设计类而操心。但实际上，Visual Basic这样设计的适应性如何呢？ 在有些地区日期表示为月/日/年，而另一些地区表示为日/月/年。语言设计者是否能够预见这些问题呢？如果没有处理好这类问题，语言就有可能陷入混乱，对此感到不满的程序员也会丧失使用这种语言的热情。
> 如果使用类，这些设计任务就交给了类库的设计者 `With classes, the design task is offloaded to a library designer` 。如果类设计的不完善，其他的操作员可以很容易地编写自己的类，以便增强或替代 `replace` 系统提供的类（作为这个问题的印证：Java的日期类库有些混乱，已经重新设计了两次）。

构造器的名字应该与类名相同。因此 `Date` 类的构造器名为 `Date` 。要想构造一个 `Date` 对象，需要在构造器前面加上 `new` 操作符，表达式 `new Date()` 构造了一个新对象。这个对象被初始化为当前的日期和时间。

如果需要的话，也可以将这个对象传递给一个方法：
```java
System.out.printTn(new Date());
```
或者，也可以对刚刚创建的对象应用一个方法。`Date` 类中有一个 `toString` 方法。这
个方法将返回日期的字符串描述。下面的语句可以说明，如何将 `toString` 方法应用于新构造的 `Date` 对象上。
```java
String s = new Date().toString();
```
在这两个例子中，构造的对象仅使用了一次。通常，希望构造的对象可以多次使用，因
此，需要将对象存放在一个变量中：
```java
Date birthday = new Date();
```
图4-3显示了对象变量 `birthday` ，它引用了 `refers to` 新构造的对象。
![图4-3 创建一个新对象](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209031612698.png)

在对象与对象变量之间存在着一个重要的区别。例如，语句
```java
Date deadline; // deadline doesn't refer to any object
```
定义了一个对象变量 `deadline` ，它可以引用 `Date` 类型的对象。但是，一定要认识到：**变量 `deadline` 不是一个对象，实际上也没有引用对象**。此时，我们还不能在这个变量上，使用任何 `Date` 方法。语句
```java
s = deadline.toString(); // not yet
```
将产生编译错误。

必须首先初始化变量 `deadline` , 这里有两个选择。当然，可以用新构造的对象初始化这个变量：
```java
deadline = new Date();
```
也让这个变量引用一个已存在的对象：
```java
deadline = birthday;
```
现在，这两个变量引用同一个对象（参见图4-4)。
![图4-4 引用同一个对象的对象变量](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209031618790.png)

一定要认识到：**一个对象变量并没有实际包含一个对象，而仅仅引用一个对象** `it only refers to an object` 。

==在Java中，任何对象变量的值都是对「存储在另一个地方的一个对象」的引用==。`new` 操作符的返回值也是一个引用。下列语句有两个部分。表达式 `new Date()` 构造了一个 `Date` 类型的对象，并且它的值是对新创建对象的引用。这个引用存储在变量 `deadline` 中。
```java
Date deadline = new Date();
```
可以显式地将对象变量设置为 `null` ，表明这个对象变量目前没有引用任何对象。
```java
deadline = null;
...
if (deadline != null)
	System.out.println(deadline);
```
如果将一个方法应用于一个值为 `null` 的对象上，那么就会产生运行时错误。
```java
birthday = null;
String s = birthday.toString(); // runtime error!
```
**局部变量不会自动地初始化为 `null` ，而必须通过调用 `new` 或将它们设置为 `null` 进行初始化**。
> C++注释：很多人错误地认为，Java对象变量与C++的引用类似。然而，在C++中没有空引用（ `NULL` 不是引用），并且引用不能被赋值。可以将Java的对象变量看作C++的对象指针。例如，`Date birthday; // Java` 实际上等同于 `Date* birthday; // C++` 。
> 
> 一旦理解了这一点，一切问题就迎刃而解了 `everything falls into place` 。当然，一个 `Date*` 指针只能通过调用 `new` 进行初始化。就这一点而言，C++与Java的语法几乎是一样的：
>  ```cpp
>  Date* birthday = new Date(); // C++
>  ```
> 如果把一个变量的值賦给另一个变量，两个变量就指向同一个日期，即它们是同一个对象的指针。在Java中的 `null` 引用对应C++中的 `NULL` 指针。
> 
> **所有的Java对象都存储在堆中** `All Java objects live on the heap` 。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。
> 
> 在C++中，指针十分令人头疼，并常常导致程序错误。稍不小心就会创建一个错误的指针，或者造成内存溢出。在Java语言中，这些问题都不复存在。如果使用一个没有初始化的指针，运行系统将会产生一个运行时错误，而不是生成一个随机的结果，同时，不必担心内存管理问题，垃圾收集器将会处理相关的事宜。
> 
> **C++确实做了很大的努力，它通过支持复制构造器和赋值运算符来实现对象的自动拷贝**。例如，一个链表 `linked list` 拷贝的结果将会得到一个新链表，其内容与原始链表相同，但却是一组独立的链接。这样一来，就可以相应地设计类，使它们与内置类型具有相同的拷贝行为。在Java中，则必须使用 `clone` 方法获得对象的完整拷贝 „

## 4.2.2 Java类库中的 `LocalDate` 类
在前面的例子中，已经使用了Java标准类库中的 `Date` 类。`Date` 类的实例有一个状态，
即特定的时间点。尽管在使用 `Date` 类时不必知道这一点，但**时间是用距离一个固定时间点的毫秒数（可正可负）表示的**，这个点就是所谓的纪元 `epoch` ，它是UTC时间1970年1月1日00:00:00。UTC是 *Coordinated Universal Time* 的缩写，与大家更熟悉的GMT ( 即 *Greenwich Mean Time* ，格林威治时间）一样，是一种具有实践意义的科学时间标准。

但是结果表明，`Date` 类对于「处理人类记录日期的日历信息」并不是很有用。Java 类库的设计者认为： 像"December 31, 1999, 23:59:59"这种特定的日期表示法，只是阳历的固有习惯。这种特定的日期描述，遵循了世界上大多数地区使用的Gregorian阳历。但是，同一时间点采用中国的农历表示和采用希伯来的阴历表示就很不一样，对于火星历来说就更不可想象了。
> 注释：有史以来，人类的文明与历法的设计紧紧地相连 `Throughout human history, civilizations grappled with the design of calendars` ，日历给日期命名、给太阳和月亮的周期排列次序。有关世界上各种日历的有趣解释，从法国革命的日历到玛雅人 `Mayan` 计算曰期的方法等，参看 *Calendrical Calculations by Nachum Dershowitz and Edward M. Reingold (Cambridge University Press, 3rd ed., 2007)* 。

类库设计者决定**将保存时间与给时间点命名分开** `separate the concerns of keeping time and attaching names to points in time` 。所以标准Java类库分别包含了两个类：
一个是用来表示时间点的 `Date` 类；另一个是用来表示大家熟悉的日历表示法的 `LocalDate` 类。Java SE 8则引入了另外一些类、来处理日期和时间的不同方面一有关内容参见卷II第6章。

**将时间与日历分开是一种很好的面向对象设计** `Separating time measurement from calendars is good object-oriented design` 。通常，最好使用不同的类表示不同的概念。

我们不使用构造器来构造 `LocalDate` 类的对象。实际上，应当使用静态工厂方法 `factory method` ，它会代表你调用构造器。表达式 `LocalDate.now()` 会构造一个新对象，表示构造这个对象时的日期。

可以提供年、月和日来构造对应一个特定日期的对象：
```java
LocalDate.of(1999, 12, 31);
```
当然，通常都希望将构造的对象保存在一个对象变量中：
```java
LocalDate newYearsEve = LocalDate.of(1999, 12, 31);
```
一旦有了一个 `LocalDate` 对象，可以用方法 `getYear, getMonthValue, getDayOfMonth` 
得到年、月和日：
```java
int year = newYearsEve.getYearO; // 1999
int month = newYearsEve.getMonthValueO; // 12
int day = newYearsEve.getDayOfMonth(); // 31
```
看起来这似乎没有多大的意义，因为这正是构造对象时使用的那些值。不过，有时可能
某个日期是计算得到的，然后我们希望调用这些方法来了解它的更多信息。例如，`plusDays` 方法会得到一个新的 `LocalDate` , 如果把应用这个方法的对象称为当前对象，这个新日期对象则是距当前对象指定天数的一个新日期：
```java
LocalDate aThousandDaysLater = newYearsEve.piusDays(1000):
year = aThousandDaysLater.getYear(); // 2002
month = aThousandDaysLater.getMonthValueO; // 09
day = aThousandDaysLater.getDayOfMonth(); // 26
```
`LocalDate` 类封装了实例字段来维护所设置的日期。如果不查看源代码，就不可能知道类内
部的日期表示。当然，封装的意义在于，这一点并不重要，重要的是类对外提供的方法。
> 注意： 实际上，`Date` 类还有 `getDay` 、`getMonth` 以及 `getYear` 等方法，然而并不推荐使用这些方法。当类库设计者意识到某个方法不应该存在时，就把它标记为不鼓励使用 `deprecated` 。
> 
> 类库设计者意识到应当单独提供类来处理日历 `it makes more sense to supply separate classes to deal with calendars` ，不过在此之前这些方法已经是 `Date` 类的一部分了。Java 1.1中引入较早的一组日历类时，`Date` 的方法被标为废弃不用。虽然仍然可以在程序中使用这些方法，不过如果这样做，编译时会出现警告。最好还是不要使用这些废弃不用的方法 `deprecated methods` ，因为将来的某个类库版本很有可能将它们完全删除。
> 
> JDK提供了 `jdeprscan` 工具，来检查你的代码中是否使用了Java API已经废弃的特性。有关说明参见[这里](https://docs.oracle.com/javase/9/tools/jdeprscan.html)。
# 4.2.3 更改器方法与访问器方法
再看上一节中的 `plusDays` 方法调用：
```java
LocalDate aThousandDaysLater = newYearsEve.plusDays(1000);
```
这个调用之后 `newYeareEve` 会有什么变化？ 它会改为1000天之后的日期吗？ 事实上，并没有。`plusDays` 方法会生成一个新的 `LocalDate` 对象，然后把这个新对象赋给 `aThousandDaysLater` 变量。原来的对象不做任何改动。我们说 `plusDays` 方法没有更改调用这个方法的对象（这类似于见过的 `String` 类的 `toUpperCase` 方法。在一个字符串上调用 `toUpperCase` 时，这个字符串仍保持不变，会返回一个将字符大写的新字符串）。

Java库的一个较早版本曾经有另一个类来处理日历，名为 `GregorianCalendar` 。可以如下
为这个类表示的一个日期增加1000天：
```java
CregorianCalendar someDay = new CregorianCalendar(1999, 11, 31);
	// Odd feature of that class: month numbers go from 0 to 11
someDay.add(Calendar.DAY_0F_M0NTH, 1000);
```
与 `LocalDate.plusDays` 方法不同，`GregorianCalendar.add` 方法是一个**更改器方法** `mutator method` 。调用这个方法后，`someDay` 对象的状态会改变。可以如下査看新状态：
```java
year = someDay.get(Calendar.YEAR); // 2002
month = someDay.get(Calendar.MONTH) + 1; // 09
day = someDay.get(Ca1endar.DAY_0F_M0NTH); // 26
```
正是因为这个原因，我们将变量命名为 `someDay` 而不是 `newYearsEve` ——调用这个更改器方法之后，它不再是新年前夜。

相反，只访问对象而不修改对象的方法有时称为**访问器方法** `accessor method` 。例如 `LocalDate.getYear` 和 `GregorianCalendar.get` 就是访问器方法。
> C++注释：在C++中，带有 `const` 后缀的方法是访问器方法；默认为更改器方法。但是，
在Java语言中，访问器方法与更改器方法在语法上没有明显的区别，

下面用一个应用 `LocalDate` 类的程序、来结束本节内容的论述。**这个程序将显示当前月的日历**，其格式如下。当前的日用一个 `*` 号标记。可以看到，这个程序需要解决「如何计算某月份的天数」以及「一个给定日期相应是星期几」。
```java
Mon Tue Wed Thu Fri Sat Sun
						  1
  2	  3	  4	  5	  6	  7   8
  9  10  11  12  13  14  15
 16  17  18  19  20  21  22
 23  24  25  26* 27  28  29
 30
	
// or 2022/9/3
Mon Tue Wed Thu Fri Sat Sun
              1   2   3*  4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30 
```
下面看一下这个程序的关键步骤。首先，构造了一个日历对象，并用当前的日期和时间
进行初始化。
```java
LocalDate date = LocalDate.now();
```
下面获得当前的月和日。
```java
int month = date.getMonthValue();
int today = date.getDayOfMonth();
```
然后，将 `date` 设置为这个月的第一天，并得到这一天为星期几。
```java
date = date.minusDays(today - 1) ; // Set to start of month
DayOfWeek weekday = date.getDayOfWeek();
int value = weekday.getValue() ; // 1 = Monday, .. . 7 = Sunday
```
变量 `weekday` 设置为 `DayOfWeek` 类型的对象。我们调用这个对象的 `getValue` 方法来得
到星期几的一个数值。这会得到一个整数，这里遵循国际惯例，即周末是一周的末尾，星期
一就返冋1，星期二返回2，依此类推。星期日则返回7。

注意，日历的第一行是缩进的 `indented` ，使得月份的第一天指向相应的星期几。下面的代码会打印表头和第一行的缩进：
```java
System.out.println("Mon Tue Wed Thu Fri Sat Sun")；
for (int i = 1; i < value; i++)
	System.out.print("    ");
```
现在我们来打印日历的主体。进入一个循环，其中 `date` 遍历一个月中的每一天。每次迭代时，打印日期值。如果 `date` 是当前日期，这个日期则用一个 `*` 标记。接下来，把 `date` 推进到下一天。**如果到达新的一周的第一天，则换行打印**：
```java
while (date.getMonthValue() == month) {
	System.out.printf("%3d", date.getDayOfMonth());
	if (date.getDayOfMonth() == today)
		System.out.print("*")；
	else
		System.out.print(" ");
	date = date.plusDays(1) ;
	if (date.getDayOfWeekQ.getValue() == 1) System.out.println();
}
```
什么时候结束呢？ 我们不知道这个月有几天，是31天、30天、29天还是28天。实际上，**只要 `date` 还在当月就要继续迭代**。 `ObjectAndClass/CalendarTest/CalendarTest.java` 给出了完整的程序。
```java
package CalendarTest;

import java.time.DayOfWeek;
import java.time.LocalDate;

public class CalendarTest {
	public static void main(String[] args) {
		LocalDate date = LocalDate.now();
		int month = date.getMonthValue();
		int today = date.getDayOfMonth();
		
		date = date.minusDays(today - 1); // set to start of month 一月的开始日期
		DayOfWeek weekday = date.getDayOfWeek(); // 该日期是星期几
		int value = weekday.getValue(); // 1 = Monday, ..., 7 = Sunday
		
		System.out.println("Mon Tue Wed Thu Fri Sat Sun");
		for (int i = 1; i < value; ++i) // 对齐该月的第一天到星期几
			System.out.print("    ");
		while (date.getMonthValue() == month) { // 该月的范围
			System.out.printf("%3d", date.getDayOfMonth());
			if (date.getDayOfMonth() == today) System.out.print("*"); // 对今天打印*
			else System.out.print(" ");
			date = date.plusDays(1); // 步进一天
			if (date.getDayOfWeek().getValue() == 1) System.out.println(); // 到一周第一天则换行
		}
		if (date.getDayOfWeek().getValue() != 1) System.out.println(); // 如果不到一周的第一天则换行,否则已经换行
	}
}
```
可以看到，利用 `LocalDate` 类可以编写一个日历程序，能处理星期几、以及各月天数不同
等复杂问题。并不需要知道 `LocalDate` 类如何计算月和星期几。只需要使用这个类的接口，如 `plusDays` 和 `getDayOfWeek` 等方法。这个示例程序的重点是，向我们展示如何使用一个类的接口、来完成相当复杂的任务，而无需了解实现细节。

> `java.time.LocalDate` 8
> - `static Local Time now()`
> 构造一个表示当前日期的对象。
> - `static LocalTime of(int year, int month, int day)`
> 构造一个表示给定日期的对象。
> - `int getYear()`
> - `int getMonthValue()`
> - `int getDayOfMonth()`
> 得到当前日期的年、月和曰。
> - `DayOfWeek getDayOfWeek()`
> 得到当前日期是星期几，作为 `DayOfWeek` 类的一个实例返回。再调用 `getValue` 来得到
$1 \sim 7$ 之间的一个数，表示这是星期几，1表示星期一，7表示星期日。
> - `Local Date piusDays(int n)`
> - `LocalDate minusDays(int n)`
> 生成当前日期之后或之前 $n$ 天的日期。

---
# 4.3 用户自定义类
在第3章中，已经开始编写了一些简单的类。但是，那些类都只包含一个简单的 `main`
方法。现在开始学习如何编写「复杂应用程序所需要的各种主力类 `workhorse class` 」。通常，这些类没有 `main` 方法，却有自己的实例字段和实例方法。**要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有 `main` 方法**。
## 4.3.1 `Employee` 类
在Java中，最简单的类定义形式为：
```java
class ClassName {
	fieldi
	fieldi
	constructori
	constructori
	methodi
	methodi
}
```
下面看一个非常简单的 `Employee` 类。在编写薪金管理系统时可能会用到。
```java
class Employee {
	// instance fields
	private String name;
	private double salary;
	private LocalDate hireDay;
	// constructor
	public Employee(String n, double s, int year, int month, int day) {
		name = n;
		salary = s;
		hireDay = LocalDate.of(year, month, day);
	}
	// a method
	public String getName() {
		return name;
	}
	// more methods
	...
}
```
这里将这个类的实现细节分成以下几个部分，并分別在稍后的几节中给予介绍。下面先看看
程序清单 `ObjectAndClass/EmployeeTest/EmployeeTest.java`, 这个程序显示了一个 `Employee` 类的实际使用。
```java
package EmployeeTest;

import java.time.*;

/**
 * This program tests the Employee class.
 */
public class EmployeeTest {
	public static void main(String[] args) {
		// file the staff array with three Employee objects
		Employee[] staff = new Employee[3];
		staff[0] = new Employee("Carl Cracker", 75000, 1987, 12, 15);
		staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
		staff[2] = new Employee("Tony Tester", 40000, 1990, 3, 15);
		
		// raise everyone's salary by 5%
		for (Employee e : staff)
			e.raiseSalary(5);
		
		// print out information about all Employee objects
		for (Employee e : staff)
			System.out.println("name=" + e.getName() + ", salary=" + e.getSalary() 
				+ ", hireDay=" + e.getHireDay());
	}
}

class Employee {
	private String name;
	private double salary;
	private LocalDate hireDay;
	
	public Employee(String n, double s, int year, int month, int day) {
		name = n;
		salary = s;
		hireDay = LocalDate.of(year, month, day);
	}
	
	public String getName() {
		return name;
	}
	
	public double getSalary() {
		return salary;
	}
	
	public LocalDate getHireDay() {
		return hireDay;
	}
	
	public void raiseSalary(double byPercent) {
		double raise = salary * byPercent / 100;
		salary += raise;
	}
}
```
在这个程序中，构造了一个 `Employee` 数组，并填人了三个雇员对象：
```java
Employee staff = new Employee[B];
staff[0] = new Employee("Carl Cracker", );
staff[1] = new Employee("Harry Hacker", ...);
staff[2] = new Employee("Tony Tester", ...);
```
接下来，利用 `Employee` 类的 `raiseSalary` 方法将每个雇员的薪水提高 $5\%$ ：
```java
for (Employee e : staff)
	e.raiseSalary(5);
```
最后，调用 `getName` 方法、`getSalary` 方法和 `getHireDay` 方法，将每个雇员的信息打印出来。

注意，在这个示例程序中包含两个类：`Employee` 类和带有 `public` 访问修饰符的 `EmployeeTest` 类。`EmployeeTest` 类包含了 `main` 方法，其中使用了前面介绍的代码。

源文件名是 `EmployeeTest.java` ，这是因为**文件名必须与 `public` 类的名字相匹配**。==在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类==。

接下来，当编译这段源代码的时候，编译器将在目录下创建两个类文件：`EmployeeTest.class` 和 `Employee.class` 。将程序中包含 `main` 方法的类名，提供给字节码解释器，以便启动这个程序：`java EmployeeTest` 。字节码解释器开始运行 `EmployeeTest` 类的 `main` 方法中的代码。在这段代码中，先后构造了三个新 `Employee` 对象，并显示它们的状态。

## 4.3.2 多个源文件的使用
在上个程序中，一个源文件包含了两个类。许多程序员习惯于将每一个类存在一个单独的源文件中。例如，将 `Employee` 类存放在文件 `Employee.java` 中，将 `EmployeeTest` 类存
放在文件 `EmployeeTest.java` 中。

如果喜欢这样组织文件，可以有两种编译源程序的方法。一种是使用通配符调用Java编译器：
```bash
$ javac Employee*.java
```
于是，所有与通配符匹配的源文件都将被编译成类文件。或者键人下列命令：
```bash
$ javac EmployeeTest.java
```
可能会感到惊讶，**使用第二种方式，并没有显式地编译 `Employee.java`** 。然而，当Java编译器发现 `EmployeeTest.java` 使用了 `Employee` 类时，会查找名为 `Employee.class` 的文件。如果没有找到这个文件，就会自动地搜索 `Employee.java` ，然后对它进行编译。更重要的是：**如果 `Employee.java` 版本的时间戳较已有的 `Empl0yee.dass` 文件版本新，Java编译器就会自动地重新编译这个文件**。
> 注释：如果熟悉UNIX的“make”工具（或者是Windows中的“nmake”等工具)，可以认为 Java编译器内置了“make”功能。

## 4.3.3 剖析 `Employee` 类
下面对 `Employee` 类进行剖析。首先从这个类的方法开始。通过查看源代码会发现，这
个类包含一个构造器和 $4$ 个方法：
```java
public Employee(String n, double s, int year, int month, int day)
public String getName()
public double getSalary()
public Local Date getHireDay()
public void raiseSalary(double byPercent)
```
这个类的所有方法都被标记为 `public` 。**关键字 `public` 意味着，任何类的任何方法都可以调用这些方法**（共有 $4$ 种访问级别，将在本章稍后和下一章中介绍）。

接下来需要注意，在 `Employee` 类的实例中，有三个实例字段用来存放将要操作的数据：
```java
private String name;
private double salary;
private Local Date hireDay;
```
**关键字 `private` 确保，只有 `Employee` 类自身的方法能够访问这些实例域，而其他类的方法不能够读写这些域**。
> 注释：可以用 `public` 标记实例字段，但这是一种极为不提倡的做法，`public` 數据字段允许程序中的任何方法对其进行读取和修改，这就完全破坏了封装。任何类的任何方法都可以修改 `public` 字段，从我们的经验来看，某些代码**将**利用这种存取权限，而这并不是我们所希望的。因此，这里强烈建议将实例字段标记为 `private` 。

最后注意，有两个实例字段本身就是对象：`name` 域是 `String` 类对象，`hireDay` 域是
`LocalDate` 类对象。这种情形十分常见：**类通常包括类型属于某个类类型的实例字段** `Classes will often contain instance fields of class type` 。

## 4.3.4 从构造器开始
下面先看看 `Employee` 类的构造器：
```java
public Employee(String n, double s, int year, int month, int day) {
	name = n;
	salary = s;
	LocalDate hireDay = LocalDate.of(year, month, day);
}
```
可以看到，**构造器与类同名**。在构造 `Employee` 类的对象时，构造器会运行、以便将实例字段初始化为所希望的状态。例如，当使用下面这条代码创建 `Employee` 类实例时：
```java
new Employee("]ames Bond", 100000, 1950, 1, 1)
```
将会把实例域设置为：
```java
name = "James Bond";
salary = 100000;
hireDay = LocalDate.of(1950, 1, 1); // January 1, 1950
```
构造器与其他的方法有一个重要的不同。构造器总是结合 `new` 操作符来调用，不能对一个已经存在的对象调用构造器、来达到重新设置实例字段的目的。例如，
```java
james.Employee("James Bond", 250000, 1950, 1, 1) // ERROR
```
将产生编译错误。

稍后会更加详细地介绍有关构造器的内容。现在只需记住：
- 构造器与类同名；
- 每个类可以有一个以上的构造器；
- 构造器可以有0个、1个或多个参数；
- 构造器没有返回值；
- 构造器总是伴随着 `new` 操作一起调用

> C++注释：Java构造器的工作方式与C++—样。但要记住，所有的Java对象都是在堆中构造的，构造器总是伴随着 `new` 操作符一起使用。C++程序员最易犯的错误就是忘记 `new` 操作符：
> ```java
> Employee number007("]anie5 Bond", 100000, 1950, 1, 1); // C++, not Java
> ```
> 这条语句在C++中能够正常运行，但在Java中却不行。

> 注意：**不要在构造器中定义与实例字段重名的局部变量**。例如，下面的构造器将
无法设置 `salary` 。
> ```java
> public Employee(String n, double s, . .) {
>	String name = n; // Error
>	double salary = s; // Error
> }
> ```
> 这个构造器声明了局部变量 `name` 和 `salary` 。这些变量只能在构造器内部访问。这些变量**屏蔽** `shadow` 了同名的实例字段。有些程序设计者偶尔不假思索地写出这类代码，因为他们已经习惯增加这类数据类型。这种错误很难被检查出来 `nasty error` 。因此必须注意，**在所有的方法中不要命名与实例字段同名的变量**。

## 4.3.5 用 `var` 声明局部变量
在Java 10中，如果可以从变量的初始值推导出它们的类型，那么可以用 `var` 关键字声明局部变量，而无须指定类型。例如，可以不这样声明：
```java
Employee harry = new Employee("Harry Hacker", 50000, 1989, 10, 1);
```
只需要写如下代码：
```java
var harry = new Employee("Harry Hacker", 50000, 1989, 10, 1);
```
这一点很好，因为这样可以避免重复写类型名 `Employee` 。

从现在开始，**假如无需了解任何Java API，就能从等号右边明显看出类型，在这种情况下我们都将使用 `var` 表示法**。不过我们不会对数值类型使用 `var` ，如 `int, long, double` ，这样就不用当心 `0, 0L, 0.0` 之间的区别。对Java API有了更多使用经验后，我们会更多地使用 `var` 关键字。

注意：**`var` 关键字只能用于方法中的局部变量 `local variable` 。参数和字段的类型必须声明**。
## 4.3.6 使用 `null` 引用
在4.2.1节中知道，一个对象变量包含一个对象的引用，或者包含一个特殊值 `null` 、表示没有引用任何对象。这似乎是一种处理特殊情况的便捷机制，如未知的名字或雇佣日期。不过使用 `null` 值时要非常小心。

如果对 `null` 值应用一个方法，会产生一个 `NullPointerException` 异常。这是一个严重的错误 `error` ，类似“索引越界”异常。如果程序没有捕获它们，就会终止。正常情况下，程序并不捕获这些异常，而是依赖于程序员从一开始就不要带来异常。
```java
LocalDate birthday = null;
String s = birthday.toString(); // NullPointerException
```
**定义一个类时，最好清楚地知道哪些字段可能为 `null`** 。在我们的例子中，我们不希望 `name` 或 `hireDay` 字段为 `null`（不用担心 `salary` 字段，这个字段是基本类型，所以不可能是 `null` ）。

`hireDay` 字段肯定是非 `null` 的，因为它初始化为一个新的 `LocalDate` 对象，但是 `name` 可能为 `null` ，如果调用构造器时为 `n` 提供的实参是 `null` ，`name` 就会是 `null` 。

对此有两种解决办法。**宽容型 `permissive` 方法是把 `null` 参数转换为一个适当的非 `null` 值**：
```java
if (n == null) name = "unknown"; else name = n;
```
在Java 9中，`Objects` 类提供了一个便利方法：
```java
public Employee(String n, double s, int year, int month, int day) {
	name = Objects.requireNonNullElse(n, "unknown");
	...
}
```
**严格型 `"tough love"` 方法则是干脆拒绝 `null` 参数**，如果有人用一个 `null` 名字构造了一个 `Employee` 对象，就会产生 `NullPointerException` 异常。乍看下去这种做法好像不太有用。不过这种方法有两个好处：
1. 异常报告会提供这个问题的描述。
2. 异常报告会准确地指出 `pinpoints` 问题所在的位置，否则 `NullPointerException` 异常可能在其他地方出现，而很难追溯到真正导致这个问题的这个构造器参数。
```java
public Employee(String n, double s, int year, int month, int day) {
	Objects.requireNonNull(n, "The name cannot be null");
	name = n;
	...
}
```
> 注释：如果要接受一个对象引用作为构造参数，就要问问自己：是不是真的希望接受可有可无的值 `be present or absent` 。如果不是，那么严格型方法更合适。

## 4.3.7 隐式参数与显式参数
方法用于操作对象、并存取它们的实例字段。例如，以下将「调用这个方法的对象」的 `salary` 实例字段设置为新值。：
```java
public void raiseSalary(double byPercent) {
	double raise = salary * byPercent / 100;
	salary += raise;
}
```
看看下面这个调用：
```java
number007.raiseSalary(5);
```
它的结果将 `number007.salary` 字段的值增加 $5\%$ 。具体地说，这个调用将执行下列指令：
```java
double raise = nuaber007.salary * 5 / 100;
nuiber007.salary += raise;
```
`raiseSalary` 方法有两个参数。第一个参数称为**隐式 `implicit` 参数**，是出现在方法名前的 `Employee` 类对象。第二个参数是位于方法名后面括号中的数值，这是一个**显式 `explicit` 参数**（有些人把隐式参数称为方法调用的目标或接收者）。可以看到，显式参数是明显地列在方法声明中的，例如 `double byPercent` 。隐式参数没有出现在方法声明中。

**在每一个方法中，关键字 `this` 表示隐式参数**。如果需要的话，可以用下列方式编写
`raiseSalary` 方法：
```java
public void raiseSalary(double byPercent) {
	double raise = this.salary * byPercent / 100;
	this.salary += raise;
}
```
有些程序员更偏爱这样的风格，因为**这样可以将实例字段与局部变量明显地区分开来**。

> C++注释：在C++中，通常在类的外面定义方法：
> ```cpp
> void Employee::raiseSalary(double byPercent) // C++, not Java 
> {
> }
> ```
> 如果在类的内部定义方法，这个方法将自动地成为内联 `inline` 方法
> ```cpp
> class Employee {
>     int getNameQ { return name; } // inline in C++
> }
> ```
> 在Java中，所有的方法都必须在类的内部定义，但并不表示它们是内联方法。**是否将某个方法设置为内联方法，是Java虚拟机的任务**。即时编译器 `just-in-time compiler` 会监视调用那些简洁、经常被调用、没有被重载以及可优化的方法。

## 4.3.8 封装的优点
最后，再仔细地看一下非常简单的 `getName` 方法、`getSalary` 方法和 `getHireDay` 方法。
```java
public String getName() {
	return name;
}
public double getSalary() {
	return salary;
}
public LocalDate getHireDay() {
	return hireDay;
}
```
这些都是典型的访问器方法。由于它们只返回实例字段值，因此又称为**字段访问器** `field accessors` 。将 `name, salary, hireDay` 字段标记为 `public` , 以此来取代独立的访问器方法，会不会更容易些呢？
- 然而，`name` 是一个只读字段。一旦在构造器中设置完毕，就没有任何一个办法可以对它进行修改，这样来确保 `name` 字段不会受到外界的破坏。
- 虽然 `salary` 不是只读字段，但是它只能用 `raiseSalary` 方法修改。特别是一旦这个字段值出现了错误，只要调试这个方法就可以了。如果 `salary` 字段是 `public` 的，破坏这个字段值的捣乱者有可能会出没在任何地方。

在有些时候，可能需要获得或设置实例字段的值。因此，应该提供下面三项内容：
- 私有的数据字段；
- 公有的字段访问器方法 `public field accessor method` ；
- 一个公有的字段更改器方法 `public field mutator method` 。

这样做要比提供一个简单的公有数据字段复杂些，但是却有着下列明显的好处 `there are considerable benefits` ——**首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码**。例如，如果将存储名字的字段改为：
```java
String firstName;
String lastName;
```
那么 `getName` 方法可以改为返回 `firstName + " " + 1astName` ，对于这点改变，程序的其他部分完全不可见。

当然，为了进行新旧数据表示之间的转换，访问器方法和更改器方法有可能需要做许多
工作。但是，这将为我们带来了第二点好处：**更改器方法可以执行错误检查**，然而直接对字段进行赋值、将不会进行这些处理。例如，`setSalary` 方法可以检查薪金是否小于0。
> 警告：注意**不要编写返回可变对象引用的访问器方法** `not to write accessor methods that return references to mutable objects` 。在 `Employee` 类中就违反了这个设计原则，其中的 `getHireDay` 方法返回了一个 `Date` 类对象：
> ```java
> class Employee { 
>     private Date hireDay;
>     public Date getHireDay() {
>         return hireDay; // Bad
>     }
> }
> ```
> `LocalDate` 类没有更改器方法，与之不同的是，`Date` 类有一个更改器方法 `setTime` 可以设置毫秒数。因此 **`Date` 对象是可变的**，这一点就破坏了封装性！下面这段代码：
> ```java
> Employee harry = ...; 
> Date d = harry.getHireDay();
> double tenYearsInMilliSeconds = 10 * 365.25 * 24 * 60 * 60 * 1000;
> d.setTime(d.getTime() - (long) tenYearsInMilliSeconds);
> // let's give Harry ten years of added seniority
> ```
> 其中出错的原因很微妙。`d` 和 `harry.hireDay` 引用同一个对象 （参见图4-5）。更改器方法就可以自动改变了这个雇员对象的私有状态！
 ![图4-5 返回可变数据域的引用](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209041431262.png)
> **如果需要返回一个可变对象的引用，应该首先对它进行克隆 `clone`** 。对象克隆是指「存放在另一个位置上的对象副本」。有关对象 `clone` 的详细内容将在第6章中讨论。下面是修改后的代码：
> ```java
> class Employee {
>     public Date getHireDay() {
>         return (Date) hireDay.clone(); // Ok
>     }
> }
> ```
> 这是经验 `a rule of thumb` ，**如果需要返回一个可变数据字段的副本，就应该使用 `clone`** 。

## 4.3.9 基于类的访问权限
从前面已经知道，方法可以访问所调用对象的私有数据。**一个方法可以访问所属类的所有对象的私有数据** *a method can access the private data of all objects of its class* ，这令很多人感到奇怪！例如，下面看一下用来比较两个雇员的 `equals` 方法。
```java
class Employee {
	public boolean equals(Employee other) {
		return name.equals(other.name) ;
	}
}
```
典型的调用方式是：
```java
if (harry.equals(boss)) ...
```
这个方法访问 `harry` 的私有域，这点并不会让人奇怪，然而，它还访问了 `boss` 的私有域。这是合法的，其原因是 `boss` 是 `Employee` 类对象，而 `Employee` 类的方法可以访问 `Employee` 类的任何一个对象的私有域。
> C++注释：C++也有同样的原则。**方法可以访问「所属类的任何对象」的私有特性** `feature` , 而不仅限于访问隐式参数的私有特性。

## 4.3.10 私有方法
在实现一个类时，由于公有数据非常危险，所以应该将所有的数据字段都设置为私有的。然而，方法又应该如何设计呢？ ==尽管绝大多数方法都被设计为公有的，但在某些特殊情况下，将它们设计为私有可能很有用==。有时，可能希望**将一个计算代码划分成若干个独立的辅助方法** `helper method` 。通常，这些辅助方法不应该成为公有接口的一部分，这是由于它们往往与当前的实现机制非常紧密，或者需要一个特别的协议或者调用次序。最好将这样的方法设计为 `private` 的。

在Java中，为了实现一个私有的方法，只需将关键字 `public` 改为 `private` 即可。**通过方法设为私有，如果改变了方法的实现方式，将没有义务 `no obligation` 保证这个方法依然可用**。如果数据的表达方式发生了变化，这个方法可能会变得更难实现，或者不再需要；这并不重要。重点在于，==只要方法是私有的，类的设计者就可以确信：它不会被外部的其他类操作调用，可以将其删去==。如果方法是公有的，就不能将其删去，因为其他的代码很可能依赖它。

## 4.3.11 `final` 实例字段
**可以将实例字段定义为 `final` 。这样的字段必须在构造对象时初始化**。也就是说，必须确保在每一个构造器执行之后 `after the end of every constructor` ，这个字段的值已被设置，并且以后不能再修改这个字段。例如，可以将 `Employee` 类中的 `name` 域声明为 `final` , 因为在对象构建之后，这个值不会再被修改，即没有 `setName` 方法。
```java
class Employee {
	private final String name;
	...
}
```
`final` 修饰符对于**基本 `primitive` 类型**或**不可变 `immutable` 类**的字段尤其有用（如果类中的每个方法都不会改变其对象，这种类就是不可变的类 `A class is immutable if none of its methods ever mutate its objects` 。例如，`String` 类就是一个不可变的类）。

**对于可变的类，使用 `final` 修饰符可能是令人困惑的**。例如，
```java
private final StringBuilder evaluations;
```
在 `Employee` 构造器中会初始化为：
```java
evaluations = new StringBuilder();
```
`final` 关键字只是表示，**「存储在 `evaluations` 变量中的对象引用」不会再指示其他 `StringBuilder` 对象，不过这个对象可以更改**：
```java
public void giveGoldStar() {
	evaluations.append(LocalDate.now() + ": Gold star!\n");
}
```

---
# 4.4 静态字段与静态方法
在前面给出的示例程序中，**`main` 方法都被标记为 `static` 修饰符**。下面讨论一下这个修饰符的含义。
## 4.4.1 静态字段
**如果将一个字段定义为 `static` ，那么所有类中仅有一个这样的字段** *there is only one such field per class* 。而对于非静态的实例字段，每个对象都有自己的一个副本。例如，假定需要给每一个员工賦予唯一的标识码。这里给 `Employee` 类添加一个实例字段 `id` 和一个静态字段 `nextId` ：
```java
class Employee {
	private static int nextId = 1;
	private int id;
}
```
现在，每一个 `Employee` 对象都有一个自己的 `id` 字段，但这个类的所有实例将共享一个 `nextId` 字段。换句话说，如果有 $1000$ 个 `Employee` 类的对象，则有 $1000$ 个实例字段 `id` 。但只有一个静态字段 `nextId` 。即使没有一个员工对象，静态字段 `nextId` 也存在。**静态字段属于类，而不属于任何独立的对象** *It belongs to the class, not to any individual object* 。

> 注释：在绝大多数的面向对象程序设计语言中，静态字段被称为**类字段** `class fields` 。术语 `static` 只是沿用了C++的叫法，并无实际意义。

下面实现一个简单的方法：
```java
public void setld() {
	id = nextId;
	nextId++;
}
```
假定为 `harry` 设定员工标识码：
```java 
harry.setId();
```
`harry` 的 `id` 字段被设置为静态字段 `nextId` 当前的值，并且静态字段 `nextId` 的值加1：
```java
harry.id = Employee.nextld;
Eip1oyee.nextId++;
```
## 4.4.2 静态常量
静态变量使用得比较少，但**静态常量 `static constants` 却很常用**。例如，在 `Math` 类中定义了一个静态常量：
```java
public class Math {
	...
	public static final double PI = 3.14159265358979323846;
	...
}
```
在程序中，可以采用 `Math.PI` 的形式获得这个常量。

如果关键字 `static` 被省略，`PI` 就变成了 `Math` 类的一个实例字段，就需要通过  `Math` 类的一个对象访问 `PI` ，并且每一个 `Math` 对象都有它自己的一份 `PI` 拷贝。

另一个**多次使用的静态常量是 `System.out`** 。它在 `System` 类中声明：
```java
public class System {
	...
	public static final PrintStream out = ...;
	...
}
```
前面曾经提到过，由于每个类对象都可以修改公有字段，所以最好不要将字段设计为 `public` 。然而，**公有常量 （即 `public final` 字段）却没问题**。因为 `out` 被声明为`final` ，所以，不允许再将其他打印流陚给它：
```java
System.out = new PrintStrean(...); // Error out is final
```
 > 注释： 如果查看一下 `System` 类，就会发现有一个 `setOut` 方法，它可以将 `System.out` 设置为不同的流。可能会感到奇怪，为什么这个方法可以修改 `final` 变量的值。原因在于，`setOut` 方法是一个**原生方法** `native method` ，而不是在Java语言中实现的。原生方法可以绕过Java语言的存取控制机制 *Native methods can bypass the access control mechanisms of the Java language* 。这是一种特殊的解决方法，在自己编写程序时**不要模仿这种做法**。

## 4.4.3 静态方法
**静态方法是一种不在对象上执行的方法** *Static methods are methods that do not operate on objects* 。例如，`Math.pow` 方法就是一个静态方法。表达式 `Math.pow(x, a)` 会计算幂 $x^a$ 。**在完成运算时，它并不使用任何 `Math` 对象，换句话说它没有隐式参数**。

可以认为**静态方法是没有 `this` 参数的方法**（在一个非静态的方法中，`this` 参数指示这个方法的隐式参数，见4.3.7节）。

`Employee` 类的静态方法不能访问 `id` 实例字段，因为它不能在对象上执行操作。但是，**静态方法可以访问自身类中的静态字段** *a static method can access
a static field* 。下面是使用静态方法的一个示例：
```java
public static int getNextId() {
	return nextId; // returns static field
}
```
可以通过类名来调用这个方法：
```java
int n = Employee.getNextId();
```
这个方法可以省略关键字 `static` 吗？答案是肯定的。但这样一来，就需要通过 `Employee` 类对象的引用来调用这个方法。

> 注释：**可以使用对象调用静态方法**，这是合法的。例如，如果 `harry` 是一个 `Employee` 对象，可以用 `harry.getNextId()` 代替 `Employee.getNextId()` 。不过，这种方式很容易造成混淆，其原因是 `getNextld` 方法计算的结果与 `harry` 毫无关系。**我们建议使用类名、而不是对象来调用静态方法**。
 
在下面两种情况下，可以使用静态方法：
- **方法**不需要访问对象状态，**其所需参数都通过显式参数提供**（例如 `Math.pow` ）；
- **方法只需要访问类的静态字段**（例如：`Employee.getNextId` ）。

> C++注释：Java中的静态字段与静态方法，在功能上与C++相同。但是，语法上稍有不同。在C++中，要使用 `::` 操作符访问自身作用域之外的静态字段和静态方法，如`Math::PI` 。
> 
> 术语 `static` 有一段不寻常的历史。起初，C引入关键字 `static` ，是为了表示**退出一个块后、依然存在的局部变量**，在这种情况下术语 `static` 是有意义的： 变量一直存在，当再次进入该块时仍然存在 *The variable stays around and is still there when the block is entered again* 。随后，`static` 在C中有了第二种含义，表示**不能被其他文件访问的全局变量和函数**。为了避免引入一个新的关键字，关键字 `static` 被重用了。最后，C++第三次重用了这个关键字，与前面赋予的含义完全不一样，这里将其解释为：**属于类但不属于任何类对象的变量和函数** *belong to a class but not to any particular object of the class* 。这个含义与Java相同。

## 4.4.4 工厂方法
**静态方法还有另外一种常见的用途**。类似 `LocalDate` 和 `NumberFormat` 的类，使用静态工厂方法 `factory method` 来构造对象。我们已经见过工厂方法 `LocalDate.now` 和 `LocalDate.of` 。`NumberFormat` 类如下利用工厂方法、生成不同风格的格式化对象：
```java
NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
NumberFormat percentFormatter = NumberFormat.getPercentInstance();
double x = 0.1;
System.out.println(currencyFormatter.format(x)); // prints $0.10
System.out.println(percentFomatter.format(x)); // prints 10%
```
为什么 `NumberFormat` 类不利用构造器完成这些操作呢？ 这主要有两个原因：
- **无法命名构造器** *You can’t give names to constructors* 。构造器的名字必须与类名相同。但这里希望将得到的货币实例和百分比实例采用不用的名字。
- **使用构造器时，无法改变所构造的对象类型**。而 `Factory` 方法将返回一个`DecimalFormat` 类对象，这是 `NumberFormat` 的子类（有关继承的详细内容参看第5章)。
## 4.4.5 `main` 方法
需要注意，**可以调用静态方法、而不需要任何对象**。例如，不需要构造 `Math` 类对象就可以调用 `Math.pow` 。同理，**`main` 方法也是一个静态方法**。
```java
public class Application {
	public static void main(String[] args) {
		// construct objects here
	}
}
```
`main` 方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。**静态的 `main` 方法执行并构造「程序所需要的对象」**。
> 提示：每一个类可以有一个 `main` 方法。这是一个**常用于对类进行单元测试的技巧**。例如，可以在 `Employee` 类中添加一个 `main` 方法：
> ```java
> class Employee {
>     public Employee(String n, double s, int year, int month, int day) {
>         name = n;
>         salary = s;
>         Local Date hireDay = Local Date.now(year, month, day) ;
>     }
>     public static void main(St ri ng[] args) { // unit test 
>         Employee e = new Employee("Romeo", 50000, 2003, 3, 31) ;
>         e.raiseSalary(lO);
>         System.out.println(e.getName() + " " + e.getSalary());
>     }
> }
> **如果想要独立地测试 `Employee` 类，只需要在命令行中执行 `java Employee`** ；如果 `Employee` 类是一个更大型应用程序的一部分，就可以使用 `java Application` 这条语句运行程序，`Employee` 类的 `main` 方法永远不会执行。

程序清单 `ObjectAndClass/StaticTest/StaticTest.java` 中的程序包含了 `Employee` 类的一个简单版本，其中有一个静态字段 `nextId` 和一个静态方法 `getNextId` 。这里将3个 `Employee` 对象写入数组，然后打印雇员信息。最后，打印出下一个可用的员工标识码来展示静态方法。

需要注意，`Employee` 类也有一个静态的 `main` 方法用于单元测试。试试运行 `java Employee` 和 `java StaticTest` 、执行两个 `main` 方法。
```java
// ObjectAndClass/StaticTest/StaticTest.java
package StaticTest;

/**
 * This program demonstrates static methods.
 */
public class StaticTest {
	public static void main(String[] args) {
		// fill the staff array with three Employee objects
		var staff = new Employee[3];
		staff[0] = new Employee("Tom", 40000);
		staff[1] = new Employee("Dick", 60000);
		staff[2] = new Employee("Harry", 65000);
		
		// print out information about all Employee objects
		for (Employee e : staff) {
			e.setId();
			System.out.println("name=" + e.getName() + ", id=" + e.getId() + ", salary="
				+ e.getSalary());
		}
		
		int n = Employee.getNextId(); // calls static method
		System.out.println("Next available id=" + n);
	}
}

class Employee {
	private static int nextId = 1;
	
	private String name;
	private double salary;
	private int id;
	
	public Employee(String n, double s) {
		name = n;
		salary = s;
		id = 0;
	}
	
	public String getName() {
		return name;
	}
	
	public double getSalary() {
		return salary;
	}
	
	public int getId() {
		return id;
	}
	
	public void setId() {
		id = nextId; // set id to next available id
		++nextId;
	}
	
	public static int getNextId() {
		return nextId; // returns static field
	}
	
	public static void main(String[] args) { // unit test
		var e = new Employee("Harry", 50000);
		System.out.println(e.getName() + " " + e.getSalary());
	}
}
```
运行结果如下所示：
```java
name=Tom, id=1, salary=40000.0
name=Dick, id=2, salary=60000.0
name=Harry, id=3, salary=65000.0
Next available id=4
```

> `java.util.Objects` 7
> - `static <T> void requireNonNull(T obj)`
> - `static <T> void requireNonNull(T obj, String message)`
> - `static <T> void requireNonNull(T obj, Supplier<String> messageSupplier)` 8
> 如果 `obj` 为 `null` ，这些方法会抛出一个 `NullPointerException` 异常、而没有消息或者有给定的消息（第6章解释如何利用供应者、以懒方式得到一个值 *obtain a value lazily with a supplier* ，第8章解释 `<T>` 语法）。
> - `static <T> T requireNonNullElse(T obj, T defaultObj)`
> - `static <T> T requireNonNullElseGet(T obj, Supplier<T> defaultSupplier)`
> 如果 `obj` 不为 `null` 则返回 `obj` ，或者如果 `obj` 为 `null` 则返回默认对象。

---
# 4.5 方法参数
回顾一下，在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按
值调用 `call by value` 表示「方法接收的是调用者提供的值」。而按引用调用 `call by reference` 表示「方法接收的是调用者提供的变量地址」。**一个方法可以修改按引用传递的变量的值，而不能修改按值传递的变量的值**。“按… … 调用”是一个标准的计算机科学术语，它用来描述各种程序设计语言（不只是Java ) 中方法参数的传递方式（事实上，以前还有**按名调用** `call by name` ，Algol程序设计语言是最古老的高级程序设计语言之一，它使用的就是这种参数传递方式。不过对于今天，这种传递方式已经成为历史）。

**Java总是 *always* 采用按值调用**。也就是说，方法得到的是所有参数值的一个副本，特别是，方法不能修改「传递给它的任何参数变量」的内容。例如，考虑下面的调用，不必理睬这个方法的具体实现，在方法调用之后，`percent` 的值还是10。
```java
double percent = 10;
harry.raiseSalary(percent):
```
下面再仔细地研究一下这种情况。假定一个方法试图将一个参数值增加至3倍：
```java
public static void tripleValue(double x) { // doesn't work
	x = 3 * x;
}
```
然后调用这个方法：
```java
double percent = 10;
tripleValue(percent);
```
不过，这样并不能起作用。调用这个方法之后，`percent` 的值还是10。下面看一下具体的执行过程：
1. `x` 被初始化为 `percent` 值的一个拷贝（也就是10）；
2. `x` 被乘以3后等于30。但是 `percent` 仍然是10 ( 如下图4-6所示 )。
3. 这个方法结束之后，参数变量 `x` 不再使用。
![图4.6 对值参数的修改没有保留下来](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209061059736.png)

然而，方法参数共有两种类型：基本数据类型（数字、布尔值等）和对象引用。我们已经看到，**一个方法不可能修改一个基本数据类型的参数**，而对象引用作为参数就不同了。可以很容易地利用下面这个方法，实现将一个雇员的薪金提高3倍的操作：
```java
public static void tripleSalary(Employee x) { // works
	x.raiseSa1ary(200);
}
```
当调用
```java
harry = new Employee(...);
tripleSalary(harry);
```
时，具体的执行过程为：
1. `x` 被初始化为 `harry` 值的副本，这里是一个对象的引用。
2. `raiseSalary` 方法应用于这个对象引用。`x` 和 `harry` 同时引用的那个 `Employee` 对象的薪金提高了200%。
3. 方法结束后，参数变量 `x` 不再使用。当然，对象变量 `harry` 继续引用那个薪金增至3倍的雇员对象（如图4-7所示)。
![图4-7 对对象参数的修改保留了下来](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209061413096.png)

已经看到，实现一个改变对象参数状态的方法、是轻松且十分常见的。理由很简单，**方法得到的是对象引用的副本，原来的对象引用及其他的副本都引用同一个对象**。

很多程序设计语言（特别是C++和Pascal）提供了两种参数传递的方式：值调用和引
用调用。有些程序员认为Java对对象采用的是按引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以给出一个反例来详细地阐述一下这个问题。

首先，编写一个交换两个 `Employee` 对象的方法：
```java
public static void swap(Employee x, Employee y) // doesn't work
	Employee temp = x;
	x = y;
	y = temp;
}
```
如果Java对对象采用的是按引用调用，那这个方法就应该能够实现交换数据的效果：
```java
Employee a = new Employee("Alice", ...);
Employee b = new Employee("Bob", ...);
swap(a, b);
// does a now refer to Bob, b to Alice?
```
但是，**方法并没有改变存储在变量 `a` 和 `b` 中的对象引用**。`swap` 方法的参数 `x` 和 `y` ，被初始化为两个对象引用的副本，这个方法交换的是这两个副本。
```java
// x refers to Alice, y to Bob
Employee temp = x;
x = y;
y = temp;
// now x refers to Bob, y to Alice
```
最终，白费力气。在方法结束时参数变量 `x` 和 `y` 被丢弃了。原来的变量 `a` 和 `b` ，仍然引用这个方法调用之前所引用的对象（如图4-8所示）。
![图4-8 交换对象参数的结果没有保留下来](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209062131744.png)

这个过程说明：Java对对象采用的不是引用调用，实际上，**对象引用是按值传递的** *object references are passed by value* 。下面总结一下Java中方法参数的使用情况：
- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）；
- 一个方法可以改变一个对象参数的状态；
- 一个方法不能让一个对象参数引用一个新的对象。

程序清单 `ObjectAndClass/ParamTest/ParamTest.java` 给出了相应的演示。在这个程序中，首先试图将一个值参数的值增至三倍，但没有成功：
``` 
Testing tripleValue:
Before: percent=10.0
End of method: x:30.0
After: percent=10.0
```
随后，成功地将一个雇员的薪金增至三倍：
```java
Testing tripleSalary:
Before: salary=50000.0
End of method: salary=150000.0
After: salary=150000.0
```
方法结束之后，`harry` 引用的对象状态发生了改变。这是因为这个方法可以通过对象引用的副本、修改所引用的对象状态。

最后，程序演示了 `swap` 方法的失败效果，可以看出，参数变量 `x` 和 `y` 交换了，但是变量 `a` 和 `b` 没有受到影响。
```java
Testing swap:
Before: a=Alice
Before: b=Bob
End of method: x=Bob
End of method: y=Alice
After: a=Alice
After: b=Bob
```
> C++注释：C++有按值调用和按引用调用。引用参数标有 `&` 符号。例如，可以轻松地实现 `void tripleValue(double& x)` 方法或 `void swap(Employee& x, Employee& y)` 方法，修改它们的引用参数。

```java
// ObjectAndClass/ParamTest/ParamTest.java
package ParamTest;

import java.time.LocalDate;

/**
 * This program demonstrates parameter passing in Java. 
 */
public class ParamTest {
	public static void main(String[] args) {
		/*
		 * Test 1: Methods can't modify numeric parameters
		 */
		System.out.println("Testing tripleValue:");
		double percent = 10;
		System.out.println("Before: percent=" + percent);
		tripleValue(percent);
		System.out.println("After: percent=" + percent);
		
		/*
		 * Test 2: Methods can change the state of object parameters
		 */
		System.out.println("\nTesting tripleSalary:");
		var harry = new Employee("Harry", 50000);
		System.out.println("Before: salary=" + harry.getSalary());
		tripleSalary(harry);
		System.out.println("After: salary=" + harry.getSalary());
		
		/*
		 * Test 3: Methods can't attach new objects to object parameters
		 */
		System.out.println("\nTesting swap:");
		var a = new Employee("Alice", 70000);
		var b = new Employee("Bob", 60000);
		System.out.println("Before: a=" + a.getName());
		System.out.println("Before: b=" + b.getName());
		swap(a, b);
		System.out.println("After: a=" + a.getName());
		System.out.println("After: b=" + b.getName());
	}
	
	public static void tripleValue(double x) { // doesn't work
		x = 3 * x;
		System.out.println("End of method: x=" + x);
	}
	
	public static void tripleSalary(Employee x) { // works
		x.raiseSalary(200);
		System.out.println("End of method: salary=" + x.getSalary());
	}
	
	public static void swap(Employee x, Employee y) {
		Employee temp = x;
		x = y;
		y = temp;
		System.out.println("End of method: x=" + x.getName());
		System.out.println("End of method: y=" + y.getName());
	}
}

class Employee {
	private String name;
	private double salary; 
	
	public Employee(String n, double s) {
		name = n;
		salary = s; 
	}
	
	public String getName() {
		return name;
	}
	 
	
	public double getSalary() {
		return salary;
	}
	
	public void raiseSalary(double byPercent) {
		double raise = salary * byPercent / 100;
		salary += raise;
	}
}
```

---
# 4.6 对象构造
前面已经学习了编写简单的构造器、以定义对象的初始状态。但是，**由于对象构造非
常重要，所以Java提供了多种编写构造器的机制**。下面将详细地介绍这些机制。
## 4.6.1 重载 `overloading`
有些类有多个构造器。例如，可以如下构造一个空的 `StringBuilder` 对象：
```java
StringBuilder messages = new StringBuilder();
```
或者，可以指定一个初始字符串：
```java
StringBuilder todoList = new StringBuilder('To do:\n");
```
这种特征叫做**重载** `overloading` 。**如果多个方法**（比如，`StringBuilder` 构造器方法）**有相同的名字、不同的参数，便产生了重载**。编译器必须挑选出具体执行哪个方法，它用各个方法首部中的参数类型、与特定方法调用中所使用的值类型进行匹配，来挑选出相应的方法 *matching the parameter types in the headers of the various methods with the types of the values used in the specific method call* 。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。（这个查找匹配的过程，被称为**重载解析** `overloading resolution` 。
> 注释：**Java允许重载任何方法，而不只是构造器方法**。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的**签名** `signature` 。例如，`String` 类有4个称为 `indexOf` 的公有方法。它们的签名是：
> ```java
> indexOf(int)
> indexOf(int, int)
> indexOf(String)
> indexOf(String, int)
> ```
> **返回类型不是方法签名的一部分**。也就是说，不能有两个名字相同、参数类型也相同、却返回不同类型值的方法。

## 4.6.2 默认字段初始化
==如果在构造器中没有显式地给字段赋予初值，那么就会被自动地赋为默认值==（包括 `final` 字段吗）：数值为0、布尔值为 `false` 、对象引用为 `null` 。然而，只有缺少程序设计经验的人才会这样做，**依赖默认值的做法是一种不好的编程实践**。如果不明确地对字段进行初始化，就会影响程序代码的可读性。
> 注释： **这是字段与局部变量的主要不同点**。方法中的局部变量必须明确地初始化。但是在类中，如果没有初始化类中的字段，将会自动初始化为默认值（ `0, false, null` ）。

例如，考虑 `Employee` 类。假定没有在构造器中对某些字段进行初始化，就会默认
地将 `salary` 字段初始化为0，将 `name` 和 `hireDay` 字段初始化为 `null` 。但这并不是一个好主意。如果此时调用 `getName` 方法或 `getHireDay` 方法，则会得到一个 `null` 引用，这应该不是我们所希望的结果：
```java
LocalDate h = harry.getHireDay();
int year = h.getYear(); // throws exception if h is null
```
## 4.6.3 无参数的构造器
很多类都包含一个无参数的构造函数 *no-argument constructor* ，**对象由无参数构造函数创建时，其状态会设置为适当的默认值**。例如，以下是 `Employee` 类的无参数构造函数：
```java
public Employee {
	name = "";
	salary = 0;
	hireDay = LocalDate,now();
}
```
如果在编写一个类时没有编写构造器，那么系统就会提供一个**无参数构造器，这个构造器将所有的实例字段设置为默认值**。于是，实例字段中的数值型数据设置为0、布尔型数据设置为 `false` 、所有对象变量将设置为 `null` 。

==如果类中提供了至少一个构造器，但没有提供无参数的构造器，则在构造对象时如果没有提供参数、就会被视为不合法==。例如，在 `ObjectAndClass/ParamTest/ParamTest.java` 中的 `Employee` 类提供了一个简单
的构造器：
```java
Employee(String name, double salary, int y, int ra, int d)
```
对于这个类，构造默认的员工就是不合法的。也就是，如下调用将会产生错误。
```java
e = new Eraployee();
```

> 警告：记住，**仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器**；如果在编写类的时候，给出了一个构造器，哪怕是很简单的，要想让这个类的用户能够采用下列方式构造实例：
> ```java
> new ClassName()
> ```
> 就必须提供一个默认的构造器（即不带参数的构造器）。当然，**如果希望所有字段被赋予默认值，只需要提供以下代码**：
> ```java
> public ClassName {
> }
> ```

## 4.6.4 显式字段初始化
通过重载类的构造器方法，我们可以采用多种形式、设置类的实例字段的初始状态。确保不管怎样调用构造器，每个实例字段都被设置为一个有意义的初值，这是一种很好的设计习惯。

**可以在类定义中，直接为任何字段赋一个值**。例如：
```java
class Employee {
	private String name = "";
	...
}
```
**在执行构造器之前，先执行完成这个赋值操作**。==当一个类的所有构造器，都希望把相同的值赋予某个特定的实例字段时，这种语法特别有用==。

**初始值不一定是常量值**。在下面的例子中，就是**利用方法调用、初始化一个字段**。仔细看一下 `Employee` 类，其中每个雇员有一个 `id` 域。可以使用下列方式进行初始化：
```java
class Employee {
	private static int nextld;
	private int id = assignId()；
	private static int assignId() {
		int r = nextId;
		nextId++;
	}
}
```
> C++注释：**在C++中，不能直接初始化类的实例字段。所有的字段必须在构造器中设置**。但是，C++有一个特殊的初始化器列表 `initializer list` 语法，如下所示：
> ```cpp
> Employee::Employee(String n, double s, int y, int m, int d) : // C++
>     name(n),
>     salary(s),
>     hireDay(y, m, d)
> {
> }
> ```
> C++使用这种特殊的语法来调用字段构造器。==在Java中没有这种必要，因为对象没有子对象，只有指向其他对象的指针== *because objects have no subobjects, only pointers to other objects*（？）。

## 4.6.5 参数名
在编写很小的构造器时 （这是十分常见的)，常常在参数命名上出现错误。通常，我们喜欢将参数用单个字符命名：
```java
public Employee(String n, double s)
	salary = s;
}
```
但这样做有一个缺陷： 只有阅读代码才能够了解参数 `n` 和参数 `s` 的含义。有些程序员在每个参数前面加上一个前缀 `a` ：
```java
public Employee(String aName, double aSalary) {
	name = aName;
	salary = aSalary;
}
```
这样很清晰。每一个读者一眼就能够看懂参数的含义。

还有一种常用的技巧，它基于这样的事实：参数变量会遮蔽同名的实例字段。例如，如果将参数命名为 `salary` ，则 `salary` 将引用这个参数，而不是实例字段。但是，**可以采用 `this.salary` 的形式访问实例字段**。回想一下，`this` 指示隐式参数，也就是所构造的对象。下面是一个示例：
```java
public Employee(String naie, double salary) {
	this.name = name;
	this.salary = salary;
}
```
> C++注释：在C++中，经常用下划线或某个固定的字母（一般选用 `m` 或 `x` ) 作为实例字段的前缀，例如 `salary` 字段可能被命名为 `_salary,mSalary, xSalary` 。Java 程序员通常不这样做。

## 4.6.6 调用另一个构造器
**关键字 `this` 引用一个方法的隐式参数**。然而，这个关键字还有另外一个含义。**如果构造器的第一个语句形如 `this(...)` ，这个构造器将调用同一个类的另一个构造器**。下面是一个典型的例子：
```java
public Employee(double s) {
	// calls Employee(String, double)
	this("Employee #" + nextId, s);
	nextId++;
}
```
当调用 `new Employee(60000)` 时，`Employee(double)` 构造器将调用 `Employee(String, double)` 构造器。

采用这种方式使用 `this` 关键字非常有用，这样**对公共的构造器代码部分只编写一次**即可。
> C++注释：**在Java中，`this` 引用等价于C++的 `this` 指针**。但是，~~在C++ 中，一个构造器不能调用另一个构造器，在C++中，必须将抽取出的公共初始化代码编写成一个独立的方法~~（可以委托构造吧？）。

## 4.6.7 初始化块
前面已经讲过**两种初始化数据字段的方法**：
- 在一个构造器中设置值；
- 在声明中赋一个值。

实际上，Java还有第三种机制，称为**初始化块** `initialization block` 。**在一个类的声明中，可以包含任意多个代码块。只要构造这个类的对象，这些块就会被执行**。例如：
```java
class Employee {
	private static int nextId;
	
	private int id;
	private String name;
	private double salary; 
	
	// object initialization block 
	{
		id = nextId;
		nextId++;
	}
	
	public Employee(String n, double s) {
		name = n;
		salary = s;
	}
	public Employee() {
		name = "";
		salary = 0;
	}
	...
}
```
在这个示例中，**无论使用哪个构造器构造对象，`id` 字段都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分**。这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。
> 注释：==可以在初始化块中设置字段，即使这些字段在类的后面才定义，这是合法的。但是，为了避免循环定义 *circular definitions* ，不要读取在后面初始化的字段 *read from fields that are only initialized later*==。具体的规则参看[Java语言规范的 8.3.2.3节](http://docs.oracle.com/javase/specs)。这个规则的复杂度，足以使编译器的实现者头疼，所以较早的Java版本中这些规则的实现存在一些小错误。因此，建议**总是将初始化块放在字段定义之后 *always place initialization blocks after the field definitions*** 。

由于初始化数据字段有多种途径，所以列出构造过程的所有路径可能让人困惑。下面是**调用构造器的具体处理步骤**：
1. 如果构造器的第一行调用了另一个构造器，则基于所提供的参数执行第二个构造器。
2. 否则：
	1. 所有数据字段初始化为默认值（ `0, false, null` ）。
	2. ==按照在类声明中出现的次序，依次执行所有字段初始化语句和初始化块 *All field initializers and initialization blocks are executed, in the order in which they occur in the class declaration*== 。
3. 执行这个构造器的主体代码。

当然，应该精心地组织好初始化代码，这样有利于其他程序员的理解。例如，==如果让类的构造器行为依赖于数据字段声明的顺序，那就会显得很奇怪、并且容易引起错误==。

可以通过**提供一个初始化值**，或者**使用一个静态的初始化块**来初始化静态字段。前面已经介绍过第一种机制：
```java
private static int nextId = 1;
```
**如果对类的静态字段进行初始化的代码比较复杂，那么可以使用静态的初始化块**。

将代码放在一个块中，并标记关键字 `static` 。下面是一个示例。其功能是将雇员ID 的起始值，赋予一个小于10000的随机整数。
```java
// static initialization block
static {
	Random generator = new Random();
	nextId = generator.nextInt(10000);
}
```
**在类第一次加载的时候，将会进行静态字段的初始化**。与实例字段一样，除非将它们显式地设置成其他值，否则默认的初始值是 `0, false, null` 。==所有的静态初始化语句、以及静态初始化块，都将依照「类声明中出现的顺序」执行 *All static field initializers and static initialization blocks are executed in the order in which they occur in the class declaration*== 。
> 注释：让人惊讶的是，在JDK 6之前，都可以用Java编写一个没有 `main` 方法的"
Hello, World"程序：
> ```java
> public class Hello {
>     static {
>         System.out.println("Hel1o, World");
>     }
> }
> ```
> 当用 `java Hello` 调用这个类时，就会加栽这个类，静态初始化块将会打印"Hello, World"。在此之后，才会显示一个消息指出 `main` 未定义。从Java SE 7以后，Java程序首先会检查是否有一个 `main` 方法。

程序清单 `ObjectAndClass/ConstructorTest/ConstructorTest.java` 展示了本节讨论的很多特性:
- 重载构造器
- 用 `this(...)` 委托调用另一个构造器
- 无参数构造器
- 对象初始化块
- 静态初始化块
- 实例字段初始化

```java
// ObjectAndClass/ConstructorTest/ConstructorTest.java
package ConstructorTest;
import java.util.*;

/**
 * This program demonstrates object construction.
 */
public class ConstructorTest {
	public static void main(String[] args) {
		// fill the staff array with three Employee objects
		var staff = new Employee[3];
		staff[0] = new Employee("Harry", 40000);
		staff[1] = new Employee(60000);
		staff[2] = new Employee();
		
		// print out information about all Employee objects
		for (Employee e : staff)
			System.out.println("name=" + e.getName() + ", id=" + e.getId() 
				+ ", salary=" + e.getSalary());
	}
}

class Employee {
	private static int nextId;
	private int id;
	private String name = ""; // instance field initialization
	private double salary;
	
	// static initialization block
	static {
		var generator = new Random();
		// set nextId to a random number between 0 and 9999
		nextId = generator.nextInt(10000);
	}
	
	// object initialization block
	{
		id = nextId;
		nextId++;
	}
	
	// three overloaded constructors
	public Employee(String n, double s) {
		name = n;
		salary = s;
	}
	public Employee(double s) {
		// calls the Employee(String, double) constructor
		this("Employee #" + nextId, s);
	}
	// the default constructor
	public Employee() {
		// name initialized to ""
		// salary not explicitly set -- initialized to 0
		// id initialized in initialization block
	}
	
	public String getName() {
		return name;
	}
	public double getSalary() {
		return salary;
	}
	public int getId() {
		return id;
	}
}
```
某次运行的结果如下：
```java
name=Harry, id=2405, salary=40000.0
name=Employee #2406, id=2406, salary=60000.0
name=, id=2407, salary=0.0
```

> `java.util.Random` 1.0
> - `Random()`
> 构造一个新的随机数生成器。
> - `int nextInt(int n)` 1.2
> 返回一个 $0\sim n - 1$ 之间的随机数。

# 4.6.8 对象析构与 `finalize` 方法
有些面向对象的程序设计语言（特别是C++）有显式的析构器方法，其中放置一些当对
象不再使用时需要执行的清理代码。**在析构器中，最常见的操作是回收分配给对象的存储空间**。由于Java会完成自动的垃圾回收，不需要人工回收内存，所以**Java不支持析构器**。

当然，**某些对象使用了内存之外的其他资源**，如文件或使用了系统资源的另一个对象的句柄。**在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要**。

**如果一个资源一旦使用完就需要立即关闭，那么就应当提供一个 `close` 方法、来完成必要的清理工作**。在对象使用完时能调用这个 `close` 方法。第7章介绍如何确保自动调用这个方法。

**如果可以等到虚拟机退出，那么可以用方法 `Runtime.addShutdownHook` 增加一个“关闭钩” `shutdown hook`** 。在Java 9中，可以使用 `Cleaner` 类注册一个动作，当对象不再可达时（除了清洁器 *cleaner* 还能访问，其他对象都无法访问这个对象），就会完成这个动作。在实际中这些情况很少见。可以参见API文档、来了解这两种方法的详细内容。

> 警告：可以为任何一个类添加 `finalize` 方法。`finalize` 方法将在垃圾回收器清理对象之前调用。在实际应用中，不要依赖于使用 `finalize` 方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用，而且该方法已经被废弃。

---
# 4.7 包
Java允许使用**包** `package` 将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。

标准的Java类库分布在多个包中，包括 `java.lang, java.util, java.net` 等。**标准的Java包具有一个层次结构**。如同硬盘的目录嵌套一样，也可以使用嵌套层次组织包，Java包里可以嵌套包。**所有标准的Java包都处于 `java` 和 `javax` 包层次中**。
## 4.7.1 包名
使用包的主要原因是**确保类名的唯一性**。假如两个程序员不约而同地建立了 `Employee` 类，只要将这些类放置在不同的包中，就不会产生冲突。事实上，==为了保证包名的绝对唯一性，要使用一个（如公司的）因特网域名（这显然是唯一的）以逆序的形式作为包名，然后对于不同的工程使用不同的子包==。例如，考虑域名 `horstmann.com` 。如果逆序来写，就得到了包名 `com.horstmann` 。然后可以追加一个工程名，如 `com.horstmann.corejava` 。如果再把 `Employee` 类放在这个包里，那么这个类的“完全限定”名就是 `com.horstmann.corejava.Employee` 。
 
> 注释：**从编译器的角度来看，嵌套的包之间没有任何关系 *there is absolutely no
relationship between nested packages*** 。例如，`java.util` 包与`java.util.jar` 包毫无关系。**每一个包都是独立的类集合**。
## 4.7.2 类的导入
**一个类可以使用所属包中的所有类，以及其他包中的公共类** `public class`（ `java.util.jar` 包的类能使用 `java.util` 包的类吗？应该可以）。我们可以采用两种方式访问另一个包中的公有类。第一种方式是使用**完全限定名** `fully qualified name` ，即在每个类名之前添加完整的包名。例如：
```java
java.time.LocalDate today = java.time.LocalDate.now();
```
这显然很繁琐。更简单且更常用的方式是使用 `import` 语句。`import` 语句是一种引用「包中各个类」的简洁方式。一旦使用了 `import` 语句，在使用类时，就不必写出包的全名了。

可以使用 `import` 语句导人一个特定的类或者整个包。**`import` 语句应该位于源文件的顶部（但位于 `package` 语句的后面）**。例如，可以使用下面这条语句导人 `java.util` 包中所有的类。
```java
import java.util.*;
```
然后，就可以使用：
```java
LocalDate today = LocalDate.now();
```
而无须在前面加上包前缀。还可以导人一个包中的特定类：
```java
import java.time.LocalDate;
```
`java.time.*` 的语法比较简单，对代码的大小也没有任何负面影响。然而，如果能明确地指出所导入的类，将会使代码的读者更加准确地知道使用了哪些类。但需要注意的是，**只能使用星号 `*` 导入一个包**，而不能使用 `import java.*` 或
`import java.*.*` 导入以 `java` 为前缀的所有包。
> 提示：在Eclipse中，可以使用菜单选项 `Source->Organize Imports` 。诸如 `import java.util.*;` 等包语句，将会自动地扩展为一组特定的导入语句，如：
> ```java
> import java.util.ArrayList;
> import java.util.Date;
> ```
> 这是一个十分便捷的特性。

在大多数情况下，可以只导入所需的包，并不必过多地理睬它们。但在发生命名冲突的时候，就不能不注意包的名字了。例如，`java.util` 和 `java.sql` 包都有日期  `Date` 类。如果在程序中导入了这两个包：
```java
import java.util.*;
import java.sql.*;
```
在程序使用 `Date` 类的时候，就会出现一个编译错误，此时编译器无法确定程序使用的是哪一个 `Date` 类：
```java
Date today; // Error java.util.Date or java.sql.Date?
```
可以采用**增加一个特定的 `import` 语句**来解决这个问题：
```java
import java.util.*;
import java.sql .*;
import java.util.Date;
```
如果这两个 Date 类都需要使用，又该怎么办呢？ 答案是，**在每个类名的前面加上完整的包名**。
```java
java.util.Date deadline = new java.util.Date();
java.sql.Date today = new java.sql.Date(...);
```
在包中定位类是编译器的工作。**类文件中的字节码总是使用完整的包名来引用其他类** *The bytecodes in class files always use full package names to refer to other classes* 。
> C++注释：C++程序员经常将 `import` 与 `#include` 弄混。实际上，这两者之间并没有共同之处。在C++中，必须使用 `#include` 来加载外部特性的声明，这是因为==除了正在编译的文件以及在头文件中明确包含的文件，C++编译器无法查看任何其他文件的内部==。Java编译器可以查看其他文件的内部，只要告诉它到哪里去查看就可以了。
>
> 在Java中，通过显式地给出包名，如 `java.util.Date` ，就可以不使用 `import` ; 而**在C++中，无法避免使用 `#include` 指令**。
> 
> `import` 语句的唯一的好处是简捷。可以使用简短的名字、而不是完整的包名来引用一个类。例如，在 `import java.util.*` 语句之后，可以仅仅用 `Date` 来引用`java.util.Date` 类。
> 
> 在C++中，与包机制类似的是命名空间 `namespace` 。**在Java中，`package` 与 `import` 语句类似于C++中的 `namespace` 和 `using` 指令**。

## 4.7.3 静态导入
有一种 `import` 语句不仅可以导入类，还可以导入静态方法和静态字段。例如，如果在源文件的顶部，添加一条指令：
```java
import static java.lang.System.*;
```
就可以使用 `System` 类的静态方法和静态字段，而不必加类名前缀：
```java
out.println("Goodbye, World!"); //i.e., System.out
exit(0); //i.e., System.exit
```
另外，还可以**导入特定的方法或字段**：
```java
import static java.lang.System.out;
```
实际上，是否有很多程序员想要简写 `System.out` 或 `System.exit` ，很值得怀疑。这种编写形式不利于代码的清晰。不过，`sqrt(pow(x, 2) + pow(y, 2))` 看起来比 `Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))` 清晰得多。

## 4.7.4 将类放入包中
==要想将一个类放人包中，就必须将包的名字放在源文件的开头，即放在「定义这个包中各个类的代码」之前==。例如：
```java
package com.horstmann.corejava;
public class Employee {
	
}
```
如果没有在源文件中放置 `package` 语句，这个源文件中的类就属于**无名包** `unnamed package` 或**默认包** `defaulf package` 中。默认包是一个没有包名的包。到目前为止，我们定义的所有类都在这个无名包中。

**将源文件放到「与完整包名匹配的子目录」中**。例如，`com.horstmann.corejava` 包中的所有源文件，应该被放置在子目录 `com/horstmann/corejava` 中。**编译器将类文件也放在相同的目录结构中**。例如，将 `PackageTest` 类放置在默认包中，该类使用了 `Employee` 类；而 `Employee` 类放置在 `com.horstmann.corejava` 包中。因此，`Employee.java` 文件必须包含在子目录 `com/horstmann/corejava` 中。换句话说，目录结构如下所示：
```java
. (base directory)
  ├─ PackageText.java
  ├─ PackageText.class
  └─ com/
    └─ horstmann/
      └─ corejava/
        ├─ Employee.java
        └─ Employee.class
```
要想编译这个程序，只需切换到基目录，并运行命令
```java
javac PackageTest.java
```
编译器就会自动地查找文件 `com/horstmann/corejava/Employee.java` 并进行编译。

更加实际的例子是，不使用默认包，而是将类分别放在不同的包中 `com. horstmann.corejava` 和 `com.mycompany` 。
```java
. (base directory)
  └─ com/
    ├─ horstmann/
    │ └─ corejava/
    │   ├─ Employee.java
    │   └─ Employee.class
    └─ mycompany/
      ├─ PayrollApp.java
      └─ PayrollApp.class
```
在这种情况下，仍然要从基目录编译和运行类，即包含 `com` 目录：
```java
javac com/myconipany/Payrol1App.java
java com.mycompany.PayrollApp
```
需要注意，**编译器对文件（带有文件分隔符和扩展名 `.java` 的文件）进行操作。而Java解释器加载类（带有 `.` 分隔符）**。从下面开始，将对源代码使用包。这样一来，就可以为各章建立一个IDE工程，而不是各小节分别建立工程。
> 警告：**编译器在编译源文件的时候不检查目录结构**。例如，假定有一个源文件开头有下列语句：
> ```java
> package com.mycompany;
> ```
> 即使这个源文件没有在子目录 `com/mycompany` 下，也可以进行编译。**如果它不依赖于其他包**，就不会出现编译错误。但是，最终的程序将无法运行，除非先将所有类文件移到正确的位置上。如果包与目录不匹配，**虚拟机**就找不到类。
```java
// ObjectAndClass/PackageTest/PackageTest.java
package PackageTest;
import PackageTest.com.horstmann.corejava.*; // the Employee class is defined in that package

import static java.lang.System.*;
/**
 * This program demonstrates the use of packages.
 */
public class PackageTest {
	public static void main(String[] args) {
		// because of the import statement, we don't have to use
		// com.horsemann.corejava.Employee here
		var harry = new Employee("Harry Hacker", 50000, 1989, 10, 1);
		harry.raiseSalary(5);
		
		// because of the static import statement, we don't have
		// to use System.out here
		out.println("name=" + harry.getName() + ", salary=" + harry.getSalary());
	}
}

// ObjectAndClass/PackageTest/com/horstmann/corejava/Employee.java
package PackageTest.com.horstmann.corejava;

// the classes in this file are part of this package

import java.time.*;

// import statements come after the package statement

public class Employee {
	private String name;
	private double salary;
	private LocalDate hireDay;
	
	public Employee(String name, double salary, int year, int month, int day) {
		this.name = name;
		this.salary = salary;
		hireDay = LocalDate.of(year, month, day);
	}
	
	public String getName() {
		return name;
	}
	
	public double getSalary() {
		return salary;
	}
	
	public LocalDate getHireDay() {
		return hireDay;
	}
	
	public void raiseSalary(double byPercent) {
		double raise = salary * byPercent / 100;
		salary += raise;
	}
}
```
运行结果如下所示：
```java
name=Harry Hacker, salary=52500.0
```
## 4.7.5 包访问
前面已经接触过**访问修饰符** `the access modifiers` 如 `public` 和 `private` 。**标记为 `public` 的部分，可以被任意的类使用；标记为 `private` 的部分，只能被定义它们的类使用**。如果没有指定 `public` 或 `private` ，这个部分（类、方法或变量）可以被「**同一个包中的所有方法**」访问 *can be accessed by all methods in the same package* 。

下面再仔细地看一下程序 `ObjectAndClass/EmployeeTest/EmployeeTest.java` 。在这个程序中，**没有将 `Employee` 类定义为公共类，因此只有在同一个包（在此是默认包）中的其他类可以访问**，例如 `EmployeeTest` 。对于类来说，这种默认是合乎情理的。但是，对于变量来说就有些不适宜了，因此**变量必须显式地标记为 `private` ，不然的话将默认为包可访问**。显然，这样做会破坏封装性。问题主要是人们经常忘记键入关键字 `private` 。在 `java.awt` 包中的 `Window` 类就是一个典型的示例。`java.awt` 包是JDK提供的部分源代码：
```java
public class Window extends Container {
	String warningString;
}
```
注意，这里的 `wamingString` 变量不是 `private` ! 这意味着 `java.awt` 包中的所有类的方法都可以访问该变量，并将它设置为任意值（例如，`"Trust me!"` ）。实际上，**只有 `Window` 类的方法访问它，因此应该将它设置为私有变量**。我们猜测可能是程序员匆忙之中忘记键入 `private` 修饰符了（为防止程序员内疚，我们没有说出他的名字，感兴趣的话，可以查看一下源代码），也可能是没有人关心这个问题？
> 注释：奇怪的是，这个问题至今还没有得到糾正，不仅如此，这个类还增加了一些新字段，其中大约一半也不是私有的。

这真的会成为一个问题吗？答案是：视具体情况而定。==在默认情况下，包不是一个封闭的实体。也就是说，任何人都可以向包中添加更多的类==。当然，有敌意或低水平的程序员很可能利用包的可见性，添加一些能修改变量的代码。例如，在Java的早期版本中，只需要将下列这条语句放在类文件的开头，就可以很容易地将其他类混入 `java.awt` 包中：
```java
package java.awt;
```
然后，把结果类文件放置在类路径某处的 `java/awt` 子目录下，就可以访问 `java.awt` 包的内部了。使用这一手段，可以对警告框进行设置（如图4-9所示）。
![图4.9](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209091005367.png)

从1.2版开始，**JDK的实现者修改了类加载器，明确地禁止加载用户自定义的、包名以 `"java."` 开始的类**！ 当然，用户自定义的类无法从这种保护中受益。然而，另一种机制是让JAR文件声明包为密封的 `sealed` 、以防止第三方修改，即通过**包密封** `package sealing` 机制、来解决将各种包混杂在一起的问题——如果将一个包密封起来，就不能再向这个包添加类了。但这种机制已经过时，现在应当使用**模块**封装包 *use modules to encapsulate packages* ，在第II卷第9章中详细讨论模块。
 
---
# 4.8 类路径
在前面已经看到，**类存储在文件系统的子目录中。类的路径必须与包名匹配**。

另外，类文件也可以存储在JAR（Java归档）文件中。==在一个JAR文件中，可以包含多个「压缩形式的类文件和子目录」，这样既可以节省空间、又可以改善性能==。在程序中用到第三方 `third-party` 的库文件时，通常会给出一个或多个需要包含的JAR文件。JDK也提供了许多的JAR文件，例如，在 `jre/lib/rt.jar` 中包含数千个类库文件。有关创建JAR文件的详细内容，将在第11章中讨论。
> 提示：JAR文件使用 `ZIP` 格式组织文件和子目录。可以使用任何ZIP工具查看内部的JAR文件。

为了使类能够被多个程序共享，需要做到下面几点：
1. 把类放到一个目录中，例如 `/home/user/classdir` 。需要注意，这个目录是包树状结构的**基目录**。如果希望将 `com.horstmann.corejava.Employee` 类添加到其中，这个 `Employee.class` 类文件就必须位于子目录 `/home/user/classdir/com/horstmann/corejava` 中。
2. 将JAR文件放在一个目录中，例如：`/home/user/archives` 。
3. 设置**类路径** `classpath` 。类路径是「所有包含类文件的路径」的集合。

在UNIX环境中，类路径中的各项之间采用冒号 `:` 分隔：
```java
/home/user/classdir:.:/home/user/archives/archive.jar
```
，而在Windows环境中，则以分号 `;` 分隔：
```java
c:\classdir;.;c:\archi»es\archive.jar
```
在上述两种情况中，句点 `.` 都表示当前目录。

类路径包括：
- 基目录 `/home/user/classdir` 或 `c:\classes` ；
- 当前目录 `.` ；
- JAR文件 `/home/user/archives/archive.jar` 或 `c:\archives\archive.jar` 。

从Java SE 6开始，可以给一个JAR文件目录指定通配符 *specify a wildcard for a JAR file directory* ，如下：
```java
/home/user/classdir:.:/home/aser/archives/'*' 
```
或者：
```java
c:\classdir;.;c:\archives\*
```
在UNIX中，`*` 必须转义、以防止Shell命令进一步扩展。在 `archives` 目录中的所有JAR文件（但不包括 `.class` 文件）都包含在这个类路径中。

由于运行时库文件（如 `rt.jar` 和在 `jre/lib` 与 `jre/lib/ext` 目录下的一些其他的JAR文件）会被自动地搜索，所以不必将它们显式地列在类路径中。
> 警告：**`javac` 编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有 `"."` 目录时，才查看当前目录**。如果没有设置类路径，那也并不会产生什么问题，因为默认的类路径包含 `"."` 目录。然而如果设置了类路径、却忘记了包含 `"."` 目录，则程序仍然可以通过编译，但不能运行。

==类路径所列出的目录和归档文件，是搜寻类的起始点==。下面看一个类路径示例：
```java
/home/user/classdir:.:/home/user/archives/archive.jar
```
假定虚拟机要搜寻 `com.horstmann.corejava.Employee` 类文件。它首先要查看Java API类（存储在 `jre/lib` 和 `jre/lib/ext` 目录下的归档文件中，所存放的系统类文件）。显然，==在那里找不到相应的类文件，所以转而查看类路径==。然后查找以下文件：
- `/home/user/classdir/com/horstmann/corejava/Employee.class`
- `com/horstmann/corejava/Employee.class`（从当前目录开始）
- `com/horstmann/corejava/Employee.class`（在 `/home/user/archives/archive.jar` 中）

**编译器定位文件要比虚拟机复杂得多**。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包。它会查看所有的 `import` 指令，确定其中是否包含了被引用的类（它将所有 `import` 指令作为类的可能源 *It consults all import directives  as possible sources for the class* ）。例如，假定源文件包含指令：
```java
import java.util.*;
import com.horstmann.corejava.*;
```
并且源代码引用了 `Employee` 类。编译器将试图查找 `java.lang.Employee`（因为`java.lang` 包被默认导入）、`java.util.Employee` 、`com.horstmann.corejava.Employee` 和当前包中的 `Employee` 。它会在类路径的所有位置中搜索以上列出的每一个类。如果找到了一个以上的类，就会产生编译错误（因为完全限定类名必须是唯一的，而 `import` 语句的次序却无关紧要）。

编译器的任务不止这些，它还要查看源文件 `Source files` 是否比类文件新。如果是这样的话，那么源文件就会被自动地重新编译。在前面已知，==仅可以导人其他包中的公共类。一个源文件只能包含一个公共类，并且文件名必须与公共类匹配==。因此，**编译器很容易定位公共类所在的源文件**。不过，也可以从当前包中导入非公共类。这些类有可能定义在「与类名不同的源文件」中。==如果从当前包中导人一个类，编译器就要搜索当前包中的所有源文件，以便确定哪个源文件定义了这个类==。
## 4.8.1 设置类路径
最好采用 `-classpath`（或 `-cp` ）选项指定类路径：
```java
java -classpath /home/user/dassdir:.:/home/user/archives/archive.jar MyProg
```
或者：
```java
java -classpath c:\classdir;.;c:\archives\archive.jar MyProg
```
整个指令应该书写在一行中。将这样一个长的命令行放在一个Shell脚本、或一个批处理文件中是一个不错的主意。

**利用 `-classpath` 选项设置类路径是首选的方法**，也可以通过设置 `CLASSPATH` 环境变量完成这个操作。其详细情况依赖于所使用的Shell。在 `Bourne Again shell (bash)` 中，命令格式如下：
```java
export CLASSPATH=/home/user/classdir:.:/home/user/archives/archive.jar
```
在Windows shell，命令格式如下：
```java
set CLASSPATH=c:\classdir;.;c:\archives\archive.jar
```
直到退出Shell为止，类路径设置均有效。
> 警告： 有人建议将 `CLASSPATH` 环境变量设置为永久不变的值。总的来说这是一个很糟糕的主意。人们有可能会忘记全局设置，因此，当使用的类没有正确地加载进来时，会感到很奇怪。一个应受到指责的示例是Windows中Apple的QuickTime安装程序。多年来，它都将 `CLASSPATH` 全局设置为一个它所需要的JAR文件，而并没有在类路径上包含当前路径 *did not include the current directory in the classpath* 。因此，当程序编译后却不能运行时，众多Java程序员不得不花费很多精力去解决这个问题。
 
> 警告：过去，有人建议完全绕开类路径，将所有的文件放在 `jre/lib/ext` 路径。这种机制在Java 9中已经过时，而且这是一个极坏的主意，其原因主要有两个：
> - 当手工地加载其他的类文件时，如果将它们存放在扩展路径上，则不能正常地工作 （有关类加载器的详细信息，请参看卷II第9章）。
> - 此外，程序员经常会忘记三个月前存放文件的位置。当类加载器忽略了曾经仔细设计的类路径时，程序员会毫无头绪地在头文件中查找。事实上，加载的是扩展路径上已长时间遗忘的类，这会让人非常困惑。

> 注释：在Java 9中，还可以从**模块路径** `module path` 加载类，见卷II第9章讨论的模块和模块路径。

---
# 4.8 JAR文件
在将应用程序打包时，一定希望只向用户提供一个单独的文件、而不是一个包含大量类文件的目录结构，Java归档 `JAR` 文件就是为此目的而设计的。**一个JAR文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件**。此外，JAR文件是压缩的，它使用了我们熟悉的ZIP压缩格式。
## 4.8.1 创建JAR文件
可以用 `jar` 工具制作JAR文件（在默认的JDK安装中，这个工具位于 `jdk/bin` 目录下）。创建一个新JAR文件，最常用的命令语法如下：
```bash
$ jar cvf jarFileName file1 file2 ...
```
例如：
```bash
$ jar cvf CalculatorClasses.jar *.class icon.gif
```
通常，`jar` 命令的格式如下：
```bash
$ jar options file1 file2 ... 
```
表4-2列出了 `jar` 程序的所有选项，它们类似于UNIX的 `tar` 命令选项。我们可以**将应用程序和代码库打包在JAR文件中**。例如，如果想在一个Java程序中发送邮件，就可以使用打包在文件 `javax.mail.jar` 中的一个库。其中，`e` 在清单文件中创建一个入口点，`m` 将一个清单文件添加到JAR文件中，`u` 更新一个已有的JAR文件，`v` 表示生成详细的输出结果：
![表4.2|700x800](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202209101828843.png)
## 4.8.2 清单文件
除了类文件、图像和其他资源外，每个JAR文件还包含一个**清单文件** `manifest` ，用于描述归档文件的特殊特性。

清单文件被命名为 `MANIFEST.MF` ，它位于JAR文件的一个特殊的 `META-INF` 子目录中。符合标准的最小清单文件极其简单：
```java
Manifest-Version: 1.0
```
复杂的清单文件可能包含更多条目。这些清单条目被分成多个节。第一节被称为**主节** `main section` ，它作用于整个JAR文件。随后的条目用来指定命名实体（如单个文件、包或URL）的属性 *specify properties of named entities such as individual files, packages, or URLs* 。它们都必须以一个 `Name` 条目开始。节与节之间用空行分开。例如：
```java
Manifest-Version: 1.0
lines describing this archive

Name: Woozle.class
lines describing this file
Name: com/mycompany/mypkg/
lines describing this package
```
要想编辑清单文件，需要将「希望添加到清单文件中的行」放到文本文件中，然后运行：
```bash
$ jar cfm jarFileName manifestFileName ...
```
例如，要创建一个包含清单文件的JAR文件，应该运行：
```bash
$ jar cfm MyArchive.jar manifest.mf com/mycompany/mypkg/*.class
```
要想更新一个已有的JAR文件的清单，则需要将增加的部分放置到一个文本文件中，然后执行以下命令：
```bash
jar ufm MyArchive.jar manifest-additions.mf
```
> 注释：参看[JAR File Specification](https://docs.oracle.com/javase/10/docs/specs/jar/jar.html)获取有关JAR文件和清单文件格式的更多信息。

## 4.8.3 可执行JAR文件
可以使用 `jar` 命令中的 `e` 选项，指定程序的**入口点** `entry point` ，即调用java程序启动器时通常指定的类：
```java
jar cvfe MyProgram.jar com.mycompany.mypkg.MainAppClass files_to_add
```
或者，可以在清单文件中指定程序的**主类**，包括以下形式的语句：
```java
Main-Class: com.mycompany.mypkg.MainAppClass
```
不要为主类名增加扩展名 `.class` 。
> 警告：清单文件的最后一行必须以换行符结束。否则，清单文件将无法被正确地读取。常见的一个错误是，创建了一个只包含 `Main-Class` 行、而没有行结束符的文本文件。

不论使用哪一种方法，用户可以简单地**通过下面的命令来启动程序**：
```bash
$ java -jar MyProgram.jar
```
取决于操作系统的配置，用户甚至可以**通过双击JAR文件图标、来启动应用程序**。下面是各种操作系统的操作方式：
- 在Windows平台中，Java运行时安装程序将为 `.jar` 扩展名创建一个文件关联，会用 `javaw -jar` 命令启动文件（与 `java` 命令不同，`javaw` 命令不打开Shell窗口）。
- 在Mac OS X平台中，操作系统能够识别 `.jar` 扩展名文件。双击JAR文件时，就会执行Java程序。

不过，人们对JAR文件中的Java程序，与原生应用还是感觉不同。在Windows平台中，可以使用第三方的包装器工具、将JAR文件转换成Windows可执行文件。包装器是一个Windows程序，有大家熟悉的扩展名 `.exe` ，它可以查找和加载Java虚拟机，或者在没有找到JVM时、告诉用户应该做些什么。有许多商业的和开源的产品，如[Launch4J](http://launch4j.sourceforge.net)和[IzPack](http://izpack.org)。

## 4.8.4 多版本JAR文件
随着模块和包强封装的引入，之前可以访问的一些内部API不再可用。例如，JavaFX 8有一个内部类 `com.sun.javafx.css.CssParser` 。如果用它解析一个样式表，会发现我们的程序不能再正常编译了。补救很简单，只需要改用Java 9提供的 `javafx.css.CssParser` 。不过这样会有一个问题，即需要向Java 8和Java 9用户发布不同的应用程序，或者需要利用**类加载和反射**等一些技巧。

为了解决类似这样的问题，Java 9引入了**多版本JAR** `multi-release JAR` ，其中可以包含面向不同Java版本的类文件。

为了保证向后兼容 *backwards compatibility* ，额外的类文件放在 `META-INF/versions` 目录中：
```java
Application.class
BuildingBlocks.class
Util.class
META-INF
├─ MANIFEST.MF (with line Multi-Release: true)
├─ versions
├─ 9
│ ├─ Application.class
│ └─ BuildingBlocks.class
└─ 10
  └─ BuildingBlocks.class
```
假设 `Application` 使用了 `CssParser` 类，那么遗留版本的 `Application.class` 文件的可以使用 `com.sun.javafx.css.CssParser` ，而Java 9版本可以使用 `javafx.css.CssParser` 。Java 8完全不知道 `META-INF/versions` 目录，它只会加载遗留的类；Java 9读取这个JAR文件时，则会使用新版本。

要增加不同版本的类文件，可以使用 `--release` 标志：
```bash
$ jar uf MyProgram.jar --release 9 Application.class
```
要从头构建一个多版本JAR文件，可以**使用 `-C` 选项，对应每个版本要切换到一个不同的类文件目录**：
```bash
$ jar cf MyProgram.jar -C bin/8 . --release 9 -C bin/9 Application.class
```
面向不同版本编译时，要使用 `--release` 标志和 `-d` 标志来指定输出目录：
```bash
$ javac -d bin/8 --release 8 ...
```
在Java 9中，`-d` 选项会创建这个目录（如果原先该目录不存在）。**`--release` 标志也是Java 9新增的**。在较早的版本中，要使用 `-source, -target` 和 `-bootclasspath` 标志。JDK现在为之前的两个API版本提供了符号文件（？）。在Java 9中，编译时可以将 `--release` 设置为9、8或7 *you can compile with --release set to 9, 8, or 7* 。

**多版本并不适用于不同版本的程序或库** *Multi-release JARs are not intended for different versions of a program or library* 。对于不同的版本，所有类的公共API都应当是一样的。多版本JAR的唯一目的是，允许你的某个特定版本的程序或库、能在多个不同的JDK版本上运行。如果你增加了功能或者改变了一个API，那就应当提供一个新版本的JAR。
> 注释：`javap` 之类的工具，并没有改造为可以处理多版本JAR文件，如果调用：
> ```bash
> $ javap -classpath MyProgram.jar Application.class
> ```
> 我们会得到类的基本版本（毕竟，它与更新的版本应有相同的公共API）。如果必须查看更新的版本，可以调用：
> ```bash
> $ javap -classpath MyProgram.jar\!/META-INF/versions/9/Application.class
> ```

## 4.8.5 关于命令行选项的说明
Java开发包JDK的命令行选项，一直以来都使用**单个短横线加多字母选项名**的形式，如：
```bash
$ java -jar ...
$ javac -Xlint:unchecked -classpath ...
```
但 `jar` 命令是个例外，这个命令遵循**经典的 `tar` 命令选项格式**、而没有短横线：
```bash
$ jar cvf ...
```

从Java 9开始，Java工具开始转向一种更常见的选项格式，**多字母选项名前面加两个短横线**，另外**对于常用的选项可以使用单字母快捷方式**。例如调用Linux `ls` 命令时，可以提供一个 `human-readable` 选项：
```bash
$ ls --human-readable # or
$ ls -h
```
在Java 9中，可以使用 `--version` 而不是 `-version` ，另外可以使用 `--class-path` 而不是 `-classpath` 。在卷II第9章可看到，`--module-path` 选项有一个快捷方式 `-p` 。

详细内容参见[JEP 293增强请求](http://openjdk.java.net/jeps/293)。在所有清理工作中，作者还提出要标准化选项参数。**带 `--` 和多字母的选项的参数，用空格或一个等号 `=` 分隔**：
```bash
$ javac --class-path /home/user/classdir ... # or
$ javac --class-path=/home/user/classdir ...
```
**单字母选项的参数可以用空格分隔**，或者直接跟在选项后面：
```bash
$ javac -p moduledir ...
$ javac -pmoduledir ...
```
> 警告：后一种方式现在不能使用，而且一般来说这也不是一个好主意。如果模块目录恰好是 `arameters` 或 `rocessor` ，这就很容易与遗留选项发生冲突，这又何必呢？

**无参数的单字母选项可以组合在一起**：
```bash
$ jar -cvf MyProgram.jar -e mypackage.MyProgram */*.class
```
> 警告：目前不能使用这种方式。这肯定会带来混淆。假设 `javac` 有个 `-c` 选项。那么 `javac -cp` 是指 `javac -c -p` 还是遗留的 `-cp` ？

这就会带来一些混乱，希望过段时间可以解决这个问题。尽管我们想要远离这些古老的 `jar` 选项，但最好还是等到尘埃落定为妙。不过，如果想要做到最优化 `be thoroughly modern` ，那么可以**安全地使用 `jar` 命令的长选项**：
```bash
$ jar --create --verbose --file jarFileName file1 file2 ...
```
对于单字母选项，如果不组合，也是可以使用的：
```bash
$ jar -c -v -f jarFileName file1 file2 ...
```

---
# 4.9 文档注释
JDK包含一个很有用的工具，叫做 `javadoc` ，它可以**由源文件生成一个HTML文档**。事实上，在第3章介绍的联机API文档，就是通过对「标准Java类库的源代码」运行 `javadoc` 生成的。

如果在源代码中**添加以专用的定界符 `/**` 开始的注释**，那么可以很容易地生成一个看上去具有专业水准的文档。这是一种很好的方式，因为这样**可以将代码与注释放在一个地方**。如果将文档存入一个独立的文件中，就有可能会随着时间的推移，出现代码和注释不一致的问题。然而，由于文档注释与源代码在同一个文件中，在修改源代码的同时，重新运行 `javadoc` 就可以**轻而易举地保持两者的一致性**。

## 4.9.1 注释的插入
`javadoc` 实用工具从下面几项中抽取信息：
- 模块；
- 包；
- 公共类与接口
- 公共的和受保护的字段；
- 公共的和受保护的构造器及方法。

在第5章中将介绍受保护特性，在第6章将介绍接口，卷II的第9章介绍模块。

可以而且应该为上面几部分编写注释 、注释应该放置在所描述特性的前面。注释以 `/**` 开始，并以 `*/` 结束。

**每个 `/** ... */` 文档注释包含「标记以及之后紧跟的自由格式文本」`free-form text`** 。
- 标记由 `@` 开始，如 `@author` 或 `@param` 。
- **自由格式文本的第一句应该是一个概要性的句子** *summary statement* 。`javadoc` 实用程序自动地将这些句子抽取出来形成概要页 *summary pages* 。
  在自由格式文本中，可以使用HTML修饰符。例如，用于强调的 `<em>...</em>` 、用于着重强调的 `<strong>...</strong>` 、用于项目符号列表 *bulleted lists* 的 `<ul>/<li>` 、以及包含图像的 `<img...>` 等。若要键入等宽代码 *monospaced code* ，需使用 `{@code ... }` 而不是 `<code>...</code>` ——这样一来，就不用操心对代码中的 `<` 字符转义了。
  
 > 注释：**如果文档中有到其他文件的链接**，如图像文件（例如，图表或用户界面组件的图像等），**就应该将这些文件放到「包含源文件的目录下的一个子目录 `doc-files` 」中**。`javadoc` 实用程序将从源目录，将 `doc-files` 目录及其内容、拷贝到文档目录中。在链接中需要使用 `doc-files` 目录，例如：`<img src="doc-files/uml_png” alt="UML diagram">` 。

## 4.9.2 类注释
**类注释必须放在 `import` 语句之后，类定义之前**。下面是一个类注释的例子：
```java
/**
 * A {©code Card} object represents a playing card, such
 * as "Queen of Hearts". A card has a suit (Diamond, Heart,
 * Spade or Club) and a value (1 = Ace, 2 . . . 10, 11 = Jack,
 * 12 = Queen, 13 = King)
 */
public class Card {
	...
}
```
没有必要在每一行的开始用星号 `*` ，如以下注释同样是合法的：
```java
/**
   A <code>Card</code> object represents a playing card, such
   as "Queen of Hearts". A card has a suit (Diamond，Heart ,
   Spade or Club) and a value (1 = Ace, 2 . . . 10, 11 = jack,
   12 = Queen, 13 = King).
 */
```
然而，大部分IDE会自动添加星号 `*` ，并且当换行改变时，自动重新排列这些星号。
## 4.9.3 方法注释
**每一个方法注释必须放在所描述的方法之前**。除了通用标记之外，还可以使用下面的标记：
- `@param variable description` ：这个标记将给当前方法的"parameter"（参数）部分添加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有 `@param` 标记必须放在一起。
- `@return description` ：这个标记将对当前方法添加"return"（返回）部分。这个描述可以跨越多行，并可以使用HTML标记。
- `@throws class description` ：这个标记将添加一个注释，表示这个方法有可能抛出异常。有关异常的详细内容将在第7章中讨论。

下面是一个方法注释的示例：
```java
/* Raises the salary of an employee.
 * @param byPercent the percentage by which to raise the salary (e.g. 10 means 10%)
 * ©return the amount of the raise
 */
public double raiseSal ary(double byPercent) {
	double raise = salary * byPercent / 100;
	salary += raise;
	return raise;
```

## 4.9.4 注释
**只需要对公有字段（通常指的是静态常量）建立文档**。例如：
```java
/**
 * The "Hearts" card suit
 */
public static final int HEARTS = 1;
```
## 4.9.5 通用注释
下面的标记可以用于所有的文档注释中。
- `@since text` ：建立一个 `since`（始于）条目。`text`（文本）可以是引入这个特性的版本的任何描述，例如 `@since 1.7.1` 。
- `@deprecated text` ：这个标记将**对类、方法或变量添加一个不再使用的注释**。文本中给出了取代的建议。例如，`@deprecated Use <code> setVIsible(true) </code> instead` 。

通过 `@see` 和 `@link` 标记，可以使用超链接，链接到 `javadoc` 文档的相关部分或外部文档。`@see reference` 将在"see also"（参见）部分增加一个超级链接。它可以用于类中，也可以用于方法中。这里的 `reference` 可以有如下选择：
```java
package.class#feature label
<a href="...">label</a>
"text"
```
第一种情况是最常见的。**只要提供类、方法或变量的名字，`javadoc` 就在文档中插入一个超链接**。例如，
```java
@see com.horstraann.corejava.Employee#raiseSalary(double)
```
这会建立一个链接到 `com.horstmann.corejava.Employee` 类的 `raiseSalary(double)` 方法的超链接。==可以省略包名，甚至把包名和类名都省去，此时，链接将定位于当前包或当前类中==。
> 需要注意，一定要使用 `#` ，而不要使用 `.` 分隔类名与方法名，或类名与变量名。Java编译器本身可以熟练地断定句点在分隔包、子包、类、内部类与方法和变量时的不同含义。但是 `javadoc` 工具就没有这么聪明了，因此必须对它提供帮助。

**如果@see 标记后面有一个 `<` 字符，就需要指定一个超链接。可以超链接到任何URL**。例如：
```java
@see <a href="www.horstmann.com/corejava.html">The Core ]ava home page</a>
```
在上述各种情况下，都可以指定一个可选的标签 `label` 作为链接锚 `link anchor` 。如果省略了 `label` , 用户看到的锚的名称就是目标代码名或URL。

如果 `@see` 标记后面有一个双引号 `"` 字符，文本就会显示在"see also"部分。例如，
```java
@see "Core Java 2 volume 2
```
**可以为一个特性添加多个 `@see` 标记，但必须将它们放在一起**。

如果愿意的话，还可以在文档注释中的任何位置，放置指向其他类或方法的超链接。可以在注释中的任何位置，插入一个形式如下的特殊标记，例如：
```java
{@link package.class#feature label ]
```
这里的特性描述规则与 `@see` 标记的规则一样。

下面的标/记可以用在类文档的注释中。
- `@author name` ：这个标记将产生一个"author"（作者）条目。可以使用多个 `@author` 标记，每个 `@author` 标记对应一个作者。**并不是非得使用这个标记，版本控制系统能够更好地跟踪作者**。
- `@version text`：这个标记将产生一个"version"（版本）条目。这里的文本可以是对当前版本的任何描述。

## 4.9.6 包概述
可以直接将类、方法和变量的注释放置在Java源文件中，只要用 `/** ... */` 文档注释界定就可以了。但是，**要想产生包注释，就需要在每一个包目录中添加一个单独的文件**。可以有如下两个选择：
1. 提供一个以 `package.html` 命名的HTML文件。在标记 `<body>...</body>` 之间的所有文本都会被抽取出来。
2. 提供一个以 `package-info.java` 命名的Java文件。这个文件必须包含一个初始的以 `/**` 和 `*/` 界定的 `javadoc` 注释，后面是一个 `package` 语句。它不应包含更多的代码或注释。

还可以为所有的源文件提供一个概述性的注释。这个注释将被放置在一个名为 `overview.html` 的文件中，这个文件位于包含所有源文件的父目录中。标记 `<body>...</body>` 间的所有文本将被抽取出来。当用户从导航栏中选择"Overview"时，就会显示出这些注释内容。

## 4.9.7 注释的抽取
这里，假设HTML文件将被放在目录 `docDirectory` 下。执行以下步骤：
1. **切换到包含「想要生成文档的源文件」的目录**。如果有嵌套的包要生成文档，例如 `com.horstmann.corejava` ，就必须切换到「包含子目录 `com` 的目录」（如果存在 `overview.html` 文件的话，这也是它的所在目录）。
2. 如果是一个包，应该运行命令:
   ```bash
   $ javadoc -d docDirectory nameOfPackage
   ```
   或者，如果要为多个包生成文档，运行:
   ```bash
   $ javadoc -d docDirectory nameOfPackage1 nameOfPackage2 ...
   ```
   如果文件在默认包中，就应该运行：
   ```bash
   $ javadoc -d docDirectory *.java
   ```
   如果省略了 `-d docDirectory` 选项，那HTML文件就会被提取到当前目录下。这样有可能会带来混乱，因此不提倡这种做法。

可以使用很多命令行选项，对 `javadoc` 程序进行 *fine-tuned* 。例如：
- 可以使用 `-author` 和 `-version` 选项，在文档中包含 `@author` 和 `@version` 标记（默认情况下，这些标记会被省略）。
- 另一个很有用的选项是 `-link` ，用来为标准类添加超链接。如果使用如下命令，那么，所有的标准类库类都会自动地链接到Oracle网站的文档。
  ```bash
  $ javadoc -link http://docs.oracle.com/javase/8/docs/api *.java
  ```
- 如果使用 `-linksource` 选项，则每个源文件将会转换为HTML（不对代码着色，但包含行号），并且每个类和方法名将转变为指向源代码的超链接。
- 使用 `-overview filename` 选项，将抽取 `overview.html` 文件中标记 `<body>...</body>` 之间的所有文本。

有关其他的选项，查阅 `javadoc` 工具的[联机文档](https://docs.oracle.com/javase/9/javadoc/javadoc.htm)。
> 注释：如果需要进一步的定制，例如生成非HTML格式的文档，可以提供自定义的
`doclet` ，以便生成想要的任何输出形式。显然，这是一种特殊的需求，有关细节内容查阅联机文档。

---
# 4.10 类设计技巧
结束之前先简单介绍几点技巧。应用这些技巧，可以使我们设计的类得到专业OOP圈子的认可。
1. **一定要保证数据私有**
这是最重要的；绝对不要破坏封装性。有时，可能需要编写一个访问器方法或更改器方法，
但最好还是保持实例字段的私有性。很多惨痛的经验告诉我们，数据的表示形式很可能会改
变，但它们的使用方式却不会经常变化。==当数据保持私有时，表示形式的变化不会对类的使用者产生影响，即使出现Bug也易于检测==。
2. **一定要对数据初始化**
Java不对局部变量进行初始化，但会对对象的实例字段进行初始化。==最好不要依赖于系统的默认值，而应显式地初始化所有的数据==，具体的初始化方式可以是提供默认值，也可以是在所有构造器中设置默认值。
3. **不要在类中使用过多的基本类型**
就是说，**用其他的类代替多个相关的基本类型的使用**。这样会使类更加易于理解且易于
修改。例如，用一个名为 `Address` 的新类替换一个 `Customer` 类中以下的实例域：
   ```java
   private String street;
   private String city;
   private String state;
   private int zip;
   ```
这样，可以很容易地处理地址的变化。例如，可能需要增加对国际地址的处理。
4. **不是所有的字段都需要单独的字段访问器和更改器**
可能需要获得或设置员工的薪金。而一旦构造了员工对象，就应该禁止更改雇用日期。另外在对象中，常常包含一些不希望别人获得或设置的实例域，例如，在 `Address` 类中，存放州缩写的数组。
5. **分解职责过多的类**
这样说似乎有点含糊，究竟多少算是“过多” ？ 每个人的看法不同。但是，如果明显地可以将一个复杂的类分解成两个更为简单的类，就应该将其分解（但另一方面，也不要走极端。设计10个类，每个类只有一个方法，显然有些矫枉过正了）。

下面是一个反面的设计示例。
```java
public class CardDeck { // bad design
	private int[] value;
	private int[] suit;
	
	public CardDeck() { ... }
	public void shuffle() { ... }
	public int getTopValue() { ... }
	public int getTopSuit() { ... }
    public void draw() { ... }
}
```
实际上，这个类实现了两个独立的概念：一副牌（含有 `shuffle` 方法和 `draw` 方法）和一
张牌（含有查看面值和花色的方法）。另外，引入一个表示单张牌的 `Card` 类。现在有两个类，每个类完成自己的职责：
```java
public class CardDeck {
	private Card[] cards;
	public CardDeck() { ... }
	public void shuffle() { ... }
	public Card getTop() { ... }
	public void draw() { ... }
}
public class Card {
	private int value;
	private int suit;
	public Card(int aValue, int aSuit) { ... }
	public int getValue() { ... }
	public int getSuit() { ... }
}
```
6. **类名和方法名要能够体现它们的职责**
与变量应该有一个能反映其含义的名字一样，类也应该如此（在标准类库中，也存在着一些含义不明确的例子，如 `Date` 类实际上是一个用于描述时间的类）。
命名类名的良好习惯是，采用一个**名词**（如 `Order` ），或者**前面有形容词修饰的名词**（如 `RushOrder` ），或者是**由动名词（有"-ing"后缀）修饰的名词**（如 `BillingAddress` ）。对于方法来说，习惯是访问器方法用小写 `get` 开头，更改器方法用小写的 `set` 开头。
7. **优先使用不可变的类**
**`LocalDate` 类以及 `java.time` 包中的其他类是不可变的**——没有方法能修改对象的状态。类似 `plusDays` 的方法并不是更改对象，而是返回状态已修改的新对象。更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预料的。==如果类是不可变的，就可以安全地在多个线程间共享其对象==。
因此，要尽可能让类是不可变的，这是一个很好的想法。对于表示值的类，如一个字符
串或一个时间点，这尤其容易。计算会生成新值，而不是更新原来的值。当然，并不是所有类都应当是不可变的。如果员工加薪时让 `raiseSalary` 方法返回一个新的 `Employee` 对象，这会很奇怪。

本章介绍了Java这种"基于对象"语言的有关对象和类的基础知识。为了真正做到面向对象，程序设计语言还必须支持继承和多态。Java提供了对这些特性的支持，具体内容将在下章中介绍。