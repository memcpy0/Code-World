▲类加载器
▲安全管理器与访问权限
▲用户认证
▲数字签名
▲加密
▲字节码校验

当Java技术刚刚问世时，令人激动的并不是因为它是一个设计完美的编程语言，而是因为它能安全运行通过因特网传播的各种applet。显然，只有当用户确信applet的代码不会破坏他的计算机时，才会接受在网上传播的可执行的applet。正因如此，无论过去还是现在，安全都是设计人员和Java技术使用者关心的一个重大问题。这就意味着，Java技术与其他的语言和系统有所不同，在那些语言和系统中、安全是在事后才想到要去实现的，或仅仅是对破坏的一种应对措施，而**对Java技术来说，安全机制是一个不可分割的组成部分**。

Java技术提供了以下三种确保安全的机制：
- **语言设计特性**（对数组边界进行检查，没有不受检查的类型转换，无指针算法等）。
- **访问控制机制**，用于控制代码能执行的操作（比如文件访问，网络访问等）。
- **代码签名** *code signing* ，利用该特性，代码的作者就能用标准的加密算法来认证Java代码。这样，该代码的使用者就能准确地知道：谁创建了该代码、以及代码被签名后是否被修改过。

首先，我们来讨论类加载器，它可以在将类加载到虚拟机中时检查类的完整性。我们将展示这种机制是如何探测类文件中的损坏的。

==为了获得最大的安全性，无论是默认的加载类机制、还是自定义的类加载器，都要与「负责控制代码运行 *controls what actions code can
perform* 的安全管理器类」协同工作==。后面要详细介绍如何配置Java平台的安全性 *Java platform security* 。

最后，介绍 `java.security` 包提供的加密算法，用来进行代码签名和用户身份认证。

与一贯宗旨一样，重点介绍应用程序编程人员最感兴趣的话题。如果要深入研究，推荐阅读 *Inside Java 2 Platform Security: Architecture, API Design, and Implementation, Li Gong, Gary Ellison, Mary Dageforde* 一书。

---
# 22.1 加载器
一个Java编译器将源指令转换为Java虚拟机的代码 *A Java compiler converts source instructions into code for the Java virtual machine* 。虚拟机代码存储在以 `.class` 为扩展名的类文件中，==每个类文件都包含某个类或者接口的定义和代码实现。这些类文件必须由一个程序进行解释，该程序能将虚拟机的指令集翻译成目标机器的机器语言==。下面看到虚拟机是如何加载这些类文件的。
## 22.1.1 类加载过程
注意，**虚拟机只加载程序执行时所需要的类文件**。例如，假设程序从 `MyProgram.class` 开始运行，下面是虚拟机执行的步骤：
1. 虚拟机有一个用于加载类文件的机制，例如，从磁盘上读取文件或请求Web上的文件;它使用该机制来加载 `MyProgram` 类文件中的内容。
2. **如果 `MyProgram` 类拥有类型为另一个类的域，或是拥有超类，那么这些类文件也会被加载**（加载某个类所依赖的所有类的过程，称为类的解析 *resolving the class* ）。
3. 接着，虚拟机执行 `MyProgram` 中的 `main` 方法（它是静态的，无需创建类的实例）。
4. **如果 `main` 方法或 `main` 调用的方法要用到更多的类，那么接下来就会加载这些类**。

然而，**类加载机制并非只使用单个的类加载器。每个Java程序至少拥有三个类加载器**：
- 引导类加载器 *bootstrap class loader* 
- 平台类加载器 *platform class loader*
- 系统类加载器 *system class loader*（有时也称为应用类加载器 *application class loader* ）

~~引导类加载器负责加载系统类（通常从JAR文件rt.jar中进行加载）。它是虚拟机不可分割的一部分，且通常是用C语言来实现的~~。==引导类加载器负责加载「包含在下列模块、以及大量的JDK内部模块」中的**平台类** *platform classes*== ：
```java
java.base
java.datatransfer
java.desktop
java.instrument
java.logging
java.management
java.management.rmi
java.naming
java.prefs
java.rmi
java.security.sasl
java.xml
```
**引导类加载器没有对应的 `ClassLoader` 对象**，例如，该方法 `StringBuilder.class.getClassLoader()` 将返回 `null` 。在Java 9之前，Java平台类位于 `rt.jar` 中。==如今Java平台是模块化的，每个平台模块都被包含在一个JMOD文件中==（[[21.Java平台模块系统]]），**平台类加载器会加载引导类加载器没有加载的Java平台中的所有类** *The platform class loader loads all classes of the Java platform that are not loaded by the bootstrap class loader* 。

在Java 9之前，扩展类加载器会加载 `jre/lib/ext` 目录中的“标准扩展”——可以将JAR文件放入该目录，这样即使没有任何类路径，扩展类加载器也可以找到其中的各个类（有些人曾推荐使用该机制来避免“可恶的类路径”），而“授权标准覆盖 *endorsed standards override*” 机制提供了一种方式，可以用更新的版本来覆盖某些旧的平台类（包括CORBA和XML的实现），**这两种机制都被移除了**。

**系统类加载器用于从模块路径和类路径中加载应用类**。它在由CLASSPATH环境变量或者-classpath命令行选项设置的类路径中的目录里或者是JAR/ZIP文件里查找这些类。

## 22.1.1 类加载器的层次结构
==类加载器有一种父/子关系。除了引导类加载器外，每个类加载器都有一个父类加载器==。根据规定，==类加载器会为它的父类加载器提供一个机会，以便加载任何给定的类，并且只有在其父类加载器加载失败时，它才会加载该给定类==。例如，当要求系统类加载器加载一个系统类（比如 `java.util.ArrayList` ）时，它首先要求平台类加载器进行加载，该类加载器则首先要求引导类加载器进行加载。引导类加载器会查找并加载这个类，而无须其他类加载器做更多的搜索。

某些程序具有插件架构 *plugin architecture* ，其中代码的某些部分是作为可选的插件被打包的。如果插件被打包为JAR文件，那就可以直接用 `URLClassLoader` 类的实例去加载这些类。
```java
var url = new URL("file:///path/to/plugin.jar");
var pluginLoader = new URLClassLoader(new URL[] { url });
Class<?> cl = pluginLoader.loadClass("mypackage.MyClass");
```
因为在 `URLClassLoader` 构造器中没有指定父类加载器，因此 `pluginLoader` 的父亲就是系统类加载器。图22-1展示了这种层次结构。
![图22-1 类加载器的层次结构](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212080930046.png)
> 警告：在Java 9之前，系统类加载器是 `URLClassLoader` 类的实例。有些程序员会使用强制转型来访问其 `getURLs` 方法，或者通过反射机制调用受保护的 `addURLs` 方法、将JAR文件添加到类路径中，现在无法这样操作了。

大多数时候，你不必操心类加载的层次结构。通常，类是由于其他的类需要它而被加载的，而这个过程对你是透明的。偶尔，**你也会需要干涉和指定类加载器**。考虑下面的例子：
- 你的应用的代码包含一个助手方法，它要调用 `Class.forName(classNameString)` `。
- 这个方法是从一个插件类中被调用的。
- 而 `classNameString` 指定的正是一个包含在这个插件JAR中的类。

插件的作者很合理地期望这个类应被加载。但助手方法的类是由系统类加载器加载的，这正是 `Class.forName` 所使用的类加载器。而对于它来说，在插件JAR中的类是不可视的，这种现象称为**类加载器倒置** *classloader inversion*  。

要解决这个问题，助手方法需要使用恰当的类加载器，它可以要求类加载器作为其一个参数传递给它。或者，它可以要求将恰当的类加载器设置成为当前线程的上下文类加载器 *context class loader* ，这种策略在许多框架中都得到了应用（例如JAXP和JNDI框架）。

==每个线程都有一个对类加载器的引用，称为上下文类加载器。主线程的上下文类加载器是系统类加载器==。当新线程创建时，它的上下文类加载器会被设置成为创建线程的上下文类加载器 *the creating thread’s context class loader* 。因此，==如果你不做任何特殊的操作，那么所有线程就都将它们的上下文类加载器设置为系统类加载器==。但，我们也可以通过下面的调用，将其设置成为任何类加载器。
```java
Thread t = Thread.currentThread();
t.setContextClassLoader(loader);
```
然后助手方法可以获取这个上下文类加载器：
```java
Thread t = Thread.currentThread();
ClassLoader loader = t.getContextClassLoader();
Class<?> cl = loader.loadClass(className);
```
> 当上下文类加载器设置为插件类加载器时，问题依旧存在。应用设计者必须作出决策：通常，当调用由不同的类加载器加载的插件类的方法时，进行上下文类加载器的设置是一种好的思路;或者，让助手方法的调用者设置上下文类加载器。（还正确吗？）

如果你编写了一个按名字来加载类的方法，那么让调用者在传递显式的类加载器和使用上下文类加载器之间进行选择就是一种好的做法。**不要直接使用该方法所属的类的类加载器**。

## 22.1.2 将类加载器作为命名空间
每个Java程序员都知道，包的命名是为了消除名字冲突。在标准类库中，有两个名为 `Date` 的类，它们的实际名字分别为 `java.util.Date` 和 `java.sql.Date` 。使用简单的名字只是为了方便程序员，它们要求程序包含恰当的 `import` 语句。在一个正在执行的程序中，所有的类名都包含它们的包名。

然而，令人惊奇的是，==在同一个虚拟机中，可以有两个类，它们的类名和包名都是相同的。类是由它的全名和类加载器来确定的。这项技术在加载来自多处的代码时很有用==。例如，应用服务器会为每个应用都使用一个独立的类加载器类，这样虚拟机就能区分来自不同应用的各个类，而不用管它们是怎么命名的。图22-2展示了一个实例。假设有一个应用服务器加载了两个不同的应用，它们都有一个名为 `Util` 的类，因为每个类都是由单独的类加载器加载的，因此这些类可以彻底地区分开、而没有任何冲突。
![图22-2 两个类加载器分别加载具有相同名字的两个类](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212081029817.png)
> 注意：这种技术还有其他用处，例如servlets和EJB的“热部署”。详细信息请访问http://zeroturnaround.com/labs/rjc301。（还有用吗？）

## 22.1.3 编写自己的类加载器
==我们可以编写自己的、用于特殊目的的类加载器，这使我们可以在向虚拟机传递字节码之前执行定制的检查==。例如，我们可以编写一个类加载器，它可以拒绝加载没有标记为“paid for”的类。

如果要编写自己的类加载器，只需要继承 `ClassLoader` 类，然后覆盖下面这个方法：
```java
findClass(String className)
```
`ClassLoader` 超类的 `loadClass` 方法负责向父类的委托（用于将类的加载操作委托给其父类加载器去进行），只有当类尚未加载、并且父类加载器也无法加载该类时，才调用 `findClass` 方法。

如果要实现该方法，必须做到以下几点：
1. 为来自本地文件系统 *local fiel system* 或其他来源的类加载其字节码。
2. 调用 `ClassLoader` 超类的 `defineClass` 方法，向虚拟机提供字节码 *present the bytecodes to the virtual machine* 。

在 `classLoader/ClassLoaderTest.java` 中，我们实现了一个类加载器，用于加载加密过的类文件。该程序要求用户输入第一个要加载的类的名字（即包含 `main` 方法的类）和密钥。然后，使用一个专门的类加载器来加载指定的类、并调用 `main` 方法。该类加载器对指定的类、和所有被其引用的**非系统类**进行解密。最后，该程序调用已加载类的 `main` 方法（参见图22-3）。
![图22-3 ClassLoaderTest程序](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212081100778.png)

为了简单起见，我们忽略了密码学领域2000年来所取得的技术进展，而是采用了传统的Caesar密码对类文件进行加密。我们的Caesar密码版本使用的密钥是从1~255之间的一个数字，解密时，只需将密钥与每个字节相加，然后对256取余。**`Caesar.java` 程序就实现了这种加密行为**。为了不与常规的类加载器相混淆，我们对加密的类文件使用了不同的扩展名 `.caesar` 。
> 注意：*The Code breakers, David Kahn, Macmillan Press, 1967* ，原书第84页中称 *Suetonius* 是Caesar密码的发明人。Caesar将罗马字母表的24个字母移动了3个字母的位置，在那个时代这可以迷惑对手。
> 作者第一次撰写Core Java这一章时，美国政府限制高强度加密方法的出口。因此，在实例中使用的是Caesar的加密方法，因为该方法的出口显然是合法的。

解密时，类加载器只需要将每个字节减去该密钥即可。在程序代码中，可以找到4个类文件，它们都是用“3”这个传统的密钥值进行加密的。为了运行被加密的程序 *run the encrypted program* ，需要使用在我们的 `ClassLoaderTest` 程序中定义的定制类加载器。
```java
// classLoader/ClassLoaderTest.java
package classLoader;

import java.io.*;
import java.lang.reflect.*;
import java.nio.file.*;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * This program demonstrates a custom class loader that decrypts class files.
 */
public class ClassLoaderTest {
	public static void main(String[] args) {
		EventQueue.invokeLater(() -> {
			var frame = new ClassLoaderFrame();
			frame.setTitle("ClassLoaderTest");
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}
}

/**
 * This frame contains two text fields for the name of the class to load and the decryption key.
 */
class ClassLoaderFrame extends JFrame {
	private JTextField keyField = new JTextField("3", 4);
	private JTextField nameField = new JTextField("Calculator", 30);
	private static final int DEFAULT_WIDTH = 300;
	private static final int DEFAULT_HEIGHT = 200;

	public ClassLoaderFrame() {
		setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);
		setLayout(new GridBagLayout());
		add(new JLabel("Class"), new GBC(0, 0).setAnchor(GBC.EAST));
		add(nameField, new GBC(1, 0).setWeight(100, 0).setAnchor(GBC.WEST));
		
		add(new JLabel("Key"), new GBC(0, 1).setAnchor(GBC.EAST));
		add(keyField, new GBC(1, 1).setWeight(100, 0).setAnchor(GBC.WEST));

		var loadButton = new JButton("Load");
		add(loadButton, new GBC(0, 2, 2, 1));
		loadButton.addActionListener(event -> runClass(nameField.getText(), keyField.getText()));

		pack();
	}

	/**
	 * Runs the main method of a given class.
	 * @param name the class name
	 * @param key the decryption key for the class files
	 */
	public void runClass(String name, String key) {
		try {
			var loader = new CryptoClassLoader(Integer.parseInt(key));
			Class<?> c = loader.loadClass(name);
			Method m = c.getMethod("main", String[].class);
			m.invoke(null, (Object) new String[] {} );
		} catch (Throwable t) {
			JOptionPane.showMessageDialog(this, t);
		}
	}
}

/**
 * This class loader loads encrypted class files.
 */
class CryptoClassLoader extends ClassLoader {
	private int key;
	/**
	 * Constructs a crypto class loader.
	 * @param k the decryption key
	 */
	public CryptoClassLoader(int k) { key = k; }

	protected Class<?> findClass(String name) throws ClassNotFoundException {
		try {
			byte[] classBytes = null;
			classBytes = loadClassBytes(name);
			Class<?> cl = defineClass(name, classBytes, 0, classBytes.length);
			if (cl == null) throw new ClassNotFoundException(name);
			return cl;
		} catch (IOException e) {
			throw new ClassNotFoundException(name);	
		}
	}

	/** 
	 * Loads and decrypt the class file bytes.
	 * @param name the class name
	 * @return an array with the class file bytes
	 */
	private byte[] loadClassBytes(String name) throws IOException {
		String cname = name.replace('.', '/') + ".caesar";
		byte[] bytes = Files.readAllBytes(Paths.get(cname));
		for (int i = 0; i < bytes.length; ++i)
			bytes[i] = (byte) (bytes[i] - key);
			return bytes;
	}
}
```
```java
// classLoader/Caesar.java
package classLoader;

import java.io.*;

/**
 * Encrypts a file using the Caesar cipher.
 */
public class Caesar {
	public static void main(String[] args) throws Exception {
		if (args.length != 3) {
			System.out.println("USAGE: java classLoader.Caesar in out key");
			return;
		}
		try (var in = new FileInputStream(args[0]);
			 var out = new FileOutputStream(args[1])) {
			int key = Integer.parseInt(args[2]);
			int ch;
			while ((ch = in.read()) != -1) {
				byte c = (byte) (ch + key);
				out.write(c);
			}
		}
	}
}
```
```java
package classLoader;

/*
GBC - A convenience class to tame the GridBagLayout

Copyright (C) 2002 Cay S. Horstmann (http://horstmann.com)

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

import java.awt.*;

/**
   This class simplifies the use of the GridBagConstraints
   class.
*/
public class GBC extends GridBagConstraints 
{
   /**
      Constructs a GBC with a given gridx and gridy position and
      all other grid bag constraint values set to the default.
      @param gridx the gridx position
      @param gridy the gridy position
   */
   public GBC(int gridx, int gridy)
   {
      this.gridx = gridx;
      this.gridy = gridy;
   }

   /**
      Constructs a GBC with given gridx, gridy, gridwidth, gridheight
      and all other grid bag constraint values set to the default.
      @param gridx the gridx position
      @param gridy the gridy position
      @param gridwidth the cell span in x-direction
      @param gridheight the cell span in y-direction
   */
   public GBC(int gridx, int gridy, int gridwidth, int gridheight)
   {
      this.gridx = gridx;
      this.gridy = gridy;
      this.gridwidth = gridwidth; 
      this.gridheight = gridheight; 
   }

   /**
      Sets the anchor.
      @param anchor the anchor value
      @return this object for further modification
   */
   public GBC setAnchor(int anchor) 
   { 
      this.anchor = anchor; 
      return this;
   }
   
   /**
      Sets the fill direction.
      @param fill the fill direction
      @return this object for further modification
   */
   public GBC setFill(int fill) 
   { 
      this.fill = fill; 
      return this;
   }

   /**
      Sets the cell weights.
      @param weightx the cell weight in x-direction
      @param weighty the cell weight in y-direction
      @return this object for further modification
   */
   public GBC setWeight(double weightx, double weighty) 
   { 
      this.weightx = weightx; 
      this.weighty = weighty; 
      return this;
   }

   /**
      Sets the insets of this cell.
      @param distance the spacing to use in all directions
      @return this object for further modification
   */
   public GBC setInsets(int distance) 
   { 
      this.insets = new Insets(distance, distance, distance, distance);
      return this;
   }

   /**
      Sets the insets of this cell.
      @param top the spacing to use on top
      @param left the spacing to use to the left
      @param bottom the spacing to use on the bottom
      @param right the spacing to use to the right
      @return this object for further modification
   */
   public GBC setInsets(int top, int left, int bottom, int right) 
   { 
      this.insets = new Insets(top, left, bottom, right);
      return this;
   }

   /**
      Sets the internal padding
      @param ipadx the internal padding in x-direction
      @param ipady the internal padding in y-direction
      @return this object for further modification
   */
   public GBC setIpad(int ipadx, int ipady) 
   { 
      this.ipadx = ipadx; 
      this.ipady = ipady; 
      return this;
   }
}
```
（这里我将 `Calculator.caesar` 及其几个 `Panel, Frame` 文件，都移到了 `22.Security` 目录一层，才运行成功）直接运行 `ClassLoaderTest.java` ，结果如下，它读入输入框中的类名和密钥，然后运行密钥创建自定义类加载器的对象，再用该对象加载指定类，调用指定类对象的 `main` 方法：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212082117833.png)
 ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212082117659.png)
对上面的 `Caesar.java` 直接运行，会打印用法。使用命令行运行如下：
```bash
22.Security/bin$ java classLoader.Caesar classLoader/GBC.class classLoader/GBC.caesar 2
```

==对类文件进行加密有很多用途==（当然，使用的密码的强度应高于Caesar密码），==如果没有解密密钥 *Without the decryption key* ，类文件就毫无用处。它们既不能由标准虚拟机来执行，也不能轻易地被反汇编==。这就是说，可以使用定制的类加载器来认证类用户的身份，或确保程序在被允许运行之前、已支付了软件费用。当然，==加密只是定制类加载器的应用之一。可以使用其他类型的加载器来解决别的问题，例如，将类文件存储到数据库中==。

> [API] `java.lang.Class` 1.0
> - `ClassLoader getClassLoader()`
> 获取加载该类的类加载器。

> [API] `java.lang.ClassLoader` 1.0
> - `ClassLoader getParent()` 1.2
> 返回父类加载器，如果父类加载器是引导类加载器，则返回 `null` 。
> - `static ClassLoader getSystemClassLoader()` 1.2
> **获取系统类加载器，即用于加载第一个应用类的类加载器**。
> - `protected Class findClass(String name)` 1.2
> **类加载器应覆盖该方法，以查找类的字节码，并通过调用 `defineClass` 方法将字节码传给虚拟机**。在类的名字中，**使用 `.` 作为包名分隔符，并且不使用 `.class` 后缀**。
> - `Class defineClass(String name, byte[] byteCodeData, int offset, int length)`
> **将一个新的类添加到虚拟机中**，其字节码在给定的数据范围中。

> [API] `java.net.URLClassLoader` 1.2
> - `URLClassLoader(URL[] urls)`
> - `URLClassLoader(URL[] urls, ClassLoader parent)`
> 构建一个类加载器，它可以从给定的URL处加载类。如果URL以 `/` 结尾，那么它表示的一个目录，否则它表示的是一个JAR文件。

> [API] `java.lang.Thread` 1.0
> - `ClassLoader getContextClassLoader()` 1.2
> 获取类加载器，该线程的创建者将其指定为执行该线程时最适合使用的类加载器。
> - `void setContextClassLoader(ClassLoader loader)` 1.2
> 为该线程中的代码设置一个类加载器，以获取要加载的类。如果在启动一个线程时没有显式地设置上下文类加载器，则使用父线程的上下文类加载器。

---
# 22.2 字节码校验
==当类加载器将「新加载的Java平台类的字节码」传递给虚拟机时，这些字节码首先要接受校验器 *verifier* 的校验==。校验器负责检查那些指令无法执行的、明显有破坏性的操作。**除了系统类外，所有的类都要被校验**。

下面是校验器执行的一些检查：
- 变量要在使用之前进行初始化。
- 方法调用与对象引用类型之间要匹配 *Method calls match the types of object references* 。
- 访问私有数据和方法的规则没有被违反。
- 对本地变量的访问都落在运行时堆栈内。
- 运行时堆栈没有溢出。

如果以上这些检查中任何一条没有通过，那么该类就被认为遭到了破坏，并且不予加载。
> 注意：如果熟悉Gödel的定理，那么可能想知道，校验器究竟是如何证明某个类文件不存在类型不匹配、变量没有初始化和堆栈溢出等问题的。==根据Gödel的定理，你不可能设计出这样的算法：它能处理程序文件，并确定输入的程序是否有特定的属性（比如不出现堆栈溢出问题）==。这是否属于Oracle公司的公共关系部门和逻辑法则之间的矛盾呢？不——事实上，校验器并非是一个Gödel意义上的决策算法。**如果校验器接受了一个程序，那么该程序就确实是安全的**。然而，也有许多程序尽管是安全的，但却被校验器拒绝了（在被强制用哑元值 *dummy* 来初始化一个变量时，你会碰到这个问题，因为编译器无法了解这个变量应如何正确地初始化）。

这种严格的校验是出于安全上的考虑，有一些偶然性的错误，比如变量没有初始化，如果这类错误没有被捕获，就很容易地对系统造成严重的破坏。更为重要的是，在因特网这样开放的环境中，你必须保护自己、以防恶意的程序员对你实施攻击，因为他们的目的就是要造成恶劣影响。例如，通过修改运行时堆栈中的值，或向系统对象的私有数据字段写入数据，某个程序就会突破浏览器的安全防线。

可能想知道，为什么要有一个专门的校验器来检查这些特性呢？毕竟，编译器绝不会允许你生成一个这样的类文件：该类文件中有未初始化的变量、或可以通过另一个类来访问该类的某个私有数据字段。实际上，**用Java语言编译器生成的类文件，总是可以通过校验**。然而，类文件中使用的字节码格式是 *well documented* 的，对于具有汇编程序设计经验、并且拥有十六进制编辑器的人来说，要手工地创建一个对Java虚拟机来说、由合法但不安全的指令构成的类文件，是一件非常容易的事情。再次提醒，要记住，==校验器总是在防范被故意篡改的类文件，而不只是检查编译器产生的类文件==。

下面的例子将展示如何创建一个变动过的类文件。我们从 `verifier/VerifierTest.java` 开始。这是一个简单的程序，它调用一个方法，并且显示方法的运行结果。该程序既可以在控制台运行，也可以作为一个applet程序来运行。其中的 `fun` 方法本身只是负责计算1+2。
```java
// verifier/VerifierTest.java
package verifier;

import java.awt.*;

/**
 * This application demonstrates the bytecode verifier of the virtual machine. If you use a
 * hex editor to modify the class file, then the virtual machine should detect the tampering.
 */
public class VerifierTest {
	public static void main(String[] args) {
		System.out.println("1 + 2 == " + fun());
	}

	/**
	 * A function that computes 1 + 2.
	 * @return 3, if the code has not been corrupted.
	 */
	public static int fun() {
		int m;
		int n;
		m = 1;
		n = 2;
		// use hex editor to change to "m = 2" in class file
		int r = m + n;
		return r;
	}
}
```
作为一次实验，尝试编译下面这个对该程序进行修改后的文件。
```java
static int fun() {
	int m;
	int n;
	m = 1;
	m = 2;
	int r = m + n;
	return r;
}
```
在这种情况下，`n` 没有被初始化，它可以是任何随机值。当然，编译器能检测到这个问题、并拒绝编译该程序。如果要建立一个不良的类文件，我们必须得多花点工夫。首先，运行 `javap` 程序，以知晓编译器是如何翻译 `fun` 方法的。下面**这个命令用助记 *mnemonic* 格式显示了类文件中的字节码**：
```bash
$ $ javap -c verifier.VerifierTest
Compiled from "VerifierTest.java"
public class verifier.VerifierTest {
  public verifier.VerifierTest();
    Code:
       0: aload_0
       1: invokespecial #8                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #16                 // Field java/lang/System.out:Ljava/io/PrintStream;
       3: new           #22                 // class java/lang/StringBuilder
       6: dup
       7: ldc           #24                 // String 1 + 2 ==
       9: invokespecial #26                 // Method java/lang/StringBuilder."<init>":(Ljava/lang/String;)V
      12: invokestatic  #29                 // Method fun:()I
      15: invokevirtual #33                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      18: invokevirtual #37                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      21: invokevirtual #41                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      24: return

  public static int fun();
    Code:
       0: iconst_1
       1: istore_0
       2: iconst_2
       3: istore_1
       4: iload_0
       5: iload_1
       6: iadd
       7: istore_2
       8: iload_2
       9: ireturn
}
```
我们使用一个十六进制编辑器，将指令3从 `istore_1` 改为 `istore_0` ，也就是说，局部变量0（即 `m` ）被初始化了两次，而局部变量1（即 `n` ）则根本没有初始化。我们必须知道这些指令的十六进制值，这些值可以从[Java虚拟机规范](https://docs.oracle.com/javase/specs/jvms/sell/html/index.html)中获知，还有书 *The Java Virtual Machine Specification, Tim Lindholm and Frank Yellin* 。
```java
0 iconst_1 04
1 istore_0 3B
2 iconst_2 05
3 istore_1 3C
4 iload_0 1A
5 iload_1 1B
6 iadd 60
7 istore_2 3D
8 iload_2 1C
9 ireturn AC
```
可以使用十六进制编辑器。在图22-4中，可以看到类文件 `VerifierTest.class` 被加载到了Gnome编辑器中，`fun` 方法的字节码已经被选定。
![图22-4 使用十六进制编辑器修改字节码](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212091148509.png)

将3C改为3B并保存类文件。然后设法运行 `VerifierTest` 程序，将会看到下面的出错信息：
```java
Exception in thread "main" java.lang.VerifyError: (class: VerifierTest, method:fun signature:
()I) Accessing value from uninitialized register 1
```
这很好——虚拟机发现了我们所做的修改。现在用 `-noverify` 选项（或者 `-Xverify: none` ）来运行程序：
```bash
$ java -noverify verifier.VerifierTest
```
从表面上看，`fun` 方法似乎返回了一个随机值。但实际上，该值是2与「存储在尚未初始化的变量 `n` 中的值」相加得到的结果。下面是典型的输出结果：
```
1 + 2 == 15102330
```

---
# 22.3 安全管理器与访问权限
==一旦某个类被加载到虚拟机中，并由检验器检查过之后，Java平台的第二种安全机制就会启动，这个机制就是安全管理器==。
## 22.3.1 权限检查
安全管理器是一个**控制具体操作是否被允许执行** *controls whether a specific operation is permitted* 的类。安全管理器负责检查的操作包括以下内容（整个Java类库中还有许多其他类似的检查）：
- 创建一个新的类加载器。
- 退出虚拟机。
- 使用反射访问另一个类的成员。
- 访问本地文件。
- 打开 `socket` 连接。
- 启动打印作业。
- 访问系统剪贴板。
- 访问AWT事件队列。
- 打开一个顶层窗口。

==在运行Java应用程序时，默认的设置是不安装安全管理器的，这样所有的操作都是允许的==。另一方面，applet浏览器会执行一个功能受限的安全策略 *a very restrictive security policy* 。更严格的安全性对其他情况也具有意义。例如，applet不允许退出虚拟机。如果它们试图调用 `exit` 方法，就会抛出一个安全异常。

例如，假设你运行了一个Tomcat的实例，并允许合作者或学生在其中安装Servlet。你并不想让他们中的任何人调用 `System.exit` ，因为这会终止该Tomcat实例。可以设置一个安全策略，让对 `System.exit` 的调用抛出安全异常、而非真的关闭虚拟机。下面将详细说明这种情况，`Runtime` 类的 `exit` 方法会调用安全管理器的 `checkExit` 方法，下面是 `exit` 方法的全部代码：
```java
public void exit(int status) {
	SecurityManager security = System.getSecurityManager();
	if (security != null)
		security.checkExit(status);
	exitInternal(status);
}
```
这时安全管理器要检查，退出请求是来自浏览器、还是单个的applet程序。如果安全管理器同意了退出请求，那么 `checkExit` 便直接返回并继续处理下面正常的操作。但如果安全管理器不同意退出请求，那么 `checkExit` 方法就会抛出一个 `SecurityException` 异常。

只有当没有任何异常发生时，`exit` 方法才能继续执行。然后它调用本地私有的 `exitInternal` 方法，以真正终止虚拟机的运行。**没有其他的方法可以终止虚拟机的运行，因为 `exitInternal` 方法是私有的，任何其他类都不能调用它**。因此，任何试图退出虚拟机的代码都必须通过 `exit` 方法，在不触发安全异常的情况下、通过 `checkExit` 安全检查。

显然，**安全策略的完整性依赖于谨慎的编码**。==标准类库中系统服务的提供者，在试图继续任何敏感的操作之前，都必须与安全管理器进行协商==。

Java平台的安全管理器，不仅允许系统管理员，而且允许程序员对各个**安全访问权限**实施细致的控制。在下一节介绍这些特性。首先，介绍Java 2平台的安全模型的概况，然后介绍如何使用**策略文件**对各个权限实施控制。最后，我们要介绍如何来定义你自己的**权限类型**。
> 注意：实现并安装自己的安全管理器是可行的，但你不应进行这种尝试，除非你是计算机安全方面的专家。配置标准的安全管理器更加安全。

## 22.3.1 Java平台安全性
JDK 1.0具有一个非常简单的安全模型，即**本地类拥有所有的权限，而远程类只能在沙盒里运行** *Local classes had full permissions, and remote classes were confined to the sandbox* 。就像儿童只能在沙盒里玩沙子一样，远程代码只被允许打印屏幕和与用户进行交互。applet的安全管理器拒绝了远程代码对本地资源的所有访问。

JDK 1.1对此进行了微小的修改，**如果远程代码带有可信赖的实体的签名，将被赋予和本地类相同的访问权限**。不过，JDK 1.0和1.1这两个版本提供的都是一种“要么都有，要么都没有” *all-or-nothing* 的权限赋予方法——程序要么拥有所有的访问权限，要么必须在沙盒里运行。

从Java SE 1.2开始，Java平台拥有了更灵活的安全机制，==（它的）一个安全策略建立了代码来源和访问权限集之间的映射关系== *A security policy maps code sources to permission sets*（参见图22-6）。
![图22-6 一个安全策略](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212091805212.png)

代码来源 *code source* 是由一个代码位置 *code location* 和一个证书集 *certificates* 指定的。
- **代码位置指定了代码的来源**。例如，远程applet代码的代码位置是下载applet的HTTP URL，位于JAR文件中的代码的代码位置是该文件的URL。
- **证书的目的是要由某一方来保障代码没有被篡改过**。后面讨论证书。

权限 *permission* 是指由安全管理器负责检查的任何属性。**Java平台支持许多访问权限类，每个类都封装了特定权限的详细信息**。例如，下面这个 `FilePermission` 类的实例表示：允许在 `/tmp` 目录下读取和写入任何文件。
```java
var p = new FilePermission("/tmp/*", "read,write");
```
更为重要的是，`Policy` 类的默认实现，会从一个访问权限文件中读取权限。在权限文件中，同样的读权限表示为：
```java
permission java.io.FilePermission "/tmp/*", "read,write";
```
下一节介绍权限文件。

图22-7显示了Java 1.2中提供的权限类的层次结构。JDK的后续版本添加了更多的权限类。
![图22-7 权限类的层次结构](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212091910375.png)

在上一节中，我们看到了 `SecurityManager` 类有许多诸如 `checkExit` 的安全检查方法，这些方法的存在、只是为了程序员的方便和向后兼容性，它们都已被映射为标准的权限检查，例如，下面是 `checkExit` 方法的源代码：
```java
public void checkExit() {
	checkPermission(new RuntimePermission("exitVM"));
}
```

==每个类都有一个**保护域** *protection domain* ，它是一个用于封装类的代码来源和权限集合的对象==。当 `SecurityManager` 类需要检查某个权限时，==它要查看当前位于调用堆栈上的所有方法的类，然后它要获得所有类的保护域==，并且询问每个保护域，其权限集合是否允许执行当前正在被检查的操作。如果所有的域都同意，那么检查得以通过。否则，就会抛出一个 `SecurityException` 异常。

为什么在调用堆栈上的所有方法，都必须允许某个特定的操作呢？让我们通过一个实例来说明这个问题。假设一个Servlet的 `init` 方法想要打开一个文件，它可能会调用下面的语句：
```java
var in = new FileReader(name);
```
`FileReader` 构造器调用 `FileInputStream` 构造器，而 `FileInputStream` 构造器调用安全管理器的 `checkRead` 方法，安全管理器最后用 `FilePermission(name, "read")` 对象调用 `checkPermission` 。表22-1显示了该调用堆栈。
![表22-1 权限检查期间的调用堆栈](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212091949281.png)

`FileInputStream` 和 `SecurityManager` 类都属于系统类，它们的 `CodeSource` 为 `null` ，它们的权限都是由 `AllPermission` 类的一个实例组成的，`AllPermission` 类允许执行所有的操作。显然地，仅根据它们的权限是无法确定检查结果的。正如看到的那样，`checkPermission` 方法必须考虑applet类的受限制的权限问题 *the restricted permissions of the applet class* 。==通过检查整个调用堆栈，安全机制就能确保「一个类决不会要求另一个类代表自己去执行某个敏感的操作==。
> 注意：上面关于如何进行权限检查的简要介绍，展示了这方面的基本概念。不过这里省略了对许多技术细节的说明。对于安全性的细节问题，建议阅读Li Gong撰写的著作，以了解更多的内容。有关Java平台安全模型的更多重要信息，查阅 *Securing Java: Getting Down to Business with Mobile Code, 2nd Edition, Gary McGraw, Ed Felten* 一书，[该书的在线版本](http://www.securingjava.com/)。

> [API] `java.lang.SecurityManager` 1.0
> - `void checkPermission(Permission p)` 1.2
> 检查当前安全管理器是否授予给定的权限。如果没有授予该权限，本方法抛出一个 `SecurityException` 异常。

> [API] `java.lang.Class` 1.0
> - `ProtectionDomain getProtectionDomain()` 1.2
> 获取该类的保护域，如果该类被加载时没有保护域，则返回 `null` 。

> [API] `java.security.ProtectionDomain` 1.2
> - `ProtectionDomain(CodeSource source, PermissionCollection permissions)`
> 用给定的代码来源和权限构建一个保护域。
> - `CodeSource getCodeSource()`
> 获取该保护域的代码来源。
> - `boolean implies(Permission p)`
> 如果该保护域允许给定的权限，则返回 `true` 。

> [API] `java.security.CodeSource` 1.2
> - `Certificate[] getCertificates()`
> 获取与该代码来源相关联的用于类文件签名的证书链。
> - `URL getLocation()`
> 获取与该代码来源相关联的类文件代码位置。

## 22.3.2 安全策略文件
**策略管理器要读取相应的策略文件 *policy files*，这些文件包含了将代码来源映射为权限的指令**。下面是一个典型的策略文件，该文件给所有下载自http://www.horstmann.com/classes的代码授予在 `/tmp` 目录下读取和写入文件的权限：
```java
grant codeBase "http://www.horstmann.com/classes" {
	permission java.io.FilePermission "/tmp/*", "read,write";
};
```

可以将策略文件安装在标准位置上。默认情况下，有两个位置可以安装策略文件：
- Java平台主目录的 `java.policy` 文件。
- 用户主目录 *user's home directory* 的 `.java.policy` 文件（注意文件名前面的圆点）。

注意：**可以在 `java.security` 配置文件中修改这些文件的位置**，默认位置设定为：
```java
policy.url.1=file:${java.home}/lib/security/java.policy
policy.url.2=file:${user.home}/.java.policy
```
系统管理员可以修改 `java.security` 文件，并可以指定「驻留在另外一台服务器上并且用户无法修改的策略URL *policy URLs that reside on another server and cannot be edited by users* 」。策略文件（？）中允许存放任何数量的策略URL（这些URL带有连续的编号）。所有文件的权限都被组合了在一起 *The permissions of all files are combined* 。

如果想将策略文件存储到文件系统之外，那么可以去实现 `Policy` 类的一个子类，让其去收集所允许的权限。然后在 `java.security` 配置文件中更改下面这行：
```java
policy.provider=sun.security.provider.PolicyFile
```

==在测试期间，我们不喜欢经常地修改这些标准文件。因此，我们更愿意为每一个应用程序配置显式的策略文件== *explicitly name the policy file required for each application* ，将权限写入一个独立的文件（比如 `MyApp.policy` ）中即可。要应用这个策略文件，可以有两个选择。一种是在应用程序的 `main` 方法内部设置系统属性：
```java
System.setProperty("java.security.policy", "MyApp.policy");
```
或者，可以像下面这样启动虚拟机：
```bash
$ java -Djava.security.policy=MyApp.policy MyApp
```
在这些例子中，实际上 `MyApp.policy` 文件将被添加到其他有效的策略中 *is added to the other policies in effect* 。如果在命令行中添加了第二个等号，比如：
```bash
$ java -Djava.security.policy==MyApp.policy MyApp
```
那么应用程序就只 *only* 使用指定的策略文件，而标准策略文件将被忽略。
> 警告：在测试期间，一个容易犯的错误是在当前目录中留下一个 `.java.policy` 文件，该文件授予了 *grants* 许许多多的权限，甚至可能授予了 `AllPermission` 。如果发现你的应用程序似乎没有注意到策略文件中的限制，就应检查当前目录下的 `.java.policy` 文件。如果使用的是UNIX系统，就更容易犯这样的错误，因为在UNIX中，文件名以圆点开头的文件默认是不显示的。

如前所说，==在默认情况下，Java应用程序是不安装安全管理器的。因此，在安装安全管理器之前，看不到策略文件的作用==。当然，可以将这行代码：
```java
System.setSecurityManager(new SecurityManager());
```
添加到 `main` 方法中，或在启动虚拟机时添加命令行选项 `-Djava.security.manager` 。
```bash
$ java -Djava.security.manager -Djava.security.policy=MyApp.policy MyApp
```
> 你可能会认为，使用 `System.setProperty("java.security.manager")` 也能打开 `SecurityManager` ，但这种方式并不会生效。原因就是，系统属性是在当JVM启动时进行检查的，在JVM完全启动之后，程序手动设置的系统属性，并不能奏效，因为已经不在对系统属性进行检查了。

在本节剩余部分，详细介绍**如何描述策略文件的权限**。我们将介绍整个策略文件的格式，不过不包括代码证书部分，代码证书将在后面部分介绍。一个策略文件包含一系列 `grant` 项。每一项都具有以下的形式：
```java
grant codesource {
	permission ;
	permission ;
	...
};
```
**代码来源包含一个代码库**（如果该条目适用于来自所有源的代码 *code from all sources* ，则可以省略）**和值得信赖的用户特征 *principal* 与证书签名者的名字**（如果不要求对该项签名，则可以省略），代码库可以设定为：
```java
codeBase "url"
```
如果URL以“/”结束，那么它是一个目录。否则，它将被视为一个JAR文件的名字。例如：
```java
grant codeBase "www.horstmann.com/classes/" { ... };
grant codeBase "www.horstmann.com/classes/MyApp.jar" { ... };
```
代码库是一个URL、并且总是以斜杠作为文件分隔符，即使是Windows中的文件URL，也是如此。例如：
```java
grant codeBase "file:C:/myapps/classes/" { ... };
```
> 注意：都知道 `http` 格式的URL都以双斜杠 `http://` 开头的，但它很容易与 `file` 格式的URL搞混淆，策略文件阅读器接受两种格式的 `file URL` ，即 `file://localFile` 和 `file:localFile` 。此外，Windows驱动器名前面的斜杠是可有可无的。也就是说，下面的各种表示都是可以接受的：
> ```java
> file:C:/dir/filename.ext
> file:/C:/dir/filename.ext
> file://C:/dir/filename.ext
> file:///C:/dir/filename.ext
> ```
> 实际上，我们的测试结果是 `file:////C:/dir/filename.ext` 也是允许的，对此我们不做解释 *have no explanation for that* 。

> 注释：考虑一个会编译一些Java代码的应用程序，它需要大量的权限。在JDK 9之前，我们可以被授权 *granted all permissions to the code* ——获得对 `tools.jar` 中的代码的所有权限。 这个JAR文件现在已经不存在了。因此，需要像下面这样、授予对适合的模块进行访问的权限：
> ```java
> grant codeBase "jrt:/jdk.compiler" {
> 	permission java.security.AllPermission;
> };
> ```

权限采用下面的结构：
```java
permission className targetName, actionList;
```
- **类名是权限类的全称类名**（比如 `java.io.FilePermission` ）。
- **目标名是个与权限相关的值** *permission-specific value* ，例如，文件权限中的目录名或者文件名，或者是 `socket` 权限中的主机和端口。
- 操作列表同样是与权限相关的，它是一个操作方式的列表，比如 `read` 或 `connect` 等操作，用逗号分隔。

有些权限类并不需要目标名和操作列表。表22-2列出了标准的权限和它们执行的操作。
![表22-2 权限及其相关的目标和操作](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212092119978.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212092120689.png)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212092120338.png)

正如22-2中所示，大部分权限只允许执行某种特定的操作 *operation* 。可以将操作视为「具有一个隐含行为"permit"的目标 *the **target** with an implied **action** "permit"*」。这些权限类都继承自 `BasicPermission` 类（参见图22-7）。然而，文件、`socket` 和属性权限 *property permissions* 的目标都比较复杂，我们必须对它们进行详细介绍。

文件权限的目标可以有下面几种形式（ `directory/-` 表示目录和其子目录中的所有文件，`-` 表示当前目录和其子目录中所有文件）：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212092129780.png)

例如，下面的权限项赋予对 `/myapp` 目录和它的子目录中的所有文件的访问权限。
```java
permission java.io.FilePermission "/myapp/-", "read,write,delete";
```
必须使用 `\\` 转义字符序列来表示Window文件名中的反斜杠。
```java
permission java.io.FilePermission "c:\\myapp\\-", "read,write,delete";
```

`Socket` 权限的目标由主机和端口范围组成。对主机的描述具有下面几种形式（ `*.domainSuffix` 表示以给定后缀结尾的域中的所有主机）：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212092229191.png)
端口范围是可选的，具有下面几种形式：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212092231221.png)
下面是一个权限的实例：
```java
permission java.net.SocketPermission "*.horstmann.com:8000-8999", "connect";
```

最后，属性权限的目标可以采用下面两种形式之一：
 ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212092234058.png)
`"java.home"` 和 `"java.vm.*"` 就是这样的例子。
例如，下面的权限项允许程序读取以 `java.vm` 开头的所有属性。
```java
permission java.util.PropertyPermission "java.vm.*", "read";
```
可以在策略文件中使用系统属性，其中的 `${property}` 标记会被属性值替代，例如，`${user.home}` 会被用户主目录替代。下面是在一个访问权限项中使用系统属性的典型应用。
```java
permission java.io.FilePermission "${user.home}", "read,write";
```

为了创建平台无关的策略文件，使用 `file.separator` 属性、而非使用显式的 `/` 或 `\\` 分隔符绝对是个好主意。如果要使它更加简单，可以使用符号 `${/}` 作为 `${file.separator}` 的缩写。例如，
```java
permission java.io.FilePermission "${user.home}${/}-", "read,write";
```
是一个可移植的项，用于授予对「在用户的主目录及其子目录中的文件」进行读写的权限。
> 注意：JDK提供了一个名为 `policytool` 的基础工具，可以用它编辑策略文件。当然，该工具对完全不清楚其大部分设置的用户来说是不适用的。这正好证明了这样一种观念，管理工具可能只能供那些关心“定位-点击操作”、而不关心具体语法的系统管理员使用。尽管如此，它所欠缺的是对于非专家用户来说非常具有实际意义的级别设置（例如低，中或者高安全性设置）。一般来说，我们相信Java 2平台肯定包含了所有级别的细粒度安全模型，但将这些模型提供给最终用户和系统管理员会获得更大的收益。

## 22.3.3 定制权限
在本节中，介绍如何把自己的权限类提供给用户，以使得他们可以在策略文件中引用这些权限类。

如果要实现自己的权限类，可以继承 `Permission` 类，并提供以下方法：
- 带有两个 `String` 参数的构造器，这两个参数分别是目标和操作列表
- `String getActions()`
- `boolean equals()`
- `int hashCode()`
- `boolean implies(Permission other)`

最后一个方法是最重要的。权限有一个排序 *ordering* ，其中更加泛化的权限隐含了更加具体的权限 *more general permissions imply more specific ones* 。请考虑下面的文件权限，该权限允许读写 `/tmp` 目录以及子目录中的任何文件：
```java
p1 = new FilePermission("/tmp/-", "read, write");
```
该权限隐含了其他更加具体的权限：
```java
p2 = new FilePermission("/tmp/-", "read");
p3 = new FilePermission("/tmp/aFile", "read, write");
p4 = new FilePermission("/tmp/aDirectory/-", "write");
```
换句话说，如果：
1. p1的目标文件集包含p2的目标文件集。
2. p1的操作集包含p2的操作集。

那么，**文件访问权限p1就隐含了另一个文件访问权限p2**。

考虑下面关于 `implies` 方法的用法举例。当 `FileInputStream` 构造器想要打开一个文件、以读取该文件时，要检查它是否拥有操作权限。如果要执行这种检查，一个具体的文件权限对象被传递给 `checkPermission` 方法：
```java
checkPermission(new FilePermission(fileName, "read"));
```
现在安全管理器询问所有适用的权限是否隐含了该权限 *all applicable permissions whether they imply this permission* 。如果其中某个隐含了该权限，就通过了检查。特别地，`AllPermission` 隐含了其他所有的权限。

如果你定义了自己的权限类，那么必须对权限对象定义一个合适的隐含法则 *define a suitable notion of implication for your permission objects* 。例如，假设你为采用Java技术的机顶盒定义一个 `TVPermission` ，那么下面这个访问权限将允许Tommy在19点到22点之间、对2至12频道的电视节目进行观看和录像：
```java
new TVPermission("Tommy:2-12:1900-2200", "watch,record")
```
必须实现 `implies` 方法，以使此权限隐含一个（像上面这样的）更具体的权限 *this permission implies a more specific one* 。
## 22.3.4 实现权限类
在下面示例程序中，实现了一个新的权限，用于监视将文本插入到文本域的操作。该程序会确保不能输入“不良单词”，例如 `sex, drugs, C++` 等。我们使用一个定制的权限类，以便在策略文件中提供这些不良单词 *the list of bad words can be supplied in a policy file* 。

下面这个 `JTextArea` 的子类，询问安全管理器是否准备好去添加新文本：
```java
class WordCheckTextArea extends JTextArea {
	public void append(String text) {
		var p = new WordCheckPermission(text, "insert");
		SecurityManager manager = System.getSecurityManager();
		if (manager != null) manager.checkPermission(p);
		super.append(text);
	}
}
```
如果安全管理器赋予了 `WordCheckPermission` 权限，那么该文本就可以追加。否则，`checkPermission` 方法就会抛出一个异常。

单词检查权限有两个可能的操作，一个是 `insert`（用于插入特定文本的权限），另一个是 `avoid`（添加「不包含某些不良单词的任何文本」的权限）。应用下面的策略文件运行这个程序：
```java
grant {
	permission permissions.WordCheckPermission "sex,drugs,C++", "avoid";
};
```
这个策略文件赋予的权限是，可以插入不包含不良单词 `sex, drugs, C++` 的任何文本。

当设计 `WordCheckPermission` 类时，我们必须特别注意 `implies` 方法，下面是**控制权限p1是否隐含p2的规则**：
- 如果p1有 `avoid` 操作 *action* ，p2有 `insert` 操作，那么**p2的目标必须避开p1中的所有单词**。例如，权限 `permissions.WordCheckPermission "sex,drugs,C++", "avoid"` 隐含了权限 `permissions.WordCheckPermission "Mary had a little lamb", "insert"` 。
- 如果p1和p2都有 `avoid` 操作，那么**p2的单词集合必须包含p1单词集合中的所有单词**。例如，权限 `permissions.WordCheckPermission "sex,drugs", "avoid"` 隐含了权限 `permissions.WordCheckPermission "sex,drugs,C++", "avoid"` 。
- 如果p1和p2都有 `insert` 操作，那么p1的文本必须包含p2的文本。例如，权限 `permissions.WordCheckPermission "Mary had a little lamb", "insert"` 包含了下面这个权限 `permissions.WordCheckPermission "a little lamb", "insert"` 。

可以在程序 `permissions/WordCheckPermission.java` 中看到该类的具体实现。

注意，可以用 `Permission` 类中名字容易混淆的 `getName` 方法、来获取权限的目标。**由于在策略文件中权限是由一对字符串来表示的，因此，权限类需要准备好解析这些字符串**。特别地，我们应使用下面的方法，将用逗号分隔的 `avoid` 权限的不良单词表、转换为一个真正的 `Set` 。
```java
public Set<String> badWordSet() {
	var set = new HashSet<String>();
	set.addAll(List.of(getName().split(",")));
	return set;
}
```
该代码允许我们用 `equals` 和 `containsAll` 方法来比较这些集。正如章2中所介绍的，如果两个集包含任意次序的相同元素，那么集 *set* 类的 `equals` 方法可以判定它们相等。
> 警告：**务必要把你的权限类设为 `public`** 。策略文件加载器 *policy file loader* 不能加载具有包可视性的类，并且它会悄悄忽略其无法找到的所有类。

`permissions/PermissionTest.java` 展示了 `WordCheckPermission` 类是如何工作的。在文本框内输入任意文本，然后按下 `Insert` 按钮。如果文本通过了安全检查，该文本就会被添加到文本区域中。如果没有通过检查，就会弹出一个消息（参见图22-7）。
![图22-7 PermissionTest程序](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212100123937.png)
> 警告：如果仔细看看上图，就会看到消息窗口带有一个警告三角形，这是用来警告用户：该窗口可能是因为无插入文本权限而弹出的。这个警告最初带有一个表示不良含义的标签，即“未受信的Java Applet窗口”，在后续JDK的多个连续版本中，其因惯性而一直保留了下来。现在，它对警告用户来说已经变得毫无意义了。这个警告可以通过 `java.awt.AWT Permission` 的 `showWindowWithoutWarningBanner` 目标来关闭。如果你喜欢，可用编辑策略文件以赋予该权限。

```java
// permissions/PermissionTest.java
package permissions;

import java.awt.*;
import javax.swing.*;

/**
 * This class demonstrates the custom WordCheckPermission.
 */
public class PermissionTest {
	public static void main(String[] args) {
		System.setProperty("java.security.policy", "permissions/PermissionTest.policy");
		System.setSecurityManager(new SecurityManager());
		EventQueue.invokeLater(() -> {
			var frame = new PermissionTestFrame();
			frame.setTitle("PermissionTest");
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}
}

/** 
 * This frame contains a text field for inserting 
 * words into a text area that is protected from "bad words".
 */
class PermissionTestFrame extends JFrame {
	private JTextField textField;
	private WordCheckTextArea textArea;
	private static final int TEXT_ROWS = 20;
	private static final int TEXT_COLUMNS = 60;

	public PermissionTestFrame() {
		textField = new JTextField(20);
		var panel = new JPanel();
		panel.add(textField);
		var openButton = new JButton("Insert");
		openButton.addActionListener(event -> insertWords(textField.getText()));
		panel.add(openButton);

		add(panel, BorderLayout.NORTH);

		textArea = new WordCheckTextArea();
		textArea.setRows(TEXT_ROWS);
		textArea.setColumns(TEXT_COLUMNS);
		add(new JScrollPane(textArea), BorderLayout.CENTER);
		pack();
	}

	/**
	 * Tries to insert words into the text area. Displays a dialog if the attempt fails.
	 * @param words the words to insert
	 */
	public void insertWords(String words) {
		try {
			textArea.append(words + "\n");
		} catch (SecurityException ex) {
			JOptionPane.showMessageDialog(this, "I am sorry, but I cannot do that.");
			ex.printStackTrace();
		}
	}
}

/**
 * A text area whose append method makes a security check
 * to see that no bad words are added.
 */
class WordCheckTextArea extends JTextArea {
	public void append(String text) {
		var p = new WordCheckPermission(text, "insert");
		SecurityManager manager = System.getSecurityManager();
		if (manager != null) manager.checkPermission(p);
		super.append(text);
	}
}
```
```java
// permissions/WordCheckPermission.java
package permissions;

import java.security.*;
import java.util.*;

/** 
 * A permission that checks for bad words.
 */
public class WordCheckPermission extends Permission {
	private String action;

	/**
	 * Constructs a word check permission.
	 * @param target a comma separated word list
	 * @param anAction "insert" or "avoid"
	 */
	public WordCheckPermission(String target, String anAction) {
		super(target);
		action = anAction;
	}

	public String getActions() {
		return action;
	}

	public boolean equals(Object other) {
		if (other == null) return false;
		if (!getClass().equals(other.getClass())) return false;
		var b = (WordCheckPermission) other;
		if (!Objects.equals(action, b.action)) return false;
		if ("insert".equals(action)) 
			return Objects.equals(getName(), b.getName());
		else if ("avoid".equals(action)) 
			return badWordSet().equals(b.badWordSet());
		else return false;
	}

	public int hashCode() {
		return Objects.hash(getName(), action);
	}

	public boolean implies(Permission other) {
		if (!(other instanceof WordCheckPermission)) return false;
		var b = (WordCheckPermission) other;
		if (action.equals("insert")) {
			return b.action.equals("insert") && getName().indexOf(b.getName()) >= 0;
		} else if (action.equals("avoid")) {
			if (b.action.equals("avoid"))
				return b.badWordSet().containsAll(badWordSet());
			else if (b.action.equals("insert")) {
				for (String badWord : badWordSet()) 
					if (b.getName().indexOf(badWord) >= 0)
						return false;
				return true;
			} else return false;
		} else return false;
	}

	/**
	 * Gets the bad words that this permission rule describe.
	 * @return a set of the bad words
	 */
	public Set<String> badWordSet() {
		var set = new HashSet<String>();
		set.addAll(List.of(getName().split(", ")));
		return set;
	}
}
```
```java
// PermissionTest.policy
grant  {  
	permission permissions.WordCheckPermission "sex,drugs,C++", "avoid";   
};
```
发现一个问题，`SecurityManager` 已经被 `deprecated` 了（[JEP 411: Deprecate the Security Manager for Removal](https://openjdk.org/jeps/411)）：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212131222028.png)

现在已看到，应如何配置Java平台的安全性了。更常见的情况是，只需微调标准的权限集。对于其他额外的控制，可以定义自制的权限，它们可按照与标准权限相同的方式配置。
> [API] `java.security.Permission` 1.2
> - `Permission(String name)`
> 用指定的目标 *target* 名构建一个权限。
> - `String getName()`
> 返回该权限的目标 *target* 名称。
> - `boolean implies(Permission other)`
> 检查该权限是否隐含了其他权限。如果其他权限描述了一个更加具体的条件，而这个具体条件是由该权限所描述的条件所产生的结果，就需要进行这样的检查。

---
# 22.4 用户认证
**Java认证和授权服务** *Java Authentication and Authorization Service, JAAS* 包含两部分：**“认证”部分主要负责确定程序使用者的身份，而“授权”将各个用户映射到相应的权限**。

JAAS是一个可插拔的API，可以将Java应用程序与实现认证的特定技术分离开来。除此之外，JAAS还支持UNIX登录、NT登录、Kerberos认证和基于证书的认证。

**一旦用户通过认证，就可以为其附加一组权限**。例如，这里我们赋予Harry一个特定的权限，而其他用户则没有，它的语法规则如下：
```java
grant principal com.sun.security.auth.UnixPrincipal "harry" {
	permission java.util.PropertyPermission "user.*", "read";
	...
};
```
在该语法中，`com.sun.security.auth.UnixPrincipal` 类检查运行该程序的UNIX用户的名字，它的 `getName` 方法将返回UNIX登录名，然后我们就可以检查该名称是否等于“harry”。

可以使用一个 `LoginContext` 、以使安全管理器能检查这样的授权语句。下面是登录代码的基本轮廓。这里，`subject` 是指已经被认证的个体：
```java
try {
	System.setSecurityManager(new SecurityManager());
	var context = new LoginContext("Login1"); // defined in JAAS configuration file
	context.login();
	// get the authenticated Subject
	Subject subject = context.getSubject();
	...
	context.logout();
} catch (LoginException exception) { // thrown if login was not successful 
	exception.printStackTrace();
}
```
`LoginContext` 构造器中的字符串参数“Login1”是指JAAS配置文件中具有相同名字的项 *an entry with the same name in the JAAS configuration file* 。下面是一个简单的配置文件：
```java
Login1 {
	com.sun.security.auth.module.UnixLoginModule required;
	com.whizzbang.auth.module.RetinaScanModule sufficient;
};
Login2 {
	...
};
```
当然，JDK中没有包含任何使用生物特征 *biometric* 的登录模块。JDK在 `com.sun.security.auth.module` 包中包含以下模块：
```java
UnixLoginModule
NTLoginModule
Krb5LoginModule
JndiLoginModule
KeyStoreLoginModule
```
一个登录策略由一个登录模块序列组成，每个模块被标记为 `required, sufficient, requisite, optional` 。这些关键字的含义在下面的算法中进行了描述（？）：
1. 各个模块依次执行，直到有一个 `sufficient` 的模块认证成功，或者有一个 `requisite` 的模块认证失败，或者已经执行到最后一个模块时才停止。
2. 当标记为 `required` 和 `requisite` 的所有模块都认证成功，或者它们都没有被执行，但至少有一个 `sufficient` 或 `optional` 的模块认证成功时，这次认证就成功了。

**登录时要对登录的主体 *subject* 进行认证，该主体可以拥有多个特征 *principal*** 。特征描述了主体的某些属性，比如用户名、组ID或角色等。我们在 `grant` 语句中可以看到，特征控制着各个权限 *principals govern permissions* 。
`com.sun.security.auth.UnixPrincipal` 类描述了UNIX登录名，`UnixNumericGroupPrincipal` 类可以用来检测是否归属于某个UNIX用户组。
使用下面的语法，`grant` 语句可以对一个特征进行测试：
```java
grant principalClass "principalName"
```
例如：
```java
grant com.sun.security.auth.UnixPrincipal "harry"
```

**当用户登录后，就会在独立的访问控制上下文 *access control context* 中，运行要求检查用户特征的代码。使用静态的 `doAs` 或 `doAsPrivileged` 方法、去启动一个新的 `PrivilegedAction` ，其run方法就会执行这段代码**——这两个方法都可以通过使用主体特征的权限 *using the permissions of the subject's principals* 、来**调用「某个实现了 `PrivilegedAction` 接口的对象」的 `run` 方法、去执行特定操作**。如果该操作会抛出受检查的异常，那么必须改为实现 `PrivilegedExceptionAction` 接口。
```java
PrivilegedAction<T> action = () -> {
	// run with permissions of subject principals
	...
};
T result = Subject.doAs(subject, action); 
	// or Subject.doAsPrivileged(subject, action, null)
```

`doAs` 和 `doAsPrivileged` 方法之间的区别是微小的。`doAs` 方法开始于当前的访问控制上下文，而 `doAsPrivileged` 方法则开始于一个新的上下文。**后者允许将登录代码和“业务逻辑”的权限相分离**。在示例应用程序中，登录代码有如下权限：
```java
permission javax.security.auth.AuthPermission "createLoginContext.Login1";
permission javax.security.auth.AuthPermission "doAsPrivileged";
```
通过认证的用户有一个权限：
```java
permission java.util.PropertyPermission "user.*", "read";
```
如果我们用 `doAs` 代替了 `doAsPrivileged` ，那么登录代码也需要这个权限！

`auth/AuthTest.java` 和 `auth/SysPropAction.java` 展示了如何限制某些用户的权限。`AuthTest` 程序对用户的身份进行了认证，然后运行了一个简单的操作，以获得一个系统属性。
> `doAsPrivileged` 只有和 `SecurityManager` 联合用才有用，而 `SecurityManager` 被 `deprecated` 了，这个方法也被 `deprecated and subject to removal` 了。

```java
// auth/AuthTest.java
package auth;

import javax.security.auth.*;
import javax.security.auth.login.*;

/**
 * This program authenticates a user via a custom login 
 * and then executes the SysPropAction with the user's priviledges.
 */
public class AuthTest {
	public static void main(final String[] args) {
		System.setSecurityManager(new SecurityManager());
	    try {
	    	var context = new LoginContext("Login1");
	    	context.login();
	    	System.out.println("Authentication successful.");
	    	Subject subject = context.getSubject();
	    	System.out.println("subject=" + subject);

	    	var action = new SysPropAction("user.home");
	    	String result = Subject.doAsPrivileged(subject, action, null);
	    	System.out.println(result);
	    	context.logout();
	    } catch (LoginException e) {
	    	e.printStackTrace();
	    }
	}
}
```
```java
package auth;
import java.security.*;

/**
 * This action looks up a system property.
 */
public class SysPropAction implements PrivilegedAction<String> {
	private String propertyName;

	/**
	 * Constructs an action for looking up a given property.
	 * @param propertyName the property name (such as "user.home")
	 */
	public SysPropAction(String propertyName) {
		this.propertyName = propertyName;
	}

	public String run() {
		return System.getProperty(propertyName);
	}
}
```
```java
// AuthTest.policy
grant codebase "file:login.jar" {  
	permission javax.security.auth.AuthPermission "createLoginContext.Login1";
	permission javax.security.auth.AuthPermission "doAsPrivileged";
};

grant principal com.sun.security.auth.UnixPrincipal "harry" {
	permission java.util.PropertyPermission "user.*", "read";
};
```
`auth/jaas.config` 展示了登录配置。
```java
// jaas.config
Login1  {       
   com.sun.security.auth.module.UnixLoginModule required;
};
```

要使该例子能运行，必须将**登录类**和**操作类**的代码封装到两个独立的JAR文件中：
```bash
$ javac auth/*.java
$ jar cvf login.jar auth/AuthTest.class
$ jar cvf action.jar auth/SysPropAction.class
```
如果查看策略文件 `AuthTest.policy` ，将会看到名为harry的UNIX用户拥有读取所有文件的权限。将harry改为你自己的登录名，然后运行下面的命令
```bash
$ java -classpath login.jar:action.jar \
	-Djava.security.policy=auth/AuthTest.policy \
	-Djava.security.auth.login.config=auth/jaas.config \ 
	auth.AuthTest
```
在Windows下运行时，将 `AuthTest.policy` 中的 `UnixPrincipal` 改为 `NTUserPrincipal` ，并将 `jaas.config` 中的 `UnixLoginModule` 改为 `NTLoginModule` 。运行该程序时，用分号来分隔各个JAR文件：
```bash
$ java -classpath login.jar;action.jar ...
```
`AuthTest` 程序现在将显示 `user.home` 属性的值。但如果用不同的名字登录，那么就应抛出一个安全异常，因为你不再拥有必需的权限了。
> 警告：必须严格按照这些指令来运行。如果对程序进行了一些看上去无关紧要的更改，那就很容易使你的设置出错。
> 注意：**实际情况是无法运行**！

> [API] `javax.security.auth.login.LoginContext` 1.4
> - `LoginContext(String name)`
创建一个登录上下文。`name` 对应于JAAS配置文件中的登录描述符。
> - `void login()`
> 建立一个登录操作，如果登录失败，则抛出一个 `LoginException` 异常。**它会调用JAAS配置文件中的管理器上的 `login` 方法**。
> - `void logout()`
> `Subject` 退出登录。它会调用JAAS配置文件中的管理器上的 `logout` 方法。
> - `Subject getSubject()`
> 返回认证过的 `Subject` 。

> [API] `javax.security.auth.Subject` 1.4
> - `Set<Principal> getPrincipals()`
> 获取该 `Subject` 的各个 `Principal` 。
> - `static Object doAs(Subject subject, PrivilegedAction action)`
> - `static Object doAs(Subject subject, PrivilegedExceptionAction action)`
> - `static Object doAsPrivileged(Subject subject, PrivilegedAction action, AccessControlContext context)`
> - `static Object doAsPrivileged(Subject subject, PrivilegedExceptionAction action, AccessControlContext context)`
> **以 `subject` 的身份执行特许操作** *executes the privileged action on behalf of the subject* 。它将**返回 `run` 方法的返回值**。
> `doAsPrivileged` 方法在给定的访问控制上下文中执行该操作，你可以提供一个在前面调用静态方法 `AccessController.getContext()` 时所获得的“上下文快照”，或者指定为 `null` ，以使其在一个新的上下文中执行该代码。

> [API] `java.security.PrivilegedAction` 1.4
> - `Object run()`
> 必须定义该方法，以执行你想要代表某个主体去执行的代码。
> [API] `java.security.PrivilegedExceptionAction` 1.4
> - `Object run()`
> 必须定义该方法，以执行你想要代表某个主体去执行的代码。本方法可以抛出任何受检查的异常。

> [API] `java.security.Principal` 1.1
> - `String getName()`
> 返回该特征的身份标识 *the identifying name of this principal* 。

---
## 22.4.2 JAAS登录模块
在本节中，用一个JAAS例子介绍：
- 如何实现你自己的登录模块;
- 如何实现**基于角色的认证**。

**如果登录信息存储在数据库中，那么使用自己的登录模块就非常有用**。尽管你可能很喜欢默认的登录模块，但是学习如何定制自己的模块，将有助于理解JAAS配置文件的各个选项。

==基于角色的认证对于大量用户的管理来说是十分必要的，将所有合法用户的名字都写入策略文件是不切实际的==。而**登录模块应将用户映射到诸如 `"admin", "HR"` 等角色**，并且权限的赋予也要基于这些角色。

登录模块的工作之一是**组装被认证的主体的特征集** *populate the principal set of the subject that is being authenticated* 。如果一个登录模块支持某些角色，该模块就会添加 `Principal` 对象来描述这些角色。JDK并没有为这个目的提供一个类（一个 `Principal` 相关类），所以我们写了自己的类（见程序 `jaas/SimplePrincipal.java` ）。该类直接存储了一个描述/值对，例如 `role=admin` 。该类的 `getName` 方法用于返回该描述/值对，因此我们就可以添加基于角色的权限 *role-based permissions* 到策略文件中：
```java
grant principal SimplePrincipal "role=admin" { ... }
```
```java
// jaas/SimplePrincipal.java
package jaas;

import java.security.*;
import java.util.*;

/**
 * A principal with a named value (such as "role=HR" or "username=harry")
 */
public class SimplePrincipal implements Principal {
	private String descr;
	private String value;

	/**
	 * Constructs a SimplePrincipal to hold a description and a value
	 * @param descr the description
	 * @param value the associated value
	 */
	public SimplePrincipal(String descr, String value) {
		this.descr = descr;
		this.value = value;
	}

	/**
	 * Returns the role name of this principal.
	 * @return the role name
	 */
	public String getName() {
		return descr + "=" + value;
	}

	public boolean equals(Object otherObject) {
		if (this == otherObject) return true;
		if (otherObject == null) return false;
		if (getClass() != otherObject.getClass()) return false;
		var other = (SimplePrincipal) otherObject;
		return Objects.equals(getName(), other.getName());
	}

	public int hashCode() {
		return Objects.hashCode(getName());
	}
}
```

我们的登录模块会在包含如下行的 `password.txt` 中，查找用户、密码和角色：
```java
harry|secret|admin
carl|guessme|HR
```
当然，在实际的登录模块中，你可能会将这些信息存储在数据库或者目录中。

在 `jaas/SimpleLoginModule.java` 中，可以找到 `SimpleLoginModule` 的代码，其 `checkLogin` 方法用于检查输入的用户名和密码、是否与密码文件中的用户记录相匹配。如果匹配成功，则会添加两个 `SimplePrincipal` 对象到主体的特征集中：
```java
Set<Principal> principals = subject.getPrincipals();
principals.add(new SimplePrincipal("username", username));
principals.add(new SimplePrincipal("role", role));
```
`SimpleLoginModule` 剩余的部分就非常直截了当了。`initialize` 方法接收下面几个参数：
- 用于认证的 `Subject` 。
- 一个获取登录信息的 `handler` 。
- 一个 `sharedState` 映射表，它可以用于登录模块之间的通信。
- 一个 `options` 映射表，它包含了登录配置文件中设置的名/值对。

例如，我们将模块做如下配置：
```java
SimpleLoginModule required pwfile = "password.txt";
```
则登录模块可以从 `options` 映射表中获取 `pwfile` 设置：
```java
package jaas;

import java.io.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;

import java.security.*;
import javax.security.auth.*;
import javax.security.auth.callback.*;
import javax.security.auth.login.*;
import javax.security.auth.spi.*;

/**
 * This login module authenticates uses by reading usernames, passwords, and roles from
 * a text file.
 */
public class SimpleLoginModule implements LoginModule {
	private Subject subject;
	private CallbackHandler callbackHandler;
	private Map<String, ?> options;

	public void initialize(Subject subject, CallbackHandler callbackHandler, 
		Map<String, ?> sharedState, Map<String, ?> options) {
		this.subject = subject;
		this.callbackHandler = callbackHandler;
		this.options = options;	
	}

	public boolean login() throws LoginException {
		if (callbackHandler == null) throw new LoginException("no handler");
		var nameCall = new NameCallback("username: ");
		var passCall = new PasswordCallback("password: ", false);
		try {
			callbackHandler.handle(new Callback[] { nameCall, passCall });
		} catch (UnsupportedCallbackException e) {
			var e2 = new LoginException("Unsupported callback");
			e2.initCause(e);
			throw e2;
		} catch (IOException e) {
			var e2 = new LoginException("I/O exception in callback");
			e2.initCause(e);
			throw e2;
		}

		try {
			return checkLogin(nameCall.getName(), passCall.getPassword());
		} catch (IOException e) {
			var e2 = new LoginException();
			e2.initCause(e);
			throw e2;
		}
	}

	/**
	 * Checks whether the authentication information is valid.
	 * If it is, the subect acquires principals for the user name and role.
	 * @param username the user name
	 * @param password a character array containing the password
	 * @return true if the authentication information is valid
	 */
	private boolean checkLogin(String username, char[] password) 
		throws LoginException, IOException {
		try (var in = new Scanner(
				Paths.get("" + options.get("pwfile")), StandardCharsets.UTF_8)) {
			while (in.hasNextLine()) {
				String[] inputs = in.nextLine().split("\\|");
				if (inputs[0].equals(username)
					&& Arrays.equals(inputs[1].toCharArray(), password)) {
					String role = inputs[2];
					Set<Principal> principals = subject.getPrincipals();
					principals.add(new SimplePrincipal("username", username));
					principals.add(new SimplePrincipal("role", role));
					return true;	
				}
			}
			return false;
		}	
	}

	public boolean logout() { return true; }
	public boolean abort() { return true; }
	public boolean commit() { return true; }
}
```

该登录模块并没有收集用户名和密码，这是单独的 `handler` 需要做的工作。==这种功能上的分离，有助于你在各种情况下使用相同的登录模块，而不用关心登录信息是来自GUI对话框、控制台提示符还是配置文件==。`handler` 是在创建 `LoginContext` 时指定的。例如：
```java
var context = new LoginContext("Login1",
	new com.sun.security.auth.callback.DialogCallbackHandler());
```
`DialogCallbackHandler` 会弹出一个简单的GUI对话框，以获取用户名和密码。而 `com.sun.security.auth.callback.TextCallbackHandler` 则从控制台获取这些信息。

但在我们的应用程序中，是通过自己编写的GUI来获得用户名和密码的（参见图22-10）。我们创建了一个简单的 `handler` ，仅仅用于存储和返回这些信息（见 `jaas/SimpleCallbackHandler.java` ）。
![图22-8 一个定制的登录模块](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212101923788.png)
```java
// jaas/SimpleCallbackHandler.java
package jaas;

import javax.security.auth.callback.*;

/**
 * This simple callback handler presents the given user name and password.
 */
public class SimpleCallbackHandler implements CallbackHandler {
   private String username;
   private char[] password;

   /**
    * Constructs the callback handler.
    * @param username the user name
    * @param password a character array containing the password
    */
	public SimpleCallbackHandler(String username, char[] password) {
		this.username = username;
		this.password = password;
	}

	public void handle(Callback[] callbacks) {
		for (Callback callback : callbacks) {
			if (callback instanceof NameCallback) {
				((NameCallback) callback).setName(username);
			} else if (callback instanceof PasswordCallback) {
				((PasswordCallback) callback).setPassword(password);
			}
		}
	}
}
```
该 `handler` 有一个简单的方法 `handle` ，用于处理 `Callback` 对象数组。**有很多预定义类，比如 `NameCallback` 和 `PasswordCallback` 等，都实现了 `Callback` 接口**。也可以添加自己的类，比如 `RetinaScanCallback` 等。下面这段 `handler` 代码可能有些不雅致，因为它要分析 `callback` 对象的类型：
```java
public void handle(Callback[] callbacks) {
	for (Callback callback : callbacks) {
		if (callback instanceof NameCallback) ...
		else if (callback instanceof PasswordCallback) ...
		else ...
	}
}
```
**登录模块提供 `callbacks` 数组、以满足认证的需要**。
```java
var nameCall = new NameCallback("username: ");
var passCall = new PasswordCallback("password: ", false);
callbackHandler.handle(new Callback[] { nameCall, passCall });
```
然后它从 `callbacks` 中获取所要的信息。

```java
// jaas/SysPropAction.java
package jaas;

import java.security.*;
/**
 * This action looks up a system property.
 */
public class SysPropAction implements PrivilegedAction<String> {
   private String propertyName;

   /**
    * Constructs an action for looking up a given property.
    * @param propertyName the property name (such as "user.home")
    */
    public SysPropAction(String propertyName) {
	    this.propertyName = propertyName;
    }

	public String run() {
		return System.getProperty(propertyName);
	}
}
```

`jaas/JAASTest.java` 中的程序将显示一个窗体，用于输入登录信息和系统属性名。如果用户通过了认证，属性值会在 `PrivilegedAction` 中被取出。从 `jaas/JAASTest.policy` 策略文件中可以看到，只有具有 `admin` 角色的用户才具有对属性的读取权限。
```java
// jaas/JAASFrame.java
package jaas;

import java.awt.*;
import javax.security.auth.*;
import javax.security.auth.login.*;
import javax.swing.*;

/**
 * This frame has text fields for user name and password, 
 * a field for the name of the requested system property, 
 * and a field to show the property value.
 */
public class JAASFrame extends JFrame {
	private JTextField username;
	private JPasswordField password;
	private JTextField propertyName;
	private JTextField propertyValue;

	public JAASFrame() {
		username = new JTextField(20);
	    password = new JPasswordField(20);
	    propertyName = new JTextField("user.home");
	    propertyValue = new JTextField(20);
	    propertyValue.setEditable(false);

		var panel = new JPanel();
		panel.setLayout(new GridLayout(0, 2));
		panel.add(new JLabel("username:"));
		panel.add(username);
		panel.add(new JLabel("password:"));
		panel.add(password);
		panel.add(propertyName);
		panel.add(propertyValue);
		add(panel, BorderLayout.CENTER);
		
		var getValueButton = new JButton("Get Value");
		getValueButton.addActionListener(event -> getValue());
		var buttonPanel = new JPanel();
		buttonPanel.add(getValueButton);
		add(buttonPanel, BorderLayout.SOUTH);
		pack();
	}

	public void getValue() {
		try {
			var context = new LoginContext("Login1", new SimpleCallbackHandler(
				username.getText(), password.getPassword()));
			System.out.println("Trying to log in with " + username.getText() 
				+ " and " + new String(password.getPassword())
			);
			context.login();
			Subject subject = context.getSubject();
			propertyValue.setText("" + Subject.doAsPrivileged(subject, 
				new SysPropAction(propertyName.getText()), null));
			context.logout();
		} catch (LoginException e) {
			e.printStackTrace();
			Throwable cause = e.getCause();
			if (cause != null) cause.printStackTrace();
		}
	}
}
```
```java
// jaas/JAASTest.java
package jaas;

import java.awt.*;
import javax.swing.*;

/**
 * This program authentication a user via a custom login and then looks up a system property 
 * with the user's privileges.
 */
public class JAASTest {
	public static void main(final String[] args) {
		System.setSecurityManager(new SecurityManager());
		EventQueue.invokeLater(() -> {
			var frame = new JAASFrame();
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setTitle("JAASTest");
			frame.setVisible(true);
		});
	}
}
```
```java
// jaas/JAASTest.policy
grant codebase "file:login.jar" {    
	permission java.awt.AWTPermission "showWindowWithoutWarningBanner";
	permission java.awt.AWTPermission "accessEventQueue";
	permission javax.security.auth.AuthPermission "createLoginContext.Login1";
	permission javax.security.auth.AuthPermission "doAsPrivileged";
	permission javax.security.auth.AuthPermission "modifyPrincipals";
	permission java.io.FilePermission "jaas/password.txt", "read";
};

grant principal jaas.SimplePrincipal "role=admin" {
	permission java.util.PropertyPermission "*", "read";
};
```
`jaas/jaas.config` 说明了登录的配置。
```java
Login1 {
	jaas.SimpleLoginModule required pwfile="jaas/password.txt" debug=true;
};
```

正如前一节中所讲到的，**必须将登录和操作代码分开**。因此，首先创建两个JAR文件：
```bash
$ javac *.java
$ jar cvf login.jar JAAS*.class Simple*.class
$ jar cvf action.jar SysPropAction.class
```
然后以如下方式运行程序：
```bash
$ java -classpath login.jar:action.jar \
	-Djava.security.policy=JAASTest.policy \
	-Djava.security.auth.login.config=jaas.config \
	JAASTest
```

> 注意：有些应用有可能需要支持**更复杂的两阶段协议**，即只有登录配置文件中的所有模块都认证成功，该登录才会被提交。更多详细信息，请参阅下面地址的[登录模块开发指南](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/JAASLMDevGuide.html)。

> [API] `javax.security.auth.callback.CallbackHandler` 1.4
> - `void handle(Callback[] callbacks)`
> 处理给定的 `callbacks` ，如果想要、可以与用户进行交互，并且将安全信息存储到 `callback` 对象中。

> [API] `javax.security.auth.callback.NameCallback` 1.4
> - `NameCallback(String prompt)`
> - `NameCallback(String prompt, String defaultName)`
> 用给定的提示符和默认的名字构建一个 `NameCallback` 。
> - `void setName(String name)`
> - `String getName()`
> 设置或者获取该 `callback` 所收集到的名字。
> - `String getPrompt()`
> 获取查询该名字时所使用的提示符。
> - `String getDefaultName()`
> 获取查询该名字时所使用的默认名字。

> [API] `javax.security.auth.callback.PasswordCallback` 1.4
> - `PasswordCallback(String prompt, boolean echoOn)`
> 用给定提示符和回显标记构建一个 `PasswordCallback` 。
> - `char[] getPassword()`
> - `void setPassword(char[] password)`
> 设置或者获取该 `callback` 所收集到的密码。
> - `String getPrompt()`
> 获取查询该密码时所使用的提示符。
> - `boolean isEchoOn()`
> 获取查询该密码时所使用的回显标记。

> [API] `javax.security.auth.spi.LoginModule` 1.4
> - `void initialize(Subject subject, CallbackHandler handler, Map<String, ?> sharedState, Map<String, ?> options)`
> 为了认证给定的 `subject` ，初始化该 `LoginModule` 。**在登录处理期间，用给定的 `handler` 来收集登录信息**;使用 `sharedState` 映射表与其他登录模块进行通信;`options` 映射表包含「该模块实例的登录配置」中指定的名/值对。
> - `boolean login()`
> 执行认证过程，并组装主体的特征集。如果登录成功，则返回 `true` 。
> - `boolean commit()`
> 对于需要两阶段提交的登录场景，当所有的登录模块都成功后，调用该方法。如果操作成功，则返回 `true` 。
> - `boolean abort()`
> 如果某一登录模块失败导致登录过程中断，就调用该方法。如果操作成功，则返回 `true` 。
> - `boolean logout()`
> 注销当前的主体。如果操作成功，则返回 `true` 。

---
# 22.5 数字签名
如前所说，applet是在Java平台上开始流行起来的。实际上人们发现，尽管他们可以编写出像著名的“nervous text”那样栩栩如生的applet，但applet无法在JDK 1.0安全模型中完成大量有用的工作。例如，由于JDK 1.0下的applet要受到严密的监管，因此，即使applet在公司安全内部网上运行时风险相对较小，applet也无法在企业内部网上发挥很大的作用。

Sun公司很快就认识到，要使applet真正变得有用，用户必须可以根据applet的来源为其**分配不同的安全级别** *assign different levels of security* 。如果applet来自值得信赖的提供商，并且没有被篡改过，那么applet的用户就可以决定是否给applet授予更多的运行特权。

如果要给予一个applet更多的信任，你必须知道下面两件事：
1. **这个applet来自哪里**？
2. **在传输过程中代码是否被破坏**？

在过去的50年里，数学家和计算机科学家已经开发出各种各样成熟的算法，用于**确保数据和电子签名的完整性**，在 `java.security` 包中包含了许多这类算法的实现，而且幸运的是，你无需掌握相应的数学基础知识，就可以使用 `java.security` 包中的算法。下面几节中，介绍**消息摘要是如何检测数据文件中的变化**，以及**数字签名是如何证明签名者的身份**。

## 22.5.1 消息摘要
**消息摘要** *message digest* 是数据块的数字指纹。例如，==所谓的SHA1（安全散列算法#1）可将任何数据块，无论其数据有多长，都压缩为160位（20字节）的序列==。与真实的指纹一样，人们希望任何两条消息都不会有相同的SHA1指纹。当然，这是不可能的——因为只存在 $2^{160}$ 个SHA1指纹，所以肯定会有某些消息具有相同的指纹。因为 $2^{160}$ 是一个很大的数字，所以存在重复指纹的可能性微乎其微，那么这种重复的可能性到底小到什么程度呢？根据 *True Odds: How Risks Affect Your Everyday Life, James Walsh* 一书中所叙述的，人死于雷击的概率为三万分之一。现在，假设有9个人，比如你不喜欢的9个经理或者教授，你和他们所有的人都死于雷击的概率，比伪造的消息与原有消息具有相同SHA1指纹的概率还要高（当然，可能有你不认识的其他10个以上的人会死于雷击，但这里讨论的是你选择的特定的人的死亡概率）。

**消息摘要具有两个基本属性**：
1. **如果数据的1位或者几位改变了，那么消息摘要也将改变**。
2. **拥有给定消息的伪造者 *forger* ，不能创建与原消息具有相同摘要的假消息**。

当然，第二个属性又是一个概率问题。让我们来看看下面这位亿万富翁留下的遗嘱：
```java
"Upon my death, my property shall be divided equally among my children; however, my son George shall receive nothing."
```
这份遗嘱的SHA1指纹 *fingerprint* 为：
```java
12 5F 09 03 E7 31 30 19 2E A6 E7 E4 90 43 84 B4 38 99 8F 67
```
这位有疑心病的父亲将这份遗嘱交给一位律师保存，而将指纹交给另一位律师保存。现在，假设George能贿赂那位保存遗嘱的律师，他想修改这份遗嘱，使得Bill一无所得。当然，这会将原指纹改为下面这样完全不同的位模式 *that changes the fingerprint to a completely different bit pattern* ：
```java
7D F6 AB 08 EB 40 EC CD AB 74 ED E9 86 F9 ED 99 D1 45 B1 57
```
那么George能找到与原指纹相匹配的其他措辞 *some other wording that matches the fingerprint* 吗？如果从地球形成之时，他就很自豪地拥有10亿台计算机，每台计算机每秒钟能处理一百万条信息，他依然无法找到一个能替换的遗嘱。

人们已经设计出大量的算法，用于计算这些消息摘要，其中最著名的两种算法是SHA1和MD5。SHA1是由美国国家标准和技术学会开发的加密散列算法，MD5是由麻省理工学院的Ronald Rivest发明的算法。这两种算法都使用了独特巧妙的方法，对消息中的各个位进行扰乱 *scramble* 。如果要了解这些方法的详细信息，见 *Cryptography and Network Security, 5th Edition, William Stallings* ，值得注意的是，最近人们在这两种算法中发现了某些微妙的规律性，因此美国国家标准和技术学会建议切换到更强的加密算法上，Java支持SHA-2和SHA-3算法集。

`MessageDigest` 类是用于创建「封装了指纹算法的对象」的“工厂”，它的静态方法 `getInstance` 返回「继承了 `MessageDigest` 类的某个类」的对象。这意味着 `MessageDigest` 类能承担下面的双重职责：
- 作为一个工厂类。
- 作为所有消息摘要算法的超类。

例如，下面获取一个能计算SHA指纹的对象（如果要获取计算MD5的对象，使用字符串“MD5”作为 `getInstance` 的参数）：
```java
MessageDigest alg = MessageDigest.getInstance("SHA-1");
```
在获取 `MessageDigest` 对象之后，可以通过反复调用 `update` 方法，将信息中的所有字节提供给该对象。例如，下面的代码将文件中的所有字节传给上面创建的 `alg` 对象，以执行指纹算法：
```java
InputStream in = . . .
int ch;
while ((ch = in.read()) != -1)
	alg.update((byte) ch);
```
另外，如果这些字节存放在一个数组中，那就可以一次完成整个数组的更新：
```java
byte[] bytes = ...;
alg.update(bytes);
```
当完成上述操作后，调用 `digest` 方法。该方法按照指纹算法的要求补齐输入 *pads the input* ，并且进行相应的计算，然后以字节数组的形式返回消息摘要。
```java
byte[] hash = alg.digest();
```

`hash/Digest.java` 计算了一个消息摘要，既可以用SHA，也可以使用MD5来计算。可以按如下方式、在命令行中指定文件和算法：
```bash
$ java hash.Digest hash/input.txt SHA-1
```
如果没有提供命令行参数，那么就会提示输入文件名和算法名。
```java
// hash/Digest.java
package hash;

import java.io.*;
import java.nio.file.*;
import java.security.*;
import java.util.*;

/** 
 * This program computes the message digest of a file
 */
public class Digest {
	/**
	 * @param args args[0] is the filename, args[1] is optionally the algorithm
	 * (SHA-1, SHA-256, or MD5)
	 */
	public static void main(String[] args) throws IOException, GeneralSecurityException {
		var in = new Scanner(System.in);
		String filename;
		if (args.length >= 1) filename = args[0];
		else {
			System.out.print("File name: ");
			filename = in.nextLine();
		}
		String algname;
		if (args.length >= 2) algname = args[1];
		else {
			System.out.println("Select one of the following algorithms: ");
			for (Provider p : Security.getProviders())
				for (Provider.Service s : p.getServices())
					if (s.getType().equals("MessageDigest"))
						System.out.println(s.getAlgorithm());
			System.out.print("Algorithm: ");
			algname = in.nextLine();
		}
		MessageDigest alg = MessageDigest.getInstance(algname);
		byte[] input = Files.readAllBytes(Paths.get(filename));
		byte[] hash = alg.digest(input);
		for (int i = 0; i < hash.length; ++i)
			System.out.printf("%02X ", hash[i] & 0xFF);
		System.out.println();
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212131521612.png)

> [API] `java.security.MessageDigest` 1.1
> - `static MessageDigest getInstance(String algorithm Name)`
> 返回实现指定算法的 `MessageDigest` 对象。如果没有提供该算法，则抛出一个 `NoSuchAlgorithmException` 异常。
> - `void update(byte input)`
> - `void update(byte[] input)`
> - `void update(byte[]input, int offset, int len)`
> 使用指定的字节来更新摘要。
> - `byte[] digest()`
> 完成散列计算，返回计算所得的摘要，并复位算法对象。
> - `void reset()`
> 复位摘要。

## 22.5.2 消息签名
上一节介绍了如何计算**消息摘要**，即**原始消息的指纹**的方法。==如果消息改变了，那么「改变后的消息的指纹」与原消息的指纹将不匹配。如果消息和它的指纹是分开传送的，那么接收者就可以检查消息是否被篡改过==。但**如果消息和指纹同时被截获了，对消息进行修改、再重新计算指纹，就是一件很容易的事情**。毕竟，消息摘要算法是公开的，不需要使用任何密钥。在这种情况下，假消息和新指纹的接收者永远不会知道消息已经被篡改。**数字签名解决了这个问题**。

为了了解数字签名的工作原理，我们需要解释公密加密技术领域 *public key cryptography* 中的几个概念。==公密加密技术是基于公共密钥和私有密钥这两个基本概念的。它的设计思想是你可以将公共密钥告诉世界上的任何人，但只有自己才持有私有密钥，重要的是你要保护你的私有密钥，不将它泄漏给其他任何人==。这些密钥之间存在一定的数学关系，但这种关系的具体性质、对于实际的编程来说并不重要。如果有兴趣，可以参阅 [*The Handbook of Applied Cryptography*](http://www.cacr.math.uwaterloo.ca/hac/) 一书。

密钥非常长，而且很复杂。例如，下面是一对匹配的数字签名算法 *Digital Signature Algorithm, DSA* 的公共密钥和私有密钥。
```java
公共密钥：
p: fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e17
q: 962eddcc369cba8ebb260ee6b6a126d9346e38c5
g: 678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca4
y: c0b6e67b4ac098eb1a32c5f8c4c1f0e7e6fb9d832532e27d0bdab9ca2d2a8123ce5a8018b8161a760480fadd040b927281ddb22cb9bc4df596d7de4d1b977d50
私有密钥：
p: fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e17
q: 962eddcc369cba8ebb260ee6b6a126d9346e38c5
g: 678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca4
x: 146c09f881656cc6c51f27ea6c3a91b85ed1d70a
```
==在现实中，几乎不可能用一个密钥去推算出另一个密钥==。也就是说，即使每个人都知道你的公共密钥，不管他们拥有多少计算资源，他们一辈子也无法计算出你的私有密钥。

**任何人都无法根据公共密钥来推算私有密钥**，这似乎让人难以置信。但是时至今日，还没有人能找到一种算法，来为现在常用的加密算法进行这种推算。如果密钥足够长，那么要是使用穷举法——也就是直接试验所有可能的密钥——所需要的计算机将比用太阳系中所有原子制造的计算机还要多，而且还得花费数千年的时间。当然，可能会有人提出比穷举更灵活的计算密钥的算法。

例如，RSA算法（该加密算法由 *Rivest, Shamir, Adleman* 发明）就利用了对数值巨大的数字进行因子分解的困难性。在最近20年里，许多优秀的数学家都在尝试提出好的因子分解算法，但迄今为止都没有成功。据此，大多数密码学者认为，拥有2000位或者更多位“模数 *modulus* ”的密钥目前是完全安全的，可以抵御任何攻击。**DSA被认为具有类似的安全性**。

图22-10展示了实践中这种机制是如何工作的。
![图22-10 使用DSA进行公共密钥签名的交换](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212111459289.png)

假设Alice想要给Bob发送一个消息，Bob想知道该消息是否来自Alice，而不是冒名顶替者。==Alice写好了消息，并且用她的私有密钥对该消息摘要签名==。==Bob得到了她的公共密钥的拷贝，然后Bob用公共密钥对该签名进行校验==。如果通过了校验，则Bob可以确认以下两个事实：
1. 原始消息没有被篡改过。
2. 该消息是由Alice签名的，她是私有密钥的持有者，该私有密钥就是与Bob用于校验的公共密钥相匹配的密钥。

可以看到私有密钥的安全性为什么是最重要的。如果某个人偷了Alice的私有密钥，或者政府要求她交出私有密钥，那么她就麻烦了。小偷或者政府代表就可以假扮她的身份来发送消息，例如资金转账指令，而其他人则会相信这些消息确实来自于Alice。 

## 22.5.3 校验签名
JDK配有一个 `keytool` 程序，该程序是一个命令行工具，用于生成和管理一组证书。我们期望该工具的功能最终能被嵌入到其他更加用户友好的程序中去。但现在要做的是，**使用 `keytool` 工具来展示Alice是如何对一个文档进行签名**、并且将它发送给Bob的，而**Bob又是如何校验该文档确实是由Alice签名、而非冒名顶替的**。

**`keytool` 程序负责管理密钥库 *keystores* 、证书数据库和私有/公有密钥对**。密钥库中的每一项 *entry* 都有一个别名 *alias* 。下面展示Alice如何创建一个密钥库 `alice.certs` 、并用别名生成一个密钥对。
```bash
$ keytool -genkeypair -keystore alice.certs -alias alice
```
当新建或者打开一个密钥库时，系统将提示你**输入密钥库口令**，在下面的这个例子中，口令就使用 `secret` ，如果你要将 `keytool` 生成的密钥库用于重要的应用，那么需要选择一个好的口令来保护这个文件。
> 此处报错：keytool 错误: java.lang.Exception: 必须指定 -keyalg 选项。

当生成一个密钥时，系统提示输入下面这些信息：
```bash
Enter keystore password: secret
Reenter new password: secret
What is your first and last name?
	[Unknown]: Alice Lee
What is the name of your organizational unit?
	[Unknown]: Engineering
What is the name of your organization?
	[Unknown]: ACME Software
What is the name of your City or Locality?
	[Unknown]: San Francisco
What is the name of your State or Province?
	[Unknown]: CA
What is the two-letter country code for this unit?
	[Unknown]: US
Is <CN=Alice Lee, OU=Engineering, O=ACME Software, L=San Francisco, ST=CA, C=US> correct?
	[no]: yes
```
`keytool` 工具使用X.500格式的名字，它包含常用名 *Common Name, CN*、机构单位 *Organizational Unit, OU*、机构 *Organization, O*、地点 *Location, L*、州 *State, ST* 和国别 *Country, C* 等成分，以确定密钥持有者和证书发行者的身份 *identify key owners and certificate issuers* 。

最后，**必须设定一个密钥口令**，或按回车键，将密钥库口令作为密钥口令来使用。

==假设Alice想把她的公共密钥提供给Bob，她必须导出一个证书文件==：
```bash
$ keytool -exportcert -keystore alice.certs -alias alice -file alice.cer
```
这时，Alice就可以把证书发送给Bob。当Bob收到该证书时，他可以将证书打印出来：
```bash
$ keytool -printcert -file alice.cer
```
打印的结果如下：
```bash
Owner: CN=Alice Lee, OU=Engineering, O=ACME Software, L=San Francisco, ST=CA, C=US
Issuer: CN=Alice Lee, OU=Engineering, O=ACME Software, L=San Francisco, ST=CA, C=US
Serial number: 470835ce
Valid from: Sat Oct 06 18:26:38 PDT 2007 until: Fri Jan 04 17:26:38 PST 2008
Certificate fingerprints:
	MD5: BC:18:15:27:85:69:48:B1:5A:C3:0B:1C:C6:11:B7:81
	SHA1: 31:0A:A0:B8:C2:8B:3B:B6:85:7C:EF:C0:57:E5:94:95:61:47:6D:34
	Signature algorithm name: SHA1withDSA
	Version: 3
```
如果Bob想检查他是否得到了正确的证书，可以给Alice打电话，让她在电话里读出证书的指纹。
> 注意：有些证书发放者将证书指纹公布在他们的网站上。例如，要检查 `jre/lib/security` 目录中的密钥库里的VeriSign公司的证书，可以使用 `-list` 选项：
> ```bash
> $ keytool -list -v -keystore jre/lib/security/cacerts
> ```
> 该**密钥库的口令**是 `changeit` 。在该密钥库中有一个证书是：
> ```java
> Owner: OU=VeriSign Trust Network, OU="(c) 1998 VeriSign, Inc. - For authorized use only", OU=Class 1 Public Primary Certification Authority - G2, O="VeriSign, Inc.", C=US
> Issuer: OU=VeriSign Trust Network, OU="(c) 1998 VeriSign, Inc. - For authorized use only", OU=Class 1 Public Primary Certification Authority - G2, O="VeriSign, Inc.", C=US
> Serial number: 4cc7eaaa983e71d39310f83d3a899192
> Valid from: Sun May 17 17:00:00 PDT 1998 until: Tue Aug 01 16:59:59 PDT 2028 
> Certificate fingerprints:
> 	MD5: DB:23:3D:F9:69:FA:4B:B9:95:80:44:73:5E:7D:41:83
> 	SHA1: 27:3E:E1:24:57:FD:C4:F9:0C:55:E8:2B:56:16:7F:62:F5:32:E5:47
> ```
> 通过访问[网址](http://www.verisign.com/repository/root.html)，就可以核实该证书的有效性。

**一旦Bob信任该证书，他就可以将它导入密钥库中**，他就有了Alice的公共密钥。
```bash
$ keytool -importcert -keystore bob.certs -alias alice -file alice.cer
```
> 警告：**绝对不要将你并不完全信任的证书导入到密钥库中**。一旦证书添加到密钥库中，使用密钥库的任何程序都会认为这些证书可以用来对签名进行校验。

现在Alice就可以**开始**给Bob发送已签名文档 *signed documents* 了。具体步骤如下。Alice需要先将要签名的文档 *the document to be signed* 添加到一个JAR文件中：
```bash
$ jar cvf document.jar document.txt
```
`jarsigner` 工具负责对JAR文件进行签名和校验，然后使用 `jarsigner` 工具将签名添加到文件中，她必须指定要使用的密钥库、JAR文件和密钥的别名：
```bash
$ jarsigner -keystore alice.certs document.jar alice
```
当Bob收到JAR文件时，他可以使用 `jarsigner` 程序的 `-verify` 选项，对文件进行校验。
```bash
$ jarsigner -verify -keystore bob.certs document.jar
```
Bob不需要设定密钥别名。**`jarsigner` 程序会在数字签名中找到密钥所有者的X.500名字，并在密钥库中搜寻匹配的证书**。如果JAR文件没有受到破坏而且签名匹配，那么 `jarsigner` 程序将打印：
```bash
jar verified.
```
否则，程序将显示一个出错消息。

## 22.5.4 认证问题
假设你从朋友Alice那接收到一个消息，该消息是Alice用她的私有密钥签名的，使用的签名方法就是我们刚刚介绍的方法。你可能已经有了她的公共密钥，或者你能容易地获得她的公共密钥，比如问她要一个密钥拷贝，或者从她的Web页中获得密钥。这时，你就可以校验该消息是否是Alice签过名的，并且有没有被破坏过。

现在，假设你从一个声称代表某著名软件公司的陌生人那里获得了一个消息，他要求你运行消息附带的程序。这个陌生人甚至将他的公共密钥的拷贝发送给你，以便让你校验他是否是该消息的作者。你检查后会发现该签名是有效的，这就证明该消息是用匹配的私有密钥签名的，并且没有遭到破坏。

此时你要小心：你仍然不清楚谁写的这条消息。任何人都可以生成一对公共密钥和私有密钥，再用私有密钥对消息进行签名，然后把签名好的消息和公共密钥发送给你。**这种确定发送者身份的问题称为“认证问题”** *authentication problem* 。

解决这个认证问题的通常做法是比较简单的。假设陌生人和你有一个你们俩都值得信赖的共同熟人，陌生人亲自约见了该熟人，将包含公共密钥的磁盘交给了他。后来，你的熟人与你见面，向你担保他与该陌生人见了面，并且该陌生人确实在那家著名的软件公司工作，然后将磁盘交给你（参见图20-10）。这样一来，你的熟人就证明了陌生人身份的真实性。
![图20-10 通过一个值得信赖的中间人进行认证](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212111814776.png)

事实上，你的熟人并不需要与你见面。取而代之的是，**他可以将他的私有签名应用于陌生人的公共密钥文件之上即可**（参见图20-11）。当你拿到公共密钥文件之后，就可以检验你的熟人的签名是否真实，由于你信任他，因此你确信他在添加他的签名之前，确实核实了陌生人的身份。
![图20-11 通过受信赖的中间人的签名进行认证](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212111816448.png)
然而，你们之间可能没有共同的熟人。==有些信任模型假设你们之间总是存在一个“信任链”——即一个共同熟人的链路——这样你就可以信任该链中的每个成员==。当然，实际情况并不总是这样。你可能信任你的熟人Alice，而且你知道Alice信任Bob，但你不了解Bob，因此你没有把握究竟是不是该信任他。==其他的信任模型则假设有一个大家都信任的慈善者==，在扮演这个角色的公司中，有名的是公司DigiCert、GlobalSign和Entrust，它们都提供认证服务。

你常常会遇到「由负责担保他人身份的一个或多个实体」签署的数字签名，必须评估一下究竟能在多大程度上信任这些身份认证人。你可能非常信赖某种特定的证书授权、或某个公司。然而，对于实际被认证的对象，你应抱有一个符合实际的期望：在认证公共密钥时，直接在Web页面上填一份表格，并支付少量的费用，就可以获得一个“第一类 *class 1*” ID，包含在证书中的密钥将被发送到指定的邮件地址。因此，你有理由相信该电子邮件是真实的，但密钥申请人也可能填入任意名字和机构。还有其他对身份信息的检验更加严格的ID类别。例如，如果是“第三类 *class 3*” ID，VeriSign将要求密钥申请人必须进行身份公证，公证机构将要核实企业申请者的财务信用资质。其他认证机构将采用不同的认证程序。因此，==当你收到一条经过认证的消息时，重要的是你应明白它实际上认证了什么==。
## 22.5.5 证书签名
在22.5.3节中，已看到了Alice如何**使用自签名的证书向Bob分发公共密钥**。但，Bob需要通过**校验Alice的指纹以确保这个证书是有效的**（发送的文档也要签名，并用得到的证书进行校验）。

假设Alice想要给同事Cindy发送一条经过签名的消息，但Cindy并不希望因为要校验许多签名指纹而受到困扰。因此，假设有一个Cindy信任的实体来校验这些签名。在这个例子中，Cindy信任ACME软件公司的信息资源部——这个部门负责证书授权 *certificate authority, CA* 的运作。ACME的每个人在其密钥库中都有CA的公共密钥，这是由一个专门负责详细核查密钥指纹的系统管理员安装的。CA对ACME雇员的密钥进行签名（？），当他们在安装彼此的密钥时，密钥库将隐含地信任这些密钥，因为它们是由一个可信任的密钥签名的。

下面显示了可以如何模仿这个过程。首先需要创建一个密钥库 `acmesoft.Certs` ，生成一个密钥对并导出公共密钥：
```bash
$ keytool -genkeypair -keystore acmesoft.certs -alias acmeroot
$ keytool -exportcert -keystore acmesoft.certs -alias acmeroot -file acmeroo.cer
```
其中的公共密钥被导入到了一个自签名的证书 *"self-signed" certificate* 中，然后将其添加到每个雇员的密钥库中：
```bash
$ keytool -importcert -keystore cindy.certs -alias acmeroot -file acmeroot.cer
```
如果Alice要发送消息给Cindy以及ACME软件公司的其他任何人，她需要将她的证书提交给信息资源部，并使其被签名（用公司私钥加密？）。但这个功能在 `keytool` 程序中是缺失的。在附带的代码中，提供了一个 `CertificateSigner` 类来弥补这个问题（？）。ACME软件公司的授权机构成员将负责核实Alice的身份，并且生成如下的签名证书：
```bash
$ java CertificateSigner -keystore acmesoft.certs -alias acmeroot \
	-infile alice.cer -outfile alice_signedby_acmeroot.cer
```
证书签名器程序必须拥有对ACME软件公司密钥库的访问权限，并且该公司成员必须知道密钥库的口令，显然这是一项敏感的操作。

现在Alice将文件 `alice_signedby_acmeroot.cert` 交给Cindy和ACME软件公司的其他任何人。或，ACME软件公司直接将该文件存储在公司的目录中。记住，**该文件包含了Alice的公共密钥**和**ACME软件公司的声明**，证明该密钥确实属于Alice。

现在，Cindy将签名的证书导入到她的密钥库中：
```bash
$ keytool -importcert -keystore cindy.certs -alias alice -file alice_signedby_acmeroot.cer
```
密钥库校验以确定该密钥是由密钥库中已有的受信任的根密钥签过名的（用公司公钥解密？）。Cindy就不必对证书的指纹进行校验了。

一旦Cindy添加了根证书和经常给她发送文档的人的证书后，她就再也不用担心密钥库了。
## 22.5.6 证书请求
前一节用密钥库和 `CertificateSigner` 工具模拟了一个CA。但大多数CA，都运行着更加复杂的软件来管理证书，并且使用的证书格式也略有不同。本节展示与这些软件包进行交互时、需要增加的处理步骤。

用OpenSSL软件包作为实例。许多Linux系统和Mac OS X都预装了这个软件，并且用于Windows的Cygwin端口也可用这个软件，也可到[http://www.openssl.org](http://www.openssl.org)网站下载。

为了创建一个CA，需要运行CA脚本，其确切位置依赖于你的操作系统。在Ubuntu上，运行：
```bash
$ /usr/lib/ssl/misc/CA.pl -newca
```
这个脚本会在当前目录中创建一个 `demoCA` 子目录，这个目录包含了一个根密钥对，并存储于证书与证书撤销列表 *certificate revocation lists* 。

你希望将这个公共密钥导入到所有雇员的Java密钥库中，但是它的格式是隐私增强型邮件 *Privacy Enhanced Mail, PEM* 格式，而不是密钥库更容易接受的DER格式。将文件 `demoCA/cacert.pem` 复制成文件 `acmeroot.pem` ，然后在文本编辑器中打开这个文件。移除下面这行之前的所有内容：
```bash
-----BEGIN CERTIFICATE-----
```
以及下面这行之后的所有内容：
```bash
-----END CERTIFICATE-----
```
现在可以按照通常的方式，将 `acmeroot.pem` 导入到各个密钥库中了：
```bash
$ keytool -importcert -keystore cindy.certs -alias alice -file acmeroot.pem
```
这看起来有点不可思议，`keytool` 竟然不能自己去执行这种编辑操作。

要对Alice的公共密钥签名，需要生成一个证书请求 *certificate request* ，它包含这个PEM格式的证书：
```bash
$ keytool -certreq -keystore alice.store -alias alice -file alice.pem
```
要签名这个证书，需要运行：
```bash
$ openssl ca -in alice.pem -out alice_signedby_acmeroot.pem
```
与前面一样，在 `alice_signedby_acmeroot.pem` 中切除 `BEGIN CERTIFICATE/END CERTIFICATE` 标记之外的所有内容。然后，将其导入到密钥库中：
```bash
$ keytool -importcert -keystore cindy.certs -alias alice -file alice_signedby_acmeroot.pem
```
你可以使用相同的步骤，使一个证书得到诸如VeriSign这样的公共证书权威机构的签名。
（这一节不明白？）

## 22.5.7 代码签名
**认证技术最重要的一个应用是，对可执行程序进行签名**。如果从网上下载一个程序，自然会关心该程序可能带来的危害，例如，该程序可能已经感染了病毒。==如果知道代码从何而来，并且它从离开源头后就没有被篡改过，那么放心程度会比不清楚这些信息时要高得多==。
> 事实上，如果该程序是用Java语言编写的，那么就可以利用这些信息来理性地决定应让该程序拥有什么样的特权。或许只让它像普通applet一样在沙盒里运行，或者也可能为它授予一组不同的权限和限制条件。例如，你下载了一个文字处理器，你可能想授予它访问打印机和某个子目录中的文件的权限，但不想授予它建立网络连接的权限，这样，该程序就无法在你不知道的情况下将你的文件发送给第三方。

在本节中，介绍如何对JAR文件签名，以及如何配置Java以校验这种签名。这种能力是为applet和Java Web Start应用而设计的。这些技术已经不在被广泛使用了，但仍旧需要在遗留产品中支持他们。

当Java首次发布时，applet在加载后就运行于具有有限权限的“沙盒”之中。如果用户想要使用「能访问本地文件系统、创建网络连接等诸如此类功能的applet」，那么必须明确同意允许其运行。为了确保applet代码不会在传输过程中被篡改，必须对其进行数字签名。

下面是一个具体例子，假设当你在因特网上冲浪时，遇到了一个Web站点，倘若你为它授予了需要的权限，它就会运行一个来自不明提供商的applet（图22-12）。这样的程序，是用由证书权威机构发放的“软件开发者”证书进行签名的。弹出的对话框，用于确定软件开发者和证书发放者的身份。现在，你需要决定是否对该程序授权。现在你有两个选择：
- 用全部特权运行程序。
- 将程序限制在沙盒中运行（对话框中的Cancel按钮是一种误导。如果点击这个按钮，applet不会被取消，而是运行在沙盒中）。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212112127824.png)

那么什么样的因素，可能会影响你的决定呢？假设下面是你已经了解的情况：
1. Thawte公司将一个证书卖给了软件开发人员。
2. 程序确实是用该证书签名的，并且在传输过程中没有被篡改过。
3. 该证书确实是由Thawte签名的——它被本地 `cacerts` 文件中的公共密钥校验过。
当然，上面这些信息都不能告诉你、代码是否可以安全运行。如果你只知道供应商的名字，以及Thawte公司卖给了他们一个软件开发者证书这个事实，那么你会信赖该供应商 *vendor* 吗？这种方式显然没什么意义。如果想要担保ChemAxonKft.不是个彻头彻尾的破解者，恐怕连Thawte公司自己也会陷入麻烦之中。毕竟，没有一个证书发放者会对软件供应商的诚信度和资格能力进行广泛的审查。

对内联网部署，证书更有用。管理员可以在本地机器上、安装策略文件和证书，使得在启动从受信源而来的代码时（它就会查询密钥库的签名和策略文件中的权限），可以无需任何用户交互。无论何时，只要Java插件工具加载了签名的代码，它就会向策略文件索要权限、向密钥库索要签名。

本节剩余部分，介绍如何建立策略文件，来为已知来源的代码赋予特定的权限。创建和部署这些策略文件不是普通最终用户要做的（然而，系统管理员在准备部署企业内联网程序时需要做这些工作）。

假设ACME软件公司想让它的用户、运行某些需要具备本地文件访问权限的程序，并且想要通过浏览器部署这些程序为Web Start应用。正如前面看到的那样，ACME可以根据程序代码库来确定它们的身份，但那将意味着每当程序移动到不同的Web服务器时，ACME都需要更新策略文件。为此，ACME决定对含有程序代码的JAR文件进行签名。

首先，ACME生成根证书：
```bash
$ keytool -genkeypair -keystore acmesoft.certs -alias acmeroot
```
当然，包含根密钥的密钥库必须存放在一个安全的地方。因此，我们用 `-exportcert` 导出公共密钥，并为公共证书建立第二个密钥库 `client.certs` ，将公共的 `acmeroot` 证书添加进去。
```bash
$ keytool -exportcert -keystore acmesoft.certs -alias acmeroot -file acmeroot.cer
$ keytool -importcert -keystore client.certs -alias acmeroot -file acmeroot.cer
```

为了创建一个经过签名的JAR文件，首先将各个类文件添加到JAR文件中，然后**ACME中某个受信任的人运行 `jarsigner` 工具，通过指定JAR文件和私有密钥的别名，对任何想要签名的应用签名**：
```bash
$ jarsigner -keystore acmesoft.certs ACMEApp.jar acmeroot
```
被签名的Web Start应用，现在就已经准备好在Web服务器中部署了。

接着，让我们转而配置客户机，必须将一个策略文件发布到每一台客户机上。为了引用密钥库，策略文件将以下面这行开头：
```bash
keystore "keystoreURL", "keystoreType";
```
其中，URL可以是绝对的或相对的，其中相对URL是相对于策略文件的位置而言的。如果密钥库是由 `keytool` 工具生成的，则它的类型是 `JKS` 。例如：
```bash
keystore "client.certs", "JKS";
```
`grant` 子句可以有 `signedBy "alias"` 后缀，例如：
```bash
grant signedBy "acmeroot" {
	...
};
```
所有可以用「与别名相关联的公共密钥」进行校验的签名代码，现在都已经在grant语句中被授予了权限。

---
# 22.7 加密
到现在为止，已介绍了一种在Java security API中实现的重要密码技术，**即通过数字签名进行的认证**。安全性的第二个重要方面是**加密** *encryption* 。当信息通过认证之后，该信息本身是直白可见的。**数字签名只不过负责检验信息有没有被篡改过**。相比之下，信**息被加密后，是不可见的，只能用匹配的密钥进行解密**。

==认证对于代码签名已足够了 *Authentication is sufficient for code signing* ——没必要将代码隐藏起来==。但是，当applet或者应用程序传输机密信息时，比如信用卡号码和其他个人数据等，就有必要进行加密了。

过去，由于专利和出口控制的原因，许多公司被禁止提供高强度的加密技术。幸运的是，现在对加密技术的出口控制已经不是那么严格了，某些重要算法的专利也已到期。现在，Java SE已经有了出色的加密支持，它已经成为标准类库的一部分。
## 22.7.1 对称密码
**Java密码扩展包含了一个 `Cipher` 类，该类是所有加密算法的超类**。通过调用下面的 `getInstance` 方法可以获得一个 `Cipher` 对象：
```java
Cipher cipher = Cipher.getInstance(algorithName);
```
或者调用下面这个方法：
```java
Cipher cipher = Cipher.getInstance(algorithName, providerName);
```
JDK中是由名为“SunJCE”的提供商提供Ciphers的，如果没有指定其他提供商，则会默认为该提供商。如果要使用特定的算法，而对该算法、Oracle公司没有提供支持，那么也可以指定其他的提供商。

算法名称是一个字符串，比如 `"AES"` 或者 `"DES/CBC/PKCS5Padding"` 。数据加密标准 *Data Encryption Standard, DES* ，是一个密钥长度为56位的古老的分组密码 *block cipher* 。**DES加密算法在现在看来已经是过时了**，因为可以用穷举法将它破译（参见[网页中的例子](http://www.eff.org/Privacy/Crypto/Crypto_misc/DESCracker/)）。更好采用它的后续版本，即高级加密标准 *AES* ，更多详细信息访问[网址](http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf)。下面我们以AES为例。

一旦获得了一个密码对象，就可以通过设置模式和密钥来对它初始化。
```java
int mode = ...;
Key key = ...;
cipher.init(mode, key);
```
模式有以下几种：
```java
Cipher.ENCRYPT_MODE
Cipher.DECRYPT_MODE
Cipher.WRAP_MODE
Cipher.UNWRAP_MODE
```
**`wrap` 和 `unwrap` 模式会用一个密钥对另一个密钥进行加密**，具体例子见下一节。

现在可以反复调用 `update` 方法来对数据块进行加密。
```java
int blockSize = cipher.getBlockSize();
var inBytes = new byte[blockSize];
... // read inBytes
int outputSize= cipher.getOutputSize(blockSize);
var outBytes = new byte[outputSize];
int outLength = cipher.update(inBytes, 0, outputSize, outBytes);
... // write outBytes
```
完成上述操作后，还必须调用一次 `doFinal` 方法。如果还有最后一个输入数据块（其字节数小于 `blockSize` ），那么就要调用：
```java
outBytes = cipher.doFinal(inBytes, 0, inLength);
```
如果所有的输入数据都已经加密，则用下面的方法调用来代替：
```java
outBytes = cipher.doFinal();
```
**对 `doFinal` 的调用是必要的，以对最后的块进行“填充”**。就拿DES密码来说，它的数据块的大小是8字节。假设输入数据的最后一个数据块少于8字节，当然我们可以将其余的字节全部用0填充，从而得到一个8字节的最终数据块，然后对它进行加密。但==当对数据块进行解密时，数据块的结尾会附加若干个0字节，因此它与原始输入文件之间会略有不同。这肯定是个问题==，我们需要一个填充方案 *padding scheme* 来避免这个问题。常用的填充方案是RSA Security公司在[公共密钥密码标准#5, *Public Key Cryptography Standard, PKCS*](ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-5v2/pkcs5v2-0.pdf)中描述的方案。

在该方案中，最后一个数据块不是全部用填充值0进行填充，而是用等于填充字节数量的值 *a pad value that equals the number of pad bytes* 作为填充值进行填充。换句话说，如果 `L` 是最后一个（不完整的）数据块，那么它将按如下方式进行填充：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212120208408.png)
最后，如果**输入的数据长度**确实能被8整除，那么就会将下面这个数据块：
```java
08 08 08 08 08 08 08 08
```
附加到数据块后，并进行加密。==在解密后，明文的最后一个字节就是要丢弃的填充字符数==。
## 22.7.2 密钥生成
为了加密，我们需要生成密钥。每个 *cipher* 都有不同的密钥格式，我们需要确保密钥的生成是随机的。这需要遵循下面的步骤：
1. 为加密算法获取 `KeyGenerator` 。
2. 用随机源来初始化密钥发生器。如果密码块的长度是可变的，还需要指定期望的密码块长度 *the desired block length* 。
3. 调用 `generateKey` 方法。

例如，下面是如何生成AES密钥的方法：
```java
KeyGenerator keygen = KeyGenerator.getInstance("AES");
var random = new SecureRandom(); // see below
keygen.init(random);
Key key = keygen.generateKey();
```
或者，可以从一组固定的原生数据（也许是由口令或者随机击键产生的）来生成一个密钥，这时可以使用如下的 `SecretKeyFactory` ：
```java
byte[] keyData = ...; // 16 bytes for AES
var key = new SecretKeySpec(keyData, "AES");
```
当你要生成密钥时，必须确保使用“真随机”数 *truly random numbers* 。例如，在 `Random` 类中常规的随机数发生器。是根据当前的日期和时间来产生随机数的，因此它不够随机。例如，假设计算机时钟可以精确到1/10秒，那么，每天最多存在864000个种子。如果攻击者知道发布密钥的日期（通常可以由消息日期或证书有效日期推算出来），那么就可以很容易地生成那一天所有可能的种子。

`SecureRandom` 类产生的随机数，远比由 `Random` 类产生的那些数字安全得多。你仍然需要提供一个种子，以便在一个随机点上开始生成数字序列。要这样做，最好的方法是从一个「诸如白噪声发生器之类的硬件设备」那里获取输入。另一个合理的随机输入源是，请用户在键盘上进行随心所欲的盲打，但每次敲击键盘只为随机种子提供1位或者2位。一旦你在字节数组中收集到这种随机位后，就可以将它传递给 `setSeed` 方法。
```java
var secrand = new SecureRandom();
var b = new byte[20];
// fill with truly random bits
secrand.setSeed(b);
```
如果没有为随机数发生器提供种子，那么它将通过启动线程，使它们睡眠，然后测量它们被唤醒的准确时间 *launching threads, putting them to sleep, and measuring the exact time when they are awakened* ，以此来计算自己的20个字节的种子。
> 注意：这个算法仍然未被认为是安全的。而且在过去，依靠对其他一些计算机组件（如硬盘访问时间之类）进行计时的算法，后来也被证明并不是完全随机的。

结尾示例程序 `aes/AESTest` 将应用AES密码。如果要使用该程序，首先要生成一个密钥，运行如下命令行：
```bash
$ java aes.AESTest -genkey secret.key
```
密钥就被保存在 `secret.key` 文件中了。现在可以用如下命令进行加密：
```bash
$ java aes.AESTest -encrypt plaintextFile encryptedFile secret.key
```
用如下命令进行解密：
```bash
$ java aes.AESTest -decrypt encryptedFile decryptedFile secret.key
```
该程序非常直观：
- 使用 `-genkey` 选项将产生一个新的密钥，并且将其序列化到给定的文件中。该操作需要花费较长的时间，因为密钥随机生成器的初始化非常耗费时间。
- `-encrypt` 和 `-decrypt` 选项都调用相同的 `crypt` 方法，而 `crypt` 方法则调用密码的 `update` 和 `doFinal` 方法。注意 `update` 方法和 `doFinal` 方法是怎样被调用的：只要输入数据块具有全长度 *full length*（长度能被8整除），就要调用 `update` 方法，而如果输入数据块不具有全长度（长度不能被8整除，此时需要填充），或没有更多额外的数据（以便生成一个填充字节 *to generate one pad block* ），那么就要调用 `doFinal` 方法。

```java
// aes/AESTest.java
package aes;
import java.io.*;
import java.security.*;
import javax.crypto.*;

/**
 * This program tests the AES cipher.
 * Usage: <br>
 * java aes.AESTest -genkey keyfile<br>
 * java aes.AESTest -encrypt plaintext encrypted keyfile<br>
 * java aes.AESTest -decrypt encrypted decrypted keyfile<br>
 */
public class AESTest {
	public static void main(String[] args) 
		throws IOException, GeneralSecurityException, ClassNotFoundException {
		if (args[0].equals("-genkey")) {
			KeyGenerator keygen = KeyGenerator.getInstance("AES");
			var random = new SecureRandom();
			keygen.init(random);
			SecretKey key = keygen.generateKey();
			try (var out = new ObjectOutputStream(new FileOutputStream(args[1]))) {
				out.writeObject(key);
			}
		} else {
			int mode;
			if (args[0].equals("-encrypt")) mode = Cipher.ENCRYPT_MODE;
			else mode = Cipher.DECRYPT_MODE;
			
			try (var keyIn = new ObjectInputStream(new FileInputStream(args[3]));
				var in = new FileInputStream(args[1]);
				var out = new FileOutputStream(args[2])) {
				var key = (Key) keyIn.readObject();
				Cipher cipher = Cipher.getInstance("AES");
				cipher.init(mode, key);
				Util.crypt(in, out, cipher);
			}
		}
	}
}
```
```java
// aes/Util.java
package aes;

import java.io.*;
import java.security.*;
import javax.crypto.*;

public class Util {
	/**
	 * Uses a cipher to transform the bytes in an input stream and 
	 * sends the transformed bytes to an an output stream
	 * @param in the input stream
	 * @param out the output stream
	 * @param cipher the cipher that transforms the bytes
	 */
	public static void crypt(InputStream in, OutputStream out, Cipher cipher) 
		throws IOException, GeneralSecurityException {
		int blockSize = cipher.getBlockSize(); // update one block every time 
		int outputSize = cipher.getOutputSize(blockSize); // get max size of transformed bytes
		var inBytes = new byte[blockSize];
		var outBytes = new byte[outputSize];

		int inLength = 0;
		var done = false;
		while (!done) {
			inLength = in.read(inBytesc);
			if (inLength == blockSize) {
				int outLength = cipher.update(inBytes, 0, blockSize, outBytes); // actual bytes size
				out.write(outBytes, 0, outLength);
			} else done = true;
		}
		if (inLength > 0) outBytes = cipher.doFinal(inBytes, 0, inLength);
		else outBytes = cipher.doFinal();
		out.write(outBytes);
	}
}
```
运行结果如下所示：
```bash
$ javac aes/AESTest.java aes/Util.java
$ java aes.AESTest -genkey aes/secret.key
$ java aes.AESTest -encrypt aes/test.jpg aes/encryptedTest.jpg aes/secret.key
$ java aes.AESTest -decrypt aes/encryptedTest.jpg aes/decryptedTest.jpg aes/secret.key
```
测试所用图片和结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212140014410.png)

> [API] `javax.crypto.Cipher` 1.4
> - `static Cipher getInstance(String algorithmName)
> - `static Cipher getInstance(String algorithmName, String providerName)`
> 返回实现了指定加密算法的 `Cipher` 对象。如果未提供该算法，则抛出一个 `NoSuchAlgorithmException` 异常。
> - `int getBlockSize()`
> 返回密码块 *cipher block* 的大小，如果该密码不是一个块密码 *block cipher* ，则返回0。
> - `int getOutputSize(int inputLength)`
> 如果下一个输入数据块拥有给定的字节数，则返回所需的输出缓冲区的大小。本方法的运行要考虑到密码对象中的所有已缓冲的字节数量 *any buffered bytes in the cipher object* 。
> - `void init(int mode, Key key)`
> 对加密算法对象进行初始化。`Mode` 是 `ENCRYPT_MODE, DECRYPT_MODE, WRAP_MODE, UNWRAP_MODE` 之一。
> - `byte[] update(byte[] in)`
> - `byte[] update(byte[] in, int offset, int length)`
> - `int update(byte[] in, int offset, int length, byte[] out)`
> 对输入数据块进行转换。前两个方法返回该输出，第三个方法返回放入`out` 的字节数。
> - `byte[] doFinal()`
> - `byte[] doFinal(byte[] in)`
> - `byte[] doFinal(byte[] in, int offset, int length)`
> - `int doFinal(byte[] in, int offset, int length, byte[] out)`
> 转换输入的最后一个数据块，并刷新该加密算法对象的缓冲。前三个方法返回输出，第四个方法返回放入 `out` 的字节数。

> [API] `javax.crypto.KeyGenerator` 1.4
> - `static KeyGenerator getInstance(String algorithmName)`
> 返回实现指定加密算法的 `KeyGenerator` 对象。如果未提供该加密算法，则抛出一个 `NoSuchAlgorithmException` 异常。
> - `void init(SecureRandom random)`
> - `void init(int keySize, SecureRandom random)`
> 对密钥生成器进行初始化。
>- `SecretKey generateKey()`
> 生成一个新的密钥。

> [API] `javax.crypto.spec.SecretKeySpec` 1.4
> - `SecretKeySpec(byte[] key, String algorithmName)`
> 创建一个密钥描述规格说明。

## 22.7.3 密码流
**JCE库提供了一组使用便捷的流类，用于对流数据进行自动加密或解密**。例如，下面是对文件数据进行加密的方法：
```java
Cipher cipher = ...;
cipher.init(Cipher.ENCRYPT_MODE, key);
var out = new CipherOutputStream(new 
    FileOutputStream(outputFileName), cipher);
var bytes = new byte[BLOCKSIZE];
int inLength = getData(bytes); // get data from data source
while (inLength != -1) {
	out.write(bytes, 0, inLength);
	inLength = getData(bytes); // get more data from data source
}
out.flush();
```
同样地，可以使用 `CipherInputStream` ，对文件的数据进行读取和解密：
```java
Cipher cipher = ...;
cipher.init(Cipher.DECRYPT_MODE, key);
var in = new CipherInputStream(
	new FileInputStream(inputFileName), cipher);
var bytes = new byte[BLOCKSIZE];
int inLength = in.read(bytes);
while (inLength != -1) {
	putData(bytes, inLength); // put data to destination
	inLength = in.read(bytes);
}
```
密码流类能透明地调用 `update` 和 `doFinal` 方法，所以非常方便。
> `javax.crypto.CipherInputStream 1.4
> - `CipherInputStream(InputStream in, Cipher cipher)`
> 构建一个输入流，以读取 `in` 中的数据，并且使用指定的密码对数据进行解密和加密。
> - `int read()`
> - `int read(byte[] b, int off, int len)`
> 读取输入流中的数据，该数据会被自动解密和加密。

> [API] `javax.crypto.CipherOutputStream 1.4
> - `CipherOutputStream（OutputStream out, Cipher cipher)` 
> 构建一个输出流，以便将数据写入 `out` ，并且使用指定的密码对数据进行加密和解密。
> - `void write(int ch)`
> - `void write(byte[] b, int off, int len)`
> 将数据写入输出流，该数据会被自动加密和解密。
> - `void flush()`
> 刷新密码缓冲区，如果需要的话，执行填充操作。

## 22.7.4 公共密钥密码
在前面小节中看到的==AES密码是一种对称密码，加密和解密都使用相同的密钥。对称密码的致命缺点在于密码的分发==。如果Alice给Bob发送了一个加密的方法，那么Bob需要使用与Alice相同的密钥。如果Alice修改了密钥，那么她必须在给Bob发送信息的同时，还要通过安全信道发送新的密钥，但是也许她并不拥有到达Bob的安全信道，这也正是为什么她必须对她发送给Bob的信息进行加密的原因。

公共密钥密码技术解决了这个问题。在公共密钥密码中，Bob拥有一个密钥对，包括一个公共密钥和一个相匹配的私有密钥。==Bob可以在任何地方发布公共密钥，但是他必须严格保守他的私有密钥。Alice只需要使用公共密钥对她发送给Bob的信息进行加密即可==。

实际上，**加密过程并没有那么简单**。所有已知的公共密钥算法的操作速度，都比对称密钥算法（比如DES或AES等）**慢得多**，使用公共密钥算法对大量的信息进行加密是不切实际的。但==如果像下面这样，将公共密钥密码与快速的对称密码结合起来，这个问题就可以得到解决==：
1. Alice生成一个随机对称加密密钥，她用该密钥对明文进行加密。
2. **Alice用Bob的公共密钥给对称密钥进行加密**。
3. Alice将加密后的对称密钥和加密后的明文同时发送给Bob。
4. **Bob用他的私有密钥给对称密钥解密**。
5. Bob用解密后的对称密钥给信息解密。

除了Bob之外，其他人无法给对称密钥进行解密，因为只有Bob拥有解密的私有密钥。因此，**昂贵的公共密钥加密技术只适用于给少量的关键数据加密**。

最普通的公共密钥算法是 *Rivest, Shamir, Adleman* 发明的RSA算法。直到2000年10月，该算法一直受RSA Security公司授予的专利保护。该专利的转让许可证价格昂贵，通常要支付3%的专利权使用费，每年至少付款50000美元。现在该加密算法已经公开。**如果要使用RSA算法，就需要一对公共/私有密钥**。你可以按如下方法使用 `KeyPairGenerator` 来获得：
```java
KeyPairGenerator pairgen = KeyPairGenerator.getInstance("RSA");
var random = new SecureRandom();
pairgen.initialize(KEYSIZE, random);

KeyPair keyPair = pairgen.generateKeyPair();
Key publicKey = keyPair.getPublic();
Key privateKey = keyPair.getPrivate();
```
程序 `rsa/RSATest.java` 有三个选项。`-genkey` 选项用于产生一个密钥对，`-encrypt` 选项用于生成AES密钥，并且**用公共密钥对其进行包装 *wrap*** 。
```java
Key key = ...; // an AES key
Key publicKey = ...; // a public RSA key
Cipher cipher = Cipher.getInstance("RSA");
cipher.init(Cipher.WRAP_MODE, publicKey);
byte[] wrappedKey = cipher.wrap(key);
```
然后它便生成一个包含下列内容的文件：
- 包装过的密钥的长度。
- 包装过的密钥字节。
- 用AES密钥加密的明文。

`-decrypt` 选项用于对这样的文件进行解密。请试运行该程序，首先生成RSA密钥：
```bash
$ java rsa.RSATest -genkey public.key private.key
```
然后对一个文件进行加密：
```bash
$ java rsa.RSATest -encrypt plaintextFile encryptedFile public.key
```
最后，对该文件进行解密，并且检验解密后的文件是否与明文相匹配：
```bash
$ java rsa.RSATest -decrypt encryptedFile decryptedFile private.key
```
```java
// rsa/RSATest.java
package rsa;

import java.io.*;
import java.security.*;
import javax.crypto.*;

/**
 * This program test the RSA cipher. 
 * java rsa.RSATest -genkey public private<br>
 * java rsa.RSATest -encrypt plaintext encrypted public<br>
 * java rsa.RSATest -decrypt encrypted decrypted private<br>
 */
public class RSATest {
	private static final int KEYSIZE = 512;

	public static void main(String[] args)
		throws IOException, GeneralSecurityException, ClassNotFoundException {
		if (args[0].equals("-genkey")) {
			// generate a pair of private/public RSA key
			KeyPairGenerator pairgen = KeyPairGenerator.getInstance("RSA");
			var random = new SecureRandom();
			pairgen.initialize(KEYSIZE, random);
			KeyPair keyPair = pairgen.generateKeyPair();

			try (var out = new ObjectOutputStream(new FileOutputStream(args[1]))) {
				out.writeObject(keyPair.getPublic());
			}
			try (var out = new ObjectOutputStream(new FileOutputStream(args[2]))) {
				out.writeObject(keyPair.getPrivate());
			}
		} else if (args[0].equals("-encrypt")) {
			// AES is a symmetric cipher with only one key
			KeyGenerator keygen = KeyGenerator.getInstance("AES");
			var random = new SecureRandom();
			keygen.init(random);
			SecretKey key = keygen.generateKey();

			// wrap with RSA public key
			try (var keyIn = new ObjectInputStream(new FileInputStream(args[3])); // public key
				var out = new DataOutputStream(new FileOutputStream(args[2]));
				var in = new FileInputStream(args[1])) {
				var publicKey = (Key) keyIn.readObject();
				
				Cipher cipher = Cipher.getInstance("RSA");
				cipher.init(Cipher.WRAP_MODE, publicKey);
				byte[] wrappedKey = cipher.wrap(key); // wrap AES key with RSA public key
				out.writeInt(wrappedKey.length);
				out.write(wrappedKey); // wrapped AES key

				cipher = Cipher.getInstance("AES");
				cipher.init(Cipher.ENCRYPT_MODE, key);
				Util.crypt(in, out, cipher); 
				// Uses cipher(AES) to encrypt the bytes in an input stream 
				// and sends the transformed bytes into an output stream
			} 
		} else {
			try (var in = new DataInputStream(new FileInputStream(args[1]));
				var keyIn = new ObjectInputStream(new FileInputStream(args[3])); // private key
				var out = new FileOutputStream(args[2])) {
				int length = in.readInt();
				var wrappedKey = new byte[length];
				in.read(wrappedKey, 0, length); // wrapped AES key

				// unwrap with RSA private key
				var privateKey = (Key) keyIn.readObject();
				Cipher cipher = Cipher.getInstance("RSA");
				cipher.init(Cipher.UNWRAP_MODE, privateKey);
				Key key = cipher.unwrap(wrappedKey, "AES", Cipher.SECRET_KEY);

				cipher = Cipher.getInstance("AES");
				cipher.init(Cipher.DECRYPT_MODE, key);
				Util.crypt(in, out, cipher);
			}
		}
	}
}
```
```java
// ras/Util.java
package rsa;

import java.io.*;
import java.security.*;
import javax.crypto.*;

public class Util {
	/**
	 * Uses a cipher to transform the bytes in an input stream and sends the transformed bytes to an
	 * output stream.
	 * @param in the input stream
	 * @param out the output stream
	 * @param cipher the cipher that transforms the bytes
	 */
	public static void crypt(InputStream in, OutputStream out, Cipher cipher) 
		throws IOException, GeneralSecurityException {
	    int blockSize = cipher.getBlockSize();
	    int outputSize = cipher.getOutputSize(blockSize);
	    var inBytes = new byte[blockSize];
	    var outBytes = new byte[outputSize];

	    int inLength = 0;
      
	    var done = false;
	    while (!done) {
			inLength = in.read(inBytes);
	        if (inLength == blockSize) {
	            int outLength = cipher.update(inBytes, 0, blockSize, outBytes);
	            out.write(outBytes, 0, outLength);
	        } else done = true;
	    }
	    if (inLength > 0) outBytes = cipher.doFinal(inBytes, 0, inLength);
	    else outBytes = cipher.doFinal();
	    out.write(outBytes);
	}
}
```
运行结果如下所示：
```bash
$ javac rsa/*.java
$ java rsa.RSATest -genkey rsa/public.key rsa/private.key
$ java rsa.RSATest -encrypt rsa/test.jpg rsa/encryptedTest.jpg rsa/public.key
$ java rsa.RSATest -decrypt rsa/encryptedTest.jpg rsa/decryptedTest.jpg rsa/private.key
```
测试所用图片和结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212140111230.png)
其中，三幅图片的大小有所不同，encryptedTest.jpg的大小大于原图和解密后的图片，因为里面还有加密后的对称密钥：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212140116315.png)

现在已经看到了，Java安全模型是如何允许我们去控制代码的执行的，这是Java平台的一个独一无二且越来越重要的方面。你也已经看到了Java类库提供的认证和加密服务。但没有涉及许多高级和专有的话题，比如：
- 提供了对 *Kerberos* 协议进行支持的“通用安全服务”的GSS-API（原则上同样支持其他安全信息交换协议）。下面网址上有一份[指南](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jgss/tutorials)。
- 对SASL的支持，SASL即简单认证和安全层，可以为LDAP和IMAP协议所使用。如果想在自己的应用程序中实现SASL，见[下面](http://docs.oracle.com/javase/7/docs/technotes/guides/security/sasl/sasl-refguide.html)。
- 对SSL的支持，SSL即安全套接层。**在HTTP上使用SSL对应用程序的编程人员是透明的，只需直接使用以 `https` 开头的URL即可**。如果想要给你的应用程序添加SSL支持，参阅下面网址中的[Java安全套接扩展, JSSE参考指南](http://java.sun.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html)。
