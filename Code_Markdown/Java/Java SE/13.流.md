▲从迭代到流操作
▲流的创建
▲filter, map, flatMap方法
▲抽取子流和组合流
▲其他的流转换
▲简单约简
▲Optional类型
▲收集结果
▲收集到映射表中
▲群组与分区
▲下游收集器
▲约简操作
▲基本类型流
▲并行流

与集合相比，流提供了一种「让我们在更高的概念级别上指定计算任务」的数据视图 *view of data* 。通过使用流，你指定想要做什么、而不是怎样做它，你将操作的调度留给具体实现来解决 *leave the scheduling of operations to the implementation* 。例如，假设想要计算某个属性的平均值，那就可以指定数据源和该属性，然后流库能对计算进行优化，例如使用多线程来计算总和与个数，并将结果结合起来。

这里学习如何使用Java的流库（Java 8中引入），用来 *process collections in a "what, not how" style* 。

## 13.1 从迭代到流操作
处理集合时，我们通常会迭代遍历它的元素，并在每个元素上执行某项操作。例如，假设想要计数某本书中的所有长单词。首先将所有单词放到一个列表中：
```java
String contents = new String(
	Files.readAllBytes(Paths.get("alice.txt")),
	StandardCharsets.UTF_8
); // Read file into string
List<String> words = Arrays.asList(contents.split("\\PL+"));
	// Split into words; nonletters are delimiters
```
现在可以迭代它了：
```java
long count = 0;
for (String w : words) {
	if (w.length() > 12) count++;
}
```
使用流时，相同的操作看起来像下面这样：
```java
long count = words.stream()
	.filter(w -> w.length() > 12)
	.count();
```
流版本更易读，现在不必扫描整个代码去查找过滤和计数操作，方法名就可以直接告诉我们代码意欲何为。而且，循环需要非常详细地描述操作的顺序，而流却能以想要的任何方式来调度这些操作 *schedule the operations any way it wants* ，只要结果正确即可。

仅把 `stream` 修改为 `parallelStream` ，就可以让流库以并行方式执行过滤和计数：
```java
long count = words.parallelStream()
	.filter(w -> w.length() > 12)
	.count();
```
流遵循"What, now How"的原则，在流示例中描述了需要做什么：获取长单词、并对它们计数，而没有指定该操作应以什么顺序或者在哪个线程中执行。开头处的循环，要确切指定计算应如何工作，因此也就丧失了优化的机会。

流表面上和集合相似，都可以让我们转换和获取数据。但它们之间存在着显著的差异：
1. **流并不存储其元素**。这些元素可能存储在一个底层的集合中，或是按需生成的。
2. **流的操作不会修改其数据源**。例如 `filter` 方法不会从流中移除元素，而是会生成一个新的流，其中不包含被过滤掉的元素。
3. **流的操作是尽可能惰性执行的** *lazy when possible* 。这意味着直到需要结果时，操作才会执行。例如，如果只想查找前5个长单词（而不是所有），那 `filter` 方法就会在匹配到第5个单词后停止过滤。因此，我们甚至能有无限流 *have infinite streams* 。

再来看这个示例，`stream` 和 `parallelStream` 会产生一个用于 `words` 列表的流，`filter` 方法返回另一个流、其中只包含长度大于12的单词，`count` 方法将这个流化简 *reduce* 为一个结果。**这个工作流是操作流时的典型流程**，我们建立了一个**三阶段操作管道**：
1. 创建一个流。
2. 指定「将初始流转换为其他流的中间操作 *intermediate operations* 」，可能包含多个步骤。
3. ==应用终止操作 *terminal operation* ，从而产生结果==。这个操作会==强制执行之前的懒操作。此后这个流就再也不能用了==。

`streams/CountLongWords.java` 中，流是用 `stream` 或 `parallelStream`方法创建的，`filter` 方法对其进行转换，`count` 方法终止操作。
```java
// streams/CountLongWords.java
package streams;

import java.io.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;

public class CountLongWords {
	public static void main(String[] args) throws IOException {
		var contents = new String(Files.readAllBytes(Paths.get("./src/alice30.txt")), StandardCharsets.UTF_8);
		List<String> words = List.of(contents.split("\\PL+"));

		long count = 0;
		for (String w : words)
			if (w.length() > 12) ++count;
		
		System.out.println(count);
		
		count = words.stream().filter(w -> w.length() > 12).count();
		System.out.println(count);
	
		count = words.parallelStream().filter(w -> w.length() > 12).count();
		System.out.println(count);
	}
}
```
运行结果如下所示：
```java
27
27
27
```
后面学习创建流、以及流的转换、终止操作。

> [API] `java.util.stream.Stream<T>` 8
> - `Stream<T> filter(Predicate<? super T> p)`
> 产生一个流，其中包含当前流中满足 `p` 的所有元素。
> - `long count()` 
> 产生当前流中元素的数量，是一个终止操作。

> [API] `java.util.Collection<E>` 1.2
> - `default Stream<E> stream()`
> - `default Stream<E> parallelStream()`
> 产生当前集合中所有元素的顺序流或并行流。

## 13.2 流的创建
已知道**可用 `Collection` 接口的 `stream` 方法，将任何集合转换为一个流**。如果有一个数组，那么可以**使用静态的 `Stream.of` 方法**：
```java
Stream<String> words = Stream.of(contents.split("\\PL+"));
	// split returns a String[] array
```
`of` 方法具有一个可变参数，因此可以从任意数量的参数构造流：
```java
Stream<String> song = Stream.of("gently", "down", "the", "stream");
```

**使用 `Array.stream(array, from, to)`** ，可以用数组中的一部分元素创建一个流。

`Stream` 接口有两个用于创建无限流的静态方法。`generate` 方法会接受一个无参数的函数 *a function with no arguments*（技术上讲是一个 `Supplier<T>` 接口的对象）。无论何时，只要需要一个流值 *a stream value* ，该函数就被调用、来产生一个（这样的）值。我们可像下面这样，获得一个常量值的流 *a stream of constant values* ：
```java
Stream<String> echos = Stream.generate(() -> "Echo");
```
或像下面这样，获得一个随机数的流：
```java
Stream<Double> randoms = Stream.generate(Math::random);
```

如果要产生像0 1 2 3...这样的序列，可以使用 `iterate` 方法。它会接受一个“种子”值和一个函数（技术上讲是一个 `UnaryOperation<T>` ），并且会反复地将该函数应用到之前的结果上。例如，下面序列的第一个元素是 `BigInteger.ZERO` ，第二个元素是 `f(seed)` 即1（作为大整数），下一个元素是 `f(f(seed))` 即2，以此类推：
```java
Stream<BigInteger> integers = Stream.iterate(BigInteger.ZERO,
	n -> n.add(BigInteger.ONE));
```

==如果要产生一个有限序列，则需要添加一个**谓词** *predicate* 、来描述迭代应如何结束==。只要该谓词拒绝了某个迭代生成的值，这个流就结束：
```java
var limit = new BigInteger("10000000");
Stream<BigInteger> integers = Stream.iterate(BigInteger.ZERO,
	n -> n.compareTo(limit) < 0,
	n -> n.add(BigInteger.ONE));
```

最后，**`Stream.ofNullable` 方法会用一个对象来创建一个非常短的流**。如果该对象为 `null` ，那么这个流的长度为0；否则，这个流的长度为1，即只包含该对象。**这个方法与 `flatMap` 相结合时最有用**（1.7.7节示例）。
> 注释：Java API中大量方法都可以产生流。例如，`Pattern` 类的 `splitAsStream` 方法，会按照某个正则表达式来分割一个 `CharSequence` 对象。可使用下面的语句来将一个字符串分割为一个个的单词：
> ```java
> Stream< String> words = Pattern.compile("\\PL+").splitAsStream(contents);
> ```
> `Scanner` 的 `tokens` 方法会产生一个扫描器 *scanner* 的符号流。另一种从字符串中获取单词流的方式是：
> ```java
> Stream< String> words = new Scanner(contents).tokens();
> ```
> 静态的 `Files.lines` 方法会返回一个包含文件中所有行的 `Stream` ：
> ```java
> try (Stream< String> lines = Files.lines(path)) {
> 	// process lines
> }
> ```

**如果我们持有的 `Iterable` 对象不是集合，那么可以通过下面的调用将其转换为一个流**：
```java
StreamSupport.stream(iterable.spliterator(), false);
```
如果持有的是 `Iterator` 对象，并且希望得到一个由它的结果构成的流，那么可以使用下面的语句：
```java
StreamSupport.stream(Spliterators.spliteratorUnknownSize(
	iterator, Spliterator.ORDERED), false);
```

> 警告：==至关重要的是，在执行流操作时，我们并没有修改流背后的集合==。记住，==流并没有收集其数据，数据一直存储在单独的集合中==。如果你修改了该集合，那么流操作的结果是未定义的。JDK文档称这种要求为**不干涉性** *noninterference* 。
> 
> 准确地，==因为中间的流操作是懒惰的，所以在终止操作得以执行时，集合有可能已经发生了变化==。例如，尽管不推荐下面这段代码，但是它仍旧可以工作：
> ```java
> List< String> wordList = ...;
> Stream< String> words = wordList.stream();
> wordList.add("END");
> long n = words.distinct().count();
> ```
> 但下面的代码是错误的：
> ```java
> Stream< String> words = wordList.stream();
> words.forEach(s -> if (s.length() < 12) wordList.remove(s));
> 	// ERROR--interference
> ```

`streams/CreatingStreams.java` 展示了创建流的各种方式。
```java
// streams/CreatingStreams.java
package streams;

import java.io.IOException;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.*;

public class CreatingStreams {
	public static <T> void show(String title, Stream<T> stream) {
		final int SIZE = 10;
		List<T> firstElements = stream.limit(SIZE + 1)
			.collect(Collectors.toList());
		System.out.print(title + ": ");
		for (int i = 0; i < firstElements.size(); ++i) {
			if (i > 0) System.out.print(", ");
			if (i < SIZE) System.out.print(firstElements.get(i));
			else System.out.print("...");
		}
		System.out.println();
	}
	
	public static void main(String[] args) throws IOException {
		Path path = Paths.get("./src/alice30.txt");
		var contents = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);
	
		Stream<String> words = Stream.of(contents.split("\\PL+"));
		show("words", words);
		Stream<String> song = Stream.of("gently", "down", "the", "stream");
		show("song", song);
		Stream<String> silence = Stream.empty();
		show("silence", silence);
	
		Stream<String> echos = Stream.generate(() -> "Echo");
		show("echos", echos);
	
		Stream<Double> randoms = Stream.generate(Math::random);
		show("randoms", randoms);
	
		Stream<BigInteger> integers = Stream.iterate(BigInteger.ONE,
			n -> n.add(BigInteger.ONE));
		show("integers", integers);
	
		Stream<String> wordsAnotherWay = Pattern.compile("\\PL+").splitAsStream(contents);
		show("wordsAnotherWay", wordsAnotherWay);
	
		try (Stream<String> lines = Files.lines(path)) {
			show("lines", lines);
		}
	
		Iterable<Path> iterable = FileSystems.getDefault().getRootDirectories();
		Stream<Path> rootDirectories = StreamSupport.stream(iterable.spliterator(), false);
		show("rootDirectories", rootDirectories);
	
		Iterator<Path> iterator = Paths.get("./src/alice30.txt").iterator();
		Stream<Path> pathComponents = StreamSupport.stream(Spliterators.spliteratorUnknownSize(
			iterator, Spliterator.ORDERED), false);
		show("pathComponents", pathComponents);
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212162133848.png)

> [API] `java.util.stream.Stream` 8
> - `static <T> Stream<T> of(T... values)`
> 产生一个元素为给定值的流。
> - `static <T> Stream<T> empty()`
> 产生一个不包含任何元素的流。
> - `static <T> Stream<T> generate(Supplier<T> s)`
> 产生一个无限流，它的值是通过反复调用函数 `s` 而构建的。
> - `static <T> Stream<T> generate(Supplier<T> s)`
> - `static <T> Stream<T> iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> f)`
> 产生一个无限流，它的元素包含 `seed` 、在 `seed` 上调用 `f` 产生的值、在前一个元素上调用 `f` 产生的值等等。第一个方法产生一个无限流，第二个方法的流碰到第一个不满足 `hasNext` 谓词的元素时终止。
> - `static <T> Stream<T> ofNullable(T t)` 9
> 如果 `t` 为 `null` ，返回一个空流，否则返回包含 `t` 的流。

> [API] `java.util.Spliterators` 8
> - `static <T> Spliterator<T> spliteratorUnknownSize(Iterator<? extends T> iterator, int characteristics)`
> 用给定的特性（一种包含诸如 `Spliterator.ORDERED` 之类的常量的位模式）将一个迭代器，转换为一个具有未知尺寸的、可分割的迭代器 *a splittable iterator of unknown size with the given characteristics* 。

> [API] `java.util.Arrays`
> - `static <T> Stream<T> stream(T[] array, int startInclusive, int endExclusive)` 8
> 产生一个流，它的元素是由数组中指定范围内的元素构成的。

> [API] `java.util.regex.Pattern` 1.4
> - `Stream<String> splitAsStream(CharSequence input)` 8
> 产生一个流，它的元素是输入中由该模式界定的部分。

> [API] `java.nio.file.Files` 7
> - `static Stream<String> lines(Path path)` 8
> - `static Stream<String> lines(Path path, Charset cs)` 8
> 产生一个流，它的元素是指定文件中的行，该文件的字符集为UTF_8或指定的字符集。

> [API] `java.util.stream.StreamSupport` 8
> - `static <T> Stream<T> stream(Spliterator<T> spliterator, boolean parallel)`
> 产生一个流，它包含了由给定的可分割迭代器产生的值。

> [API] `java.lang.Iterable`
> - `Spliterator<T> spliterator()`
> 为这个 `Iterable` 产生一个可分割的迭代器，默认实现不分割也不报告尺寸。

> [API] `java.util.Scanner` 5
> - `public Stream<String> tokens()` 9
> 产生一个字符串流，该字符串是调用这个扫描器的 `next` 方法时返回的。

> [API] `java.util.function.Supplier<T>` 8
> - `T get()`
> 提供一个值。

## 13.3 `filter, map, flatMap` 方法
==流的转换会产生一个新的流，它的元素派生自另一个流中的元素==。我们已经看到，**`filter`**（参数是 `Predicate<T>` ，即从 `T` 到 `boolean` 的函数）**转换会产生一个新流，它的元素匹配某种条件**。下面将一个字符串流转换为「只包含长单词的另一个流」：
```java
List<String> words = ...;
Stream<String> longWords = words.stream()
	.filter(w -> w.length() > 12);
```

经常，**我们想要按某种方式来转换流中的值。此时可用 `map` 方法、并传递执行该转换的函数**。例如，可像下面这样、将所有单词都转换为小写：
```java
Stream<String> lowercaseWords = words.stream().map(String::toLowerCase);
```
这里使用的是带有**方法引用**的 `map` ，但通常可用**lambda表达式**来代替。下面语句产生的流中，包含了所有单词的首字母：
```java
Stream<String> firstLetters = words.stream().map(s -> s.substring(0, 1));
```

在使用 `map` 时会有一个函数应用到每个元素上，并且其结果是包含了「应用该函数后产生的所有结果」的流。现在假设有一个函数，它返回的不是一个值、而是一个包含众多值的流。下面的示例展示的方法，将把字符串转换为字符串流，即一个个编码点 *the individual code points* ：
```java
public static Stream<String> codePoints(String s) {
	var result = new ArrayList<String>();
	int i = 0;
	while (i < s.length()) {
		int j = s.offsetByCodePoints(i, 1);
		result.add(s.substring(i, j));
		i = j;
	}
	return result.stream();
}
```
这个方法可以正确地处理需要用两个 `char` 值表示的Unicode字符，因为本来就应这样处理。但我们不用再次纠结其细节。假如 `codePoints("boat")` 的返回值是流 `["b", "o", "a", "t"]` 。假设在字符串流上映射 `codePoints` 方法：
```java
Stream<Stream<String>> result = words.stream().map(w -> codePoints(w));
```
那么将得到一个包含流的流，像 `[... ["y", "o", "u", "r"], ["b", "o", "a", "t"], ...]` 。为了将其摊平为单个流 `[... "y", "o", "u", "r", "b", "o", "a", "t", ...]` ，可以使用 `flatMap` 方法、而不是 `map` 方法：
```java
Stream<String> flatResult = words.stream().flatMap(w -> codePoints(w));
	// Calls codePoints on each word and flattens the results
```

在流之外的类中也会发现 `flapMap` 方法，因为它是计算机科学中的一种通用概念。假设有一个泛型 `G`（例如 `Stream` ），以及将某种类型 `T` 转换为 `G<U>` 的函数 `f` 和将类型 `U` 转换为 `G<V>` 的函数 `g` 。我们可以通过使用 `flatMap` 来组合它们，即先应用 `f` 、再应用 `g` ，这是单子论 *monads* 的关键概念。
> [API] `java.util.stream.Stream` 8
> - `Stream<T> filter(Predicate<? super T> predicate)`
> 产生一个流，它包含当前流中所有满足谓词条件的元素。
> - `<R> Stream<R> map(Function<? super T, ? extends R> mapper)`
> 产生一个流，它包含将 `mapper` 应用于当前流中所有元素所产生的结果。
> - `<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`
> 产生一个流，它是通过将 `mapper` 应用于当前流中所有元素所产生的结果连接到一起而获得的（这里的每个结果都是一个流）。	
 
---
# 13.4 抽取子流和组合流
**调用 `stream.limit(n)` 会返回一个新的流，它在 `n` 个元素之后结束**（如果原来的流比 `n` 短，则在该流结束时结束）。这个方法用于裁剪无限流的尺寸。例如，下面会产生包含100个随机数的流：
```java
Stream<Double> randoms = Stream.generate(Math::random).limit(100)
```

调用 `stream.skip(n)` 正好相反：它会丢弃前 `n` 个元素。这个方法对于下面的读操作示例很方便，因为按照 `split` 方法的工作方式，第一个元素是没什么用的空字符串，我们可以跳过它：
```java
Stream<String> words = Stream.of(contents.split("\\PL+")).skip(1);
```

`stream.takeWhile(predicate)` 调用，会在谓词为真时获取流中的所有元素，然后停止。例如，假设我们使用上一节的 `codePoints` 方法将字符串分割为字符，然后收集所有的数字元素。`takeWhile` 方法可以实现此目标：
```java
Stream<String> initialDigits = codePoints(str).takeWhile(s -> "0123456789".contains(s));
```

`dropWhile` 方法正好相反。它会在条件为真时丢弃元素，并产生一个「由第一个使该条件为假的字符开始的所有元素」构成的流。
```java
Stream<String> withoutInitialWhiteSpace = codePoints(str).dropWhile(s -> s.trim().length() == 0);
```
我们可以用 `Stream` 类的静态 `concat` 方法将两个流连接起来。当然，第一个流不应是无限的，否则第二个流永远没有机会处理。：
```java
Stream<String> combined = Stream.concat(
codePoints("Hello"), codePoints("World"));
// Yields the stream ["H", "e", "l", "l", "o", "W", "o", "r", "l", "d"]
```

> [API] `java.util.stream.Stream` 8
> - `Stream<T> limit(long maxSize)`
> 产生一个流，其中包含了当前流中最初的 `maxSize` 个元素。
> - `Stream<T> skip(long n) 
> 产生一个流，它的元素是当前流中除了前 `n` 个元素之外的所有元素。
> - `Stream<T> takeWhile(Predicate<? super T> predicate)` 9
> 产生一个流，它的元素是当前流中所有满足谓词条件的元素。
> - `Stream<T> dropWhile(Predicate<? super T> predicate)` 9
> 产生一个流，它的元素是当前流中排除不满足谓词条件的元素之外的所有元素。
> - `static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)`
> 产生一个流，它的元素是 `a` 的元素后面跟着 `b` 的元素。

---
# 13.5 其他的流转换
**`distinct` 方法返回一个流**，它的元素从原有流中产生，即原来的元素**按照同样的顺序剔除重复元素后产生**，这些重复元素不一定相邻。
```java
Stream<String> uniqueWords = Stream.of("merrily", "merrily", "merrily", "gently").distinct();
// Only one "merrily" is retained
```

对于流的排序，有多种 `sorted` 方法的变体可用。其中一种用于操作 `Comparable` 元素的流，另一种可以接受一个 `Comparator` 。下面对字符串排序（从最长到最短）：
```java
Stream<String> longestFirst = words.stream().sorted(Comparator.comparing(String::length).reversed());
```
与所有流转换一样，**`sorted` 方法会产生一个新流**，它的元素是原有流中按照顺序排列的元素。当然，**在对集合排序时可以不用流，但当排序处理是流管道的一部分时，`sorted` 方法就显得很有用**。

最后，**`peek` 方法会产生另一个流，它的元素与原来流中的元素相同，但在每次获取一个元素时，都会调用一个函数**。这对于调试很方便：
```java
Object[] powers = Stream.iterate(1.0, p -> p * 2)
	.peek(e -> System.out.println("Fetching " + e))
	.limit(20).toArray();
```
当实际访问一个元素时，就会打印出一条消息。通过这种方式，可以验证 `iterate` 返回的无限流是被懒处理的。

当我们使用调试器调试流的计算程序时，可以针对各个流转换操作中的某一个，在它所调用的方法中设置断点。==对于大多数IDE，我们也可以在lambda表达式中设置断点==。如果只想了解在流管道的某个特定点上会发生什么，那么可以添加下面的代码，并在第二行上设置断点：
```java
.peek(x -> { 

	return; })
```

> [API] `java.uti.stream.Stream` 8
> - `Stream<T> distinct()` 
> 产生一个流，包含当前流中所有不同的元素。
> - `Stream<T> sorted()`
> - `Stream<T> sorted(Comparator<? super T> comparator)`
> 产生一个流，它的元素是当前流中的所有元素按照顺序排列的。第一个方法要求元素是实现了 `Comparable` 的类的实例。
> - `Stream<T> peek(Consumer<? super T> action)`
> 产生一个流，它与当前流中的元素相同，获取其中每个元素时会将其传递给 `action` *passing each element to action as it is consumed* 。


---
# 13.6 简单约简 *REDUCTIONS* 
现在知道如何创建、转换、抽取、组合、排序流，要讨论最重要的内容，即**从流数据中获取答案**。本节讨论的方法被称为**约简** `reduction` ，它是一种**终结操作** `terminal operations` ，会将流约简为可在程序中使用的非流值 *nonstream value* 。

一种简单约简：`count` 方法返回流中元素的数量。其他的简单约简还有 `max, min` ，分别返回最大值和最小值。稍作解释，这些方法返回的是一个类型 `Optional<T>` 的值——它要么在其中包装了答案，要么表示没有任何值（因为流碰巧为空）。过去碰到这种情况返回 `null` 是很常见的，但这样做会导致在未做完备测试的程序中、产生空指针异常。**`Optional` 类型是一种表示缺失值的更好的方式**，下一节详细讨论这一类型。下面展示如何获取流中最大值：
```java
Optional<String> largest = words.max(String::compareToIgnoreCase);
System.out.println("largest: " + largest.orElse(""));
```

**`findFirst` 返回的是非空集合中的第一个值，它通常在与 `filter` 组合使用时很有用**。例如，找到第一个以Q开头的单词，前提是存在这样的单词：
```java
Optional<String> startsWithQ = words.filter(s -> s.startsWith("Q")).findFirst();
```

如果不强调使用第一个匹配、而是可以使用任意匹配，那么就可以使用 **`findAny` 方法**。**这个方法在并行处理流 *parallelize the stream* 时很有效**，因为流可以报告任何它找到的匹配、而不是被限制为「必须报告第一个匹配」。
```java
Optional<String> startsWithQ
= words.parallel().filter(s -> s.startsWith("Q")).findAny();
```

如果只想知道是否存在匹配，那么可以使用 `anyMatch` ，这个方法接收一个断言 *predicate* 谓词，因此不需要使用 `filter` ：
```java
boolean aWordStartsWithQ = words.parallel().anyMatch(s -> s.startsWith("Q"));
```

还有 **`allMatch, noneMatch` 方法**，分别在所有元素或没有任何元素匹配谓词的情况下、返回 `true` ，这些方法**也可以通过并行运行而获益**。

> [API] `java.util.stream.Stream` 8
> - `Optional<T> max(Comparator<? super T> comparator)`
> - `Optional<T> min(Comparator<? super T> comparator)`
> 分别产生这个流的最大、最小元素，使用给定比较器定义的排序规则。如果这个流为空，则产生一个空 `Optional` 对象。这些操作都是终结操作。
> - `Optional<T> findFirst()`
> - `Optional<T> findAny()`
> 分别产生这个流的第一个和任意一个元素。如果这个流为空，则产生一个空的 `Optional` 对象。这些操作都是终结操作。
> - `boolean anyMatch(Predicate<? super T> predicate)`
> - `boolean allMatch(Predicate<? super T> predicate)`
> - `boolean noneMatch(Predicate<? super T> predicate)`
> 分别在这个流中任一元素、所有元素、没有元素匹配给定谓词时，返回 `true` 。这些操作都是终结操作。

---
# 13.7 `Optional` 类型
**一个 `Optional<T>` 对象是一个包装器，要么包装了类型 `T` 的对象，要么没有包装任何对象**。对第一种情况，称这个值是存在的 *present* 。`Optional<T>` 类型被当做一种更安全的方式，用来替代类型 `T` 的引用，这种引用要么引用某个对象、要么为 `null` 。但它只有在正确使用时才会更安全，下三节讨论如何正确使用。
## 13.7.1 获取 `Optional` 值
有效使用 `Optional` 的关键是，==去使用这样的方法：它在值不存在时产生一个可替代物，而只有在值存在时才使用这个值== *consumes the value only if it is present* 。

下面看第一条策略。通常，在没有任何匹配时，我们会希望使用某种默认值，可能是空字符串：
```java
String result = optionalString.orElse("");
	// The wrapped string, or "" if none
```
还可以调用代码来计算默认值：
```java
String result = optionalString.orElseGet(() -> System.getProperty("myapp.default"));
	// The function is only called when needed
```
或在没有任何值时抛出异常：
```java
String result = optionalString.orElseThrow(IllegalStateException::new);
	// Supply a method that yields an exception object
```

> [API] `java.tuil.Optional` 8
> - `T orElse(T other)`
> 产生这个 `Optional` 值，或者在该 `Optional` 为空时，产生 `other` 。
> - `T orElseGet(Supplier<? extends T> other)`
> 产生这个 `Optional` 值，或者在该 `Optional` 为空时，产生调用 `other` 的结果。
> - `<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)`
> 产生这个 `Optional` 值，或者在该 `Optional` 为空时，抛出调用 `exceptionSupplier` 的结果。

## 13.7.2 消费 `Optional` 值
上一节看到，如何在不存在任何值时产生相应的替代物。另一条使用 *optional values* 的策略是，**只有在其存在的情况下才消费该值**。

`ifPresent` 方法接收一个函数，如果可选值存在，那么它会被传递给该函数，否则不会发生任何事情。
```java
optionalValue.ifPresent(v -> Process v);
```
例如，如果该值存在时想将其添加到某个集中，那么可以调用：
```java
optionalValue.ifPresent(v -> results.add(v));
// or simply
optionalValue.ifPresent(results::add);
```

**如果想要在可选值存在时执行一种动作，在可选值不存在时执行另一种动作，可以用 `ifPresentOrElse`** ：
```java
optionalValue.ifPresentOrElse(
	v -> System.out.println("Found " + v),
	() -> logger.warning("No match"));
```

> [API] `java.util.Optional` 8
> - `void ifPresent(Consumer<? super T> action)`
> 如果该 `Optional` 不为空，就将它的值传递给 `action` 。
> - `void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`
> 如果该 `Optional` 不为空，就将它的值传递给 `action` ，否则调用 `emptyAction` 。

## 13.7.3 管道化 `Optional` 值
上面了解了如何从 `Optional` 对象获取值。另一种有用的策略是，**保持 `Optional` 完整 *intact* ，使用 `map` 方法来转换 `Optional` 内部的值**。如果 `optionalString` 为空，那么 `transformed` 也为空：
```java
Optional<String> transformed = optionalString.map(String::toUpperCase);
```
另一个例子是，将一个结果添加到列表中，如果它存在的话；如果 `optionalValue` 为空，则什么都不会发生：
```java
optionalValue.map(results::add);
```
> 这个 `map` 方法与1.3节 `Stream` 接口的 `map` 方法类似。可以直接将可选值想象成尺寸为0或1的流，结果的尺寸也是0或1，并且后一种情况中，函数会应用于其上。

类似地，可以**使用 `filter` 方法、来只处理那些在转换它之前或之后、满足某种特定属性的 `Optional` 值**。如果不满足该属性，那么管道会产生空结果：
```java
Optional<String> transformed = optionalString
	.filter(s -> s.length() >= 8)
	.map(String::toUpperCase);
```

也可以用 `or` 方法，用一个可选 `Optional` 替换空 `Optional` *substitute an alternative Optional for an empty Optional* 。这个可选 *alternative*将被懒计算。如下，如果 `optionalString` 的值存在，那么 `result` 为 `optionalString` 。如果值不存在，那么就会计算lambda表达式，并使用计算出来的结果：
```java
Optional<String> result = optionalString.or(() -> 
	// Supply an Optional
	alternatives.stream().findFirst());
```

> [API] `java.util.Optional` 8
> - `<U> Optional<U> map(Function<? super T, ? extends U> mapper)`
> 产生一个 `Optional` ，如果当前 `Optional` 的值存在，那么产生的 `Optional` 的值是通过「将给定的函数应用于当前 `Optional` 的值」而得到的；否则，产生一个空 `Optional` 。
> - `Optional<T> filter(Predicate<? super T> predicate)`
> 产生一个 `Optional` ，如果当前 `Optional` 的值满足给定的谓词条件，那么所产生的 `Optional` 的值就是当前 `Optional` 的值；否则，产生一个空 `Optional` 。
> - `Optional<T> or(Supplier<? extends Optional<? extends T>> supplier)` 9
> 如果当前 `Optional` 不为空，则产生当前的 `Optional` ；否则，由 `supplier` 产生一个 `Optional` 。

## 13.7.4 不适合使用 `Optional` 值的方式
如果没有正确使用 `Optional` 值，那么相比以往得到 `something or null` 的方式，就并没有得到任何好处。

`get` 方法会在 `Optional` 值存在时、获得其中包装的元素，或在不存在时抛出一个 `NoSuchElementException` 异常。因此：
```java
Optional<T> optionalValue = ...;
optionalValue.get().someMethod();
```
并不比下面的方式更安全：
```java
T value = ...;
value.someMethod();
```

`isPresent` 方法会报告某个 `Optional<T>` 对象是否有一个值，但是：
```java
if (optionalValue.isPresent())
	optionalValue.get().someMethod();
```
并不比下面的方式更容易处理：
```java
if (value != null) value.someMethod();
```
> 注释：Java 10为 `get` 方法引入一个同义词 `optionalValue.orElseThrow()` ，这个名字明确表示，该方法会在 `optionalValue` 为空时、抛出一个 `NoSuchElementException` 。这样命名，是希望程序员只有在非常明确地知道 `Optional` 永远都不会为空时、才去调用该方法。

下面是一些有关 `Optional` 类型正确用法的提示：
- `Optional` 类型的变量**永远**都不应为 `null` 。
- **不要使用 `Optional` 类型的字段**。因为其代价是额外多出一个对象。在一个类内部，使用 `null` 表示缺失的字段更易于操作。
- **不要在集合中放置 `Optional` 对象，且不要将它们用作 `map` 的键，应直接收集其中的值**。

> [API] `java.util.Optional` 8
> - `T get()`
> - `T orElseThrow()`
> 产生这个 `Optional` 值，或在该 `Optional` 为空时抛出一个 `NoSuchElementException` 异常。
> - `boolean isPresent()`
> 如果该 `Optional` 不为空，则返回 `true` 。

## 13.7.5 创建 `Optional` 值
之前讨论了如何使用他人创建的 `Optional` 对象。如果想编写方法创建 `Optional` 对象，那么有多个方法可以用于此目的，包括 **`Optional.of(result)` 和 `Optional.empty()`** 。例如：
```java
public static Optional<Double> inverse(Double x) {
	return x == 0 ? Optional.empty() : Optional.of(1 / x);
}
```
**静态 `ofNullable` 方法被用来作为「可能出现的 `null` 值和 *optional value* 之间的桥梁」**，`Optional.ofNullable(obj)` 在 `obj` 不为 `null` 时返回 `Optional.of(obj)` ，否则返回 `Optional.empty()` 。

> [API] `java.util.Optional`
> - `static <T> Optional<T> of(T value)`
> - `static <T> Optional<T> ofNullable(T value)`
> 产生一个具有给定值的 `Optional` 。如果 `value` 为空，第一个方法抛出一个 `NoSuchElementException` ，第二个方法产生一个空 `Optional` 。
> - `static <T> Optional<T> empty()`
> 产生一个空 `Optional` 。

## 13.7.6 用 `flatMap` 构建 `Optional` 值的函数
假设有一个可以产生 `Optional<T>` 对象的方法 `f` ，并且目标类型 `T` 具有一个可以生成 `Optional<U>` 对象的方法 `g` 。如果它们都是普通的方法，那么可以通过调用 `s.f().g()` 来将它们组合起来，但这种组合无法工作，因为 `s.f()` 的类型为 `Optional<T>` 、而非 `T` 。因此，需要调用：
```java
Optional<U> result = s.f().flatMap(T::g);
```
如果 `s.f()` 的值存在，那么 `g` 就可以应用到它上面，否则会返回一个空 `Optional<U>` 。

很明显，如果有更多可以产生 `Optional` 值的方法或lambda表达式，那么就可以重复此过程。**可以直接将对 `flatMap` 的调用链接起来，从而构建由这些步骤构成的管道** *pipeline* ，**只有所有步骤都成功，该管道才会成功**。

例如，考虑前一节中安全的 `inverse` 方法，假设还有一个安全的平方根：
```java
public static Optional<Double> squareRoot(Double x) {
	return x < 0 ? Optional.empty() : Optional.of(Math.sqrt(x));
}
```
那么可以像下面这样，计算倒数的平方根：
```java
Optional<Double> result = inverse(x).flatMap(MyMath::squareRoot);
```
或者选择：
```java
Optional<Double> result = Optional.of(-4.0).flatMap(Demo::inverse).flatMap(Demo::squareRoot);
```
无论是 `inverse` 方法还是 `squareRoot` 方法返回 `Optional.empty()` ，整个结果都会为空。
> 注释：在 `Stream` 接口已看过 `flatMap` 方法（1.3节），当时这个方法被用来将产生流的两个方法组合起来，其实现方式是摊平由流组成的流。如果将可选值解释为具有0或1个元素的流，那么 `Optional.flatMap` 方法与其操作方式一样。

> [API] `java.util.Optional` 8
> - `<U> Optional<U> flatMap(Function<? super T, ? extends Optional<? extends U>> mapper)`
> 如果 `Optional` 存在，返回将 `mapper` 应用于当前 `Optional` 值所产生的结果，或者在当前 `Optional` 为空时、返回一个空 `Optional` 。

## 13.7.7 将 `Optional` 转换为流
**`stream` 方法会将一个 `Optional<T>` 对象转换为一个具有0或1个元素的 `Stream<T>` 对象**。*Sure, why not, but why would you ever want that?* **这会使返回 `Optional` 结果的方法变得很有用**。假设我们有一个用户ID的流和下面的方法：
```java
Optional<User> lookup(String id)
```
怎样才能在获取用户流时，跳过那些无效的ID呢？当然，我们可以过滤掉无效ID，然后将 `get` 方法应用于剩余的ID：
```java
Stream<String> ids = ...;
Stream<User> users = ids.map(Users::lookup)
	.filter(Optional::isPresent)
	.map(Optional::get);
```
但这样就要使用之前警告过要慎用的 `isPresent` 和 `get` 方法，下面的调用显得更优雅：
```java
Stream<User> users = ids.map(Users::lookup)
	.flatMap(Optional::stream);
```
每个对 `stream` 的调用都会返回一个有0或1个元素的流。`flatMap` 方法将这些方法组合在一起，这意味着不存在的用户会简单被丢弃。
> 注释：本节设想了一些令人愉快的场景，其中拥有可以返回 `Optional` 值的方法。当前，许多方法都会在没有任何有效结果的情况下、返回 `null` 。假设 `Users.classicLookup(id)` 会返回一个 `User` 对象或者 `null` 、而非 `Optional<User>` 。我们当然可以过滤掉 `null` 值：
> ```java
> Stream< User> users = ids.map(Users::classicLookup).filter(Objects::nonNull);
> ```
> 但如果更喜欢 `flatMap` 的方式，那我们可以使用下面的代码：
> ```java
> Stream< User> users = ids.flatMap(id -> Stream.ofNullable(Users.classicLookup(id)));
> ```
> 或下面的代码：
> ```java
> Stream< User> users = ids.map(Users::classicLookup).flatMap(Stream::ofNullable);
> ```
> `Stream.ofNullable(obj)` 这个调用在 `obj` 为 `null` 时会产生一个空流，否则会产生一个只包含 `obj` 的流。

`optional/OptionalTest.java` 展示了Optional API的使用方式。
```java
// optional/OptionalTest.java
package optional;

import java.io.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;

public class OptionalTest {
	public static void main(String[] args) throws IOException {
		var contents = new String(Files.readAllBytes(Paths.get("./src/alice30.txt")), StandardCharsets.UTF_8);
		List<String> wordList = List.of(contents.split("\\PL+"));

		Optional<String> optionalValue = wordList.stream()
			.filter(s -> s.contains("fred"))
			.findFirst();
		System.out.println(optionalValue.orElse("No word") + " contains fred");

		Optional<String> optionalString = Optional.empty();
		String result = optionalString.orElse("N/A");
		System.out.println("result: " + result);
		result = optionalString.orElseGet(() -> Locale.getDefault().getDisplayName());
		System.out.println("result: " + result);
		try {
			result = optionalString.orElseThrow(IllegalStateException::new);
			System.out.println("result: " + result);
		} catch (Throwable t) {
			t.printStackTrace();
		}

		optionalValue = wordList.stream()
			.filter(s -> s.contains("red"))
			.findFirst();
		optionalValue.ifPresent(s -> System.out.println(s + " contains red"));

		var results = new HashSet<String>();
		optionalValue.ifPresent(results::add);
		Optional<Boolean> added = optionalValue.map(results::add);
		System.out.println(added);
		
		System.out.println(inverse(4.0).flatMap(OptionalTest::squareRoot));
		System.out.println(inverse(-1.0).flatMap(OptionalTest::squareRoot));
		System.out.println(inverse(0.0).flatMap(OptionalTest::squareRoot));
		Optional<Double> result2 = Optional.of(-4.0).flatMap(OptionalTest::inverse).flatMap(OptionalTest::squareRoot);
		System.out.println(result2);
	}

	public static Optional<Double> inverse(Double x) {
		return x == 0 ? Optional.empty() : Optional.of(1 / x);
	}

	public static Optional<Double> squareRoot(Double x) {
		return x < 0 ? Optional.empty() : Optional.of(Math.sqrt(x));
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212170122169.png)

> [API] `java.util.Optional`
> - `<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper)`
> 返回将 `mapper` 应用于当前 `Optional` 值所产生的结果，或者在当前 `Optional` 为空时返回一个空 `Optional` 。

---
# 13.8 收集结果
处理完流后，通常会想要查看其结果。此时可以**调用 `iterator` 方法，它会产生用来访问元素的旧式风格 *old-fashioned* 的迭代器**。或者可以**调用 `forEach` 方法、将某个函数应用于每个元素**：
```java
stream.forEach(System.out::println);
```
并行流上，`forEach` 方法会以任意顺序遍历各个元素。如果想要按照流中的顺序处理它们，可以调用 `forEachOrdered` 方法。当然，这个方法会丧失并行处理的部分甚至全部优势。

但更常见的情况是，我们想要将结果收集到数据结构中。此时，可以调用 `toArray` ，获得由流的元素构成的数组。因为**无法在运行时创建泛型数组**，所以表达式 `stream.toArray()` 会返回一个 `Object[]` 数组。如果想要一个正确类型的数组，可以传递数组构造器：
```java
String[] result = stream.toArray(String[]::new);
	// stream.toArray() has type Object[]
```

针对将流中元素收集到另一个目标中，有一个便捷方法 `collect` 可用，它接受一个 `Collector` 接口的实例。**收集器** *collector* 是一个收集众多元素并产生一个结果的对象，**`Collectors` 类提供了大量用于生成常见收集器的工厂方法**，要想将流中元素收集到一个列表中，应使用 `Collectors.toList()` 方法产生的收集器：
```java
List<String> result = stream.collect(Collectors.toList());
```
类似地，可以将流中元素收集到一个集中：
```java
Set<String> result = stream.collect(Collectors.toSet());
```
==如果想要控制得到的集的种类，可以用下面的调用==：
```java
TreeSet<String> result = stream.collect(Collectors.toCollection(TreeSet::new));
```
假设想要通过连接操作、来收集流中的所有字符串，可以调用：
```java
String result = stream.collect(Collectors.joining());
```
如果要在元素之间增加分隔符，可以将分隔符传递给 `joining` 方法：
```java
String result = stream.collect(Collectors.joining(", "));
```
如果流中包含除字符串以外的对象，那需要先将其转换为字符串：
```java
String result = stream.map(Object::toString).collect(Collectors.joining(", "));
```

如果想将流的结果约简为总和、数量、平均值、最大值或最小值，可以用 `summarizing(Int/Long/Double)` 方法中的一个。这些方法会接受一将流对象映射为数字的函数，产生类型为 `(Int/Long/Double)SummaryStatistics` 的结果，同时计算总和、数量、平均值、最大值和最小值：
```java
IntSummaryStatistics summary = stream.collect(
	Collectors.summarizingInt(String::length));
double averageWordLength = summary.getAverage();
double maxWordLength = summary.getMax();
```

`collecting/CollectingResults.java` 展示了如何从流中收集元素：
```java
package collecting;

import java.io.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;
import java.util.stream.*;

public class CollectingResults {
	public static Stream<String> noVowels() throws IOException {
		var contents = new String(Files.readAllBytes(
			Paths.get("./src/alice30.txt")),
			StandardCharsets.UTF_8);
		List<String> wordList = List.of(contents.split("\\PL+"));
		Stream<String> words = wordList.stream();
		return words.map(s -> s.replaceAll("[aeiouAEIOU]", ""));
	}

	public static <T> void show(String label, Set<T> set) {
		System.out.print(label + ": " + set.getClass().getName());
		System.out.println("["
			+ set.stream().limit(10).map(Object::toString).collect(Collectors.joining(", "))
			+ "]");
	}

	public static void main(String[] args) throws IOException {
		Iterator<Integer> iter = Stream.iterate(0, n -> n + 1).limit(10).iterator();
		while (iter.hasNext())
			System.out.println(iter.next());

		Object[] numbers = Stream.iterate(0, n -> n + 1).limit(10).toArray();
		System.out.println("Object array:" + numbers);
			// Note it's an Object[] array

		/*
		try {
			var number = (Integer) numbers[0]; // OK
			System.out.println("number: " + number);
			System.out.println("The following statement throws an exception: ");
			var number2 = (Integer[]) numbers; // Throws exception

		} catch (ClassCastException ex) {
			System.out.println(ex);
		}
		*/

		Integer[] number3 = Stream.iterate(0, n -> n + 1)
			.limit(10)
			.toArray(Integer[]::new);
		System.out.println("Integer array: " + number3);
			// Note it's an Integer[] array

		/** --- **/
		Set<String> noVowelSet = noVowels().collect(
			Collectors.toSet());
		show("noVowelSet", noVowelSet);

		TreeSet<String> noVowelTreeSet = noVowels().collect(
			Collectors.toCollection(TreeSet::new));
		show("noVowelTreeSet", noVowelTreeSet);

		String result = noVowels().limit(10).collect(Collectors.joining());
		System.out.println("Joining: " + result);
		result = noVowels().limit(10)
			.collect(Collectors.joining(", "));
		System.out.println("Joining with commas: " + result);

		/** --- **/
		IntSummaryStatistics summary = noVowels().collect(
			Collectors.summarizingInt(String::length));
		double averageWordLength = summary.getAverage();
		double maxWordLength = summary.getMax();
		System.out.println("Average word length: " + averageWordLength);
		System.out.println("Max word length: " + maxWordLength);
		System.out.println("forEach: ");
		noVowels().limit(10).forEach(System.out::println);
	}
}
```
运行结果如下所示：
```java
0
1
2
3
4
5
6
7
8
9
Object array:[Ljava.lang.Object;@776ec8df
Integer array: [Ljava.lang.Integer;@404b9385
noVowelSet: java.util.HashSet[, Pppr, rsrc, tdy, srprsd, kss, Txts, gssd, WLD, clmly]
noVowelTreeSet: java.util.TreeSet[, B, BC, BCDC, BFR, BG, BRCH, BST, BSY, BT]
Joining: ThssthPrjctGtnbrgtxtflcn
Joining with commas: , Ths, s, th, Prjct, Gtnbrg, txt, f, lc, n
Average word length: 2.4493551160791056
Max word length: 10.0
forEach: 

Ths
s
th
Prjct
Gtnbrg
txt
f
lc
n
```
> [API] `java.util.stream.BaseStream` 8
> - `Iterator<T> iterator()`
> 产生一个用于获取当前流中各个元素的迭代器，这是一个终结操作。

> [API] `java.util.stream.Stream` 8
> - `void forEach(Consumer<? super T> action)`
> 在流的每个元素上调用 `action` ，是一个终结操作。
> - `Object[] toArray()`
> - `<A> A[] toArray(IntFunction<A[]> generator)`
> 产生一个对象数组，或在将引用 `A[]::new` 传递给构造器时，返回一个 `A` 类型的数组。是终结操作。
> - `<R, A> R collect(Collector<? super T,A,R> collector)`
> 使用给定的收集器、来收集当前流中的元素。`Collectors` 类有多种收集器的工厂方法。

> [API] `java.util.stream.Collectors` 8
> - `static <T> Collector<T,?,List<T>> toList()`
> - `static <T> Collector<T,?,List<T>> toUnmodifiableList()` 10
> - `static <T> Collector<T,?,Set<T>> toSet()`
> - `static <T> Collector<T,?,Set<T>> toUnmodifiableSet()`
> 产生一个将元素收集到列表或集合中的收集器。
> - `static <T,C extends Collection<T>> Collector<T,?,C> toCollection(Supplier<C> collectionFactory)`
> 产生一个将元素收集到任意集合中的收集器。可以传递一个诸如 `TreeSet::new` 的构造器引用。
> - `static Collector<CharSequence,?,String> joining()`
> - `static Collector<CharSequence,?,String> joining(CharSequence delimiter)`
> - `static Collector<CharSequence,?,String> joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)`
> 产生一个连接字符串的收集器。分隔符置于字符串之间，而第一个字符串之前可以有前缀，最后一个字符串之后可以有后缀。如果没有指定，那么它们都为空。
> - `static <T> Collector<T,?,IntSummaryStatistics> summarizingInt(ToIntFunction<? super T> mapper)`
> - `static <T> Collector<T,?,LongSummaryStatistics> summarizingLong(ToLongFunction<? super T> mapper)`
> - `static <T> Collector<T,?,DoubleSummaryStatistics> summarizingDouble(ToDoubleFunction<? super T> mapper)`
> 产生能生成 `(Int|Long|Double)SummaryStatistics` 对象的收集器，通过它们可以获得将 `mapper` 应用于每个元素后产生的结果的数量、总和、平均值、最大和最小值。

> [API] `IntSummaryStatistics` 8
> [API] `LongSummaryStatistics` 8
> [API] `DoubleSummaryStatistics` 8
> - `long getCount()`
> 产生汇总后的元素个数。
> - `(int|long|double) getSum()`
> - `double getAverage()`
> 产生汇总后的元素的总和或平均值，或在没有任何元素时返回0。
> - `(int|long|double) getMax()`
> - `(int|long|double) getMin()`
> 产生汇总后的元素的最大值和最小值，或在没有任何元素时产生 `(Integer|Long|Double).(MAX|MIN)_VALUE` 。

---
# 13.9 收集到映射表中
假设有一个 `Stream<Person>` ，并想将其元素收集到一个映射表中，这样后续就可以通过它们的ID来查找人员了。**`Collectors.toMap` 方法有两个函数参数，它们用来产生映射表的键和值**。例如：
```java
Map<Integer, String> idToName = people.collect(
	Collectors.toMap(Person::getId, Person::getName));
```
通常情况下，值应该是实际的元素，因此第二个函数可以使用 `Function.identity()` ：
```java
Map<Integer, Person> idToPerson = people.collect(
	Collectors.toMap(Person::getId, Function.identity()));
```
如果多个元素具有相同的键，就会存在冲突，收集器会抛出一个 `IllegalStateException` 。可以通过提供第3个函数参数来覆盖这种行为，该函数在给定现有值和新值的情况下，可以解决 *resolve* 冲突、并确定键对应的值，这个函数应返还已有值、新值或它们的组合。

下面代码中构造了一个映射表，存储了可用locale中的每种语言，其中每种语言在默认locale中的名字（例如"German"）为键，而其本地化的名字（例如"Deutsch"）为值：
```java
Stream<Locale> locales = Stream.of(Locale.getAvailableLocales());

Map<String, String> languageNames = locales.collect(
	Collectors.toMap(Locale::getDisplayLanguage,
	loc -> loc.getDisplayLanguage(loc),
	(existingValue, newValue) -> existingValue));
```
我们并不关心，同一种语言是否可能出现两次（例如德国和瑞士都使用德语 *German in Germany and in Switzerland*  ），因此只记录第一项。

现在假设想了解给定国家的所有语言，这样就需要一个 `Map<String, Set<String>>` ，例如"Switzerland"的值是集[French, German, Italian]。首先 *store a singleton set for each language* ，无论何时只要找到了给定国家的新语言，就会对已有集和新集进行并操作。
```java
Map<String, Set<String>> countryLanguageSets = locales.collect(
	Collectors.toMap(Locale::getDisplayCountry,
		l -> Collections.singleton(l.getDisplayLanguage()),
		(a, b) -> { // Union of a and b
			var union = new HashSet<String>(a);
			union.addAll(b);
			return union;
		}
	)
);
```
下一节有更简单的获取这种映射表的方式。

**如果想要得到 `TreeMap` ，那么可以将构造器作为第四个参数提供**。必须提供一种合并函数 *merge function* 。下面是本节开始的示例，现在它产生一个 `TreeMap` ：
```java
Map<Integer, Person> idToPerson = people.collect( Collectors.toMap(
	Person::getId,
	Function.identity(),
	(existingValue, newValue) -> { 
		throw new IllegalStateException(); 
	},
	TreeMap::new)
);
```
> 注释：**对每个 `toMap` 方法，都有一个等价的可以产生并发映射表的 `toConcurrentMap` 方法**。单个并发映射表可被用于并行集合处理。当使用并行流时，一个共享的映射表比合并映射表更高效 *a shared map is more efficient than merging maps* 。注意，元素不再是按照流中顺序收集的，但通常这不会有什么问题。

`collecting/CollectingIntoMaps.java` 给出了将流的结果收集到映射表的示例。
```java
package collecting;

import java.io.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class CollectingIntoMaps {
	public static class Person {
		private int id;
		private String name;

		public Person(int id, String name) {
			this.id = id;
			this.name = name;
		}
		public int getId() {
			return id;
		}
		public String getName() {
			return name;
		}
		public String toString() {
			return getClass().getName() + "[id=" + id + ",name=" + name + "]";
		}
	}

	public static Stream<Person> people() {
		return Stream.of(new Person(1001, "Peter"), 
			new Person(1002, "Paul"), new Person(1003, "Mary"));
	}

	public static void main(String[] args) throws IOException {
		Map<Integer, String> idToName = people().collect(
			Collectors.toMap(Person::getId, Person::getName)
		);
		System.out.println("idToName: " + idToName);

		Map<Integer, Person> idToPerson = people().collect(
			Collectors.toMap(Person::getId, Function.identity())
		);
		System.out.println("idToPerson: " + idToPerson.getClass().getName() + idToPerson);

		idToPerson = people().collect(
			Collectors.toMap(Person::getId, Function.identity(),
			(existingValues, newValue) -> { throw new IllegalStateException(); },
			TreeMap::new)
		);
		System.out.println("idToPerson: " + idToPerson.getClass().getName() + idToPerson);
		
		Stream<Locale> locales = Stream.of(Locale.getAvailableLocales());
		Map<String, String> languageNames = locales.collect(
			Collectors.toMap(
				Locale::getDisplayLanguage,
				l -> l.getDisplayLanguage(l),
				(existingValue, newValue) -> existingValue
			)
		);
		System.out.println("languageNames: " + languageNames);

		locales = Stream.of(Locale.getAvailableLocales());
		Map<String, Set<String>> countryLanguageSets = locales.collect(
			Collectors.toMap(
				Locale::getDisplayCountry,
				l -> Set.of(l.getDisplayLanguage()),
				(a, b) -> { // union of a and b
					Set<String> union = new HashSet<>(a);
					union.addAll(b);
					return union;
				}
			)
		);
		System.out.println("countryLanguageSets: " + countryLanguageSets);
	}
}
```
运行结果如下，有些字符无法显示出来：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212170131301.png)

> [API] `java.util.stream.Collectors` 8
> - `static <T,K,U> Collector<T,?,Map<K,U>> toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper)`
> - `static <T,K,U> Collector<T,?,Map<K,U>> toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)`
> - `static <T,K,U,M extends Map<K,U>> Collector<T,?,M> toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier)`
> - `static <T,K,U> Collector<T,?,Map<K,U>> toUnmodifiableMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper)` 10
> - `static <T,K,U> Collector<T,?,Map<K,U>> toUnmodifiableMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)` 10
> - `static <T,K,U> Collector<T,?,ConcurrentMap<K,U>> toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper)`
> - `static <T,K,U> Collector<T,?,ConcurrentMap<K,U>> toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)`
> - `static <T,K,U,M extends ConcurrentMap<K,U>> Collector<T,?,M> toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier)`
> 产生一个收集器，收集器会产生一个映射表、不可修改的映射表或并发映射表。`keyMapper` 和 `valueMapper` 函数会应用于每个收集到的元素上，从而在所产生的映射表中生成一个键值项。默认情况下，**当两个元素产生相同的键时，会抛出一个 `IllegalStateException`** 。**可以提供一个 `mergeFunction` 来合并具有相同键的值**。默认情况下，其结果是一个 `HashMap` 或 `ConcurrentHashMap` 。可以提供一个 `mapSupplier` ，它会产生所期望的映射表实例。

---
# 13.10 群组和分区
上节中看到如何收集给定国家的所有语言，但其处理显得有些冗长。必须为每个映射表的值都生成单例集，然后指定如何将现有值与新值合并。**将具有相同特性的值群聚成组是非常常见的**，并且 `groupingBy`方法直接就支持它。

看看通过国家聚组Locale的问题。首先，构造该映射表：
```java
Map<String, List<Locale>> countryToLocales = locales.collect(
	Collectors.groupingBy(Locale::getCountry));
```
函数 `Locale::getCountry` 是群组的分类函数 *classifier* ，现在可以查找给定国家代码 *country code* 对应的所有locales了。例如：
```java
List<Locale> swissLocales = countryToLocales.get("CH");
	// Yields locales de_CH, fr_CH, it_CH and maybe more
```
> 注释：快速复习locale：**每个locale都有一个语言代码**（例如英语的 `en` ）**和一个国家代码**（例如美国的 `US` ）。locale `en_US` 描述的是美国英语，而 `en_IE` 是爱尔兰英语。**某些国家有多个locale**，例如，`ga_IE` 是爱尔兰的盖尔语，前面的示例也展示了JDK知道瑞士至少有三个locale。

**当分类函数是断言函数（即返回 `boolean` 值的函数）时，流的元素可分为两个列表：该函数返回 `true` 的元素和其他元素**。这时使用 `partitioningBy` 比使用 `groupingBy` 更高效。例如，在下面的代码中，我们将所有locale分成了使用英语和使用所有其他语言的两类：
```java
Map<Boolean, List<Locale>> englishAndOtherLocales = 
	locales.collect(
		Collectors.partitioningBy(l -> l.getLanguage().equals("en"))
);
List<Locale> englishLocales = englishAndOtherLocales.get(true);
```
如果调用 `groupingByConcurrent` 方法，就会在使用并行流时获得一个被并行组装的并行映射表，这与 `toConcurrentMap` 方法完全类似。

> [API] `java.util.stream.Collectors` 8
> - `static <T,K> Collector<T,?,Map<K,List<T>>> groupingBy(Function<? super T,? extends K> classifier)`
> - `static <T,K> Collector<T,?,ConcurrentMap<K,List<T>>> groupingByConcurrent(Function<? super T,? extends K> classifier)`
> 产生一个收集器，它会产生一个映射表或并发映射表，其键是将 `classifier` 应用于所有收集到的元素上产生的结果，值是由具有相同键的元素构成的一个个列表。
> - `static <T> Collector<T,?,Map<Boolean,List<T>>> partitioningBy(Predicate<? super T> predicate)`
> 产生一个收集器，它产生一个映射表，其键是 `true/false` ，值是由满足/不满足断言的元素构成的列表。

---
# 13.11 下游收集器
`groupingBy` 方法产生一个映射表，它的每个值都是一个列表。==如果想以某种方式来处理这些列表，就需要提供一个“下游收集器” *downstream collector*== 。例如，如果想要获得集、而非列表，那么可以使用上节中看到的 `Collectors.toSet` 收集器：
```java
Map<String, Set<Locale>> countryToLocaleSet = locales.collect(groupingBy(Locale::getCountry, toSet()));
```
Java提供了多种可以将收集到的元素约简为数字的收集器（静态导入 `java.util.stream.Collector.*` ）：
- `counting` 会产生收集到的元素的个数。例如对每个国家有多少个Locale计数：
	```java
	Map<String, Long> countryToLocaleCounts =
		locales.collect(groupingBy(Locale::getCountry, counting()));
	```
- `summing(Int|Long|Double)` 接收一个函数参数，将该函数应用于 *downstream elements* 中，并产生它们的和。例如计算城市流中每个州的人口总和。
	```java
	Map<String, Integer> stateToCityPopulation = 
		cities.collect(groupingBy(City::getState, summingInt(City::getPopulation)));
	```
- `maxBy, minBy` 接受一个比较器，分别产生 *downstream elements* 中的最大值和最小值。例如查找每个州中最大的城市：
	```java
	Map<String, Optional<City>> stateToLargestCity =
		cities.collect(
			groupingBy(City::getState,
				maxBy(Comparator.comparing(City::getPopulation))
			)
		);
	```

`collectingAndThen` 收集器在收集器后面添加了一个最终处理步骤。例如，想知道有多少个不同的结果，那就可以将它们收集到一个集中，然后计算其数目：
```java
Map<Character, Integer> stringCountsByStartingLetter = strings.collect(
	groupingBy(s -> s.charAt(0),
		collectingAndThen(toSet(), Set::size)
	)
);
```

`mapping` 收集器的做法正好相反，它将一个函数应用于「收集到的每个元素 *collected elements* 」并传递结果给下游收集器（这里是 `toSet()` ）。这里按照首字符对字符串进行分组，每个组内部计算字符串的长度，然后将这些长度收集到一个集中：
```java
Map<Character, Set<Integer>> stringLengthsByStartingLetter =
strings.collect(
	groupingBy(s -> s.charAt(0),
		mapping(String::length, toSet())
	)
);
```
`mapping` 方法针对上节的问题，即把某国所有语言收集到一个集中，产生了一种更佳的解决方案：
```java
Map<String, Set<String>> countryToLanguages = locales.collect(
	groupingBy(Locale::getDisplayCountry,
		mapping(Locale::getDisplayLanguage, toSet())
	)
);
```
还有一个 `flatMapping` 方法，可以与返回流的函数一起使用。

如果群组和映射函数 *grouping or mapping function* 返回类型为 `int, long, double` ，那么可将元素收集到一个汇总统计对象中 *summary statistics object*（13.8节）：
```java
Map<String, IntSummaryStatistics> stateToCityPopulationSummary = cities.collect(
	groupingBy(City::getState,
		summarizingInt(City::getPopulation)
	)
);
```
然后，可以从每个组的汇总统计对象中，获取这些函数值的总和、数量、平均值、最小最大值。

`filtering` 收集器会将一个过滤器用于每个组上。例如：
```java
Map<String, Set<City>> largeCitiesByState = cities.collect(
	groupingBy(City::getState,
		filtering(c -> c.getPopulation() > 500000, toSet())
	)
); // States without large cities have empty
```
> 还有三个版本的 `reducing` 方法，它们都应用了通用的约简操作（如13.12节）。

将收集器组合起来是很强大的，但它也可能导致产生非常复杂的表达式 *convoluted expressions* 。最佳用法是与 `groupingBy, partitioningBy` 一起处理“下游的”映射表中的值 *“downstream”
map values* 。否则，应直接在流上应用如 `map, reduce, count, max, min` 这样的方法。下面演示了下游收集器。
```java
// collecting/DownstreamCollectors.java
package collecting;

import static java.util.stream.Collectors.*;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.stream.*;

public class DownstreamCollectors {
	public static class City {
		private String name;
		private String state;
		private int population;

		public City(String name, String state, int population) {
			this.name = name;
			this.state = state;
			this.population = population;
		}

		public String getName() { return name; }
		public String getState() { return state; }
		public int getPopulation() { return population; }

		public static Stream<City> readCities(String filename) throws IOException {
			return Files.lines(Paths.get(filename))
				.map(l -> l.split(", "))
				.map(a -> new City(a[0], a[1], Integer.parseInt(a[2])));
		}

		public static void main(String[] args) throws IOException {
			Stream<Locale> locales = Stream.of(Locale.getAvailableLocales());
			Map<String, Set<Locale>> countryToLocaleSet = locales.collect(groupingBy(
				Locale::getCountry, toSet()));
			System.out.println("countryToLocaleSet: " + countryToLocaleSet);

			locales = Stream.of(Locale.getAvailableLocales());
			Map<String, Long> countryToLocaleCounts = locales.collect(groupingBy(Locale::getCountry, counting()));
			System.out.println("countryToLocaleCounts: " + countryToLocaleCounts);

			String filename = "./src/cities.txt";
			Stream<City> cities = readCities(filename);
			Map<String, Integer> stateToCityPopulation = cities
				.collect(groupingBy(City::getState, summingInt(City::getPopulation)));
			System.out.println("stateToCityPopulation: " + stateToCityPopulation);

			cities = readCities(filename);
			Map<String, Optional<String>> stateToLongestCityName = cities
				.collect(groupingBy(City::getState,
					mapping(City::getName, maxBy(Comparator.comparing(String::length)))
				)
			);
			System.out.println("stateToLongestCityName: " + stateToLongestCityName);

			locales = Stream.of(Locale.getAvailableLocales());
			Map<String, Set<String>> countryToLanguages = locales.collect(groupingBy(
				Locale::getDisplayCountry, mapping(Locale::getDisplayLanguage, toSet())
			));
			System.out.println("countryToLanguages: " + countryToLanguages);

			cities = readCities(filename);
			Map<String, IntSummaryStatistics> stateToCityPopulationSummary = cities
				.collect(groupingBy(City::getState, summarizingInt(City::getPopulation)));
			System.out.println(stateToCityPopulationSummary.get("NY"));

			cities = readCities(filename);
			Map<String, String> stateToCityNames = cities.collect(groupingBy(
				City::getState,
				reducing("", City::getName, (s, t) -> s.length() == 0 ? t : s + ", " + t)
			));
			System.out.println("stateToCityNames: " + stateToCityNames);
			
			cities = readCities(filename);
			stateToCityNames = cities.collect(groupingBy(
				City::getState, mapping(City::getName, joining(", "))
			));
			System.out.println("stateToCityNames: " + stateToCityNames);
		}
	}
}
```
运行结果如下所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212170144969.png)

> [API] `java.util.stream.Collectors` 8
> - `public static <T,K,A,D> Collector<T,?,Map<K,D>> groupingBy(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream)`
> 产生一个收集器，该收集器会产生一个映射表，其中的键是将 `classifier` 应用到所有收集到的元素上之后产生的结果，==值是使用下游收集器收集「具有相同的键的元素」所产生的结果==。
> - `static <T> Collector<T,?,Long> counting()`
> 产生一个可对收集到的元素进行计数的收集器。
> - `static <T> Collector<T,?,Integer> summingInt(ToIntFunction<? super T> mapper)`
> - `static <T> Collector<T,?,Long> summingLong(ToLongFunction<? super T> mapper)`
> - `static <T> Collector<T,?,Double> summingDouble(ToDoubleFunction<? super T> mapper)`
> 产生一个收集器，对「将 `mapper` 应用到收集到的元素上后产生的结果」计算总和。
> - `static <T> Collector<T,?,Optional<T>> maxBy(Comparator<? super T> comparator)`
> - `static <T> Collector<T,?,Optional<T>> minBy(Comparator<? super T> comparator)`
> 产生一个收集器，使用 `comparator` 指定的排序方法，计算收集到的元素中的最大值和最小值。
> - `static <T,A,R,RR> Collector<T,A,RR> collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher)`
> 产生一个收集器，它会将元素发送到下游收集器中，然后将 `finisher` 函数应用到其结果上。
> - `static <T,U,A,R> Collector<T,?,R> mapping(Function<? super T,? extends U> mapper, Collector<? super U,A,R> downstream)`
> 产生一个收集器，它会在每个元素上调用 `mapper` ，再将结果发送到下游收集器中。
> - `static <T,U,A,R> Collector<T,?,R> flatMapping(Function<? super T,? extends Stream<? extends U>> mapper, Collector<? super U,A,R> downstream)`
> 产生一个收集器，它会在每个元素上调用 `mapper` ，再将**结果中的元素**发送到下游收集器中。
> - `static <T,A,R> Collector<T,?,R> filtering(Predicate<? super T> predicate, Collector<? super T,A,R> downstream)`
> 产生一个收集器，它会将满足谓词逻辑的元素发送到下游收集器中。

---
# 13.12 约简操作
`reduce` 方法是一种从流中计算某个值的通用机制，最简单的形式是**接收一个二元函数，并从前两个元素开始持续应用它**。如果该函数是求和函数，就很容易解释这机制。下面，`reduce` 方法会计算 $v_0 + v_1 + v_2 + \dots$ ，其中 $v_i$ 是流中的元素。如果流为空，那么该方法返回一个 `Optional` ，因为没有任何有效的结果：
```java
List<Integer> values = ...;
Optional<Integer> sum = values.stream().reduce((x, y) -> x + y); 
	// or reduce(Integer::sum)
```
更一般地，**可以使用任何约简操作、将部分结果 `x` 与下一个值 `y` 组合起来、以产生新的部分结果**。

下面是**另一种看待约简的方式**。给定约简操作 $op$ ，该约简产生 $v_0 \ op \ v_1 \ op\ v_2 \ op \dots$ ，其中将函数调用 $op(v_i, v_{i+1})$ 写成 $v_i\ op\ v_{i+1}$ 。有多种在实践中很有用的可结合操作，例如求和、乘积、字符串连接、求最大/小值、集的并和交等。

==如果要用并行流来约简，那么这项约简操作必须是可结合的 *associative* ，即组合元素时使用的顺序不会产生任何影响==。在数学标记法中，$(x\ op\ y)\ op\ z$ 必须等于 $x\ op\ (y\ op\ z)$ 。减法是一个不可结合操作的例子，例如 $(6-3) - 2 \ne 6 - (3 - 2)$ 。

通常，会有一个幺元 *identity* $e$ 使得 $e\ op \ x = x$ ，可以使用这个元素作为计算的起点。例如，0是加法的幺元值。由此，我们可使用第二种形式的 `reduce` ——如果流为空会返回幺元值，就再也不需要处理 `Optional` 类了：
```java
List<Integer> values = ...;
Integer sum = values.stream().reduce(0, (x, y) -> x + y);
	// Computes 0 + v0 + v1 + v2 + ...
```

现在假设有一个对象流，并且想对某些属性求和，例如字符串流中所有字符串的长度，那么就不能用简单形式的 `reduce` ，它需要 `(T, T) -> T` 这样的函数，即参数和结果的类型相同 *with the same types for the arguments and the result* 的函数，但在这种情况下你**有两种类型：流的元素具有 `String` 类型，而累积结果是整数**。有一种形式的 `reduce` 可以处理这种情况。

首先需要提供一个累加器 *accumulator* 函数 `(total, word) ->total + word.length()` ，这个函数被反复调用，产生累积的总和。==但当计算被并行化时，会有多个这种类型的计算，你需要将它们的结果合并。因此需要提供第二个函数来执行此处理==。完整的调用如下：
```java
int result = words.reduce(0,
	(total, word) -> total + word.length(),
	(total1, total2) -> total1 + total2);
```
实践中，可能并不会频繁用到 `reduce` 方法。通常，映射为一个数字流 *stream of numbers* 并使用其方法来计算总和、最大/小值更容易（13.13节）。在这个特定示例中，可以调用 `words.mapToInt(String::length).sum()` ，因为它不涉及装箱操作，所以更简单也更高效。

有时 `reduce` 会显得不够通用。例如假设想收集 `BitSet` 中的结果。如果收集操作 *collection* 是并行的，那么就不能直接将元素放到单个 `BitSet` 中，因为 `BitSet` 对象不是线程安全的。因此我们不能使用 `reduce` ，因为每个部分都需要以其自己的空集开始，并且 `reduce` 只能让我们提供一个幺元值。此时应该使用 `collect` ，它会接受三个参数：
1. 一个**提供者** *supplier* ，它会创建目标对象的新实例，例如散列集的构造器。
2. 一个**累积器** *accumulator* ，它会将一个元素添加到该目标上，例如 `add` 方法。
3. 一个**组合器** *combiner* ，它会将两个对象合并为一个，例如 `addAll` 。

下面的代码展示 `collect` 方法如何操作位集：
```java
BitSet result = stream.collect(BitSet::new, BitSet::set, BitSet::or);
```

> [API] `java.util.stream` 8
> - `Optional<T> reduce(BinaryOperator<T> accumulator)`
> - `T reduce(T identity, BinaryOperator<T> accumulator)`
> - `<U> U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)`
> 用给定的 `accumulator` 函数产生流中元素的累积总和。如果提供了幺元，那么第一个被累积的元素就是该幺元。**如果提供了组合器，那么它可以用来将「分别累积的各个部分」整合成总和**。
> - `<R> R collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)`
> 将元素收集到类型 `R` 的结果中。每个部分 *each segment* 上都会调用 `supplier` 来提供初始结果，调用 `accumulator` 动态添加元素 *mutably add* 到结果中，并调用 `combiner` 来整个两个结果。

---
# 13.13 基本类型流
目前都是将整数收集到 `Stream<Integer>` 中，将每个整数都包装到包装器对象中是很低效的。对其他基本类型来说也一样。**流库中有专门的类型 `IntStream, LongStream, DoubleStream` ，用来直接存储基本类型值、而无须使用包装器**。如果想存储 `short, char, byte, boolean` ，可以使用 `IntStream` ；对于 `float` 可以使用 `DoubleStream` 。

**为了创建 `IntStream` ，要调用 `IntStream.of` 和 `Arrays.stream` 方法**：
```java
IntStream stream = IntStream.of(1, 1, 2, 3, 5);
stream = Arrays.stream(values, from, to); // values is an int[] array
```

**和对象流一样，还可以使用静态 `generate` 和 `iterate` 方法**。此外，`IntStream, LongStream` 有静态方法 `range, rangeClosed` ，可以生成步长为1的整数范围：
```java
IntStream zeroToNinetyNine = IntStream.range(0, 100); // Upper bound is excluded
IntStream zeroToHundred = IntStream.rangeClosed(0, 100); // Upper bound is included
```

`CharSequence` 接口拥有 `codePoints` 和 `chars` 方法，可生成由字符的Unicode码或UTF-16编码机制的码元构成的 `IntStream` ：
```java
String sentence = "\uD835\uDD46 is the set of octonions.";
// \uD835\uDD46 is the UTF-16 encoding of the letter , unicode U+10546
IntStream codes = sentence.codePoints();
// The stream with hex values 1D546 20 69 73 20 . . .
```

**当有一个对象流时，可以用 `mapToInt, mapToLong, mapToDouble` 将其转换为基本类型流**。例如，有一个字符串流，并想将其长度处理为整数，那么就可以在 `IntStream` 中实现此目的：
```java
Stream<String> words = ...;
IntStream lengths = words.mapToInt(String::length);
```
**为了将基本类型流转换为对象流，需要使用 `boxed` 方法**：
```java
Stream<Integer> integers = IntStream.range(0, 100).boxed();
```

通常，基本类型流上的方法与对象流上的方法类似。主要差异如下：
- `toArray` 方法会返回基本类型数组。
- 产生可选结果的方法，会返回一个 `OptionalInt, OptionalLong, OptionalDouble` 。这些类与 `Optional` 类类似，但具有 `getAsInt, getAsLong, getAsDouble` 方法、而非 `get` 方法。
- 具有分别返回总和、平均值、最大/小值的 `sum, average, max, min` 方法。对象流没有定义这些方法。
- `summaryStatistics` 方法产生一个类型为 `IntSummaryStatistics， LongSummaryStatistics, DoubleSummaryStatistics` 对象，它们可以同时报告流的总和、数量、平均值、最大/小值。

**`Random` 类具有 `ints, longs, doubles` 方法，会返回由随机数组成的基本类型流**。如果需要的是并行流中的随机数，那么需要使用 `SplittableRandom` 类。
```java
// streams/PrimitiveTypeStreams.java
package streams;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class PrimitiveTypeStreams {
	public static void show(String title, IntStream stream) {
		final int SIZE = 10;
		int[] firstElements = stream.limit(SIZE + 1).toArray();
		System.out.print(title + ": ");
		for (int i = 0; i < firstElements.length; ++i) {
			if (i > 0) System.out.print(", ");
			if (i < SIZE) System.out.print(firstElements[i]);
			else System.out.print("...");
		}
		System.out.println();
	}
	
	public static void main(String[] args) throws IOException {
		IntStream is1 = IntStream.generate(() -> (int) (Math.random() * 100));
		show("is1", is1);
		IntStream is2 = IntStream.range(5, 10);
		show("is2", is2);
		IntStream is3 = IntStream.rangeClosed(5, 10);
		show("is3", is3);

		Path path = Paths.get("./src/alice30.txt");
		var contents = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);
		Stream<String> words = Stream.of(contents.split("\\PL+"));
		IntStream is4 = words.mapToInt(String::length);
		show("is4", is4);
		
		var sentence = "\uD835\uDD46 is the set of octonions.";
		System.out.println(sentence);
		IntStream codes = sentence.codePoints();
		System.out.println(codes.mapToObj(c -> String.format("%X ", c)).collect(Collectors.joining()));

		Stream<Integer> integers = IntStream.range(0, 100).boxed();
		IntStream is5 = integers.mapToInt(Integer::intValue);
		show("is5", is5);
	}
}
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212170148469.png)

> [API] `java.util.stream.IntStream` 8
> - `static IntStream range(int startInclusive, int endExclusive)`
> - `static IntStream rangeClosed(int startInclusive, int endInclusive)`
> 产生一个由给定范围内的整数构成的 `IntStream` 。
> - `static IntStream of(int... values)`
> 产生一个由给定元素构成的 `IntStream` 。
> - `int[] toArray()`
> 产生一个由当前流中元素构成的数组。
> - `int sum()`
> - `OptionalDouble average()`
> - `OptionalInt max()`
> - `OptionalInt min()`
> - `IntSummaryStatistics summaryStatistics()`
> 产生当前流中元素的总和、平均值、最大最小值，或产生一个可从中获取所有这四个值的对象。
> - `Stream<Integer> boxed()`
> 产生用于当前流中元素的包装器对象流。

> [API] `java.util.stream.LongStream` 8
> - `static LongStream range(long startInclusive, long endExclusive)`
> - `static LongStream rangeClosed(long startInclusive, long endInclusive)`
> 产生一个由给定范围内的整数构成的 `LongStream` 。
> - `static LongStream of(long... values)`
> 产生一个由给定元素构成的 `LongStream` 。
> - `long[] toArray()`
> 产生一个由当前流中元素构成的数组。
> - `long sum()`
> - `OptionalDouble average()`
> - `OptionalLong max()`
> - `OptionalLong min()`
> - `LongSummaryStatistics summaryStatistics()`
> 产生当前流中元素的总和、平均值、最大最小值，或产生一个可从中获取所有这四个值的对象。
> - `Stream<Long> boxed()`
> 产生用于当前流中元素的包装器对象流。

> [API] `java.util.stream.DoubleStream` 8
> - `static DoubleStream of(double... values)`
> 用给定元素产生一个 `DoubleStream` 。
> - `double[] toArray()`
> 用当前流中元素产生一个数组。
> - `double sum()`
> - `OptionalDouble average()`
> - `OptionalDouble max()`
> - `OptionalDouble min()`
> - `DoubleSummaryStatistics summaryStatistics()`
> 产生当前流中元素的总和、平均值、最大最小值，或产生一个可从中获取所有这四个值的对象。
> - `Stream<Double> boxed()`
> 产生用于当前流中元素的包装器对象流。

> [API] `java.lang.CharSequence` 1.0
> - `IntStream codePoints()` 8
> 产生由当前字符串的所有Unicode码点构成的流。

> [API] `java.util.Random` 1.0
> - `IntStream ints()`
> - `IntStream ints(int randomNumberOrigin, int randomNumberBound)` 8
> - `IntStream ints(long streamSize)` 8
> - `IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound)` 8
> - `LongStream longs()` 8
> - `LongStream longs(long randomNumberOrigin, longrandomNumberBound)` 8
> - `LongStream longs(long streamSize)` 8
> - `LongStream longs(long streamSize, long randomNumberOrigin, long randomNumberBound)`
> - `DoubleStream doubles()`
> - `DoubleStream doubles(double randomNumberOrigin, double randomNumberBound)`
> - `DoubleStream doubles(long streamSize)`
> - `DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)`
> 产生随机数流。如果提供了 `streamSize` ，这个流就是具有给定数量元素的有限流。当提供了边界时，其元素将属于 `[randomNumberOrigin, randomNumberBound)` 区间。

> [API] `java.util.Optional(Int|Long|Double)` 8
> - `static Optional(Int|Long|Double) of((int|long|double) value)`
> 用提供的基本类型值产生一个可选对象。
> - `(int|long|double) getAs(Int|Long|Double)()`
> -产生当前可选对象的值，或者在其为空时抛出一个 `NoSuchElementException` 异常。
> - `(int|long|double) orElse((int|long|double) other)`
> - `(int|long|double) orElseGet((Int|Long|Double)Supplier other)`
> 产生当前可选对象的值，或者在这个对象为空时产生可替代的值。
> - `void ifPresent((Int|Long|Double)Consumer consumer)`
> 如果当前可选对象不为空，则将其值传递给 `consumer` 。

> [API] `java.util.(Int|Long|Double)SummaryStatistics`
> - `long getCount()`
> - `(int|long|double) getSum()`
> - `double getAverage()`
> - `(int|long|double) getMax()`
> - `(int|long|double) getMin()`
> 产生收集到的元素的数量、总和、平均值、最大/小值。

---
# 13.14 并行流
流使并行化批处理 *bulk operations* 变得很容易，这个过程几乎是自动的，但需要遵守一些规则。**首先必须有一个并行流**，可以用 `Collection.parallelStream()` 方法从任意集合获取一个并行流：
```java
Stream<String> parallelWords = words.parallelStream();
```
而且，`parallel` 方法可以将任意顺序流转换为并行流：
```java
Stream<String> parallelWords = Stream.of(wordArray).parallel();
```
==只要在终结方法执行时，流处于并行模式，所有的中间流操作就都会被并行化==。**当流操作并行运行时，其目标是让其返回结果与「顺序执行时返回结果」相同**。重要的是，这些操作是无状态的 *stateless* ，并且可以以任意顺序执行。

下面的示例是一项你完成不了的任务，假设想对字符串流中的所有短单词计数：
```java
var shortWords = new int[12];
words.parallelStream().forEach(s -> { 
	if (s.length() < 12) shortWords[s.length()]++; 
});  // ERROR--race condition!
System.out.println(Arrays.toString(shortWords));
```
这是非常糟糕的代码 *bad code* ，传递给 `forEach` 的函数会在多个线程中并发运行，每个都会更新一个共享数组。这是一种典型的竞争情况。如果多次运行这个程序，可能会发现每次运行都产生不同的计数值，而且每个都是错的。

==你的职责是，确保传递给并行流操作的任何函数，都可以安全地并行执行。达到这一目的的最佳方式是，远离易变状态 *stay away from
mutable state*== 。本例中如果用长度将字符串分组，然后分别对它们计数，那么就可以安全地并行化这项计算：
```java
Map<Integer, Long> shortWordCounts = words.parallelStream()
	.filter(s -> s.length() < 12)
	.collect(groupingBy(
		String::length, counting()
	)
);
```

默认情况下，从有序集合（数组和列表）、范围 *range* 、生成器 *generator* 、迭代器中产生的流，或通过调用 `Stream.sorted` 产生的流，都是有序的。它们的结果是按照原来元素的顺序累积的，因而是完全可预知的 *entirely predictable* 。如果运行相同的操作两次，就会得到完全相同的结果。

排序并不排斥高效的并行处理 *Ordering does not preclude efficient parallelization* 。例如，当计算 `stream.map(fun)` 时流可以被划分为 `n` 部分，它们会被并行地处理，然后结果将会按顺序重新组装起来。

**当放弃排序需求时，有些操作可以被更有效地并行化。通过在流上调用 `Stream.unordered` 方法，就可以明确地表示我们对排序不感兴趣**。`Stream.distinct` 就是从这种方式获益的一种操作。在有序流中，`distinct` 会保留所有相同元素中的第一个，这对并行化是一种阻碍，因为处理每个部分的线程在其之前的所有部分都被处理完之前，并不知道应该丢弃哪些元素。如果可以接受保留唯一元素中任意一个的做法，那么所有部分就可以并行地处理（使用一个共享集来跟踪重复元素）。

还可以**通过放弃排序要求、来提高 `limit` 方法的速度**。如果只想从流中取出任意 `n` 个元素，而并不在意到底要获取哪些，那么可以调用：
```java
Stream<String> sample = words.parallelStream().unordered().limit(n);
```
（13.9节）合并映射表的代价很高昂。正是这个原因，`Collectors.groupingByCoucurrent` 方法使用了共享的并发映射表。为了从并行化中获益，映射表中值的顺序不会与流中顺序相同：
```java
Map<Integer, List<String>> result = words.parallelStream().collect(
	Collectors.groupingByConcurrent(String::length));
	// Values aren't collected in stream order
```
当然，**如果使用一个独立于排序的下游收集器，那么就不必在意了**。例如：
```java
Map<Integer, Long> wordCounts = words.parallelStream()
	.collect(
		groupingByConcurrent(String::length, counting()
	)
);
```

不要指望通过将所有的流都转换为并行流、就能加速操作，要牢记下面几条：
- 并行化会导致大量的开销 *substantial overhead* ，只有面对非常大的数据集才划算。
- **只有在底层的数据源，可以被有效分割为多个部分时，将流并行化才有意义**。
- 并行流使用的线程池，可能会因诸如文件I/O或网络访问这样的操作被阻塞、而饿死。

只有面对海量的内存数据和计算密集型处理，并行流才会工作最佳。
> 注意：在Java 9之前，对 `Files.lines` 方法返回的流进行并行化是没有意义的，因为数据是不可分割的——所以我们只能在读取文件的后半部分之前读取前半部分。现在，该方法使用的是内存映射文件 *memory-mapped file* ，因此可以有效地进行分割。如果想处理一个大型文件的各个行，并行化这个流可能会提高性能。

默认情况下，并行流使用的是 `ForkJoinPool.commonPool` 返回的全局fork-join池。只有在操作不会阻塞、并且我们不会将这个池与其他任务共享时，这种方法才不会有什么问题。有一种解决方法是**使用另一个不同的池，即把操作放置到定制的池的 `submit` 方法中**：
```java
ForkJoinPool customPool = ...;
result = customPool.submit(() ->
	stream.parallel().map(...).collect(...)
).get();
```
或者使用异步方式：
```java
CompletableFuture.supplyAsync(() ->
	stream.parallel().map(...).collect(...), customPool
).thenAccept(result -> ...);
```
如果想要并行化基于随机数的流计算，那么请不要以从 `Random.ints/longs/doubles` 方法中获得的流为起点，因为这些流不可分割，应该使用 `SplittableRandom` 类的 `ints/longs/doubles` 。
```java
// parallel/ParallelStreams.java
package parallel;

import static java.util.stream.Collectors.*;
import java.io.*;
import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;
import java.util.stream.*;

public class ParallelStreams {
	public static void main(String[] args) throws IOException {
		var contents = new String(Files.readAllBytes(
			Paths.get("./src/alice30.txt")), StandardCharsets.UTF_8);
		List<String> wordList = List.of(contents.split("\\PL+"));

		// Very bad code ahead
		var shortWords = new int[10];
		wordList.parallelStream().forEach(s -> {
			if (s.length() < 10) shortWords[s.length()]++;
		});
		System.out.println(Arrays.toString(shortWords));

		// Try again--the result will likely be different (and also wrong)
		Arrays.fill(shortWords, 0);
		wordList.parallelStream().forEach(s -> {
			if (s.length() < 10) shortWords[s.length()]++;
		});
		System.out.println(Arrays.toString(shortWords));

		// Remedy: Group and count
		Map<Integer, Long> shortWordCounts = wordList.parallelStream()
			.filter(s -> s.length() < 10)
			.collect(groupingBy(String::length, counting()));
		System.out.println(shortWordCounts);

		// Downstream order not deterministic
		Map<Integer, List<String>> result = wordList.parallelStream().collect(
			Collectors.groupingByConcurrent(String::length)
		);
		System.out.println(result.get(14));

		result = wordList.parallelStream().collect(
			Collectors.groupingByConcurrent(String::length)
		);
		System.out.println(result.get(14));

		Map<Integer, Long> wordCounts = wordList.parallelStream().collect(
			groupingByConcurrent(String::length, counting())
		);
		System.out.println(wordCounts);
	}
}
```
运行结果如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212170153261.png)

> [API] `java.util.stream.BaseStream<T, S extends BaseStream<T, S>>` 8
> - `S parallel()`
> 产生一个与当前流中元素相同的并行流。
> - `S unordered()`
> 产生一个与当前流中元素相同的无序流。

> [API] `java.util.Collection<E>` 1.2
> - `Stream<E> parallelStream()` 8
> 用当前集合中元素产生一个并行流。