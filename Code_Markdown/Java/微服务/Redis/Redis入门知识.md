# 1.1 什么是Redis

原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）ACID是传统_数据库_常用的设计理念, 追求强一致性模型
BASE 是基本可用，指分布式系统在出现不可预知故障的时候，允许损失部分可用性。
关联：主键、外键，数据的实体完整性、参照完整性和一致性

基于内存的是说，Redis通常将全部数据存储在内存中，但也可以不时的将数据写入硬盘实现持久化，但仅用于重新启动后将数据加载回内存
* 内存的速度比硬盘快一个数量级

Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个开源的、基于内存的、键值型的NoSQL数据库，常用作分布式缓存、消息队列等。
按DB-Engines Ranking的排名，Redis是连续几年最受欢迎的键值存储数据库。

基于内存的是说，Redis通常将全部数据存储在内存中，但也可以不时的将数据写入硬盘实现持久化，但仅用于重新启动后将数据加载回内存
什么是redis。我们先来看一下redis这个词的意思啊，它是源于这三个单词的缩写，remote dictionary server,远程字典服务器。为什么这么叫呢？是这样，就是它是一个独立的数据库的软件啊。所以它可以被独立安装在一台服务器上。它可以远程操作，所以他是远程的。然后它是用键值存储的，键值存储是就像查字典一样，我们根据一个一个词去查这个词的解释，我们的键就是根据一个关键字key去查它对应的值value，所以他叫远程字典服务器。

它是一个基于内存的、当然是开源的数据库，然后通常用作键值存储，缓存或者是消息队列。然后我们来看一下什么叫做基于内存的数据库呢？是这样，redis通常将所有的数据都存在内存中，当然，不通常的情况就是你有虚拟内存。虚拟内存本质上不在内存里，但他也是内存，逻辑上也是内存啊。

然后当然呢，他为了实现持久化，它是这样。默认情况下是每隔两秒把这个数据也写入到硬盘来实现持久化，但是他写入到硬盘里的数据，仅仅是为了重新打开这个软件的时候把数据给加载回来、加载回内存。为什么要这么做啊？是因为我们内存的速度是不是要比硬盘快一个数量级啊。这样做我们这个数据库的性能就会非常的强，正因为他性能非常的好，他在DB engines里的排名，连续好多年是这个键值存储的第一名，最受欢迎。

咱们来看一下redis的发展简史，一个意大利程序员叫做Salvatore Sanfilippo， 他发明了redis。他最早是用普通的原来的传统的数据库，做了一个实时的Web日志分析器。然后他对这个传统数据库的性能不是很满意，就开发了redis。不过要注意的是2020年的6月，他已经辞去了redis的这个维护者的身份

Radis安装
我们分别会说Windows，mac和Linux下怎么安装。
首先我们来看Windows下的安装。我们在搜索这里，搜控制面板，卸载程序，启用或关闭Windows功能，翻到最下面会有一个适用于Linux的Windows子系统，确定这个是勾上的，然后确定。如果不是勾上你勾上然后确定，需要你重启一下。

这个解决了以后呢，我们去应用商店搜ubuntu，然后点安装就可以了，如果你安装过了，可以直接打开，也可以在命令行里输ubuntu来打开。然后我们就可以安装我们这个ubuntu上的redis了。乌班图上有个这个安装工具叫做apt，我们就用它，sudo是管理员权限、以管理员权限运行我们的apt。然后首先更新一下他的软件列表 update。更新完成以后呢，我们就可以来安装，首先还是为了防止权限不够，我们还是用这个管理员的权限来安装sudo apt install redis-server。安装完成以后我们怎么启动呢，还是用管理员权限啊，防止他权限不够sudo service redis-server start
这样就启动了我们的redis服务端

为了检验安装成功，我们启动一下redis命令行界面redis-cli，我们给他输一个ping，他会返回来一个pong，就代表安装成功

然后这个ubuntu，当然他底层是这个debian上面，都是apt啊，我们就不说了
至于Centos，它是使用yum这个工具来安装我们的redis

接下来我们来看Mac OS上的安装。首先我们刚才你们看Windows上安装，我们用到了这个Windows的子系统ubuntu啊，上面有个方便的软件包管理器叫apt
 macOS上也有这么方便的工具啊，叫做homebrew，他的官网就是这个brew.sh
 咱们直接进去官网，他有一条安装命令，把这个复制到命令行去运行就OK，然后我们就安装了homebrew。然后我们用这个命令，brew install redis就可以完成redis的安装，然后我们用这个brew services start redis就可以启动我们的redis，而且呢
，他会帮我们自动的配置这个开机自启动啊什么的，非常的方便。

ZRANGE根据排名查询具体的值，而不是数量，不过ZRANGE默认根据分数的升序，所以要用ZREVRANGE

查同学还是用ZRANGE，但按的不是排名、而是分数，要用ZRANGEBYSCORE
# 2. 分布式缓存与Redis集群
-- 基于Redis集群解决单机Redis存在的问题

缓存大家都不陌生，现在企业中做缓存、很多都会使用到Redis，不过前面讲到的Redis都是做的单节点部署，单节点Redis其实存在一些问题。要用Redis集群实现分布式缓存，就要解决这些问题。
- 数据丢失问题，Redis是内存存储，服务器断电重启、故障等，可能会丢失数据 --> 用Redis本身的数据持久化功能写入数据到磁盘
- 并发能力问题：单节点Redis并发能力虽然不错，但也无法满足双11等高并发电商购物场景 --> 搭建Redis主从集群，从结点可以有很多个，多个从结点之间可以负载均衡，主从之间则实现读写分离，避免读写互斥，并发能力更强 --> 主从模式满足高可用效果，很大程度避免宕机导致的数据丢失。--> 为了避免全部挂完，需要恢复结点
- 故障恢复问题：如果Redis出现故障，则服务不可用，需要一种自动的故障恢复手段。我们需要保证整个Redis集群是持续可用的，一旦任意一个服务出现故障，它不能影响其他服务的使用，且能在运行过程中修复这些故障结点。单节点Redis挂了就是挂了。 --> 利用Redis哨兵机制，哨兵不断监测集群中节点的健康状态，实现健康监测和自动恢复，一旦节点故障了就进行恢复
- 存储能力问题：Redis基于内存，内存空间有限且昂贵，而我们的数据量是在持续增长的，单节点存储的数据量难以满足海量数据需求。--> 
最后一个问题，刚才说的主从集群，主从存的数据是一样的，它的存储上限不超过单个节点的内存上限。应对这个问题，学习ElasticSearch，其中把数据分片保存到多个节点，搭建分片集群，利用插槽机制实现动态扩容。数据越多、就加更多机器，理论上存储能力是无上限的。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212021905001.png)



时间有限，只简单介绍一下Redis的持久化机制。

RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说，就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，就从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。

和RDB持久化相关的命令我们之前就看到了，RDB持久化在四种情况下会执行：
- 执行save命令：
- 执行bgsave命令
- Redis停机时
- 触发RDB条件时

save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。save命令把数据写到磁盘，磁盘的速度比较慢，如果数据量比较大，这个过程耗时比较久。等待执行结束，会返回一个OK，此时才算完成，主进程才能处理其他请求。这个方式是比较不推荐的，主要用于Redis服务马上要停机时（不是宕机）。

bgsave执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。推荐使用这个命令，在后台异步执行，用另一个进程单独执行数据的保存（一个子进程），比较适合于在Redis运行过程中做。

Redis停机时会执行一次save命令，实现RDB持久化。不过如果这个过程中宕机，数据就会丢失。我们更希望的是每隔一段时间执行一次RDB。

Redis内部有触发RDB的机制，可以在配置文件redis.conf中找到，格式如下。我们可以自己修改配置文件，设置RDB执行的时间间隔、触发条件、是否压缩RDB文件，以及设置RDB文件名称和存储路径等：
PPT
进行设置后，这样每隔一段时间、会执行一次RDB，数据的可持久化就得到保障了。设置时间多少好呢？太长可能出现数据丢失、没有记录，太短RDB执行频率过高，如果数据量很大，也会影响性能。一般情况下按照默认就行了。

对于是否在保存时压缩RDB文件，建议不开启。虽然开启后，文件体积变小、节省磁盘,但压缩过程会消耗CPU时间和资源，磁盘的话不值钱，而CPU资源比较紧张。当然，如果CPU资源充足的话，也完全可以开启。

RDB如何实现异步持久化？在Linux中，所有进程都不能直接操作物理内存，而是由操作系统给每个进程分配虚拟内存，（Redis主）进程只能操作虚拟内存，操作系统维护一个物理内存和虚拟内存的映射关系表（页表）。

Redis操作虚拟内存，而虚拟内存基于页表操作物理内存。这里的fork仅仅拷贝页表，能映射到相同的物理内存区域，实现子进程和主进程的物理内存共享。大大减少阻塞时间（而非复制主进程数据）。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212021955705.png)

bgsave开始时会fork主进程得到子进程（`fork` 的过程是阻塞的，此时主进程不能接收用户请求，只有尽可能完成这件事才能避免阻塞时间过久），子进程共享主进程的内存数据。**完成fork后读取内存数据并写入RDB文件**（这个过程是异步的）。几乎能实现对主进程零阻塞。

在子进程写RDB文件时，主进程可以接受用户请求，修改内存中的数据。主进程和子进程可能读写冲突。为避免这个问题，`fork` 采用的是 `copy-on-write` 技术：
- 当主进程执行读操作时，访问共享内存（标记共享内存为Read-Only，任何进程只能读、而不能写）；
- 当主进程每次执行写操作时，都会拷贝一份数据（如数据B副本），再执行写操作。

极端情况下，RDB写文件比较慢，而不断有数据进来、要求修改这些共享的数据，结果所有数据都被修改一遍，意味着所有数据都要拷贝一份新的、且redis对内存的占用翻倍了。几乎不可能发生，但理论上可能。一般情况下，Redis要预留一些空间，服务器的空间Redis不能全部占满

和AOP一起应用，能大大提高数据的安全性，弥补RDB的缺陷。
AOF全称为 `Append Only File`（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。（$符表示长度为多少）
```properties
# 表示每当Redis执行一次写命令,会将数据写到内存,同时立即记录命令到AOF文件,都是由主进程完成的,主进程接到命令后,先操作内存、再写磁盘,这两个动作必须一起完成,请求才算处理完毕,和SQL数据库很像,数据安全性保障强,性能最差
appendfsync always 
# 写命令执行完先放入AOF缓冲区,然后每隔1秒将缓冲区数据一起写到AOF文件，是默认方案.性能比较好,主进程只负责往缓冲区写、还是内存方式的读写;不过如果一秒间隔间有服务出现宕机情况,数据就丢失了
appendfsync everysec 
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘,写磁盘的频率比较低,安全性最差,与其这个不如RDB
appendfsync no
```
RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。

## RabbitMQ
MQ是一门重要且复杂的技术，MQ全称为Message Queue，即消息队列，是分布式系统中一种通信手段。重要是因为它功能强劲、能解决很多问题，复杂是因为由于引入MQ诞生更多的问题，这些问题需要我们解决。

这里说到分布式系统的通信问题，这里有两个系统，它们职责不同、干的事不一样，但它们可以组成一个大的系统，我们称为分布式系统。A和B称为分布式系统的子系统，它们之间要完成通信、有两种方式。第一种是，A直接通过远程调用的方式访问B系统；除了这种方式，A系统还能通过第三方完成通信，A将数据发给C，C再将数据发给B。

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212031853694.png)

MQ消息队列就属于后者。在A系统和B系统中引入一个MQ，这个时候A先将数据发送给MQ，MQ再把数据给B系统。这样也可以完成A、B之间的间接通信。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212031906803.png)
回到这个通信模型，A系统是生产消息的，称为生产者、B系统是消费消息的，称为消费者，中间这个MQ称为中间件，存储消息的中间件。

*Advanced Message Queuing Protocol, AMQP*（高级消息队列协议），是一个网络协议，是应用层协议的一个开放标准，**为面向消息的中间件设计**。基于此协议实现的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。可以类比HTTP。

Publisher：发布者
Exchange：翻译过来是交换机，它是用来分发网络请求的。而在AMQP中也是类似的，它将消息分发到不同的Queue（一种容器，存储消息）中。交换机分发的过程就是Routes，路由
Consumer：监听队列，并取走消息
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212032356561.png)

2007年，Rabbit 技术公司基于AMQP标准开发的RabbitMQ 1.0发布。RabbitMQ 采用 Erlang 语言开发。
> Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。