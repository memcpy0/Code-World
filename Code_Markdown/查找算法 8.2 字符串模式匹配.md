串：又叫作字符串，是由零个或多个字符组成的有限序列。对字符串通常用双引号括起来，例如S="abcdef"，S为字符串的名称，双引号里面的内容为字符串的值。
- 串长：串中字符的个数，例如S的串长为7。
- 空串：零个字符的串，串长为0。
- 子串：串中任意连续的字符组成的子序列，被称为该串的子串，原串被称为子串的主串。例如T="cde"，T是S的子串。子串在主串中的位置，用子串的第1个字符在主串中出现的位置表示。T在S中的位置为3，如下图所示。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132153736.png)

注意：空格也算一个字符，例如S="abc fg"，S的串长为6。空格串：全部由空格组成的串为空格串，空格串不是空串。
## 8.2.1　BF算法
模式匹配：子串的定位运算被称为串的模式匹配或串匹配。

假设有两个串S、T，设S为主串，也称之为正文串；T为子串，也称之为模式。在主串S中查找与模式T相匹配的子串，如果查找成功，则返回匹配的子串的第1个字符在主串中的位置。

最“笨”的算法就是穷举所有S的所有子串，判断其是否与T匹配，该算法被称为BF（Brute Force，暴力穷举）算法。
### 1. 算法步骤
（1）i=0，j=0，如果S[i]=T[j]，则i++，j++，继续比较，否则转向下一步。
（2）i=1，j=0，如果S[i]=T[j]，则i++，j++，继续比较，否则转向下一步。
（3）i=2，j=0，如果S[i]=T[j]，则i++，j++，继续比较，否则转向下一步。
……
（4）如果T比较完毕，则返回T在S中第1个字符出现的位置。
（5）如果S比较完毕，则返回0，说明T在S中未出现。
### 2. 完美图解
例如，S="abaabaabeca"，T="abaabe"，求子串T在主串S中的位置。
（1）i=0，j=0，如果S[i]=T[j]，则i++，j++，继续比较，否则转向下一步。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132156546.png)
（2）i回退到i-j+1的位置，j回退到0的位置，即i-j+1=6-6+1=1。如果S[i]=T[j]，则i++，j++，继续比较，否则转向下一步。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132157027.png)

解释：为什么i要回退到i-j+1的位置呢？如果本趟开始位置的字符是a，那么下一趟开始位置的字符就是a的下一个字符b，这个位置的下标正好是i-j+1。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132158261.png)

（3）i回退到i-j+1的位置，i=2-1+1=2，j回退到0的位置。如果S[i]=T[j]，则i++，j++，继续比较，否则转向下一步。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132158731.png)
（4）i回退到i-j+1的位置，i=4-2+1=3，j回退到0的位置。如果S[i]=T[j]，则i++，j++，继续比较，此时T串比较完毕。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132158799.png)

（5）T比较完毕，则返回子串T在主串S中第1个字符出现的位置，即i-m+1=9-6+1=4，m为T串的长度。注意：位序是从1开始的。

### 3. 算法实现
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132159074.png)

### 4. 算法分析
设S、T串的长度分别为n、m，则BF算法的时间复杂度分析如下。
1）最好情况在最好情况下，每一次匹配都在第一次比较时发现不等，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132200257.png)
假设第k次匹配成功，则前k-1次匹配都进行了1次比较，共k-1次，在第k次匹配成功时进行了m次比较，则总的比较次数为k-1+m。在匹配成功的情况下，最多需要n-m+1次匹配，即模式串正好在主串的最后端。假设每一次匹配成功的概率均等，概率为pk=1/(n-m+1)，则在最好情况下，匹配成功的平均比较次数如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132200557.png)

最好情况下的平均时间复杂度为O(n+m)。

2）最坏情况在最坏情况下，每一次匹配都比较到T的最后一个字符时发现不等，回退并重新开始，这样每次匹配都需要比较m次，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132200449.png)
假设第k次匹配成功，则前k-1次匹配都进行了m次比较，在第k次匹配成功时也进行了m次比较，总的比较次数为k×m。在匹配成功的情况下，最多需要n-m+1次匹配，即模式串正好在主串的最后端。假设每一次匹配成功的概率均等，概率为pk=1/(n-m+1)，则在最坏情况下，匹配成功的平均比较次数如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132200676.png)

最坏情况下的平均时间复杂度为O(n×m)。
## 8.2.2　KMP算法
实际上，完全没必要从S的每一个字符开始暴力穷举每一种情况，Knuth、Morris和Pratt对该算法进行了改进，称之为KMP算法。

再回头看8.2.1节中的例子：i=0，j=0，如果S[i]=T[j]，则i++，j++，继续比较，否则转向下一步，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132258710.png)

按照BF算法，如果不等，则i回退到i-j+1，j回退到0，即i=1，j=0，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132341324.png)
其实i不用回退，令j回退到2，接着比较即可，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132341647.png)
是不是像T串向右滑动了一段距离？为什么令j回退到2？而不是1或3？

因为T串中开头的两个字符和i指向的字符前面的两个字符一模一样，如下图所示。那么j就可以回退到2继续比较了，因为前面两个字符已经相等了，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132342459.png)
怎么知道T串中开头的两个字符和i指向的字符前面的两个字符一模一样？难道还要比较？观察发现i指向的字符前面的两个字符和T串中j指向的字符前面两个字符一模一样，因为它们一直相等，才会i++、j++走到当前位置，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132343112.png)
也就是说，==不必判断开头的两个字母和i指向的字符前面的两个字符是否一样，**只需在T串本身比较就可以了**。假设T串中当前j指向的字符前面的所有字符为T′，则只需比较T′的前缀和T′的后缀即可==，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132344054.png)
前缀是从前向后取若干字符，后缀是从后向前取若干字符，但前缀和后缀都不可以取字符串本身。字符串的长度为n，前缀和后缀的长度最多达到n-1，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132344733.png)
判断T′="abaab"的前缀和后缀是否相等，找前缀和后缀相等的最大长度。
- 长度为1：前缀为“a”，后缀为“b”，不相等。
- 长度为2：前缀为“ab”，后缀为“ab”，相等。
- 长度为3：前缀为“aba”，后缀为“aab”，不相等。
- 长度为4：前缀为“abaa”，后缀为“baab”，不相等。

前缀和后缀相等的最大长度l=2，j可以回退到2继续比较。因此当i、j指向的字符不相等时，**只需求出T′的相等前缀后缀的最大长度l**，i不变，j回退到l继续比较即可，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132349874.png)
现在可以写出如下通用公式，其中，**next[j]表示j需要回退的位置**，T′="t0t1…tj-1"，则：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132349607.png)
根据公式很容易求解T="abaabe"的next[]数组，过程如下。
（1）j=0：根据公式，next[0]=-1。
（2）j=1：**T′="a"，没有前缀和后缀，next[1]=0**。
（3）j=2：T′="ab"，前缀为“a”，后缀为“b”，不相等，next[2]=0。
（4）j=3：T′="aba"，前缀为“a”，后缀为“a”，相等且l=1；前缀为“ab”，后缀为“ba”，不相等；因此next[3]=l=1。
（5）j=4：T′="abaa"，前缀为“a”，后缀为“a”，相等且l=1；前缀为“ab”，后缀为“aa”，不相等; 前缀为“aba”，后缀为“baa”，不相等；因此next[4]=l=1。
（6）j=5：T′="abaab"，前缀为“a”，后缀为“b”，不相等；前缀为“ab”，后缀为“ab”，相等且l=2；前缀为“aba”，后缀为“aab”，不相等；前缀为“abaa”，后缀为“baab”，不相等；取最大长度2，因此next[5]=l=2。
（7）j=6：T′="abaabe"，前缀和后缀都不相等，next[6]=0。字符串T的next[]数组如下表所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306132357603.png)
这样找所有的前缀和后缀进行比较的方法，是不是也属于暴力穷举？
### 1. 完美图解
可以**用动态规划**递推。首先**假设已经知道了next[j]=k**，T′="t0t1…tj-1"，那么T′的相等前缀后缀的最大长度为k，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306140007476.png)

那么next[j+1]等于什么？考察以下两种情况。
（1）tk=tj：next[j+1]=k+1，即相等前缀（相当于模式串）和后缀（相当于待匹配的串）的长度比next[j]多1，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306140010217.png)

（2）tk≠tj：**当两者不相等时，我们又开始了这两个串的模式匹配**，回退并**查找next[k]=k′的位置**，比较tk′与tj是否相等，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306140014668.png)

如果tk′与tj相等，则next[j+1]=k′+1。如果tk′与tj不相等，则继续回退并查找next[k′]=k''，比较tk''与tj是否相等，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306140019606.png)

如果tk''与tj相等，则next[j+1]=k''+1。如果tk''与tj不相等，则继续向前查找，直到找到next[0]=-1，停止，此时next[j+1]=-1+1=0，即从0开始比较。求解next[]的代码实现如下。
```cpp
void getNext(string t) { // 求模式串T的next[]函数
    int j = 0, k = -1; // 快慢指针,分别指向后缀的结束字符j和前缀的结束字符
    next[0] = -1;
    while (j < tlen) { // 模式串t的长度
        if (k == -1 || t[j] == t[k]) 
            next[++j] = ++k;
        else 
            k = next[k];
    }
}
```
用上述方法再次求解得出T="abaabe"的next[]数组，过程如下。
（1）初始化时next[0]=-1，j=0，k=-1，进入循环，判断k=-1，执行代码next[++j]=++k，即next[1]=0，此时j=1，k=0。
（2）进入循环，判断是否满足T[j]=T[k]，T[1]≠T[0]，执行代码k=next[k]，即k=next[0]= -1，此时j=1，k=-1。
（3）k=-1，执行代码next[++j]=++k，即next[2]=0，此时j=2，k=0。
（4）T[2]=T[0]，执行代码next[++j]=++k，即next[3]=1，此时j=3，k=1。
（5）T[3]≠T[1]，执行代码k=next[k]，即k=next[1]=0，此时j=3，k=0。
（6）T[3]=T[0]，执行代码next[++j]=++k，即next[4]=1，此时j=4，k=1。
（7）T[4]=T[1]，执行代码next[++j]=++k，即next[5]=2，此时j=5，k=2。
（8）T[5]≠T[2]，执行代码k=next[k]，即k=next[2]=0，此时j=5，k=0。
（9）T[5]≠T[0]，执行代码k=next[k]，即k=next[0]= -1，此时j=5，k=-1。
（10）k=-1，执行代码next[++j]=++k，即next[6]=0，此时j=6，k=0。
（11）此时j=tlen，字符串处理完毕，算法结束。

是不是和穷举前缀和后缀的结果一模一样？有了next[]数组，就很容易进行模式匹配了，当S[i]≠T[j]时，i不动，j回退到next[j]继续比较即可。
### 2. 算法实现
位序从1开始。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306140024263.png)
### 3. 算法分析
设S、T串的长度分别为n、m。KMP算法的特点：i不回退，当S[i]≠T[j]时，j回退到next[j]，重新开始比较。在最坏情况下扫描整个S串，其时间复杂度为O(n)。计算next[]数组时需要扫描整个T串，其时间复杂度为O(m)，因此总的时间复杂度为O(n+m)。

需要注意的是，尽管BF算法在最坏情况下的时间复杂度为O(n×m)，KMP算法的时间复杂度为O(n+m)，但==在实际运用中，BF算法的时间复杂度一般为O(n+m)，因此仍然有很多地方用BF算法进行模式匹配==。**只有在主串和子串有很多部分匹配的情况下，KMP才显得更优越**。

### 4. 改进的KMP算法
在KMP算法中，采用next[]求解非常方便、迅速，但也有一个问题：当si≠tj时，j回退到next[j]（k=next[j]），然后将si与tk进行比较。这样的确没错，但**如果tj=tk，这次比较就没必要了**，刚才正是因为si≠tj才回退的，tj=tk，所以si≠tk，完全没必要再比较了。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306140025670.png)

再向前回退，找下一个位置next[k]，继续比较就可以了。当si≠tj时，本来应该j回退到next[j]（k=next[j]），将si与tk进行比较。但如果tk=tj，则不需要比较，继续回退到下一个位置next[k]，减少了一次无效比较。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306140025735.png)

字符串T ="aaaab"的next[]数组和改进的next[]数组如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306140025328.png)

采用KMP算法在字符串S="aabaaabaaaabea"中查找T串，如果使用next[]数组，则需要比较19次才能匹配成功，采用改进的next[]数组则比较14次即可匹配成功。

求解改进的next[]的代码实现如下。
```cpp
void getNext2(string t) { // 改进的next[]
    int j = 0, k = -1;
    next[0] = -1; 
    while (j < tlen) { // 模式串t的长度
        if (k == -1 || t[j] == t[k]) {
            ++j, ++k;
            if (t[j] == t[k]) next[j] = next[k];
            else next[j] = k;
        } else k = next[k];
    }
}
```
### 5. 算法分析
设S、T串的长度分别为n、m。改进的KMP算法只是在求解next[]数组时从常数上进行改进，并没有降阶，因此其时间复杂度仍为O(n+m)。


---
## 训练1　统计单词数
题目描述（P1308）：一般文本编辑器都有查找单词的功能，可以快速定位特定单词在文章中的位置，有的还能统计特定单词在文章中出现的次数。给定一个单词，请输出它在给定的


文章中出现的次数和第1次出现的位置。匹配单词时，不区分大小写，但要求完全匹配，即给定的单词必须与文章中的某一独立的单词在不区分大小写的情况下完全相同（参见输入样例1），如果给定的单词仅是文章中某一单词的一部分，则不算匹配（参见输入样例2）。输入：第1行是一个单词字符串，只包含字母；第2行是一个文章字符串，只包含字母和空格。1≤单词长度≤10，1≤文章长度≤1 000 000。输出：如果在文章中找到给定的单词，则输出以空格隔开的两个整数，分别表示单词在文章中出现的次数和第1次出现的位置（即在文章中第1次出现时，单词首字母在文章中的位置，位置从0开始）；如果单词在文章中没有出现，则输出-1。[插图]题解：本题为字符串匹配问题，需要注意两个问题：①不区分大小写；②完全匹配。对第①个问题很容易解决，将所有字母都统一转换为小写或大写即可。对第②个问题可以采用首尾补空格的办法解决，例如单词为“Abc”，文章为“xYabc aBc”，首先将其全部转换为小写字母，然后在单词和文章的首尾分别补空格，单词为“˽abc˽”，文章为“˽xyabc˽abc˽”，空格为不可见字符，为了表达清楚，用“˽”表示。这样就可以

在文章中查找单词，保证完全匹配。1. 算法设计（1）读入单词和文章，首尾分别补空格。（2）将单词和文章全部转换为小写字母。（3）在文章中查询单词首次出现的位置posfirst，如果查询失败，则输出-1，算法结束。（4）令t=posfirst+len1-1，出现的次数cnt=1。如果t<len2，则从t位置开始在文章中查找单词，如果匹配成功，t=BF(word,sentence,t)，则cnt++，更新t=t+len1-1，继续搜索。2. 算法实现[插图][插图]训练2　KMP字符串匹配题目描述（P3375）：给定两个字符串s1 和s2，若s1 的 [l,r] 区间的子串与s2 完全相同，则称s2在s1中出现了，其出现位置为l。请求出s2在s1中所有出现的位置。定义一个字符串s的border为s的一个非s本身的子串t，满足t既是s的前缀，又是s的后缀。对于s2，还需要求出对于其每个前缀的最长border的长度。输入：第1行为字符串s1；第2行为字符串s2。1≤|s1|,|s2|≤106，字符串只含大写英文字母。输出：首先输出若干行，每行一个整数，按从小到大的顺序输出s2在s1中出现的位置。最后一行输出|s2 |个整数，第i个整数表示s2的长度为i的前缀的最长border的长度。[插图]题解：本题实质上是模式匹配和求解KMP算法中next[]数组的问题。1. 算法设计（1）输入字符串s和t，采用KMP算法从头开始查找t在s中出现的位置。（2）求解字符串t的next[]数组。next[i]表示t的长度为i的前缀的最长border的长度。2. 算法实现[插图]
