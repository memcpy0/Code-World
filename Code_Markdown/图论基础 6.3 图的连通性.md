## 6.3.1　连通性的相关知识
### 1. 无向图的连通分量
在无向图中，如果从节点vi到节点vj有路径，则称节点vi和节点vj是连通的。如果图中任意两个节点都是连通的，则称图G为连通图。如下图所示就是一个连通图。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112158911.png)
无向图G的极大连通子图被称为图G的连通分量。极大连通子图是图G连通子图，如果再向其中加入一个节点，则该子图不连通。连通图的连通分量就是它本身；非连通图则有两个以上的连通分量。

例如在下图中有3个连通分量。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112206301.png)

### 2. 有向图的强连通分量
在有向图中，如果图中的任意两个节点从vi到vj都有路径，且从vj到vi也有路径，则称图G为强连通图。有向图G的极大强连通子图被称为图G的强连通分量。极大强连通子图是图G的强连通子图，如果再向其中加入一个节点，则该子图不再是强连通的。例如在下图中，(a)是强连通图，(b)不是强连通图，(c)是(b)的强连通分量。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112207498.png)
### 3. 无向图的桥与割点
在生活中，桥是连接河两岸的交通要道，桥断了，则河两岸不再连通。在图论中，桥有同样的含义，如下图所示，去掉边5-8后，图分裂成两个互不连通的子图，边5-8为图G的桥。同样，边5-7也为图G的桥。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112208356.png)
如果在去掉无向连通图G中的一条边e后，图G分裂为两个不相连的子图，那么e为图G的**桥或割边**。在日常网络中有很多路由器使网络连通，有的路由器坏掉也无伤大雅，网络仍然连通，但若非常关键节点的路由器坏了，则网络将不再连通。如下图所示，如果节点5的路由器坏了，图G将不再连通，会分裂成3个不相连的子图，则节点5为图G的割点。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112214305.png)

如果在去掉无向连通图G中的一个点v及与v关联的所有边后，图G分裂为两个或两个以上不相连的子图，那么v为图G的**割点**。

注意：==删除边时，只把该边删除即可，不要删除与边关联的点；而删除点时，要删除该点及其关联的所有边==。

割点与桥的关系：①**有割点不一定有桥，有桥一定有割点**；②**桥一定是割点依附的边**。
### 4. 无向图的双连通分量
**如果在无向图中不存在桥，则称它为边双连通图**。
- 在边双连通图中，在任意两个点之间都存在两条及以上路径，且==**路径上的边**互不重复==。
- **如果在无向图中不存在割点，则称它为点双连通图**。
    - ==在点双连通图中，如果节点数大于2，则在任意两个点间都存在两条或以上路径，且**路径上的点**互不重复==。
    - 如果节点数为2，如 1 -- 2，也是点双连通。

无向图的极大边双连通子图被称为边双连通分量，记为e-DCC。无向图的极大点双连通子图被称为点双连通分量，记为v-DCC。二者被统称为双连通分量DCC。
### 5. 双连通分量的缩点
把每一个**边双连通分量**e-DCC都看作一个点，把桥看作连接两个缩点的无向边，可得到一棵树，这种方法被称为**e-DCC缩点**。

例如，在下图中有两个桥：5-7和5-8，将每个桥的边都保留，将桥两端的边双连通分量缩为一个点，**生成一棵树**。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112216005.png)
注意：**边双连通分量就是删除桥之后留下的连通块**，但**点双连通分量并不是删除割点后留下的连通块**。

在图G中有两个割点（5和8）及4个点双连通分量，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112217872.png)

把每一个**点双连通分量**v-DCC都看作一个点，==把割点看作一个点，每个割点都向包含它的v-DCC连接一条边==，**得到一棵树**，这种方法被称为v-DCC缩点。

例如，在图G中有两个割点5、8，前3个点双连通分量都包含5，因此从5向它们引一条边，后两个点双连通分量都包含8，因此从8向它们引一条边，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112218101.png)

## 6.3.2　Tarjan算法
Robert Tarjan以在数据结构和图论上的开创性工作而闻名，他的一些著名算法包括Tarjan最近公共祖先离线算法、Tarjan强连通分量算法及Link-Cut-Trees算法等。其中，Hopcroft-Tarjan平面嵌入算法是第1个线性时间平面算法。Robert Tarjan也开创了重要的数据结构，例如斐波纳契堆和Splay树，另一项重大贡献是分析了并查集。

在介绍算法之前，首先引入时间戳和追溯点的概念。
- 时间戳：$dfn[u]$ 表示节点u深度优先遍历的序号。
- 追溯点：$low[u]$ 表示节点u或u的子孙能通过**非父子边**追溯到的**dfn最小的节点序号**，即回到最早的过去。

例如，在深度优先搜索中，每个点的时间戳和追溯点的求解过程如下。初始时，$dfn[u]=low[u]$ ，如果该节点的邻接点未被访问，则一直进行深度优先遍历，1-2-3-5-6-4，此时==4的邻接点1已被访问，且1不是4的父节点，4的父节点是6（深度优先搜索树上的父节点）==。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112223094.png)
那么节点4能回到最早的节点是节点1（dfn=1），因此 $low[4]=min(low[4],dfn[1])=1$ 。返回时，更新 $low[6]=min(low[6],low[4])=1$ 。**更新路径上所有祖先节点的low值，因为子孙能回到的追溯点，其祖先也能回到**。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112224615.png)

### 1. 无向图的桥
桥判定法则：无向边x-y是桥，当且仅当在搜索树上**存在x的一个子节点y**，满足$low[y]>dfn[x]$ 。

也就是说，==若孩子的low值比自己的dfn值大，则从该节点到这个孩子的边为桥==。在下图中，边为5-7，5的子节点为7，满足low[7]>dfn[5]，因此边5-7为桥。

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112228025.png)
算法代码：
```cpp
void tarjan(int u, int fa) { // 求割边
    dfn[u] = low[u] = ++num;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if (v == fa) continue;
        if (!dfn[v]) { // 未访问过
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] > dfn[u]) 
                cout << u << "--" << v << "是桥" << endl;
        } else low[u] = min(low[u], dfn[v]);
    }
}
```
### 2. 无向图的割点
割点判定法则：**若x不是根节点**，则x是割点，当且仅当在搜索树上存在x的一个子节点y，满足 $low[y]≥dfn[x]$ ；**若x是根节点**，则x是割点，==当且仅当在搜索树上至少存在两个子节点，满足该条件==。也就是说，如果不是根，且孩子的low值大于或等于自己的dfn值，则该节点就是割点；如果是根，则至少需要两个孩子满足条件。

在下图中，5的子节点是7，满足low[7]>dfn[5]，因此5是割点。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112246770.png)
有几种割点判定情况，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112247117.png)

算法代码：
```cpp
void tarjan(int u, int fa) { // 求割点
    dfn[u] = low[u] = ++num;
    int count = 0;
    for (int i = 0; i; i = e[i].next) {
        int v = [i].to;
        if (v == fa) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                ++count;
                if (u != root || count > 1)
                    cout << u << "是割点" << endl;
            }
        } else low[u] = min(low[u], dfn[v]);
    }
}
```
### 3. 有向图的强连通分量
算法步骤：
（1）深度优先遍历节点，在第1次访问节点x时，将x入栈，且$dfn[x]=low[x]=++num$ 。
（2）遍历x的所有邻接点y。
- 若y没被访问，则递归访问y，返回时更新 $low[x]=\min(low[x],low[y])$。
- 若**y已被访问且在栈中**，则令 $low[x]=\min(low[x],dfn[y])$ ——一个节点可以被访问过，但==在栈中表示它不是其他强连通分量的节点==。
（3）在x回溯之前，**如果判断 $low[x]=dfn[x]$ ，则从栈中不断弹出节点，直到x出栈时停止**。弹出的节点就是一个连通分量。

例如，求解有向图的强连通分量，过程如下。
（1）从节点1出发进行深度优先搜索，$dfn[1]=low[1]=1$ ，1入栈；$dfn[2]=low[2]=2$ ，2入栈；此时无路可走，回溯。因为 $dfn[2]=low[2]$ ，所以2出栈，得到强连通分量2。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112327652.png)

（2）回溯到1后，继续访问节点1的下一个邻接点3。接着访问3-4-5，5的邻接点1的dfn已经有解，且1在栈中，更新 $low[5]=min(low[5],dfn[1])=1$ 。回溯时更新 $low[4]=min(low[4],low [5])=1$ ，$low[3]=min(low[3],low[4])=1$ ，$low[1]=min(low[1],low[3])=1$ 。节点1的所有邻接点都已访问完毕，因为$dfn[1]=low[1]$，所以开始出栈，直到遇到1，得到强连通分量5 4 3 1。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112327665.png)
```cpp
void tarjan(int u) { // 求强连通分量
    low[u] = dfn[u] = ++num;
    ins[u] = true; // 在栈中
    s.push(u);
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (ins[v]) // dfn[v]!=0表示已被访问,ins[v]表示在栈中
            low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        int v;
        cout << "强连通分量：";
        do {
            v = s.top(); s.pop();
            cout << v << " ";
            ins[v] = false;
        } while (v != u);
        cout << endl;
    }
}
```

## 训练1　电话网络
题目描述（POJ1144）：电话公司正在建立一个新的电话网络，每个地方都有一个电话交换机（编号为1～N）。线路是双向的，并且总是将两个地方连接在一起，在每个地方，线路都终止

于电话交换机。从每个地方都可以通过线路到达其他地方，但不需要直接连接，可以进行多次交换。有时在某个地方发生故障，会导致交换机无法运行。在这种情况下，除了无法到达失败的地方，还可能导致其他地方无法相互连接。这个地方（发生故障的地方）是至关重要的。请写程序来查找所有关键位置的数量。输入：输入包含多个测试用例。每个测试用例都描述一个网络。每个测试用例的第1行都是N（N<100）。接下来最多N行中的每一行都包含一个地点的编号，后面是该地方可以直达的地点的编号。每个测试用例都以一条仅包含0的行结束。N=0时输入结束，不处理。输出：对每个测试用例，都单行输出关键位置的数量。[插图]题解：• 输入样例1，构建的图如下图所示。在该图中有1个关键点5。[插图]• 输入样例2，构建的图如下图所示。在该图中有两个关键点，分别是2和5。[插图]本题比较简单，就是求割点数，利用Tarjan算法求解即可。算法代码：[插图][插图]训练2　道路建设题目描述（POJ3352）：热带岛屿负责道路的人们想修理和升级岛上各个旅游景点之间的道路。道路本身也很有趣，它们从不在交叉路口汇合，而是通过桥梁和隧道相互交叉或相互通过。通过这种方式，每条道路都在两个

特定的旅游景点之间运行，这样游客就不会迷失。不幸的是，当建筑公司在特定道路上工作时，该道路在任何一个方向都无法使用。如果在两个旅游景点之间无法同行，则即使建筑公司在任何特定时间只在一条道路上工作，也可能出现问题。道路部门已经决定在景点之间建造新的道路，以便在最终配置中，如果任何一条道路正在建设，则仍然可以使用剩余的道路在任意两个旅游景点之间旅行。我们的任务是找到所需的最少数量的新道路。输入：输入的第1行将包括正整数n（3≤n≤1000）和r（2≤r≤1000），其中n是旅游景点的数量，r是道路的数量。旅游景点的编号为1～n。以下r行中的每一行都将由两个整数v和w组成，表示在v和w的景点之间存在道路。请注意，道路是双向的，在任何两个旅游景点之间最多有一条道路。此外，在目前的配置中，可以在任意两个旅游景点之间旅行。输出：单行输出需要添加的最少道路数量。[插图]题解：输入样例2，构建的图如下图所示。不需要添加新的道路，就可以保证在一条道路维修时，可以通过其他道路到达任何一个景点。因此至少需要添加0条边。[插图]如何求解至少添加多少条边呢？（1）如果在无向图中不存在桥，则称它为边双连通图。如果节点在一个边

双连通分量中，则不需要添加边。因此需要求解边双连通分量。在边双连通分量之间需要添加边。输入样例1，其边双连通分量如下图所示。[插图]（2）将每个连通分量都缩成一个点，如下图所示。[插图]（3）求解需要添加的新路数量。如果度为1的节点数为k，则至少添加(k+1)/2条边。例如，对3个度为1的节点至少需要加两条边，对4个度为1的节点至少需要加两条边。[插图]• 为什么要统计叶子（度为1的节点）呢？连通分量缩点后得到一个棵树，在树中任意两个点间添加一条边都会产生一个回路。在两个叶子之间添加一条边，则叶子和一些分支节点一起构成一个回路。而在分支节点之间添加一条边，产生的回路不会包含叶子。因此通过连接叶子可以添加最少的边，使每个节点都在回路中。• 为什么添加的边数为(k+1)/2？实际上，如果度为1的点数为偶数k，那么直接两两添加一条边即可，即k/2；如果为奇数，则在k-1点两两添加一条边，在最后一个点再添加一条边，即(k-1)/2+1=(k+1)/2。k为偶数时，k/2=(k+1)/2，因此统一为(k+1)/2。1. 算法设计（1）先运行Tarjan算法，求解边双连通分量。（2）缩点。检查每个节点u的每个邻接点


v，若low[u]!=low[v]，则将这个连通分量点low[u]的度加1，degree[low[u]]++，同一个连通分量中的节点low[]相同。（3）统计度为1的点的个数为leaf，添加的最少边数为(leaf+1)/2。2. 算法实现[插图][插图]训练3　图的底部题目描述（POJ2553）：对于有向图G中任意一个节点v，如果节点v可以到达节点w，那么节点w都可以到达节点v，那么节点v是一个sink节点。图G的底部是由图G中所有的sink节点构成的，请按顺序输出图G底部的所有sink节点，如果没有sink节点，则输出一个空行。输入：输入包含几个测试用例，每个测试用例都对应一个有向图G。每个测试用例都以整数v（1≤v≤5000）开始，表示图G的节点数，节点编号为1～v。接下来是非负整数e，然后是e对节点编号v1,w1,…,ve,we，其中(vi,wi)表示一条边。在最后一个测试用例后跟着一个0。输出：单行输出图底部的所有sink节点。如果没有，则输出一个空行。[插图]题解：输入样例1，构建的图如下图所示。图中的sink节点为1和3。[插图]求解强连通分量，并对强连通分量缩点，计算缩点的出度，出度为0的强连通

分量中的所有节点均为sink节点。1. 算法设计（1）先采用Tarjan算法求解有向图的强连通分量，标记强连通分量号。（2）检查每个节点u的每个邻接点v，若强连通分量不同，则将u的连通分量号的出度加1。（3）检查每个节点u，若其连通分量号的出度为0，则输出该节点。2. 算法实现[插图]训练4　校园网络题目描述（POJ1236）：许多学校连接到计算机网络，这些学校之间已达成协议：每所学校都有一份学校名单，其中包括分发软件的学校（接收学校）。注意，即使学校B出现在学校A的分发列表中，学校A也不一定出现在学校B的列表中。编写程序，计算必须收到新软件副本的最少学校数量，以便软件根据协议到达网络中的所有学校（子任务1）。作为进一步的任务，希过将新软件的副本发送到任意学校，使该软件覆盖网络中的所有学校。为了实现这一目标，可能必须通过新成员扩展接收者列表。请计算必须进行的最小数量的扩展，以便发送新软件到任意学校，它将到达所有其他学校（子任务2）。一个扩展表示将一个新成员引入一所学校的接收者名单。输入：第1行包含1个整数N，表示网络中的学校数（2≤N≤100）。学校由前N个正整数标识。接下来的N行，每一行都

描述了接收者列表，第i+1行包含学校i的接收者的标识符。每个列表都以0结尾。空列表在行中仅包含0。输出：输出包括两行。第1行应包含子任务1的解，第2行应包含子任务2的解。[插图]题解：求解过程如下。（1）求解子任务1：至少发送给多少个学校，才能让软件到达所有学校呢？实际上，求强连通分量并缩点后，每个入度为0的强连通分量都必须收到一个新软件副本。输入样例1，构建的图如下图所示，其中包含3个强连通分量，缩点后入度为0的强连通分量有1个，至少发送给1个学校即可，即1、2、5中的任意一个学校。[插图]（2）求解子任务2：至少添加多少个接收关系，才能实现发送给任意一个学校，所有学校都能收到？也就是说，每个强连通分量都必须既有入度，又有出度。对入度为0的强连通分量，至少添加一个入度；对出度为0的强连通分量，至少添加一个出度。添加的边数为max(p,q)，如下图所示。[插图]特殊情况：若只有一个强连通分量，则至少分发给1个学校，需要添加的边数为0。1. 算法设计（1）采用Tarjan算法求解强连通分量，标记连通分量号。（2）检查每个节点u的每个邻接点v，若连通分量号不同，则u连通分量号出度加1，v连通分量号入度加1。




（3）统计入度为0的连通分量数p及出度为0的连通分量数q，求max(p,q)。2. 算法实现[插图][插图]