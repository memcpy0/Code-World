如果你是一位从事网络方面工作的工程师，那么应该经常会听到别人向你抱怨“为什么我又上不去网了？”“为什么我又打不开这个网页了？”“怎么今天网速这么慢？”这些让人头疼的故障。

那么要将之前学习到的知识投入到实践中去，Wireshark 的主要功能之一就是对网络中发生的故障进行排除。接下来对如何使用 Wireshark 来分析网络中常见的故障和威胁进行讲解。

由网络使用中的第一个常见问题“网络在哪里变慢了？”开始，这部分将会围绕以下几点展开：
- 建立一个访问远程服务器的仿真网络；
- 在 Wireshark 中观察远程访问的过程；
- Wireshark 中的时间显示；
- 各位置延迟时间的计算。

# 1. 建立一个可访问远程 HTTP 服务器的仿真网络
在生活和工作中经常会遇到应用程序可以使用，但速度却变得十分缓慢的情况。例如，在使用浏览器查看某个网页的时候，可能会等待很长时间才能查看到页面的内容。

对于大多数人来说，这是一个非常棘手的问题，因为在这个过程中有很多设备参与其中，而这些设备又分布在不同的位置，使用者不可能对它们逐一进行排查，所以也很难找到问题所在。

为了能够更好地了解整个网络的状况，我们首先来构建一个模拟的仿真网络，在这个网络中存在着客户端、服务器以及连接它们的各种设备。构建完成的仿真网络如图 1 所示。
图 1 模拟的仿真网络
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141604325.png)

这个网络主要由以下 3 个部分组成。
- 客户端所在网络，包括“客户端”“内部交换机”“网关”“DNS 服务器”。
- 互联网，包括“互联网路由器”。
- 服务器所在网络，包括“目标网关”“交换机”“HTTP 服务器”。

下面我们给出这个网络的具体设计过程，步骤如下所示。
（1）设计中的两个主要网络的 IP 地址分配为：客户端所在网络 IP 地址为192.168.1.0/24，目标网络所在网络 IP 地址为 192.168.4.0/24。
（2）打开 ENSP，按照图 1 中所示向网络拓扑中添加两个 Server，一个 Client，一个交换机 S3700，3 台路由器 AR1220。
（3）其中 client 的设置如图 2 所示。
图 2 client 的设置
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141721320.png)

（4）DNS 服务器的基础设置如图 3 所示。

如图 4 所示，在服务器信息中的“DNSServer”中添加一条 DNS 记录，主机域名为
“www.a.com”，IP 地址为“192.168.4.100”，单击“增加”按钮之后将其添加到 DNS记录之后，再单击“启动”按钮。
图 3 .DNS 服务器的设置
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141721239.png)
图 4 在“DNSServer”中添加一条 DNS 记录
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141721428.png)
（5）图 1 中的两台交换机不进行任何配置。
（6）图 1 中的 3 台路由器的左侧均为 GE0/0/0 接口，右侧为 GE0/0/1 接口。
（7）3 个路由器使用了动态路由协议 rip，其中网关路由器的配置如下：
```java
<Huawei>sys
[Huawei] interface GigabitEthernet0/0/0
[Huawei-GigabitEthernet0/0/0] ip address 192.168.1.1 255.255.255.0
[Huawei-GigabitEthernet0/0/0]quit
[Huawei] interface GigabitEthernet0/0/1
[Huawei-GigabitEthernet0/0/1] ip address 192.168.2.1 255.255.255.0
[Huawei-GigabitEthernet0/0/1]quit
[Huawei] rip 1
[Huawei-rip-1] version 2
[Huawei-rip-1] network 192.168.1.0
[Huawei-rip-1] network 192.168.2.0
[Huawei-rip-1] quit`
```
（8）互联网路由器的配置如下：
```java
<Huawei>sys
[Huawei] interface GigabitEthernet0/0/0
[Huawei-GigabitEthernet0/0/0] ip address 192.168.2.2 255.255.255.0
[Huawei-GigabitEthernet0/0/0]quit
[Huawei] interface GigabitEthernet0/0/1
[Huawei-GigabitEthernet0/0/1] ip address 192.168.3.1 255.255.255.0
[Huawei-GigabitEthernet0/0/1]quit
[Huawei] rip 1
[Huawei-rip-1] version 2
[Huawei-rip-1] network 192.168.2.0
[Huawei-rip-1] network 192.168.3.0
[Huawei-rip-1] quit
```
（9）HTTP 路由器的配置如下：
```
<Huawei>sys
[Huawei] interface GigabitEthernet0/0/0
[Huawei-GigabitEthernet0/0/0] ip address 192.168.3.2 255.255.255.0
[Huawei-GigabitEthernet0/0/0]quit
[Huawei] interface GigabitEthernet0/0/1
[Huawei-GigabitEthernet0/0/1] ip address 192.168.4.1 255.255.255.0
[Huawei-GigabitEthernet0/0/1]quit
[Huawei] rip 1
[Huawei-rip-1] version 2
[Huawei-rip-1] network 192.168.3.0
[Huawei-rip-1] network 192.168.4.0
[Huawei-rip-1] quit
```
（10）HTTP 服务器的基础配置如图 5 所示。
图 5 HTTP 服务器的配置
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141722414.png)

在其中的服务器信息中设置 HttpServer，这里需要建立一个网页。如果你手头没有专门用来设计网页的工具，可以使用最常见的 Word 来完成，在 C 盘下建立一个名为 net 的文件夹。然后新建一个 Word 文档，在文档中输入“Hello word”。然后在菜单栏中依次单击“另存为”→“其他格式”，起名为“default.htm”。将其保存到 C 盘 net 文件夹中（该文件更需要读者自行创建），如图 6 所示。
图 6 创建的“default.htm”
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141722135.png)

接下来我们在 HTTP 服务器中将 net 文件夹作为网站发布出去，这个网站只包含了一个名为“default.htm”的页面，如图 7 所示。
图 7 发布网站
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141723854.png)

好了，到现在为止，我们已经完成了整个仿真环境的模拟，不妨使用 client 来访问 HTTP服务器以验证它是否能正常工作。我们在客户端中打开“客户端信息”选项卡，左侧首先选择 HttpClient，然后在右侧的地址栏中输入“http://192.168.4.100/default.htm”。

可以看到当在地址栏中输入地址之后单击获取按钮时，就会显示一个“File download” 的文件保存对话框（见图 8），这就表示已经成功地打开了目标页面。这里需要注意的是，模拟的浏览器并没有 IE 或者 Firefox 那么强大的功能，它无法真正地从数据包中解析并显示网页的内容。

图 8 使用 client 来访问 HTTP 服务器
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141724042.png)

现在我们已经建立好了一个仿真网络，==它虽然简化了很多，但是运行原理和真实网络是完全一样的==。刚刚我们使用客户端的浏览器访问了 HTTP 服务器，这个过程一共只用了几秒（甚至更短）。但是在这个过程中都发生了什么呢，我们对此一无所知。那么现在我们就在 Wireshark 的帮助下来解读刚刚所经历的一切。

==在仿真网络中，我们可以使用 Wireshark 在任何一个节点查看数据包，这也是它的优势所在==。但是在实际工作中，我们是不可能做到这一点的。因此在这个示例中，我们仅考虑在图 8 的网络中的内部进行数据包的观察，实验过程如下所示。
（1）如图 9 所示，在 client 的端口上启动 Wireshark，在实际工作中，你可以选择使用TAP 来分流 client 的数据。
图 9 在 client 的端口上启动 Wireshark
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141725787.png)
（2）在 client 的客户端中输入“http://www.a.com/default.htm”，按下“获取”按钮，如图 10 所示。
图 10 浏览对应网页
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141725573.png)
（3）返回 Wireshark，查看捕获到的数据包，如图 11 所示。
图 11 在 Wireshark 中查看捕获到的数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141726780.png)
下面我们就以捕获到的数据包文件为例来详细地了解刚刚都发生了什么？按照最简单的思路来说，客户端会产生一个请求发送给服务器，然后服务器再将资源发回给客户端。
图 12 客户端与服务器的通信
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141727615.png)

不过实际的情形要远远比这复杂得多，该如何做才能将请求数据包发送到目标服务器呢？

首先我们需要明确的一点是在这个过程中客户端的工作是由“操作系统”和“应用程
序”两个部分共同完成的。而客户端上网的这个过程就是先从“操作系统”开始的。
（1）首先我们使用的客户端计算机位于一个局域网内部，它所有的通信要分为局域网内部通信和局域网外部通信两种。当我们在尝试使用浏览器去访问 HTTP 服务器候，第一个步骤就是要判断这个访问的服务器与我们所使用的主机是否在同一个局域网中。这个判断需要由操作系统完成，本例中我们要访问 HTTP 服务器的 IP 地址为192.168.4.100。

操作系统要先将自己的 IP 地址和子网掩码转换成二进制，然后进行“与”运算。例如当前主机的 IP 地址为 192.168.1.10，子网掩码为 255.255.255.0。计算的过程如表 1 所示。
表 1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141728898.png)

将转换为二进制的 11000000.10101000.00000001.00001010 与11111111.11111111.11111111.00000000 进行与运算之后，11000000.10101000.00000001.00000000 就是客户端所在的子网，转换成十进制就是 192.168.1.0。

同样的方法计算目标地址 192.168.4.100 所在的子网为 192.168.4.0，二者不在同一子网。因此这个访问的服务器与我们所使用的主机不在同一个局域网中。
（2）同一局域网的通信可以直接发送给目标，但是发往不同局域网的通信则要先交给网关。因为 HTTP 服务器位于局域网的外部，所以现在客户端计算机的第一个工作就是要找到网关。之前客户端的设置中已经将网关设置为“192.168.1.1”。在这次通信中所有的数据包都应该由这个网关转发。

但是在局域网内部是无法使用 IP 地址进行通信的，因为局域网中的交换机只能识别 MAC 地址。如果你仅仅告诉交换机 IP 地址，交换机是不能将其转发到网关的。所以现在我们需要一种可以将 IP 地址转换成 MAC 地址的机制，在网络协议中就提供了一个专门完成这个任务的协议：ARP。

ARP 是通过一个查找表（ARP 缓存）来执行这种转换的。当在 ARP 缓存中没有找到地址时，则向网络发送一个广播请求，网络上所有的主机和路由器都接收和处理这个 ARP 请求，但是只有相同 IP 地址的接收到广播请求的主机或路由器，发回一个 ARP 应答分组，应答中包含它的 IP 地址和物理地址，并保存在请求主机的 ARP 缓存中。其他主机或路由器都丢弃此分组。

（3）当我们成功地找到网络出口之后，接下来要做的就是客户端和服务器建立一个连接。这个连接也正是通过 TCP 协议的三次握手实现的。

（4）当连接成功建立之后，操作系统的工作就完成了，此时将会由应用程序来构造 HTTP 请求数据包。那么需要注意的是，TCP 3 次握手的最后一个数据包是由客户端的操作系统发出的，而 HTTP 请求数据包是由客户端上的应用程序所完成的。

一般情况下，操作系统在完成 TCP 操作时所消耗的时间可以忽略不计。但是应用程序在构造请求或者回应时却可能造成明显的延迟。在这个阶段，客户端所发送的 TCP 数据包和 HTTP 之间的间隔就是应用程序产生所花费的时间。

（5）当客户端上应用程序产生的请求发送出去之后，经过路径到达服务器之后，服务器会给出回应，这两个数据包之间的时间就是数据包传送的时间加上服务器上应用程序的响应时间。
## 1.3 时间显示设置
在对数据包进行分析的时候，时间是一个很重要的参考值。Wireshark 会根据系统的时钟来为捕获到的每个数据包加上一个时间戳。Wireshark 在保存文件的时候，也会将捕获数据包的时间保存起来。当你使用另外一台设备来打开这个文件的时候，Wireshark 会根据新设备所处的时区对时间进行调整。我们在分析一些 Wireshark 官方的数据包时，就会遇到这种情况。因为这些数据包往往是在美国产生的，而我们位于中国，看到数据包的时间会与当时捕获的时间有所不同。

我们平时使用的时间格式有两种，一种是常用的某年某月某日，称为绝对格式。另一种就是形如秒表上的显示，这个示数表示的是经过了多久，例如 2 分 21 秒，称为相对格式。

默认情况下，Wireshark 中提供了一个显示捕获数据包时刻的“Time”列（见图 13）。

这个列中显示的是相对值，捕获到第一个数据包的时间定义为零点，之后捕获到数据包的时间值都是距离这个零点的时间间隔，单位为微秒。
图 13 Wireshark 中的 Time 列
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141738022.png)

Wireshark 为了能够更好地对数据包进行分析，还提供了多种时间的显示方式。如果要修改这些显示方式的话，可以在菜单栏上依次单击“视图”→“时间显示格式”，Wireshark中提供的包括如图 14 所示的选项。
图 14 Wireshark 中的“时间显示格式”
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141738892.png)
默认情况下，Wireshark 使用的“自捕获开始经过秒数”，那么第一个捕获到数据包的时间值就是 0.000000，所有其他的数据包都是参照第一个数据包定的，这样就是显示了从捕获开始所经过的时间。我们也可以使用其他的格式，从 Wireshark 这个菜单中提供的名称上可以很清楚地了解到这些格式的意义。例如“自上一个捕获分组经过的秒数”就表示显示当前数据包和它前面时间数据包的间隔。而“自上一个显示分组经过的秒数”则表示在使用了显示过滤器的情况下，当前数据包和它前面数据包的间隔。

这个菜单的下半部分显示了时间的精度，默认为自动。这里我们同样可以对其进行调整，这些精度可以设置为秒、十分之一秒、百分之一秒、毫秒、微秒、纳秒等。大部分的设备都可以精确到毫秒级，但是如果要精确到纳秒级别的话，就需要考虑网卡是否支持。

如果使用一个不支持纳秒的设备捕获数据包的话，而我们又在这里设置了精度为纳秒的话，最后面的 3 位就会显示全部为 0。

只使用某一种时间格式的话不太容易看出数据包之间的关联，但是来回切换时间格式又过于烦琐。这时我们就可以选择在原有时间列的基础上再添加新的列，这个列用来显示当前包与前面包的时间间隔，具体的步骤如下。

（1）首先单击菜单栏上的“编辑”→“首选项”，或者直接单击工具栏上的“首选项”
按钮。
（2）然后在图 15 所示的首选项窗口左侧选择“外观”→“列”。
图 15 Wireshark 中的首选项![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141740724.png)


（3）这时首选项窗口的右侧就会显示出当前数据包列表中的全部列，点击左下方的“+”号就可以添加新的一列。

（4）这时在首选项窗口的右侧就会添加新的一行，这一行分成两个标题和类型两个部分，我们单击标题处为新添加的列起一个名字，这里我们为其起名为 tcp.time_delta。

（5）在类型下面的 Number 下拉列表框处，选中我们需要的列内容。其中和时间有关的选项如图 16 所示。
图 16 在 Wireshark 中添加新的一列
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141740723.png)
- “Absolute date, as YYYY-MM-DD, and time”：这个选项用来显示捕获设备所处时区的日期和时间，例如“2018-04-25 12:53:06.775724”。
- “Absolute date, as YYYY/DOY, and time”：这个选项同样是用来显示捕获设备所处时区的日期和时间。但是不显示月和日，而是一年中的第多少天。例如 2018 年 4 月 25 日就是这一年的第 115 天，按照这个格式显示就是“2018/115 12:53:06.775724”。
- Relative time：这个选项用来显示当前数据包距离捕获第一个数据包的时间间隔。
- Delta time：这个选项用来显示当前数据包距离上一个数据包的时间间隔。
- Delta time displayed：这个选项用来显示当前数据包距离上一个数据包（在使用了显示过滤的情况下）的时间间隔。
- Custom：虽然上面提供了很多可以使用的时间格式，但是我们可能还会需要进行一些自定义的操作。例如在计算同一个会话中这些数据包之间的时间间隔，这时前面的格式就无法满足这个需求了。于是 Wireshark 还提供了一个 Custom（自定义）功能。

如图 17 所示，我们在类型里选择使用 Custom 类型，在字段处输入“tcp.time_delta”， 最后在字段发生处添加一个“0”。
图 17 添加列的内容
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141740160.png)
（6）单击“OK”按钮即可将这个列添加到数据包列表面板中。

在数据包列表面板中已经多了一个名为“tcp.time_delta”的列，但是现在该列还不能正常工作。我们还需要完成如下的步骤。
（1）在 Wireshark 首选项窗口中依次选择“Protocols”→“TCP”。
（2）勾选“Calculate conversation timestamps”，默认这个选项是不被选中的（见图 18）。选中之后 Wireshark 会为 TCP 会话中的数据包再加上一个新的时间戳，用来表示该数据包在当前会话的产生时间。
图 18 勾选“Calculate conversation timestamps”
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141741270.png)
（3）单击“OK”按钮。这时再查看数据包列表面板就可以看到新的一列已经起作用了。

Wireshark 提供了这么多的时间格式，那么我们又该如何对它们进行选择呢？这个问题的答案其实很简单，首先我们需要明确 Wireshark 分析的目的是什么，然后才能确定要使用的时间格式。比如我们需要知道捕获数据包的具体日期和时间，或者需要找出与系统日志相关的数据包时，就可以采用“Absolute date, as YYYY-MM-DD, and time”这种绝对时间格式。

如果我们要研究在开始捕获之后的一段特定时间内发生的事件，就可以使用”“Relative time”这种相对时间格式。如果你希望对特定数据包（例如客户端和服务器之间的请求和应答）之间的时间间隔进行研究，“Delta time”这种时间格式则是很好的选择。

这里还必须提到一点，在默认情况下，Wireshark 会以捕获第一个数据包的时间作为原点。但是我们也可以自行将某一个数据包定义为原点，具体的方法是在一个数据包上单击鼠标右键，在弹出的菜单上选中“设置/取消设置时间参考”，此时这个数据包的时间列就会显示为“*REF*”。如果我们使用了相对时间格式的话，它之后的所有数据包都会将这个数据包的捕获时间作为原点。
## 7.4 各位置延迟时间的计算
在 7.3 节我们已经学习了 Wireshark 的时间设置，现在我们继续来了解远程上网这个实例。在整个上网过程中，一共可以分成 4 个阶段，但是由于其中的 ARP 阶段位于内网，而且速度非常快，因此通常不会引起网络延迟，这里只考虑后面的 3 个阶段，分别是网络传输延迟、客户端应用程序引起的延迟和服务器应用程序引起的延迟。需要注意的一点是，这种延迟分类的方法是基于 Wireshark 捕获数据包得出的。图 19 中显示了上网过程中捕获到的数据包。
图 19 上网过程中产生的数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141743944.png)

这 5 个数据包的含义如图 20 所示，其中①②③④⑤分别对应着图 19 中的第 9、10、11、12、13 这几个数据包。
图 20 客户机与服务器的通信过程
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141744668.png)

## 7.4.1 网络传输延迟的计算
当发生网络延迟时，我们首先需要考虑的就是传输线路导致的延迟。如图 21 所示，我们首先来查看捕获到的 TCP 3 次握手中的第 2 个数据包，
图 21 TCP 3 次握手中的第 2 个数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141744487.png)
它的 tcp.time_delta 值为 0.062，这个值是由 3 个时间共同组成的：
- 从客户端到服务端的时间；
- 服务端操作系统接收 TCP 3 次握手的 syn 请求，并回应一个（syn，ack）回应；
- 从服务端到客户端的时间。考虑操作系统在处理 TCP 握手时的时间很短，这个值可以看作是由第一个和第 3 个时间组成的，也就是数据包在线路上传输所花费的时间。如果这个值较大的话，则说明线路传输时出现了延时，这个原因可能是由服务端和客户端之间的设备造成的。
## 7.4.2 客户端延迟的计算
第 2 个网络延迟的位置就位于客户端，这是由于客户端上的应用程序造成的。我们平时所使用的浏览器就是一个典型的例子，当你使用浏览器打开了太多的窗口时，速度就会变得十分缓慢。另外，很多用来完成网络操作的客户端由于设计的缺陷也会消耗大量的时间。

这部分延迟时间的值可以通过查看第 12 个数据包的 time_delta 值得到。其中第 11 个数据包是由操作系统产生并发送出去的，这是因为客户端操作系统在处理 TCP 连接时的时间很短，例如图中这个值为 0（实验环境，实际情况中要比这大一些）。

在客户端操作系统向目标发送了 TCP 3 次握手的最后一次握手包之后，客户端的应用程序还会继续向目标发送一个 HTTP 请求。这个请求所花费的时间就是客户端延迟的时间（见图 22）。
图 22 客户端延迟的时间
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141745095.png)

## 7.4.3 服务端延迟的计算
如果排除了前面两个网络延迟的可能性，那么延迟的位置就只能位于服务器。由于我们现在的观察点位于客户端，所以并不能直接获得服务器产生 HTTP 回应的时间。我们可以观察第 12 个数据包（客户端发出的 HTTP 请求）和第 13 个数据包（服务端发出的 HTTP回应）之间的时间来计算这个时间。

如图 23 所示，这个 0.109 秒是由网络传输和服务端产生回应共同构成的，所以我们可以大致估计服务端用来生成回应的时间为 0.109−0.062=0.047。
图 23 服务端延迟的时间
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307141745363.png)

如果网络发生延迟的话，我们可以根据下面的方法来确定延迟发生的位置。
- 如果图 20 中的②处数据包的延时较大的话，则可以确定延迟发生在传输的路径上。
- 如果图 20 中的④处数据包的延时较大的话，则可以确定延迟发生在客户端处。
- 如果图 20 中的⑤处数据包的延时较大的话，则可以确定延迟发生在服务器处。
# 7.5 小结
延迟是我们在使用网络时经常会遇到的一个问题，本章就延迟位置的确定进行了简单讲解。考虑到大多数的学习者不可能拥有完整的网络实验环境，所以本章在一开始就给出了如何使用 Ensp 来构建了一个虚拟的仿真环境，其中包括了与真实环境完全相同的路由器和交换机等设备。接下来，我们介绍了 Wireshark 中的时间设置，这个功能在对网络中的延时进行分析时是相当有用的。最后给出了如何确定网络延时发生的位置的方法。通过本章的学习，读者可以掌握如何根据实际情况对 Wireshark 的时间显示进行设置。