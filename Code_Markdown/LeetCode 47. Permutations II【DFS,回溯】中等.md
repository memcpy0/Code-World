> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202310091713532.png)
相似题型
46.全排列

看到 全排列，或者 枚举全部解，等类似的 搜索枚举类型题，基本就是 回溯 没跑了。 因为回溯就是类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。

回溯主要的考虑的 三要素 已经在 46.全排列 写过了，但是这道题有了一点改变，那么就是列表里面有重复数字，全排列的结果，相同答案只算一种，那么我们就要优先考虑重复，再思考 三要素，定下我们思路和代码的基调。 【flag：上一篇写得有点乱，之后再去整理，顺便汇总回溯题，emmm 好像上一篇也有一个 flag（逃。。】

考虑重复
重复即为：存在相同数字，比如 [1,2,2']，那么答案 [1,2,2'] 和 [1,2',2] 就其实是一样的，在保存结果的时候，我们只选择其一，但是这不是字符串，在保存结果的时候再去判断是否答案里已经保存了这一种情况会比较麻烦，那么我们能不能在生成答案的过程中就将其 剪枝（类比用过的数字就不考虑），这样根本就不会生成重复的答案了。

我们希望的是，如果发现数字重复了，当前的就不考虑了，比如 [1,2,2'] 存在之后，当遇到 [1] 遇到 2'，发现和 2 重复了，我就直接剪枝，不考虑之后的所有的情况，因为：两个相同数字，我可以：

两个都选
两个都不选
但是如果只选一个，那么选哪一个都可以，因为和选择另一个是相同情况，所以只有这种情况我们需要剪枝
又到了小 trick 时间：
考虑重复元素一定要优先排序，将重复的都放在一起，便于找到重复元素和剪枝！！！ 推广至 --> 如果涉及考虑重复元素，或者大小比较的情况，对列表排序是一个不错的选择

好了，我们知道要排序，重复元素要剪枝，那么该如何剪枝呢？ 首先我们得使用第一个元素，因为这时候是第一次使用，还没有重复，并且所有情况都回溯搜索答案，除了用过的元素不再使用，其余不做剪枝，直到我们遇到第一个重复元素，我们才要考虑剪枝，但是考虑剪枝的时候还要考虑跟它重复的元素有没有被用过：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307061526513.png)



如果前一个重复元素没有使用过，那么在当前重复元素下一层的可选项中一定会存在，也就是绿色部分 那么一定会重复，即出现 2 X = X 2' 的情况（X 为不选） 也就是 2 和 2' 以及 2' 和 2 一定会重复，则整体剪枝，且是提前剪枝，在红色选择处就剪枝

那么这部分剪枝的条件即为：和前一个元素值相同（此处隐含这个元素的 index>0），并且前一个元素还没有被使用过

回溯问题三要素
把和 46.全排列 的区别--重复，考虑了之后，这道题就是和我们之前写过的思考过程一样了，依然是回到老三样：

有效结果 仍然是当前结果的长度==列表的长度，即为找到了一个有效结果
if len(sol) == len(nums):
            self.res.append(sol)
回溯范围及答案更新
仍然是全部遍历，因为每一层都要考虑全部元素
答案更新仍然是在修改 check 之后回溯内部累加更新 sol
for i in range(len(nums)):
    check[i] = 1
    self.backtrack(sol+[nums[i]], nums, check)
    check[i] = 0
剪枝条件 在之前的 剪枝条件 1：用过的元素不能再使用之外，又添加了一个新的剪枝条件，也就是我们考虑重复部分思考的结果，于是 剪枝条件 2：当当前元素和前一个元素值相同（此处隐含这个元素的 index>0 ），并且前一个元素还没有被使用过的时候，我们要剪枝
if check[i] == 1:
    continue
if i > 0 and nums[i] == nums[i-1] and check[i-1] == 0:
    continue
代码
考虑完三要素就可以写代码啦！

Python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        self.res = []
        check = [0 for i in range(len(nums))]
        
        self.backtrack([], nums, check)
        return self.res
        
    def backtrack(self, sol, nums, check):
        if len(sol) == len(nums):
            self.res.append(sol)
            return
        
        for i in range(len(nums)):
            if check[i] == 1:
                continue
            if i > 0 and nums[i] == nums[i-1] and check[i-1] == 0:
                continue
            check[i] = 1
            self.backtrack(sol+[nums[i]], nums, check)
            check[i] = 0


附：两种不同剪枝条件的区别
在考虑重复及剪枝条件的时候，我们考虑的是：当当前元素和前一个元素值相同（此处隐含这个元素的 index>0），并且前一个元素还没有被使用过的时候，我们要剪枝 但实际，如果条件设为：并且前一个元素被使用过，我们要剪枝，其实也是可以的：

if i > 0 and nums[i] == nums[i-1] and check[i-1] == 1:
    continue
但是这两种有什么区别，又该如何选择呢？ 主要的区别还是在于在那个阶段剪枝，以及重复元素中选择哪一个。 结论：选择 check[i-1] == 0 效率要高于 check[i-1] == 1

看了很多解释，但是还是一定要自己画图理解！回溯的图真的是天助，画图能很好理解递归：

1. if i > 0 and nums[i] == nums[i-1] and check[i-1] == 0
灰色为剪枝部分，蓝色为答案部分：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307061528088.png)

2. if i > 0 and nums[i] == nums[i-1] and check[i-1] == 1
灰色为剪枝部分，蓝色为答案部分：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307061528313.png)

能够明显发现第一种能够提前剪枝，减少计算步骤和搜索次数，并且第一种选择了重复元素的第一个，而**第二种选择了重复元素的最后一个**，虽然答案都相同，我们成年人当然是要选效率更高一些的那一种对吧~

作者：sammy
链接：https://leetcode.cn/problems/permutations-ii/solutions/71776/hot-100-47quan-pai-lie-ii-python3-hui-su-kao-lu-zh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。