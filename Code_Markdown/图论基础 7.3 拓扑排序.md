## 原理　拓扑排序
一个无环的有向图被称为有向无环图（Directed Acycline Graph，DAG）。**有向无环图**是描述一个工程、计划、生产、系统等流程的有效工具。一个大工程可分为若干子工程（活动），活动之间通常有一定的约束，例如先做什么活动，在什么活动完成后才可以开始下一个活动。

**用节点表示活动，用弧表示活动之间的优先关系的有向图**，被称为AOV网（Activity On Vertex Network）。在AOV网中，若从节点i到节点j存在一条有向路径，则称节点i是节点j的前驱，或者称节点j是节点i的后继。若<i,j>是图中的弧，则称节点i是节点j的直接前驱，节点j是节点i的直接后继。

AOV网中的弧表示了活动之间存在的制约关系。例如，计算机专业的学生必须完成一系列规定的基础课和专业课才能毕业。学生按照怎样的顺序来学习这些课程呢？这个问题可以被看成一个大的工程，其活动就是学习每一门课程。课程的名称与相应编号如下表所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131420888.png)
如果用节点表示课程，用弧表示先修关系，若课程i是课程j的先修课程，则用弧<i,j>表示，课程之间的关系如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131420867.png)

在AOV网中是不允许有环的，否则会出现自己是自己的前驱的情况，陷入死循环。怎么判断在AOV网中是否**有环**呢？一种检测的办法是**对有向图中的节点进行拓扑排序。如果AOV网中的所有节点都在拓扑序列中，则在AOV网中必定无环**。

拓扑排序指将AOV网中的节点排成一个线性序列，该序列必须满足：==若从节点i到节点j有一条路径，则在该序列中节点i一定在节点j之前==。

拓扑排序的基本思想：
①选择一个无前驱的节点并输出；
②从图中删除该节点和该节点的所有发出边；
③重复步骤1、2，直到不存在无前驱的节点；
④**如果输出的节点数少于AOV网中的节点数，则说明网中有环**，否则输出的序列即拓扑序列。

拓扑排序并不是唯一的，例如在上图中，节点C0和C5都无前驱，先输出哪一个都可以，如果先输出C0，则删除C0及C0的所有发出边。此时C2和C5都无前驱，如果输出C5，则删除C5及C5的所有发出边。此时C2和C3都无前驱，如果输出C3，则删除C3及C3的所有发出边。此时C2无前驱，如果输出C2，则删除C2及C2的所有发出边。此时C1和C4都无前驱，将其输出并删除即可。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131553820.png)
拓扑序列为C0、C5、C3、C2、C1、C4。

在上述描述过程中有删除节点和边的操作，实际上，没必要真的删除节点和边。可以将没有前驱的节点（入度为0）暂存到栈中，**输出时出栈即表示删除**。进行边的删除时将其邻接点的入度减1即可。例如在下图中删除C0的所有发出边，相当于将C3、C2、C1节点的入度减1。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131553958.png)
### 1. 算法步骤
（1）求各节点的入度，将其存入数组indegree[]中，并将入度为0的节点入栈S。
（2）如果栈不空，则重复执行以下操作：
①将栈顶元素i出栈并保存到拓扑序列数组topo[]中；
②将节点i的所有邻接点入度都减1，如果减1后入度为0，则立即入栈S。（3）如果输出的节点数少于AOV网中的节点数，则说明网中有环，否则输出拓扑序列。
### 2. 完美图解
例如，一个AOV网如下图所示，其拓扑排序的过程如下。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131554099.png)
（1）输入边时累加节点的入度并保存到数组indegree[]中，将入度为0的节点入栈S。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131554608.png)
（2）将栈顶元素5出栈并保存到拓扑序列数组topo[]中。将节点5的所有邻接点（C3、C4）入度都减1，如果减1后入度为0，则立即入栈S。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131554276.png)
（3）将栈顶元素0出栈并保存到拓扑序列数组topo[]中。将节点0的所有邻接点（C1、C2、C3）入度都减1，如果减1后入度为0，则立即入栈S。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131554302.png)
（4）将栈顶元素3出栈并保存到拓扑序列数组topo[]中。将节点3的邻接点C4入度减1，如果减1后入度为0，则立即入栈S。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131555927.png)
（5）将栈顶元素2出栈并保存到拓扑序列数组topo[]中。将节点2的所有邻接点（C1、C4）入度减1，如果减1后入度为0，则立即入栈S。节点1没有邻接点，什么也不做。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131555557.png)
（6）将栈顶元素4出栈并保存到拓扑序列数组topo[]中。节点4没有邻接点。
（7）将栈顶元素1出栈并保存到拓扑序列数组topo[]中。节点1没有邻接点。
（8）栈空，算法停止。输出拓扑排序序列。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306131555382.png)

### 3. 算法实现
```cpp
bool TopoSort() { // 拓扑排序
    int cnt = 0;
    for (int i = 0; i < n; ++i)
        if (indegree[i] == 0)
            s.push(i);
    while (!s.empty()) {
        int u = s.top();
        s.pop();
        topo[cnt++] = u;
        for (int j = 0; j < n; ++j)
            if (map[u][j]) 
                if (--indgree[j] == 0) s.push(j);
    }
    if (cnt < n) return 0;
    return 1;
}
```
### 4. 算法分析
时间复杂度：度数为0的节点入栈的时间复杂度为O(n)，在每个节点出栈后都需要将其邻接点入度减1，如果使用邻接矩阵存储，则每次访问邻接点的时间复杂度都为O(n)，总的时间复杂度为 $O(n^2)$ 。采用邻接表或链式前向星存储访问一个节点的所有邻接点，访问次数为该节点的度，总的时间复杂度为O(e)。

空间复杂度：辅助空间包括入度数组indegree[]、拓扑序列数组topo[]、栈S，算法的空间复杂度是O(n)。
## 训练1　家族树题目描述（POJ2367）
火星人的血缘关系制度令人困惑。在火星行星理事会中，令人困惑的家谱系统导致了一些尴尬：为了在所有讨论中不冒犯任何人，老火星人先发言，而不是年轻人或最年轻的无子女人员。但是，维护这个命令不是一项微不足道的任务，火星人并不总是知道其父母和祖父母是谁，如果一个孙子先发言而不是其年轻的曾祖父先发言，则会出现错误。编写程序，保证理事会的每个成员都早于其每个后代发言。

输入：第1行包含整数N（1≤N≤100），表示火星行星理事会的成员数。成员编号为1～N。接下来的N行，第i行包含第i个成员的孩子名单。孩子的名单可能是空的，名单以0结尾。输出：单行输出一系列发言者的编号，用空格分隔。如果有几个序列满足条件，则输出任意一个，至少存在一个这样的序列。[插图]题解：根据输入样例，构建的图形结构如下图所示，其拓扑序列为2 4 5 31。本题属于简单的拓扑排序问题，输出拓扑序列即可。[插图]算法代码：[插图][插图]训练2　全排序题目描述（POJ1094）：不同值的升序排序序列是使用某种形式的小于运算符从小到大排序的元素序列。例如，排序后的序列ABCD表示A<B、B<C和C<D。给定一组A<B形式的关系，要求确定是否指定已排序的订单。输入：输入包含多个测试用例。每个测试用例的第1行都包含两个正整数n（2≤n≤26）和m。n表示

要排序的对象数量，排序的对象是大写字母的前n个字符。m表示将给出的A<B形式的关系的数量。接下来的m行，每行都包含一种由3个字符组成的关系：第1个大写字母、字符“<”和第2个大写字母。n=m=0的值表示输入结束。输出：对于每个问题实例，其输出都由一行组成，该行应该是以下三种之一。• 在x种关系之后确定的排序顺序：yyy…y。• 无法确定排序顺序。• 在x种关系后发现不一致。其中，x是在确定排序序列或找到不一致时处理的关系数，以先到者为准，yyy…y是已排序的升序序列。[插图]题解：在本题中，一边进行输入，一边进行判断，分为有序、无序（不一致）、无法确定三种情况，可以利用拓扑排序进行判断。1. 算法设计（1）如果入度为0的节点个数为0，则说明有环；如果拓扑序列节点数小于n，则也说明有环。此情况即无序。（2）如果入度为0的节点个数大于1，则无法确定，因为拓扑序列不唯一。（3）否则是拓扑有序的，输出拓扑序列。特别注意：①得到判断结果后不能break，需要继续输入，否则下一个测试用例会读入本次输入的剩余数据；②在数据输入完毕后才能判断是不是无法确定。2. 算法实现[插图][插图]训练3　标签球题目描述（POJ3

687）：有N个不同重量的球，重量为1～N个单位。对球从1到N进行标记，使得：①没有两个球具有相同的标签；②标签满足几个约束，例如“标签为a的球比标签为b的球轻”。输入：第1行包含测试用例的数量。每个测试用例的第1行都包含两个整数N（1≤N≤200）和M（0≤M≤40000），分别表示球的数量和约束的数量。后面的M行，每行都包含两个整数a和b，表示标签为a的球比标签为b的球轻（1≤a,b≤N）。在每个测试用例前都有一个空行。输出：对于每个测试用例，都单行输出标签1～N的球的重量。如果存在多种解决方案，则输出标签为1的球的最小重量，然后输出标签为2的球的最小重量，以此类推……如果不存在解，则输出-1。[插图]题解：本题不是输出小球的标签，而是按标签输出小球的重量，而且标签小的球的重量尽可能小。例如，输入以下数据，构建的图形结构如下图所示。[插图][插图]分析：根据重量关系，节点3是最重的，因此令重量weight[3]=5；节点1和节点2比节点3轻，因为每个球的重量都不同，按照标签小的球重量小的原则，先给标签大的球分配重量，先处理节点2，因此weight[2]=4；节点4比节点2轻，weight[4]=3；

节点1比节点3轻，weight[1]=2；节点5比节点1轻，weight[5]=1。按照标签1～5输出其重量：2 4 5 3 1。例如，输入以下数据，构建的图形结构如下图所示。[插图][插图]分析：按照标签小的球重量小的原则，先给标签大的球分配重量：weight[10]=10；weight[9]=9；weight[6]=8；weight[5]=7；weight[3]=6；weight[1]=5。节点8和节点4比节点1轻，按照标签小的球重量小的原则，先给标签大的球分配重量，先处理节点8，因此weight[8]=4；节点7和节点2比节点8轻，先处理节点7，weight[7]=3；现在只剩下节点4和节点2，weight[4]=2；weight[2]=1。按照标签1～10输出其重量：5 1 6 2 7 8 3 4 9 10。注意：本题有重复边，需要去重，否则会有环，最后输出-1。1. 算法设计可以采用下面两种方法解决。（1）建立正向图。i=n...1，j=n...1，检查第1个出度为0的点t，分配重量w[t]=i，将弧尾节点的出度减1，继续下一个循环。若没有出度为0的节点，则说明有环，退出。（2）建立原图

的逆向图。i=n...1，j=n...1，检查第1个入度为0的节点t，分配重量w[t]=i，将其邻接点的入度减1，继续下一个循环。若没有入度为0的节点，则说明有环，退出。2. 算法实现[插图][插图]训练4　秩序题目描述（POJ1270）：给定x<y形式的变量约束列表，编写程序，输出与约束一致的变量的所有顺序。例如，给定约束x<y和x<z，变量x、y和z的两个排序与这些约束一致：xyz和xzy。输入：输入由一系列约束规范组成。每个约束规范都由两行组成：一行为变量列表，后面一行为约束列表。约束由一对变量给出，其中xy表示x<y。所有变量都是单个小写字母。在约束规范中至少有两个且不超过20个变量，至少有一个且不超过50个约束，至少有一个且不超过300个与约束规范中的约束条件一致的顺序。输出：对每个约束规范，都以字典顺序单行输出与约束一致的所有排序。不同约束规范的输出以空行分隔。[插图]题解：根据输入样例1，构建的图形结构如下图所示。[插图]本题需要按照字典序输出所有拓扑序列，因此使用回溯法搜索所有拓扑序列。注意，到达叶子时输出，回溯时需要还原现场。1. 算法设计（1）将变量列表的字符转换为数字并统计出现次数，累计

变量列表的长度。（2）将每对约束都转换为数字，用邻接矩阵存储并统计入度。（3）以回溯法求解所有拓扑序列并输出。3. 算法实现[插图][插图]
