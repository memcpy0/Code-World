> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个正整数数组 `nums` 。每一次操作中，你可以从 `nums` 中选择 任意 一个数并将它减小到 **恰好** 一半。（注意，在后续操作中你可以对减半过的数继续执行操作）

请你返回将 `nums` 数组和 **至少** 减少一半的 **最少** 操作数。

**示例 1：**
```java
输入：nums = [5,19,8,1]
输出：3
解释：初始 nums 的和为 5 + 19 + 8 + 1 = 33 。
以下是将数组和减少至少一半的一种方法：
选择数字 19 并减小为 9.5 。
选择数字 9.5 并减小为 4.75 。
选择数字 8 并减小为 4 。
最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。
nums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 >= 33/2 = 16.5 。
我们需要 3 个操作实现题目要求，所以返回 3 。
可以证明，无法通过少于 3 个操作使数组和减少至少一半。
```
**示例 2：**
```java
输入：nums = [3,8,20]
输出：3
解释：初始 nums 的和为 3 + 8 + 20 = 31 。
以下是将数组和减少至少一半的一种方法：
选择数字 20 并减小为 10 。
选择数字 10 并减小为 5 。
选择数字 3 并减小为 1.5 。
最终数组为 [1.5, 8, 5] ，和为 1.5 + 8 + 5 = 14.5 。
nums 的和减小了 31 - 14.5 = 16.5 ，减小的部分超过了初始数组和的一半， 16.5 >= 31/2 = 16.5 。
我们需要 3 个操作实现题目要求，所以返回 3 。
可以证明，无法通过少于 3 个操作使数组和减少至少一半。
```
**提示：**
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^7`

---
### 解法 贪心+最大堆
基于贪心的思想，将数组和减半的操作次数最小化的做法是：**每次操作都选择对当前数组的最大值进行减半操作**。
> 证明：假设存在某一种做法的操作次数最小，它的某一步没有选择对最大值 $x$ 进行操作，而是选择对 $y$ 进行操作。那么有两种情况：
> 1. 后续的操作都没有对 $x$ 进行操作。此时如果我们将后续（包括当前操作）所有对 $y$ 的操作替换为对 $x$ 的操作，操作次数不会变大。
> 2. 后续的某一步操作选择了对 $x$ 进行操作，那么我们可以交换这两步操作，操作次数不变。

第一个实现方法是，将数组所有元素都放入一个浮点数最大堆中，使用 $sum$ 记录最初的数组和，$reduce$ 记录减少的和，当 $reduce \times 2 < sum$ 时，重复如下步骤：
1. 从优先队列中取出最大元素 $x$ ；
2. 令 $reduce += \dfrac{x}{2}$ ；
3. 将 $\dfrac{x}{2}$ 放入优先队列中。

返回执行步骤次数即可。

下面使用浮点数+C++的优先队列类：
```c++
class Solution {
public:
    int halveArray(vector<int>& nums) {
        priority_queue<double> pq;
        double sum = 0, reduce = 0;
        int ans = 0;
        for (auto v : nums) {
            sum += v;
            pq.push(v);
        }
        while (reduce * 2 < sum) {
            double v = pq.top(); pq.pop();
            reduce += 1.0 * v / 2;
            ++ans;
            pq.push(1.0 * v / 2);
        }
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(n\log n)$ ，其中 $n$ 是数组 $nums$ 的长度。**将数组和减半最多不超过 $n$ 次操作**，每次操作需要 $O(\log n)$ 。
- 空间复杂度：$O(n)$ ，保存优先队列需要 $O(n)$ 空间。

~~[这篇文章](https://blog.csdn.net/weixin_61857742/article/details/127776538)说明了C++的 `make_heap, push_heap, pop_heap, sort_heap` 四个函数的用法。使用这四个函数，似乎可以不用额外空间。但是，在使用这些函数之前，需要注意到，最大堆中存储的是浮点数，而 `make_heap` 是在原来的数组上进行操作~~。

如果本着能不用浮点数就不用的想法（浮点数计算有误差，有[精度问题](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6766)），==将每个数乘上一个 $2$ 的幂次，比如 $2^{20}$ ，因为可以证明每个数除以 $2$ 的次数不会超过 $20$ ==，这样就可以用整数+优先队列来模拟了，但要使用 `long long` 类型。
> **证明**：如果最优解中最大的数 $x$ 被减半了 $t$ 次，那么考虑缩小它之前的时刻，所有数都不超过 $\dfrac{ x } { 2^{t - 1}}$ ，总和 $\le n \times \dfrac{x}{2^{t - 1}}$ 。原始和的一半至少为 $\dfrac{x}{2}$ ，所以有 $n \times \dfrac{x}{2^{t - 1}} > \dfrac{x}{2}$ ，即 $t < \log n+ 2 < 19$ 。这样就可以用 `long long` 代替 `double` 了。
```cpp
class Solution {
public:
    int halveArray(vector<int>& nums) {
        priority_queue<long long> pq;
        int ans = 0;
        long long half = 0;
        for (int num : nums) pq.push((long long) num << 19), half += ((long long) num << 18);
        while (half > 0) {
            long long x = pq.top() >> 1; pq.pop();
            half -= x;
            pq.push(x);
            ++ans;
        }
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(n\log⁡n)$ 。
- 空间复杂度：$O(n)$ 。

---
### 解法2 中位数+分治
我们倒推，减半的操作肯定是每次取当前数组中的最大值、进行减半、原地更新数组，直到达到要求为止。那么，**最后一次减半操作对应的数是固定的**，这里就用类似二分查找+分治的方式来找到这个数……

找到这个数的做法是：在当前范围（初始范围是整个数组）内，取中位数 $mid$ ，然后假设它就是最后一次减半操作对应的数，进行计算。
- 尝试对 $\ge mid$ 的数进行减半，同时令总和 $s$ 减少对应的值。==如果「当前减少后的总和」大于等于原总和的一半，则说明 $mid$ 以及大于 $mid$ 的数，都应该不断减半到小于 $mid$ 为止==，进行此操作，更新数组，**但保持当前范围不变，然后再继续**。
- 否则，说明最后一次减半操作的数肯定 $\ge mid$ ， 那当前比 $mid$ 小的数都没有用了，可以缩小当前取数范围，再继续。

2, 4, 6, 8
在处理时，取数范围的缩小，是用快速排序中的操作实现的，将中位数mid放到正确的位置，小于等于它的放左边，大于它的放右边，然后缩小要处理的下标范围即可。


一共只会进行至多 $n$ 次减半操作。按照中位数分治，每轮花费 $O(n)$ 时间，要么把 $n$ 减少一半，每轮花费 O(n)O(n)O(n) 的时间，要么把 nnn 减小一半，要么进行 n/2n/2n/2 次减半操作。递归式为 T(n,m)≤max⁡{T(n/2,m),T(n,m−n/2)}+O(n)T(n,m)\leq \max\{T(n/2,m),T(n,m-n/2)\}+O(n)T(n,m)≤max{T(n/2,m),T(n,m−n/2)}+O(n)，其中 mmm 为剩余减半次数的上界。解得 T(n,m)=O(n+m)T(n,m)=O(n+m)T(n,m)=O(n+m)。


用中位数分治思想可以 O(n)O(n)O(n) 时间解决的类似题目： 1648. 销售价值减少的颜色球 1833. 雪糕的最大数量 2141. 同时运行 N 台电脑的最长时间 2187. 完成旅途的最少时间

看不太懂，这个跟前段时间的 [2126. 摧毁小行星](https://leetcode-cn.com/problems/destroying-asteroids/) 有相似之处吗？

0

隐藏回复

回复

[![](https://assets.leetcode.cn/aliyun-lc-upload/users/hqztrue/avatar_1605404429.png)](https://leetcode.cn/u/hqztrue/)

[hqztrue](https://leetcode.cn/u/hqztrue/)L5

发布于 美国

2022.03.20

[@梁震甲](https://leetcode.cn/u/zhenliang153) 我这个题解不太一样，更像快排，和 [2187. 完成旅途的最少时间](https://leetcode-cn.com/problems/minimum-time-to-complete-trips/solution/on-by-hqztrue-cd8n/) 是一个套路。用小行星那个题分log n个桶的思想也是能做的，但是桶里还要套一次中位数分治，代码会长一点。