图通常以一个二元组 G=<V, E>表示，V表示节点集，E表示边集。|V|表示节点集中元素的个数，即节点数，也被称为图G的阶，例如在n阶图中有n个节点。|E|表示边集中元素的个数，即边数。

若图G中的每条边都是没有方向的，则称之为无向图；若图G中的每条边都是有方向的，则称之为有向图。

在无向图中，每条边都是由两个节点组成的无序对，例如节点v1和节点v3之间的边，记为(v1,v3)或(v3,v1)。在有向图中，有向边也被称为弧，每条弧都是由两个节点组成的有序对，例如从节点v1到节点v3的弧，记为<v1,v3>，v1被称为弧尾，v3被称为弧头，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111304381.png)

节点的度指与该节点相关联的边数，记为TD(v)。握手定理：所有节点的度数之和等于边数的两倍，即
$$\sum^n_{i=1} TD(v_i) = 2e$$

其中，n为节点数，e为边数。如果在计算度数之和时，每计算一度就画一条小短线，则可以看出每条边都被计算了两次，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111304059.png)
在有向图中，节点的度又被分为入度和出度。节点v的入度是以节点v为终点的有向边的数量，记为ID(v)，即进来的边数。节点v的出度是以节点v为始点的有向边的数量，记为OD(v)，即发出的边数。节点v的度等于入度加上出度。所有节点的入度之和等于出度之和，又因为所有节点的度数之和等于边的2倍，因此：
$$\sum^n_{i=1}\texttt{ID}(v_i) = \sum^n_{i=1} \texttt{OD}(v_i)= e$$

---
# 6.1 图的存储
图的结构比较复杂，任何两个节点之间都可能有关系。图的存储分为顺序存储和链式存储。顺序存储包括邻接矩阵和边集数组，链式存储包括邻接表、链式前向星、十字链表和邻接多重表。
## 6.1.1 邻接矩阵
邻接矩阵通常采用一个一维数组存储图中节点的信息，采用一个二维数组存储图中节点之间的邻接关系。
### 1. 邻接矩阵的表示方法
无向图、有向图和网的邻接矩阵的表示方法如下所述。
#### 1）无向图的邻接矩阵
在无向图中，若从节点vi到节点vj有边，则邻接矩阵 $M[i][j]=M[j][i]=1$ ，否则 $M[i][j]=0$ 。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111755412.png)

例如，一个无向图的节点信息和邻接矩阵如下图所示。在该无向图中，从节点a到节点b有边，从节点b到节点a也有边，节点a、b在一维数组中的存储位置分别为0、1，则 $M[0][1]=M[1][0]=1$ 。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111755704.png)
无向图的邻接矩阵的特点如下。
（1）无向图的邻接矩阵是对称矩阵，并且是唯一的。
（2）第i行或第i列非零元素的个数正好是第i个节点的度。上图中的邻接矩阵，第3列非零元素的个数为2，说明第3个节点c的度为2。
### 2）有向图的邻接矩阵
在有向图中，若从节点vi到节点vj有边，则邻接矩阵 $M[i][j]=1$ ，否则 $M[i][j]=0$ 。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111758093.png)
 注意：以尖括号<vi,vj>表示的是有序对，以圆括号(vi,vj)表示的是无序对，后同。
 
例如，一个有向图的节点信息和邻接矩阵如下图所示。在该有向图中，从节点a到节点b有边，节点a、b在一维数组中的存储位置分别为0、1，因此M[0][1]=1。有向图中的边是有向边，从节点a到节点b有边，从节点b到节点a不一定有边，因此有向图的邻接矩阵不一定是对称的。
 ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111758004.png)
有向图的邻接矩阵的特点如下。
（1）有向图的邻接矩阵不一定是对称的。
（2）第i行非零元素的个数正好是第i个节点的出度，第i列非零元素的个数正好是第i个节点的入度。上图中的邻接矩阵，第3行非零元素的个数为2，第3列非零元素的个数也为2，说明第3个节点c的出度和入度均为2。
### 3）网的邻接矩阵
**网是带权图，需要存储边的权值**，则邻接矩阵表示为
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111759516.png)

其中，wij表示边上的权值，∞表示无穷大。当i=j时，**wii也可被设置为0**。

例如，一个网的节点信息和邻接矩阵如下图所示。在该网中，从节点a到节点b有边，且该边的权值为2，节点a、b在一维数组中的存储位置分别为0、1，因此 $M[0][1]=2$ 。从节点b到节点a没有边，因此 $M[1][0]=∞$ 。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111803170.png)

### 2. 邻接矩阵的数据结构
定义首先定义邻接矩阵的数据结构，如下图所示。
```cpp
#define MaxVnum 100 // 节点数的最大值
typedef char VexType; // 节点的数据类型，根据需要定义
typedef int EdgeType; // 边上权值的数据类型，若为不带权值的图，则为0或1

typedef struct {
    VexType Vex[MaxVnum];
    EdgeType Edge[MaxVnum][MaxVnum];
    int vexnum, edegnum; // 节点数,边数
} AMGraph;
```
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111809506.png)

### 3. 邻接矩阵的存储方法
算法步骤：
（1）输入节点数和边数；
（2）依次输入节点信息，将其存储到节点数组 $Vex[]$ 中；
（3）初始化邻接矩阵，如果是图，则将其初始化为0；如果是网，则将其初始化为∞；
（4）依次输入每条边依附的两个节点，
- 如果是网，则还需要输入该边的权值。
- 如果是无向图，则输入ab，查询节点a、b在节点数组Vex[]中的存储下标i、j，令 $Edge[i][j]=Edge[j][i]=1$ 。
- 如果是有向图，则输入ab，查询节点a、b在节点数组Vex[]中的存储下标i、j，令 $Edge[i][j]=1$ 。
- 如果是无向网，则输入a b w，查询节点a、b在节点数组Vex[]中的存储下标i、j，令 $Edge[i][j]=Edge[j][i]  = w$。
- 如果是有向网，则输入a b w，查询节点a、b在节点数组Vex[]中的存储下标i、j，令 $Edge[i][j]=w$ 。

完美图解：一个无向图如下图所示，其邻接矩阵的存储过程如下所述。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111809994.png)
（1）输入节点数和边数。
```cpp
4 5
```
结果：G.vexnum=4、G.edgenum=5。
（2）输入节点信息，将其存入节点信息数组。
```cpp
a b c d 
```
存储结果如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111810132.png)

（3）初始化邻接矩阵的值均为0，如下图所示。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111810513.png)
（4）依次输入每条边依附的两个节点。
- 输入a b，处理结果：在Vex[]数组中查找到节点a、b的下标分别为0、1，是无向图，因此令 $Edge[0][1]=Edge[1][0]=1$ ，如下图所示。
   ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111810243.png)
- 输入a d，处理结果：在Vex[]数组中查找到节点a、d的下标分别为0、3，是无向图，因此令 $Edge[0][3]= Edge[3][0]=1$ ，如下图所示。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111811042.png)
- 输入b c，处理结果：在Vex[]数组中查找到节点b、c的下标分别为1、2，是无向图，因此令 $Edge[1][2]= Edge[2][1]=1$ ，如下图所示。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111812841.png)
- 输入b d，处理结果：在Vex[]数组中查找到节点b、d的下标分别为1、3，是无向图，因此令 $Edge[1][3]= Edge[3][1]=1$ ，如下图所示。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111812415.png)
- 输入c d，处理结果：在Vex[]数组中查找到节点c、d的下标分别为2、3，是无向图，因此令 $Edge[2][3]= Edge[3][2]=1$ ，如下图所示。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111813531.png)

在实际应用中，也可以先输入节点信息并将其存入数组Vex[]。在输入边时直接输入节点的存储下标序号，这样可以节省查询节点下标所需的时间，从而提高效率。算法代码：
```cpp
void CreateAMGraph(AMGraph &G) {
    int i, j;
    VexType u, v;
    cout << "输入节点数：" << endl;
    cin >> G.vexnum;
    cout << "输入边数：" << endl;
    cin >> G.edgenum;
    cout << "输入节点信息：" << endl;
    for (int i = 0; i < G.vexnum; ++i) // 输入节点信息，将其存入节点信息数组
        cin >> G.Vex[i];
    for (int i = 0; i < G.vexnum; ++i) // 初始化邻接矩阵所有值为0，如果是网则初始化邻接矩阵为无穷大
        for (int j = 0; j < G.vexnum; ++j)
            G.Edge[i][j] = 0;
    cout << "输入每条边依附的两个节点：" << endl;
    while (G.edgenum--) {
        cin >> u >> v;
        i = locatevex(G, u); // 查找节点u的存储下标
        j = locatevex(G, v); // 查找节点v的存储下标
        if (i != -1 && j != -1) 
            G.Edge[i][j] = G.Edge[j][i] = 1; // 将邻接矩阵设置为1
    }
}
```
### 4. 邻接矩阵的优缺点
（1）优点如下。
- 快速判断在两节点之间是否有边。在图中，$Edge[i][j]=1$ ，表示有边；$Edge[i][j] = 0$ ，表示无边。**在网中，$Edge[i][j]=∞$ ，表示无边，否则表示有边**。时间复杂度为O(1)。
- 方便计算各节点的度。在无向图中，邻接矩阵第i行元素之和就是节点i的度；在有向图中，第i行元素之和就是节点i的出度，第i列元素之和就是节点i的入度。时间复杂度为O(n)。

（2）缺点如下。
- 不便于增删节点。增删节点时，需要改变邻接矩阵的大小，效率较低。•
- 不便于访问所有邻接点。访问第i个节点的所有邻接点时，需要访问第i行的所有元素，时间复杂度为O(n)。访问所有节点的邻接点，时间复杂度为 $O(n^2)$ 。
- 空间复杂度高，为 $O(n^2)$ 。

在实际应用中，如果在一个程序中只用到一个图，就可以用一个二维数组表示邻接矩阵，直接输入节点的下标，省去节点信息查询步骤。有时**如果图无变化**，则为了方便，可以省去输入操作，直接在程序头部定义邻接矩阵。例如，可以直接定义图的邻接矩阵如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111820350.png)

## 6.1.2 边集数组
边集数组通过数组存储每条边的起点和终点，如果是网，则增加一个权值域。网的边集数组数据结构定义如下：
```cpp
struct Edge {
    int u, v, w;
} e[N * N];
```
采用边集数组计算节点的度或查找边时，要遍历整个边集数组，时间复杂度为O(e)。**除非特殊需要，很少使用边集数组**，例如求解最小生成树kruskal算法时需要按权值对边进行排序，使用边集数组更方便。
## 6.1.3　邻接表
邻接表是图的一种链式存储方法，其数据结构包括两部分：节点和邻接点。
### 1. 邻接表的表示方法
#### 1）无向图的邻接表
例如，一个无向图及其邻接表如下图所示。一个节点的所有邻接点构成一个单链表。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111923274.png)

解释：
- 节点a的邻接点是节点b、d，其邻接点的存储下标为1、3，按照头插法（逆序）将其放入节点a后面的单链表中；
- 节点b的邻接点是节点a、c、d，其邻接点的存储下标为0、2、3，将其放入节点b后面的单链表中；
- 节点c的邻接点是节点b、d，其邻接点的存储下标为1、3，将其放入节点c后面的单链表中；
- 节点d的邻接点是节点a、b、c，其邻接点的存储下标为0、1、2，将其放入节点d后面的单链表中。

无向图邻接表的特点如下。
- 如果无向图有n个节点、e条边，则节点表有n个节点，邻接点表有2e个节点。
- 节点的度为该节点后面单链表中的节点数。

在上图中，节点数n=4，边数e=5，则在该图的邻接表中，节点表有4个节点，邻接点表有10个节点。节点a的度为2，其后面单链表中的节点数为2；节点b的度为3，其后面单链表中的节点数为3。

#### 2）有向图的邻接表（出弧）
例如，一个有向图及其邻接表如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111926443.png)

解释：
- 节点a的邻接点（只看出边，即出弧）是节点b、c、e，其邻接点的存储下标为1、2、4，按照**头插法（逆序）**将其放入节点a后面的单链表中；
- 节点b的邻接点是节点c，其邻接点的存储下标为2，将其放入节点b后面的单链表中；
- 节点c的邻接点是节点d、e，其邻接点的存储下标为3、4，按头插法将其放入节点c后面的单链表中；
- 节点d的邻接点是节点e，其邻接点的存储下标为4，将其放入节点d后面的单链表中；
- 节点e没有邻接点，其后面的单链表为空。

注意：对有向图中节点的邻接点，只看该节点的出边（出弧）。有向图的邻接表的特点如下。
- 如果有向图有n个节点、e条边，则节点表有n个节点，邻接点表有e个节点。
- 节点的出度为该节点后面单链表中的节点数。在上图中，节点数n=5，边数e=7，则在该图的邻接表中，节点表有5个节点，邻接点表有7个节点。节点a的出度为3，其后面单链表中的节点数为3；节点c的出度为2，其后面单链表中的节点数为2。

==在有向图邻接表中很容易找到节点的出度，但是找入度很难，需要遍历所有邻接点表中的节点，查找到该节点出现了多少次，入度就是多少==。例如在下图中，节点c的下标为2，在邻接点表中有两个为2的节点，因此节点c的入度为2；节点e的下标为4，在邻接点表中有3个为4的节点，因此节点e的入度为3。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111927357.png)

#### 3）有向图的逆邻接表（入弧）
有时为了方便得到节点的入度，可以建立一个有向图的逆邻接表，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111927329.png)
解释：
- 节点a没有逆邻接点（只看入边，即入弧），其后面的单链表为空；
- 节点b的逆邻接点是节点a，其邻接点的存储下标为0，将其放入节点b后面的单链表中；
- 节点c的逆邻接点是a、b，其邻接点的存储下标为0、1，按照头插法将其放入节点c后面的单链表中；
- 节点d的逆邻接点是节点c，其邻接点的存储下标为2，将其放入节点d后面的单链表中；
- 节点e的逆邻接点是节点a、c、d，其邻接点的存储下标为0、2、3，按照头插法（逆序）将其放入节点e后面的单链表中。

注意：对有向图中节点的逆邻接点，只看该节点的入边（入弧）。有向图的逆邻接表的特点如下。
（1）如果有向图有n个节点、e条边，则节点表有n个节点，邻接点表有e个节点。
（2）节点的入度为该节点后面的单链表中的节点数。在上图中，节点数n=5，边数e=7，在该图的邻接表中，节点表有5个节点，邻接点表有7个节点。节点a的入度为其后面的单链表中的节点数0，节点c的入度为其后面的单链表中的节点数2。
### 2. 邻接表的数据结构定义
邻接表的数据结构包括节点和邻接点，对其分别定义如下。
（1）节点。包括节点信息data和指向第1个邻接点的指针first，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111932064.png)
```cpp
typedef struct VexNode {
    VexType data; // VexType为节点信息的数据类型，根据需要定义
    AdjNode *first; // 指向第i个邻接点
} VexNode;
```
（2）邻接点。包括该邻接点的存储下标v和指向下一个邻接点的指针next，如果是网的邻接点，则还需增加一个权值域w，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111933614.png)
```cpp
typedef struct AdjNode { // 定义邻接点类型
        int v; // 邻接点下标
    struct AdjNode *next; // 指向下个邻接点
} AdjNode;
```
邻接表的结构体定义，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111937946.png)

### 3. 邻接表的存储方法
算法步骤：
（1）输入节点数和边数；
（2）依次输入节点信息，将其存储到节点数组Vex[]的data域中，将Vex[]的first域置空；
（3）依次输入每条边依附的两个节点，如果是网，则还需要输入该边的权值。
- 如果是无向图，则输入a b，查询节点a、b在节点数组Vex[]中的存储下标i、j，创建一个新的邻接点s，令s->v=j; s->next=NULL；然后将节点s插入第i个节点的第1个邻接点之前（头插法）。在无向图中，从节点a到节点b有边，从节点b到节点a也有边，因此还需要创建一个新的邻接点s2，令s2->v=i; s2->next=NULL；然后将s2节点插入第j个节点的第1个邻接点之前（头插法）。
- 如果是有向图，则输入ab，查询节点a、b在节点数组Vex[]中的存储下标i、j，创建一个新的邻接点s，令s->v=j; s->next=NULL；将节点s插入第i个节点的第1个邻接点之前（头插法）。
- **如果是无向网或有向网，则和无向图或有向图的处理方式一样，只是邻接点多了一个权值域**。

完美图解：一个有向图如下图所示，其邻接表的存储过程如下所述。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111938572.png)
（1）输入节点数5和边数7，G.vexnum=5，G.edgenum=7。
（2）输入节点信息a b c d e并将其存入节点表，存储结果如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111939322.png)

（3）依次输入每条边依附的两个节点。
- 输入ab，处理结果：在Vex[]数组的data域中查找到节点a、b的下标分别为0、1，创建一个新的邻接点s，令s->v=1;s->next=NULL。将节点s插入第0个节点的第1个邻接点之前（头插法）。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111940613.png)
- 输入a c，处理结果：在Vex[]数组的data域中查找到节点a、c的下标分别为0、2，创建一个新的邻接点s，令s->v=2;s->next=NULL。将节点s插入第0个节点的第1个邻接点之前（头插法）。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111940887.png)
- 输入a e，处理结果：在Vex[]数组的data域中查找到节点a、e的下标分别为0、4，创建一个新的邻接点s，令s->v=4;s->next=NULL。将节点s插入第0个节点的第1个邻接点之前（头插法）。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111940564.png)
- 输入b c，处理结果：在Vex[]数组的data域中查找到节点b、c的下标分别为1、2，创建一个新的邻接点s，令s->v=2;s->next=NULL。将节点s插入第1个节点的第1个邻接点之前（头插法）。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306111941072.png)
- 输入c d，处理结果：在Vex[]数组的data域中查找到节点c、d的下标分别为2、3，创建一个新的邻接点s，令s->v=3;s->next=NULL。将节点s插入第2个节点的第1个邻接点之前（头插法）。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112052607.png)
- 输入c e，处理结果：在Vex[]数组的data域中查找到c、e的下标分别为2、4，创建一个新的邻接点s，令s->v=4; s->next=NULL。将节点s插入第2个节点的第1个邻接点之前（头插法）。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112052701.png)
- 输入d e，处理结果：在Vex[]数组的data域中查找到节点d、e的下标分别为3、4，创建一个新的邻接点s，令s->v=4;s->next=NULL。将节点s插入第3个节点的第1个邻接点之前（头插法）。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112053825.png)
- 注意：由于后输入的内容被插在了单链表的前面，因此若输入顺序不同，则建立的单链表也不同。

算法代码：
```cpp
void CreateALGraph(ALGraph &G) {
    VexType u, v;
    cout << "输入节点数和边数：" << endl;
    cin >> G.vexnum >> G.edgenum;
    cout << "输入节点信息：" << endl;
    for (int i = 0; i < G.vexnum; ++i)
        cin >> G.Vex[i].data;
    for (int i = 0; i < G.vexnum; ++i)
        G.Vex[i].first = NULL;
    cout << "依次输入每条边的两个节点u, v" << endl;
    while (G.edgenum--) { // ???
        cin >> u >> v;
        int i = locatevex(G, u);
        int j = locatevex(G, v); // 查询节点u, v的存储下标
        if (i != -1 && j != -1) insertEdge(G, i, j); // 插入该边，无向图还需要插入一条边
    }
}
void insertEdge(ALGraph &G, int i, int j) { // 插入一条边（头插法）
    AdjNode *s;
    s = new AdjNode;
    s->v = j;
    s->next = G.Vex[i].first;
    G.Vex[i].first = s;
}
```
### 4. 邻接表的优缺点
（1）优点如下。
- 便于增删节点。
- 便于访问所有邻接点。访问所有节点的邻接点，其时间复杂度为O(n+e)。
- 空间复杂度低。节点表占用n个空间，无向图的邻接点表占用n+2e个空间，有向图的邻接点表占用n+e个空间，总体空间复杂度为O(n+e)。而邻接矩阵的空间复杂度为 $O(n^2)$ 。因此，对于稀疏图，可采用邻接表存储；对于稠密图，可采用邻接矩阵存储。

（2）缺点如下。
- 不便于判断在两个节点之间是否有边。要判断在两个节点之间是否有边，需要遍历该节点后面的邻接点链表。
- 不便于计算各节点的度。在无向图邻接表中，节点的度为该节点后面单链表中的节点数；在有向图邻接表中，节点的出度为该节点后面单链表中的节点数，但不易于求入度；在有向图的逆邻接表中，节点的入度为该节点后面单链表中的节点数，但不易于求出度。

==虽然以邻接表访问单条边的效率不高，但是访问同一节点的所有关联边时，仅需访问该节点后面的单链表==，时间复杂度为该节点的度 $O(d(v_i))$ ；而以邻接矩阵访问同一节点的所有关联边时，时间复杂度为 $O(n)$ 。总体上，邻接表比邻接矩阵效率更高。
## 6.1.4　链式前向星
链式前向星采用了一种静态链表存储方式，**将边集数组和邻接表相结合**，可以**快速访问一个节点的所有邻接点**，在算法竞赛中被广泛应用。链式前向星有如下两种存储结构。
（1）边集数组：edge[]，edge[i]表示第i条边。
（2）头节点数组：head[]，$head[i]$ 存储以 $i$ 为起点的第 $1$ 条边的下标（**edge[]中的下标**）。
```cpp
struct node {
    int to, next, w;
} edge[maxe]; // 边集数组，对边数一般要设置比maxn*maxn大的数，题目有要求除外
int head[maxn]; // 头节点数组如下
```
每一条边的结构都如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112059063.png)
例如，一个无向图如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112100895.png)

按以下顺序输入每条边的两个端点，建立链式前向星，过程如下。
（1）输入1 2 5。创建一条边1-2，权值为5，创建第1条边edge[0]，将该边链接到节点1的头节点中（初始时head[]数组全部被初始化为-1）。即$edge[0].next=head[1];head[1]=0$ ，表示节点1关联的第1条边为0号边，如下图所示。图中的虚线箭头仅表示它们之间的链接关系，不是指针。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112127095.png)
因为是无向图，所以还需添加它的反向边2-1，权值为5。创建第2条边edge[1]，将该边链接到节点2的头节点中。即 $edge[1].next=head[2]; head[2]=1$ ；表示节点2关联的第1条边为1号边，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112127939.png)
（2）输入1 4 3。创建一条边1-4，权值为3。创建第3条边edge[2]，将该边链接到节点1的头节点中（头插法）。即edge[2].next=head[1]; head[1]=2，表示节点1关联的第1条边为2号边，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112128538.png)
因为是无向图，所以还需要添加它的反向边4-1，权值为3。创建第4条边edge[3]，将该边链接到节点4的头节点中。即edge[3].next=head[4]; head[4]=3，表示节点4关联的第1条边为3号边，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112128136.png)
（3）依次输入三条边2 3 8、2 4 12、3 4 9，创建的链式前向星如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112129385.png)
添加一条边u v w的代码如下：
```cpp
void add(int u, int v, int w) { // 添加一条边
    edge[cnt].to = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt++;
}
```
如果是有向图，则每输入一条边，都执行一次 `add(u,v,w)` 即可；如果是无向图，则需要添加两条边 `add(u,v,w); add(v,u,w)` 。如何使用链式前向星访问一个节点u的所有邻接点呢？代码如下。
```cpp
for (int i = head[u]; i != -1; i = edge[i].next) { // i!=-1可以写为~i
    int v = edge[i].to; // u的邻接点
    int w = edge[i].w; // u-v的权值
    ...
}
```
链式前向星的特性如下。
（1）**和邻接表一样，因为采用头插法进行链接，所以边的输入顺序不同，创建的链式前向星也不同**。
（2）**对于无向图，每输入一条边，都需要添加两条边，互为反向边**。例如，输入第1条边1 2 5，实际上添加了两条边，如下图所示。这两条边互为反向边，**可以通过与1的异或运算得到其反向边**，0^1=1，1^1=0。也就是说，==如果一条边的下标为i，则其反向边为i^1。这个特性在网络流中应用起来非常方便==。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112132865.png)
（3）链式前向星具有边集数组和邻接表的功能，属于静态链表，不需要频繁地创建节点，应用起来十分灵活。
## 训练1　最大的节点
题目描述（P3916）：给定有N个节点、M条边的有向图，对每个节点v都求A(v)，表示从节点v出发，能到达的编号最大的节点。输入：第1行包含两个整数N、M（1≤N,M≤105）。接下来的M行，每行都包含两个整数Ui、Vi，表示边(Ui,Vi)。节点的编号为1～N。输出：N个整数A(1),A(2),⋯,A(N)。

题解：本题求从节点v出发能遍历到的最大节点，可以采用以下两种思路。• 从节点v出发，深度优先遍历所有的节点，求最大值。• 也可以换种思路，建立原图的反向图，从最大节点u出发，对凡是能遍历到的节点v，v能到达的编号最大的节点就是u。如下图所示，在反向图中，节点4能遍历到的节

点是4、1、2，这3个节点能到达的最大编号节点都是4；节点3能遍历到的节点是3、4，但是节点4已经有解，无须求解，因此节点3能到达的最大节点是3。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112133156.png)

1. 算法设计（1）存储图的反向图。（2）在反向图上进行倒序深度遍历。2. 算法实现[插图][插图]训练2　有向图D和E题目描述（UVA11175）：有向图D有n个节点和m条边，可以通过以下方式制作D的Lying图E。E将有m个节点，每个都用于表示D的每条边。例如，如果D具有边(u,v)，则E将具有节点uv。现在，当D具有边(u,v)和(v,w)时，E将具有从节点uv到节点vw的边。在E中没有其他边。给定一个图E，确定E是否可能是某个有向图D的Lying图。注意，在D中允许有重复的边和自环。输入：第1行包含测试用例数N（N<220）。在每个测试用例的前两行都包含m（0≤m≤300）和k，表示图E中的节点数和边数。下面的k行，每行都包含两个节点x和y，表示在E中从x到y有一条边。节点编号为0～m-1。输出：对每个测试用例，都输出一行Case #t:，其中t表示测试用例编号，然后是Yes或者No，用于判断E是否是一个有向图D的Lying图。[插图]题解：本题实际

上就是把D中的边缩成点，D中的一条边对应E中的一个节点，如果在D中存在边i(u,v)和j(v,w)，则E将具有从节点i到节点j的边。[插图]如果在D中边i和边j有公共端点，则i连接的边，j一定也连接，不存在i连接的边但是j没连接的情况。那么在E中，节点i和节点j有公共邻接点，则i邻接的节点，j一定也邻接。如下图所示，在D中，边i和边j有公共端点c，i连接边k1、k2，j则一定也连接边k1、k2；在对应的E中，节点i和节点j有公共邻接点k1，i有邻接点k2，j则一定也有邻接点k2。[插图]1. 算法设计（1）用邻接矩阵存储E。（2）判断在E中是否存在节点i和节点j有公共邻接点但是对i邻接的节点而j不邻接的情况。2. 算法实现[插图][插图]训练3　奶牛排序题目描述（POJ3275）：约翰想按照奶牛的产奶能力给它们排序。已知有N（1≤N≤1 000）头奶牛，而且知道这些奶牛的M（1≤M≤10 000）种关系，将每种关系都表示为“XY”，表示奶牛X的产奶能力大于奶牛Y。约翰想知道自己至少还要调查多少对关系才能完成整个排序。输入：第1行包含两个整数N和M。第2…M+1行，每行都包含两个整数X和Y。X和Y都在1～N范围


内，表示奶牛X的排名高于奶牛Y。输出：单行输出至少还要调查多少种关系才能完成整个排序。[插图]提示：在输入样例中，cow2>cow1>cow5，cow2>cow3>cow4，所以cow2的排名最高。不过，约翰需要知道排名大于cow1及cow3的排名第二的牛，还需要通过一个问题来确定cow4和cow5的顺序。之后，他需要知道如果cow1大于cow3，那么cow5是否大于cow3。他必须问三个问题才能确定排名：“cow1>cow3？cow4>cow5？”“cow5>cow3？”。题解：（1）根据输入样例，创建一个有向图。[插图]（2）根据传递性，得到的已知关系有7种，分别是：1>4、1>5、2>1、2>3、2>4、2>5、3>4。（3）对于有n个节点的图，两两之间的关系一共有n(n-1)/2种，5个节点共有5×4/2=10种关系，还需要知道10-7=3种关系即可。如何得到已知关系呢？可以利用bitset位运算，将每个节点都用一个bitset来表示。[插图]初始化时，p[i][i]=1，即p[i]的第i位为1（从右侧数第0位、1位、2位）。输入1-5，令p[1][5]=1，则p[1]=…….100010。输入1-


4，令p[1][4]=1，则p[1]=…….110010。输入2-1，令p[2][1]=1，则p[2]=…….000110。输入2-3，令p[2][3]=1，则p[2]=…….001110。输入3-4，令p[3][4]=1，则p[3]=…….011000。判断每个数组的每一位，代码如下。[插图]例如，p[2][1]=1，则p[2]=p[2]|p[1]= 001110 |110010=111110。如果2和1有关系，而1和4、5有关系，则通过或运算，可以得出2和4、5也有关系。通过此方法，可以找到每个点和其他点的关系。用ans累计每个数组元素1的个数，因为初始化时自己到自己为1，所以ans多算了n种关系，已知关系数应为ans-n，用n(n-1)/2减去已知关系数即可。[插图]

