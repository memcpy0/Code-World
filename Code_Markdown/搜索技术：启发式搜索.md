
尽管广度优先搜索、深度优先搜索加上有效的剪枝方法，可以解决很多问题，但这两种搜索都是盲目的，它们不管目标在哪里，只管按照自己的方式搜索，会存在很多没必要的搜索。有没有一种启发式搜索算法，可以启发程序朝着目标的方向搜索，从而提高搜索效率呢？启发式搜索算法对每一个搜索状态都进行评估，选择估值最好的状态，从该状态进行搜索直到目标。如何对一个状态进行评估呢？一个状态的当前代价最小，只能说明从初始状态到当前状态的代价最小，不代表总的代价最小，因为余下的路还很长，未来的代价有可能更高。因此评估需要考虑两部分：当前代价和未来估价。评估函数f(x)：f(x)=g(x)+h(x)，其中，g(x)表示从初始状态到当前状态x的代价，h(x)表示从当前状态到目标状态的估价，h(x)被称为启发函数。常用的启发式搜索算法有很多，例如A*、IDA*、模拟退火算法、蚁群算法、遗传算法等。9.4.1　A*算法A*算法是带有评估函数的优先队列式广度优先搜索算法。在广度优先搜索时维护一个优先队列，每次都从优先队列中取出评估值最优的状态进行扩展。第1次从优先队列中取出目标状态时，即可得到最优解。A*算法提高搜索效率的关键在于

启发函数的设计，不同的启发函数，其搜索效率不同。启发函数h(x)越接近当前状态到目标状态的实际代价h′(x)，A*算法的效率就越高。启发函数的估值不能超过实际代价，即h(x)≤h′(x)。如果启发函数的估值超过实际代价，则失去意义。例如，如果当前节点到目标的实际最短距离为30，当前节点的启发函数估值为50，另一个节点的启发函数估值为100，则在两个节点已走过路径长度g(x)相同的情况下，不能说明当前节点就一定比另一个节点优，也没有比较的意义，反正两个都不优。如果令所有状态的h(x)都为0，则退化为普通的优先队列式广度优先搜索算法，不再有启发式搜索的作用。9.4.2　IDA*算法IDA*算法是带有评估函数的迭代加深DFS算法。深度优先搜索有可能跌入一个无底深渊，搜索了很多步也无法找到问题的解，因此要对搜索的深度加以限制，超过该深度便不再搜索，立即回溯。迭代加深DFS算法是深度优先搜索算法的一种变形，事先限定一个深度depth，在不超过该深度的情况下进行深度优先搜索，如果找不到解，则增加深度限制，重新进行搜索，直到找到目标。IDA*算法设置了一个评估函数f(x)：当前深度+未来估计步数，当

f(x)>depth时立即回溯，避免无效搜索，提高效率。在很多情况下，IDA*算法的效率更高，代码更少。训练1　八数码题目描述（HDU1043）：十五数码问题是由15块滑动的方块构成的，在每一块上都有一个1～15的数字，所有方块都是一个4×4的排列，其中一块方块丢失，称之为“x”。拼图的目的是排列方块，使其按以下顺序排列：[插图]其中唯一合法的操作是将“x”与相邻的方块之一交换。下面的移动序列解决了一个稍微混乱的拼图：[插图]上一行中的字母表示在每个步骤中“x”方块的哪个邻居与“x”交换；合法值分别为“r”“l”“u”和“d”，表示右、左、上和下。在这个问题中，编写一个程序来解决八数码问题，它由3×3的排列组成。输入：输入包含多个测试用例，描述是初始位置的方块列表，从上到下列出行，在一行中从左到右列出方块，其中的方块由数字1～8加上“x”表示。例如以下拼图[插图]由以下列表描述：[插图]输出：如果没有答案，则输出“unsolvable”，否则输出由字母“r”“l”“u”和“d”组成的字符串，描述产生答案的一系列移动。字符串不应包含空格，并从行首开始。[插图]题解：本题为八数码问题，包含多个测试用例，同一题目的POJ


1077数据较弱，只有1个测试用例。要求通过x方块上下左右四个方向移动，经过最少的步数达到目标状态。例如，初始状态1 2 3 x 4 6 7 5 8，经过r、d、r等3步后达到目标状态。[插图]注意：答案不唯一，任一正确答案均可。可以采用A*算法、IDA*算法或打表解决。1. A*算法本题采用康托展开判断重复状态，以当前状态和目标状态的曼哈顿距离作为启发函数，评估函数为已走过的步数+启发函数，评估函数值越小越优先。从初始状态开始，根据优先队列广度优先搜索目标状态。1）预处理首先将字符串读入，例如，1 2 3 x 4 6 7 5 8，将x转换为数字8，其他字符1～8转换成数字0～7。转换之后的棋盘如下图所示。用start.x记录x所在位置的下标，方便以后移动。[插图]2）可解性判断把除x外的所有数字排成一个序列，求序列的逆序对数。逆序对数指对于第i个数，后面有多少个数比它小。例如，对于1 2 3 x 4 6 7 5 8，6后面有一个数5比它小，6和5是一个逆序对，7后面有一个数5比它小，7和5是一个逆序对，该序列共两个逆序对。数码问题可以被看作N×N的棋盘，八数码问题N=3，十五数码问题N=4。对于

每一次交换操作，左右交换都不改变逆序对数，上下交换时逆序对数增加(N-1)、减少(N-1)或不变。• N为奇数时：上下交换时每次增加或减少的逆序对数都为偶数，因此每次移动逆序对数，奇偶性不变。若初态的逆序对数与目标状态的逆序对数的奇偶性相同，则有解。• N为偶数时：上下交换时每次增加或减少的逆序对数都为奇数，上下交换一次，奇偶性改变一次。因此需要计算初态和目标状态x相差的行数k，若初态的逆序对数加上k与目标状态逆序对数奇偶性相同，则有解。八数码问题N=3，若初态的逆序对数与目标状态逆序对数奇偶性相同，则有解。本题目标状态的逆序对数为0，因此初态的逆序对数必须为偶数才有解。注意：统计逆序对数时x除外。算法代码：[插图][插图]3）康托展开判重在A*算法中，每种状态只需在第一次取出时扩展一次。如何判断这种状态已经扩展过了呢？可以设置哈希函数或使用STL中的map、set等方法。有一个很好的哈希方法是“康托（Cantor）展开”，它可以将每种状态都与0～(9!-1)的整数建立一一映射，快速判断一种状态是否已扩展。状态是数字0～8的全排列，共362880个。将所有排列都按照从小到大的顺序映射到一个整数（位

序），将排列最小的数012345678映射到0，将排列最大的数876543210映射到362880-1，如下图所示。[插图]如果采用排序算法，则最快O(n!log(n!))，其中n=9。而康托展开可以在O(n2)时间内将一种状态映射到这个整数。康托展开是怎么计算的呢？例如，2031，求其在{0,1,2,3}全排列中的位序，其实就是计算排在2031前面的排列有多少个，可以按位统计，如下所述。• 第0位的数字2：在2031中，2后面比2小的有两个数字{0,1}。以0开头，其他3个数字全排列有3!个，即(0123,0132,0213,0231,0312,0321)；以1开头，其他3个数字全排列有3!个(1023,1032,1203,1230,1302,1320)。因此排在以2开头的数字之前共2×3!个数字。• 第1位的数字0：在2031中，0后面没有比0小的数字。• 第2位的数字3：在2031中，3后面比3小的有1个数字{1}，前两位20已确定，以1开头，剩余1个数字的全排列有1!个数字，即2013。排在3之前的共1×1!个数字。• 第3位的数字1：在2031中，1后面没有比它小的数字。因此203

1的位序为2×3!+1=13。位序计算公式：[插图]其中，cnt[i]为a[i]后面比a[i]小的数字个数，n为数字个数。8数码问题包含0～8共9个数字，首先求出0～8的阶乘并将其保存到数组中。然后统计在每一个数字后面有多少个数字比它小，累加cnt*fac[8-i]即可得到该状态的位序。状态与位序之间是一一映射的，无须处理哈希冲突问题。算法代码：[插图]4）曼哈顿距离A*算法的启发函数有多种设计方法，可以选择当前状态与目标状态位置不同的数字个数，也可以选择当前状态的逆序对数（目标状态逆序对数为0），还可以选择当前状态与目标状态的曼哈顿距离。本题选择当前状态和目标状态的曼哈顿距离作为启发函数。曼哈顿距离又被称为“出租车距离”，指行列差的绝对值之和，即从一个位置到另一个位置的最短距离。例如，从A点到B点，无论是先走行后走列，还是先走列后走行，走的距离都为行列差的绝对值之和。如下图所示，A和B的曼哈顿距离为2+1=3。[插图]求当前状态与目标状态的曼哈顿距离，需要将两种状态上的数字位置转换为行、列，然后求行、列差的绝对值之和。例如，当前状态和目标状态如下图所示，将位置下标i转换为行(i/3)，转换为列(i%3

)。当前状态的数字4的位置下标为7，转换为7/3行、7%3列，即2行、1列。目标状态的数字4的位置下标为4，转换为4/3行、4%3列，即1行、1列。两个位置的曼哈顿距离为|2-1|+|1-1|=1。[插图]除了8（x滑块），计算当前状态和目标状态中每个位置的曼哈顿距离之和。曼哈顿距离为什么不需要计算8（x滑块）？因为其他数字都是通过和滑块交换达到目标状态的。例如下图中，当前状态只有数字7，与目标状态的数字7位置不同，差一个曼哈顿距离，与滑块交换一次，7即可归位。当所有数字都与目标状态的位置相同时，滑块自然跑到了它应该在的位置。如果计算8（x滑块）的曼哈顿距离，那么当前状态和目标状态的曼哈顿距离为2，很明显是错误的，进行一步交换就可以达到目标状态。[插图]算法代码：[插图]5）A*算法算法步骤：（1）创建一个优先队列，将评估函数f(t)=g(t)+h(t)作为优先队列的优先级，g(t)为已走过的步数，h(t)为当前状态与目标状态的曼哈顿距离，f(t)越小越优先。计算初始状态的启发函数h(start)，计算初始状态的康托展开值cantor(start)并标记已访问，初始状态入队。（2）如果队列不空，则队头t

出队，否则算法结束。（3）计算康托展开值k_s=cantor(t)，从t出发向4个方向扩展。计算x新位置的行列值。[插图]例如，如下图所示，当前状态x（数字8）的位置t.x=3，将其转换为3/3=1行、3%3=0列，向右移动一格后，x的新位置为1行、1列，转换为下标为4。[插图]如果新位置超出边界，则继续下一循环，否则令新旧位置上的数字交换，记录新状态x的位置。计算新状态的评估函数，nex.g++; nex.h=h(nex);ex.f=nex.g+nex.h; 计算新状态的康托展开值k_n=cantor(nex)，如果该状态已被访问，则继续下一循环；否则标记已访问，并将新状态入队。[插图]如果k_n=0，则说明已找到目标（目标状态康托展开值为0），返回。算法代码：[插图][插图]2. IDA*算法IDA*算法是带有评估函数的迭代加深DFS算法，本题设计评估函数f(t)=g(t)+h(t)，g(t)为已走过的步数，h(t)为当前状态与目标状态的曼哈顿距离。算法步骤：（1）从depth=1开始进行深度优先搜索。（2）计算当前状态与目标状态的曼哈顿距离t=h()，如果t=0，则说明已找到目标，ans[d]='\0'，返回

1。如果d+t＞depth，则返回0。（3）从当前状态出发，沿4个方向扩展。（4）如果没有找到目标，则增加深度，++depth，继续搜索。算法代码：[插图][插图]IDA*算法优化算法：上面的IDA*算法深度从1开始，每次都增加1，这样搜索的速度不快。其实可以从初始状态到目标状态的曼哈顿距离开始，每次都增加上一次搜索失败的最小深度，从而提高搜索效率。HDU1043的提交运行时间在优化前为202ms，在优化后为124ms。算法步骤：（1）从depth=h()开始进行深度优先搜索。（2）计算当前状态与目标状态的曼哈顿距离t=h()，如果t=0，则说明已找到目标，ans[d]='\0'，返回1。如果d+t＞depth，则更新mindep=min(mindep,d+t)，返回0。（3）从当前状态出发，沿着4个方向扩展。（4）如果没有找到目标，则增加深度，depth=mindep，继续搜索。算法代码：[插图][插图]3. 打表打表是一种典型的用空间换时间的技巧，一般指将所有可能需要用到的结果都事先计算出来，在后面需要用到时可以直接查表。当所有的可能状态都不多时，用打表的办法速度更快。从目标状态开始进行广度优先搜索，反向


搜索所有状态，记录该状态的前驱及方向字符。记录方向字符时，因为是倒推的，所以左移相当于前一状态到目标状态的右移，因此方向字符为r，如下图所示。[插图]对每一个状态都用康托展开值作为唯一标识，如果求解从某一个状态到目标状态，则可以直接根据该状态的前驱数组找到目标状态。如果初始状态没被标记过，则说明从该状态无法到达目标状态。算法代码：[插图][插图]4种算法的运行时间及空间比较如下表所示。[插图]训练2　八数码II题目描述（HDU3567）：八数码，也叫作“九宫格”，来自一个古老的游戏。在这个游戏中，你将得到一个3×3的棋盘和8个方块。方块的编号为1～8，其中一块方块丢失，称之为“X”。“X”可与相邻的方块交换位置。用符号“r”表示将“X”与其右侧的方块进行交换，用“l”表示左侧的方块，用“u”表示其上方的方块，用“d”表示其下方的方块。[插图]棋盘的状态可以用字符串S表示，使用下面显示的规则。[插图]问题是使用“r”“u”“l”“d”操作列表可以将棋盘的状态从状态A转到状态B，需要找到满足以下约束的结果：（1）在所有可能的解决方案中，它的长度最小；（2）它是所有最小长度解中词典序最小的一个。输入：第1行是T（T≤200），

表示测试用例数。每个测试用例的输入都由两行组成，状态A位于第1行，状态B位于第2行。保证从状态A到状态B都有有效的解决方案。输出：对于每个测试用例，都输出两行。第1行是“Case x:d”格式，其中x是从1开始计算的案例号，d是将A转换到B的操作列表的最小长度。第2行是满足约束条件的操作列表。[插图]题解：本题为八数码问题，与前面八数码问题（HDU1043）不同的是，本题的终态（目标状态）不是固定不变的，而是由输入确定的。要求从初态A到终态B，输出最少的步数和操作序列，而且如果最小步数相同，则输出字典序最小的一个。本题保证有解，无须可解性判断，可以采用A*、IDA*算法解决，在此采用IDA*算法。1. 算法设计（1）读入初态，用变量x记录“X”出现的位置i，令a[i]=0，将其他位置减去“0”转换成数字。例如，初态为564178X23，用变量x记录“X”出现的位置6，转换之后的棋盘如下图所示。[插图]（2）读入终态，“X”出现的位置为i，令goal[i]=0，其他位置减去“0”转换成数字。上题（HDU1043）中目标状态数字正好等于位置下标，本题中的目标状态是根据输入数据确定的，为了方便计算启发函

数，对目标状态建立一个从数字到位置下标的映射。将goal[i]映射到位置下标i，m[goal[i]]=i。例如，终态为7568X4123，转换之后的棋盘如下图所示，m[7]=0，m[6]=2。[插图]（3）计算初态启发函数并初始化深度depth=h()。如下图所示，初始状态中数字7的位置下标为4，转换为4/3行、4%3列，即1行、1列。目标状态中数字7的映射位置下标为0，转换为0/3行、0%3列，即0行、0列。两个位置的曼哈顿距离为|1-0|+|1-0|=2。除了0（X滑块），计算当前状态和目标状态中每个位置的曼哈顿距离之和。[插图]（4）深度优先搜索，计算当前状态的启发函数h()，如果正好为0，则找到目标输入答案，返回1。如果d+t>depth，则更新mindep=min(mindep, d+t)，返回0。（5）沿着4个方向搜索，如果x的新位置未出边界、不是前一个位置，则交换原位置和新位置，记录操作序列，从新位置开始深度加1，进行深度优先搜索，如果找到答案，则返回1，否则交换原位置和新位置，还原现场并回溯。（6）如果未找到答案，则深度为depth=mindep，继续进行迭代加深搜索。2. 算法实




现定义方向数组及操作序列，操作序列字母按字典序排序。[插图][插图]训练3　第K短路题目描述（POJ2449）：给定一个有向图，N个节点，M条边。求从源点S到终点T的第K短路。路径可能包含两次或两次以上的同一节点，甚至是S或T。具有相同长度的不同路径将被视为不同。输入：第1行包含两个整数N和M（1≤N≤1000，0≤M≤100 000）。节点编号为1～N。以下M行中的每一行都包含3个整数A、B和T（1≤A, B≤N，1≤T≤100），表示从A到B有一条直达的路径，需要时间T。最后一行包含3个整数S、T和K（1≤S, T≤N，1≤K≤1000）。输出：单行输出第K短路径的长度（所需时间）。如果不存在第K短路，则输出-1。[插图]题解：本题求第K短路。如果采用优先队列式广度优先搜索算法，则记录当前节点v和源点s到v的最短路径长度(v, dist)。首先将(s, 0)入队，然后每次都从优先队列中取出dist最小的二元组(x, dist)，对x的每一个邻接点y都进行扩展，将新的二元组(y, dist+w(x, y))入队。第1次从优先队列中取出(x, dist)时，就得到从源点s到x的最短路径长度dist。那么


在第i次从优先队列中取出(x, dist)时，就得到从源点s到x的第i短路径长度dist。实际上，从源点s到当前节点x的最短路径长度最小，并不代表经过x就能够得到从源点s到终点t的最短路径长度。因为余下的路有可能很长，并不知道从x到终点t的最短路径长度是多少。因此可以考虑采用A*算法，设置评估函数f(x)=g(x)+h(x)，其中g(x)表示从源点s到节点x的最短路径长度，h(x)表示从节点x到终点t的最短路径长度。将f(x)作为优先队列的优先级，f(x)越小，得到从起点到终点最短路径长度的可能性越大。1. 算法设计（1）在原图的反向图中，采用Dijkstra算法求出从终点t到所有节点x的最短路径长度dist[x]。实际上，dist[x]就是原图中从节点x到终点t的最短路径长度。（2）如果dist[s]=inf，则说明从源点无法到达终点，返回-1，算法结束。（3）在原图中，采用A*算法求解。用三元组(v, g, h)记录状态，第1个参数为当前节点编号，后两个参数分别代表从源点到当前节点的最短路径长度和从当前节点到终点的最短路径长度。优先级为g+h，其值越小，优先级越高。初始时，将(s, 

 0, 0)加入优先队列中。（4）如果队列不空，则队头p出队，u=p.v，节点u的访问次数加1，即times[u]++。如果u正好是终点且访问次数为k，则返回最短路径长度p.g+p.h，算法结束。（5）如果times[u]>k，则不再扩展，否则扩展u的所有邻接点E[i].v，将(E[i].v,p.g+E[i].w, dist[E[i].v])入队。2. 算法实现[插图][插图]训练4　幂运算题目描述（POJ3134）：从x开始，反复乘以x，可以用30次乘法计算x31：x2=x×x，x3=x2×x，x4=x3×x，…，x31=x30×x。平方运算可以明显地缩短乘法序列，以下是用8次乘法计算x31的方法：x2=x×x，x3=x2×x，x6=x3×x3，x7=x6×x，x14=x7×x7，x15=x14×x，x30=x15×x15，x31=x30×x。这不是计算x31的最短乘法序列。有很多方法只有7次乘法，以下是其中之一：x2=x×x，x4=x2×x2，x8=x4×x4，x10=x8×x2，x20=x10×x10，x30=x20×x10，x31=x30×x。如果除法也可用，则可以找到一个更短的操作序列。可以

用6个运算（5乘1除）计算x31：x2=x×x，x4=x2×x2，x8=x4×x4，x16=x8×x8，x32=x16×x16，x31=x32÷x。如果除法和乘法一样快，则这是计算x31最有效的方法之一。编写一个程序，通过从x开始的乘法和除法，为给定的正整数n找到计算xn的最少运算次数。在序列中出现的乘积和商应该是x的正整数幂。输入：输入是由一行或多行组成的序列，每行都包含一个整数n（0<n≤1000）。以输入0结束。输出：单行输出从x开始计算xn所需的最小乘法和除法总数。[插图]题解：本题从x开始计算xn所需的最小乘法和除法总数，可以采用IDA*算法解决。1. 算法设计（1）初始化，指数ex[0]=1，深度depth=0。（2）进行深度优先搜索，如果ex[d]=n，则返回1。如果d≥depth，则返回0。如果当前指数在倍增depth-d之后还小于n，则返回0。（3）从0到d执行乘法，ex[d+1]=ex[d]+ex[i]，深度优先搜索dfs(d+1)，如果成功，则返回1；执行除法，ex[d+1]=abs(ex[d]-ex[i])，进行深度优先搜索dfs(d+1)，如果成功，则返回1。（4）如果搜索失败，则深度depth++，重新开始搜索。2. 算法实现[插图]