套利，网格，趋势三类策略
套利：三角、跨市、统计套利
网格：基于深度、价格的网格、时间序列、混合多种条件
趋势：基于均线、因子、NLP分析、消息的策略

使用Python+Jupiter Notebook
回测：FMZ（原botvx）
模拟盘建议使用：bitmex测试网络 或 FMZ模拟盘

为了后续优化策略便捷，需要把策略逻辑层，底层，和一些支持的中间组件分开来。

数字货币 深度差！24小时不间断交易！交易所不稳定，非常需要考虑容错功能！

数字货币 != 数字货币的交易，交易类似于期货的交易！
数字货币的交易 != 数字货币的量化交易，逻辑差别很大。

区分币相关与市场还是政策（公告币，小盘），强相关政策应该跑趋势、而非网格和套利
# 1 从使用API获取信息开始学习
RESTAPI
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200115465.png)
上来用FMZ.COM https://www.fmz.com/bbs-topic/458
使用ccxt这个库
```python
# 获取价格 深度，账户信息
# 实现买卖功能
### ccxt 获取信息，实现买卖

### 使用botvs获取信息，以及挂单
```

---
Quantitative Trading: How to Build Your Own Algorithmic Trading Business

# The Whats, Whos, and Whys of Quantitative Trading
## 第一章：The Whats,Whos,and Whys of Quantitative Trading

量化交易是什么？

量化交易也被称作算法交易，各类资产的买入卖出严格按照计算机算法，交易员自己设计的算法和程序。

很多书籍提到的技术分析，如果技术分析的指标可以被量化，那么也算是量化交易的一种。

总的来说如果你可以把各种信息转化为计算机能够识别的信息来进行交易，就可以被看作是量化交易。

谁可以成为量化交易员？

实际上大多数机构的交易员都是毕业于物理、数学、工程或者计算机科学专业，当然科学技能的训练是这些人在分析和交易复杂的衍生品时所必须的技能，但是本书并不会涉及复杂的交易标的，有一种交易策略是统计套利，交易标的是简单的股票、期货以及外汇，入门相对简单，只要你上过一些高等数学、统计学和会变成，你就可以掌握统计套利策略（简单的！！！）

  

## 第二章：Fishing for ideas:从哪里找到好的策略

网络上有成千上网的交易策略，主要有以下一些渠道：

  

![](https://pic3.zhimg.com/80/v2-7eb549abaf19ad317144f376b271b32e_720w.webp)

（我个人会看的像 Elite Trader/[http://epchan.blogspot.com](https://link.zhihu.com/?target=http%3A//epchan.blogspot.com)，大家也可以挖掘挖掘这些网站）

但是自己需要对公开的策略有一些辨识能力，比如说许多论文中的策略都是针对小市值股票的，流动性并不好，真实的交易中利润肯定不如回测表现好（这里涉及到交易的流动性成本问题，在后面的专栏中会详细讲讲），还有网上PO出来的策略表现可能并没有经过严格的回测检验条件，比如并没有考虑到交易成本之类的。EPCHAN还是经常从博客和论坛中发现简单且能盈利的策略

  

下面这个问题比较重要，人要选择适合自己的策略：

1、工作时间：如果你是业余交易者，每天交易的时间有限，那么可能你会更倾向于隔夜交易（持有超过1天，一般对今天买入并卖出的交易称为：日内交易）

2、编程技能：如果你的编程水平有限，那么就不要选择对编程水平要求较高的高频交易（比如说每TICK交易几十上百次）

3、交易本金：如果本金较少，那么就需要考虑一些把杠杆用到极限，就是交易标的期货、期权、外汇，这些交易标的都是可以加杠杆的。

4、盈利目标：这里有一个大众误区，就是如果你追求长期的回报，那么你只需要买入并持有。优秀的策略应该是找到一个夏普率最高的策略（实践中其实夏普率并不是唯一的参考指标，不过也是非常好的一个参考指标，需要大家在大量的策略检验中去寻找平衡点）。

  

如果你在网上找到了自己认为适合的策略，并且别人PO出来的策略表现非常优越，但是不要急于的将你的时间花在测试这些策略上面，你可以从以下几点去快速的检验策略（很多量化交易机构都会使用人海战术，就是不放过一个指标及策略，全部进行回测，反正现在计算能力已经不是问题）：

（1）盈利水平和基准进行对比情况，还有盈利的持续性

比如一个股票的策略盈利水平就需要和股指的表现进行对比。这个时候就引入前面已经谈到的夏普比指标。

SHARPE RATIO = average of excess Returns / standard deviation of excess Returns

夏普比 = 超额收益的平均值/超额收益的标准差

其中 excess Returns = Portfolio Returns - Benchmark Returns

超额收益 = 策略收益 - 基准收益

  

注：如果你的策略一年之中只交易很少的几次，夏普率就不会太高，如果你的策略有很深的回撤（drawdown，见下图），并且持续时间长，夏普比也不会太高。

  

![](https://pic4.zhimg.com/80/v2-0ea5cdd1174b88e51eafaad837e0d0ef_720w.webp)

任何策略如果夏普率低于1，这就是一个不太合适的策略，如果一个策略基本上每个月都盈利的话， 夏普率应该是大于2，如果一个策略基本上每日都盈利话，那么夏普率会通常大于3。

  

（2）交易成本对策略表现的影响

每一次买卖证券，都会产生交易成本。交易成本对策略的影响是非常大的（感觉99.99%的策略都是败给手续费的，开赌场的最赚钱）。交易成本不只是交易佣金（比如印花税），还有流动性成本（非常重要！），如果你想买入或者卖出证券，你都需要付出最优卖家和最优买价的价差。如果你使用限价单（到一定心理价位才成交），那么你将可能会失去交易机会。还有如果你的买入卖出量够大的话，你的行为就会影响市场的价格，就是需求和供给严重不平衡，这个时候可能就会出现流动性缺乏，付出巨大的交易成本，举个栗子，如果现在买卖苹果，第一个卖苹果的人卖1元，第二个卖苹果的人卖100元，你需要买入两个苹果，你下了两个市价单（按照现在市场能成交的价格成交的订单类型），那么你就会花费101元买两个苹果！。

  

另外“滑点”对策略的表现影响也很大，滑点就是你看到苹果卖1元，你发了个订单去买，但是1元的苹果已经被别人买走了，别人的交易速度比你快，于是你的订单一到交易所就成交了100元的苹果，你比预期的成交价高了99块，这99块就是滑点成本，一般来讲回测策略至少需要设置2跳（比如说苹果只能按照1元、2元...每一块报价，那么1元=1跳）。

  

（3）数据是否存在生存者偏差

我们股票市场中有不少很差的企业都退市了，比如说A企业在2015年退市了，你在回测过去5年的数据时，很可能只选择了还存活在现在的企业，这些很差的如A企业数据并不包含，那么你使用的数据就存在了生存者偏差，自动的排除了已经被市场淘汰的企业。

  

（4）策略每年的表现

regime shifts就是市场结构变化，会使你的策略失效，市场结构变化多是由交易所监管导致，比如说在15年我国对股指期货提高交易手续费、限制交易手数，一下子把市场的流动性都打下来了，这个品种接近死掉。

  

（5）策略过拟合

如果交易策略有100个交易参数，回测的结果也非常的完美，那么你的策略很可能已经过度拟合，就是你已经知道了过去市场的表现，你按照特定的数据选择了一条最优路线，但是正如你不可能踏入同一条河流，你的策略的普适性是非常差的，基本上会100%亏掉（我一般交易策略不会高于5个参数）。避免过拟合也非常简单，用一些新的数据来验证策略参数即可。

---

书的前两章重点就讲了这么些，我觉得比较重要的不要深化量化交易，加减乘除也许就OK，但是一些重要的概念必须要谨记：滑点、过拟合、交易成本、数据准确度。

下一篇将进入实战前篇：回测！！！！

第三章：Backtesting 回测

  

和传统的投资管理程序不同，量化交易流程是先需要把交易策略运用于历史数据、检验交易策略历史表现如何。尽管你找到了一个策略，并且有完成详细的历史表现，但是你仍然需要亲自的去检验回测策略。这样做有几个好处，一是你可以完全的理解别人的策略思想，而是你可以接触到不同类型的策略，这些策略都可以被重新定义或者升级为更牛逼的策略。

  

在这个章节中，作者介绍了一些用来回测的工具平台和数据（我也写一下自己的真实感受）：

回测平台：

1、excel:这个环节就略过了，作为大量交易策略来讲，EXCEL实在是容易卡主，我们跳过！

2、matlab:刚接触量化交易时，用的就是matlab，矩阵计算能力相当好，不妨作为入门级工具，也可以深入的掌握matlab，作为一个偏交易策略的trader来讲，这个工具也就OK了。

其余书中提到的平台TRADERSTATION等都不适合国内交易员用，另外我再补充两个：

1、C++：这个是作为量化交易团队中作底层系统支持的程序员们必须要掌握的语言，C++计算速度非常快，建议也可以学习一下，当你的策略在matlab中有了初步模型时，可以使用C++来做策略参数迭代优化等。

2、PYTHON：这个是最近新崛起的工具，其优势在于有很多开源库，基本属于人人都可入门的语言。

历史数据：

作者列举的都是国外的数据源，也并不实用，下面我谈一下一般量化交易的数据源:

1、期货数据方面：直接CTP从交易所收取行情，并储存在本地，这个后期我会写文章

2、股票数据方面：我一般都会直接从公司版的wind里获取数据，如果没有的话，同花顺，以及雅虎的股票数据都是考虑的。

  

注：在读专栏时不要担心，我会把策略回测涉及的历史数据分享出来，但是如果真正的要想做交易，还是先花钱买到质量高的数据，毕竟有了好的材料，才能做出美味的食品。

  

> 周五就写这么多了，重点是每天都有更新，下一篇会涉及到常用的数据格式、另外的一些策略评价指标计算、最大回撤及最大回撤区间的计算方法。


英文书籍的特点就是废话是比较多的，写这个系列也是挑出精华部分，另外加上自己在实操中的一些东东，进行修改，但是是按照书的内容精神走。

  

> 英文书籍的特点就是废话是比较多的，写这个系列也是挑出精华部分，另外加上自己在实操中的一些东东，进行修改，但是是按照书的内容精神走。

## 回测文件格式

做交易时往往涉及到不同的交易品种，一般会按品种区分文件夹，如下图（这里是下载了所有的主力合约，就是每天交易量最大的合约）：

  

![](https://pic2.zhimg.com/80/v2-c1296fbb5ff819fbcdf618850e72cfb1_720w.webp)

  

每一个文件夹按照品种命名，我们在做回测时需要保证读取数据时，路径及数据格式统一，方便不同策略回测，我们打开a文件夹，如下图：

  

![](https://pic2.zhimg.com/80/v2-4aaf0458a202c0fd0b13f7b5a1595b99_720w.webp)

  

这个文件夹里装着这个品种从11年以来的所有交易数据，数据命名格式为交易的合约标的（如：a1201）+ 数据日期（如：20110329），储存格式为TXT文本文件，下面我们再打开一个数据交易合约看看，如下图：

![](https://pic4.zhimg.com/80/v2-f3320d9887ba05b331ecd876ae968413_720w.webp)

我们可以看到第一行#开头的为昨日的数据：开盘价、收盘价、成交量；第二行为今日交易数据，分别为：交易时间(time)、买价(bidprice)、买量(bidvolume)、卖价(askprice)、卖量(askvolume)、成交价(settleprice)、成交量(settlevolume)、累计成交量(totalvolume)。

所有的交易数据都以以上的格式进行储存。

  

现在我们用PYTHON来读取一下交易文件：

![](https://pic2.zhimg.com/80/v2-f7b5d6e7927199e8a9dbeca17921bf71_720w.webp)

输出结果：

![](https://pic1.zhimg.com/80/v2-ba6bb63e18c6f5a9c0c93a8171f7dfe8_720w.webp)

在回测中我们会写一个批量读取文件的函数，然后打开每日交易数据后，按照行数依次读取，在这里多讲一点点，我们可以观察一下上图的输出结果，其实交易数据并不是连续的，因为交易所只有在有交易产生的时候才推送一次数据，而且是数据快照，我们在做统计套利的策略时，就需要做一些处理，两个方法，一是提前对基础数据进行填充，将缺失的数据以上一个数据源填充，二是在回测程序中去识别交易时间，推送匹配的数据。但是在做其他交易策略时，数据点的缺失影响并不大。

  

## 策略评价指标

量化交易员会使用很多不同的指标来衡量策略的表现，这个跟个人偏好有很大关系（也就是前面说到的个人对策略风险与收益之间的偏好），对EP.CHAN来说他最看重的两个指标是夏普率和回撤，在第二章中已经提到了夏普率，最大回撤和最大回撤期间（maximum drawdown duration）,在这里，我们将介绍这些指标的具体计算方法。

  

夏普率：

通常，如果你计算你的平均收益和标准差收益需要基于一个交易区间T，T可以是按月、按天甚至按小时算，你必须确认你的交易时间跨度里有多个个T，我们记为Nt,那么年化夏普率为：

![](https://pic4.zhimg.com/80/v2-7df14d41365ba264810da78971b2c377_720w.webp)

下面将用程序思维来表达计算方法，设：

value列= 每日日终的持有市值

daily return列 =value（2：end） - value(1 : end -1) / value (1 : end -1 )

每天的回报率都等于（T日终市值-T-1日终市值）/T-1日终市值

excessRet列 = dailyreturn - Rf(无风险收益率）/ 252 （每年252个交易日）

sharperatio = sqrt(252) * mean(excessRet)/std(excessRet)

  

大家可以测试一下每日赚0.01%的夏普率和今天赚0.03%，明天亏0.01%的两种情况下夏普率的差距，就比较能理解夏普率的概念了。

  

最大回撤：

最大回撤就比较简单了，设置一个变量 maxdraw = 0 ，当策略亏损时，就更新maxdraw , 交易结束时，就得到了期间最大亏损值。

最大回撤区间：

同样的设置变量 drawdownduration = 0，maxdownduration = 0

如果 t时刻策略亏损

drawdownduration + = 1

如果 t时刻策略盈利

drawdownduration = 0 (一旦盈利就初始化为0）

更新 maxdownduration

  

最后一部分是使用回撤数据需要注意的地方，作者东西写的比较散，但是都比较实用。

Look-ahead bias 使用未来数据

就是你在T日交易，你使用了T+1日的数据，我曾经有个策略就是这样，最终的结果就是策略盈利很恐怖，类似于如果T+1日涨，策略就在T日买入。基本上就是上帝视觉，你知道了明天市场将发生的情况。

Data-Snooping Bias 过度拟合

前面已经讲到了这个概念，解决方法：1、用新数据测试 2、对策略进行鲁棒性检验

Sample Size 数据集大小

以前有一个同学告诉我他发现了简单移动平均线赚大钱，我就问了他你按什么数据区间测试，他回答按照每日，共才800个数据。我说基本你选择了最优路线就回到了过度拟合中。

  

> 下一篇我们将按照书中的代码实现一个简单的统计套利策略。

我这里随便挑了两个合约，工商银行和建设银行，因为都是国有银行，两个交易序列之间具有较高的相关性，我们统计套利的基础原理是基于价差的回归。我们使用tushare库来直接获取这两个银行2015至今的日收盘价数据，这样可以让整个程序直接在任何一台电脑上奔跑，不用依赖基础数据，建议还是把代码都自己敲一遍。

如果没有太多编程基础的童鞋，可以先看一些PYTHON入门的东西，然后就可以轻松的跟完整本书，我始终认为编程只是技能，够用就行了，重要的交易策略思维，因此整个专栏都不会去死磕技术，如果只是想学习“编程技术”的童靴，可以关注相关技术类专栏，深信都会比我牛逼得多。

我使用的编程工具为：anaconda + spyder ,这里力推anaconda,因为已经集成了科学计算所要用到的几乎所有库。官网地址为：[https://www.anaconda.com/download/](https://link.zhihu.com/?target=https%3A//www.anaconda.com/download/) 下载安装即可。

首先我们引入tushare库，data1储存工商银行的日数据，data2储存建设银行的日数据，接着我们把两个数据的长度打印出来，顺便保存数据看看数据结构，发现如下图：

![](https://pic1.zhimg.com/80/v2-e97ace01eb880584a7db6d3fcbeace70_720w.webp)

两个数据长度相同，但是我试了其他股票有不相同的情况，所以在使用数据时我们还是按照日期来取数，然后发现比较累人的是，dataframe并没有date键值，我们存储数据再重新读取一次。

![](https://pic2.zhimg.com/80/v2-501c67d386e19bad07c692eb09d9e4cd_720w.webp)

这里我们采用一种较为快速的方法，先求出修正后的价差列，这种方法可以在初期做策略回测时使用，因为数据处理较快，也较为方便，后期还是需要按照实盘的程序进行依次识别处理。

  

我们在开始策略前先直观感受一下两者的走势及价差序列：

![](https://pic3.zhimg.com/80/v2-525cd01fcc730cd0bd501fb8292f5456_720w.webp)

![](https://pic4.zhimg.com/80/v2-2cfffb7fd64a585fc6c834258db324bb_720w.webp)

现在我们求出一个spead序列和交易时间trade_day序列：

![](https://pic1.zhimg.com/80/v2-ad0b8b4531d375eb0f4013bbf9cd5d58_720w.webp)

![](https://pic1.zhimg.com/80/v2-13e9424c234710dc5188ac76e70d6458_720w.webp)

  

这里主要实现了一个交易日期匹配，并选择相应的交易数据，求出交易天trade_day和价差序列spread

最后我们求出了两个交易标的之间的相关性Cor = 0.9647，两者之间经验证具有强相关性。

下面是一个回测最简单结构，首先是参数定义，然后是按照交易日循环，接着是在每个交易日去运算并记录结果：

![](https://pic1.zhimg.com/80/v2-c9d3fd56691cf5461d85acb4257d19ac_720w.webp)

这边我们看看output的输出：

![](https://pic3.zhimg.com/80/v2-0995fa287e1dd5b26b998d37515727ca_720w.webp)

我们发现有很多情况第一天刚记为-1，后一天又记为1，这样的表现是因为股票价格剧烈变化，我们一般回测完后都需要去看看策略什么时候进场、出场、是否符合我们开始的设想，以及策略中有没有什么较为极端的情形发生，总之，策略复盘非常重要。

本书这个也是最简单的演示了，我们设计了两个参数 n 和 m ，并且赋予了初值，参数优化指的就是修改n,m来找到最优参数让策略盈利更好，output这边只记录了两个数据，一个是当价差过高或者过低时记录，并且记录此时的交易日。后面就可以用这两个数据计算持仓盈亏及交易，用程序化的思维直接的理解什么是回测，大概的思路是什么。

# 量化交易入门书籍-Quantitative Trading how to Build Your Own Algorithmic Trading Business 05

[![风口上的交易狗](https://pic1.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

3 人赞同了该文章

> 第五章我们直接跳过，因为讲的是如何实盘系统，参考价值较为低。第六章就是展开讲了凯利公式，当然作为入门来讲，用凯利公式做资金管理是没有任何问题的，但是在实际交易中还是要按照实际的数据表现去调整自己的资金配比，找到自己最舒服的公式。

  

第六章：资金和风险管理

  

所有的交易策略都会面临偶然损失，回撤有时候会持续几分钟或者几年。做量化交易，重要的是管理风险，限制回撤幅度到可忍耐范围内，找到最优的杠杆率，最大可能的实现财富增长。

资金及风险管理的核心工具就是凯利公式（KELLY FORMULA）

假设你现在使用多个策略交易，每个策略都有自己的预期收益和标准差。那你面临一个问题，怎么把资金合理的分配到各个策略中呢？

每一个优化问题都有一个初始目标，我们的初始目标就是最大化我们的长期财富。

首先假设：每个交易策略的回报 i 的概率分布为Gaussian，均值为Mi，标准差是Si（i是超额收益的概念）。这个是金融学上一个通常的假设，但是对于实践中来讲并不是非常准去。损失发生的频率比高斯分布的概率大，但是，每一个科学和工程计算都是始于最简单的模型。

  

凯利公式：

![](https://pic2.zhimg.com/80/v2-881fe8c1bbb8ff11764071b1a7f81405_720w.webp)

因为回报i的分布并不是真正的高斯分布，所以交易员喜欢用公式计算出来结果的一般作为杠杆比例，这样更安全，也被称为“half-Kelly”

  

EXAMPLE:基于凯利公式计算最优杠杆率

假设我们的投资策略持有SPY（S&P500指数基金），我们再假设SPY的平均收益为11.23%，标准差为16.91%，无风险收益率比为4%，因此这个投资策略的超额收益为7.231%

  

夏普率 = 7.231%/16.91% = 0.4276

  

凯利公式计算：

![](https://pic1.zhimg.com/80/v2-885f078d34848ed9a4c7071bc63a4b18_720w.webp)

f = 2.528表示，对于这个策略，如果你有10万现金投资，并接受投资收益和标准差的假设，你可以借入资金，买入价值25.28万的SPY，

  

凯利公式不仅可以用来计算最优的杠杆率，还可以用来做风险管理，因为凯利公式是基于平均收益率和标准来计算，当市场剧烈波动时，标准差分母就会变大，那么凯利公式计算出来的杠杆率就会变小。

  

> PS：该公式肯定并不是绝对最优的，在交易多品种时有时候平均分配本金也不错（震惊脸）

# 量化交易入门书籍-Quantitative Trading how to Build Your Own Algorithmic Trading Business 06

[![风口上的交易狗](https://picx.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

8 人赞同了该文章

> 本篇将是Quantitative Trading how to Build Your Own Algorithmic Trading Business的最后一篇的上篇。主要是讲了6个主要的交易策略方向，重点预告：下一本书我将带来**Trading and Exchanges**，这本书堪称是交易圣经吧，每一个做交易的人都需要深入的去理解市场，价格背后的真想。这本书目前还没有任何中文翻译版，非常精彩，特别是对于order book的理解，这本书的读法呢，我就会比较慢，很细致了，希望高度还原原版的精神。

  

均值回归策略VS趋势策略

  

交易策略能够赚钱是基于交易标的的价格形成了回归或者趋势，否则，就是随机游走，交易就不会有盈利。如果你相信股票价格是均值回复的，而现在的价格相对于大多数情况较低，那么你应该现在买入，然后当价格走高时卖出。然而，如果你相信价格是趋势的，如果他现在比较低，那么你就需要卖空，然后等价格走低时平仓。

  

学术研究表面股票价格的走势接近于随机游走，但是这并不意味着在一些特定条件下，不会存在均值回归或者趋势的表现。甚至，在不同的时间跨度下，股票价格可以同时表现为均值回归和趋势。开发策略很重要的一点就是判断股票在一个固定时间跨度下价格表现为趋势或者均值回复。

  

人们喜欢描述价格既有均值回复又有趋势的状态叫做“fractal”，技术分析者或图表分析者喜欢用Elliott Wave理论来分析这个现象，有一些其他人喜欢用机器学习（比如说隐马尔科夫链、卡尔曼滤波，神经网络等）来发现价格是处在均值回复状态还是趋势状态。我本人是未发现普适的理论来判断趋势或均值回复。但是，我发现一个很有用的假设，如果公司的期望收益不发生变化，股票价格都会处在均值回复状态。事实上，金融研究者（Khandani and Lo,2007）已经发现一个简单的短期均值回复模型是可以盈利的，当然，这个策略能否在加上交易成本后仍旧盈利是个问题。

  

尽管均值回复是一个流行的策略方向，但是针对此类策略进行回测时要非常的小心。

1、许多历史交易数据是不精准的

2、数据生存偏差依旧对均值回复策略的表现有很大影响。

  

信息的传播是有过程的，信息传播是逐渐的，这个过程中就会产生趋势，当越来越多的人知道确切的消息，更多的人就会决定买入或者卖出股票，因此让股票向同一方向运动。

  

有一个趋势策略就是：post earnings announcement drift。

这个策略就是当公司盈利大于预期时，就买入股票，反之亦然

  

趋势也可以在群体行为发生时产生：交易者都按照别人的决定来判断自己的交易方向。没有人可以有玩呗的信息来决定交易，每个人都必须对别人的决定做出反映，但是确很难判断别人做出的决定的质量高低。

  

但是悲剧的以上两种情况都很难量化。

  

最后一个均值回复和趋势策略不同点时值得深思的。

  

使用同一种交易策略的交易者们之间是怎么相互影响的？

对于均值回复策略，最典型的影响就是套利机会的交易机会，交易机会会逐渐将至0，比如说当价格过高，于是所有人都会卖出，价格将逐渐降低，回到正常水平，但是对于趋势策略来讲，越多的人使用趋势策略，趋势将会持续，当信息传递越快，交易者优势越大，均衡价格将会更快达到。当达到均衡价格后，交易者就没有盈利机会了。

  

REIGIME SWITCHING（市场转换）

如果我们的母的是预测市场从牛市到熊市的转折点，那么我们需要重点讨论这种市场转换类型。我已经发现了两种市场转换：（1）2003年股票价格以10进制表示 （2）2007年去除报升原则

这种市场转变是监管者的规则发生变化所造成的，但是这种情况是预测不了的，比如说期货市场过热时，我们的交易所提高交易手续费、最大手数，对股指期货的市场结构产生了重大影响。

通常情况下，主要的市场转换类型是：通涨VS通缩、高波动VS低波动、均值回复VS趋势，波动率模式的转换是学术研究工具最容易解释的，比如说GARCH模型。如果谁能够更准确的预测波动率，谁就能成为一个优秀的期权交易员。

学术上试图用模型去解释市场转换，但是会做很多的假设，比如说假设这两种情况发生时股票价格有不同的概率分布。最简单的模型就是假设log(Price)服从正态分布，这两种情况的价格有不同的均值和标准差。

Turning points models是一个数据挖掘过程，所有可能的变量都会影响预测转折点，变量包括现在的波动率、最近一段时间的市场转向，宏观数据、石油价格变化、债券价格变化等。

  

哇哦，突然已经很晚了，今天先更新这么多，明天更新最后的平稳和协整、价格模式。

# 量化交易入门书籍-Quantitative Trading how to Build Your Own Algorithmic Trading Business 07

[![风口上的交易狗](https://pica.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

5 人赞同了该文章

平稳和协整

  

如果股票价格是平稳的，那么均值回归策略将会特别匹配，但是，多数股票价格都不是平稳的，但是如果你交易一组股票（持有空头A，多头B），那么价差可能就是平稳的，A、B股票就是协整的。通常，如果两个股票价格表现出协整，那么他们大概率都是同一领域的公司，如图所示,如果我们要买入套利组合，就是持有多头1手GLD，和空头1.6766手GDX，这个套利组合的价格就构成了一个平稳时间序列，GLD和GDX的组合比例可以通过回归方程计算。

![](https://pic1.zhimg.com/80/v2-05f877451569cee28ca0deb29204bd08_720w.webp)

许多套利交易者对于平稳和协整并不是很熟悉，但是他们都对相关性很熟悉，但是他们是不同的，想过性是指在同一的时间纬度下，他们的股票投资回报是相关的，如果两个股票是正相关，那么他们在大多数情况下是向同一方向运动的，然而，两者之间的正相关关系并没有说明这两只股票的长期表现。特别是，它不能保证股票从长期来看，价格不会越走越远。但是，如果两个股票是协整的，那么（适当加权）未来价格不太可能发散。但他们短期（或每周或任何其他时间段）收益可能是不相关的。

作为例子，A股票和B股票，他们是协整的但不相关，见图。股票B显然没有以A股移动任何相关的方式：有几天他们移动在同一方向上，其他日子正好相反。大多数日子，股票B一点也不动。但请注意，A股和B股之间的价差通常会在一段时间后回到1美元左右。

![](https://pic2.zhimg.com/80/v2-2df3c7e6c5e63bf53640b4e7b31d4689_720w.webp)

  

平稳性并不局限于股票之间的价差：它可以也可以在一定的货币兑换率中找到。例如，加拿大元/澳元（加元/澳元）交叉汇率等。

  

因子模型

金融评论员常说这样的话：“当前市场看好价值股票，“市场关注收益、增长“，”或者“投资者正在关注通胀数字。”我们如何量化这些和其他常见的回报驱动因素？

有一个众所周知的定量金融框架叫做因子模型（又称套利定价理论），试图捕捉不同收益的驱动因素，如收益公司的增长率、利率或市值。这些驱动因素称为因素。数学上，我们可以写股票的超额收益（收益减去无风险利率）R：

![](https://pic4.zhimg.com/80/v2-90ba63359e3d66499f5061397c33d6ef_720w.webp)

最简单的因子模型就是Fama和French 1993年提出可以建立一个三因子模型来解释股票回报率。模型认为，一个投资组合(包括单个股票)的超额回报率可由它对三个因子的暴露来解释，这三个因子是：市场资产组合(Rm− Rf)、市值因子(SMB)、账面市值比因子(HML)。

  

最后书中提了一个一月效应策略（因为美国税收问题，产生一个集体行为）。这个给了我们一个很好的策略开发方向，与其无脑测试各种“技术指标”，不如想想策略思路，归纳与演绎的区别。

  

本书就结束了！今天也是上班第一天！冬奥会收获第一金！



# 量化交易入门书籍-Trading and Exchanges : market microstructure for practitioners 01

[![风口上的交易狗](https://pic1.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

24 人赞同了该文章

> 现在开始正式走上新书：Trading and exchanges : market microstructure for practitioners ，市场微观结构入门书籍，案例丰富(想做高频交易的同学绝对不可以放过的一本书)。

  

通过本章可以对市场的构成有个简单的了解，就像德州扑克，你只有了解了你面对的对手是鲨鱼、傻鱼、疯鱼，才能选择最适合当下的策略。交易市场是人与人博弈的市场。

  

**THE TRADING INDUSTRY**

  

这章主要介绍有哪些交易者、交易标的、交易地点和他们怎么安排交易。

  

**3.1 WHO ARE THE PLAYERS?**

  

当交易者持有多头时，价格上升时盈利，他们会在低位买入在高位卖出。当交易者持有空头时，是卖出他们并没有拥有的资产，他们希望价格降低，能够将交易标的买回来平头寸。

交易市场有买方和卖方，市场中最重要的是流动性，流动性可以让你想买的时候能够交易，而卖方正是提供了流动性，让买方可以买入。本书也将重点探讨买方和卖方之间的博弈以及对流动性的影响。

  

**3.1.1 The buy side**

买方市场中有个人交易者、基金、公司、政府，他们利用市场来解决各自面临的问题。

![](https://pic3.zhimg.com/80/v2-ff1439f0258b90609f246bac0153b2be_720w.webp)

这些问题通常起源于交易市场之外。例如，投资者使用证券市场来解决跨期现金流问题：他们今天有收入，他们希望在未来某时点再收到现金。他们利用市场购买股票和债券将他们的收入从现在转到未来。我们将在第8章中的交易问题中更详细的讨论

许多买方机构是养老基金，共同基金，信托基金，捐赠基金和投资基金。这些机构统称为investment sponsors。investment sponsors 经常聘用投资顾问来管理他们的资金。投资顾问也被称为投资经理或投资组合经理。投资顾问经常雇佣交易员来执行他们的交易。买方交易者总结见上图。

  

**3.1.2 The sell side**

交易行业的卖方包括为买方提供交易服务的做市商和经纪商。这两种类型的交易者都有助于买方在想要交易的时候找到交易对手。

做市商可以让客户在想要交易的时候交易成功（就是做客户的对手盘，然后通过低买高卖盈利，做市商策略就是高频交易模型的原型之一）。我们将在第13章讨论做市商。

相反，经纪人代表客户进行交易。经纪商希望通过找到其他交易对象来和他们的客户进行交易。当成功撮合交易双方时，经纪人通过佣金盈利。我们在第7章讨论经纪人。

许多卖方公司雇佣做市交易员和经纪人进行交易。这些公司因此被称为经纪商或双贸易商。卖方的存在只是因为买方会支付其服务费用。我们必须明白了解买方，因此理解卖方盈利的源头。在随后的章节中我们将讨论买卖双方如何以及为什么交易。表3-2提供了卖方构成。

![](https://pic2.zhimg.com/80/v2-4799a37eba72f08588c3688d2ef12ff5_720w.webp)

**3.2 TRADE FACILITATOR**

许多机构帮助交易员进行交易。本节我们介绍交易所，清算机构和结算代理人，保管人和保管人（实在跟交易关系不是特别大，跳过）

**3.3 TRADING INSTRUMENTS**

本节主要介绍国外交易的标的，跳过，国内目前就股票、期货、机构的话还有债券、互换、期权等

第三章后面的全部略过，主要讲了监管和自律组织。

  

**Orders and Order Properties**

终于来到了订单板块。

订单是一份简单的交易指示。它们详细说明了交易者想要交易的内容，是否买入或卖出，多少，何时以及如何交易，以及期限。订单是交易策略的基本组成部分。下单策略是交易者成功的最重要的决定因素。在正确的时间使用最市场匹配的策略可以决定你的交易是好还是坏。

许多市场通过使用一套规则来匹配所有交易者提交给他们的订单。了解这些如何市场工作并有效使用它们，你必须了解交易者的下单逻辑。

了解订单也可以让你看到流动性的来源。流动性是您想要交易时必须具备的。有些交易者是向市场提供流动性的，其他交易者就会抓住这些流动性进行交易。因此，交易者提供或获取流动性的决定会影响市场。为了理解流动性，您必须了解交易员的订单提交策略。

本章将向您展示订单是什么，交易员如何指定它们，最重要的是，他们拥有哪些属性。交易者选择订单使他们能够最好地解决交易问题。熟悉本章介绍的许多术语。我们将在整本书中使用它们。交易者使用专业词汇和短语来快速准确地与对方进行交流。无论你打算进行交易，还是仅仅想了解交易，你需要熟悉市场命名。尽管订单说明在所有市场中都具有相同的含义，根据交易者提交的市场类型不同，性质也不同。在本章中，我们将假定交易者将订单发送给一个连续交易的市场。

**4.1 WHAT ARE ORDERS, AND WHY DO PEOPLE USE THEM?**

订单是交易员给经纪人和交易所指示安排他们的交易，说明了他们想怎样完成交易。

订单总是指定要交易的标的、交易多少，以及是否买入或卖出。订单也可能包括交易达成时必须满足的条件，最常见的情况限制了交易者接受的价格。其他条件可能会指定多长时间该订单是有效的，订单可以执行时，是否可以部分执行订单，在哪里展示订单，以及如何匹配交易对手方。有些订单甚至指定交易人与谁交易。订单是必要的，因为大多数交易者不亲自安排他们的交易。安排他们自己的交易（通常是交易商）的交易者不会使用命令。他们当场决定他们想要做什么以及如何去做。所有其他交易者必须提前谨慎表达意图。对于许多散户来说，持续监控的时间成本是很高，这些交易者使用订单来代表他们的交易意愿。

一般来说，对市场变化反应最快的交易者条件优于慢速交易者。交易者手动取消订单比使用计算机监控和调整订单的交易员要慢（其实很多时候赢的就是速度）。如果速度是关键，那么交易商和交易商就会发现量化交易者是最成功的交易者。在快速市场交易时，清晰高效的沟通至关重要。经纪商必须确切了解交易者的需求。否则，可能会出现极其昂贵的错误。为了避免错误，大多数交易者使用标准订单来降低他们的失误。

本章介绍标准订单并描述其属性。我们必须首先定义一些基本术语。

**4.2 SOME IMPORTANT TERMS**

交易员通过报出自己的bid（买入）或者ask（卖出）来下单。否则，他们会使用订单将他们的bid和ask报价转达给经纪人、自动交易系统，来安排他们的交易。bid和ask通常包括有关交易者接受的价格和数量的信息。

市场中最高的bid是最优买价。最低ask是最优卖价。交易者还称它们为市场报价和市场报价（或市场询问），因为他们是市场中最容易成交的交易价格。市场报价通常被称为BBO（BEST BID AND OFFER）。最优bid和最优ask之间的价差我们称为NBBO(National Best Bid and Offer)。交易员有时称之为bid/ask spread(这个最常用)，有时候也成为内部价差。

如果这个订单给其他交易者一个交易机会，那么我们就说这个订单提供了流动性。例如，假设乔发出一个以每股不超过100美元的价格购买IBM的100股股份的订单，乔的出价提供流动性，因为其他交易者现在有机会以每股100美元的价格出售IBM股票100股。乔的出价是一天限价订单，因为它仅适用于这一天，并且因为乔限制了他将支付的价格。买家和卖家都可以提供流动性。买家提供流动性时他们的出价让其他交易者有机会出售。卖家提供流动性时，他们的报价让其他交易者有机会购买。在英语中提供流动性经常用“offer”这个词。双重用法可能会让人感到困惑。它可能指的是要约出售物品或提供流动性。如果你想到流动性 - 当你想交易时的交易能力 - 作为一种服务你可以买或卖，使用“offer”这个词是有道理的。例如，做事商通过向客户出售流动性赚钱，（standing order）常规订单是公开报价进行交易。乔的订单将一直持续下去，直到有人以100美元或更少的价格出售给乔，订单将在一天结束时到期，或乔取消它。

# 量化交易入门书籍-Trading and Exchanges : market microstructure for practitioners 02

[![风口上的交易狗](https://pic1.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

4 人赞同了该文章

> 关注的人数过百，谢谢各位，继续我们读书的脚步，这本书写的很细，读起来就是感觉枯燥，但是没关系，大家就当科普读物，读完整个读书笔记，脑子中留下一定印象，随着研究交易的深入，会慢慢的回味理解到这本书的意义。

  

买方和卖方都可以提供流动性，当买方的bids给了其他交易者机会卖出，那么他就提供了流动性，反之亦然。

交易者如果想快速成交，那么就需要市场流动性，如果说如果SUE想卖出100股IBM的股票，价格100，那么她就可以拿下Joe的订单。

当交易成交时对市场价格的影响很小，我们就说这个市场流动性很好，比如说市场中有很多限价单和bid/ask spread很小。

  

订单成交的价格我们称为成交价（trade price），

  

4.3 MARKET ORDERS 市价单

市价单就是会在现有的最优价格立即成交。没有耐心的交易者和那些想抓住市场流动性的交易者都会使用市价单，市价单的成交情况依赖于订单大小和市场现在的流动性。

小的市价单（交易数量少）可以立即成交并且对市场的价格影响较小，买入的订单将直接和最低卖价成交，卖出的订单将直接与最低买价成交。

  

4.3.1 Marker orders pay the spread (市价单承担了bid/ask spread成本)

假设，Amy发出一个买入的市价单，接着又是一个卖出的市价单，完成一个快速的买卖债券的交易。现在市场最优bid = 100，最优ask = 102 ,于是她的买入市价单成交价为102，卖出市价单成交价为100，这来回两笔交易，她就亏损了bid/ask spread。因为Amy付出了流动性成本换回订单的立即成交，所以1/2的spread就是使用市场单所要付出的直接成本。

  

4.3.2 Price Improvement

市价单有时候会在优于此刻的市场最优报价成交，这样的订单我们就说他受到了price improvement，这种情况发生于市场交易者愿意出由于现在市场最优报价的价格，一般这种情况下，市场的spread是很大的，而且新增的市价单少。（美国市场中有floor）

  

4.3.3 Market Impact

大市价单比起小市价单是更难交易的。而且市场中也很难有大订单出现，因为交易者会想如果某人对交易标的的价值有充分的了解度，那么一次性成交大量交易标的，可能会面临巨额亏损（你在和一个比你有信息优势的人交易，亏损概率极高）

为了吸引交易对手，很多不耐心的交易者会提出更激进的价格，比如说买家会提高买入价格来吸引卖家卖给他们，当交易者改变价格使他们的订单成交的话，他们就对市场形成了影响，叫做Market Impact。交易者如果使用large market order就会付出超过1/2 买卖价差的流动性成本。

市价单对市场价格的影响取决于这个市场的流动性，在小的、流动性不好的市场，small order也都是很难被成交的，large order就跟不可能被成交了。相反，在大的、流动性好的市场中，有很多活跃的交易者，这些交易者经常交易数百万美元也不会产生市场价格影响。

  

Market impact example

Martha想要买入3月到期的橙汁期货合约，现在市场的bid 为84.20，ask为84.25。她将她想买入的量平均分为两个market order，其中一个帮martha交易的broker在84.60买入了5个合约，在84.80买入了75个合约，在85.00买入了45个合约，在85.15成交了75个合约，为了满足她的交易需求，Martha的broker提高了市场价格0.9。

  

4.3.4 Execution Price Uncertainty（交易价格不确定性）

因为市场环境变化特别快，使用market order的交易者面临着在比他们预期更差的价格成交。经济学家称这个为execution price uncertainty，导致这个现象的原因就是我们的订单发出到订单达到交易所是有时间差的，这个时间差中bid/ask会发生变化（这也是高频交易要求极高速度的原因，特别是套利交易），为了避免这个风险，交易者会使用限价单(limit order)

  

> 明天我们介绍限价单。


# 量化交易入门书籍-Trading and Exchanges : market microstructure for practitioners 03

[![风口上的交易狗](https://picx.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

6 人赞同了该文章

> 整本书差不多已经到10%，后面会跳过一些内容，加快进度，订单、流动性相关章节就多写写。

  

4.4 LIMIT ORDERS

限价单可以在我们最心仪的价位成交，对于买入的订单，成交价格必须低于或者等于限价单价格，而对于卖出的订单，成交价格必须高于或者等于限价单价格。

在一个连续交易的市场，如果限价单达到交易所，如果没有对手方愿意接受这个价格，那么限价单将不会被交易，而是，一直排在订单列队（limit order book:如下图）里，直到等到合适的价格或者订单被取消。

![](https://pic2.zhimg.com/80/v2-81ded7b433c0299ef9be5a6e42a601f1_720w.webp)

  

一个限价单成交的概率是基于限价单的报价，如果一个买入的限价单报价过低，它就不会被成交。在最高价买入的限价单是最容易被成交的。

  

4.4.1 Limit Price Placement

交易者利用市场价格与限价单的价格差别来区分限价单类型，market是至高于最高卖价和低于最低买价之间。

marketable limit order是指在交易所或者broker那里可以立即成交的订单，marketable limit buy order的报价是优于市场现在的最优报价，broker可以里面向卖方报出现在市场最优报价，然后转手和marketable limit buy order成交。

Marketable limit order有些像市价单，只是限定了价格，这种订单的作用是保护了交易者在市场流动性非常不好的时候付出超过心理预期的流动性成本。

我们看看下图的分类：

![](https://pic3.zhimg.com/80/v2-8431ffe21b769a3e765f124932c2422a_720w.webp)

At the market:即限价单的价格正好等于最优市场报价

In the market:在最优买价和最优卖价之间的区间报价

Behind the markert:低于最优买价/高于最优卖价

![](https://pic3.zhimg.com/80/v2-0789d673204d2b205faf68bf1fb50316_720w.webp)

从订单的激进程度来排序的话：In the market > at the market > behind the market

  

4.4.2 Standing Limit Orders Are Trading Options That Offer Liquidity

  

限价单是提供流动性的，它可以让其他人在报价价位得到交易的机会，卖出的限价单是买入看涨期权，给了别人一个买入持有的机会，交割价格就是订单报价。认识到限价单实际上是一种期权是非常重要的，这可以帮助你了解流动性是什么，为什么broker在市场中是非常重要的，为什么市场是聚集了（交易者喜欢在同一市场交易），交易者如果选择他们的报单策略，为什么速度快的交易者对速度慢的交易者有优势，由于这个概念非常重要，我们需要深入了解限价单所拥有的期权特征。我们首先会探讨限价单和期权合约的区别，然后讨论哪些要素决定了限价单的期权价值。

限价单是一个期权，但是并不是一个期权合约，期权合约是指以一定价格向指定交易者交易标的资产的工具，但是无论这个期权的买入方是否执行期权，他都将付出期权费（买入期权的成本），相比之下，限价单并不指定交易对象，它是面向全部市场，任何想要行使限价单期权的话，只需要向市场发送市价单或者限价市价单。

限价单的期权价值是取决于这个订单对其他交易者的价值，包括价格、订单有效时间、市场价格波动，其中最重要的是价格，如果限价单价格远离市场价格，这个限价单的期权价值就很低，市场价格波动程度也会影响限价单的价值，如果市场波动非常厉害，限价单的价值就越大，波动性会增大利用限价单交易盈利的可能性，在波动率高的市场中，交易者可能没有机会取消他们很有价值的限价单，而给其他交易者机会。

交易者是不喜欢白卖期权给别人的，所以在波动率高的市场中，交易者通常都会设置订单价格远离市场价格。但是限价单也补偿了交易者，限价单的交易者希望不付出成本而成交在市场最优价格，假如他们发送的是市价单，那么可能会支付高于自己预期的价格。

  

4.4.4 The Risks of Using Standing Limit Orders

第一个风险就是限价单可能不会被交易，他们就失去了交易的机会。第二个风险就是订单被成交后后悔，因为一般情况下订单会在市场逆行的时候被成交（比如说市场现在最优卖价是10元，你报价9元卖掉，然后市场快速上扬，你的9元订单被执行，同时市场上涨你开始亏损）

# Trading and Exchanges : market microstructure for practitioners 04

[![风口上的交易狗](https://pica.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

6 人赞同了该文章

交易者经常使用止损订单来控制亏损，比如，价格stan在80 cents买入了10个合约，为了限制持仓损失，Stan会下一个价格为70cents的止损订单，如果合约价格下降到70以下，Stan的broker会立马执行这个止损订单。

但是执行的价格不一定完全等于订单价格，如果合约的价格下降太快，最终的成交价格会低于70。

4.5.2 Stop Orders and Liquidity

止损单会加速价格的变化，在买方或者卖方一边所需要的市场流动性大于市场所能提供的流动性时，市场价格就会发生变化，当市场价格变化激活了止损订单后，这些止损订单很不幸的就变成的单边的流动性需求方（比如说现在持有空单，设定价格买入平仓，市场价格因为买力足，迅速上涨，到达设定价格，那么这个时候止损单就变为了买入的市价单，进一步推高价格）。

趋势交易者在价格上升时买入，价格下跌时卖出，趋势交易者经常使用止损订单来完成交易，而逆市交易者，经常使用限价单来完成交易。

4.6 MARKET-IF-TOUCHED ORDERS

MIT是一个市价单，但是有激活条件，与止损订单不同的是，MIT订单是当价格跌到TOUCH价格的时候买入，当价格涨到TOUCH价格的时候卖出。与限价单不同的是，如果MIT订单一旦激活，他就变为一般的市价单，会在市场目前的最优价格成交。相反，限价单只能在限价或者更好的价格成交。交易者们当他们希望到达目标价位后一定能够成交时使用MIT订单。MIT订单使用的频率并不大，大多数交易者都使用限价单，因为他们想在更好的价格成交。

4.7 TICK-SENSITIVE ORDERS

交易者将价格表现分为uptick/downtick/zero tick

uptick:现在的价格高于上一个tick价格

downtick:现在的价格低于上一个tick价格

zerotick:现在的价格等于上一个tick价格

如果交易者想让自己的交易条件与tick价格变动有关，他们就会使用TICK-SENSITIVE ORDERS.一个买入的down tick order只会在价格变现为down tick或者是zerotick时才会触发成交

4.7.1 Tick-Sensitive Order Properties

Tick交易条件使TSO(TICK-SENSITIVE ORDERS)对市场价格没有影响，因为一个broker持有一个买入的down tick order时是没法通过提高买入报价来吸引卖家，broker必须等待市场中有一个交易对手愿意以更低的价格成交，TSO是提供市场流动性的订单类型。

有一种报价策略是动态限价单策略（dynamic limit order strategies）：如果要买入，报价仅低于最优报价，如果要卖出，报价仅高于最优卖价，如果市场价格发生变动，报价就随之改变，但是这个报价策略受到市场交易规则的限制，一般交易所不允许高频率撤单，然后重新报价，这个时候tick-sensitive order就会排上用场。

4.11.1 Spread Orders

当交易者想买入标的A的时候，同是卖出标的B，就可以使用套利订单，国内期货市场中有一些交易所提供的标准套利订单，

本章还讲了一些其他的order类型，但是国内交易市场基本不支持这些订单类型。

下一张进入市场结构

# Trading and Exchanges : market microstructure for practitioners 05

[![风口上的交易狗](https://picx.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

12 人赞同了该文章

交易机制决定了市场结构，他们决定谁可以交易，交易什么，交易时间、地点和如何交易等。他们也决定了交易者可以看到订单、报价等信息的成都。

市场结构是非常重要的，它决定了交易者在市场中能知道和做什么。

为了达到有效的交易，你需要知道每个你所交易市场的结构，在A市场中有效的交易策略可能在B市场中就不适用了，因为他们有不同的市场机构。

你必须理解市场结构和它是怎么影响交易者的行为，进一步了解市场的流动性、价格影响、波动和交易盈利。因为市场结构影响这交易者的行为，这也决定了交易市场是不是具有流动性，是不是价格会充分表现信息。

我们会介绍和描述一个框架来分类不同的市场结构。这些分类将帮助你认识到市场的相同和不同之处。

5.1 OVERVIEW

交易发生在交易时段里，分为连续竞价和集合竞价。

接下来就介绍了连续竞价和集合竞价，跳过

5.3 EXECUTION SYSTEMS

每个市场都有将买家和卖家进行匹配的流程，而这个匹配成交匹配系统决定了市场的特性，分析师们经常通过这个规则给市场分类。三种主要的市场类型是：quote-

driven markets（报价驱动）, order-driven markets（订单驱动）, and brokered markets（中介市场）

5.3.1 Quote-driven Dealer Markets

在纯粹的报价驱动市场中，dealer（场内交易员）参与所有的交易，任何人想要交易的话都必须通过dealer，优秀的交易者会跟dealer讨价还价。而dealer之间也是经常相互交易的，但是散户（Public trader）之间是不能相互交易的。比如说，散户Barbara想买一个证券A，她必须找到一个dealer愿意买给她，此时，散户Saul想卖出证券A，但是这两个散户之间是不能直接交易的。这就是一个报价驱动市场，因为dealer们报出他们想要买入和卖出的价格，这也被称为dealer market，因为dealer提供市场所有的流动性。

尽管在某些报价驱动市场中，在没有dealer愿意交易的情况下，交易者之间可以相互交易，但是市场大部分流动性还是dealer提供的，纳斯达克就是一个这样的市场。

在大多数报价驱动市场中，dealer和他们的客户会彼此相互选择，客户或者客户的代理会选择提供最优报价和服务的dealer.dealer只和他们认为信任他们并且信用良好的交易者交易。与dealer没有建立这种联系的交易者们可以通过broker来保证他们对交易的履行，很多dealer是特别的服务于一些散户或者大型的机构投资者。大多数dealer都是试图避免与那些具有信息优势的交易者交易，因为他们会输给具有信息优势的交易者（举个栗子，如果你是个具有预测明天涨跌能力的交易者，你买入，市场必然涨，那么你的交易对手dealer每次都必然亏损）。

报价驱动市场非常普遍，几乎所有的债券、货币和一部分股票交易市场，都是报价驱动。 纳斯达克股票市场，伦敦证券交易所等都是报价驱动市场的类型。

  

5.3.2 Order-driven Markets

在订单驱动市场中，买方和卖方之间是直接进行匹配交易的。这些市场会设定一些交易规则来安排交易，这使交易有序。

订单驱动市场就是一个拍卖市场，在拍卖市场中，交易规则保证买家可以找到合适的最低价格，卖家可以找到最高卖价。经济学家称这个过程是一个价格发现过程，在订单驱动市场中，交易者可以提供或者获取流动性，那些表明自己交易条件的交易者是向市场提供流动性，而接受这些交易条件的交易对手就是获取流动性的一方。

订单驱动市场的市场结构差距很大，因为他们处理如何撮合的规则不一样，在oral auction中，交易者们在场内面对面的交易，交易规则是决定他们谁可以谈判交易和什么时候谈判交易，这也叫做公开拍卖市场，因为交易者们公开报出他们的买价和卖价。而另外的市场使用基于规则的订单匹配系统，所有的订单都有交易者发到交易中心并进行撮合。

订单驱动型市场使用的规则非常重要，因为他们影响市场流动性。 一些交易规则鼓励交易者提供流动性，而有些正相反。 在第6章中，我们将考虑在订单驱动型市场中交易规则如何影响交易策略的。

由于订单驱动的市场使用订单优先规则来安排交易，交易者不能选择与谁交易。为了防止交割失败，以订单为导向的市场需要精心设计的机制来确保他们所有的交易者都值得信赖。 我们在第7章来讨论。

5.3.3 Brokered Markets

Broker在市场中同时积极寻找可以进行交易匹配的买家和卖家，但是大部分都是当broker收到订单需求时，broker也会经常对他们的客户提供一些交易建议。

这个市场的特性是由broker来寻求流动性，这些市场通常是非公开市场，这些市场的流动性都不高。比如说大宗交易的市场，订单交易并不会特别频繁，但是对交易对手履行交易的信用是非常在意的。

5.3.4 Hybrid Markets

混合市场的意思就是允许多种交易机制的存在。结合上述几个市场的特性。

# Trading and Exchanges : market microstructure for practitioners 06

[![风口上的交易狗](https://picx.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

3 人赞同了该文章

订单驱动市场利用交易规则来撮合交易，我们接下来会了解这些市场是如何运作，以及基于此市场机构下对交易策略的影响。

6.1 ORAL AUCTIONS

许多期货、期权、股票交易市场使用持续双边口头报价方式来交易合约和标的，世界上最大的口头报价市场是美国长期政府债券交易市场，在这个市场中，芝加哥交易所经常会吸引到超过500个场内交易者，这可能是流动性最好的的交易市场了。

在口头公开报价中，交易员在交易所内面对面的交易。有些交易员会喊出他们的买价和卖价来吸引其他的交易者，其他的交易员会仔细听是否有他们想要的买价或者卖价，大多数交易者两种行为都有，如果一个买家接受一个交易，他会喊出“take it”(国内债券市场也一样，如果是一方主动的接受了卖家的报价，那么成交就会显示take，市场好的时候，交易员就会跟中介报价直接说take,take,take),如果是卖家接受了买家的报价，那么卖家就会喊出“sold”,当交易员们喊出买价或者卖价，他就在提供流动性，如果是接受买价或者卖价，他就在获取市场流动性。

交易员们必须遵守市场交易规则，这些交易规则保证所有交易者都被公平对待，提高信息传递效率，使撮合交易高效。

口头公开报价的第一条规则是公开喊价规则。 交易者必须发布所有的买价和卖价，以便所有的交易者都可以采取行动。 这种设计确保所有交易者能够公平参与市场。 在大多数口头公开报价市场中，任何交易者可以接受另一个交易者的出价或报价。 第一个交易者接受报价或报价会进行交易。 公开喊价规则还规定，交易商必须公布成交信息，以便所有的交易者都能知道他们的交易情况。 这些信息有助于交易者评估市场状况。 它还保护客户免受不诚实的经纪人可能会试图私下安排交易。

6.1.1 Order Precedence Rules

在oral auctions中，价格始终优先，第二优先规则根据市场不同而不同，期货市场使用时间优先。 美股股票交易所使用公开订单优先，然后时间优先。

6.1.1.1 Price Priority

价格优先规则给了报出最优价格的交易员优先成交权，其他交易者不能接受其他inferior price(比最优价格更差的价格)，买家只能在最低的卖价成交。

6.1.1.2 Time Precedence

在相同的报价下，最先报价的订单会优先成交，时间优先的交易规则鼓励交易者们更激进的报价来获取成交的机会。

6.2.1.1 Order Precedence Ranking Example  

![](https://pic1.zhimg.com/80/v2-68fbe549bf2d86a8d49e68a4dee2821c_720w.webp)

假设交易者把上述订单发送至了一个AUCTION市场，这个市场使用的是纯价格-时间优先规则，排列如上图，Sol的卖单在卖方报价优先，因为它提供了最低价格。 Bif的买单在买方方面的优先级最高，因为

这是一个市场订单。 Bea的订单和Ben的订单的价格相同，但是，Bea的订单比Ben的订单有时间优先，因次它到了第一。

6.2.2 The Matching Procedure

市场会第一时间去匹配排在最优先位置的买单和卖单，如果一个买家愿意接受最优卖价，那么这个交易将会被撮合，如果买量小于现在最优卖价的量，那么这个订单将会被完成成交，否则，市场将会和次优报价进行撮合成交。

6.2.2.1 Order-matching Example

假设交易者们把上面栗子中订单发送至了一个10：30集合竞价的市场，市场将会按照下面的方式撮合：

1、首先sol的订单以19.8卖出1单位会和Bif的市价单成交。那么bif还剩3个单位市价单。

2、Bif身下的三个单位订单将会与SUE的订单成交，成交价格20.0。

3、Sue剩下的三个订单将会与Bob的买入订单成交，成交量2，交易价格20，SUE和BOB能够成交的原因在于，BOB愿意付出比SUE订单价更高的价位。

4、最后SUE的一个订单将会与BEA成交，成交价格20.0.

剩下的订单将不会被撮合，因为BEA的买价已经低于SAM的卖价，下图总结了这些交易。

![](https://pic4.zhimg.com/80/v2-eb09b6177177fe5be4c608d0cc22733b_720w.webp)

下图列明了剩余未交易的合约。

![](https://pic2.zhimg.com/80/v2-946dd77ddc09f8dd92803fd2fc972c7d_720w.webp)

买单和卖单现在已经分开列明，如果现在市场开始持续竞价，市场报价就为：20 买入/4 单位，20.1 卖出/2单位。

编辑于 2018-05-13 11:55

作者：风口上的交易狗  
链接：https://zhuanlan.zhihu.com/p/44563088  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  
  

量化交易的第一步就是回测，还记得我的一个回测程序就是简单的写一个双均线策略，里面用了一个很多个vector(C++)来记录交易数据、还有成交信息等等。基本上就是面向过程的编程方法，没有做太多的抽象，很长一段时间里写新策略回测的成本非常高（并非专业计算机专业出身，所以啊技术高手可以绕道~），后来用老师写的平台，因为非开源，很多bug调来调去就是本身底层代码的原因，又因为封装了，报个内存错误，真的是欲哭无泪，这里VNPY的逻辑和体系是比较完整和易懂的，我自己借用了很多VNPY的源代码，改出了适合自己数据和交易模式的回测平台。网上大部分文章都是基于结构去宏观分析，对于小白门入手还是有一定难度的，所以这篇文章会从应用，将从最小的一步开始讲起，不涉及到模块就不展开，希望每个看完整篇文章的人都能够基于VNPY做回测。  

要了解一个系统，当然是手把手的去一步步调试看看。

首先去GITHUB上搜索VNPY，下载最新版本。然后按照官网的教程安装（贴不了链接，知乎会盾）。  

![](https://pic3.zhimg.com/v2-838012f48572e1f8ff90f0b6316a4ed6_b.jpg)

  

大家可以看一下，如果把回测相关的模块抽出来（没有加风控、优化等，其中数据读取是重新写了）出现其实只涉及到很少的几个py文件，所以回测改起来没有那么难，但是本篇文章还是基于最原始的VNPY回测去写，写完之后大家自己去改动。

所有量化交易的第一步都是看数据。打开\vnpy-master\examples\CtaBacktesting文件夹。

![](https://pic2.zhimg.com/v2-6d653509a162d29a092ab7e4fcd60105_b.jpg)

打开其中的loadCsv.py:

![](https://pic2.zhimg.com/v2-463d80bbe2bbf3c9750f6ce6552141bd_b.jpg)

再看看loadMcCsv函数在做什么，于是乎跳转到ctaHistoryData.py，是将我们本地的IF0000_1MIN.CSV和RB0000_1MIN.CSV的数据导入到MONGODB本地数据库中。

这个时候下载一下stodio 3T这个软件，我们可以看到本地数据库可视化。

  

![](https://pic1.zhimg.com/v2-8fd237bd7db421222ff304d0d5aca128_b.jpg)

里面就有了VnTrader_1MIN的数据啦，再进一步打开看看

![](https://pic4.zhimg.com/v2-c9630a19bf6aedcc050ce8900b5fc15f_b.jpg)

![](https://pic2.zhimg.com/v2-1d7c801e6ad2e7a6683ec0b899821689_b.jpg)

可以看到数据有这么多关键字：交易时间、交易量、交易合约标的、最高价、最低价、收盘价等。  

[runBacktesting.py](https://link.zhihu.com/?target=http%3A//runBacktesting.py)

  

**from** vnpy.trader.app.ctaStrategy.strategy.strategyKingKeltner **import** KkStrategy

  

这里是你要回测的策略引入，打开\vnpy-master\vnpy\trader\app\ctaStrategy\strategy文件夹

![](https://pic1.zhimg.com/v2-3fb44cb0b699f27ae867910d0fa67304_b.jpg)

我们只需要把import后面的策略名改掉就可以引入其他策略，所以你的其他新策略也都放在这个文件夹里就行。接着回到runBacktesting.py文件：engine = BacktestingEngine()

这里创建回测引擎，我们看看回测引擎对象有什么，打开看看ctaBacktesting.py.

![](https://pic3.zhimg.com/v2-0228dd534ad24cd048bd5a0ec31ef8e2_b.jpg)

基本上与回测相关的基本参数初始化、函数都在回测引擎类中定义了，接着回到runBacktesting.py文件。

![](https://pic4.zhimg.com/v2-433cf249f2ebee6632d9c396c451c303_b.jpg)

对回测的相关参数进行了设置，大家可以看看回测引擎类，里面有很多参数设置的函数，可以根据自己的需要调配，这里设置了回测数据的起始日期，滑点（用于策略表现计算），合约大小，最小tick等。

![](https://pic1.zhimg.com/v2-d12fdfe18782fc87d9d547352f6b8e14_b.jpg)

接着初始化策略对象，又回到ctaBacktesting.py，找到这个initStrategy函数，没什么东

![](https://pic4.zhimg.com/v2-26363c87e6f5363bbc64090fb1344b4b_b.jpg)

接下来重中之重来了！

![](https://pic2.zhimg.com/v2-6077afbcca74803849432cc1f7de7e71_b.jpg)

我们跳转到ctaBacktesting.py，找到里面的runBacktesting()函数

![](https://pic1.zhimg.com/v2-8d3ac1638eefb1cf95e22763b6284e58_b.jpg)

接着打开loadHistoryData()这个函数，我们如果要修改读取数据的路径的话，就在这个函数里做修改。

接着载入需要的回测数据：

![](https://pic3.zhimg.com/v2-f3fc871a5bd4e6cdadb8c842733da0a2_b.jpg)

flt就是选取回测最开始的日期到策略开始日期间的数据，并且按照日期顺序排列

![](https://pic4.zhimg.com/v2-f0c0d04eaaf2bdaec384f3703d8c3fb7_b.jpg)

将读取的数据都存入initData列表中，这个是策略初始化所需要的数据，比如说双均线策略中，你的快均线和慢均线的第一个值是需要一定初始数据量测算的，比如说需要20天之类。

![](https://pic2.zhimg.com/v2-87f08c4eb48101435a9fdda342cf8941_b.jpg)

这里就是载入回测交易所需要的数据，可以说是真正交易的回测数据。

![](https://pic1.zhimg.com/v2-cf9636199ecadf13fad71bd3b96497a8_b.jpg)

这里根据我们在runBacktesting里面设置的回测模式（tick还是bar模式），dataClass记录回测数据类型，func记录回测读取的数据函数。这里我们深入看一下回测数据类型，数据类全部定义在vtObject.py中，包括tick类数据，bar，成交、订单数据类等，如果我们要根据我们自己的数据类型定义的话，就可以在这个py文件中去增加写就行了，比如说为了方便价差交易回测，我就自己增加了一个spreaddata类，我们可以具体看看其中bar类的数据，定义了最高、最低、收盘价等，里面用了很多像EMPTY_FLOAT的常量定义，这些常量都在vnpy.trader.vtConstant.py文件里，如果你有什么新的常量都可以在里面添加定义。

![](https://pic1.zhimg.com/v2-ba52d984263e4c4959133f7148b49c18_b.jpg)

![](https://pic1.zhimg.com/v2-d6da5f1b61b183c2a1c207d70eb6bb3c_b.jpg)

继续我们回到runBacktesting函数里，继续执行。

![](https://pic3.zhimg.com/v2-c6a122e7f0c6dfe0e6cd443008089b0a_b.jpg)

这里进行策略初始化，我们看看都初始化了什么，打开strategyKingKeltner.py。

![](https://pic2.zhimg.com/v2-41a2baeb93e312c45a194f180d65d3b5_b.jpg)

这里通过回放initData初始化策略参数，打开self.onBar

![](https://pic3.zhimg.com/v2-be6f1878c50e1f911f8144b873993af6_b.jpg)

看看bg的初始化：self.bg = BarGenerator(self.onBar, 5, self.onFiveBar)

![](https://pic4.zhimg.com/v2-3aa012fc7b179223d1416c74a74ba84f_b.jpg)

BarGenerator就是K线合成器，可以合成N分钟K线。

打开**def** **updateBar**(self, bar)函数

我们可以看到如果self.xminbar == None的时候，就用第一个BAR去初始化它，接着如果X分钟已经走完的时候。

![](https://pic3.zhimg.com/v2-87e5984a6073e330654b471ea8e18812_b.jpg)

我们向onXminBar函数去推送一个X分钟BAR数据，然后再吧xminBar设置为None.因为前面初始化bg时传入的onXminBar的函数为KKstrategy的onFiveBar。

# VNPY应用入门/进行量化策略回测02（不谈理论，只谈应用）

[![风口上的交易狗](https://picx.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

13 人赞同了该文章

喜欢周五写写笔记啊。。。。。。  
  
  
上次讲到策略初始化，开始读取了第一根5Min Bar。  
回到strategyKingKelter.py中的onFiveBar函数：  

![](https://pic4.zhimg.com/80/v2-d59b79ff80342c281d032427f116820f_720w.webp)

  
在每根Bar数据开始计算之前，如果遇到之前有没有成交的订单，都直接取消掉，这块跟你自己的策略如何设置有关系，可以进行修改。  
接下来初始化

- am:[http://self.am](https://link.zhihu.com/?target=http%3A//self.am) = ArrayManager()

在ctaTemplate.py中找到ArrayManager()函数，我们可以看到这个是个K线管理工具

![](https://pic2.zhimg.com/80/v2-ba0cb62b0a764d99e6f056d3f3545dcd_720w.webp)

  
储存最近的100个bar值，这个你可以自己定义内存长度，另外有最高、最低价等序列，方便回测计算。（你想储存的任何序列值都可以在这里定义）  

- am.updateBar(bar)

![](https://pic4.zhimg.com/80/v2-b36bc5e50fa30d57bc5e634de679a683_720w.webp)

  
如果还没有存储够100个Bar值就不更新，如果超过size = 100，那么就把最初的Bar移除，把新的bar加入进来。

- **if not** am.inited:  
    **return**

在am初始化前不做下面执行，这里的话回顾上我们上篇笔记，其实还在策略初始话init阶段，如果初始化数据超过了am的初始化数据量，程序会继续向下执行，但是并不会产生交易，因为在下单环节，还会识别现在是不是trading状态，这个马上会讲到。这个时候我们回到strategyKingKeltner.py的onInit都执行完毕后，再回到上一层runBacktesting函数里，继续执行。

![](https://pic3.zhimg.com/80/v2-aaff559cfc383cea99611cbddb088822_720w.webp)

  
  
这个时候我们的策略初始化就完成了，接着我们将strategy,trading 设置为True，接着执行onStart()函数  

![](https://pic3.zhimg.com/80/v2-ea6ab7e6fabd87b96cd76e96eb12617a_720w.webp)

  
  
这里默认没有什么内容，如果你想在策略启动前做些什么策略动作，可以在这里添加。  

![](https://pic3.zhimg.com/80/v2-184e0058342b765c78cb03e0fc238b36_720w.webp)

  
接着开始回放数据，进行真正的策略交易阶段。dbCursor就是上篇笔记中我们记录的从数据库中取出交易数据代码。继续执行func（data）, func = self.newBar.  

![](https://pic1.zhimg.com/80/v2-2d4d7881e45dc0bc5bc85395fcbcd2fc_720w.webp)

  
self.crossLimitOrder()就是会在每个新的bar推送过来的时候，先去模拟撮合限价单，这里可以写自己的想要的撮合成交条件。

![](https://pic3.zhimg.com/80/v2-14352157b5bfa6e036d22d953e859f3e_720w.webp)

  
先根据是bar数据还是tick数据定义出撮合成交的价格（buycrossprice,sellcrossprice等）

![](https://pic4.zhimg.com/80/v2-15bfd355b199b33615e552d9876db38f_720w.webp)

  
  
遍历限价单字典中所有的限价单，如果发生了成交，那么新建一个trade类对象

![](https://pic4.zhimg.com/80/v2-f69ced843744fc4b38bcc64ab8d85a6f_720w.webp)

  
如果发生了成交，那么记录下交易价格（trade.price）和现在的策略持仓（strategy.pos）,将成交对象(trade)添加进入trade列表（tradeDict），之后我们会用trade列表来计算策略表现

![](https://pic1.zhimg.com/80/v2-e4af57c4f7ec9a1b55fbe18d46d667cc_720w.webp)

  
如果这个限价单成交了，那么就从限价单列表里删除它。

![](https://pic2.zhimg.com/80/v2-025216607165f30c16c0e1519b5409e1_720w.webp)

接着我们回到ctaBacktesting.py里面的runbacktesting函数，接着撮合停止单，然后执行self.strategy.onBar(bar)，就跟我们开始初始化策略时执行的路径一样了：

  

onBar -> bg.updateBar(bar) -> self.onXminBar(self.xminBar) (这里调用KK策略的onFiveBar)

  

本篇文章就写到这里，下一篇写发送Order和最后策略收益等测算的代码逻辑。

# VNPY应用入门/进行量化策略回测03（不谈理论，只谈应用）

[![风口上的交易狗](https://picx.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

今天来到回测的第三篇详解：

上次我们讲到现在开始策略回测数据，进入到真正的策略模块，调用 def onFiveBar(self, bar)

```text
for orderID in self.orderList:
        self.cancelOrder(orderID)
self.orderList = []
```

这里是将前面没有成交的委托单全部取消，可以根据自己的策略进行修改。

接着就是更新K线数据和计算指标数值：

```text
    am = self.am
    am.updateBar(bar)
    if not am.inited:
        return
    self.kkUp, self.kkDown = am.keltner(self.kkLength, self.kkDev)
```

策略分为三种情况进行执行：无持仓/多仓/空仓

- 无持仓 POS=0 时，发送OCO(One Cancel Other)委托单：  
    self.intraTradeHigh = bar.high self.intraTradeLow = bar.low self.sendOcoOrder(self.kkUp, self.kkDown, self.fixedSize)

这里我们看看什么是OCO订单：

```text
    self.buyOrderIDList = self.buy(buyPrice, volume, True)
    self.shortOrderIDList = self.short(shortPrice, volume, True)
    self.orderList.extend(self.buyOrderIDList)
    self.orderList.extend(self.shortOrderIDList)
```

同时发送做空和做多的订单，在满足条件的时候开仓。

- 多仓 POS>0 时：  
    elif self.pos > 0: self.intraTradeHigh = max(self.intraTradeHigh, bar.high) self.intraTradeLow = bar.low l = self.sell(self.intraTradeHigh*(1-self.trailingPrcnt/100), abs(self.pos), True) self.orderList.extend(l) 我们计算好出场的价格，发送sell订单。最后一种情况，当POS<0时，我们计算好平仓价格，发送cover订单。 整个策略模块就结束了，这里我们展开看一下在回测中的订单流情况，我们看看在多仓时是如何执行下单的：  
    l = self.sell(self.intraTradeHigh*(1-self.trailingPrcnt/100), abs(self.pos), True)

这里调用了ctaTemplate.py的sell函数:

```text
def sell(self, price, volume, stop=False):
    """卖平"""
    return self.sendOrder(CTAORDER_SELL, price, volume, stop)
```

接着我们发现它继续调用了sendOrder函数：

```text
def sendOrder(self, orderType, price, volume, stop=False):
    """发送委托"""
    if self.trading:
        # 如果stop为True，则意味着发本地停止单
        if stop:
            vtOrderIDList = self.ctaEngine.sendStopOrder(self.vtSymbol, orderType, price, volume, self)
        else:
            vtOrderIDList = self.ctaEngine.sendOrder(self.vtSymbol, orderType, price, volume, self) 
        return vtOrderIDList
    else:
        # 交易停止时发单返回空字符串
        return []
```

这里分为两种情况：是停止单还是非停止单，接着分别调用sendStopOrder或者sendOrder，这里需要注意的是，分为两种引擎，回测和实盘，调用的发单函数是不一样的，现在回测中调用的是ctabacktesting里的下单函数，我们看一看：

```text
def sendStopOrder(self, vtSymbol, orderType, price, volume, strategy):
    """发停止单（本地实现）"""
    self.stopOrderCount += 1
    stopOrderID = STOPORDERPREFIX + str(self.stopOrderCount)
    so = StopOrder()
    so.vtSymbol = vtSymbol
    so.price = self.roundToPriceTick(price)
    so.volume = volume
    so.strategy = strategy
    so.status = STOPORDER_WAITING
    so.stopOrderID = stopOrderID  
    if orderType == CTAORDER_BUY:
        so.direction = DIRECTION_LONG
        so.offset = OFFSET_OPEN
    elif orderType == CTAORDER_SELL:
        so.direction = DIRECTION_SHORT
        so.offset = OFFSET_CLOSE
    elif orderType == CTAORDER_SHORT:
        so.direction = DIRECTION_SHORT
        so.offset = OFFSET_OPEN
    elif orderType == CTAORDER_COVER:
        so.direction = DIRECTION_LONG
        so.offset = OFFSET_CLOSE           
    # 保存stopOrder对象到字典中
    self.stopOrderDict[stopOrderID] = so
    self.workingStopOrderDict[stopOrderID] = so 
    # 推送停止单初始更新
    self.strategy.onStopOrder(so)          
    return [stopOrderID]
```

主要就是更新stopOrderDict和workingStopOrderDict。所有的策略逻辑及下单、撮合到这里就全部将完了，下面我们看看关于策略表现的代码块。 回到runbacktesting文件，执行最后一条语句：engine.showBacktestingResult() 调用BacktestingEngine的showBacktestingResult函数：

```text
d = self.calculateBacktestingResult()
```

这个函数中就会配对计算，基本上不用做什么修改，照搬就行，不过还是需要大家仔细读一下代码，到底是如何计算的，不难，这里就不一一解释了。

最后我们看看如何对参数进行优化，打开runOptimization.py

```text
setting = OptimizationSetting()                 # 新建一个优化任务设置对象
setting.setOptimizeTarget('capital')            # 设置优化排序的目标是策略净盈利
setting.addParameter('atrLength', 12, 20, 2)    # 增加第一个优化参数atrLength，起始12，结束20，步进2
setting.addParameter('atrMa', 20, 30, 5)        # 增加第二个优化参数atrMa，起始20，结束30，步进5
setting.addParameter('rsiLength', 5)            # 增加一个固定数值的参数
```

可以看到显示定义了一个优化对象setting,然后加入自己想优化的对象，大家可以执行一下默认的runOptimization.py

# VNPY应用入门-实盘逻辑分析

[![风口上的交易狗](https://picx.zhimg.com/v2-7f85e105dd4f9920010460ef945afb05_l.jpg?source=172ae18b)](https://www.zhihu.com/people/dogtrade)

[风口上的交易狗](https://www.zhihu.com/people/dogtrade)

[​](https://www.zhihu.com/question/48510028)

西南财经大学 金融工程硕士

16 人赞同了该文章

还有很多功能再以后整理为笔记，这篇是近期最后更新关于VNPY的文章了。

  

实盘逻辑：

首先打开runCtaTrading.py,主函数执行： runChildProcess()

```text
# 创建日志引擎
le = LogEngine()
le.setLogLevel(le.LEVEL_INFO)
le.addConsoleHandler()
le.addFileHandler()

le.info(u'启动CTA策略运行子进程')

ee = EventEngine2()
le.info(u'事件引擎创建成功')

me = MainEngine(ee)
me.addGateway(ctpGateway)
me.addApp(ctaStrategy)
le.info(u'主引擎创建成功')

ee.register(EVENT_LOG, le.processLogEvent)
ee.register(EVENT_CTA_LOG, le.processLogEvent)
ee.register(EVENT_ERROR, processErrorEvent)
le.info(u'注册日志事件监听')
```

首先这里我们初始化了三个引擎：日志引擎（用来记录交易日志）、事件引擎和主引擎。

日志引擎很简单，我们就不展开了，在temp文件夹下会生成每次运行的日志文件，比如说我们随便打开一个.log文件就可以看到所有的日志记录情况。

事件引擎在eventEngine.py中定义，我们可以看到有EventEngine和EventEngine2两种事件驱动引擎，两个版本的区别在于定时器通过不同的方式实现，这里我们看到初始化的是EventEngine2。

接着初始化主引擎，在vtEngine.py中定义了四个类，我们看看主引擎的初始化参数有哪些： def **init**(self, eventEngine): """Constructor""" # 记录今日日期 self.todayDate = datetime.now().strftime('%Y%m%d')

```text
# 绑定事件引擎
    self.eventEngine = eventEngine
    self.eventEngine.start()

    # 创建数据引擎
    self.dataEngine = DataEngine(self.eventEngine)

    # MongoDB数据库相关
    self.dbClient = None    # MongoDB客户端对象

    # 接口实例
    self.gatewayDict = OrderedDict()
    self.gatewayDetailList = []

    # 应用模块实例
    self.appDict = OrderedDict()
    self.appDetailList = []

    # 风控引擎实例（特殊独立对象）
    self.rmEngine = None

    # 日志引擎实例
    self.logEngine = None
    self.initLogEngine()
```

在三大引擎初始化完毕以后，连接CTP接口。

```text
me.connect('CTP')
le.info(u'连接CTP接口')
```

接着调用主引擎下的connect函数：

```text
def connect(self, gatewayName):
    """连接特定名称的接口"""
    gateway = self.getGateway(gatewayName)

    if gateway:
        gateway.connect()
        # 接口连接后自动执行数据库连接的任务
        self.dbConnect()
```

接着gateway.connect()调用ctpGateway类的connect函数：

```text
def connect(self):
    """连接"""
    try:
        f = file(self.filePath)
    except IOError:
        log = VtLogData()
        log.gatewayName = self.gatewayName
        log.logContent = text.LOADING_ERROR
        self.onLog(log)
        return

    # 解析json文件
    setting = json.load(f)
    try:
        userID = str(setting['userID'])
        password = str(setting['password'])
        brokerID = str(setting['brokerID'])
        tdAddress = str(setting['tdAddress'])
        mdAddress = str(setting['mdAddress'])

        # 如果json文件提供了验证码
        if 'authCode' in setting: 
            authCode = str(setting['authCode'])
            userProductInfo = str(setting['userProductInfo'])
            self.tdApi.requireAuthentication = True
        else:
            authCode = None
            userProductInfo = None

    except KeyError:
        log = VtLogData()
        log.gatewayName = self.gatewayName
        log.logContent = text.CONFIG_KEY_MISSING
        self.onLog(log)
        return            

    # 创建行情和交易接口对象
    self.mdApi.connect(userID, password, brokerID, mdAddress)
    self.tdApi.connect(userID, password, brokerID, tdAddress, authCode, userProductInfo)

    # 初始化并启动查询
    self.initQuery()
```

首先是读取CTP_connect.json文件路径，即在CtaTrading中的文件，这个文件里面其实就是定义了userID、password、brokerID和交易与行情的服务器地址，使用模拟盘的盆友可以登录simnow注册，就会获得这四个参数，配置进CTP_connect.json中就行。然后创建行情和交易接口对象。 这里我们主要看下行情接口：

```text
self.mdApi.connect(userID, password, brokerID, mdAddress)
```

这里调用CtpMdApi类的connect函数：

```text
def connect(self, userID, password, brokerID, address):
    """初始化连接"""
    self.userID = userID                # 账号
    self.password = password            # 密码
    self.brokerID = brokerID            # 经纪商代码
    self.address = address              # 服务器地址

    # 如果尚未建立服务器连接，则进行连接
    if not self.connectionStatus:
        # 创建C++环境中的API对象，这里传入的参数是需要用来保存.con文件的文件夹路径
        path = getTempPath(self.gatewayName + '_')
        self.createFtdcMdApi(path)

        # 注册服务器地址
        self.registerFront(self.address)

        # 初始化连接，成功会调用onFrontConnected
        self.init()

    # 若已经连接但尚未登录，则进行登录
    else:
        if not self.loginStatus:
            self.login()
```

这里完成账户登录，但是并没有开始获取数据。

```text
cta.loadSetting()
```

调用ctaEngine.py中的loadSetting函数：  
def loadSetting(self): """读取策略配置""" with open(self.settingfilePath) as f: l = json.load(f)

```text
for setting in l:
            self.loadStrategy(setting)
```

这里读取setting的文件路径为'\examples\CtaTrading\CTA_setting.json',我们需要在这个文件中去定义我们想要实盘交易的策略，这里我们仅配置一个策略，更改品种为IH1810：

```text
{
    "name": "king keltner",
    "className": "KkStrategy",
    "vtSymbol": "IH1810"
}
```

回到runCtaTrading.py

```text
cta.initAll()
```

调用ctaEngine的initAll函数：

```text
def initAll(self):
    """全部初始化"""
    for name in self.strategyDict.keys():
        self.initStrategy(name)
```

调用ctaEngine的initStrategy函数：

```text
def initStrategy(self, name):
    """初始化策略"""
    if name in self.strategyDict:
        strategy = self.strategyDict[name]

        if not strategy.inited:
            self.callStrategyFunc(strategy, strategy.onInit)
            strategy.inited = True

            self.loadSyncData(strategy)                             # 初始化完成后加载同步数据
            self.subscribeMarketData(strategy)                      # 加载同步数据后再订阅行情
        else:
            self.writeCtaLog(u'请勿重复初始化策略实例：%s' %name)
    else:
        self.writeCtaLog(u'策略实例不存在：%s' %name)
```

首先里面先是调用策略的onInit函数进行初始化，初始化成功以后调用subscribeMarketData函数：

```text
def subscribeMarketData(self, strategy):
    """订阅行情"""
    # 订阅合约
    contract = self.mainEngine.getContract(strategy.vtSymbol)
    if contract:
        req = VtSubscribeReq()
        req.symbol = contract.symbol
        req.exchange = contract.exchange

        # 对于IB接口订阅行情时所需的货币和产品类型，从策略属性中获取
        req.currency = strategy.currency
        req.productClass = strategy.productClass

        self.mainEngine.subscribe(req, contract.gatewayName)
    else:
        self.writeCtaLog(u'%s的交易合约%s无法找到' %(strategy.name, strategy.vtSymbol))
```

接着里面调用self.mainEngine.subscribe(req, contract.gatewayName)，即vtEngine.py中的mainengine的subscribe函数。

```text
def subscribe(self, subscribeReq, gatewayName):
    """订阅特定接口的行情"""
    gateway = self.getGateway(gatewayName) 
    if gateway:
        gateway.subscribe(subscribeReq)
```

接着调用ctp接口的subscribe函数：

```text
def subscribe(self, subscribeReq):
    """订阅行情"""
    self.mdApi.subscribe(subscribeReq)
```

接着调用mdApi的subscribe函数：

```text
def subscribe(self, subscribeReq):
    """订阅合约"""
    # 这里的设计是，如果尚未登录就调用了订阅方法
    # 则先保存订阅请求，登录完成后会自动订阅
    if self.loginStatus:
        self.subscribeMarketData(str(subscribeReq.symbol))
    self.subscribedSymbols.add(subscribeReq)
```

接下来就是引用VNPY的作者写的数据流，具体的可以看文章：

[用Python的交易员：一张图看懂VnTrader的数据流91 赞同 · 24 评论文章![](https://pic2.zhimg.com/v2-964ef0d2cbeb44513508d73c474c6fb5_180x120.jpg)](https://zhuanlan.zhihu.com/p/32848878)

这里调用底层中调用C++封装的MdApi.subscribeMarketData函数，将订阅行情的请求最终通过底层C++ CTP API发出。

C++ CTP API收到Tick推送，自动回调MdApi.onRtnDepthMarketData函数推送行情数据字典data

MdApi.onRtnDepthMarketData中将data里的数据读取并转化成VtTickData对象，并调用ctpGateway.onTick函数

ctpGateway.onTick函数将VtTickData对象包装成类型为EVENT_TICK的行情事件对象Event，并调用eventEngine.put函数，放入事件引擎的缓冲队列

事件引擎的工作线程，从缓冲队列中读取出最新的行情事件后，根据EVENT_TICK事件类型去查找缓存在内部字典中的处理函数列表，并将事件对象作为入参，遍历调用到列表中的处理函数ctaEngine.processTickEvent

ctaEngine.processTickEvent中查看Tick的代码vtSymbol，并调用交易该代码合约的策略对象strategy.onTick函数，最终去运行策略中的逻辑

这里要注意策略涉及读取历史数据，需要本地数据库存储。

最后界面是在examply->vntrader里运行run.py,但是运行时报错 ，修改代码如下：

```text
qApp.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())
```