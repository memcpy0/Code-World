[TOC]

## 第7章 函数
>函数是重用的程序段。类和模块、包也是。它们是Python系统的层次构造工具。

- 函数中的参数名称为形参，而你提供给函数调用的值称为实参。将实参传递给形参是一个隐性的赋值过程。

- **局部变量**：当你在函数定义内声明变量的时候，它们**与函数外具有相同名称的其他变量没有任何关系**，即变量名称对于函数来说是`局部`的。
这称为变量的作用域 。所有变量的作用域是它们被定义的块，从它们的名称被定义的那点开始。
这意味着当我们在顶层文件中定义变量时，它就是全局变量；在函数内定义是它就是局部变量。且变量和函数一样只允许`前向引用`，即不能在定义之前使用它们。

- 使用global语句声明(**多个**)全局变量，使得在函数中就可以改变函数外变量的值

- **默认参数值**：对于一些函数，你可能希望它的一些参数是`可选`的，如果用户不想要为这些参数提供值的话，这些参数就使用默认值。这个功能借助于默认参数值完成。
你可以在函数定义的形参名后加上赋值运算符（=）和默认值，从而给形参指定默认参数值。注意，**默认参数值应该是一个参数**，而且默认参数值应该是不可变的。
> 只有在形参表末尾的那些参数可以有默认参数值，即**你不能在声明函数形参的时候，先声明有默认值的形参而后声明没有默认值的形参。**
>
>这是因为Python语法的限制，例如，`def func(a, b=5)`是有效的，但是`def func(a=5, b)`是无效的。

- **关键参数**
如果你的某个函数有许多参数，而你只想指定其中的一部分，那么你可以通过命名来为这些参数赋值——即使用关键字参数 ——我们使用名字（关键字）而不是位置（我们前面所一直使用的方法）来给函数指定实参。
优势在于：
  - 由于我们不必担心参数的顺序，使用函数变得更加简单了；
  - 假设其他参数都有默认值，我们可以只给我们想要的那些参数赋值。

- 没有返回值的return语句等价于`return None`，除非你提供你自己的return语句，每个函数都在结尾**暗含**有`return None`语句。

- **DocStrings**
> Python有一个很奇妙的特性，称为`文档字符串`，它通常被简称为`docstrings `。
> DocStrings是一个重要的工具，由于它帮助你的程序文档更加简单易懂，你应该尽量使用它。你甚至可以在程序运行的时候，从函数恢复文档字符串！

  - 文档字符串也适用与类和模块；
  - 我们使用`__doc__`调用函数对象的文档字符串属性，也可以使用`help()`，它所做的就是抓取函数的`__doc__`属性，然后整洁地展示给你。
  - 随我们的Python发行版附带的pydoc命令，与help()类似地使用`DocStrings`。

## 第8章 模块
- 在一个程序中使用函数来重用代码，如果想要在其他程序中重用很多函数，那么你该如何编写程序呢？答案就是使用模块。
- 首先，我们将学习如何使用标准库模块。

### 使用sys模块
> sys模块包含了与Python解释器和它的环境有关的函数。

> 当Python执行`import sys`语句的时候，它在**sys.path变量中所列目录**中寻找sys.py模块。如果找到了这个文件，这个模块的主块中的语句将被运行，然后这个模块将能够被你使用 。
> 注意，初始化过程仅在我们`第一次`输入模块的时候进行。

> sys.argv变量是一个字符串的列表，包含了命令行参数的列表，即我们使用命令行传递给程序的参数。记住，**脚本的名称总是sys.argv列表的第一个参数**。

> sys.path包含输入模块的目录名列表。sys.path的**第一个字符串是空的**，这个空的字符串**表示当前目录也是sys.path的一部分**，这与`PYTHONPATH环境变量`是相同的。这意味着你可以直接输入位于当前目录的模块。否则，你得把你的模块放在sys.path所列的目录之一。
```python
# use_sys.py

import sys
print "The command line arguments are:'
for i in sys.argv:
	print i

print '\n\nThe PYTHONPATH is', sys.path, '\n'
```

- 字节编译的.pyc文件：输入一个模块相对来说开销较大。而创建字节码编译的文件 ，这些文件以.pyc作为扩展名，则会快得多，因为一部分输入模块所需的处理已经完成了。另外，这些字节编译的文件也是与平台无关的，这使得Python具有跨平台的特性。而且，这样可以使我们不必将源代码也一并泄露出去。

- 模块的`__name__`：每个模块都有一个名称，在模块中可以通过语句来找出模块的名称。
   - 假如我们只想在程序本身被使用的时候运行主块，而在它被别的模块导入的时候不运行主块，这可以通过模块的`__name__`属性完成。

```python
# use_name.py
if __name__ == "__main__":
	print 'This program is being run by itself.'
else:
	print 'I am being imported from another module.'
``` 
输出：
```python
$ python using_nam e.py
This program is being run by itself

$ python
>>> import using_name
I am being im ported from another m odule
```
如果它是`'__m ain__'`，这说明这个模块被用户单独运行，我们可以进行相应的恰当操作。

- dir()函数：我们可以使用内建的`dir函数`来列出模块定义的标识符。标识符有`函数、类和变量`。
当你为dir()提供一个模块名的时候，它返回模块定义的名称列表；如果不提供参数，它返回当前模块中定义的名称列表。

- 关于del的一点注释——这个语句在运行后被用来删除一个变量/名称。

## 第9章 数据结构
在Python中有三种内建的数据结构——列表、元组和字典。

- 列表：是处理一组有序项目的数据结构。
- 元组：元组和字符串一样是 不可变的，元组通过圆括号中用逗号分割的项目定义。
元组通常**用在使语句或用户定义的函数能够安全地采用一组值**的时候，即被使用的元组的值不会改变。

- 字典：
  - 注意：键必须是唯一的；
  - 注意：只能使用不可变的对象（比如字符串）来作为字典的键，但可以把不可变或可变的对象作为字典的值。

- 序列：
列表、元组和字符串都是序列。
**序列的两个主要特点是索引操作符和切片操作符**。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。

-  **引用**：当我们创建一个对象并给它赋一个变量的时候，这个变量仅仅 引用 那个对象，而不是表示这个对象本身！
也就是说，变量名指向你计算机中存储那个对象的内存，它等同于指针。而这被>称作名称到对象的绑定。
>在Python中，变量无类型，对象有类型，因为变量只是指向对象的引用。而Python也因为对对象类型的强调，被认为是一种强类型语言。
>
>记住**列表的赋值语句不创建拷贝，得使用切片操作符来建立序列的拷贝**。

- **更多字符串的内容**
  - startwith方法是用来测试字符串是否以给定字符串开始。
  - in操作符用来检验一个给定字符串是否为另一个字符串的一部分。
  - find方法用来找出给定字符串在另一个字符串中的位置，或者返回-1以表示找不到子字符串。
  - str类也有以一个作为分隔符的字符串join序列的项目的整洁的方法，它返回一个生成的大字符串。
```python
# str_method.py
name = 'Swaroop' # This is a string object
if name.startwith('Swa'):
	print 'Yes, the string starts with "Swa".'

if 'a' in name:
	print 'Yes, it contains the string "a".'

if name.find('war') != -1:
	print 'Yes, it contains the string "war".'

delimiter = '_*_'
mylist = ['Brazil', 'Russia', 'India', 'China']
print delimiter.join(mylist)
```
```python
$ python str_m ethods.py
Yes, the string starts with "Swa"
Yes, it contains the string "a"
Yes, it contains the string "war"
Brazil_*_Russia_*_India_*_China
```


