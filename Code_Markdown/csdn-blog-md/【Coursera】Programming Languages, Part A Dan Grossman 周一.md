
@[toc]

---
# 周一
## 1 Introduction and Course-Wide Information (Start Here)
### 1.1 Welcome! (And Some Course Mechanics) 9分钟
 Hello, welcome to the Programming Languages course. I'm Dan Grossman and I'm so glad and excited that you've chosen to participate in this course. As you might expect in a very first video for a course, I want to welcome you and just give you some basic information on how the course is organized and what will come next. So in one slide, this course is about an opportunity to learn the fundamental concepts of programming languages and we're going to do it in a way that will I believe, make you a better programmer in any programming language. And in fact, in programming languages that we're not even going to use during this course. The idea is really to learn the ideas around which every programming language is built and understand precisely the different ideas that we use when we program, and how those ideas are expressed in lots of different programming languages. So it's common when you look at courses like this to hear people say, that's the course where you learn ML, Racket and Ruby, which happen to be the three languages that we'll use through programming languages overall. But in fact, that's really not the point as I'll emphasize throughout the course. It's really about getting past the surface level distinctions between languages and getting at the core ideas. So, I hope that excites you. I hope you'll find that challenging and enriching, and we'll get back to actual programming languages in a little bit. But like in any course, we first need to talk a little bit about mechanics and structure and make sure you can find everything you're looking for. So, we'll do some of that in this video and they there'll be six more introductory videos. I'll tell you a little bit about myself, if you're interested. You can ignore that one if you like. We'll motivate the course a little bit, although I'll explain that it's really hard to motivate this material until we've done some of it. So, we'll get back to that a little later in the course. We'll discuss recommended background. You'll have noticed that the title of this course was actually Programming Languages Part A, so I'll explain why there's a Part B and a Part C. We'll talk about grading policies and I'll try to give you a very high-level roadmap of all the main topics in the course, so that you can have a little better sense of what your getting into. So here's a to-do list on things you should be making sure to do, as you dive into the course. Of course, there's getting used to the web page and looking around and finding what's there. Whether or not this is your first course on Coursera, there are a number of things in this MOOC that are run a little bit differently and you'll want to make sure you notice those. Please watch the videos and read all the announcements and messages, so that you don't miss something by assuming it's like another course you took. We're not doing different things just to be different, but we have a reason to do certain things and we want to make sure you know about them. There's a fair amount of software installation for doing the homeworks here in Part A and you'll want to do that soon, so that when you get into the videos in the first real section of the course, you can follow along and try out programs and do things. You'll need both a text editor. We do everything in the videos and have installation instructions for Emacs, so we recommend that in some sense. But if you don't like Emacs and you prefer another text editor that can be used for ML program, that's fine. And the related software installation materials make that clear and there's even some videos, if you want to watch me install slightly older versions of the software on windows just to get a sense of what the written instructions are about. And then the last thing you don't need to do right away, but I want to point out to you is that we have an optional Homework 0 that isn't really a homework. We ask you to change one character in one file and then go through the process of uploading your solution for the auto-grader, and participating in peer assessment. So that before you do a lot of work on homework one, you understand the mechanics of uploading the homeworks for this course, because they're a little bit complicated. There is a lot of material we have made available, so I want to explain how those fit together. The obvious thing is there will be a lot of video lectures that will look a lot like this, except there will be a lot more code writing and a lot less staring at PowerPoint. If a video is ever optional and not needed for the homeworks and other stuff in the course, I'll be sure to label that very clearly and that's an opportunity to explain some additional things that may be of interest to some of you. One thing that's not as common in online courses is that I also have reading notes for all the material that's covered in the videos. Those tend to get underutilized. So, I really recommend using them as a second resource. A way to get a written down explanation of what I'm talking about. A more thorough explanation. A more precise explanation sometimes. They're optional, because the video should have everything that you need, but it's a good resource that you want to make sure you don't forget about. I also post all the lecture code. So anything that you see in the videos, you shouldn't have to retype in. I'll make those files available, so that you don't have to do a lot of unnecessary copying and pasting or typing something out of a video buffer. There's homework assignments and as we'll explain in more detail in an upcoming video. We both have an auto-grader that it's correct and also sometimes that you use the language features we tell you to use, but then we also ask you to participate in peer assessment to look at certain stylish use in the code. And also, so that you can learn from looking at each other's solutions. And then we do have some exams for things that cover topics better in a format other than written homeworks where all you do is write code, so there's one exam at the end of Part A of the course and another one at the end of part C and we'll have a lot more information on those when we get there. In terms of the homeworks, there's basically one per major course section. So, this is I'm like an online course where you do a problem here and a problem there. This is much more like in a traditional university course where you might have one homework each week where you do all the problems together, and then turn them in all together. The homeworks that way, let you synthesize a lot of the topics and have it all fit together. The disadvantage is you don't get a lot of feedback along the way that you're doing okay so far. So, that's a tradeoff and we made the decision that the homeworks kind of come in big chunks. They break down into individual problems, but you turn them in all together. When you go to do the homework, the thing that people tend to do is just write the code you're asked to write and turn it in and see how you did. And I want to say here in the very first video that often times, if you do that, you'll be making the homework harder and less fulfilling than if you take sort of a more complete approach to doing the homework problems. That a great first thing when reading a homework problem is to understand what part of the course is this problem probably involved with, is it connected to? Because there should always be a connection. We don't have videos about one topic and then homework that are about something totally different. So instead figure out what we're asking about, then work on writing the code, then test it out, try it. Probably the most important thing you can do for your learning is take a solution you think is correct, make it wrong and check that it's wrong in the way you expect. Play around with variations, try different things. And then when you're confident, you understand the question, then you're probably done and it probably didn't take any more time than just trying to get it done as quickly as you possibly could. A couple other details, we do have some challenge problems in the homework. Those are clearly identified and they are not worth very many points. So those are optional, but a great opportunity to go a little further. Then of course, because I want every one to get as much out of this course as they can. If your sample solution from when you did the course is one Google search away, it's going to be really unfulfilling for other people. So, it's your responsiblity not to post your solutions in public places. Final thing about the homework that I'll just say quickly is I've learned from experience in talking to former students that they're somewhat surprised at how precise and concise our homework problem wording can be. So, I do that on purpose. I try to make things, as technically accurate as when you're writing code and just realize that it's not the kind of homework assignment that you'll get a lot of out skimming. You really need to read the whole thing, I try to keep them as short as possible. Be as straight forward as possible not trick anyone. So, try to read things carefully. And then by all means in the discussion forums, ask if something is confusing. If you are unsure about a certain case, that's perfectly natural. That's perfectly welcome. And then once your confusion is cleared up, hopefully, you'll go back and see that the assignment was written in a way that made it possible to understand that. And if not, let us know and we'll improve the write-up for the homework assignment. So with that, let me just say, welcome. And then on online course like this, particularly one with as much content as this one has is a great adventure not only for you, but also for me and I really want to welcome everyone. This is in many ways the most exciting thing I've ever done professionally is taking this material, which is my favorite material in all of computing, something I'm deeply passionate about and making it available and kind of sharing with you my perspective on how to think about programming languages. And why I think that's such both an effective way to think about software, but even a beautiful way. There's something deeply artistic and elegant in the way programming languages fit together and I want you to stretch your mind, and I want you to look at this course as a fresh way to look about software. A fresh way to think about programming that you've never thought about before. We're going to make you uncomfortable. We're going to do things in a strange way. And I hope that by the end of the course, it'll all connect back to what you may have already loved about programming and get you to love programming even more by giving you the unique perspective that studying programming languages gives you. So, welcome.


您好，欢迎来到编程语言课程。我是 Dan Grossman，我很高兴也很兴奋你选择参加这门课程。正如您在课程的第一个视频中所期望的那样，我想欢迎您，并只为您提供一些有关课程组织方式以及接下来会发生什么的基本信息。所以在一张幻灯片中，这门课程是关于学习编程语言基本概念的机会，我们将以一种我相信的方式来做，让你成为任何编程语言的更好的程序员。事实上，在本课程中我们甚至不会使用的编程语言。这个想法实际上是学习构建每种编程语言的思想，并准确理解我们在编程时使用的不同思想，以及这些思想如何在许多不同的编程语言中表达。所以当你看这样的课程时，听到人们说，那是你学习 ML、Racket 和 Ruby 的课程，这恰好是我们将在整个编程语言中使用的三种语言，这是很常见的。但事实上，这真的不是重点，因为我将在整个课程中强调。这实际上是关于超越语言之间的表面差异并获得核心思想。所以，我希望这会让你兴奋。我希望你会发现它具有挑战性和丰富性，我们稍后会回到实际的编程语言。但是就像在任何课程中一样，我们首先需要谈谈力学和结构，并确保您可以找到所需的一切。所以，我们会在这个视频中做一些，他们还会有六个介绍性视频。如果你有兴趣，我会告诉你一些关于我自己的事情。如果你愿意，你可以忽略那个。我们会稍微激发课程的动力，尽管我会解释说，在我们完成其中的一些内容之前，很难激发这些材料的动力。所以，我们稍后会在课程中讨论这个问题。我们将讨论推荐的背景。你会注意到这门课程的标题实际上是编程语言 A 部分，所以我将解释为什么有 B 部分和 C 部分。我们将讨论评分政策，我会尽量给你一个非常课程中所有主要主题的高级路线图，以便您可以更好地了解您将要学习的内容。所以这里有一份待办事项清单，列出了您在深入学习课程时应该确保做的事情。当然，已经习惯了网页并环顾四周并找到那里的内容。无论这是否是您在 Coursera 上的第一门课程，此 MOOC 中有许多内容的运行方式略有不同，您需要确保注意到这些内容。请观看视频并阅读所有公告和消息，这样您就不会因为假设它就像您上的另一门课程而错过任何东西。我们做不同的事情并不是为了与众不同，而是我们有理由去做某些事情，我们希望确保您了解它们。在 A 部分中，有相当多的软件安装用于完成家庭作业，您很快就会想要安装，这样当您进入课程的第一个真实部分的视频时，您就可以继续学习并试用程序和做事。您将需要一个文本编辑器。我们完成了视频中的所有操作，并提供了 Emacs 的安装说明，因此我们在某种意义上推荐这样做。但是如果您不喜欢 Emacs 并且您更喜欢另一个可用于 ML 程序的文本编辑器，那也没关系。并且相关的软件安装材料清楚地说明了这一点，甚至还有一些视频，如果您想看我在 Windows 上安装稍旧版本的软件只是为了了解书面说明的内容。然后你不需要马上做的最后一件事，但我想向你指出的是，我们有一个可选的家庭作业 0，它不是真正的家庭作业。我们要求您更改一个文件中的一个字符，然后完成为自动评分器上传您的解决方案并参与同行评估的过程。因此，在您对家庭作业做大量工作之前，您了解上传本课程作业的机制，因为它们有点复杂。我们提供了很多材料，所以我想解释一下它们是如何组合在一起的。显而易见的是会有很多视频讲座看起来很像这样，除了会有更多的代码编写和更少的盯着 PowerPoint。如果视频是可选的，并且课程中的家庭作业和其他内容不需要视频，我一定会非常清楚地标记它，这是一个解释你们中一些人可能感兴趣的一些其他内容的机会。在线课程中不常见的一件事是，我还有视频中涵盖的所有材料的阅读笔记。这些往往没有得到充分利用。所以，我真的建议将它们用作第二资源。

解释我在说什么。更彻底的解释。有时更准确的解释。它们是可选的，因为视频应该包含您需要的一切，但它是一个很好的资源，您希望确保不会忘记。我还发布了所有讲座代码。所以你在视频中看到的任何东西，你都不应该重新输入。我会让这些文件可用，这样你就不必做很多不必要的复制和粘贴或从视频缓冲区中输入一些东西.有家庭作业，我们将在即将发布的视频中更详细地解释。我们都有一个自动评分器，它是正确的，有时您使用我们告诉您使用的语言功能，但我们也要求您参与同行评估以查看代码中的某些时尚用法。而且，这样你们就可以从查看彼此的解决方案中学习。然后我们确实有一些考试，这些考试以书面作业以外的形式更好地涵盖主题，您所做的只是编写代码，所以在课程的 A 部分结束时有一个考试，在 C 部分结束时有另一个考试当我们到达那里时，我们将获得更多关于这些的信息。在作业方面，基本上每个专业课程部分都有一个。所以，这就像一个在线课程，你在这里做一个问题，在那里做一个问题。这更像是在传统的大学课程中，您可能每周有一个家庭作业，您可以一起做所有问题，然后将它们全部交出来。这样的家庭作业，可以让你综合很多主题并将它们组合在一起。缺点是您在到目前为止做得还不错的过程中没有得到很多反馈。所以，这是一个权衡，我们决定家庭作业是大块的。它们分解为单独的问题，但您将它们全部放在一起。当你做作业时，人们倾向于做的事情就是编写你被要求编写的代码并提交它，看看你是怎么做的。我想在第一个视频中经常说，如果你这样做，你会让作业变得更难，比你采取一种更完整的方法来解决家庭作业问题更不充实。在阅读家庭作业问题时，首先要了解这个问题可能涉及课程的哪一部分，是否与课程有关？因为应该总是有联系的。我们没有关于一个主题的视频，然后是关于完全不同的事情的家庭作业。因此，而是弄清楚我们在问什么，然后编写代码，然后测试它，尝试一下。或许你可以为你的学习做的最重要的事情就是找到一个你认为正确的解决方案，把它弄错，然后检查它是否按照你期望的方式错了。玩转变化，尝试不同的东西。然后当你有信心时，你理解了这个问题，那么你可能已经完成了，它可能不会花更多的时间，只是尽可能快地完成它。其他一些细节，我们在作业中确实有一些挑战问题。这些都被清楚地识别出来，它们不值多少分。所以这些都是可选的，但这是一个走得更远的好机会。然后当然，因为我希望每个人都尽可能多地从这门课程中获得。如果您在完成课程时的示例解决方案距离 Google 搜索仅一个 Google 搜索，那么对其他人来说将非常不令人满意。因此，您有责任不在公共场所发布您的解决方案。关于作业的最后一件事，我要快速说一下，我从与以前的学生交谈的经验中了解到，他们对我们的作业问题措辞可以如此精确和简洁感到有些惊讶。所以，我是故意这样做的。我试着做一些事情，就像你在写代码一样技术上准确，只是意识到这不是那种你会得到很多浏览的家庭作业。你真的需要阅读整篇文章，我尽量让它们尽可能短。尽可能直截了当，不要欺骗任何人。因此，请尝试仔细阅读。然后通过各种方式在论坛中，询问是否有什么令人困惑的地方。如果您不确定某个案例，那是很自然的。这是完全受欢迎的。然后，一旦你的困惑消除了，希望你能回过头来看看作业的编写方式让你能够理解它。如果没有，请告诉我们，我们将改进家庭作业的写作。所以，我只想说，欢迎。然后在这样的在线课程上，特别是一个内容如此多的课程，不仅对你来说是一次伟大的冒险，对我来说也是一次伟大的冒险，我真的很想欢迎大家。在很多方面，这是我在专业领域做过的最令人兴奋的事情就是采用这种材料，这是我在所有计算中最喜欢的材料，我对此充满热情  
出来并使其可用，并与您分享我对如何思考编程语言的看法。 为什么我认为这既是一种思考软件的有效方式，又是一种美丽的方式。 编程语言组合在一起的方式具有深刻的艺术性和优雅性，我希望您能够扩展您的思维，并且我希望您将本课程视为看待软件的全新方式。 以一种全新的方式思考您以前从未想过的编程。 我们会让你感到不舒服。 我们将以一种奇怪的方式做事。 我希望在课程结束时，这一切都将与您可能已经喜欢的编程联系起来，并通过为您提供学习编程语言所带来的独特视角，让您更加热爱编程。 所以，欢迎。 
 
### 1.2 Optional: Who I Am / Acknowledgments 6分钟
In this optional video, I want to do two things. 
- I want to give you a little background on who I am, just in case you're curious since we'll be spending a lot of time together. 
- And, second, I want to acknowledge all the people you don't see in front of the camera that have been absolutely essential in making this course what it is. 

So in terms of me, here's a picture of the United States where I have lived all of my life. I grew up right in the middle in the suburbs of St. Louis, Missouri. When I was 18, I went off to college as an undergraduate at Rice University in Houston, Texas. I last lived in Texas in 1997, I miss the burritos. I then went to grad school in upstate New York at Cornell University. For those of you not familiar with Northeast United States geography, when you hear New York, you tend to think New York City. I was about a 4.5-hour drive from New York City, it's a rather large state. 

And then in 2003, I moved to the University of Washington all the way on the West Coast where I've been a faculty member in the Department of Computer Science and Engineering ever since. It's my favorite place to live. It's my favorite place to work and I'm very, very happy here. A little bit about my research when I'm not teaching courses, an online courses. 

I am a member of the programming languages research community and I believe deeply in the fundamental elegance of the formal side of programming languages. Things like functional languages, type systems, proofs about programs. And in general, **formal semantics**. And in particular, **operational semantics**, but I've been rather applied within that context in using that sort of foundation for messy real world computing problems such as how to write systems programs in languages like C. How to solve the difficulties of concurrent programming, which became much more important when we got to multicore processors. 

More recently, even dealing with ways to try to continue to improve computing's performance in an age where our hardware is fundamentally limited by issues of power and energy. So, I've always found this to be a really enjoyable fulfilling strategy to collaborate with others on important problems from a perspective of sort of foundational concepts and programming languages. 

Theory. In recent years, I've also become more focused on computer science education. This MOOC is certainly a part of that, but more generally, computer science curriculum issues overall is something I'm very passionate about. I don't spend all my time on computer science, I used to do a bunch of things like go hiking in Montana. I did that I think in the summer of 2012. Play ice hockey once a week. You can't tell that that guy in front with the helmet and the stick is me, but I enjoy skating around when I get the opportunity. I like to go on long bike rides, this is me finishing up a 320 kilometer bike ride here in the Pacific Northwest and I even live with a dog. This is Red dog, she's awesome. And as you finish each homework, she will visit you and give you a message. I've also traveled a fair amount, although I would love to do more. Here's a list of the countries I've visited. For fun, I've put them in order from smallest to largest. I think there are about 25 of them and I've traveled a lot around my own country of the 50 states in the US, I've definitely not been to Alaska. And I'm not sure if when I was a kid, I made it to Delaware or not. I've certainly been everywhere else, but a lot has changed for me in the last couple years. 

In fact, since I first recorded most of the material for this MOOC. I had my first child, a wonderful baby boy in December 2013 and a second wonderful baby boy in September 2015. So, I have no idea how I would have ever created an online course after I had kids. So, I'm glad I did most of it before. I have no idea how I'm able to survive on as little sleep as I do these days, but having kids is the most wonderful thing and it's a huge part of my life that you won't see in the course, but I wanted to show you a little bit about me and that's a huge part of how I am today. 

Let me switch to the other topic of the video, which is acknowledging all the people you don't see in front of the camera. It's been an amazing journey with tons of help to make this course everything that it is. Way back in the summer of 2012, we gathered a collection of students, Cody, Rachel, Sean, Claire, Eric and Max back when MOOCs were just starting. There had only been a few and we really had no idea what we were doing, but we put it together. 

These folks figured a lot of things out for the first time and that always be a particular special experience that they will be able to be a part of. As the course continued and evolved, there were a later set of TAs that made things better, that fixed a lot of things, that were the important second crew. And then more recently, as we migrated to a platform that let people take the course more often on a more regular schedule. There was another set of people that really had to redo a lot of the autograding infrastructure and I appreciate that. All through the course, there's been volunteers who've served as community teaching assistants. 

Community mentors that have provided a lot of feedback where explanations were unclear. A lot of extra practice problems and an amazing commitment to discussion forums. There will be more in the future. But at the time of recording in this video, these are the names I have to share with you. Folks who helped set up the recording studio that I'm using to share this information with you. People at Coursera over almost four years now who have always been responsive to questions, given excellent feedback. This course certainly wouldn't exist without them. 

And then some extra special people who maybe were not as directly involved in the course, but a set of friends and colleagues that when I really needed something I wasn't quite able to do myself provided special scripts and easier installation instructions and helped out in crucial times. 

There's a set of people that have been deeply involved in the course that I teach here on campus that is most similar to this online course, then had made them it material better that have contributed things over the years. And this course is certainly better, because of all the work they did. And then of course, thousands of students who participated in the course down type asked given feedbacks, said what work to ours, said what work to ask well. 

And in the end, it's an amazing team effort involving an enormous number of people. And while it's always my head in the corner of the screen and my voice coming out of your speakers, I did want to be clear here at the beginning of the course just how much I appreciate the massive effort that's gone on by a lot of people in order to make this course everything that it is.


### 1.3 What the Course is About / Initial Motivation 8分钟
 In this video, I want to talk about what the course is really about, programming languages, and why one might want to take a course about this sort of material. The idea is that we are going to learn the basic concepts that underlie all or almost all programming languages and how those pieces fit together. While we're going to use the standard ML programming languages here in Part A of the course, Racket in part B, and Ruby in part C, we're doing so because it lets the concepts that we want to study really shine and focus on the key ideas in real languages where they tend to be easiest to learn and focus on what we want to focus on. By using multiple languages, we can see how the same concepts, because we'll see some of the same concepts over and over again using all three of the languages, can look different when they sometimes are a little different and more often when they're quite similar with just some basic syntactic differences in the different languages. You could ask, why aren't we using Java or C# or Python or Scholar or JavaScript? Well, in many ways the languages we're using are simpler than when we're trying to study the core concepts, simplicity is a virtue. The other thing I would emphasize, even though it's not in the course title, is that we will emphasize functional programming throughout most of the material that we study, so what does that mean? Well, we'll learn when we get there, but it means we're not going to have assignment statements or much in the way of mutating or updating the contents of memory, which may surprise you, and if you've never programmed the before, don't worry about it, we will get lots of practice. It also means we will use first class functions and function closures, a really important topic, but one that I can not explain in a short video. So, let me just leave the jargon there, and don't worry if you never heard it before, and, of course, we are going to do much much more as well. Normally, you would spend some time at the beginning of a course motivating why you should learn the main topics in the course, but in my experience, it's very difficult to do that until we've built up some shared experience and shared terminology. And you've done a homework or two, or actually three, to understand the basic ideas behind functional programming in particular, and programming languages in general. So, what I've done instead is made a collection of videos that motivate the course that would be delayed and will come after section three in the course. Now, unfortunately that means you're going to have to trust me for now or trust the students who have come before you who like to say things like, you know, at the time I was learning in this strange language in doing this strange stuff, But afterwards, I was able to go back and learn things I had tried to learn before, and found it so much simpler, because you gave me the perspective and the terminology and the concepts I needed to pick up new programming languages, and understand the programming languages I already knew better. So I'm asking you to trust me because if I try to motivate the course without having taught you the concepts I'll just be using a bunch of fancy words and talking in abstract terms that don't make a lot of sense. But what I would like to say is one high level idea that I deeply believe that is learning this material will give you a new way to think about software That will make you a better programmer, even when you go back to the environments and programs and languages so that you already feel comfortable with. That it will, on top of that, give you the mental tools and experience you need for a lifetime of confidently picking up new languages and ideas and for being able to reason carefully, precisely and correctly about the software you're writing. And I fully admit, that as you get into the first couple of hours of material in this course and do the first homework, it will feel like nothing you've done before in writing programs if you haven't done this type of functional programming before. And maybe the best analogy I can think of are these movies, the karate kid. I remember it from my childhood and it was remade in the 21st century. In this movie, if you've never seen it, I don't claim these are particularly great movies but they are what they are. You have a kid who wants to learn karate, a martial art and is told instead to spend days and days, cleaning windows and washing cars and doing other menial tasks. And it turns out that he's building, or she, I think in the remake. The mental, the muscle memory, to do exactly what you need, to be successful in karate. Now I know nothing about karate. But I do know some things about programming languages and writing software. And I believe what we're going to do in this course, particularly early, is building those basic muscular skills and basic ideas, that we'll then be able to build on, very quickly, in order to understand, in a compositional way, how more complex software and algorithms and programs can fit together in an effective way. So perhaps that analogy will resonate with some of you. It's certainly a good way to motivate yourself early in the course when you're doing something that feels very uncomfortable or unfamiliar. And indeed I want to emphasize that here in part A of the course we're going to use the standard ML language, which probably very few of you used before. We may use a text editor you're not familiar with. What editor you use is optional. But, you may not have a familiar development environment that you're used to for other languages. And we're going to evaluate our programs using this thing called the read-eval-print loop. That will feel different than the normal compile and run cycle that you may be more familiar with. You're going to have to install software you're not familiar with. You're going to have to get these things up and running before you can really start on the content of homework 1. And I understand that's and extra burden, but I think it's also something that you will grant, that in computing is fairly common. That as you take different courses, as you take new jobs, as you do new things, you're always working in strange new environments and installing new tools. And while it may Not be fun and often causes complications and it can be aggravating at first. It's something you get more comfortable with time, and this course like many requires you to do a little of that right at the beginning so you can get started. Let me emphasize again, as I did in the very first video, that this course is not about ML. And when you get into part b, it's not about racket. And part c is not about ruby. These are means to other ends. These are chosen as languages that are particularly good fits for the topics we want to present. You could teach these concepts with other languages. But I've chosen these because I think they're particularly good tools for what we want to accomplish. And let me say right here in introducing the course that standard ML in particular is not a fashionable language that these days is used for real software and that's okay because we're not in the homeworks in this course trying to build real software. We're trying to give you the background for building better real software in other languages in the future. So there are closely related languages that are very active and effective, and still in much more common use today. In sort of decreasing similarity from standard ML, OCami, F#, Scala, and Haskell. Each would be an okay choice for part A of this course in various ways. I think standard ML is a slightly better choice. And in fact I could argue and will argue here briefly that it's a bit of a feature and not a bug that we're picking a language that doesn't have a lot of modern libraries, that doesn't do a lot of things in the modern software ecosystems. That way we can focus just on the core ideas. We won't be distracted by trying to do anything fancy. We won't have a lot of complications. That are common in modern software development. We get to focus on standard ML which in many ways, even compared to these other wonderful languages, is clean, compositional, and elegant in ways we're going to start seeing even in the first week of this course. Let me also emphasize that these introductory videos are a lot of text on PowerPoint and me just telling you stuff. That's not the way most of the course works. I think that you learn about software by writing code and trying things out and you'll see that we do that in a lot of the videos. There's in video questions with quick quizzes on things. in short I actually think that most the videos in this course are better than the introduction videos but introducing things is just something you need to get through and we'll get on to the good stuff soon enough.

在这个视频中，我想谈谈这门课程的真正内容，编程语言，以及为什么人们可能想要参加有关此类材料的课程。这个想法是我们将学习所有或几乎所有编程语言的基本概念，以及这些部分如何组合在一起。虽然我们将在课程的 A 部分使用标准 ML 编程语言，B 部分使用 Racket，C 部分使用 Ruby，但我们这样做是因为它让我们想要学习的概念真正闪耀和聚焦在真正的语言中，他们往往最容易学习并专注于我们想要关注的关键思想。通过使用多种语言，我们可以看到相同的概念，因为我们会在使用所有三种语言时一遍又一遍地看到一些相同的概念，当它们有时有点不同时看起来会有所不同，而当它们更常见时非常相似，只是不同语言中的一些基本语法差异。你可能会问，为什么我们不使用 Java、C#、Python、Scholar 或 JavaScript？嗯，在很多方面，我们使用的语言比我们尝试研究核心概念时更简单，简单是一种美德。我要强调的另一件事是，即使它不在课程标题中，我们将在我们学习的大部分材料中强调函数式编程，那是什么意思？好吧，当我们到达那里时我们会学习，但这意味着我们不会有赋值语句或很多改变或更新内存内容的方式，这可能会让你感到惊讶，如果你从来没有编程过之前，别担心，我们会得到很多练习。这也意味着我们将使用一流的函数和函数闭包，这是一个非常重要的话题，但我无法在短视频中解释。所以，让我把行话留在那里，如果您以前从未听说过，请不要担心，当然，我们还将做更多的事情。通常，您会在课程开始时花一些时间来激励您为什么应该学习课程中的主要主题，但根据我的经验，在我们建立一些共享经验和共享术语之前，很难做到这一点。您已经完成了一两个或实际上三个作业，以了解函数式编程背后的基本思想，以及一般的编程语言。所以，我所做的是制作了一系列视频来激励课程，这些课程将被推迟，并将在课程的第三部分之后出现。现在，不幸的是，这意味着你现在必须相信我，或者相信在你之前的学生喜欢说这样的话，你知道，当时我正在用这种奇怪的语言学习做这种奇怪的事情, 但后来，我能够回去学习我以前尝试学习的东西，发现它简单得多，因为你给了我学习新编程语言所需的视角、术语和概念，并理解我已经更了解的编程语言。所以我要求你相信我，因为如果我试图在没有教你概念的情况下激励课程，我只会使用一堆花哨的词，并用没有多大意义的抽象术语说话。但是我想说的是一个高层次的想法，我深信学习这些材料会给你一种新的方式来思考软件这会让你成为一个更好的程序员，即使你回到环境和程序，语言，让你已经感觉舒服。最重要的是，它将为您提供一生所需的心理工具和经验，让您自信地学习新语言和新想法，并能够仔细、准确和正确地对您正在编写的软件进行推理。我完全承认，当你进入本课程的前几个小时材料并做第一个作业时，如果你没有做过这种类型的函数式编程，你会觉得你以前在编写程序时什么都没做过前。也许我能想到的最好的比喻是这些电影，空手道小子。我记得它从我的童年开始，它是在 21 世纪重新制作的。在这部电影中，如果你从未看过它，我不会说这些是特别棒的电影，但它们就是它们。你有一个孩子想要学习空手道，一种武术，却被告知要花几天时间，擦窗户、洗车和做其他琐碎的工作。事实证明，他正在建造，或者她，我认为在翻拍中。精神，肌肉记忆，做你需要做的事，在空手道中取得成功。现在我对空手道一无所知。但我确实知道一些关于编程语言和编写软件的事情。我相信我们在这门课程中要做的，特别是在早期，是建立那些基本的肌肉技能和基本思想，然后我们将能够非常快速地以组合方式进行理解 ，更复杂的软件、算法和程序如何以有效的方式组合在一起。所以也许这个比喻会引起你们中的一些人的共鸣。当您在做一些感觉非常不舒服或不熟悉的事情时，这当然是在课程早期激励自己的好方法。事实上，我想强调的是，在课程的 A 部分，我们将使用标准 ML 语言，你们中可能很少有人以前使用过。我们可能会使用您不熟悉的文本编辑器。您使用的编辑器是可选的。但是，您可能没有熟悉其他语言的开发环境。我们将使用称为 read-eval-print 循环的东西来评估我们的程序。这与您可能更熟悉的正常编译和运行循环感觉不同。您将不得不安装您不熟悉的软件。在真正开始作业 1 的内容之前，您将必须启动并运行这些东西。我理解这是额外的负担，但我认为这也是您会同意的事情，这在计算中是相当普遍的.当你学习不同的课程，当你接受新工作，当你做新事情时，你总是在陌生的新环境中工作并安装新工具。虽然它可能并不有趣，而且经常会导致并发症，而且一开始可能会加重。随着时间的推移，这会让你更加适应，而这门课程和许多课程一样，要求你一开始就做一些这样的事情，这样你就可以开始了。让我再次强调，正如我在第一个视频中所做的那样，本课程与 ML 无关。当你进入 b 部分时，这与 Racket 无关。而 c 部分与 Ruby 无关。这些都是达到其他目的的手段。这些被选为特别适合我们想要呈现的主题的语言。您可以使用其他语言教授这些概念。但我选择这些是因为我认为它们是我们想要完成的特别好的工具。让我在介绍这门课程时说，标准 ML 特别是现在不是一种流行的语言，现在用于真正的软件，这没关系，因为我们不是在本课程的作业中试图构建真正的软件。我们正在努力为您提供在未来用其他语言构建更好的真实软件的背景。所以有一些非常活跃和有效的密切相关的语言，并且今天仍然使用得更加普遍。与标准 ML、OCami、F#、Scala 和 Haskell 的相似度有所下降。对于本课程的 A 部分来说，每一个都是不错的选择。我认为标准 ML 是一个稍微更好的选择。事实上我可以争论并且将在这里简要争论它是一个功能而不是一个错误，我们选择的语言没有很多现代库，它没有做很多事情现代软件生态系统。这样我们就可以只关注核心思想。我们不会因为尝试做任何花哨的事情而分心。我们不会有很多并发症。这在现代软件开发中很常见。我们开始专注于标准 ML，即使在许多方面，即使与其他出色的语言相比，它也是干净、组合和优雅的，即使在本课程的第一周，我们也将开始看到它。我还要强调，这些介绍性视频是 PowerPoint 上的大量文字，我只是告诉你一些东西。这不是大多数课程的运作方式。我认为你通过编写代码和尝试来了解软件，你会在很多视频中看到我们这样做。有关于事物的快速测验的视频问题。简而言之，我实际上认为本课程中的大多数视频都比介绍视频要好，但介绍内容只是您需要完成的事情，我们很快就会介绍好东西。  


### 1.4 Recommended Background 9:08
In this video, I want to discuss the recommended background for the course, which of course is a very important topic, but also a very difficult one to discuss since so many people have so many different backgrounds that could be a good fit for what we are going to study. So the key thing to emphasize is that on the one hand, this is not an introductory programming course. That the way I've designed the material assumes you have done programming before just in different languages. It doesn't have to be a lot of programming however. If you've taken one or two other programming courses and succeeded at them. This will probably be fine. It doesn't have to have been courses. You could have picked it up on the job or on your own learning or whatever. On the other hand this is not an advanced programming language course. I typically teach this on campus to sort of second year students, not people with years of professional industry experience or not even what I would consider last year undergraduate course. So it's not an introductory course, you should have programmed before, but it's not a particularly advanced course. I want to give you a little better sense of that. So here are some topics that I assume you would have seen when programming before. So things like variables and having arguments to a method or function or procedure. Any, if you've called things methods, that's fine, but things that take arguments and return results. Some kind of if statements, some kind of branching for, I do this in some situations, in other situations, I do that. You've probably seen some sort of loop. You've probably seen some sort of array. Even though here in, at least, part a of programming languages we're not going to have loops or arrays. I do assume that you've seen recursion before. Now we're going to get a lot more practice with recursion. We're going to use recursion on almost every problem, on almost every homework assignment. But we're going to go awfully fast if you've never seen it before. Recursion is the idea of defining some computation in terms of itself, defining some data in terms of itself. And we'll get lots more practice, but the way I've organized this course assumes some exposure before, and if you haven't seen that, you may find it a little extra difficult in the beginning. The next thing, implementation versus interface. The idea that clients of some code only have a high level idea of what the code is doing and should not have exposed to them the implementation details and they should not rely on those implementation details. This goes by a lot of different names like abstraction, modularity. You may have seen this in terms of an object-oriented setting. Something that we won't do until part C of the course. It doesn't matter where you've seen it. And again it's the sort of thing you may be able to pick along the way but it is kind of assumed background. The sort of thing one would see in a first programming course. I'll refer to some basic data structures like linked lists and binary trees that often come up in introductory courses as well. And dynamic dispatch or method overriding or subclassing is something that students generally have seen before but we're actually not going to need it until late in the course and even then it will be reviewed. So if everything on this slide that you'd probably be okay without, this would be it. Now you'll notice I haven't really emphasized what language you need to have programmed in before because it doesn't really matter. I tend to sometimes assume more of a Java or C# sort of background, but not in the actual material, not anything you'll have to do for the homeworks or have to understand in a video. If you've only programmed in Python or JavaScript or something else, that's probably fine. What matters are the concepts on the previous slide. Now sometimes an optional videos compare to Java, for those of you that know it. And if you only know C#, Java will probably be fine. And I'll sometimes compare to C, which is a lower level programming language that is often a really nice contrast for some of the concepts we'll study in the course. But all of those specific comparisons will always be an optional material. And one reason why it doesn't matter what language you've used before, is that we're really going to start over from the beginning. But particularly early in the course, you may find it even more frustrating if you have a lot of programming experience because using ML can feel so foreign and so different. And that's actually a great thing because it means it doesn't matter exactly where your prior experience is. It's just we are going to go fast enough that if you haven't programmed before, it's going to just not make a whole lot of sense what we're doing. Okay, so what I want to do now is do an example of the sort of code that students at my university would be able to write or at least follow along with prior to taking the course that this MOOC is based on. Now, I want to emphasize that if you haven't seen Java before, this might not make sense. Hopefully some of it makes sense. You should also understand that as I write this code, first of all I'm the teacher, so I know what I'm about to do. And second, I'm actually cheating. I actually have a copy of the code I'm writing for you nearby, and I just looked at it. So don't take this as intimidating, just take it as an example of how throughout the course I am going to write a lot of code and I'm going to discuss concepts as I write the code that should, even if they sound a little foreign to you because of the strange syntax or maybe you haven't used exactly this terminology before. Some of what I'm doing should look like programming and feel like this sort of thing you have seen before. So to give you some sense of what I mean by programming experience, but again with all the different backgrounds and everything, it's just not something that I can promise will make sense to everyone and that's okay. All right so here I am. I often write code in front of you. And here is the only time, for a long long time I will write Java code for you. But in Java we would declare a class for a binary tree of integers. This would be something where any tree that's not empty which we'll represent with Java's null will have an integer in it. And, we'll have a left sub tree and a right sub tree. Those are the two child branches of the tree. So, this is a data structure where each part of the structure has an int and then two other structures which we're calling left and right. In Java, we would create one of these with something called a constructor. And this is how you define a constructor in Java that takes three arguments. And because I'm using a nice big font here, very little fits on a line. And then this would be some code. This is a method, although constructors are a little different in Java, where we would initialize the fields of our object. Too, in this case just be the three arguments, passed in. All right. And that's how we would create such a thing. We could then write a method on a tree that would say sum up all the numbers in a tree. So just take a tree and sum up all the numbers. And the way I would do that, here I'm going to do it recursively, is I would compute an answer, which I'm eventually going to return, and I'm going to include the i field. All right which I could write this .i or I could just write i, the this dot is not necessary in Java here. And then if the left child is not null then I need to add to ans and there's a faster way to write this I know,. The result of calling the sumAll method on the left child. And I then need to further add on the sum of recursively adding all the numbers in the right child. And this is how you would do such a recursive algorithm in Java. And if I've made any mistakes here, I always fix up the code before I post it, I actually, of course, am coding in front of you here and maybe making small typos as I go. And that would be our SumAll method. Let me show you one other thing, and here, I'm going to just paste this in so that you don't have to watch me type it all out. Here is another method, this one happens to be a static method, that's a distinction that doesn't matter to us too much, that just takes in an array of integers. This has nothing to do with binary trees anymore and just returns the maximum element. If you think about it, returning the maximum element for a collection, doesn't work very well if you don't have any numbers. So, this code happens to assume that the array has at least one element, which I'm putting in a comment here. And the way it does it, is it, starts with the first element of the array, which counts from 0 in Java, and in many programming languages. And then has a for loop that keeps saying if the next element on the right is greater then the answer computed so far. If so, it updates it. When we're done with this for loop, we return the answer. So this is just an example of how I code in class. And in a language here that you may or may not be familiar with. But when we get into ML, in the first real section of the course I will go slower, I will explain everything I'm doing. But this is how I talk about programming, in this case, relying on some experience you may have seen but more generally by explaining every little thing as I go. The class will feel a lot like this but with everything explained one piece at a time.

, how more complex software and algorithms and programs can fit together in an effective way. So perhaps that analogy will resonate with some of you. It's certainly a good way to motivate yourself early in the course when you're doing something that feels very uncomfortable or unfamiliar. And indeed I want to emphasize that here in part A of the course we're going to use the standard ML language, which probably very few of you used before. We may use a text editor you're not familiar with. What editor you use is optional. But, you may not have a familiar development environment that you're used to for other languages. And we're going to evaluate our programs using this thing called the read-eval-print loop. That will feel different than the normal compile and run cycle that you may be more familiar with. You're going to have to install software you're not familiar with. You're going to have to get these things up and running before you can really start on the content of homework 1. And I understand that's and extra burden, but I think it's also something that you will grant, that in computing is fairly common. That as you take different courses, as you take new jobs, as you do new things, you're always working in strange new environments and installing new tools. And while it may Not be fun and often causes complications and it can be aggravating at first. It's something you get more comfortable with time, and this course like many requires you to do a little of that right at the beginning so you can get started. Let me emphasize again, as I did in the very first video, that this course is not about ML. And when you get into part b, it's not about racket. And part c is not about ruby. These are means to other ends. These are chosen as languages that are particularly good fits for the topics we want to present. You could teach these concepts with other languages. But I've chosen these because I think they're particularly good tools for what we want to accomplish. And let me say right here in introducing the course that standard ML in particular is not a fashionable language that these days is used for real software and that's okay because we're not in the homeworks in this course trying to build real software. We're trying to give you the background for building better real software in other languages in the future. So there are closely related languages that are very active and effective, and still in much more common use today. In sort of decreasing similarity from standard ML, OCami, F#, Scala, and Haskell. Each would be an okay choice for part A of this course in various ways. I think standard ML is a slightly better choice. And in fact I could argue and will argue here briefly that it's a bit of a feature and not a bug that we're picking a language that doesn't have a lot of modern libraries, that doesn't do a lot of things in the modern software ecosystems. That way we can focus just on the core ideas. We won't be distracted by trying to do anything fancy. We won't have a lot of complications. That are common in modern software development. We get to focus on standard ML which in many ways, even compared to these other wonderful languages, is clean, compositional, and elegant in ways we're going to start seeing even in the first week of this course. Let me also emphasize that these introductory videos are a lot of text on PowerPoint and me just telling you stuff. That's not the way most of the course works. I think that you learn about software by writing code and trying things out and you'll see that we do that in a lot of the videos. There's in video questions with quick quizzes on things. in short I actually think that most the videos in this course are better than the introduction videos but introducing things is just something you need to get through and we'll get on to the good stuff soon enough.
5000 / 5000
翻译结果
在这个视频中，我想讨论推荐的课程背景，这当然是一个非常重要的话题，但也是一个非常难以讨论的话题，因为有这么多不同的背景可能非常适合我们要去学习。所以要强调的关键是一方面，这不是一门介绍性的编程课程。我设计材料的方式假设您之前已经使用不同的语言进行过编程。然而，它不必是大量的编程。如果您参加过一两门其他编程课程并取得了成功。这可能没问题。它不一定是课程。你本可以在工作中或在你自己的学习中或其他任何事情上掌握它。另一方面，这不是高级编程语言课程。我通常在校园里教这些二年级学生，而不是具有多年专业行业经验的人，甚至不是我认为去年本科课程的人。所以它不是入门课程，你之前应该编程过，但它不是特别高级的课程。我想让你更好地理解这一点。所以这里有一些主题，我假设您以前在编程时会看到。所以诸如变量和方法、函数或过程的参数之类的东西。任何，如果你已经调用了东西的方法，那很好，但是需要参数并返回结果的东西。某种 if 语句，某种分支 for，我在某些情况下这样做，在其他情况下，我这样做。你可能见过某种循环。你可能见过某种数组。即使在这里，至少，在编程语言的一部分中，我们不会有循环或数组。我确实假设您以前见过递归。现在我们将获得更多的递归练习。我们将在几乎所有问题、几乎所有家庭作业中使用递归。但是，如果您以前从未见过它，我们将走得非常快。递归是根据自身定义一些计算，根据自身定义一些数据的想法。我们会得到更多的练习，但是我组织这门课程的方式假设之前有一些接触，如果你还没有看过，你可能会发现它在开始时有点困难。接下来，实现与接口。某些代码的客户端只对代码正在做什么有一个高级别的想法，不应该向他们公开实现细节，他们不应该依赖这些实现细节。这有很多不同的名称，如抽象、模块化。您可能已经在面向对象的设置中看到了这一点。在课程的 C 部分之前我们不会做的事情。你在哪里见过它并不重要。同样，这是您可能能够沿途选择的那种东西，但它是一种假定的背景。人们在第一门编程课程中会看到的那种东西。我将参考一些基本的数据结构，如链表和二叉树，它们也经常出现在介绍性课程中。动态分派或方法覆盖或子类化是学生们以前通常见过的东西，但我们实际上直到课程后期才需要它，即使到那时我们也会对其进行审查。所以如果这张幻灯片上的所有内容你可能没有，那就是它了。现在你会注意到我之前并没有真正强调你需要用什么语言编程，因为这并不重要。有时我倾向于假设更多的 Java 或 C# 类背景，但不是在实际材料中，不是你必须为家庭作业做的任何事情或必须在视频中理解。如果您只使用 Python 或 JavaScript 或其他语言进行编程，那可能没问题。重要的是上一张幻灯片中的概念。现在，对于那些了解 Java 的人来说，有时可以将可选视频与 Java 进行比较。如果您只知道 C#，Java 可能会很好。有时我会与 C 进行比较，C 是一种较低级别的编程语言，对于我们将在课程中学习的某些概念而言，它通常是一个非常好的对比。但是所有这些特定的比较将始终是可选材料。您之前使用什么语言并不重要的一个原因是，我们真的要从头开始。但特别是在课程的早期，如果您有很多编程经验，您可能会发现它更令人沮丧，因为使用 ML 会让人感觉如此陌生和如此不同。这实际上是一件很棒的事情，因为这意味着您之前的经验在哪里并不重要。只是我们会走得足够快，如果你以前没有编程过，那么我们正在做的事情就会完全没有意义。好的，所以我现在想做的是做一个示例，说明我大学的学生在参加 MOOC 基础课程之前可以编写或至少遵循的代码类型 

编辑。现在，我想强调的是，如果您以前没有见过 Java，这可能没有意义。希望其中一些是有道理的。你也应该明白，在我写这段代码的时候，首先我是老师，所以我知道我要做什么。其次，我实际上是在作弊。实际上，我在附近有一份我正在为您编写的代码的副本，我只是看了看。所以不要把这当作吓人的，只是把它作为一个例子，说明我将如何在整个课程中编写大量代码，并且我将在编写代码时讨论概念，即使它们听起来很由于奇怪的语法，或者您以前没有完全使用过这个术语，所以对您来说有点陌生。我正在做的一些事情应该看起来像编程，感觉就像你以前见过的那种事情。因此，为了让您了解我所说的编程经验是什么意思，但同样有所有不同的背景和一切，我不能保证对每个人都有意义，这没关系。好吧，我来了。我经常在你面前写代码。而这里也是唯一一次，很长一段时间我都会为你写Java代码。但是在 Java 中，我们会为整数二叉树声明一个类。这将是任何我们将用 Java 的 null 表示的非空树将在其中包含一个整数的情况。并且，我们将有一个左子树和一个右子树。这是树的两个子分支。所以，这是一个数据结构，其中结构的每个部分都有一个 int 和另外两个我们称之为 left 和 right 的结构。在 Java 中，我们将使用称为构造函数的东西创建其中之一。这就是你如何在 Java 中定义一个接受三个参数的构造函数。而且因为我在这里使用了很好的大字体，所以很少适合一行。然后这将是一些代码。这是一种方法，尽管构造函数在 Java 中略有不同，我们将在其中初始化对象的字段。太，在这种情况下只是三个参数，传入。好吧。这就是我们如何创造这样的东西。然后，我们可以在树上编写一个方法，该方法可以对树中的所有数字求和。所以只需取一棵树并总结所有数字。我这样做的方式，在这里我将递归地进行，是我将计算一个答案，我最终将返回该答案，并且我将包括 i 字段。好吧，我可以写这个 .i 或者我可以写 i，这个点在 Java 中不是必需的。然后如果左孩子不为空，那么我需要添加到 ans 并且我知道有一种更快的方法来写这个。在左孩子上调用 sumAll 方法的结果。然后我需要进一步添加递归添加右孩子中所有数字的总和。这就是您在 Java 中执行这种递归算法的方式。如果我在这里犯了任何错误，我总是在发布之前修正代码，当然，我实际上是在你面前编码，并且可能会在我写的时候犯一些小的错别字。这就是我们的 SumAll 方法。让我告诉你另一件事，在这里，我将把它粘贴进去，这样你就不必看着我把它全部打出来。这是另一种方法，这个方法恰好是一个静态方法，这是一个对我们来说无关紧要的区别，它只接收一个整数数组。这与二叉树无关，只返回最大元素。如果您考虑一下，如果您没有任何数字，则返回集合的最大元素不会很好地工作。所以，这段代码碰巧假设数组至少有一个元素，我在这里添加了一个注释。它的工作方式是从数组的第一个元素开始，在 Java 和许多编程语言中，它从 0 开始计数。然后有一个 for 循环，它不断说右边的下一个元素是否大于到目前为止计算的答案。如果是这样，它会更新它。当我们完成这个 for 循环时，我们返回答案。所以这只是我如何在课堂上编码的一个例子。在这里使用一种您可能熟悉也可能不熟悉的语言。但是当我们进入 ML 时，在课程的第一个真正的部分我会放慢速度，我会解释我正在做的一切。但这就是我谈论编程的方式，在这种情况下，依赖于您可能已经看到的一些经验，但更一般地是通过解释每件小事。这门课会感觉很像这样，但每次都解释一遍。 
### 1.5 Why Part A, Part B, Part C 5:24
I want to discuss why the Programming Languages course is actually on Coursera, three courses Part A, Part B, Part C, why we made that decision and how the three pieces fit together. So the biggest reason we split it into three parts is because it's a large course, there's a lot of material. People who've finished the entire course, Part A, Part B and Part C, have spent somewhere between 100 and 200 hours. It very much depends on the person and how quickly they go through the material. And so it just seemed like a lot, the way most modern courses, online courses are at this point to call that all one course. This is something that corresponds to something that students in my university do over a 10 or 11 week period while they're not trying to do a lot of other things in their lives, although they are taking a couple other courses at the same time. Now splitting it up was not easy for me to do. If you can imagine writing a novel and then having someone say, I really only want to read the first few chapters. That's kind of how I feel splitting up the course. It really does all fit together, there are cross-cutting themes that only really make sense once you get to the end. There are neat things that tie together once you get into Part B and Part C. There are contrasts that we can't do until late in the course. And overall, I've put a lot of thought into what is in this course and just as importantly, what is not, to have it all sort of packaged up as one piece that tells a consistent story from beginning to end. And I cannot emphasize enough how much I want all of you to participate all the way through to the end of Part C. And, indeed, the goal here was not to split it into three courses that try to make more money or make you think you're doing three times more than you're actually doing. And usually, when I say the course, I mean everything. So what I've done here is basically argue that I shouldn't have split it up, but obviously we did, so let me now explain the reasons why we did. The biggest one is that there's just more material and it's more challenging and you in some sense deserve the credit for completing three courses worth of material and the places where we split it are reasonable intermediate milestones. They are places where you should feel very proud of getting that far and if you choose to go no further, you will have learned something and they sort of are reasonable stopping points that make sense. So you deserve recognition for that, it's something that when we had everything together, as we did when we first offered this MOOC, we didn't have. And so I think that's a great step in a really good direction. It will also give you a chance to take a break, if you will. As you go through Part A, you really don't want to lose momentum. You want to do each piece of the course in sort of consecutive weeks, so that you can keep track of everything. But if you wanted to take a couple weeks off or a month off before starting Part B. Well, it might be a little tough to remember where you were and get started again but, again, because it's a reasonable stopping point, I actually think that makes a lot of sense. And so it's a way that kind of let you go through the overall course at a slower pace by going sort of at a certain pace for Part A and then taking a break before Part B that sort of thing. So in terms of how it breaks down, I say unfortunately, each part of the course is done in a different programming language. I say unfortunate because it feeds back into this idea that the parts of courses are about the languages where I keep emphasizing that they're really not. But nonetheless, that is how things break down. I should also emphasize that we didn't break it into thirds, right? We picked the reasonable stopping points, and the way that worked out is Part B is definitely the biggest part of the three parts. And could we divide Part A into two smaller pieces, maybe we could but I don't see a natural breaking point, so I didn't, all right? So the way this breaks down is that Part A has three homework assignments and then a fourth substantial section that has no homework assignment but does have an exam, so to finish Part A, is really four major units of the course. Then Part B is only two more units, so about half the size of Part A, although, the second of those units has what's usually considered the most challenging, and also most rewarding homework in the course. And then Part C, where we study object oriented programming and then compare and contrast it back with the functional programming that we do in Part A and Part B, has just another two homeworks but then a final exam. And that exam focuses mostly on Parts B and C. because you'll notice Part B doesn't have an exam. But refers a little bit to contrast with Part A, because when you get to the end of the course you'll see that that's an appropriate thing to do. So altogether, things are one course in three parts. I hope you appreciate that. It's perhaps obvious, but I'll say it, that you can't really do Part B without Part A and you can't really do Part C without Parts A and Part B because they often refer back to earlier parts. And that's the story of how we divided things up and we hope that you make the most of the material available to you in the way that makes the most sense to you.
我想讨论为什么编程语言课程实际上是在 Coursera 上，三门课程 A、B、C 部分，我们为什么做出这个决定以及这三部分如何结合在一起。所以我们把它分成三个部分的最大原因是因为这是一个很大的课程，有很多材料。完成整个课程（A 部分、B 部分和 C 部分）的人花费了 100 到 200 个小时之间的时间。这在很大程度上取决于个人以及他们阅读材料的速度。所以它看起来很多，大多数现代课程，在线课程在这一点上都称之为一门课程。这与我大学的学生在 10 或 11 周内所做的事情相对应，而他们在生活中并没有尝试做很多其他事情，尽管他们同时参加了其他几门课程。现在拆分对我来说并不容易。如果你能想象写一部小说然后有人说，我真的只想读前几章。这就是我拆分课程的感觉。它真的很适合在一起，有一些交叉主题，只有在你走到最后才真正有意义。一旦你进入 B 部分和 C 部分，就会有一些巧妙的东西联系在一起。有些对比我们直到课程后期才能做。总的来说，我已经对这门课程的内容进行了很多思考，同样重要的是，什么不是，把它打包成一个整体，从头到尾讲述一个一致的故事。我多么希望你们所有人一直参与到 C 部分的结尾，我再怎么强调也不为过。 事实上，这里的目标不是将它分成三门课程，试图赚更多的钱或让你思考你做的比你实际做的多三倍。通常，当我说课程时，我的意思是一切。所以我在这里所做的基本上是争辩说我不应该拆分它，但显然我们做到了，所以现在让我解释我们这样做的原因。最大的一个是材料更多，而且更具挑战性，从某种意义上说，你完成了三门课程的材料值得称赞，而我们将其拆分的地方是合理的中间里程碑。在这些地方，您应该为取得如此大的成就而感到非常自豪，如果您选择不再继续，您将学到一些东西，而且它们是合理的、有意义的停靠点。所以你应该得到认可，当我们把所有东西都放在一起时，就像我们第一次提供这个 MOOC 时那样，我们没有。所以我认为这是朝着一个非常好的方向迈出的重要一步。如果您愿意，它还会给您一个休息的机会。当您完成 A 部分时，您真的不想失去动力。您希望在连续几周内完成课程的每一部分，以便您可以跟踪所有内容。但是如果你想在开始 B 部分之前休息几周或一个月。 好吧，记住你在哪里并重新开始可能有点困难，但是，再次，因为这是一个合理的停止点，我实际上认为这很有意义。所以这是一种让你以较慢的速度完成整个课程的方式，通过在 A 部分以一定的速度进行，然后在 B 部分之前休息一下。因此，就其分解方式而言，不幸的是，课程的每个部分都是用不同的编程语言完成的。我说不幸是因为它反馈了这样一种想法，即课程的部分是关于语言的，我一直强调它们实际上不是。但无论如何，事情就是这样崩溃的。我还要强调一下，我们没有把它分成三份，对吧？我们选择了合理的停靠点，得出的方法是B部分绝对是三部分中最大的部分。我们能否将 A 部分分成两个更小的部分，也许我们可以，但我没有看到一个自然的突破点，所以我没有，好吗？所以这个分解的方式是 A 部分有三个家庭作业，然后是第四个实质性部分，没有家庭作业但有考试，所以要完成 A 部分，实际上是课程的四个主要单元。然后 B 部分只有两个单元，所以大约是 A 部分的一半大小，不过，这些单元中的第二个单元通常被认为是课程中最具挑战性的作业，也是最有价值的作业。然后是 C 部分，在那里我们学习面向对象的编程，然后将它与我们在 A 部分和 B 部分中所做的函数式编程进行比较和对比，还有另外两个家庭作业，然后是期末考试。该考试主要关注 B 部分和 C 部分。因为您会注意到 B 部分没有考试。但是稍微提及与 A 部分的对比，因为当您完成课程时，您会发现这是一件合适的事情。总而言之，事情是一门课程，分为三个部分。我希望你欣赏 

在。 也许很明显，但我要说的是，没有 A 部分你就不能真正做 B 部分，没有 A 部分和 B 部分你就不能真正做 C 部分，因为它们经常参考之前的部分。 这就是我们如何划分事物的故事，我们希望您以对您最有意义的方式充分利用您可用的材料。 
### 1.6 Grading Policy 9:07
 In this video, I want to go over how grading will work in this course. All of this information is detailed elsewhere. So in that sense, you could consider this video optional. But I think that it's helpful to highlight key points, I've also learned that people are less likely to miss key details if there is a video that goes over some of the information. I also don't consider grades to be a major focus in these online courses and I hope that's true for you as well, but I know these things matter to people. And so, I want to have a clear policy and make sure everyone understands it. The key issue in this video, of course is what the policies are, but I also tried to give a bit of rationale to justify why that can help things make a little more sense. And also, let me acknowledge that there are trade offs and no perfect policy that's going to be the best fit for whatever ones trying to get out of this course. So for each homework, you will first, submit it to an auto-grader. A computer program that will look at your assignment. Run it on test cases, analyze what language features you're using and assign a grade. And we do this in a more strict fashion that in many of the MOOCs out there. So the basic thing is too pass, you need too get 80%. I actually think that is a reasonable bar. I hope that you will continue trying until you get a hundred percent and fix things up, but that is the way it works. If we ever change that 80% threshold, I may not rerecord this video, but I think its in about the right place. And then the strict thing is that we're only going to let you submit at most once per day. Now, why are we doing that? I'll explain more on the next slide, but it really means you need to do the whole homework together. So what we don't allow you to do in a sort of reasonable way is just do the first problem and then see how you're doing, and then just the next little problem, and see how you're doing. And I know that some of you will prefer that, but there are good pedagogic reasons to make it more like things on a traditionally university campus. Well, the homework is do it in the end of the week and you do your best job as you can and everything and then you submit it. Now, the worst part is with this policy is when you make a tiny little mistake that causes your code to not compile. Or if you upload the wrong file, then you're going to have to wait til the next day to submit what you meant to submit in the first place. And that's a casualty of this policy and I apologize in advance for it, but there's not a good easy way to fix that. And I guess all I can really say is well, you'll only have to wait a day. So this is a stricter policy than most MOOCs, but it's actually still much more lenient than the new traditional university course. You get to keep submitting every day, if you want to. Although I really encourage you to do the assignment, really try to be confident you have everything right and then submit it. And then if you want to try again to do better, well then, of course, that opportunity's available to you. I should also point out that this MOOC also used to have a much stricter policy where you could only submit twice and then that was it. But in the more modern model that you can continue in the MOOC, learning until you can master the material and finish. Of course, having a hard limit where you can never submit again doesn't make any sense. And so, once per day is actually a pretty lenient policy compared to where things used to be. So, what I'm really going for here is unlike a lot of online courses where you're just trying to get through a tutorial and move on to the next thing. I don't want you to keep twiddling and changing little things, and using the auto-grader as a substitute for your own understanding of the material, and your own testing of the programs. I understand that can convenient. That it can be frustrating to put a lot of time in on homework and then when you go to the auto-grader, have it tell you lots and lots of things are wrong. But I truly believe, the best way to learn this material is to focus on the assignment and think to yourself about how the pieces fit together and is everything correct. And we give you a lot of help in the assignment, the types the functions should have, example test cases. So, you can do that reasoning on your own and then the auto-grader can be just a sanity check when you're done. That's the idea. And if we let you just use the auto-grader as much as you wanted, it'd be much, much easier to get everything right. Basically, you would just fix things one at a time until you happen to pass all the test cases and I think that's not the way to learn the material in the course. Now I want to say, there is no perfect policy. This grading policy is not perfect. There's trade-offs here and it's just sort of the best compromise. I need to pick one policy for everyone and that's what we've come up with. A few details and other parts of the course, that was the main auto-grader policy. So first of all, we have some challenge problems on the homework. They are not worth very much credit. They're just a few percent bonus, if you will. And I would love to take someone who turn in the homework. Got everything right and got the challenge problems right and give them say, 104% out of a 100%. Now at the time I'm recording this video, the Coursera platform doesn't let me give more than 100% the way we're doing the auto-grading infrastructure. So unfortunately, I can't give you more than 100%. You'll get it in your text feedback, you should feel very good about getting it. But in terms of your official course score and course record, it'll max out at 100% and maybe we can fix that sometime in the future. Let me also talk about peer assessment, which I think is a really important part of this course. After you're done with the auto-grader for an assignment, then you need to turn in your assignment again for others in the course to look over your code and give you feedback on your style. And you're going to give feedback to three other people in the course on the style of their submissions. Now the way this is going to work is you can on the Coursera platform participate in peer assessment at any point, but you should not until you pass the auto-grader and you won't be able to do it correctly. Because the file that has the detailed grading instructions for peer assessment also has a sample solution in it. And therefore, won't be available to you until you get that 80% threshold on the auto-grader. Because otherwise, you would have a sample solution sitting there right in a file available to you, which would be far too tempting. And really, demotivating for those of you working hard on the homework. So the idea is after you past the grading threshold, then the peer assessment rubric will be available to you in that separate file, then you can participate in the peer assessment and you'll have that file that you need in order to do the peer assessment. Now the actual pair assessment, I think is really crucial for learning a lot from the course and style, but it's not going to affect your grade very much. We'll make it worth a small amount. Basically, any score you get on the pair assessment is enough to continue in the course and it will just have a modest 10% affect on your overall course grade. So we're doing this, because just passing the auto-grader would give a bad impression on what's important in the course. The test cases are not everything that matters in writing clean elegant code that demonstrates you understand the concepts in the course and I've learned that people learn a ton by looking at other solutions, and getting feedback from peers on their own work. So, it is really important to be kind and helpful. We are doing this not to create a mean grading system. But in fact, to provide a constructive opportunity for everyone too help each other and we tried to structure it in a way that will be meaningful too you in learning the material with out being too time consuming. The exams, when we get there. There's one at the end of part A and then a second one all the way at the end of part C. Like on the programming assignments, you can take it at most once per day. You need to get at least an 80% and I want these to be timed exams. Now, the Coursera platform at the time of this video recording won't enforce a time limit. But part of the honor system is obeying it, so that you study for the exam and then take the exam. And if you don't do well enough, because you studied the wrong things, then you'll have the opportunity to take it again. But I don't want you to just open the exam and then go and look up each question, and spend hours doing it that way. Because I think you will learn far more by studying for the exam than you will by just answering the questions on the exam. Now, what's the exam going to be like? Well, we'll get there in a few sections. But we provide practice exams, which will give you a good sense of what questions would be like and it's an opportunity to really engage in the material in a different format than just writing programs and participating in the auto-grader and the peer assessment. So with that, we are through the grading policy. I apologize for marching you through those details, but I do think the homeworks and exams including the peer assessment for the homework assignments are a great way to learn this material. Certainly, you will learn far more by doing the homeworks than just by watching the videos. And I hope you will enjoy them, as challenging exercises that will stretch your mind and cause you to learn a lot.

在本视频中，我想了解评分在本课程中的工作方式。所有这些信息都在别处有详细说明。因此，从这个意义上说，您可以将这个视频视为可选的。但我认为突出关键点是有帮助的，我还了解到，如果有视频涵盖了某些信息，人们就不太可能错过关键细节。我也不认为成绩是这些在线课程的主要关注点，我希望这对您也是如此，但我知道这些事情对人们很重要。所以，我想有一个明确的政策，并确保每个人都理解它。这个视频中的关键问题当然是政策是什么，但我也试图给出一些理由来证明为什么这可以帮助事情变得更有意义。而且，让我承认，有权衡取舍，没有完美的政策最适合试图退出本课程的任何人。因此，对于每项作业，您首先将其提交给自动评分器。一个计算机程序，它将查看您的作业。在测试用例上运行它，分析您使用的语言功能并分配等级。我们以比许多 MOOC 更严格的方式来做到这一点。所以基本的事情是太通过了，你也需要得到 80%。其实我觉得是合理的吧。我希望你会继续尝试，直到你得到 100% 并解决问题，但这就是它的工作方式。如果我们改变 80% 的门槛，我可能不会重新录制这个视频，但我认为它在正确的地方。然后严格的是，我们只会让您每天最多提交一次。现在，我们为什么要这样做？我将在下一张幻灯片中进行更多解释，但这确实意味着您需要一起完成所有作业。所以我们不允许你以一种合理的方式做的就是先做第一个问题，然后看看你做得如何，然后再做下一个小问题，看看你做得如何。我知道你们中的一些人会更喜欢这样，但有很好的教学理由让它更像传统大学校园里的东西。嗯，家庭作业是在周末完成，你尽你所能做最好的工作，然后你提交它。现在，这个策略最糟糕的部分是当你犯了一个小错误导致你的代码无法编译时。或者，如果您上传了错误的文件，那么您将不得不等到第二天提交您最初打算提交的文件。这是这项政策的牺牲品，我提前为此道歉，但没有一个很好的简单方法来解决这个问题。我想我只能说很好，你只需要等一天。所以这是一个比大多数MOOCs更严格的政策，但它实际上仍然比新的传统大学课程宽松得多。如果您愿意，您可以每天继续提交。尽管我真的鼓励您完成作业，但请务必确保您做对了一切，然后再提交。然后如果你想再次尝试做得更好，那么，当然，这个机会对你来说是可用的。我还应该指出，这个 MOOC 也曾经有一个更严格的政策，你只能提交两次，然后就是这样。但是在更现代的模型中，您可以在 MOOC 中继续学习，直到您掌握材料并完成为止。当然，有一个你永远不能再次提交的硬限制没有任何意义。因此，与过去相比，每天一次实际上是一个相当宽松的政策。所以，我在这里真正要做的与许多在线课程不同，在这些在线课程中，您只是试图完成教程并继续进行下一件事。我不希望你一直摆弄和改变小东西，并使用自动评分器来代替你自己对材料的理解和对程序的测试。我明白，可以方便。花很多时间做家庭作业，然后当你去自动评分机时，它会告诉你很多很多事情是错误的，这可能会令人沮丧。但我真的相信，学习这些材料的最好方法是专注于作业，并自己思考这些部分如何组合在一起以及一切是否正确。我们在分配中为您提供了很多帮助，函数应该具有的类型，示例测试用例。因此，您可以自己进行推理，然后自动评分器可以在您完成后进行完整性检查。这就是想法。如果我们让您随心所欲地使用自动分级机，那么一切都会变得更容易。基本上，您只需一次解决一个问题，直到您碰巧通过了所有测试用例，我认为这不是学习课程材料的方式。现在我想说，没有完美的政策。这种分级政策并不完美。这里有权衡，这只是最好的妥协。我需要为每个人选择一项政策，这就是我们提出的。课程的一些细节和其他部分， 

这是主要的自动分级机政策。所以首先，我们在作业上有一些挑战性的问题。他们不值得太多的信任。如果您愿意，它们只是百分之几的奖金。我很想带一个交作业的人。把一切都做对了，把挑战问题做对了，给他们说，100% 中的 104%。现在，在我录制此视频时，Coursera 平台并没有让我提供超过 100% 的自动评分基础设施。所以不幸的是，我不能给你超过 100%。你会在你的文本反馈中得到它，你应该对得到它感觉很好。但是就你的官方课程分数和课程记录而言，它会达到 100%，也许我们可以在未来的某个时候解决这个问题。让我也谈谈同伴评估，我认为这是本课程的一个非常重要的部分。使用自动评分器完成作业后，您需要再次上交作业，让课程中的其他人查看您的代码并就您的风格提供反馈。您将向课程中的其他三个人提供关于他们提交的风格的反馈。现在的工作方式是，您可以在 Coursera 平台上随时参与同行评估，但在通过自动评分器之前您不应该参与，否则您将无法正确进行。因为有同行评估的详细评分说明的文件中也有示例解决方案。因此，在您在自动分级器上获得 80% 的阈值之前，您将无法使用。因为否则，您将有一个示例解决方案就在您可用的文件中，这太诱人了。真的，让你们这些努力做家庭作业的人失去动力。所以这个想法是在您超过评分阈值之后，您将可以在该单独的文件中使用同行评估量规，然后您可以参与同行评估，并且您将拥有进行同行评估所需的文件评估。现在实际的配对评估，我认为对于从课程和风格中学到很多东西真的很重要，但它不会对你的成绩产生太大影响。我们会让它值一点钱。基本上，您在配对评估中获得的任何分数都足以在课程中继续学习，并且只会对您的整体课程成绩产生 10% 的适度影响。所以我们这样做，因为只是通过自动评分器会给课程中的重要内容留下不好的印象。在编写干净优雅的代码以证明您理解课程中的概念时，测试用例并不是最重要的，我了解到人们通过查看其他解决方案并从同行那里获得他们自己工作的反馈来学习大量知识。所以，善良和乐于助人真的很重要。我们这样做不是为了创建平均评分系统。但事实上，为了给每个人提供一个建设性的机会也互相帮助，我们试图以一种对你学习材料也有意义的方式来构建它，而不会太耗时。考试，当我们到达那里时。在 A 部分的末尾有一个，然后在 C 部分的末尾一直有第二个。就像编程作业一样，你每天最多可以做一次。你需要至少达到 80%，我希望这些是定时考试。现在，录制此视频时的 Coursera 平台不会强制执行时间限制。但是荣誉系统的一部分是服从它，所以你为考试而学习，然后参加考试。如果你做得不够好，因为你学习了错误的东西，那么你就有机会再次接受它。但我不希望你只是打开考试，然后去查找每个问题，然后花几个小时这样做。因为我认为通过为考试而学习，你会比仅仅通过回答考试中的问题学到更多。现在，考试会是什么样子？好吧，我们将在几个部分中介绍。但是我们提供练习考试，这将使您很好地了解问题会是什么样子，并且这是一个真正以不同形式参与材料的机会，而不仅仅是编写程序和参与自动评分器和同行评估。因此，我们通过了分级政策。我很抱歉让你详细了解这些细节，但我确实认为家庭作业和考试，包括家庭作业的同伴评估是学习这些材料的好方法。当然，通过做功课你会学到更多，而不仅仅是观看视频。我希望你会喜欢它们，因为它们是具有挑战性的练习，可以伸展你的思维并让你学到很多东西。 
### 1.7 Optional: Very High-Level Outline 7:31
The last topic I want to cover in the introductory material, before we really start the course and start on this amazing journey, is just a high-level outline of where we're going. I want this to be optional because, first of all, it's fine to just start and see where we're going as we get there. But also because there is no way to discuss the course in just a few minutes without using a bunch of jargon and terminology that I don't expect you to know yet. The whole point of taking the course is so that you learn about these things, and I would hate for you to watch this video, think, I have no idea what he's walking about, I guess I shouldn't continue on, when that's exactly why you should continue on. So that you can learn about all these things that we'll explain one piece at a time. With that said, let's kind of give the overview in case you've seen some of these things before and want to know, am I going to get to some new stuff, or I've heard I really want to learn about something, is that going to come up? I'm certainly not going to list every topic here. There are just too many, there's many weeks worth of stuff, but at a very high level. Here in Part A of the chorus, we are going to do the basics of functional programming, EMA statically typed language, namely ML. We are going to start with basics, things like variables and scope, numbers and addition. Don't worry, of course you've seen that before when programming before but in a precise way. We will build up to functions, which I like methods but without objects, if you seen object oriented programming. We're going to do recursion, in fact it's the way we're going to write computations as well as other computations. We're going to have ways to build larger data structures both tuples and lists. That's all going to be in section one. So with that and the software installation stuff it's a fair amount, especially in an unusual environment. So we give extra time, that's really like you have about twice as long for that section as for the ones that follow. After that, section two is all about datatypes and pattern-matching. This is a new way that most of you probably have not seen before to represent larger data structures, to model different data. To access that data, it's a great way to think about traversals over compound data structures of different types, that will be the focus in section 2, we'll also do a little bit on tail recursion, which is the key thing you need to understand in order to use recursion efficiently in modern languages like we're using here. Then in section three, we get to what a lot of people think is kind of the biggest feature of functional programming which is functions as first class values. Having functions that you pass around the other functions, return from functions, put in data structures, it's a large topic, it has very interesting meaning what it means to pass around functions and that will be our focus in section three And then in the last section of Part A, we'll both learn type inference, how you can have a language with type errors, with a type system, where the programmer doesn't have to write down types, because the compile infers them for us. And a separate but important topic of modules, support that ML has for. Collecting together types, and values, and functions over that type in a way that enforces that clients cannot misuse an abstraction. It's the way we think in this sort of language about separating an interface from an implementation. So overall these are several of the key pieces that give you a precisely specified introduction to functional programming built up piece-by-piece. And these are the top high level topics for part A of the course. Now when we begin in the part B. Well, first re-do most of what we did in part A In a dynamically typed language. What changes, what are the trade offs, when you don't have very many programs being rejected before they run, instead you just rely on runtime failures in a dynamically type setting. And we will get there when we get there. And then, in the second unit in part B, we will actually implement a programming language using an interpreter. And that will lead to a very nice discussion of how you implement programming languages, what it means to be a programming language and the implementation of it, and show you that you can actually implement your own language Well one that we give you. In fact, one that has first class functions. So often the best way to understand something is to implement it yourself and we are going to give you that experience with first class functions. We will also in that section six if you will, the second unit in part B, compare static versus dynamic typing. We don't do that right away in section five because first we want to get experience with dynamic typing. And then we can have a good discussion sort of comparing ML and Racket along this important design dimension where they make different high level decisions. And then in Part C, we now visit object oriented programming, which many of you would have seen before, and it's okay if you haven't. And in the first we sort of do some basics in Ruby, and a learn a lot about Ruby. And because it is our third language we see we can learn a lot more quickly. We focus on how it's sort of even more dynamic Then racket and how it is even more object oriented than you may be used to in languages like Java or C#. Because in Ruby, really everything is an object. Even numbers are objects. And then in the last section of the course, we compare object-oriented with functional, and we do a number of more advanced object-oriented topics, things like mixins and double dispatch, and that makes the last homework of the course fairly challenging when we use some non-trivial object-oriented idioms to compare some of these ideas. So I really encourage Part C, of course that's a long way off from us, a lot of people think, well I already know OOP, I'm really here for the functional stuff so I'm not going to do Part C. I encourage you to continue to Part C exactly for that compare and contrast and complementing things. I think it's also worth pointing out that some people who have done Part C, feel that I am kind of anti OOP and I'm somewhat unfair to object oriented programming compared to functional programming. I think that's mostly not true. I have no problem with object oriented programming, but I am somewhat purposely in this course Pushing the functional perspective, because it is the less well known one, and I think it is a good opportunity to do so. And to point out that while yes there are situations where the OOP mindset is ideal. Let's investigate somewhere where the OOP mindset is possible, but not ideal. So yes there are some things in that last homework assignment that I make you do in an object way even though that tends to be somewhat cumbersome. And this is not a criticism of any language, there are languages that encourage objects to give other ways to do things. There are languages that encourage functional style even when the functional style is not perfect. so you will not see from this course from the beginning to the end have me saying one approach is always better than another approach. I do point out when the functional approach is a good one. Sometimes even it's a better one but you will leave this course with a lot of food for thought and a lot of new perspectives and that is my entire goal. All right, that's the introduction. Let's start and dig in with section one when you get to the next video.

在我们真正开始课程并开始这个惊人的旅程之前，我想在介绍性材料中讨论的最后一个主题只是我们要去的地方的高级概述。我希望这是可选的，因为首先，可以开始并在到达那里时看看我们要去哪里。但也因为没有办法在几分钟内讨论课程而不使用一堆我不希望你知道的行话和术语。参加课程的全部目的是让你了解这些事情，我讨厌你看这个视频，想，我不知道他在做什么，我想我不应该继续，当那正是为什么你应该继续。这样您就可以了解所有这些内容，我们将一次解释一个部分。话虽如此，让我们提供一个概述，以防您以前看过其中的一些东西并想知道，我是要接触一些新东西，还是听说我真的想了解一些东西，是那会出现吗？我当然不会在这里列出每个主题。有太多，有好几个星期的东西，但在一个非常高的水平。在合唱的 A 部分，我们将学习函数式编程的基础知识，即 EMA 静态类型语言，即 ML。我们将从基础开始，比如变量和作用域、数字和加法。别担心，当然，您之前在编程时已经看到过，但是以一种精确的方式。如果你看过面向对象的编程，我们将构建函数，我喜欢方法但没有对象。我们将进行递归，实际上这是我们编写计算以及其他计算的方式。我们将有办法构建更大的数据结构，包括元组和列表。这将在第一节中进行。所以有了它和软件安装的东西，这是一个相当大的数量，尤其是在一个不寻常的环境中。所以我们给了额外的时间，这真的就像你在那个部分的时间是接下来的时间的两倍。在那之后，第二部分是关于数据类型和模式匹配的。这是一种新的方式，你们中的大多数人可能以前从未见过表示更大的数据结构，对不同的数据进行建模。要访问这些数据，这是考虑遍历不同类型的复合数据结构的好方法，这将是第 2 节的重点，我们还将在尾递归上做一点，这是您需要做的关键理解以便在我们在这里使用的现代语言中有效地使用递归。然后在第三节中，我们将了解很多人认为函数式编程的最大特征，即函数作为一等值。将函数传递给其他函数，从函数返回，放入数据结构，这是一个很大的话题，它具有非常有趣的意义，传递函数意味着什么，这将是我们在第三节中的重点，然后在最后在 A 部分的部分，我们都将学习类型推断，如何使用具有类型错误的语言，使用类型系统，程序员不必写下类型，因为编译会为我们推断它们。还有一个单独但重要的模块主题，支持机器学习。以强制客户端不能滥用抽象的方式将类型、值和函数收集在一起。这是我们在这种语言中思考将接口与实现分离的方式。所以总的来说，这些是几个关键部分，它们为您提供了对逐个构建的函数式编程的精确指定的介绍。这些是课程 A 部分的顶级高级主题。现在，当我们开始 B 部分时。首先，用动态类型语言重新做我们在 A 部分中所做的大部分工作。当你没有很多程序在运行之前被拒绝时，你会发生什么变化，有什么权衡，而你只是依赖动态类型设置中的运行时失败。当我们到达那里时，我们就会到达那里。然后，在 B 部分的第二个单元中，我们将使用解释器实际实现一种编程语言。这将引发关于如何实现编程语言、成为一种编程语言及其实现的意义的非常好的讨论，并向您展示您实际上可以实现您自己的语言以及我们提供给您的语言。事实上，它具有一流的功能。通常，理解某事的最佳方式是自己实现它，我们将为您提供一流功能的体验。如果您愿意，我们还将在第 6 部分（B 部分的第二单元）中比较静态类型与动态类型。我们不会在第 5 节中立即这样做，因为首先我们想获得动态类型的经验。然后我们可以在这个重要的设计维度上进行一个很好的讨论，比较 ML 和 Racket，在那里他们做出不同的高层决策。然后在C 部分，我们现在访问面向对象的编程，你们中的许多人以前会看到，如果没有也没关系。首先，我们在 Ruby 中做一些基础知识，并学习了很多关于 Ruby 的知识。因为它是我们的第三语言，所以我们可以更快地学习。我们专注于它如何变得更加动态，然后 Racket 以及它如何比您在 Java 或 C# 等语言中可能习惯的更加面向对象。因为在 Ruby 中，实际上一切都是对象。即使是数也是对象。然后在课程的最后一部分，我们比较了面向对象和函数式，我们做了一些更高级的面向对象主题，比如 mixin 和双重调度，这使得课程的最后作业相当具有挑战性我们使用一些非平凡的面向对象习语来比较其中一些想法。所以我真的很鼓励 C 部分，当然这离我们还有很长的路要走，很多人认为，我已经知道 OOP，我真的在这里是为了功能性的东西，所以我不会做 C 部分。我鼓励您继续阅读 C 部分，以便进行比较、对比和补充。我认为还值得指出的是，有些人做了 C 部分，觉得我有点反 OOP，与函数式编程相比，我对面向对象编程有些不公平。我认为这主要不是真的。我对面向对象编程没有任何问题，但我在这门课程中有点故意推功能的角度，因为它是鲜为人知的，我认为这是一个很好的机会。并指出，虽然是的，但在某些情况下，OOP 心态是理想的。让我们调查一下 OOP 思维方式可能存在但并不理想的地方。所以是的，在上次家庭作业中有些事情我让你以客观的方式完成，尽管这往往有点麻烦。这不是对任何语言的批评，有些语言鼓励对象提供其他方式来做事。有些语言鼓励函数式风格，即使函数式风格并不完美。所以你不会从这门课程中看到从头到尾让我说一种方法总是比另一种方法好。我确实指出了函数式方法何时是一种好的方法。有时即使它是更好的，但你会带着很多思考和很多新观点离开这门课程，这就是我的全部目标。好了，介绍就到这里了。当您进入下一个视频时，让我们开始并深入研究第一部分。 

### 阅读材料1 Start here!5分钟
### 阅读材料2 About the Course10分钟
### 阅读材料3 Some More Perspective on Recommended Background7分钟
### 阅读材料4 Why are there 3 courses (Part A, Part B, Part C) 5分钟
### 阅读材料5 Grading Policy Details10分钟

---
## 2. Software Installation and Homework 0
This module contains two things: 
- The information for the [unusual] software you need to install for Programming Languages Part A. 
- An optional "fake" homework that you can **turn in for auto-grading and peer assessment** to get used to the mechanics of assignment turn-in that we will use throughout the course. 
You can do this module either before or after watching the first few "actual course content" videos in the next module, but you will want to **get the software installed soon**, so you can learn by **actively trying out variations on the code** in the videos. You will need to install the software to do the homework.

### Software Installation Introduction 1分钟
This video, like all the videos in this section on software installation, is optional, but we put it together because we thought some of you might find it useful. Basically, before you can get started in the programming languages course, there are a few pieces of software that we need you to install. And we have instructions for all of this. So if you go to the webpage and click on the page about software installation, you'll find a link to this file. Which gives installation instructions for various different operating systems, different version of the software and what not. And while its fairly simple to go through it and spend a few minutes doing it, you may have questions. And we thought it might be helpful for some of you to have a set of videos where I am literally going to install the software in front of you while the camera is running. So I don't think that that's very interesting. In fact I hope these are the least interesting videos in the entire course, but it might be useful. So the software we're going to install here in this first set, set of videos is going to take us through the first few weeks of the course. For later weeks, we need some additional software, but that actually is a bit easier to install. And as a last note these videos are all going to be on Windows. The instructions will be a little more, a little different, a little more complicated for Mac or Linux. But the instructions do cover those. As we have questions we expect people on the discussion board will be able to help you. 

1534 / 5000
翻译结果
与本节中有关软件安装的所有视频一样，此视频是可选的，但我们将其放在一起是因为我们认为你们中的一些人可能会觉得它很有用。基本上，在您开始学习编程语言课程之前，我们需要您安装一些软件。我们有所有这些的说明。因此，如果您转到该网页并单击有关软件安装的页面，您将找到指向该文件的链接。它给出了各种不同操作系统、不同版本的软件以及其他什么的安装说明。虽然通过它并花几分钟时间来完成它相当简单，但您可能会有疑问。我们认为对你们中的一些人来说，拥有一组视频可能会有所帮助，我将在相机运行时在你们面前安装软件。所以我认为这不是很有趣。事实上，我希望这些是整个课程中最不有趣的视频，但它可能有用。所以我们将在第一组中安装的软件，一组视频将带我们完成课程的前几周。在接下来的几周里，我们需要一些额外的软件，但这实际上更容易安装。最后一点，这些视频都将在 Windows 上播放。对于 Mac 或 Linux，说明会多一点、一点不同、更复杂一点。但说明确实涵盖了这些。由于我们有问题，我们希望讨论板上的人能够为您提供帮助。 
### Emacs installation 2分钟
In this in this video we're going to get Emacs installed so you'll see here I've got the PDF file opened with all of the instructions just going to scroll down to the emax section in there for Windows. Here is the key link I need there's.zip file if you have trouble just clicking on it instead just listen to your browser but I can click on it its connected to my browser you see here I want to save this ZIP. file and it's going to go ahead and download this its about 50 megabytes so that takes a minute or so, so I'm going to click pause just until that's done. Okay, we are now down, done downloading the file, depending how your browser is configured you need to find where that file was downloaded, I've got it here on the desktop which is a fine place to at least get it copied too if that's not what it was originally downloaded. And now in the next key step I'm going to right click on this file, and just choose extract all, that will bring up this window. If you have another program you like to use to extract zip files that's just fine. You're going to click extract and this is again going to take a minute, because now it's really going to unpack all of these files and get them pretty much installed. So I'm going to click pause again, so you don't have to sit here for two or three minutes while it does that. Okay. We are now done extracting the files and you'll see here a folder emacs-24.2-bin-i386. Let's open that, let's get this folder from inside of it, cut that out and paste it wherever you want. Just put it somewhere where you're going to leave it. So, I'm putting it on the desktop. That might not be where you want it. Just put it in one place that you're going to leave it there before this next step. So, no matter how you got here, as long as you have this folder where you want it, you're doing great. Open it up, go into the bin folder, and just this one time run this add PM program. Go ahead and choose run, it's going to ask if we want to install Emacs here. We're going to say yes, because we already picked the location we want and that's it. We should be done installing Emacs. And we can check that by just going down to the start menu, and you could just type in Emacs here on Windows 7 and choose that top option or in general go to All Programs > GNU Emacs, and then this Emacs program. just this first time it'll ask if you want to run this. It's perfectly safe so, I would unclick this box, choose Run and when you see Emacs looking like this, you're done installing it. 


在本视频中，我们将安装 Emacs，因此您将在此处看到我打开了 PDF 文件，其中包含所有说明，只需向下滚动到适用于 Windows 的 emax 部分。这是我需要的关键链接.zip 文件，如果您在单击它时遇到问题，而只是听一下您的浏览器，但我可以单击它，它已连接到我的浏览器，您在此处看到我想保存此 ZIP。文件，它会继续下载大约 50 兆字节的文件，所以这需要一分钟左右的时间，所以我将点击暂停，直到完成。好的，我们现在已经关闭，完成下载文件，根据您的浏览器的配置，您需要找到该文件的下载位置，我在桌面上找到了它，这是一个至少可以复制它的好地方，如果那不是它最初下载的内容。现在在下一个关键步骤中，我将右键单击此文件，然后选择全部提取，这将打开此窗口。如果你有另一个程序你喜欢用来解压缩 zip 文件，那很好。您将单击提取，这将再次花费一分钟，因为现在它真的要解压所有这些文件并安装它们。所以我将再次单击暂停，这样您就不必在此期间坐两三分钟。好的。我们现在完成了文件的提取，您将在此处看到一个文件夹 emacs-24.2-bin-i386。让我们打开它，从里面取出这个文件夹，把它剪下来，粘贴到任何你想要的地方。把它放在你要离开的地方。所以，我把它放在桌面上。那可能不是您想要的地方。只需将它放在一个地方，以便在下一步之前将其留在那里。因此，无论您如何到达这里，只要您将这个文件夹放在您想要的位置，您就做得很好。打开它，进入 bin 文件夹，就这一次运行这个添加 PM 程序。继续选择运行，它会询问我们是否要在这里安装 Emacs。我们会说是的，因为我们已经选择了我们想要的位置，仅此而已。我们应该完成安装 Emacs。我们可以通过进入开始菜单进行检查，您可以在 Windows 7 上输入 Emacs 并选择顶部选项，或者通常转到所有程序 > GNU Emacs，然后是这个 Emacs 程序。第一次它会询问您是否要运行它。这是完全安全的，所以我会取消点击这个框，选择运行，当你看到 Emacs 看起来像这样时，你就完成了安装。 
### SML installation 1分钟

And in this video we're going to install SML, particularly the Standard ML of New Jersey compiler. So, let's just click down here to the relevant portion of our instructions. Since we're here on Windows. In fact, on all the operating systems we can follow this URL. If you can't just click on that, just paste it into your browser instead. So, this is the web page we want to be at. And down here under Windows there's just this.msi file. You just click on that. And browser should ask me if I want to download it? Which I do. Let's just go ahead and save that file. Your browser will put it wherever if you get this download window. Or just go ahead and double click on that. That'll be fine. And just click run, and then it's just gonna bring up our little install wizard. All the default settings are fine for me. And we're installing. We are now completely done installing it. And now we just wanna check that we installed it correctly. So, we're gonna run SML, just right now, differently than the way we usually will, just to make sure this part worked fine. We just wanna open a command prompt. You can just type 'cmd' here, or if you prefer to find it, or you have a different version of your operating system: 'all programs > accessories > command prompt'. So, that's gonna bring up this guy here. And again just to make sure we installed SML correctly, just type 'sml' return. Notice we get this interesting prompt saying we have Standard ML New Jersey version 110.75. The exact version is not so important. We could type '1+1;'. Indeed we get back '2'. So, it is working properly. And if you want to exit back out of this on Windows anyway it's control Z. Hit return and that's it. We have SML installed.

在本视频中，我们将安装 SML，尤其是新泽西编译器的标准 ML。因此，让我们点击此处查看说明的相关部分。因为我们在 Windows 上。事实上，在所有操作系统上，我们都可以访问这个 URL。如果您不能点击它，只需将其粘贴到您的浏览器中即可。所以，这就是我们想要访问的网页。在 Windows 下，这里只有 this.msi 文件。你只需点击它。浏览器应该问我要不要下载？我做的。让我们继续并保存该文件。如果你得到这个下载窗口，你的浏览器会把它放在任何地方。或者只是继续并双击它。那会好的。只需单击运行，然后它就会调出我们的小安装向导。所有的默认设置对我来说都很好。我们正在安装。我们现在已经完全完成了安装。现在我们只想检查我们是否正确安装了它。所以，我们现在将运行 SML，与我们通常的方式不同，只是为了确保这部分工作正常。我们只想打开一个命令提示符。您可以在此处输入“cmd”，或者如果您更喜欢找到它，或者您的操作系统版本不同：“所有程序 > 附件 > 命令提示符”。所以，这会把这个人带到这里来。再次确保我们正确安装了 SML，只需键入“sml”返回。请注意，我们收到了这个有趣的提示，说我们有 Standard ML New Jersey 版本 110.75。确切的版本不是那么重要。我们可以输入'1+1;'。事实上，我们得到了'2'。所以，它工作正常。如果你想在 Windows 上退出这个，无论如何它是控制 Z。点击返回，就是这样。我们已经安装了 SML。 


http://www.smlnj.org/dist/working/

https://baike.baidu.com/item/ML%E8%AF%AD%E8%A8%80/7526775?fr=aladdin

smlnj-110.99.1.msi

![在这里插入图片描述](https://img-blog.csdnimg.cn/da0e5e8f76784208b68537e8b2a47f4b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_19,color_FFFFFF,t_70,g_se,x_16)

### SML Mode installation 3分钟
All right, now what we're going to do is we're going to get, SML mode for E max installed, so we've installed the E max and we've installed SML, but now we want to make E max convenient and useful for both writing and running SML programs. So we're going to do this entirely from within E max. So the first thing I'm going to do is open it, just going to type E max here and run it, you're going to see some slightly different colors here and you're not going to see the menu bar, that is just formating that I did. so that it's easier to see on the video. You probably still have a white background and that's just fine. so now I've opened EMAX. I'm now going to run a command meta-x list packages. So on a windows keyboard I'm going to type alt X. And then type list. Either space, although it'll print as a dash, or you could type the dash, packages, and hit return. What that's going to do, if you're in Emax version 24 something or higher, is bring up a list of packages that are easy to install. If you have an older version of Emax or you're not connected to the internet, you're going to have to follow some significantly more complicated instructions in an older version of SML Mode, and the written instructions do walk through that. But assuming you got this screen to go up, you can just scroll down either with your mouse or with your keyboard, down here to SML dash Mode and then you can just take your mouse and click on that. That's going to split the screen in two here. So I'm now seeing two buffers in EMAX, and you can just click on this install button. It's going to ask if I want to install it. I clearly do. And a minute later it says that everything's installed. Now what I want to do is go ahead and exit Emax with control X, control C. And then I'm just going to reopen it here. and bring that. Back over so you can see it and get that nice big font again. And now we just want to check that we've done it correctly. We are done installing. So you want to open an s m l file. Now, you can use control x control f and then the file name to do this, or if you have a file created, and I'm just going to create one over here on the desktop. I'm not going to give it a t x t extension. I'm going to call it something like test dot s m l. So I'll get a warning saying do you really want to change the file extension, and I do. Because when you have something with an s m l file extension. Emax should now know that it's an SML file. So I can literally just drag it on to Emax, and you'll notice down here on the bottom. The mode line says, I'm add-, editing an SML file. So, if you write SML code which if you haven't learned how to do yet, something you will learn how to do soon. Something like Val X= three+4, Val Y= X times five. You'll see coloring. We have multiple lines here. You see nice indentation by hitting the tab key and etcetera. When I want to save the file, I type control X, control S. Now what if I wanted to run SML. I'm not going to do that in this buffer but I can do it from within EMAX. Anytime I'm eding- editing a.SML file I can just type control C control S now. All I did was type control c control s. What's come up is sml command sml. Hit return. It's going to split my buffer in two and now here at the bottom I do have an sml read eval print loop where I could type one plus one semi-colon and get two. In fact, because I did that, from that test that SML file, I'm in the same folder directory as I was over there, so if I want to load the contents of that file, I can say, use, then in quotation marks, test that SML on semi colon, and indeed it just ran that program, and said X is seven and Y is 35, so we have everything correctly installed, we can now use SML, from within E macs, edit are files in there and we're all set with installation for the first half of the course. 

好的，现在我们要做的就是安装 E max 的 SML 模式，所以我们已经安装了 E max 并且我们已经安装了 SML，但是现在我们想让 E max 方便并且对于编写和运行 SML 程序都很有用。因此，我们将完全在 E max 内完成此操作。所以我要做的第一件事就是打开它，只需在此处键入 E max 并运行它，您将在此处看到一些略有不同的颜色，而您不会看到菜单栏，即只是格式化我所做的。以便在视频中更容易看到。您可能仍然拥有白色背景，这很好。所以现在我打开了 EMAX。我现在要运行一个命令 meta-x list packages。所以在Windows 键盘上，我要输入alt X。然后输入list。空格，尽管它会打印为破折号，或者您可以键入破折号、包，然后按回车键。如果您使用的是 Emax 24 版或更高版本，那么将显示一个易于安装的软件包列表。如果您使用的是较旧版本的 Emax 或者您没有连接到互联网，则您将不得不在旧版本的 SML 模式中遵循一些明显更复杂的说明，并且书面说明确实会完成这些说明。但是假设你让这个屏幕上升，你可以用鼠标或键盘向下滚动，向下滚动到 SML dash 模式，然后你可以用鼠标点击它。这将在这里将屏幕一分为二。所以我现在在 EMAX 中看到两个缓冲区，您只需单击此安装按钮即可。它会询问我是否要安装它。我很清楚。一分钟后，它说一切都已安装。现在我想要做的是继续退出 Emax，控制 X，控制 C。然后我要在这里重新打开它。并带来。返回以便您可以看到它并再次获得那个漂亮的大字体。现在我们只想检查我们是否正确完成了它。我们完成安装。所以你想打开一个 sml 文件。现在，您可以使用 control x control f 然后使用文件名来执行此操作，或者如果您创建了一个文件，我将在桌面上创建一个。我不会给它一个 t x t 扩展。我将称之为 test dot s ml 之类的东西。所以我会收到一个警告，说你真的想更改文件扩展名，我这样做了。因为当你有一个文件扩展名为 s ml 的东西时。 Emax 现在应该知道它是一个 SML 文件。所以我可以直接把它拖到 Emax 上，你会在底部注意到这里。模式行说，我正在添加-，编辑 SML 文件。因此，如果您编写 SML 代码，如果您还没有学会如何做，那么您很快就会学会如何做。类似于 Val X= 三 + 4，Val Y= X 乘以五。你会看到着色。我们这里有多条线路。通过按 Tab 键等，您会看到很好的缩进。当我想保存文件时，我键入 control X，control S。现在如果我想运行 SML 怎么办。我不会在这个缓冲区中这样做，但我可以在 EMAX 中这样做。任何时候我正在编辑一个 .SML 文件，我现在都可以输入 control C control S。我所做的只是键入 control c control s。出现的是 sml 命令 sml。按回车。它将把我的缓冲区分成两部分，现在在底部我有一个 sml read eval 打印循环，我可以在其中输入一加一分号并得到两个。事实上，因为我这样做了，从那个测试那个 SML 文件，我在同一个文件夹目录中，所以如果我想加载那个文件的内容，我可以说，使用，然后在引号中标记，在分号上测试该 SML，实际上它只是运行了那个程序，并说 X 是 7，Y 是 35，所以我们已经正确安装了所有东西，我们现在可以使用 SML，从 E macs 中，编辑那里的文件我们都准备好安装课程的前半部分。 

https://zhuanlan.zhihu.com/p/37518107
https://www.jianshu.com/p/f6115fd42929?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation

善用搜索引擎
How to add sml mode in emacs list-package?​
stackoverflow.com/questions/15295872/how-to-add-sml-mode-in-emacs-list-package

总之，到这里

GNU ELPA - sml-mode

下载这个

然后M-x package-install RET sml-mode RET 指定路径安装就可以了
发布于 01-23

http://elpa.gnu.org/packages/sml-mode.html

Alternatively, you can download the latest version from the GNU ELPA archive web site and install it with M-x package-install-file
### 阅读材料1 Part A Software Installation and Use: SML and Emacs 1小时
### 阅读材料2 Why Emacs? (Optional) 5分钟
### 阅读材料3 Homework 0 Detailed Peer-Assessment Instructions
