# R语言学习手记 (1)
> 经管的会计和财管都会学数据统计与分析R语言这门课，加上我也有点兴趣，就提前选了这门课，以下的笔记由老师上课的PPT、《R语言编程艺术》和《R语言数据科学》总结而来，希望为大家提供学习R语言的借鉴。

@[toc]
## 一、初识R语言
### 1.1 什么是R语言
> 现在最常用的统计软件——SAS；SPSS；EVIEWS；MATLAB和R。

>  R是由新西兰奥克兰大学的Ross Ihaka与Robert Gentleman一起开发的一个面向对象的编程语言，因两人的名都是以R开头，所以命名为“R”。 
    R是一套完整的数据处理、计算和制图软件系统，也是一套开源的数据分析解决方案。
    其功能包括： 数据存储和处理系统；数组运算工具（其向量、矩阵运算方面功能尤其强大)；完整连贯的统计分析工具； 优秀的统计制图功能； 简便而强大的编程语言。
### 1.2 为什么使用R语言
>  一些数据分析和数据挖掘软件使用的调查显示：R语言的使用在众多统计软件中名列榜首。
> **免费是R流行开来的最大的一个因素**。不过，R的最大优点是出色的可视化图形、丰富的统计方法以及高效的更新速度。可以说R功能强大、内容丰富，各种帮助文档很多。目前R已有近5000个扩展包。
   其主要特点在于：
（1）高效的数据处理和保存机制；    
（2）完整的向量、矩阵、数组操作运算符和数据分析工具；
（3）出色的图形统计功能；                 
（4）简单高效的建模工具；
（5）R具有丰富的扩展包(Packages)，提供很多高级功能；
（6）兼容几乎全平台，逐渐支持多国语言；
（8）更新速度快，以周计算。
### 1.3 安装R
 R的官方网站是http://www.r-project.org，可以在上面找到许多资源。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190308150509276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
R安装软件和安装包（package）的**下载链接在首页左侧的CRAN**。作为中国用户，一般都会选择一个国内的镜像。目前中国大陆的镜像有如下4个，包括北京大学、中科院和厦门大学等：
<img src="https://img-blog.csdnimg.cn/20190308151528947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="70%" alt="" /> 
在R官方主页点击download R，然后选择对应的镜像后，在右侧下载和安装包栏目里会出现三种操作系统的R版本（Linux、(Mac) OS X、Windows），选择点击相应的操作系统后，再选择点击base就会进入R的下载页面，在页面上会出现R的最新版本和安装说明等文件。
### 1.4 R扩展包
#### 1.4.1 R的组织层次
整个R系统主要由一系列程序包(Package)组成。**R包是函数、数据、预编译代码以一种定义完善的格式组成的集合**，数据 < 函数 < R文件 < R包。这些包默认储存在library里。
 
 R安装好后，除了默认自带的包之外，CRAN上还有数千附加包，由R核心开发团队之外的用户自行提交，如此多的程序包基本上保证R可以实现目前几乎所有的统计分析。扩展包需要下载安装并载入到会话中才能使用。

#### 1.4.2 R包的安装、载入和更新
1. R的下载安装有几种方法，这里主要介绍其中两种方法：

   (1). 在线安装。
      比如需要安装”class”这个扩展包，输入命令`install.packages(“class”)`执行即可。
      也可以同时安装多个包，比如需同时安装“class”,“cluster”两个包，输入命令`install.packages(c(“class”,”cluster”) )`。
   (2). 利用Rstudio安装。
    下载Rstudio https://www.rstudio.com/
    在Rstudio右下角栏目里点击“packages”然后再点击 “install packages”, 会出现如图的对话框，在packages对话框里输入需要安装的包名，比如输入 class，就可以安装包。

2. R包的载入有两种方法：
   (1). 在R console输入命令`library()`载入。如需载入class包，则输入`library(class)`即可。
   (2). 利用RStudio载入。
3. R包的更新
一个包仅需安装一次，但是R的扩展包会经常被更新，要想使用更新后的扩展包，需要对已安装的包进行更新。本书主要介绍两种常用方法：
     （1）在R  Console输入命令`update.packages()`，会出现需要更新的包和相关信息，并可以选择是否需要更新。如选择”y”，则会在线更新。
     （2）利用Rstudio更新R包。

4. R包的查看
    载入R包后，可以使用该扩展包的函数和数据。比如我们载入“class”包后，想要查看该包里的函数。一种方法可以在R Console里输入命令`help(package=”class”)`，则会返回一个包含了“class”包里所有函数和数据集名称的帮助文档。另一种方法，在RStudio右侧点击”class”,则会返回帮助文档，如需进一步了解该函数的使用方法，继续点击相应的函数，则会返回该函数的详细帮助文档。
    <img src="https://img-blog.csdnimg.cn/20190308152037595.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,siz0e_16,color_FFFFFF,t_70" width="60%" alt="" />
### 1.5 R编辑器
#### 1.5.1 Rstdio界面介绍
下载安装后，双点R的快捷图标，打开R的操作平台（R  Console）。虽然可以直接在此操作平台上输入命令，但是R本身默认的IDE很粗糙。**一般情况下最好不要直接在操作平台上输入命令，而是使用R的编辑软件**。

R拥有多种优秀的IDE。这里主要使用跨平台开源IDE——RStudio。RStudio将常用的窗口都整合在一起，更方便控制。要使用RStudio，除了安装R开发环境后，还需要到[官网](http://www.rstudio.org/)上下载适合的RStudio版本并安装。

打开RStudio，如图所示。左上角是脚本编辑窗口左下角是命令窗口，在右上角是工作空间、历史记录窗口，右下角是作图、帮助、包管理窗口。看着有点杂，但是用惯了就很轻松。
<img src="https://img-blog.csdnimg.cn/20190308145104193.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="70%" alt="" />
#### 1.5.2 R代码的运行
编写R语言代码，运行途径有两种：
      （1）在左下角的命令窗口输入并回车运行；
      （2）使用左上角的脚本编辑窗口编写好代码之后，根据你的需要选择运行代码。若需要使用脚本编辑代码，你需要在RStudio中执行File—>New File—>R Script命令（快捷键为`Ctrl+Shift+N`）来新建一个脚本编辑窗口。写好代码之后，可以通过点击Run按钮来运行程。（**注意：如果直接点击Run按钮，则是运行当前行代码。如果先用鼠标选好要运行的代码，然后再点Run，就运行所选代码**）
#### 1.5.3 Rstdio高级功能
在使用脚本编辑窗口的时候，RStudio还提供一些**高级功能**。
- 在脚本标签下方，右侧有运行当前行或所选行，重新运行上一次代码等。点击左边的发光棒 ，会显示如图的多种功能，包括：代码补全，注释等，它的左边是查找和替换功能。`Source on Save最好把它勾上，可以让你的代码自动保存`。
<img src="https://img-blog.csdnimg.cn/20190308150208163.jpg" width="65%" alt="" />
<img src="https://img-blog.csdnimg.cn/20190308150219980.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="65%" alt="" />
- 左下角是一个类似Rgui的编辑器。这里可以写代码，也能显示程序运行过程和结果。（一般不建议在这里写，一是没法保存，二是不小心一部分写错了，很多都要重来。）
- 右上角的Data、Value和Function是上一次程序运行后，保存在.RData文件里面的值， 通过鼠标点击使它们显示。Environment下的标签可以让你切换工作空间.
Save可以保存当前工作区 。 
Import Dataset导入数据作为数据集。 
Clear将当前工作区的所有变量和函数清除干净。
History标签运行的历史记录界面，可以保存下来，也可以选择一部分，然后按To Console或者To Source，前者是将选择的代码送到左下角的操作平台运行，后者是将代码送到左上角的光标位置。
<img src="https://img-blog.csdnimg.cn/20190308150232257.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="75%" alt="" />
- 右下角的功能较多，Files显示工作区内的文件，New Folder就是新建文件夹，Delete删除，Rename重命名， More则提供了其他功能。
`Plot标签`下提供图形显示，并可以随着这个工作区的变大而缩放，**有时候画不出图来，可能是图片显示区域不够大**。` Zoom`放大图片，`Export`将图片导出，里面的`Image Format`处可以选择导出图片的格式，一般选择png格式。`Directory`为选择保存的文件夹，`File Name`为图片的名字，`Width和Height`可以输入图片的宽高。
`Package`标签可以显示已经读入内存的包，也显示你安装了的所有的包；可以安装新的包，也可以升级各个包。

当然，除了RStudio之外，还有很多其他优秀的IDE可供选择，如RStudio Server、Vim-R、StatET、Rattle、R AnalyticFlow、Revolution R Enterprise、Red-R等。这些IDE各有优劣。其他还有类似Notepad++的文本编辑器+R插件构成的开发环境，安装文件小巧，操作简单方便，基本语法高亮和代码补全的功能也应有尽有。

### 1.6. 工作空间
 与其他计算机程序语言一样，R也有一个记录当前工作环境的工作空间(Workspace)，里面保存了所有用户定义的向量、矩阵、函数、数据框、列表等一系列对象。在一个R的会话结束时，可以选择(自动)保存当前的工作空间并在下次启动R时自动载入。

当前工作路径(Working Directory)是R用来读取和保存文件的默认路径。使用函数`getwd()来查看当前路径`。还可通过`setwd()函数来指定当前的工作路径`。如果需要读写这个目录之外的文件则需要使用完整的路径，并且要使用引号闭合路径名。 
       <img src="https://img-blog.csdnimg.cn/20190308150255981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="75%" alt="" />
在RStudio软件中，可以直接在右上角部分直接看到工作空间的各种对象以及历史记录。


## 二、数据类型、数据对象与基本运算
### 2.1 数据类型
 R语言的数据类型(`是数据的类型，而数据对象是数据结构，是容纳各种数据的容器`)主要有: 数值型、逻辑型、字符型、复数型，原型 。此外，也可以是缺省值。
#### 2.1.1 数值型（numeric）
这种数据的形式是实数。可以写成整数integers，小数decimal fractions，或科学记数scientific notation的方式。**数值型实际上是两种独立模式的混合说法**，`整数型integers`和`双精度型double－precision`。浮点数类型数据默认是双精度型数据。

#### 2.2.2 字符型（character）
 这种数据的形式是夹在双引号“”或单引号‘ ’之间的字符串，如“MR”。
#### 2.2.3 逻辑型（logical）
这种数据只能取`T(TRUE)`或`F(FALSE)`值。
#### 2.2.4 复数型（complex）
这种数据是形如a+bi形式的复数。
#### 2.2.5 原始型（raw）
这种类型以二进制形式保存数据。
#### 2.2.6 缺省值（missing value）
有些统计资料是不完整的。当一个元素或值在统计的时候是“不可得到”（not available）或“缺失值”（missing value）的时候，相关位置可能会被保留并且赋予一个特定的`NA(not available)`值。**任何NA的运算结果都是NA**。`is.na()`用来检测数据是否缺失，如果数据缺失，则返回TRUE，否则，返回FALSE。
```python
> z <- c(1:5,NA)  # 生成向量z
> z  # 返回z向量的结果
[1]  1  2  3  4  5 NA
> is.na(z) # 识别z向量的值是否有缺失值
[1] FALSE FALSE FALSE FALSE FALSE  TRUE
```
上面，我们用c()函数首先生成了向量z。is.na()返回的结果是前面5个元素都FALSE，最后1个是TRUE，这说明前面5个都不是缺失值，最后1个是缺失值。

常见的辨别和转换对象类型的函数如下表： 

### 2.2 数据对象
R语言里的**数据对象主要有六种结构**，这里全部介绍。
#### 2.2.1 向量
1. 向量赋值   
向量（vector）是由**相同基本类型元素**组成的序列，相当于C语言的一维数组。
例：```> x <-c(1,3,5,7,9)  # 用c( )构建向量```
这是一个用函数c( )完成的赋值语句。`函数c( )可以有任意多个参数，而它输出的值是一个把这些参数首尾相连形成的一个向量`。
“#”符号后面跟的是注释，在写程序的时候清楚表明程序工作的注释能大大提高程序的可读性。
 “<-”是赋值符号，表示把<-后面的内容赋值给<-前面的内容，R的赋值符号除了“<-”外,还有“->”、“=”， ->的用法和<-的用法正好相反。R也允许“=”赋值，但不是标准语法，有些情况下用“=”有可能会出现问题，因此**一般情况不建议使用“=”**。
	```python
	例如：
	> c(1,3,5,7,9) -> y  # 将c()生成的数值向量赋值给y
	> y
	[1] 1 3 5 7 9
	> z <- c("Male","Female","Female","Male","Male")
	# 将c()生成的字符向量赋值给z
	> z
	[1] "Male"   "Female" "Female" "Male"   "Male"
	> u = c(TRUE,FALSE,TRUE,FALSE,FALSE) # 将c()生成的逻辑向量赋值给u
	> u
	[1]  TRUE FALSE  TRUE FALSE FALSE
	# 此处，y是数值向量，z是字符型向量，u是逻辑型向量。
	```
    单个向量中的数据要求是相同类型，同一向量中无法混杂不同类型的数据，只是连接函数c()会帮我们转换罢了。
    对于字符向量，一个很重要的`函数paste()可以把自变量对应元素连成一个字符串向量，还可以将这些字符串整体连接成一个长字符串`。**在长度不相同时，较短的向量被重复使用**。
	```python
	> v<-paste("x",1:5,sep="")
	> v
	[1] "x1" "x2" "x3" "x4" "x5“
	# 此外，也可以用assign（）函数对向量进行赋值
	> assign("w",c(1,3,5,7,9))
	> w
	[1] 1 3 5 7 9
	```
    函数paste的一般使用格式为：
    `paste(..., sep = " ", collapse = NULL)`
    其中...表示一个或多个R可以被转化为字符型的对象；参数sep表示分隔符，默认为空格；参数collapse可选，`如果不指定值，那么函数paste的返回值是自变量对应元素之间通过sep指定的分隔符连接后得到的一个字符型向量；如果为其指定了特定的值，那么自变量连接后的字符型向量会再被连接成一个字符串，之间通过collapse的值分隔`。
    paste函数把它的自变量连成一个字符串，中间用空格分开：
	```python
	> paste("Hello","world")
	[1] "Hello world"
	```
   如果希望将一个向量中所有字符连接在一起且中间用逗号分隔，使用`paste(x,collapse)`即可，结果只是返回一个元素。或者可以使用函数`toString`来实现（但是toString函数本来就是利用paste来实现的，所以最好还是使用paste）。
	```python
	> paste(letters[1:6], collapse=",")
	[1] "a,b,c,d,e,f"
	# 同时使用了参数sep与collapse
	> paste("A", 1:6, sep = "",collapse=",")
	[1] "A1,A2,A3,A4,A5,A6"
	```
   连接的自变量可以是向量，这时各对应元素连接起来，长度不相同时较短的向量被重复使用：
    ```python
	> paste("A", 1:6, sep = "")
	[1] "A1" "A2" "A3" "A4" "A5" "A6"
     ```
     
   如果只是希望向量x中每一个元素和特定的字符（如下划线_）连接，使用paste(x,seq=)即可，如
   ```python
	> paste(letters[1:4], sep='_')
	[1] "a _" "b _" "c _" "d _"
   ```
   我们分别对sep，collapse三个元素进行试验
	```python
	> paste(1:10,sep=",")
	[1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10"
	> paste(1:10,1,sep=",")
	[1] "1,1"  "2,1"  "3,1"  "4,1"  "5,1"  "6,1"  "7,1"  "8,1"  "9,1"  "10,1"
	> paste(1:10,collapse=",")
	[1] "1,2,3,4,5,6,7,8,9,10"
	> paste(1:10,1,collapse=",")
	[1] "1 1,2 1,3 1,4 1,5 1,6 1,7 1,8 1,9 1,10 1“
	> paste(1:10,1)
	[1] "1 1"  "2 1"  "3 1"  "4 1"  "5 1"  "6 1"  "7 1"  "8 1"  "9 1"  "10 1“
     ```
      在未设定参数的情况下，`paste(..., sep = " ", collapse = NULL)`，即sep默认是空格，collapse默认为NULL。+

2. 向量运算和向量运算符
对于向量的乘法，除法，乘方运算，其方法是对应向量的每个分量做乘法、除法和乘方运算，这里就涉及到**R语言设计的核心点——向量化(Vectorize)**，即将函数分别应用到向量的每个元素上面，所以在这里介绍的**所有向量运算符号，实质上都是R的函数**。
例如：
	```python
	>x <-c(1,3,5,7,9)
	> c(1,3,5,7,9) -> y
	> x * y  # 对应元素相乘
	[1]  1  9 25 49 81
	> x / y  # 向量化除法
	[1] 1 1 1 1 1
	> x^2
	[1]  1  9 25 49 81
	> y^x    # 向量化乘方
	[1]   1   27   3125   823543 387420489
	```

   此外，`%/%表示向量化的整数除法`(5%/%3为1)，`%%表示求余数`(5%%3为2)。
   向量运算会对该向量的每一个元素都进行同样的运算。出现在同一个表达式的向量最好同一长度。**如果长度不一，表达式中短的向量将会被循环使用**，表达式的值将是一个和最长的向量等长的向量。
       例如：
      ```python2
	> c(1,3,5) + c(2,4,6,8,10)
	[1]  3  7 11  9 13
	```
	第一个向量的长度小于第二个向量，循环补齐第一向量的长度，即为c(1,3,5,1,3)。
	|向量化的运算符 | 含义|
	|:---|:----|
	| +  | 向量对应元素相加 |
	|  - |  向量对应元素相减  |
	| * | 向量对应元素相乘  |
	| /  |  向量对应元素相除 |
	| %/% | 向量对应元素相整除 |
	| %% | 向量对应元素相取余  |
	|`& | 向量对应元素逻辑与 |
	| `|` | 向量对应元素逻辑或|
	| ! | 向量对应元素逻辑非|
	| **非向量化的运算符**| **含义**|
	| `&&`| 标量与|
	| `||` | 标量或|

3. 生成有规则序列
    (1). R可以产生正则序列，最简单的是用`:`符号，就可以产生有规律的正则序列。例如：
	```python3
	> (t <- 1:10)
	[1]  1  2  3  4  5  6  7  8  9 10
	> (r <- 5:1)
	[1] 5 4 3 2 1
	> 2*1:5
	[1]  2  4  6  8 10
	```
     其中，5:1表示逆向序列, 并且**在表达式运算中，“：”的运算级别最高**，即上面的2*1:5，R是先生成1-5的向量，然后再乘上2。
     这里**在表达式外面套()的意思把结果直接打印出来**，比如>t <- 1:10。而不套括号，则R将运算结果保存在t对象里，但是不会把t的结果打印出来。
     
	 (2). 可以用函数`seq()`产生有规律的各种序列，其句法是：`seq(from, to, by)`，from表示序列的起始值，to表示序列的终止值，by表示步长。其中，by参数（参数by）省略时，默认步长为1。并且该函数也可以产生降序数列。例如：
	```python
	> seq(1,10,2) #生成从1开始，10结束，步长为2的序列
	[1] 1 3 5 7 9
	> seq(1,10) #默认步长为1
	 [1]  1  2  3  4  5  6  7  8  9 10
	> seq(10,1,-1) #步长为-1
	 [1] 10  9  8  7  6  5  4  3  2  1
	 ```
	有时候我们需要关注的是数列的长度，这时我们可以操作如下：
	```python3
	> seq(1,by=2,length=10)
	[1]  1  3  5  7  9 11 13 15 17 19
	```
    (3). rep()函数可以用各种复杂的方式重复一个对象。其命令是：`rep(x, times, each=1...)`，其中x表示要重复的对象，times表示整个向量重复的次数，each表示每个元素重复的次数。
   ```python3
	> rep(c(1,3), 4)  #将c(1,3)向量重复4次
	[1] 1 3 1 3 1 3 1 3
	> rep(c(1,3), each=4) 
	[1] 1 1 1 1 3 3 3 3
	> rep(1:3, rep(2,3))
	[1] 1 1 2 2 3 3
	```
     第一个是向量c(1,3)重复4次的情况，也可以用第二个对每个元素进行重复，第三个是函数rep( )的嵌套使用，里层的rep(2,3)实际就等价于向量c(2,2,2)。
4. 向量的索引
 **R中提供了灵活的向量下标运算**。取出向量的某一个元素可以用x[i]。也可以通过赋值语句来改变一个或多个元素的值。例如：
	```python
	 > x <- c(1,3,5)
	> x[2]  # 返回x向量的第2元素
	[1] 3
	>(c(1,2,3)+4)[2] 
	# 先进行向量运算c(1,2,3)+4，再返回该向量的第2个元素
	[1] 6
	 > x[2] <- 10 # 将10赋值给x向量的第2个元素，,即替换掉原来的值
	> x
	[1]  1 10  5
	> x[c(1,3)] <- c(9,11) # 将9和11赋值给x向量的第1和第3个元素
	> x
	[1]  9 10 11
	```
	
    把i换成逻辑语句，对向量进行逻辑运算。例如：
    ```python
	> x <- c(1,3,5)
	> x < 4  #逻辑结果，即x向量的元素是否小于4
	[1]  TRUE  TRUE FALSE
	> x[x<4] #返回x向量里小于4的元素
	[1] 1 3
	> z <- c(-1,1:3,NA)
	> z
	[1] -1  1  2  3 NA
	> z[is.na(z)] <- 0 #将0赋值给z向量里的NA值
	> z
	[1] -1  1  2  3  0
	> z <- c(-1,1:3,NA)
	y <- z[!is.na(z)] 
	#将z里的非缺失值赋值给y
	> y
	[1] -1  1  2  3
	```
	
   这种方法可以用在对分段函数的定义上。例如：
	```python
	> x<-c(-3,-2,-1,0,5,7)
	> y <- numeric(length(x)) 
	#生成于x向量长度相同的数值型向量
	> y
	[1] 0 0 0 0 0 0
	> y[x<0] <- 1-x[x<0] 
	#求出x中小于0元素对应位置，y对应位置的值用1-x[x<0]替代
	 > y
	[1] 4 3 2 0 0 0
	>y[x>=0] <- 1+x[x>=0]  
	#求出x中大等于0元素对应位置，y对应位置的元素用1-x[x<0]赋值
	> y
	[1] 4 3 2 1 6 8
	```
	
	 如果x[i]，i取值是小于0的负整数，则表示删除相应位置的元素。
 5. 向量的常见函数
        向量里元素的个数称为向量的长度(length)，**长度为1的向量就是常数向量**。函数`length()可以返回向量的长度`，`mode()可以返回向量的数据类型`，`min()返回向量的最小值`，`max()返回向量的最大值`，`range()返回向量的范围， 即返回(最小值，最大值)`，`which.min()、which.max()返回在第几个分量求到最小、最大值`。例如：
     ```python3
	>x <-c(1,3,5,7,9)
	> length(x)
	[1] 5
	> min(x)
	[1] 1
	> range(x)
	[1] 1 9
      ```
	R提供了很多的数学函数可以对向量进行运算，这里不一 一列举，下面列出常用函数表。
	|数学函数  | 用途 |
	|:---|:----|
	| length()
	| sum()|
	|max() |
	|
	
    <img src="https://img-blog.csdnimg.cn/20190322150523906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="70%" alt="/">
#### 2.2.2 矩阵
1. **矩阵(matrix)是二维的数组**，是将数据用行和列排列的长方形表格，**其单元必须是相同的数据类型**。**通常用列来表示不同的变量，用行表示各个对象**。
R语言生成矩阵的函数句法是：
`matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames  = NULL)`
其中，data项为必要的矩阵元素，nrow为行数，ncol为列数， `注意 nrow 与 ncol 的乘积应为矩阵元素个数`，dimnames 给定行和列的名称，byrow项控制排列元素时是否按行进行，默认byrow=FALSE，即按列排列，**但无论怎么排列，矩阵在内存中的存储始终是按列的**。
  
	```python
	> matrix(1:12, nrow=4, ncol=3) # 默认按列填充
	     [,1] [,2] [,3]
	[1,]    1    5    9
	[2,]    2    6   10
	[3,]    3    7   11
	[4,]    4    8   12
	> matrix(1:12, nrow=4, ncol=3, byrow=T) # 按行填充
	     [,1] [,2] [,3]
	[1,]    1    2    3
	[2,]    4    5    6
	[3,]    7    8    9
	[4,]   10   11   12
	```
2. 矩阵的运算
`矩阵的转置用函数t()`来计算。**若将函数 t()作用于一个向量x，则当做x为列向量，返回结果为一个行向量**。若想得到一个列向量,可用 t(t(x))。
	```python
	> (A <- matrix(1:12,nrow=3,ncol=4))
	       [,1] [,2] [,3] [,4]
	[1,]    1    4    7   10
	[2,]    2    5    8   11
	[3,]    3    6    9   12
	> t(A)
	       [,1] [,2] [,3]
	[1,]    1    2    3
	[2,]    4    5    6
	[3,]    7    8    9
	[4,]   10   11   12
	```
    矩阵的加减法:
    ```python
	    >A <- B <- matrix(1:12,nrow=3) 
	#将生成的矩阵赋给B，同时又赋给A
	> A+B
	       [,1] [,2] [,3] [,4]
	[1,]    2    8   14   20
	[2,]    4   10   16   22
	[3,]    6   12   18   24
   ```

    矩阵的数乘
    ```python
	> 3*A
	       [,1] [,2] [,3] [,4]
	[1,]    3   12   21   30
	[2,]    6   15   24   33
	[3,]    9   18   27   36
	```

    矩阵的乘法，除了**矩阵需要满足可以相乘的要求**，在R中需要用运算符`%*%`来进行计算。`*`运算只是对应的元素相乘。如果要计算`t(A)%*%B`还可以用函数`crossprod(A,B)`，这种计算的效率更高。
	```python
	> B <- t(A)
	> A%*%B
	     [,1] [,2] [,3]
	[1,]  166  188  210
	[2,]  188  214  240
	[3,]  210  240  270
	```
    R中还可以对矩阵的对角元素进行计算，如取一个方阵的对角元素。而且，`对一个向量应用diag()函数可以产生以该向量的元素为对角元的对角矩阵`， 如果输入只有一个正整数的话，diag()函数将会生成一个对应维数的单位阵。
    ```python3
    > (A <- matrix(1:16,nrow=4))
	     [,1] [,2] [,3] [,4]
	[1,]    1    5    9   13
	[2,]    2    6   10   14
	[3,]    3    7   11   15
	[4,]    4    8   12   16
	> diag(A)
	[1]  1  6 11 16
	> diag(diag(A))
	     [,1] [,2] [,3] [,4]
	[1,]    1    0    0    0
	[2,]    0    6    0    0
	[3,]    0    0   11    0
	[4,]    0    0    0   16
	> diag(3)
	     [,1] [,2] [,3]
	[1,]    1    0    0
	[2,]    0    1    0
	[3,]    0    0    1
   ```
	`使用solve()函数求逆`，**如果是solve(a,b)的话是解线性方程组ax=b，b默认为单位矩阵**。
	```python3
	> (A <- matrix(rnorm(16),4,4))                  #rnorm()是生成16个标准正态分布随机数
	            [,1]       [,2]       [,3]       [,4]
	[1,]  0.44576927 -0.9841294 -0.1291554 0.18165406
	[2,]  1.04034856  1.3658480 -0.6905046 0.06254394
	[3,] -0.02689138 -0.5389127 -0.1356344 1.71923910
	[4,] -0.05693438  1.4905866 -0.2479709 0.03399939
	> solve(A)
	           [,1]      [,2]      [,3]       [,4]
	[1,]  -4.538443 2.6321129 0.4872459  -5.232100
	[2,]  -1.936148 0.7670728 0.2011416  -1.237585
	[3,] -10.806250 4.0894901 1.1996337 -10.448150
	[4,]  -1.530421 0.6042453 0.7469654  -1.294048
   ```
    在R中可以`通过函数eigen()求特征值和特征向量`。
    ```python3
	> (A <- diag(4)+1)
	     [,1] [,2] [,3] [,4]
	[1,]    2    1    1    1
	[2,]    1    2    1    1
	[3,]    1    1    2    1
	[4,]    1    1    1    2
	> (A.eigen <- eigen(A,symmetric=T))
	$values #此处返回的结果是列表格式，具体详见2.2.5
	[1] 5 1 1 1
	$vectors
	     [,1]       [,2]       [,3]       [,4]
	[1,] -0.5  0.8660254  0.0000000  0.0000000
	[2,] -0.5 -0.2886751 -0.5773503 -0.5773503
	[3,] -0.5 -0.2886751 -0.2113249  0.7886751
	[4,] -0.5 -0.2886751  0.7886751 -0.2113249
   ```
    对于正定矩阵A，可以对其进行Choleskey分解，即A=PTP，其中P为上三角矩阵，在R中`可以用函数chol()进行Choleskey分解`。
    ```python3
	> chol(A)
	         [,1]      [,2]      [,3]      [,4]
	[1,] 1.414214 0.7071068 0.7071068 0.7071068
	[2,] 0.000000 1.2247449 0.4082483 0.4082483
	[3,] 0.000000 0.0000000 1.1547005 0.2886751
	[4,] 0.000000 0.0000000 0.0000000 1.1180340
   ```
    若矩阵为对称正定阵，则可以利用Choleskey分解来**求行列式的值以及矩阵的逆**，并且这种用法更有效。
	 ```python3
	> prod(diag(chol(A))^2) # 求出A矩阵的对角元素，然后求平方，再求连乘积
	[1] 5
	> det(A)  # 求A矩阵行列式
	[1] 5
	> chol2inv(chol(A)) # 求Choleskey分解后的逆
	     [,1] [,2] [,3] [,4]
	[1,]  0.8 -0.2 -0.2 -0.2
	[2,] -0.2  0.8 -0.2 -0.2
	[3,] -0.2 -0.2  0.8 -0.2
	[4,] -0.2 -0.2 -0.2  0.8
	```
	奇异值分解。若A为m行n列矩阵，秩为r，则矩阵可以进行奇异值分解得到A=UDVT。在R中可以通过svd()函数进行计算。 
	```python3
	> (A <- matrix(1:18,3,6))
	     [,1] [,2] [,3] [,4] [,5] [,6]
	[1,]    1    4    7   10   13   16
	[2,]    2    5    8   11   14   17
	[3,]    3    6    9   12   15   18
	>(A.svd <- svd(A)) 
	#求矩阵A的svd分解，并将结果赋值给A.svd
	$d
	[1] 4.589453e+01 1.640705e+00 1.366522e-15
	$u
	           [,1]        [,2]       [,3]
	[1,] -0.5290354  0.74394551  0.4082483
	[2,] -0.5760715  0.03840487 -0.8164966
	[3,] -0.6231077 -0.66713577  0.4082483
	$v
	            [,1]        [,2]       [,3]
	[1,] -0.07736219 -0.71960032 -0.4076688
	[2,] -0.19033085 -0.50893247  0.5745647
	[3,] -0.30329950 -0.29826463 -0.0280114
	[4,] -0.41626816 -0.08759679  0.2226621
	[5,] -0.52923682  0.12307105 -0.6212052
	[6,] -0.64220548  0.33373889  0.2596585
	```
	QR分解—— 实数矩阵A的QR分解是把A分为A=QR，这里的Q是正交矩阵，而R是上三角矩阵。QR分解在R中可以用函数qr()计算.其中，rank项返回矩阵的秩，qr项包含了矩阵Q和R的信息，要得到对应矩阵，可以用函数qr.R()，qr.Q()计算。
	```python3
	> B <- matrix(1:16,4,4)
	> qr(B)
	$qr
	           [,1]        [,2]          [,3]          [,4]
	[1,] -5.4772256 -12.7801930 -2.008316e+01 -2.738613e+01
	[2,]  0.3651484  -3.2659863 -6.531973e+00 -9.797959e+00
	[3,]  0.5477226  -0.3781696  1.601186e-15  2.217027e-15
	[4,]  0.7302967  -0.9124744 -5.547002e-01 -1.478018e-15
	$rank #矩阵的秩
	[1] 2
	$qraux #Q中的额外信息
	[1] 1.182574e+00 1.156135e+00 1.832050e+00 1.478018e-15
	$```pivot #分解过程中的旋转信息
	[1] 1 2 3 4
	attr(,"class") #返回属性
	[1] "qr"
	
	> qr.R(qr(B)) #提取R矩阵
	          [,1]       [,2]          [,3]          [,4]
	[1,] -5.477226 -12.780193 -2.008316e+01 -2.738613e+01
	[2,]  0.000000  -3.265986 -6.531973e+00 -9.797959e+00
	[3,]  0.000000   0.000000  1.601186e-15  2.217027e-15
	[4,]  0.000000   0.000000  0.000000e+00 -1.478018e-15
	> qr.Q(qr(B)) #提取Q矩阵
	           [,1]          [,2]       [,3]        [,4]
	[1,] -0.1825742 -8.164966e-01 -0.4000874 -0.37407225
	[2,] -0.3651484 -4.082483e-01  0.2546329  0.79697056
	[3,] -0.5477226 -1.665335e-16  0.6909965 -0.47172438
	[4,] -0.7302967  4.082483e-01 -0.5455419  0.04882607
   ```
	可用kronecker()来计算矩阵的Kronecker积。
	```python3
	> (A <- matrix(1:4,2,2))
	      [,1] [,2]
	[1,]    1    3
	[2,]    2    4
	> (B <- matrix(rep(1,4),2,2))
	       [,1] [,2]
	[1,]    1    1
	[2,]    1    1
	> kronecker(A,B)
	       [,1] [,2] [,3] [,4]
	[1,]    1    1    3    3
	[2,]    1    1    3    3
	[3,]    2    2    4    4
	[4,]    2    2    4    4
   ```
	在R中可`使用dim()得到矩阵的维数，nrow()求行数，ncol()求列数； rowSums()求各行和， rowMeans()求行均值， colSums()求各列和， colMeans()求列均值`。

	计算XTX这样的矩阵逆，例如OLS中的系数矩阵。在R的strucchange包里面有函数solveCrossprod()函数可以很方便的计算。其具体形式如下：
     `solveCrossprod(X, method = c("qr", "chol", "solve"))`
      对于method中的求逆方法，qr效率最高，chol精度最高，而solve与solve(crossprod(x,x))的效果相同。例如：
	```py
	> A <- matrix(rnorm(16),4)
	> solveCrossprod(A,method="qr") #利用qr分解方法求逆矩阵
	           [,1]       [,2]      [,3]       [,4]
	[1,]  1.5752935  0.3617794 -1.269400  1.5530569
	[2,]  0.3617794  0.2996626 -0.139547  0.4616545
	[3,] -1.2694003 -0.1395470  1.741550 -1.1275450
	[4,]  1.5530569  0.4616545 -1.127545  2.1345205
	```
	 计算XTX这样的矩阵逆 ，在R的strucchange包里面有函数solveCrossprod()函数可以很方便的计算。
	续例：
	```py
	> solveCrossprod(A,method="chol") # 利用Choleskey分解方法求逆矩阵
	           [,1]       [,2]      [,3]       [,4]
	[1,]  1.5752935  0.3617794 -1.269400  1.5530569
	[2,]  0.3617794  0.2996626 -0.139547  0.4616545
	[3,] -1.2694003 -0.1395470  1.741550 -1.1275450
	[4,]  1.5530569  0.4616545 -1.127545  2.1345205
	
	> solveCrossprod(A,method="solve")
	           [,1]       [,2]      [,3]       [,4]
	[1,]  1.5752935  0.3617794 -1.269400  1.5530569
	[2,]  0.3617794  0.2996626 -0.139547  0.4616545
	[3,] -1.2694003 -0.1395470  1.741550 -1.1275450
	[4,]  1.5530569  0.4616545 -1.127545  2.1345205
	> solve(crossprod(A,A))
	           [,1]       [,2]      [,3]       [,4]
	[1,]  1.5752935  0.3617794 -1.269400  1.5530569
	[2,]  0.3617794  0.2996626 -0.139547  0.4616545
	[3,] -1.2694003 -0.1395470  1.741550 -1.1275450
	[4,]  1.5530569  0.4616545 -1.127545  2.1345205
	```
	可使用lower.tri()，upper.tri()提取到矩阵的上三角和下三角矩阵。结果返回为逻辑矩阵，其中diag为T时包含对角元，默认不含对角元。
	     lower.tri(x, diag = FALSE) 
	     upper.tri(x, diag = FALSE)
	例如：
	```py
	> A <- matrix(1:16,4)
	> lower.tri(A)
	      [,1]  [,2]  [,3]  [,4]
	[1,] FALSE FALSE FALSE FALSE
	[2,]  TRUE FALSE FALSE FALSE
	[3,]  TRUE  TRUE FALSE FALSE
	[4,]  TRUE  TRUE  TRUE FALSE
	> lower.tri(A,diag=T)
	     [,1]  [,2]  [,3]  [,4]
	[1,] TRUE FALSE FALSE FALSE
	[2,] TRUE  TRUE FALSE FALSE
	[3,] TRUE  TRUE  TRUE FALSE
	[4,] TRUE  TRUE  TRUE  TRUE
	> A[lower.tri(A)]=0
	> A
	     [,1] [,2] [,3] [,4]
	[1,]    1    5    9   13
	[2,]    0    6   10   14
	[3,]    0    0   11   15
	[4,]    0    0    0   16
	```
	在R中定义了row()和col()函数用来返回矩阵的行列下标。另外，也可以通过使用x[row(x)<col(x)]=0等语句来得到矩阵的上下三角矩阵。
	例如：
	```py
	> A <- matrix(1:16,4)
	> row(A)
	     [,1] [,2] [,3] [,4]
	[1,]    1    1    1    1
	[2,]    2    2    2    2
	[3,]    3    3    3    3
	[4,]    4    4    4    4
	> col(A)
	     [,1] [,2] [,3] [,4]
	[1,]    1    2    3    4
	[2,]    1    2    3    4
	[3,]    1    2    3    4
	[4,]    1    2    3    4
	> A[row(A)<col(A)]=0
	> A
	     [,1] [,2] [,3] [,4]
	[1,]    1    0    0    0
	[2,]    2    6    0    0
	[3,]    3    7   11    0
	[4,]    4    8   12   16
	```
	矩阵中计算行列式的值可以使用函数det()来计算,例如对上面的下三角矩阵求行列式：
	```py
	> det(A)
	[1] 1056
	```
	在R的使用过程中，经常需要将矩阵转化为向量化算子，编写一个小函数即可实现。
	例如：
	```py
	> vec <- function(x){
	+   t(t(as.vector(x))) 
	+   } 
	
	> (A <- matrix(1:6,2,3)) 
	     [,1] [,2] [,3]
	[1,]    1    3    5
	[2,]    2    4    6
	
	> vec(A)
	     [,1]
	[1,]    1
	[2,]    2
	[3,]    3
	[4,]    4
	[5,]    5
	[6,]    6
	```
	在时间序列分析中，常常需要用到滞后序列，R中的fMultivar包中的函数tslag()可以实现。首先，我们需要安装fMultivar，然后再载入该包。 tslag的用法为`tslag(x, k = 1, trim = FALSE)`
	其中，x为一个向量，k为滞后期数，trim默认返回序列与原序列长度相同，但包含NA值，若trim=T，则返回不含NA值。例如：
	```py
	> x <- 1:6
	> tslag(x,1:4,trim=F)
	     [,1] [,2] [,3] [,4]
	[1,]   NA   NA   NA   NA
	[2,]    1   NA   NA   NA
	[3,]    2    1   NA   NA
	[4,]    3    2    1   NA
	[5,]    4    3    2    1
	[6,]    5    4    3    2
	
	> tslag(x,1:4,trim=T)
	     [,1] [,2] [,3] [,4]
	[1,]    4    3    2    1
	[2,]    5    4    3    2
	```
	对于矩阵的运算，我们还可以使用apply()函数来进行各种计算，其用法为
	`apply(X, MARGIN, FUN, ...) `。其中，X表示需要处理的数据，MARGIN表示函数的作用范围，1为对行运算，2为对列运算。FUN为需要运用的函数。例如：
	 ```py
	> A <- matrix(1:12,3,4)
	> apply(A,2,sum) #矩阵的列求和
	[1]  6 15 24 33
	> apply(A,2,mean) #矩阵的列求均值
	[1]  2  5  8 11
	> apply(A,2,var) #矩阵的列求方差
	[1] 1 1 1 1
	> apply(A,2,sd) #矩阵的列求标准差
	[1] 1 1 1 1
	```
	矩阵合并可以使用rbind()和cbind()函数来对矩阵按照行和列进行合并。例如：
	```py
	> B=matrix(c(1,1,1,1),2,2) #生成2×2的矩阵
	> rbind(B,B) #将B和B矩阵按行合并
	     [,1] [,2]
	[1,]    1    1
	[2,]    1    1
	[3,]    1    1
	[4,]    1    1
	> cbind(B,B) #将B和B矩阵按列合并
	     [,1] [,2] [,3] [,4]
	[1,]    1    1    1    1
	[2,]    1    1    1    1
	```
	对于得到的矩阵，可以使用A[i,j]得到A矩阵第i行第j列的元素，A[i,]和A[,j]分别表示返回第i行和第j列的所有元素。也可以使用A[i:k,j:l]的形式来获得多行多列的子矩阵。
	例如：
	```py
		> A=matrix(1:12,3,4)
		> A[2,3] #返回矩阵第2行第3列元素
		[1] 8
		> A[2,] #返回矩阵第2行所有元素
		[1]  2  5  8 11
		> A[,3] #返回矩阵第3列所有元素
		[1] 7 8 9
		> A[1:3,2] #返回矩阵第1到3行，且是第2列的元素
		[1] 4 5 6
	```
	使用as.matrix()把非矩阵格式的转换成矩阵格式，函数is.matrix()可以辨别是否矩阵。


#### 2.2.3  数组
数组(array)可以看作是带有多个下标的类型相同的元素的集合，也可以看作是向量和矩阵的推广，一维数组就是向量，二维数组就是矩阵。
数组的生成函数是array()，其句法是：`array(data = NA, dim = length(data), dimnames = NULL)`
其中data表示数据，可以为空，dim表示维数，dimnames可以更改数组的维度的名称。例如:
```python
> (xx <- array(1:24,c(3,4,2)))    # 产生维数为(3,4,2)的3维数组
, , 1
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
, , 2
     [,1] [,2] [,3] [,4]
[1,]   13   16   19   22
[2,]   14   17   20   23
[3,]   15   18   21   24
```
索引数组类似于索引矩阵，**索引向量可以利用下标位置来定义**；其中`dim()函数可以返回数组的维数，还可以用来将向量转化成数组或矩阵(见下例)`。数组也可以用“+”、“-”、“*”、“/”以及函数等进行运算，其方法和矩阵相类似，这里不再详述。
```python3
> xx[2,3,2]
[1] 20
> xx[2,1:3,2]
[1] 14 17 20
> xx[,2,]
     [,1] [,2]
[1,]    4   16
[2,]    5   17
[3,]    6   18
> dim(xx)
[1] 3 4 2
> zz=c(2,5,6,8,1,4,6,9,10,7,3,5)
> dim(zz) = c(2,2,3) # 将向量转成维度为（2,2,3）的数组
> zz
  , , 1
       [,1] [,2]
  [1,]    2    6
  [2,]    5    8
  , , 2
       [,1] [,2]
  [1,]    1    6
  [2,]    4    9
  , , 3
       [,1] [,2]
  [1,]   10    3
  [2,]    7    5
```
#### 2.2.4  因子
分类型数据（category data）经常要把数据分成不同的水平或因子（factor）。比如，学生的性别包含男和女两个因子。因子代表变量的不同可能的水平（即使在数据中不出现）。在统计模型统计分析中十分有用，例如将0，1转换为’yes’,’no’就很方便。
在R里可以使用factor函数来创建因子，函数形式如下：`factor(x = character(), levels, labels = levels, exclude = NA, ordered = is.ordered(x))。`其中，levels用来指定因子的水平；labels用来指定水平的名字；exclude表示在x中需要排除的水平；ordered用来决定因子的水平是否有次序。
例如一组学生数据：
```py
> y <- c("女","男","男","女","女","女","男") 
> (f <- factor(y)) #生成因子
[1] 女 男 男 女 女 女 男
Levels: 女 男
> levels(f) #提取因子的水平
[1] "女" "男"
```

#### 2.2.5  列表
向量、矩阵和数组的元素都必须是同一类型的数据。如果一个数据对象需要含有不同的数据类型，可以采用列表（list）这种数据对象的形式（数据对象形式）。列表是一个对象的有序集合构成的对象，列表中包含的对象又称为它的分量（components），分量可以是不同的模式或类型，如一个列表可以包括数值向量、逻辑向量、矩阵、字符、数组等。创建列表的函数是list()，其句法是：list（变量1=分量1，变量2=分量2，….）。
例如：下面是某校部分学生的情况，其中，x、y、z分别表示班级、性别和成绩。
```py
>x <- c(1,1,2,2,3,3,3) 
> y <- c("女","男","男","女","女","女","男")  
> z <- c(80,85,92,76,61,95,83)
> (LST <- list(class=x,sex=y,score=z))
$class
[1] 1 1 2 2 3 3 3
$sex
[1] "女" "男" "男" "女" "女" "女" "男"
$score
[1] 80 85 92 76 61 95 83
若要访问列表的某一成分，可以用LST[[1]],LST[[2]]的形式访问，要访问第二个分量的前三个元素可以用LST[[2]][1:3]：
> LST[[3]] #返回列表的第三个成分的值
[1] 80 85 92 76 61 95 83
> LST[[2]][1:3] #返回列表第二个成分的第1到3元素
[1] "女" "男" "男“
```
由于分量可以被命名，这时，我们可以在列表名称后加$符号，再写上成分名称来访问列表分量。其中成分名可以简写到可以与其它成分能够区分的最短程度，如LST$sc与LST$score表示同样的分量。例如：
```py
> LST$score # 返回socre值
[1] 80 85 92 76 61 95 83
> LST$sc # 返回socre值
[1] 80 85 92 76 61 95 83
```
函数length（）、mode（）、names（）可以分别返回列表的长度（分量的数目）、数据类型、列表里成分的名字。
在这里要注意LST[[1]]和LST[1]的差别，[[…]]是选择单个元素的操作符，而[…]是一个一般通用的下标操作符。因此前者得到的是LST中的第一个对象，并且包含分量名字的命名列表中的分量名字会被排除在外的1；而后者得到的则是LST中仅仅由第一个元素构成的子列表。

#### 2.2.6  数据框
1、数据框的生成
数据框（data frame）是一种矩阵形式的数据，但数据框中各列可以是不同类型的数据。数据框每列是一个变量，每行是一个观测。数据框可以看成是矩阵（matrix）的推广，也可以看作是一种特殊的列表对象（list）。数据框是R语言特有的数据类型，也是进行统计分析最为有用的数据类型。不过对于可能列入数据框中的列表有如下一些限制：
分量必须是向量（数值，字符，逻辑），因子，数值矩阵，列表或者其他数据框。
矩阵，列表和数据框为新的数据框提供了尽可能多的变量，因为它们各自拥有列、元素或者变量。
数值向量、逻辑值、因子保持原有格式，而字符向量会被强制转换成因子并且它的水平就是向量中出现的独立值。
在数据框中以变量形式出现的向量结构必须长度一致，矩阵结构必须有一样的行数。
 R语言中用函数data.frame ( )生成数据框，其句法是：
`data.frame(..., row.names = NULL, check.rows = FALSE, ...)`
数据框的列名默认为变量名，也可以对列名、行名进行重新命名。例如：
```py
> x<-c(1,1,2,2,3,3,3)
> y<-c("女","男","男","女","女","女","男")
> z<-c(80,85,92,76,61,95,83)
> (student <- data.frame(x,y,z))
  x  y  z
1 1 女 80
2 1 男 85
3 2 男 92
4 2 女 76
5 3 女 61
6 3 女 95
7 3 男 83
> (student <- data.frame(class=x,sex=y,score=z))
      class sex score
1     1  女    80
2     1  男    85
3     2  男    92
4     2  女    76
5     3  女    61
6     3  女    95
7     3  男    83
```
当然，我们也可以对数据框的行名进行修改，例如：
```py
> row.names(student) <- c("王x","张x","赵x","刘x","黄x","孙x","李x")
> student
        class sex score
王x     1  女    80
张x     1  男    85
赵x     2  男    92
刘x     2  女    76
黄x     3  女    61
孙x     3  女    95
李x     3  男    83
```
2、数据框的引用
以数组形式访问。数据框可以看作是特殊的数组。数组是储存数据的有效方法，可以按行或列访问，就像电子表格一样，但输入的数据必须是同一类型。数据框可以看作数组是因为数据框的列表示变量、行表示样本观察数，因此我们可以访问指定的行或列。
例如：
```py
> student[,"score"]     #返回y变量的所有样本观察数
[1] 80 85 92 76 61 95 83
> student[,3]
[1] 80 85 92 76 61 95 83
> student[1:5,1:3]  #返回第1至第5行，第1至第3列的观察数
> student[,]              #返回所有行所有列数据
```
以列表形式访问数据框。列表比数据框更为一般、更为广泛。列表是对象的集合，而且这些对象可以是不同类型的。数据框是特殊的列表，数据框的列看作向量，而且要求是同一类型对象。以列表形式访问数据框，只要在列表名称后面加$符号，再写上变量名即可。例如：
```py
> student$score 
[1] 80 85 92 76 61 95 83
       除了用$形式访问外，还可以用列表名[[变量名(号)]]形式访问：
> student[["score"]]
[1] 80 85 92 76 61 95 83
> student[[3]]
[1] 80 85 92 76 61 95 83
```
还可以筛选出符合我们条件的数据，比如对上面的数据要得到成绩大于80分的学生，可以按如下的方法得到。例如：
```py
> student[student$score>80,]
    class sex score
张x     1  男    85
赵x     2  男    92
孙x     3  女    95
李x     3  男    83
```
3、数据框绑定Attach()函数
数据框的主要用途是保存统计建模的数据。R软件的统计建模功能都需要以数据框为输入数据。可把数据框当成一种矩阵来处理。在使用数据框的变量时可以用“数据框名$变量名”的记法。但这样使用较麻烦，R软件提供了attach()函数可以把数据框中的变量“链接”到内存中，将数据框“连接（绑定）”入当前的名字空间，从而可以直接用数据框中的变量名访问而不必用“数据框名$变量”这种格式。要取消连接，用函数detach（）即可。
 
例如上面student数据框有三个变量，对于数据框里的变量我们不能直接引用，可以用“数据框名$变量名”的格式，或是利用attach( )把数据框“连接（绑定）”入当前的名字空间。要取消连接，用函数detach（）即可。
```py
> score
错误: 找不到对象'score'
> student$score
[1] 80 85 92 76 61 95 83
> attach(student)
> score
[1] 80 85 92 76 61 95 83
```

---
## 三、函数与优化

### 3.1 常用的R内置函数
- R里面有很多内置函数，这些内置函数保存在不同的扩展包里。有些内置函数保存在**R的核心包**里，比如mean()函数保存在base包里；有些内置函数分散在**R的各个扩展包**里，比如做k-近邻分类方法的knn()保存在class包里；
- R具有的非常丰富的内置函数，大大方便了我们的数据分析工作。内置函数的使用比较简单，将穿插在各个部分讲解，重点在于编写自己的函数。在编写自己的函数之前，先要学习R的条件控制语句和循环语句。
### 3.2 条件控制语句
#### 3.2.1 if/else语句
- if/else语句是分支语句中主要的语句，if/else语句的格式为：
	 ```R
	 if(cond) statement_1
	 if(cond) statement_1 else statement_2
	 ```
	即如果条件cond成立，则执行statement_1；否则跳过。
	第二句是指如果条件cond成立，则执行statement_1；否则执行statement_2。
#### 3.2.2 if/else if/else语句
- 更复杂的情况：
	```R
	 if (cond_1)
		statement_1 
	 else if (cond_2)
		statement_2
	 else if (cond_3)
	    statement_3
	 else 
	    statement_4
	```
#### 3.2.3 ifelse语句
- `ifelse`结构是if/else紧凑的向量化版本，其语法为
	```python   
	 ifelse (cond, statement1, statement2)
	```
   即如果cond成立，则执行statement1, 否则执行statement2。
例如：
	```R
	> x<-1
	> ifelse(x>2, y<-2*x, y<-3*x) #假如x大于2，则赋y为2*x，否则为3*x
	[1] 3
	```
#### 3.2.4 switch语句

- switch语句是多分支语句，其使用方法为：` switch(statement, list)`
其中，statement是表达式，list是列表，可以用有名定义。如果表达式的返回值在1到length(list) ，则返回列表相应位置的值。
例如：    runif()函数用于生成从0到1区间范围内的服从正态分布的随机数：
	```python
	> switch(1,2*3,sd(1:5),runif(3))  #返回（2*3,sd(1:5),runif(3)）list中的第一个成分
	[1] 6
	> switch(2,2*3,sd(1:5),runif(3))  #返回第二个成分
	[1] 1.581139
	> switch(3,2*3,sd(1:5),runif(3))  #返回第三个成分
	[1] 0.5656051 0.5359544 0.7167616
	```
  当list是有名定义时，statement等于变量名时，返回变量名对应的值；否则，返回NULL值。例如
	```python
	> x<-"meat"
	> switch(x, meat="chicken", fruit="apple", vegetable="potato")
	[1] "chicken"
	```
### 3.3 循环语句
  循环语句有for循环、while循环和repeat循环语句。
#### 3.3.1 for循环
-   `for(ind in expr_1) expr_2`，其中，ind是循环变量，expr_1是一个向量表示式（通常是个序列，如-10：10，expr_2通常是一组表达式。
例如：斐波那契数列Fibonacci序列是数学中著名的序列，前两个元素都是1，第三个元素是第一、二元素的和，第四个元素是第二、三个元素的和，一直下去。为了生成Fibonacci前16个元素，程序：
	```python
	> Fibonacci<-NULL #生成一个空置向量
	> Fibonacci[1]<-Fibonacci[2]<-1 # Fibonacci向量的第1和2个元素赋值为1
	> n=16
	> for (i in 3:n) Fibonacci[i]<-Fibonacci[i-2]+Fibonacci[i-1] #用for执行循环语句
	> Fibonacci
	 [1]   1   1   2   3   5   8  13  21  34  55  89 144 233 377
	[15] 610 987
	```
#### 3.3.2 while循环
- `while (condition) expr`，只有当condition条件成立的时候，执行表达式expr。
例如：编写小于1000的Fibaonacci序列：
	```python
	> Fibonacci[1]<-Fibonacci[2]<-1 # Fibonacci向量的第1和2个元素赋值为1
	> i<-1
	> while (Fibonacci[i]+Fibonacci[i+1]<1000) {  #用while执行循环语句
	         Fibonacci[i+2]<-Fibonacci[i]+Fibonacci[i+1]
	         i<-i+1       }
	> Fibonacci
	 [1]   1   1   2   3   5   8  13  21  34  55  89 144 233 377
	[15] 610 987
	```
#### 3.3.3 repeat语句
- `repeat`循环依赖break语句跳出循环。
例：利用repeat生成小于1000的Fibonacci序列
	```python
	> Fibonacci[1]<-Fibonacci[2]<-1 # Fibonacci向量的第1和2个元素赋值为1
	> i<-1
	> repeat {    #用repeat执行循环语句
	   Fibonacci[i+2]<-Fibonacci[i]+Fibonacci[i+1]
	   i<-i+1
	   if (Fibonacci[i]+Fibonacci[i+1]>=1000) break
	 }
	> Fibonacci
	[1]   1   1   2   3   5   8  13  21  34  55  89 144 233 377
	[15] 610 987
	此处，break为中止语句。R中同样用break语句对循环进行终止，使程序跳到循环以外。
	```
### 3.4 编写自己的函数
在较复杂的计算问题中，有时候一个任务可能需要重复多次，这时我们不妨编写自己的函数。这么做的好处之一是可以批量处理这些任务，而不需要每次都重复执行。
另一个好处是函数内的变量名是局部的，即当函数运行结束后它们不再被保存到当前的工作空间，这就可以避免许多不必要的混淆和内存空间占用。

编写函数的句法是：
```
函数名 = function (参数1，参数2…)
{  
        statements
        return(object)
}
```
#### 3.4.1 函数名
函数名可以是任何值，但以前定义过了的要小心使用，后来定义的函数会覆盖原先定义的函数。一旦你定义了函数名，你就可以像R的其它函数一样使用。例如：
可以这样定义一个用std求标准差的函数（R内置的求标准差的函数是sd）
```python
> std = function(x) { sqrt(var(x)) }
对于这类只有一个语句的简单函数，也可不要{}，即 
> std = function(x)  sqrt(var(x)) 
这里的函数名就是std，以后我们就可以像其它函数一样使用它了。
> x=c(1,3,5,7,9)
> std(x)
[1] 3.162278
假如我们不使用圆括号，直接输入函数名，按回车键将显示函数的定义式：
> std
function(x) sqrt(var(x))
```
#### 3.4.2 关键字function
编写函数一定要写上function这个关键词，它告诉R这个新的数据对象是函数，所以编写函数时千万不可忘记。

#### 3.4.3 参数
函数根据实际需要的不同而有不同的参数设置，下面将介绍三种情况：

（1）无参数：有时编写函数是为了某种方便，函数每次的返回值都是一样的，其输入不是那么重要。比如我们编写“welcome”函数，其每次返回值都是“welcome use R”。
```python
> welcome = function() print("welcome to use R")
> welcome()
[1] "welcome to use R" 
（2）单参数：假如要使你的函数个性化，可以使用单参数，函数将会根据参数的不同，返回值也不同。
> welcome.sb = function(names) print(paste("welcome",names,"to use R"))
> welcome.sb("Mr fang")
[1] "welcome Mr fang to use R"
```
（2）默认参数：即不输入任何参数。上面的welcome.sb函数假如不输入参数结果将会怎么样呢？
```python
> welcome.sb()
错误在paste("welcome", names, "to use R") : 缺少变元“names”，也没有缺失值。
```
没有输入参数，函数welcome.sb将返回出错信息。其实我们可以给函数设置默认值，
R提供了一个简单的方法允许给函数的参数设置默认值。比如：
```python
> welcome.sb=function(names="Mr fang")print(paste("welcome", names,"to use R"))
> welcome.sb()
[1] "welcome Mr fang to use R"
```
（3）有参数：
下面编写一个模拟函数求服从均值为10，标准差为5的正态样本数据的t统计量。
```python
> sim.t=function(n){
 mu=10;sigma=5;
 x=rnorm(n,mu,sigma) #生成n个均值为mu,标准差为sigma的正态分布随机数
 (mean(x)-mu)/(sd(x)/sqrt(n))
}
> sim.t(5)   # 样本量为5
[1] -5.794325
```
sim.t函数的均值、标准差都是固定的，但是假如我们希望这个函数的均值、标准差是可随意设置的。这时，我们就要在函数里添加均值、标准差两个参数。例如：
```python
> sim.t = function(n,mu,sigma){
   x=rnorm(n,mu,sigma)
   (mean(x)-mu)/(sd(x)/ sqrt(n))
}
> sim.t(5,0,1)         # 样本含量为5，均值为0，标准差为1
[1] -0.720194
```
#### 3.4.4 函数体和函数返回值
函数体和函数返回值是整个函数的主要部分，默认返回函数体的最后一个表达式的结果。如果函数体的表达式只有一个当然就很简单。例如：
```python
> my.average = function(x) sum(x)/length(x)
> my.average(c(1,2,3))
[1] 2 
```
当函数体的表达式超过一个时，要用{}封起来。例如我们用一个编写名为vms()的函数来计算向量的最大5个数的均值，并返回最大的5个值。R里也可以用return()返回函数需要的结果，当需要返回多个结果时，一般建议用list形式返回。
```python
> a<-c(2,4,43,2,42,56)
> sort(a) #从小到大排序
[1]  2  2  4 42 43 56
> rev(a) #根据下标大小，从大到小排序
[1] 56 42  2 43  4  2
> rev(sort(a)) #配合使用，从大到小排序，注意和上面的区别
[1] 56 43 42  4  2  2
```
-sort(-a)

例如：
```python
> vms=function(x){
xx=rev(sort(x)) #对x向量从小到大排序，然后用rev()转成从大到小排序
xx=xx[1:5] #提取前面5个元素
mean(xx) #求均值
return(list(xbar=mean(xx),top5=xx)) #返回均值和最大的5个数
}
> y=c(5,15,32,25,26,28,65,48,3,37,45,54,23,44)
> vms(y) #利用自己编写的函数vms()
$xbar
[1] 51.2
$top5
[1] 65 54 48 45 44
```
编写程序，尤其是编写很长的程序是一件浩大的工程，费心费力，而且随着程序写的越长，越不好管理，也不好理解。
1. 建立从上到下设计的思想，将大的程序拆分成几块来写，每一块可以写成单独的函数。这有点像是盖楼，先把桩和框架搭好，然后再往里面逐步填充内容。
2. 将每一块又分成几步来写。
3. 应及时勤快地加注释。写好的程序过了几天，往往可能忘了其含义。
4. 尽可能做向量化运算。因为R将所有对象都存储在内存中，尽量少用循环(for,while)。用R内置函数 lappply,sapply,mapply等处理向量、矩阵或列表。
5. 在完整的数据集上运行程序前，抽取部分数据子集进行测试，消除bug并进一步优化程序。


### 3.5 程序调试
程序调试是每个程序员都头疼但是大多情况下必须面临的问题。计算机程序的错误或者缺陷叫“bugs”。我们所写的程序不一定都是百分百正确。调试程序一般分为如下几步：

1. 识别程序是否存在错误。有时很容易，因为如果程序出错，无法运行，那肯定是存在；但是有些时候，这类错误很难去识别。
2. 找出程序出错的原因。当程序有错，无法继续运行时，R往往会给出报错信息，可以根据报错信息找出出错的原因。在R里还提供了traceback()、Debug()、Browser()函数可以跟踪和找出程序出错的地方。
3. 修正错误并测试。
4. 寻找类似的错误

### 3.6 用R做优化求解
优化是在统计计算中非常重要的一部分内容，因为很多统计方法，比如最小二乘法和极大似然估计法，归根到底就是求目标函数的最小值或者最大值。接下来，先讲解最简单的一元函数的优化求解，然后再讲解多元函数的优化求解。

#### 3.6.1 一元函数优化求解
R做一元的最优化求解函数是
```python
optimize(f = , interval = ,  ..., lower = min(interval), upper = max(interval), maximum = FALSE,
tol = .Machine$double.eps^0.25)
```
其中，f是需要求优化的函数，interval是参数搜索的区间，**lower是参数搜索的下限，如果缺失，用interval的最小值代替，upper是参数搜索的上限，缺失时用interval的最大值代替**。Maximum默认是FALSE，表示默认是求极小值。tol是精度的容忍度。

例如：求解 f(x)=ln(x)-x2
这个函数的图形如图所示。该函数只有一个极大值，利用拉格朗日方法可以求得在?=√2/2
处取得最大值。
```python
> f=function(x) log(x)-x^2 #编写f函数
>optimize(f,c(0.1,10),tol=0.0001,maximum=T) 
#求f函数的最大值的返回结果
$maximum
[1] 0.7071232
$objective
[1] -0.8465736
```
利用R求解出来的目标函数的最大值为-0.8465736，这与利用拉格朗日方法求解的结果相同。

#### 3.6.2 多元函数优化求解
多元函数的优化求解可以用使用函数optim()求解，其用法如下
```python
optim(par, fn, gr = NULL, ...,method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN"),
lower = -Inf, upper = Inf, control = list(), hessian = FALSE)
```
par设定初始值，fn是需要优化的目标函数，gr是梯度向量，如果是NULL则由optim()计算所得的近似值替代。lower是参数搜索的下限，默认是-∞，`upper是参数搜索的上限，默认是+∞`。control是用来控制optim函数的一些参数，hessian=FALSE表示不需要返回海塞矩阵。**在计算机里，优化的求解实质上是通过迭代算法所得**。optim()提供的迭代算法主要有Nelder-Mead，BFGS，CG，L-BFGS-B，SANN。

例如：求解两元函数 g(x1,x2)=( x12+x2-11)2+(x1+x22-7)2 的极值。
Step1: 用R写出目标函数表达式
```python
x1=x2=seq(-10,10,length=100)
fr2=function(x){
   x1=x[1]
   x2=x[2]
  (x1^2+x2-11)^2+(x1+x2^2-7)^2
  }
grr=function(x){
   x1=x[1]
   x2=x[2]                  ###写一阶导表达式(梯度表达式)
c(2*(x1^2+x2-11)*2*x1+2*(x1+x2^2-7),
  2*(x1^2+x2-11)+2*(x1+x2^2-7)*2*x2)
  }
```
Step2: 设置优化算法迭代初始值，利用optim()进行优化求解。
```python
> optim(c(-5,-5),fr2,grr) #设初始值为-5，-5，不同初始值的优化结果可能不同
$par
[1] -3.779382 -3.283146
$value
[1] 4.524988e-07
$counts
function gradient 
      59       NA 
$convergence
[1] 0
$message
NULL
```
 需要注意的是不同的初始值的优化结果可能不同，将上述问题几种不同初始值的优化结果整理成如表3-1所示 。从表3-1可以看出，该两元函数应该有四个局部最小值。 
 <img src="https://img-blog.csdnimg.cn/20190308144504878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="60%" alt="" />

---
## 四、 随机数与抽样模拟
### 4.1  一元连续随机数的产生
#### 4.1.1 均匀分布随机数
均匀分布随机数是最简单的随机数，也是其他分布随机数的基础。

`runif( )——生成均匀分布随机数的函数`，其句法是：`runif(n, min=0, max=1)`，n表示生成的随机数数量，min表示均匀分布的下限，max表示均匀分布的上限，**若省略参数min、max，则默认生成[0,1]上的均匀分布随机数**。

- 例如：
```python
> runif(3,1,3)    # 生成3个[1,3] 的均匀分布的随机数
[1] 1.204 1.359 2.653
> runif(5)        # 默认生成5个[0,1]上的均匀分布随机数
[1] 0.2784 0.7755 0.4107 0.8392 0.7455
```

Runif()默认每次生成的随机数是不一样的，有时我们在做模拟的时候，为了比较不同的方法好坏，需要生成的随机数都要一样，即重复生成同样的随机数，这个时候我们可以使用set.seed()设定随机数种子，其参数为整数。
```python
> set.seed(1) #种子取一样，生成的随机数相同
> runif(5)
[1] 0.2655087 0.3721239 0.5728534 0.9082078 0.2016819
4.1.2   正态分布随机数
```
#### 4.1.2 正态分布随机数
正态分布是古典统计学的核心，它涉及到两个参数：位置参数均值，尺度参数标准差。正态分布的图形如倒立的钟型，对称分布。现实生活中，很多分布是服从正态分布，比如人类的智商IQ，大致服从均值为100，标准差为16的正态分布。**所有的正态分布可以通过标准化成均值0，标准差为1的标准正态分布。**

`rnorm( )——生成正态分布随机数的函数`，其句法是：`rnorm(n, mean=0, sd=1)`。其中，**n表示生成的随机数数量**；mean是正态分布的均值，默认为0；sd是正态分布的标准差，默认时为1。正态分布随机数R提供了`Kinderman-Ramage、Ahrens-Dieter、Box-Muller、逆变换法`。默认的是逆变换法。

- 例如： 
```python
> rnorm(5,10,5)    #产生5个均值为10标准差为5的正态分布随机数
[1]  3.172 14.705  7.173  5.842  8.879
> rnorm(5)            # 默认5个生成标准正态分布随机数
[1] -0.58204  0.04606  0.96016 -0.68698 -0.35504
 ```
 
#### 4.1.3   指数分布随机数
指数分布是统计分布中非常重要的一个分布，它有着诸多应用，比如可以用来描述电子产品的寿命，一个灯泡的平均寿命是2500小时，我们可以认为这个灯泡的寿命服从均值为2500的指数分布。

`rexp( )——生成指数分布随机数的函数`，其句法是：`rexp(n, lamda = 1)`，n表示生成的随机数个数，lamda＝1/mean。例如：
```python
> x=rexp(100,1/10)    # 生成100个均值为10的指数分布随机数
```
### 4.2  一元离散随机数的产生
#### 4.2.1   二项分布随机数的生成
二项分布是指n次独立重复贝努力试验（Bernoulli trials）成功的次数的分布，每次贝努力试验的结果只有两个，成功和失败，记成功的概率为p。如果一个变量x服从二项分布，记为x～B(n,p)，n表示试验次数，p表示成功概率。

`rbinom( )——生成二项分布随机数的函数`，其句法是：`rbinom(n, size, prob)`，n表示生成的随机数数量，size表示进行贝努力试验的次数，prob表示一次贝努力试验成功的概率。
首先，我们生成二点分布（一次贝努力试验）的随机数。
```python
> size=1; p=0.5
> rbinom(10,size,p) # size=1为两点分布
 [1] 0 0 0 1 0 0 1 1 0
```
接下来，我们生成服从B(10,0.5)的二项分布随机数。
```python
> size=10; p=0.5
> rbinom(5,size,p) # 生成5个服从B(10,0.5)的二项分布随机数
[1] 5 6 3 3 3
```
#### 4.2.2   常见分布函数表
除了生成上面介绍的几种分布的随机数，还可以生成poisson分布、t分布、F分布等很多种分布的随机数，**只要在相应的分布名前加“r”就可以**，在此不一一赘述。现把常见分布归纳成表4-1，供读者参考。
<img src="https://img-blog.csdnimg.cn/20190311235113552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="60%" alt="" />      <img src="https://img-blog.csdnimg.cn/20190311235130214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="60%" alt="" />
除了*在分布函数前面加r表示产生随机数外，还可以加p、q、d*，它们的作用参见表4-2。
|函数代号|函数作用
|:-----|:--|
| **r-** | 生成相应分布的**随机数** |
| **d-**| 生成相应分布的**概率密度函数**  |
| **p-**| 生成相应分布的**累计概率分布函数**  |
| **q-**| 生成相应分布的**分位数函数**  | 

例如： 
- dnorm表示正态分布密度函数
- pnorm表示正态分布累积概率分布函数
- qnorm表示正态分布分位数函数（即正态累积概率分布函数的逆函数）

### 4.3 多元随机数的产生
#### 4.3.1  多元正态分布随机数的生成
1. 多元正态分布随机数可以使用`MASS包中的mvrnorm()`，其使用方法是：
`mvrnorm(n = 1, mu, Sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)`。
n是生成的随机数个数，mu是均值向量，Sigma是协方差阵，tol是容忍度，empirical是逻辑参数，取TRUE时，mu和sigma取经验均值和协方差阵。
	<img src="https://img-blog.csdnimg.cn/20190313114613608.png" width="65%" alt="/" >
	```python
	> library(MASS)  #载入MASS包
	> Sigma <- matrix(c(10,3,3,2),2,2)
	> Sigma
	     [,1] [,2]
	[1,]   10    3
	[2,]    3    2
	>x=mvrnorm(n=1000, rep(0, 2), Sigma)
	> head(x)     #head   数据的前n行, tail 数据的后n行 默认为6行
	,           [,1]       [,2]
	[1,]  5.0585261  1.4603670
	[2,]  2.1053161  1.6517563
	[3,]  2.7894367  1.8277556
	[4,]  -0.4613868  -0.3554319
	[5,]  0.7204386  -0.2566820
	[6,]  -3.0624694  0.3966681
	> var(x)
	         [,1]     [,2]
	[1,] 10.18628 2.764450
	[2,]  2.76445 1.865402
	```
2. 另一种方法是安装包`mvnorm`。包中的`rmvnorm()函数可以生成多元正态分布`，其用法：`rmvnorm(n, mean = rep(0, nrow(sigma)), sigma = diag(length(mean)),  method=c("eigen", "svd", "chol"), pre0.9_9994 = FALSE)`
n是生成随机数的个数，mean是均值向量，sigma是协方差阵。method提供了三种对sigma矩阵进行分解的方法：特征根分解”eign” (默认), 奇异值分解”sv”和cholesky分解“chol”。
	<img src="https://img-blog.csdnimg.cn/20190313114623331.png" width="65%" alt="/" >
	```python
	>install.packages("mvtnorm")
	>library(Mvtnorm)
	> sigma <- matrix(c(10,3,3,2), ncol=2)
	> x <- rmvnorm(n=500, mean=c(1,2), sigma=sigma)
	> head(x)
	            [,1]      [,2]
	[1,]  -1.02706101 2.0325031
	[2,]  1.17677534 0.9076424
	[3,]  -0.69601078 1.8095752
	[4,]  0.81885937 0.2968203
	[5,]  5.01558563 3.5201720
	[6,]  -0.07314836 2.5388707
	> colMeans(x)
	[1] 1.133808 2.080458
	> var(x)
	          [,1]     [,2]
	[1,] 10.405497 2.929879
	[2,]  2.929879 1.961995
	>plot(x)
	```
	<img src="https://img-blog.csdnimg.cn/20190313114427198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%" alt="/" >
 
#### 4.3.2  多元正态分布密度函数、分位数与累积概率
与生成一元随机数类似， `pmvnorm()可以计算累积概率分布`，其用法是
`pmvnorm(lower=-Inf, upper=Inf, mean=rep(0, length(lower)), corr=NULL, sigma=NULL, algorithm = GenzBretz(), ...)`
其中lower是求累积概率的下限，默认为-∞。Upper是求累积概率的上限，默认为+∞。Mean是多元正态分布的均值向量，corr是多元正态分布的相关系数矩阵，sigma是协方差矩阵，其中**相关系数矩阵和协方差阵两者只要知道一个即可**。Algortithm是计算累积概率的算法，R提供了GenzBretz、Miwa 和 TVPACK，默认为 GenzBretz算法。
同理，求多元正态分布的`概率密度函数可以用dmvnorm()`，求多元正态分布的`分位数可以用qmvnorm()`。
<img src="https://img-blog.csdnimg.cn/20190313113902153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="65%" alt="/" >
```python
> (mean <- rep(0, 5)) #均值向量
[1] 0 0 0 0 0
> (lower <- rep(-1, 5)) #下限
[1] -1 -1 -1 -1 -1
> (upper <- rep(3, 5)) #上限
[1] 3 3 3 3 3
> (corr <- diag(5)) #相关系数矩阵
     [,1]  [,2]   [,3]  [,4]  [,5]
[1,]    1    0    0    0    0
[2,]    0    1    0    0    0
[3,]    0    0    1    0    0
[4,]    0    0    0    1    0
[5,]    0    0    0    0    1
> (corr[lower.tri(corr)] <- 0.5) 
#相关系数矩阵下三角用0.5赋值
> (corr[upper.tri(corr)] <- 0.5) 
#相关系数矩阵上三角用0.5赋值

> corr
     [,1] [,2] [,3] [,4] [,5]
[1,]  1.0  0.5  0.5  0.5  0.5
[2,]  0.5  1.0  0.5  0.5  0.5
[3,]  0.5  0.5  1.0  0.5  0.5
[4,]  0.5  0.5  0.5  1.0  0.5
[5,]  0.5  0.5  0.5  0.5  1.0
> (prob <- pmvnorm(lower, upper, mean, corr))
[1] 0.5800877
```
#### 4.3.3  多元t分布随机数
R中生成多元t分布，也可以使用mvnorm包中的`rmvt()`，其用法是
`rmvt(n, sigma = diag(2), df = 1, delta = rep(0, nrow(sigma)),      type = c("shifted", "Kshirsagar"), ...)`。
其中，n是需要生成的随机数个数，sigma是事先给定的协方差阵。df是t分布自由度，默认值为1。参数delta, type是用来设置非中心化的多元t分布。
同理，求多元t分布的`密度函数可以dmvt()`，求多元t分布的`分位数可以用qmvt()`,求多元t分布的`累积概率分布用pmvt()`。

例4-5: 我们现在需要生成1000个服从自由度为5，相关系数为0.5的两元t分布。
```python
> sigma=diag(2)+1
> sigma
     [,1] [,2]
[1,]    2    1
[2,]    1    2
> x2<-rmvt(n=1000,df=5,sigma=sigma)
> head(x2)
            [,1]       [,2]
[1,] -0.90757696 -0.2518512
[2,] -0.08005831  1.2898629
[3,] -6.16577365 -5.4776832
[4,] -2.53960124  0.1871022
[5,]  1.04038843  0.4776877
[6,] -0.59168271  0.3045581
> plot(x2)
```
 <img src="https://img-blog.csdnimg.cn/2019031311360354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" height="40%" width="40%" alt="/" >

### 4.4 随机抽样
#### 4.4.1 放回与无放回抽样
**R可以进行有放回、无放回抽样。用R语言进行抽样很简单**，只要用`sample( )`函数就可以。其句法是这样的：`sample(x, n, replace = F, prob = NULL)`。X表示总体向量，可以是数值、字符、逻辑向量。n表示样本容量，`replace = F，表示无放回抽样，replace = T表示有放回抽样，默认的是无放回抽样`。prob可以设置各个抽样单元不同的入样概率，进行不等概率抽样。

例4-6:可以用R来模拟抛一枚硬币，H表示正面，T表示反面，重复抛10次的情况。
```python
> sample(c("H","T"),10,rep=T)
[1] "H" "T" "T" "H" "T" "H" "H" "H" "T" "H"
例如掷一颗六面的骰子，重复掷10次。
> sample(1:6,10,rep=T)
[1] 3 3 6 1 2 5 2 5 2 4
> sample(100,10)        #从100个产品中无放回随机抽取10个
[1] 91 27 20 35 49 56 70 57 32 12
> dice=as.vector(outer(1:6,1:6,paste))        #掷两颗六面的骰子
> sample(dice,5,replace=T)                #重复5次
[1] "2 2" "2 3" "6 3" "5 2" "3 1"
> dice=as.vector(outer(1:6,1:6,paste))#掷两颗六面的骰子的可能结果
```

 这里outer（a,b,function），当function为空时，表示a，b两个向量的外积，也就等价于a %o% b。另外，function是paste表示X向量的第一个元素与Y向量的每个元素分别组合，组成第一行，接着，X向量的第二个元素与Y向量的每个元素分别组合，组成第二行，这样直到X向量最后一个元素组合完毕。
本题的`outer(1:6,1:6,paste)`结果是：
```python
     [,1]    [,2]   [,3]   [,4]   [,5]   [,6] 
[1,]  "1 1"  "1 2"  "1 3"  "1 4"  "1 5"  "1 6"
[2,]  "2 1"  "2 2"  "2 3"  "2 4"  "2 5"  "2 6"
[3,]  "3 1"  "3 2"  "3 3"  "3 4"  "3 5"  "3 6"
[4,]  "4 1"  "4 2"  "4 3"  "4 4"  "4 5"  "4 6"
[5,]  "5 1"  "5 2"  "5 3"  "5 4"  "5 5"  "5 6"
[6,]  "6 1"  "6 2"  "6 3"  "6 4"  "6 5"  "6 6"
```
由于这（此）时为矩阵形式，`as.vector(X)表示把X强制转换成向量形式`。
```python
> dice
[1] "1 1" "2 1" "3 1" "4 1" "5 1" "6 1" "1 2" "2 2" "3 2" "4 2" "5 2" "6 2"
[13] "1 3" "2 3" "3 3" "4 3" "5 3" "6 3" "1 4" "2 4" "3 4" "4 4" "5 4" "6 4"
[25] "1 5" "2 5" "3 5" "4 5" "5 5" "6 5" "1 6" "2 6" "3 6" "4 6" "5 6" "6 6"
```
#### 4.3.2  bootstrap重抽样
bootstrap重抽样法是Efron于1982所创立的方法，属于重复抽样(Resampling)方法。它是以原始数据为基础的模拟抽样统计推断法，其基本思想是：**在原始数据的范围内做有放回的再抽样，样本量仍为n，原始数据中每个观察单位每次被抽到的概率相等，为1/n，所得样本称为bootstrap样本**。下面演示一下一个简单的bootstrap抽样。

例4-7：R内置数据faithful有个“eruptions”变量，这是记录火山爆发时间，它不属于我们常见的分布。对它进行bootstrap重抽样，程序如下：
```python
> faithful                         #读入内置数据
          eruptions  waiting
1        3.60      79
2        1.80      54
…
271      1.82      46
272      4.47      74
> attach(faithful)                 #数据绑定
> sample(eruptions,10,replace=T)   # 从数据中抽一个样本量为10的子样本
[1] 4.617 4.800 4.667 2.367 3.833 1.883 4.350 2.017 4.467 4.183
> Sample=sample(eruptions,1000,rep=T) # 抽取一个样本容量为1000的bootstrap样本
```
### 4.5 统计模拟
#### 4.5.1 几种常见的模拟方法
R具有模拟各种类型的随机数的功能，这样允许用户进行各项试验并快速得出结果。这是非常有用的技术，但是比较难掌握。

上一节介绍了R用函数生成各种随机数，并且通过画直方图或其它方法观察它们的分布。接下来，我们将生成一些新类型的随机数，并观察它们的分布情况。

-  (1). 中心极限定理
       中心极限定理是数理统计中非常重要的定理，很多定理和统计推断都建立在中心极限定理的基础上。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190313111942344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
- (2). 二项分布模拟中心极限定理
首先用二项分布去模拟中心极限定理。
假如z ~ b(n,p)，则其标准化变量x = (z-np)/√np(1-p) 。随着n→∞，x的分布而依概率收敛于标准正态分布。该定理也称为德莫弗－拉普拉斯定理。至于这个定理是否正确，除了数学上的严格证明外，也可用统计模拟方法检验它。
首先介绍如何`用R生成二项分布随机数的标准化变量`。
	```python
	> n=10;p=0.25
	> z=rbinom(1,n,p)
	> x=(x-n*p)/sqrt(n*p*(1-p))
	[1] 0.3651484
	```
	前者只是一个随机数标准化后的结果，我们需要产生很多随机数并观察它们的分布情况，比如需要产生100个这样的随机数，这在R中是非常容易实现的。
	```python
	> m =100                      # m为模拟次数
	> n = 10; p = 0.25
	> z = rbinom(m,n,p)              # 产生100个二项随机数
	> x = (z-n*p)/sqrt(n*p*(1-p))      
	 # 对100个二项随机数标准化
	> hist(x,prob=T,main=paste("n =",n))
	> curve(dnorm(x),add=T)          # 增（添）加正态曲线 
	```
	![在这里插入图片描述](https://img-blog.csdnimg.cn/20190313112122199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
- (3). 用函数来进行模拟
在上面的模拟例子中，我们指定模拟次数m=100，样本量n=10，概率=0.25，如果要改变这些参数来重新进行模拟将会很麻烦，下面将展示如何将上面的程序形成一个模拟函数再进行模拟。
	```python
	> sim.clt <- function (m=100,n=10,p=0.25)
	 { z = rbinom(m,n,p)               
	    x = (z-n*p)/sqrt(n*p*(1-p))        
	}
	> sim.clt()            # 默认 m=100，n=10，p=0.25
	> sim.clt(1000)        # 取 m=1000，n=10，p=0.25
	> sim.clt(1000,30)      # 取 m=1000，n=30，p=0.25
	> sim.clt(1000,30,0.5)      # 取 m=1000，n=30，p=0.5
	```
- (4). 正态概率模拟
能**比直方图更好判定随机数是否近似服从正态分布的是正态概率图**。其基本思想作样本分位数与理论分位数的散点图，看图像是否近似在一条直线上。**分位数比中位数、下四分位数Q1和上四分位数Q3等更具一般性**。**q分位数就是累积概率小于q％所对应的值**，所以25％分位数就是Q1，50%分位数就是中位数，75％分位数就是Q3。用R来画正态概率图很简单，只要使用函数`qqnorm()`和`qqline()`，其中qqline是用来添加参考线（并不是回归线）。

	例4-8：下面分别产生100个均值为0，标准差为1的正态分布随机数，均值为10，标准差为5的正态分布随机数，均值为10的指数分布，[0,1]上的均匀分布。再分别作它们的正态概率图。程序如下：
	```python
	> par(mfrow=c(2,2))  #设置2行2列的作图窗口
	> x=rnorm(100,0,1);qqnorm(x,main="N(0,1)");qqline(x) 
	  #画QQ图并添加qq线
	> x=rnorm(100,10,25);qqnorm(x,main="N(10,25)");qqline(x)
	> x=rexp(100,1/10);qqnorm(x,main="exp(0.1)");qqline(x)
	> x=runif(100,0,1); qqnorm(x,main="U(0,1)");qqline(x)
	> par(mfrow=c(1,1))
	```
	结果见图4-11，第一、第二（上面）两个图的散点近似分布在参考线上，所以服从正态分布，而第三（下面左边）个图的散点严重偏离参考线，第四个图两头翘尾，可认为这两个图不服从正态分布。 
      ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190313112441965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
### 4.5.2   模拟函数的建立方法
这部分我们将介绍如何编写函数，以及如何使用函数来实现模拟。假如每次模拟都要编写一个循环，这是一件很麻烦的事情。`sim.fun( )`函数就是专门用来解决这个问题的，你只要编写一个用来生成随机数的函数，然后剩下的工作就交给sim.fun来做。下面编写`泛式sim.fun函数（泛式是指函数是虚构的，这是R语言最强大的地方）`：
```python
sim.fun <- function (m,f,...)  # m为模拟样本次数，f为需模拟的函数
  {
    sample <- 1:m
    for (i in 1:m) {
        sample[i] <- f(...)
     }
     sample
 }
```
- (1)．二项分布：
如果要用二项分布来检验中心极限定理，需首先编写一个函数用来（以）生成一个二项分布随机数的标准化值。
	```python
	>f<-function(n=10,p=0.5)
	{s=rbinom(1,n,p);(s-n*p)/sqrt(n*p*(1-p)) }
	```
	该函数可以自定义设置参数n、p，n是f函数的第一个参数，其默认值为10，p是f函数的第二个参数，默认值为0.5。
	```python
	> x=sim.fun(1000,f)                
	 # 模拟1000个二项随机数
	> hist(x,prob=T)
	```
	![在这里插入图片描述](https://img-blog.csdnimg.cn/20190313112813411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
- (2)．均匀分布：如果要用均匀分布来检验中心极限定理，可直接用均匀随机数函数来生成一个均匀随机数的值。
	```python
	> f = function(n=10) (mean(runif(n)-1/2)/(1/sqrt(12*n))
	> x=sim.fun(1000,f)                 # 模拟1000个均匀随机数
	> hist(x,prob=T)
	```
	![在这里插入图片描述](https://img-blog.csdnimg.cn/20190313113031841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
- (3)．正态分布：下面将用编写函数的方法生成1000个服从正态分布的随机数的均值标准化变量，并用sim.fun( )函数模拟，然后用直方图分析这些标准化变量是否服从正态分布。
程序如下：
	```python
	>f=function(n=10,mu=0,sigma=1)
	{r=rnorm(n,mu,sigma);(mean(r)-mu)/(sigma/sqrt(n)) }
	> x = sim.fun(1000,f)  #模拟1000个样本量为10的N(0,1)随机数
	> hist(x,breaks=10,prob=T)
	 # 模拟1000个样本量为30的N(5,4)随机数
	> x = sim.fun(1000,f,30,5,2) 
	> hist(x,breaks=10,prob=T)
	```
	![在这里插入图片描述](https://img-blog.csdnimg.cn/20190313113337153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
- (4)．指数分布：下面举一个偏态分布的数据的例子，检验随着n的增大，其样本均值是否服从中心极限定理，不妨使用指数分布数据来模拟。下面首先编写函数生成均值和标准差都为10的指数分布数据（指数分布的 = =1/），并求样本均值标准化变量。
	```python
	> f <- function(n,mu=10)(mean(rexp(n,1/mu)-mu))/(mu/sqrt(n))
	```
	例4-9：接下来我们分别模拟n取1，5，10，30情况，假如每次生成的随机数都是100，并作直方图以及正态分布密度线。
`一页多图，首先设定par(), 例如  par(mfrow=c(2,3))`， 一个图版显示2行，3列。
程序如下：
	```python
	> x=seq(-3,3,0.01)
	> par(mfrow=c(2,2))
	> hist(sim.fun(100,f,1,10),prob=T,main="n=1")
	> points(x,dnorm(x,0,1),type="l")
	> hist(sim.fun(100,f,5,10),prob=T,main="n=5")
	> points(x,dnorm(x,0,1),type="l")
	> hist(sim.fun(100,f,10,10),prob=T,main="n=10")
	> points(x,dnorm(x,0,1),type="l")
	> hist(sim.fun(100,f,30,10),prob=T,main="n=30")
	> points(x,dnorm(x,0,1),type="l")
	```

	结果见图4-16，可见随着n的增大，样本均值所服从的分布越来越接近于正态分布。
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190313113359711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
