@[toc]

## 练习5-1 求m到n之和 (10分)

本题要求实现一个计算m~n（m<n）之间所有整数的和的简单函数。
函数接口定义：
```swift
int sum( int m, int n );
```
      
其中m和n是用户传入的参数，保证有m<n。函数返回的是m~n之间所有整数的和。
裁判测试程序样例：
```c
#include <stdio.h>

int sum(int m, int n);

int main()
{    
    int m, n;

    scanf("%d %d", &m, &n);
    printf("sum = %d\n", sum(m, n));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
        
      
    

输入样例：
```swift
-5 8
```
      
        
      
    

输出样例：
```swift
sum = 21
```

答案：
```c
int sum( int m, int n ) {
    int sum = 0;
    for (int i = m; i <= n; ++i) sum += i;
    return sum;
}
```

---
## 练习5-2 找两个数中最大者 (10分)

本题要求对两个整数a和b，输出其中较大的数。
函数接口定义：
```swift
int max( int a, int b );
```
      
        
      
    

其中a和b是用户传入的参数，函数返回的是两者中较大的数。
裁判测试程序样例：
```c
#include <stdio.h>

int max( int a, int b );

int main()
{    
    int a, b;

    scanf("%d %d", &a, &b);
    printf("max = %d\n", max(a, b));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
-5 8
```
      
        
      
    

输出样例：
```swift
max = 8
```

答案：
```cpp
int max( int a, int b ) {
    return a > b ? a : b;
}
```
---
## 练习5-3 数字金字塔 (15分)

本题要求实现函数输出n行数字金字塔。
函数接口定义：
```swift
void pyramid( int n );
```
      
        
      
    

其中n是用户传入的参数，为[1, 9]的正整数。要求函数按照如样例所示的格式打印出n行数字金字塔。注

意每个数字后面跟一个空格。
裁判测试程序样例：
```cpp
#include <stdio.h>

void pyramid( int n );

int main()
{    
    int n;

    scanf("%d", &n);
    pyramid(n);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
        
      
    

输入样例：
```swift
5
```
      
        
      
    

输出样例：
```swift
    1 
   2 2 
  3 3 3 
 4 4 4 4 
5 5 5 5 5 
```
答案：
```cpp
void pyramid( int n ) { 
    int spaceNum;
    for (int i = 1; i <= n; ++i) {
        spaceNum = n - i;
        for (int j = 0; j < spaceNum; ++j)
            printf(" ");
        for (int j = 0; j < i; ++j) 
            printf("%d ", i);
        printf("\n");
    }
}
```
---
## 习题5-1 符号函数 (10分)

本题要求实现符号函数sign(x)。
函数接口定义：
```swift
int sign( int x );
```
      
        
      
    

其中x是用户传入的整型参数。符号函数的定义为：若x大于0，sign(x) = 1；若x等于0，sign(x) = 0；否则，sign(x) = −1。
裁判测试程序样例：
```c
#include <stdio.h>

int sign( int x );

int main()
{
    int x;

    scanf("%d", &x);
    printf("sign(%d) = %d\n", x, sign(x));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
10
```
      
        
      
    

输出样例：
```swift
sign(10) = 1
```
答案：
```c
int sign( int x ) {
    return x > 0 ? 1 : x == 0 ? 0 : -1;
}
```
---
## 习题5-2 使用函数求奇数和 (15分)

本题要求实现一个函数，计算N个整数中所有奇数的和，同时实现一个判断奇偶性的函数。
函数接口定义：
```swift
int even( int n );
int OddSum( int List[], int N );
```
      
        
      
    

其中函数even将根据用户传入的参数n的奇偶性返回相应值：当n为偶数时返回1，否则返回0。函数OddSum负责计算并返回传入的N个整数List[]中所有奇数的和。
裁判测试程序样例：
```c
#include <stdio.h>

#define MAXN 10

int even( int n );
int OddSum( int List[], int N );

int main()
{    
    int List[MAXN], N, i;

    scanf("%d", &N);
    printf("Sum of ( ");
    for ( i=0; i<N; i++ ) {
        scanf("%d", &List[i]);
        if ( even(List[i])==0 )
            printf("%d ", List[i]);
    }
    printf(") = %d\n", OddSum(List, N));

    return 0;
}

/* 你的代码将被嵌在这里 */ 
```
        
      
    

输入样例：
```swift
6
2 -3 7 88 0 15 
```
        
      
    

输出样例：
```swift
Sum of ( -3 7 15 ) = 19
```
答案：
```cpp
int even( int n ) {
    return !(n & 1);
}
int OddSum( int List[], int N ) {
    int sum = 0; 
    for (int i = 0; i < N; ++i)
        if (!even(List[i]))
            sum += List[i];
    return sum;
}
```
---
## 习题5-3 使用函数计算两点间的距离 (10分)

本题要求实现一个函数，对给定平面任意两点坐标(x​1​​,y​1​​)和(x​2​​,y​2​​)，求这两点之间的距离。
函数接口定义：
```swift
double dist( double x1, double y1, double x2, double y2 );
```
      
        
      
    

其中用户传入的参数为平面上两个点的坐标(x1, y1)和(x2, y2)，函数dist应返回两点间的距离。
裁判测试程序样例：
```c
#include <stdio.h>
#include <math.h>

double dist( double x1, double y1, double x2, double y2 );

int main()
{    
    double x1, y1, x2, y2;

    scanf("%lf %lf %lf %lf", &x1, &y1, &x2, &y2);
    printf("dist = %.2f\n", dist(x1, y1, x2, y2));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
10 10 200 100
```
      
        
      
    

输出样例：
```swift
dist = 210.24
```
答案：
```c
double dist( double x1, double y1, double x2, double y2 ) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
```
---
## 习题5-4 使用函数求素数和 (20分)

本题要求实现一个判断素数的简单函数、以及利用该函数计算给定区间内素数和的函数。

素数就是只能被1和自身整除的正整数。注意：1不是素数，2是素数。
函数接口定义：
```swift
int prime( int p );
int PrimeSum( int m, int n ); 
```
        
      
    

其中函数prime当用户传入参数p为素数时返回1，否则返回0；函数PrimeSum返回区间[m, n]内所有素数的和。题目保证用户传入的参数m≤n。
裁判测试程序样例：
```c
#include <stdio.h>
#include <math.h>

int prime( int p );
int PrimeSum( int m, int n );

int main()
{
    int m, n, p;

    scanf("%d %d", &m, &n);
    printf("Sum of ( ");
    for( p=m; p<=n; p++ ) {
        if( prime(p) != 0 )
            printf("%d ", p);
    }
    printf(") = %d\n", PrimeSum(m, n));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
-1 10
```
      
        
      
    

输出样例：
```swift
Sum of ( 2 3 5 7 ) = 17
```
答案：
```c
int prime( int p ) {
    if (p < 2) return 0;
    int sqr = sqrt(1.0 * p);
    for (int i = 2; i <= sqr; ++i)
        if (p % i == 0) return 0;
    return 1;
}
int PrimeSum( int m, int n ) {
    int sum = 0;
    for (int i = m; i <= n; ++i) 
        if (prime(i)) 
            sum += i;
    return sum;
}
```
---
##  习题5-5 使用函数统计指定数字的个数 (15分)

本题要求实现一个统计整数中指定数字的个数的简单函数。
函数接口定义：
```swift
int CountDigit( int number, int digit );
```
      
        
      
    

其中number是不超过长整型的整数，digit为[0, 9]区间内的整数。函数CountDigit应返回number中digit出现的次数。
裁判测试程序样例：
```cpp
#include <stdio.h>

int CountDigit( int number, int digit );

int main()
{
    int number, digit;

    scanf("%d %d", &number, &digit);
    printf("Number of digit %d in %d: %d\n", digit, number, CountDigit(number, digit));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
-21252 2
```
      
        
      
    

输出样例：
```swift
Number of digit 2 in -21252: 3
```
答案：注意，**取余的结果的符号取决于被除数**，因此如果被除数是负数而digit是正数就可能出错。
```cpp
int CountDigit( int number, int digit ) {
    int cnt = 0;
    if (number < 0) number = -number;
    do {
        if (digit == number % 10) ++cnt;
        number /= 10;
    } while (number);
    return cnt;
}
```
---
## 习题5-6 使用函数输出水仙花数 (20分)

水仙花数是指一个**N**位正整数（N≥3），它的**每个位**上的数字的**N次幂之和**等于它本身。例如：153=1​3​​+5​3​​+3​3​​。 本题要求编写两个函数，一个判断给定整数是否水仙花数，另一个按从小到大的顺序打印出给定区间(m,n)内所有的水仙花数。
函数接口定义：
```swift
int narcissistic( int number );
void PrintN( int m, int n );
```
      
        
      
    

函数narcissistic判断number是否为水仙花数，是则返回1，否则返回0。

函数PrintN则打印开区间(m, n)内所有的水仙花数，每个数字占一行。题目保证`100≤m≤n≤10000`。
裁判测试程序样例：
```c
#include <stdio.h>

int narcissistic( int number );
void PrintN( int m, int n );

int main()
{
    int m, n;

    scanf("%d %d", &m, &n);
    if ( narcissistic(m) ) printf("%d is a narcissistic number\n", m);
    PrintN(m, n);
    if ( narcissistic(n) ) printf("%d is a narcissistic number\n", n);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
153 400
```
      
        
      
    

输出样例：
```swift
153 is a narcissistic number
370
371
```
答案：注意，是N位数，每位数的N次幂之和。
```c
int narcissistic( int number ) {
    int a[10], len = 0, n = number;
    do {
        a[len++] = number % 10;
        number /= 10;
    } while (number);
    int sum = 0;
    for (int i = 0; i < len; ++i) 
        sum += (int)pow(a[i], len);
    if (sum == n) return 1;
    return 0;
}

void PrintN( int m, int n ) {
    for (int i = m + 1; i < n; ++i) 
        if (narcissistic(i)) 
            printf("%d\n", i);
}
```
---
## 习题5-7 使用函数求余弦函数的近似值 (15分)

本题要求实现一个函数，用下列公式求cos(x)的近似值，精确到最后一项的绝对值小于e：

$$cos(x)=x​0​​/0!−x​2​​/2!+x​4​​/4!−x​6​​/6!+⋯$$
函数接口定义：
```swift
double funcos( double e, double x );
```
      
        
      
    

其中用户传入的参数为误差上限e和自变量x；函数funcos应返回用给定公式计算出来、并且满足误差要求的cos(x)的近似值。输入输出**均在双精度范围内**。
裁判测试程序样例：
```c
#include <stdio.h>
#include <math.h>

double funcos( double e, double x );

int main()
{    
    double e, x;

    scanf("%lf %lf", &e, &x);
    printf("cos(%.2f) = %.6f\n", x, funcos(e, x));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
0.01 -3.14
```
      
        
      
    

输出样例：
```swift
cos(-3.14) = -0.999899
```
答案：
```c
double funcos( double e, double x ) { 
    double ans = 1, term = ans;
	double xx = 1, down = 1, d = 0;
	double f = -1; 
    while (fabs(term) >= e) {
        xx *= (x * x);
        down *= (d + 1) * (d + 2);
        term = f * xx / down;
        ans += term;
        f *= (-1);
        d += 2;
    }
    return ans;
}
```
---
##  习题6-1 分类统计字符个数 (15分)

本题要求实现一个函数，统计给定字符串中英文字母、空格或回车、数字字符和其他字符的个数。
函数接口定义：
```swift
void StringCount( char s[] );
```
      
        
      
    

其中 char s[] 是用户传入的字符串。函数StringCount须在一行内按照
```swift
letter = 英文字母个数, blank = 空格或回车个数, digit = 数字字符个数, other = 其他字符个数
```
的格式输出。
裁判测试程序样例：
```c
#include <stdio.h>
#define MAXS 15

void StringCount( char s[] );
void ReadString( char s[] ); /* 由裁判实现，略去不表 */

int main()
{
    char s[MAXS];

    ReadString(s);
    StringCount(s);

    return 0;
}

/* Your function will be put here */
```
      
        
      
    

输入样例：
```swift
aZ &
09 Az
```
       

输出样例：
```swift
letter = 4, blank = 3, digit = 2, other = 1
```
答案：ctype.h中有许多这些函数，需要记住。不然自己判断就有点麻烦。**空格字符isspace和空白字符isblank不同**，	空格字符：**水平制表符**、换行符、**垂直制表符**、换页符、回车符、**空格符**的集合。空白字符：包括空格符和制表符。
```c
#include <ctype.h>
void StringCount( char s[] ) {
    int letter, blank, digit, other;
    letter = blank = digit = other = 0;
    for (int i = 0; s[i]; ++i) {
        if (isalpha(s[i])) ++letter;
        else if (isspace(s[i])) ++blank;
        else if (isdigit(s[i])) ++digit;
        else ++other;
    }
    printf("letter = %d, blank = %d, digit = %d, other = %d", letter, blank, digit, other); 
}
```
---
## 习题6-2 使用函数求特殊a串数列和 (20分)

给定两个均不超过9的正整数a和n，要求编写函数求a+aa+aaa++⋯+aa⋯a（n个a）之和。
函数接口定义：
```swift
int fn( int a, int n );
int SumA( int a, int n );
```
      
        
      
    

其中函数fn须返回的是n个a组成的数字；SumA返回要求的和。
裁判测试程序样例：
```c
#include <stdio.h>

int fn( int a, int n );
int SumA( int a, int n );
	
int main()
{
    int a, n;

    scanf("%d %d", &a, &n);
    printf("fn(%d, %d) = %d\n", a, n, fn(a,n));		
    printf("s = %d\n", SumA(a,n));	
	
    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
2 3
```
      
        
      
    

输出样例：
```swift
fn(2, 3) = 222
s = 246
```
答案：这种题做过很多次，不过这里的简单，只有这么几位数。
```c
int fn( int a, int n ) {
    int sum = 0;
    for (int i = 0; i < n; ++i) {
        sum = sum * 10 + a;
    }
    return sum;
}
int SumA( int a, int n ) {
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        ans += fn(a, i);
    }
    return ans;
}
```
---
## 习题6-3 使用函数输出指定范围内的完数 (20分)

本题要求实现一个计算整数因子和的简单函数，并利用其实现另一个函数，输出两正整数m和n（0<m≤n≤10000）之间的所有完数。所谓完数就是该数恰好等于除自身外的因子之和。例如：6=1+2+3，其中1、2、3为6的因子。
函数接口定义：
```swift
int factorsum( int number );
void PrintPN( int m, int n ); 
```

其中函数factorsum须返回int number的因子和；函数PrintPN要逐行输出给定范围[m, n]内每个完数的因子累加形式的分解式，每个完数占一行，格式为“完数 = 因子1 + 因子2 + ... + 因子k”，其中完数和因子均按递增顺序给出。如果给定区间内没有完数，则输出一行“No perfect number”。
裁判测试程序样例：
```c
#include <stdio.h>

int factorsum( int number );
void PrintPN( int m, int n );
	
int main()
{
    int i, m, n;

    scanf("%d %d", &m, &n);
    if ( factorsum(m) == m ) printf("%d is a perfect number\n", m);
    if ( factorsum(n) == n ) printf("%d is a perfect number\n", n);
    PrintPN(m, n);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例1：
```swift
1 30
```
输出样例1：
```swift
1 is a perfect number
1 = 1
6 = 1 + 2 + 3
28 = 1 + 2 + 4 + 7 + 14
```
输入样例2：
```swift
7 25
```
输出样例2：
```swift
No perfect number
```
答案：注意，1是完数，其他的数只需算到number/2就可以了。
```cpp
int factorsum( int number ) {
    if (number == 1) return 1;
    int sum = 0;
    for (int i = 1; i <= number / 2; ++i) 
        if (number % i == 0) 
            sum += i;
    return sum;
}

void PrintPN( int m, int n ) {
    int cnt = 0; // 完数的个数
    for (int i = m; i <= n; ++i) {
        int a[1000], len = 0; // 存储因子
        if (i == 1) {
            ++cnt;
            printf("1 = 1\n");
        } else if (factorsum(i) == i) {
            ++cnt;
            printf("%d =", i); 
            for (int j = 1; j <= i / 2; ++j) // 求因子集合
                if (i % j == 0) 
                    a[len++] = j;
            for (int k = 0; k < len - 1; ++k)
                printf(" %d +", a[k]); 
            printf(" %d\n", a[len - 1]);
        }
    }
    if (!cnt) printf("No perfect number");
}
```
---
## 习题6-4 使用函数输出指定范围内的Fibonacci数 (20分)

本题要求实现一个计算Fibonacci数的简单函数，并利用其实现另一个函数，输出两正整数m和n（0<m≤n≤10000）之间的所有Fibonacci数。所谓Fibonacci数列就是满足任一项数字是前两项的和（**最开始两项均定义为1**）的数列。
函数接口定义：
```swift
int fib( int n );
void PrintFN( int m, int n );
```
      
        
      
    

其中函数fib须返回**第n项**Fibonacci数；函数PrintFN要在一行中输出给定范围[m, n]内的**所有Fibonacci数**，相邻数字间有一个空格，行末不得有多余空格。如果给定区间内没有Fibonacci数，则输出一行“No Fibonacci number”。
裁判测试程序样例：
```c
#include <stdio.h>

int fib( int n );
void PrintFN( int m, int n );
	
int main()
{
    int m, n, t;

    scanf("%d %d %d", &m, &n, &t);
    printf("fib(%d) = %d\n", t, fib(t));
    PrintFN(m, n);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例1：
```swift
20 100 7
```
      
        
      
    

输出样例1：
```swift
fib(7) = 13
21 34 55 89
```
      
        
      
    

输入样例2：
```swift
2000 2500 8
```
      
        
      
    

输出样例2：
```swift
fib(8) = 21
No Fibonacci number
```
答案：斐波拉契数越往后越大，第10000项绝对超过了整形范围。
```c
int fib( int n ) {
    if (n == 1 || n == 2) return 1;
    int first = 1, second = 1, ans;
    for (int i = 3; i <= n; ++i) {
        ans = first + second; 
        first = second;
        second = ans;
    }
    return ans;
}

void PrintFN( int m, int n ) {
    int res[10000], size = 0, i = 1;
    while (fib(i) < m) ++i;
    while (fib(i) <= n) {
        res[size++] = fib(i);
        ++i;
    }
    if (size == 0) printf("No Fibonacci number");
    else {
        for (int i = 0; i < size - 1; ++i) 
            printf("%d ", res[i]);
        printf("%d", res[size - 1]);
    }
}
```
---
## 习题6-5 使用函数验证哥德巴赫猜想 (20分)

本题要求实现一个**判断素数**的简单函数，并利用该函数验证哥德巴赫猜想：任何一个**不小于6的偶数**均可表示为**两个奇素数之和**。素数就是只能被1和自身整除的正整数。注意：1不是素数，2是素数。
函数接口定义：
```swift
int prime( int p );
void Goldbach( int n );
```
       
其中函数prime当用户传入参数p为素数时返回1，否则返回0；函数Goldbach按照格式“n=p+q”输出n的素数分解，其中p≤q均为素数。又因为这样的分解不唯一（例如24可以分解为5+19，还可以分解为7+17），要求必须输出所有解中p最小的解。
裁判测试程序样例：
```c
#include <stdio.h>
#include <math.h>

int prime( int p );
void Goldbach( int n );

int main()
{
    int m, n, i, cnt;

    scanf("%d %d", &m, &n);
    if ( prime(m) != 0 ) printf("%d is a prime number\n", m);
    if ( m < 6 ) m = 6;
    if ( m%2 ) m++;
    cnt = 0;
    for( i=m; i<=n; i+=2 ) {
        Goldbach(i);
        cnt++;
        if ( cnt%5 ) printf(", ");
        else printf("\n");
    }

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例：
```swift
89 100
```

输出样例：
```swift
89 is a prime number
90=7+83, 92=3+89, 94=5+89, 96=7+89, 98=19+79
100=3+97, 
```
答案：判断是否是素数时可以将除了2以外的偶数先排除，可以降低一定的复杂度。
```c
int prime( int p ) {
    if (p < 2) return 0;
    if (p == 2) return 1;
    if (!(p & 1)) return 0; // 偶数
    int sqr = sqrt(p);
    for (int i = 2; i <= sqr; ++i) 
        if (p % i == 0) return 0;
    return 1;
}
void Goldbach( int n ) {
    for (int i = 2; i < n; ++i) {
        int j = n - i;
        if (prime(i) && prime(j)) {
            printf("%d=%d+%d", n, i, j);
            return;
        }
    }
}
```
---
## 习题6-6 使用函数输出一个整数的逆序数 (20分)

本题要求实现一个**求整数的逆序数**的简单函数。函数接口定义：
```swift
int reverse( int number );
```
其中函数reverse须返回用户传入的整型number的逆序数。裁判测试程序样例：
```c
#include <stdio.h>

int reverse( int number );

int main()
{
    int n;

    scanf("%d", &n);
    printf("%d\n", reverse(n));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
-12340
```
      
        
      
    

输出样例：
```swift
-4321
```
答案：数字末尾的连续几个0逆转后消失，要注意。
```c
int reverse( int number ) {
    int ans = 0;
    do {
        ans = ans * 10 + number % 10;
        number /= 10;
    } while (number);
    return ans;
}
```
---
## 练习8-2 计算两数的和与差 (10分)

本题要求实现一个计算输入的两数的**和与差**的简单函数。
函数接口定义：
```swift
void sum_diff( float op1, float op2, float *psum, float *pdiff );
```

其中op1和op2是输入的两个实数，*psum和*pdiff是计算得出的和与差。
裁判测试程序样例：
```c
#include <stdio.h>

void sum_diff( float op1, float op2, float *psum, float *pdiff );

int main()
{
    float a, b, sum, diff;

    scanf("%f %f", &a, &b);
    sum_diff(a, b, &sum, &diff);
    printf("The sum is %.2f\nThe diff is %.2f\n", sum, diff);
	
    return 0; 
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
4 6
```
      
        
      
    

输出样例：
```swift
The sum is 10.00
The diff is -2.00
```
答案：估计是考察指针的使用吧。
```c
void sum_diff( float op1, float op2, float *psum, float *pdiff ) {
    *psum = op1 + op2;
    *pdiff = op1 - op2;
}
```
---
## 练习8-8 移动字母 (10分)

本题要求编写函数，将输入字符串的前3个字符移到最后。
函数接口定义：
```swift
void Shift( char s[] );
```
其中char s[]是用户传入的字符串，题目保证其长度不小于3；函数Shift须将按照要求变换后的字符串仍然存在s[]里。
裁判测试程序样例：
```c
#include <stdio.h>
#include <string.h>

#define MAXS 10

void Shift( char s[] );

void GetString( char s[] ); /* 实现细节在此不表 */

int main()
{
    char s[MAXS];

    GetString(s);
    Shift(s);
    printf("%s\n", s);
	
    return 0; 
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
abcdef
```
      
        
      
    

输出样例：
```swift
defabc
```
答案：做过很多次的套路了。
```c
void Shift( char s[] ) {
    reverse(s, 0, 2);
    reverse(s, 3, strlen(s) - 1);
    reverse(s, 0, strlen(s) - 1);
}

void reverse(char s[], int b, int e) {
    for (; b < e; ++b, --e) {
        char c = s[b];
        s[b] = s[e];
        s[e] = c;
    }
}
```
---
## 习题8-1 拆分实数的整数与小数部分 (15分)

本题要求实现一个拆分实数的整数与小数部分的简单函数。
函数接口定义：
```swift
void splitfloat( float x, int *intpart, float *fracpart );
```
       

其中x是被拆分的实数（0≤x<10000），*intpart和*fracpart分别是将实数x拆分出来的整数部分与小数部分。
裁判测试程序样例：
```c
#include <stdio.h>

void splitfloat( float x, int *intpart, float *fracpart );

int main()
{
    float x, fracpart;
    int intpart;

    scanf("%f", &x);
    splitfloat(x, &intpart, &fracpart);
    printf("The integer part is %d\n", intpart);
    printf("The fractional part is %g\n", fracpart);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
      
        
      
    

输入样例：
```swift
2.718
```
       
输出样例：
```swift
The integer part is 2
The fractional part is 0.718
```
答案：考察指针的使用。
```c
void splitfloat( float x, int *intpart, float *fracpart ) {
    int t = x;
    *intpart = t;
    *fracpart = x - t;
}
```
---
## 习题8-2 在数组中查找指定元素 (15分)

本题要求实现一个在数组中查找指定元素的简单函数。
函数接口定义：
```swift
int search( int list[], int n, int x );
```
       
其中list[]是用户传入的数组；n（≥0）是list[]中元素的个数；x是待查找的元素。如果找到

则函数search返回相应元素的最小下标（下标从0开始），否则返回−1。
裁判测试程序样例：
```c
#include <stdio.h>
#define MAXN 10

int search( int list[], int n, int x );

int main()
{
    int i, index, n, x;
    int a[MAXN];

    scanf("%d", &n);
    for( i = 0; i < n; i++ )
        scanf("%d", &a[i]);
    scanf("%d", &x);
    index = search( a, n, x );
    if( index != -1 )
        printf("index = %d\n", index);
    else
        printf("Not found\n");

    return 0;
}

/* 你的代码将被嵌在这里 */
```
       

输入样例1：
```swift
5
1 2 2 5 4
2
```

输出样例1：
```swift
index = 1
```
       

输入样例2：
```swift
5
1 2 2 5 4
0
```
输出样例2：
```swift
Not found
```
答案：顺序查找，简单。
```c
int search( int list[], int n, int x ) {
    for (int i = 0; i < n; ++i) 
        if (list[i] == x) return i;
    return -1;
}
```
---
## 习题8-3 数组循环右移 (20分)

本题要求实现一个对数组进行循环右移的简单函数：一个数组a中存有n（>0）个整数，将每个整数循环向右移m（≥0）个位置，即将a中的数据由（a​0​​a​1​​⋯a​n−1​​）变换为（a​n−m​​⋯a​n−1​​a​0​​a​1​​⋯a​n−m−1​​）（最后m个数循环移至最前面的m个位置）。
函数接口定义：
```swift
int ArrayShift( int a[], int n, int m );
```
其中a[]是用户传入的数组；n是数组的大小；m是右移的位数。函数ArrayShift须将循环右移后的数组仍然存在a[]中。
裁判测试程序样例：
```c
#include <stdio.h>
#define MAXN 10

int ArrayShift( int a[], int n, int m );

int main()
{
    int a[MAXN], n, m;
    int i;

    scanf("%d %d", &n, &m);
    for ( i = 0; i < n; i++ ) scanf("%d", &a[i]);

    ArrayShift(a, n, m);

    for ( i = 0; i < n; i++ ) {
        if (i != 0) printf(" ");
        printf("%d", a[i]);
    }
    printf("\n");

    return 0;
}

/* 你的代码将被嵌在这里 */
```
       
输入样例：
```swift
6 2
1 2 3 4 5 6
```
       
输出样例：
```swift
5 6 1 2 3 4
```
答案：老套路了。
```cpp
void reverse(int a[], int b, int e) {
    for (; b < e; ++b, --e) {
        int t = a[b]; a[b] = a[e]; a[e] = t;
    }
}

int ArrayShift( int a[], int n, int m ) {
    if (m > n) m = m % n;
    int k = n - m;
    reverse(a, 0, k - 1);
    reverse(a, k, n - 1);
    reverse(a, 0, n - 1);
    return 0;
}
```
---
##  习题8-4 报数 (20分) 

报数游戏是这样的：有n个人围成一圈，按顺序从1到n编好号。从第一个人开始报数，报到m（<n）的人退出圈子；下一个人从1开始报数，报到m的人退出圈子。如此下去，直到留下最后一个人。

本题要求编写函数，给出每个人的退出顺序编号。
函数接口定义：
```c
void CountOff( int n, int m, int out[] );
```
其中n是初始人数；m是游戏规定的退出位次（保证为小于n的正整数）。函数CountOff将每个人的退出顺序编号存在数组out[]中。因为C语言数组下标是从0开始的，所以第i个位置上的人是第out[i-1]个退出的。
裁判测试程序样例：
```c
#include <stdio.h>
#define MAXN 20

void CountOff( int n, int m, int out[] );

int main()
{
    int out[MAXN], n, m;
    int i;

    scanf("%d %d", &n, &m);
    CountOff( n, m, out );   
    for ( i = 0; i < n; i++ )
        printf("%d ", out[i]);
    printf("\n");

    return 0;
}

/* 你的代码将被嵌在这里 */
```
       
输入样例：
```swift
11 3
```

输出样例：
```swift
4 10 1 7 5 2 11 9 3 6 8 
```
答案：需要注意的是，每个人的退出顺序编号存在数组out[]中，即3是第一个退出，那么out[3-1]=1。这一点有点烦。这里采用的是普通的静态数组+实际删除的操作。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200215205345538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
```c
void Delete(int a[], int t, int n) {
	for (int i = t; i < n - 1; ++i) 
		a[i] = a[i + 1];
}

void CountOff( int n, int m, int out[] ) {
	int arr[n], len = 0;
	for (int i = 0; i < n; ++i) arr[i] = i + 1;
	int pos = 0;
	while (n) {
		pos = (pos + m - 1) % n; 
		out[arr[pos] - 1] = ++len; // 保存退出的顺序编号 
		Delete(arr, pos, n); 
        n--;
	}
} 
```

----
## 习题8-5 使用函数实现字符串部分复制 (20分)

本题要求编写函数，将输入字符串t中从第m个字符开始的全部字符复制到字符串s中。
函数接口定义：
```swift
void strmcpy( char *t, int m, char *s );
```
函数strmcpy将输入字符串char *t中从**第m个字符**开始的**全部字符**复制到字符串char *s中。若m超过输入字符串的长度，则结果字符串**应为空串**。
裁判测试程序样例：
```c
#include <stdio.h>
#define MAXN 20

void strmcpy( char *t, int m, char *s );
void ReadString( char s[] ); /* 由裁判实现，略去不表 */

int main()
{
    char t[MAXN], s[MAXN];
    int m;

    scanf("%d\n", &m);
    ReadString(t);
    strmcpy( t, m, s );
    printf("%s\n", s);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
       

输入样例：
```swift
7
happy new year
```
       
输出样例：
```swift
new year
```
答案：注意判断m是否在区间内，m是第几个。
```cpp
#include <string.h>
void strmcpy( char *t, int m, char *s ) {
    if (m <= strlen(t)) {
        char *k = t + m - 1;
        while (*k) {
            *s = *k;
            ++s, ++k;
        }
    }
    *s = '\0';
}
```
---
## 习题8-6 删除字符 (20分)

本题要求实现一个删除字符串中的指定字符的简单函数。
函数接口定义：
```swift
void delchar( char *str, char c );
```

其中char *str是传入的字符串，c是待删除的字符。函数delchar的功能是将字符串str中**出现的所有c字符删除**。
裁判测试程序样例：
```c
#include <stdio.h>
#define MAXN 20

void delchar( char *str, char c );
void ReadString( char s[] ); /* 由裁判实现，略去不表 */

int main()
{
    char str[MAXN], c;

    scanf("%c\n", &c);
    ReadString(str);
    delchar(str, c);
    printf("%s\n", str);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
       
输入样例：
```swift
a
happy new year
```
输出样例：
```swift
hppy new yer
```
答案：要删除所有的字符，就是让该字符后续的字符往前覆盖。
```cpp
void delchar( char *str, char c ) {
    int i = 0;
    while (str[i]) {
        if (str[i] == c) {
            for (int j = i; str[j]; ++j) // 删除这个字符
                str[j] = str[j + 1]; 
        } else ++i;
    }
}
```
---
## 习题8-8 判断回文字符串 (20分)

本题要求编写函数，判断给定的一串字符是否为“回文”。所谓“回文”是指顺读和倒读都一样的字符串。如“XYZYX”和“xyzzyx”都是回文。
函数接口定义：
```swift
bool palindrome( char *s );
```

函数palindrome判断输入字符串char *s是否为回文。若是则返回true，否则返回false。
裁判测试程序样例：
```c
#include <stdio.h>
#include <string.h>

#define MAXN 20
typedef enum {false, true} bool;

bool palindrome( char *s );

int main()
{
    char s[MAXN];

    scanf("%s", s);
    if ( palindrome(s)==true )
        printf("Yes\n");
    else
        printf("No\n");
    printf("%s\n", s);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
       
输入样例1：
```swift
thisistrueurtsisiht
```

输出样例1：
```swift
Yes
thisistrueurtsisiht
```
       
输入样例2：
```swift
thisisnottrue
```

输出样例2：
```swift
No
thisisnottrue
```
答案：简单。
```c
bool palindrome( char *s ) {
    char *t = s;
    while (*t) ++t;
    --t;
    for (; s < t; ++s, --t) 
        if (*s != *t) 
            return false;
    return true;
}
```
---
## 习题8-9 分类统计各类字符个数 (15分)

本题要求实现一个函数，统计给定字符串中的大写字母、小写字母、空格、数字以及其它字符各有多少。函数接口定义：
```swift
void StringCount( char *s );
```
其中 `char *s` 是用户传入的字符串。函数StringCount须在一行内按照
```swift
大写字母个数 小写字母个数 空格个数 数字个数 其它字符个数
```
的格式输出。裁判测试程序样例：
```c
#include <stdio.h>
#define MAXS 15

void StringCount( char *s );
void ReadString( char *s ); /* 由裁判实现，略去不表 */

int main()
{
    char s[MAXS];

    ReadString(s);
    StringCount(s);

    return 0;
}

/* Your function will be put here */
```
       

输入样例：
```swift
aZ&*?
093 Az
```
输出样例：
```swift
2 2 1 3 4
```
答案：到了复习ctype.h的时候了，如果这里计算空白符用的是isspace，会有两个测试点错误，换成isblank就全对。看了看示例，发现是【空白】符，所以应该用blank。

两者的区别在于 
>    isblank() 专指那些用来**分割一行文本**中的单词（文字）的空白符，不能换行换页，或者有其它特殊效果。在默认的情况下，C语言一般使用 ASCII 编码，这样的空白符只有空格' '和水平制表符'\t'。
    isspace() 没有这些要求，它指代所有的空白符，在 ASCII 编码中，这样的空白符包括空格' '、水平制表符'\t'、换行符'\n'、垂直制表符'\v'、换页'\f'以及回车'\r'。
也就是说，isblank() 所指的空白符是 isspace() 的一个子集。

题目给出的样例中，发现换行符被算到了其他字符中了，也说明应该用isblank。
```c
#include <ctype.h> 
void StringCount( char *s ) {
    int u, l, sp, n, o;
    u = l = sp = n = o = 0;
    for (; *s; ++s) {
        if (isupper(*s)) ++u;
        else if (islower(*s)) ++l;
        else if (isblank(*s)) ++sp;
        else if (isdigit(*s)) ++n;
        else ++o;
    }
    printf("%d %d %d %d %d", u, l, sp, n, o);
}
```
---
## 习题9-2 计算两个复数之积 (15分)

本题要求实现一个计算复数之积的简单函数。
函数接口定义：
```c
struct complex multiply(struct complex x, struct complex y);
```
其中struct complex是复数结构体，其定义如下：
```c
struct complex{
    int real;
    int imag;
};
```
裁判测试程序样例：
```c
#include <stdio.h>

struct complex{
    int real;
    int imag;
};

struct complex multiply(struct complex x, struct complex y);

int main()
{
    struct complex product, x, y;

    scanf("%d%d%d%d", &x.real, &x.imag, &y.real, &y.imag);
    product = multiply(x, y);
    printf("(%d+%di) * (%d+%di) = %d + %di\n", 
            x.real, x.imag, y.real, y.imag, product.real, product.imag);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例：
```swift
3 4 5 6
```
输出样例：
```swift
(3+4i) * (5+6i) = -9 + 38i
```
答案：
```c
struct complex multiply(struct complex x, struct complex y) {
    struct complex ans;
    ans.real = x.real * y.real - x.imag * y.imag;
    ans.imag = x.real * y.imag + x.imag * y.real;
    return ans;
}
```
---
## 习题9-6 按等级统计学生成绩 (20分)

本题要求实现一个根据学生成绩设置其等级，并统计不及格人数的简单函数。
函数接口定义：
```swift
int set_grade( struct student *p, int n );
```
其中p是指向学生信息的结构体数组的指针，该结构体的定义为：
```c
struct student{
    int num;
    char name[20];
    int score;
    char grade;
};
```
n是数组元素个数。学号num、姓名name和成绩score均是已经存储好的。set_grade函数需要根据学生的成绩score设置其等级grade。等级设置：85－100为A，70－84为B，60－69为C，0－59为D。同时，set_grade还需要返回不及格的人数。

裁判测试程序样例：
```c
#include <stdio.h>
#define MAXN 10

struct student{
    int num;
    char name[20];
    int score;
    char grade;
};

int set_grade( struct student *p, int n );

int main()
{   struct student stu[MAXN], *ptr;
    int n, i, count;

    ptr = stu;
    scanf("%d\n", &n);
    for(i = 0; i < n; i++){
       scanf("%d%s%d", &stu[i].num, stu[i].name, &stu[i].score);
    } 
   count = set_grade(ptr, n);
   printf("The count for failed (<60): %d\n", count);
   printf("The grades:\n"); 
   for(i = 0; i < n; i++)
       printf("%d %s %c\n", stu[i].num, stu[i].name, stu[i].grade);
    return 0;
}

/* 你的代码将被嵌在这里 */
```

输入样例：
```swift
10
31001 annie 85
31002 bonny 75
31003 carol 70
31004 dan 84
31005 susan 90
31006 paul 69
31007 pam 60
31008 apple 50
31009 nancy 100
31010 bob 78
```

输出样例：
```swift
The count for failed (<60): 1
The grades:
31001 annie A
31002 bonny B
31003 carol B
31004 dan B
31005 susan A
31006 paul C
31007 pam C
31008 apple D
31009 nancy A
31010 bob B
```
答案：
```cpp
int set_grade( struct student *p, int n ) {
    int num = 0; // 不及格人数
    for (int i = 0; i < n; ++i) {
        if (p[i].score >= 85) p[i].grade = 'A';
        else if (p[i].score >= 70) p[i].grade = 'B';
        else if (p[i].score >= 60) p[i].grade = 'C';
        else {
            p[i].grade = 'D';
            ++num;
        }
    }
    return num;
}
```
---
## 练习10-1 使用递归函数计算1到n之和 (10分)

本题要求实现一个用递归计算1+2+3+…+n的和的简单函数。
函数接口定义：
```swift
int sum( int n );
```

该函数对于传入的正整数n返回1+2+3+…+n的和；**若n不是正整数则返回0**。题目保证输入输出在长整型范围内。建议尝试写成递归函数。

裁判测试程序样例：
```c
#include <stdio.h>

int sum( int n );

int main()
{
    int n;

    scanf("%d", &n);
    printf ("%d\n", sum(n));

    return 0;
}

/* 你的代码将被嵌在这里 */
```

输入样例1：
```swift
10
```
       
输出样例1：
```swift
55
```

输入样例2：
```swift
0
```

输出样例2：
```swift
0
```
答案：
```cpp
int sum( int n ) {
    if (n == 1) return 1;
    if (n <= 0) return 0;
    return n + sum(n - 1);
}
```
---
## 习题10-1 判断满足条件的三位数 (15分)

本题要求实现一个函数，统计给定区间内的三位数中有两位数字相同的完全平方数（如144、676）的个数。
函数接口定义：
```swift
int search( int n );
```
其中传入的参数int n是一个三位数的正整数（最高位数字非0）。函数search返回[101, n]区间内所有满足条件的数的个数。
裁判测试程序样例：
```c
#include <stdio.h>
#include <math.h>

int search( int n );

int main()
{
    int number;

    scanf("%d",&number);
    printf("count=%d\n",search(number));
		
    return 0;
}


/* 你的代码将被嵌在这里 */
```
       
输入样例：
```swift
500
```

输出样例：
```swift
count=6
```
答案：注意完全平方数。
```c
int search( int n ) {
    // 三位数中有两位数字相同的完全平方数
    int ans = 0;
    for (int i = 101; i <= n; ++i) {
        int a = i % 10, b = i / 10 % 10, c = i / 100;
        if (a == b || b == c || a == c) {
            int sqr = sqrt(i);
            if (sqr * sqr == i) ++ans;
        }
    }
    return ans;
}
```
---
## 习题10-2 递归求阶乘和 (15分)

本题要求实现一个计算非负整数阶乘的简单函数，并利用该函数求 1!+2!+3!+...+n! 的值。
函数接口定义：
```swift
double fact( int n );
double factsum( int n );
```

函数fact应返回n的阶乘，建议用递归实现。函数factsum应返回 1!+2!+...+n! 的值。题目保证输入输出在双精度范围内。
裁判测试程序样例：
```c
#include <stdio.h>

double fact( int n );
double factsum( int n );

int main()
{
    int n;

    scanf("%d",&n);
    printf("fact(%d) = %.0f\n", n, fact(n));
    printf("sum = %.0f\n", factsum(n));
		
    return 0;
}

/* 你的代码将被嵌在这里 */
```

输入样例1：
```swift
10
```
输出样例1：
```swift
fact(10) = 3628800
sum = 4037913
```
输入样例2：
```swift
0
```

输出样例2：
```swift
fact(0) = 1
sum = 0
```
答案：
```cpp
double fact( int n ) {
    if (n <= 1) return 1;
    return n * fact(n - 1);
}
double factsum( int n ) {
    double ans = 0;
    for (int i = 1; i <= n; ++i) {
        ans += fact(i);
    }
    return ans;
}
```
---
## 习题10-3 递归实现指数函数 (15分)

本题要求实现一个计算x​n​​（n≥1）的函数。
函数接口定义：
```swift
double calc_pow( double x, int n );
```
函数calc_pow应返回x的n次幂的值。建议用递归实现。题目保证结果在双精度范围内。
裁判测试程序样例：
```c
#include <stdio.h>

double calc_pow( double x, int n );

int main()
{
    double x;
    int n;

    scanf("%lf %d", &x, &n);
    printf("%.0f\n", calc_pow(x, n));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例：
```swift
2 3
```

输出样例：
```swift
8
```
答案：快速幂模板。
```c
double calc_pow( double x, int n ) { // 快速幂
    double ans = 1;
    while (n) {
        if (n & 1) ans *= x;
        x *= x;
        n >>= 1;
    }
    return ans;
}
```
----
## 习题10-4 递归求简单交错幂级数的部分和 (15分)

本题要求实现一个函数，计算下列简单交错幂级数的部分和：
```swift
f(x,n)=x−x​2​​+x​3​​−x​4​​+⋯+(−1)​n−1​​x​n​​
```

函数接口定义：
```c
double fn( double x, int n );
```

其中题目保证传入的n是正整数，并且输入输出都在双精度范围内。函数fn应返回上述级数的部分和。建议尝试用递归实现。
裁判测试程序样例：
```c
#include <stdio.h>

double fn( double x, int n );

int main()
{
    double x;
   int n;

    scanf("%lf %d", &x, &n);
    printf("%.2f\n", fn(x,n));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
       
输入样例：
```c
0.5 12
```
输出样例：
```c
0.33
```
答案：没有用递归，麻烦。
```c
double fn( double x, int n ) {
    double ans = 0, ne = 1, xx = x;
    for (int i = 1; i <= n; ++i) { 
        ans += ne * xx;
        xx *= x;
        ne *= -1;
    }
    return ans;
}
```
---
## 习题10-5 递归计算Ackermenn函数 (15分)

本题要求实现Ackermenn函数的计算，其函数定义如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216010348101.png)
函数接口定义：
```c
int Ack( int m, int n );
```

其中m和n是用户传入的非负整数。函数Ack返回Ackermenn函数的相应值。题目保证输入输出都在长整型范围内。

裁判测试程序样例：
```c
#include <stdio.h>

int Ack( int m, int n );

int main()
{
    int m, n;

    scanf("%d %d", &m, &n);
    printf("%d\n", Ack(m, n));

    return 0;
}

/* 你的代码将被嵌在这里 */
```

输入样例：
```c
2 3
```
输出样例：
```c
9
```
答案：照葫芦画瓢即可。
```c
int Ack( int m, int n ) {
    if (m == 0) return n + 1;
    else if (n == 0 && m > 0) return Ack(m - 1, 1);
    else if (m > 0 && n > 0) return Ack(m - 1, Ack(m, n - 1));
}
```
---
## 习题10-6 递归求Fabonacci数列 (10分)

本题要求实现求Fabonacci数列项的函数。Fabonacci数列的定义如下：`f(n)=f(n−2)+f(n−1) (n≥2)`，其中**f(0)=0，f(1)=1**。

函数接口定义：
```c
int f( int n );
```
函数f应返回第n个Fabonacci数。题目保证输入输出在长整型范围内。建议用递归实现。

裁判测试程序样例：
```c
#include <stdio.h>

int f( int n );

int main()
{
    int n;

    scanf("%d", &n);
    printf("%d\n", f(n));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
       

输入样例：
```c
6
```

输出样例：
```c
8
```
答案：
```c
int f( int n ) {
    if (n <= 1) return n;
    return f(n - 1) + f(n - 2);
}
```
---
## 习题10-7 十进制转换二进制 (15分)

本题要求实现一个函数，将正整数n转换为二进制后输出。

函数接口定义：
```c
void dectobin( int n );
```
函数dectobin应在一行中打印出二进制的n。建议用递归实现。

裁判测试程序样例：
```c
#include <stdio.h>

void dectobin( int n );

int main()
{
    int n;

    scanf("%d", &n);
    dectobin(n);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例：
```c
10
```
输出样例：
```c
1010
```
答案：递归进制转换。
```c
void dectobin( int n ) {
    if (n < 2) printf("%d", n);
    else {
        dectobin(n / 2);
        printf("%d", n % 2); 
    }
}
```
---
## 习题10-8 递归实现顺序输出整数 (15分)

本题要求实现一个函数，对一个整数进行按位顺序输出。函数接口定义：
```c
void printdigits( int n );
```
函数printdigits应将n的每一位数字从高位到低位顺序打印出来，每位数字占一行。

裁判测试程序样例：
```c
#include <stdio.h>

void printdigits( int n );

int main()
{
    int n;
	
    scanf("%d", &n);
    printdigits(n);

    return 0;
}

/* 你的代码将被嵌在这里 */
```

输入样例：
```c
12345
```
输出样例：
```c
1
2
3
4
5
```
答案：简单的递归。
```c
void printdigits( int n ) {
    if (n < 10) printf("%d\n", n);
    else {
        printdigits(n / 10);
        printf("%d\n", n % 10);
    }
}
```

---
## 习题11-1 输出月份英文名 (15分)

本题要求实现函数，可以返回一个给定月份的英文名称。函数接口定义：
```c
char *getmonth( int n );
```
       
函数getmonth应返回存储了n对应的月份英文名称的字符串头指针。如果传入的参数n不是一个代表月份的数字，则返回空指针NULL。

裁判测试程序样例：
```c
#include <stdio.h>

char *getmonth( int n );

int main()
{
    int n;
    char *s;

    scanf("%d", &n);
    s = getmonth(n);
    if ( s==NULL ) printf("wrong input!\n");
    else printf("%s\n", s);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例1：
```c
5
```
输出样例1：
```c
May
```
输入样例2：
```c
15
```
输出样例2：
```c
wrong input!
```
答案：
```c
char *s[] = {"",
  "January", "February", "March", "April", "May", "June", "July", 
  "August", "September", "October", "November", "December"}; 
char *getmonth( int n ) {
    if (n < 1 || n > 12) return NULL;
    return s[n];
}
```
---
## 习题11-2 查找星期 (15分)

本题要求实现函数，可以根据下表查找到星期，返回对应的序号。
```swift 
序号 	星期
0 	Sunday
1 	Monday
2 	Tuesday
3 	Wednesday
4 	Thursday
5 	Friday
6 	Saturday
```

函数接口定义：
```c
int getindex( char *s );
```

函数getindex应返回字符串s序号。如果传入的参数s不是一个代表星期的字符串，则返回-1。

裁判测试程序样例：
```c
#include <stdio.h>
#include <string.h>

#define MAXS 80

int getindex( char *s );

int main()
{
    int n;
    char s[MAXS];

    scanf("%s", s);
    n = getindex(s);
    if ( n==-1 ) printf("wrong input!\n");
    else printf("%d\n", n);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例1：
```c
Tuesday
```
       

输出样例1：
```c
2
```

输入样例2：
```c
today
```
输出样例2：
```c
wrong input!
```
答案：注意星期天是序号0。
```c
char *day[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

int getindex( char *s ) {
    for (int i = 0; i < 7; ++i)  
        if (strcmp(s, day[i]) == 0) return i; 
    return -1;
}
```
---
##  习题11-3 计算最长的字符串长度 (15分)

本题要求实现一个函数，用于计算有n个元素的指针数组s中最长的字符串的长度。函数接口定义：
```c
int max_len( char *s[], int n );
```

其中n个字符串存储在s[]中，函数max_len应返回其中最长字符串的长度。

裁判测试程序样例：
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAXN 10
#define MAXS 20

int max_len( char *s[], int n );

int main()
{
    int i, n;
    char *string[MAXN] = {NULL};

    scanf("%d", &n);
    for(i = 0; i < n; i++) {
        string[i] = (char *)malloc(sizeof(char)*MAXS);
        scanf("%s", string[i]);
    }
    printf("%d\n", max_len(string, n));

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例：
```c
4
blue
yellow
red
green
```
输出样例：
```c
6
```
答案：
```c
int max_len( char *s[], int n ) {
    int max = 0;
    for (int i = 0; i < n; ++i) {
        int len = strlen(s[i]);
        if (len > max) max = len;
    }
    return max;
}
```
---
## 习题11-4 字符串的连接 (15分)

本题要求实现一个函数，将两个字符串连接起来。函数接口定义：
```c
char *str_cat( char *s, char *t );
```

函数str_cat应将字符串t复制到字符串s的末端，并且返回字符串s的首地址。

裁判测试程序样例：
```c
#include <stdio.h>
#include <string.h>

#define MAXS 10

char *str_cat( char *s, char *t );

int main()
{
    char *p;
    char str1[MAXS+MAXS] = {'\0'}, str2[MAXS] = {'\0'};

    scanf("%s%s", str1, str2);
    p = str_cat(str1, str2);
    printf("%s\n%s\n", p, str1);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例：
```c
abc
def
```
输出样例：
```c
abcdef
abcdef
```
答案：
```c
char *str_cat( char *s, char *t ) {
    char *k = s;
    while (*k) ++k;
    while (*t) {
        *k = *t;
        ++k, ++t;
    }
    return s;
}
```
---
## 习题11-5 指定位置输出字符串 (20分)

本题要求实现一个函数，对给定的一个字符串和两个字符，打印出给定字符串中**从与第一个字符匹配的位置开始到与第二个字符匹配的位置之间的所有字符**。函数接口定义：
```c
char *match( char *s, char ch1, char ch2 );
```
  
函数match应**打印s中从ch1到ch2之间的所有字符**，并且**返回ch1的地址**。

裁判测试程序样例：
```c
#include <stdio.h>

#define MAXS 10

char *match( char *s, char ch1, char ch2 );

int main()
{
    char str[MAXS], ch_start, ch_end, *p;

    scanf("%s\n", str);
    scanf("%c %c", &ch_start, &ch_end);
    p = match(str, ch_start, ch_end);
    printf("%s\n", p);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例1：
```c
program
r g
```

输出样例1：
```swift
rog
rogram
```
       

输入样例2：
```c
program
z o 
```
输出样例2：
```c
(空行)
(空行)
```

输入样例3：
```c
program
g z
```

输出样例3：
```c
gram
gram
```
答案：ch1找不到时，**用字符串s的最后一位'\0'的地址作为返回的结果**。
```c
char *match( char *s, char ch1, char ch2 ) {
    char *ans = NULL;
    while (*s && *s != ch1) ++s;
    ans = s; // sample2, ch1找不到, ch2找到
    if (*s) {
        char *t = s; 
        while (*t && *t != ch2) ++t;
        if (*t == '\0') --t;
        for (; s <= t; ++s) 
            printf("%c", *s);
    } 
    printf("\n"); // 必须换行
    return ans;
}
```
---
## 习题11-6 查找子串 (20分)

本题要求实现一个字符串查找的简单函数。函数接口定义：
```c
char *search( char *s, char *t );
```
      
函数search在字符串s中查找子串t，返回子串t在s中的首地址。若未找到，则返回NULL。

裁判测试程序样例：
```c
#include <stdio.h>
#define MAXS 30

char *search(char *s, char *t);
void ReadString( char s[] ); /* 裁判提供，细节不表 */

int main()
{
    char s[MAXS], t[MAXS], *pos;

    ReadString(s);
    ReadString(t);
    pos = search(s, t);
    if ( pos != NULL )
        printf("%d\n", pos - s);
    else
        printf("-1\n");

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例1：
```c
The C Programming Language
ram
```

输出样例1：
```c
10
```

输入样例2：
```c
The C Programming Language
bored
```
输出样例2：
```c
-1
```
答案：字符串的暴力匹配。
```c
#include <string.h>
char *search( char *s, char *t ) { // 暴力匹配
    int i = 0, j = 0;
    while (s[i] && t[j]) {
        if (s[i] == t[j]) {
            ++i;
            ++j;
        } else {
            i = i - j + 1; // 回溯
            j = 0;
        }
    }
    if (j == strlen(t)) return s + i - j;
    return NULL; // 未找到
}
```
---
## 习题11-7 奇数值结点链表 (20分)

本题要求实现两个函数，分别将读入的数据存储为单链表、将链表中奇数值的结点重新组成一个新的链表。链表结点定义如下：
```c
struct ListNode {
    int data;
    ListNode *next;
};
```
函数接口定义：
```c
struct ListNode *readlist();
struct ListNode *getodd( struct ListNode **L );
```
函数readlist从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到−1时表示输入结束，函数应返回指向单链表头结点的指针。

函数getodd将单链表L中奇数值的结点分离出来，重新组成一个新的链表。返回指向新链表头结点的指针，同时将L中存储的地址改为删除了奇数值结点后的链表的头结点地址（所以要传入L的指针）。

裁判测试程序样例：
```c
#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int data;
    struct ListNode *next;
};

struct ListNode *readlist();
struct ListNode *getodd( struct ListNode **L );
void printlist( struct ListNode *L )
{
     struct ListNode *p = L;
     while (p) {
           printf("%d ", p->data);
           p = p->next;
     }
     printf("\n");
}

int main()
{
    struct ListNode *L, *Odd;
    L = readlist();
    Odd = getodd(&L);
    printlist(Odd);
    printlist(L);

    return 0;
}

/* 你的代码将被嵌在这里 */
```
输入样例：
```c
1 2 2 3 4 5 6 7 -1
```

输出样例：
```c
1 3 5 7 
2 2 4 6 
```
答案：无头结点的链表操作真麻烦啊，必须特判队首。
```cpp
struct ListNode *readlist() {
    int read;
    struct ListNode *l = NULL, *r = l;
    while (~scanf("%d", &read)) {
        if (read == -1) break;
        struct ListNode *newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        newNode->data = read;
        newNode->next = NULL;
        if (l == NULL) l = newNode; // 队首特殊判断 
		else r->next = newNode;
        r = newNode; // 尾插法
    }
    return l;
}
struct ListNode *getodd( struct ListNode **L ) {
    struct ListNode *odd = NULL, *r = odd, *pre = *L, *cur = *L;
    while (cur) {
        if (cur->data & 1) {  // 奇数结点
            if (pre == *L && cur == *L) *L = pre = cur->next; // 原链表队首特判  
            else pre->next = cur->next; // 相当于删除了这个奇数结点
            
			if (odd == NULL) odd = cur; // 新链表队首特判 
			else r->next = cur; 
            
			r = cur; // 尾插法
            cur = cur->next; // 移动到下一个结点
            r->next = NULL;  // 奇数结点链表结尾为NULL
        } else {
            pre = cur;
            cur = cur->next;
        }
    }
    return odd;
}
```
---
## 习题11-8 单链表结点删除 (20分)

本题要求实现两个函数，分别将读入的数据存储为单链表、将链表中所有存储了某给定值的结点删除。链表结点定义如下：
```c
struct ListNode {
    int data;
    ListNode *next;
};
```
函数接口定义：
```c
struct ListNode *readlist();
struct ListNode *deletem( struct ListNode *L, int m );
```
函数readlist从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到−1时表示输入结束，函数应返回指向单链表头结点的指针。

函数deletem将单链表L中所有存储了m的结点删除。返回指向结果链表头结点的指针。

裁判测试程序样例：
```c
#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int data;
    struct ListNode *next;
};

struct ListNode *readlist();
struct ListNode *deletem( struct ListNode *L, int m );
void printlist( struct ListNode *L )
{
     struct ListNode *p = L;
     while (p) {
           printf("%d ", p->data);
           p = p->next;
     }
     printf("\n");
}

int main()
{
    int m;
    struct ListNode *L = readlist();
    scanf("%d", &m);
    L = deletem(L, m);
    printlist(L);

    return 0;
}

/* 你的代码将被嵌在这里 */
```

输入样例：
```c
10 11 10 12 10 -1
10
```
输出样例：
```c
11 12 
```
答案：队首特判还是有点麻烦。
```c
struct ListNode *readlist() {
    int read;
    struct ListNode *l = NULL, *r = l;
    while (~scanf("%d", &read)) {
        if (read == -1) break;
        struct ListNode *newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        newNode->data = read;
        newNode->next = NULL;
        if (l == NULL) l = newNode; // 队首特殊判断 
		else r->next = newNode;
        r = newNode; // 尾插法
    }
    return l;
}

struct ListNode *deletem( struct ListNode *L, int m ) {
    struct ListNode *p = L, *q = L;
    while (p) {
        if (p->data == m) {
            if (p == L) L = q = p->next; // 队首特判 
            else q->next = p->next;
            free(p);
            p = q;
        } else {
            q = p;
            p = p->next;
        }
    }
    return L;
}
```
