总时间限制:    1000ms
内存限制:    65536kB

**描述**
    有一个由按钮组成的矩阵，其中**每行有6个按钮，共5行**。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会**改变一次**。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。**在矩阵角上的按钮改变3盏灯的状态**；**在矩阵边上的按钮改变4盏灯的状态**；其他的按钮改变5盏灯的状态。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200313173602790.png)
  
   在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的**每盏灯设置一个初始状态**。请你按按钮，**直至每一盏等都熄灭**。与一盏灯毗邻的多个按钮被按下时，**一个操作会抵消另一次操作的结果**。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200313173611350.png)
    请你写一个程序，确定**需要按下哪些按钮，恰好使得所有的灯都熄灭**。

根据上面的规则，我们知道1）第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，**每个按钮最多只需要按下一次**；2）**各个按钮被按下的顺序对最终的结果没有影响**；3）**对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯**。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的灯。


**输入**
    5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。
**输出**
    5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。
**样例输入**

    0 1 1 0 1 0
    1 0 0 1 1 1
    0 0 1 0 0 1
    1 0 0 1 0 1
    0 1 1 1 0 0

**样例输出**

    1 0 1 0 0 1
    1 1 0 1 0 1
    0 0 1 0 1 1
    1 0 0 1 0 0
    0 1 0 0 0 0

---
**题意**：给出一个灯矩阵[5X6]，要求将矩阵里面的灯全部熄灭。问如何按？

**思路**：题目给出了许多提示。甚至把解法都告诉我们了：
- **每个按钮最多只需要按下一次**(==由于两次按同一盏灯，带来的影响会被抵消；而且题目给的按按钮方案要么是0要么是1，没有2(笑)==)；
- **各个按钮被按下的顺序对最终的结果没有影响**(如果顺序会有影响的话，不会只让我们给出按钮矩阵的按法)；
- **对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯**。如此重复下去，可以熄灭第1、2、3、4行的全部灯。

关于顺序的问题，有点难以明白，不过我们可以知道：
- 如果两个按钮无法影响到彼此，那么它们按的顺序就不重要；
- 如果按钮间相邻，那么它对别的按钮的影响，会被按别的按钮的影响抵消；别的按钮对它的影响，会被它按自己的影响抵消；
- 如果按钮间的影响有交集，那么彼此对交集的影响会被抵消；

因此顺序无关紧要。

然后，题目还把解法告诉了我们……

对于这个题，很容易想到可以用2进制数，枚举所有的状态，来对应相应的按按钮的方案，$[0, 2^n)$，有$2^{30}$个方案，再加上按按钮和判断的时间消耗……复杂度绝对爆表！

而题目则告诉我们，可以从第一行开始， **对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯**，如此重复下去，**可以熄灭第1、2、3、4行的全部灯**。==只要在对第4行的每盏点亮的灯，按下第5行对应的按钮，熄灭第4行的全部灯后，检查第5行的灯是否全部熄灭了即可判断方案是否可行==。复杂度降到了$2^6 = 64$个状态，因为只需要枚举第一行的状态。

---
这是很重要的枚举优化的技巧。
> 如果存在某个局部，一旦这个局部的状态被确定，那么其他剩余部分的状态只能是确定的一种或不多的n种，那么只需枚举这个局部的状态即可。

本题的这个**局部**就是第一行：
- 因为第1行的各开关状态确定的情况下，其中的一些开关作用过后，将导致第1行某些灯是亮的，某些灯是灭的；
- 要熄灭第1行某个**亮着**的灯(假设位于第i列)，那么唯一的办法就是按下第2行第i列的开关(因为第1行的开关**已经用过**了, 而第3行及其后的开关**不会影响到**第1行)
- 为了**使第1行的灯全部熄灭**, 第2行的**合理开关状态就是唯一的**；
- 第2行的开关起作用后，为了熄灭第2行的灯， **第3行的合理开关状态就也是唯一的**；
-  以此类推，**最后一行的开关状态也是唯一的**。

只要第1行的状态定下来，记作A，那么剩余行的情况就是确定唯一的了。

推算出最后一行的开关状态，然后看看最后一行的开关起作用后，最后一行的所有灯是否都熄灭： 如果是， 那么A就是一个解的状态；如果不是，那么A不是解的状态，第1行换个状态重新试试。

---
照这样说，……，第一列不也是一个局部状态吗？对，而且只用枚举第一列，状态个数为$2^5=32$！

所以，我的答案就枚举第一列。

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int m[5][6], temp[5][6];  
int solution[5][6];
int Move[][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
#define isLegal(r, c) (r >= 0 && r < 5 && c >= 0 && c <= 5)

void reverseBits(int r, int c) {
	temp[r][c] ^= 1;
	for (int i = 0; i < 4; ++i) {
		int rr = r + Move[i][0], cc = c + Move[i][1];
		if (isLegal(rr, cc)) temp[rr][cc] ^= 1;
	}
}

void solve() {
	for (int i = 0; i < 32; ++i) {
		memcpy(temp, m, sizeof(m));
		memset(solution, 0, sizeof(solution));
		int t = i;
		for (int j = 0; t; ++j) { //对0列的第几行操作 
			if (t & 1) {
				reverseBits(j, 0);  
				solution[j][0] = 1; 
			}
			t >>= 1;
		}
		for (int j = 1; j < 6; ++j) { //对1列到5列进行操作 
			for (int k = 0; k < 5; ++k) { 
				if (temp[k][j - 1]) { //前一列灯亮 
					reverseBits(k, j);
					solution[k][j] = 1;	
				}
			}
		}
		bool flag = true;
		for (int j = 0; j <= 4; ++j) { //如果第5列灯都熄灭
			if (temp[j][5]) {
				flag = false;
				break; 
			}
		}
		if (flag) {
			for (int r = 0; r < 5; ++r) {  //打印方案
				for (int c = 0; c < 6; ++c) {
					if (c != 0) cout << " ";
					cout << solution[r][c];
				}
				cout << endl;
			}
			return;
		}
	}
}

int main() {
	for (int i = 0; i < 5; ++i) 
		for (int j = 0; j < 6; ++j) 
			cin >> m[i][j]; 
	solve();
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200313195442706.png)
看到别人的答案，发现了新技巧。

由于矩阵数据要么是0，要么是1，每一行只有6个字符，因此可以用一个`char[5]`存储整个矩阵。每一个`char`存储一行的数据。这不仅节约了一点空间，而且有时候**很容易对整行进行操作，如设置整行和比较**，提高了效率。**唯一麻烦的就是要进行位操作**。
```cpp
#include <cstring>
#include <iostream>
using namespace std;
int GetBit(char c, int i) { //得到矩阵某行的i列数 
	return (c >> i) & 1;	//取c的i位 0/1 
}
void SetBit(char &c, int i, int v) {
	if (v) c |= (1 << i); //置i位为1
	else c &= ~(1 << i);  //置i位为0 
}
void Flip(char &c, int i) { 
	c ^= (1 << i); //将c的i位取反 
}
void outputResult(char result[]) {
	for (int i = 0; i < 5; ++i) {
		for (int j = 0; j < 6; ++j) {
			cout << GetBit(result[i], j);
			if (j < 5) cout << " ";
		}
		cout << endl;
	}
}

int main() {
	char oriLights[5]; //最初的灯矩阵, 一个比特表示一盏灯
	char lights[5]; //中间结果
	char result[5]; //决策矩阵 
	char switchs; //某一行的开关状态 
	memset(oriLights, 0, sizeof(oriLights));
	
	for (int i = 0; i < 5; ++i) {
		for (int j = 0; j < 6; ++j) {
			int t;
			cin >> t;
			SetBit(oriLights[i], j, t);
		}
	}
	
	for (int n = 0; n < 64; ++n) { //遍历首行开关的64种状态
		memcpy(lights, oriLights, sizeof(oriLights));
		switchs = n; //第i行的开关状态
		for (int i = 0; i < 5; ++i) {
			result[i] = switchs; //第i行的开关方案, 先是第0行
			for (int j = 0; j < 6; ++j) {
				if (GetBit(switchs, j)) {
					if (j > 0)
						Flip(lights[i], j - 1); //改左灯
					Flip(lights[i], j); //改开关位置的灯
					if (j < 5)
						Flip(lights[i], j + 1); //改右灯
				}
			}
			if (i < 4) //不是最后一行 
				lights[i + 1] ^= switchs; //改下一行的灯
			switchs = lights[i]; //第i+1行开关方案和第i行灯相同 
		}
		if (lights[4] == 0) {
			outputResult(result);
			break;
		}
	}
	return 0;	 
}
```
