**试题背景**
顿顿在学习了数字图像处理后，想要对手上的一副灰度图像进行降噪处理。不过该图像仅在较暗区域有很多噪点，如果贸然对全图进行降噪，会在抹去噪点的同时也模糊了原有图像。因此顿顿打算先使用**邻域均值**来判断一个像素是否处于较暗区域，然后仅对处于**较暗区域**的像素进行降噪处理。

**问题描述**
待处理的灰度图像长宽皆为 $n$ 个像素，可以表示为一个 $n \times n$ 大小的矩阵 ，其中每个元素是一个 $[0, L)$  范围内的整数，表示对应位置像素的灰度值。

对于矩阵中任意一个元素 $A_{ij}$（$0\le i,j \lt n$），其**邻域**定义为附近若干元素的集和：
$$Neighbor(i,j,r) = \{ A_{xy} \ | \ 0 \le x, y \lt n \ and \ |x - i| \le r \ and \ |y - i| \le r \ \}$$
这里使用了一个额外的参数 $r$ 来指明 $A_{ij}$ 附近元素的具体范围。根据定义，易知 $Neighbor(i,j,r)$  最多有 $(2r+1)^2$ 个元素。

如果元素 $A_{ij}$ **邻域**中所有元素的**平均值**小于或等于一个给定的阈值 $t$ ，我们就认为该元素对应位置的像素处于**较暗区域**。

下图给出了两个例子，左侧图像的较暗区域在右侧图像中展示为黑色，其余区域展示为白色。
![ ](https://img-blog.csdnimg.cn/1d39cb22f1094eb1b47e57d2408e3b94.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_20,color_FFFFFF,t_70,g_se,x_16)
 
现给定邻域参数 $r$ 和阈值 $t$ ，试统计输入灰度图像中有多少像素处于**较暗区域**。

**输入格式**
输入共 $n + 1$ 行。输入的第一行包含四个用空格分隔的正整数 $n$ 、$L$ 、$r$ 和 $t$ ，含义如前文所述。

第二到第 $n + 1$ 行输入矩阵 $A$ 。第 $i + 2$（$0\le i \lt n$）行包含用空格分隔的 $n$ 个整数，依次为 $A_{i0}, A_{i1}, ..., A_{i(n-1)}$ 。

**输出格式**
输出一个整数，表示输入灰度图像中处于较暗区域的像素总数。

**样例输入**

```haskell
4 16 1 6
0 1 2 3
4 5 6 7
8 9 10 11
12 13 14 15
```
 
**样例输出**

```haskell
7
```
 
**样例输入**

```haskell
11 8 2 2
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 7 0 0 0 7 0 0 7 7 0
7 0 7 0 7 0 7 0 7 0 7
7 0 0 0 7 0 0 0 7 0 7
7 0 0 0 0 7 0 0 7 7 0
7 0 0 0 0 0 7 0 7 0 0
7 0 7 0 7 0 7 0 7 0 0
0 7 0 0 0 7 0 0 7 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```

 
**样例输出**

```haskell
83
```

 
**评测用例规模与约定**
$70%$ 的测试数据满足 $n \le 100$ 、$r \le 10$ 。
全部的测试数据满足 $0 \lt n \le 600$ 、$0\lt r\le 100$ 且 $2 \le t  \lt L \le 256$ 。

---
### 解法 二维前缀和
双重循环检查每个像素，用二维前缀和在 $O(1)$ 时间内求出领域元素的和，领域元素的个数易知，判断是否是**较暗区域**就很简单了：
```cpp
#include <bits/stdc++.h> 
using namespace std;
const int maxn = 610;
int n, L, r, t, tmp, s[maxn][maxn] = {0}, ans = 0;

int main() {
	scanf("%d%d%d%d", &n, &L, &r, &t);
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			scanf("%d", &tmp);
			s[i + 1][j + 1] = s[i][j + 1] + s[i + 1][j] - s[i][j] + tmp;
		}
	}
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			int x1 = max(i - r, 0), y1 = max(j - r, 0);
			int x2 = min(i + r, n - 1), y2 = min(j + r, n - 1);
			int sum = s[x2 + 1][y2 + 1] - s[x1][y2 + 1] - s[x2 + 1][y1] + s[x1][y1];
			int cnt = (x2 - x1 + 1) * (y2 - y1 + 1);
			
			if (sum <= t * cnt) ++ans; 
		} 
	}
	printf("%d", ans);
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/3c6fda540d504bd6a41b0cf82a9233b1.png)

