# [好数](https://pintia.cn/problem-sets/1437682745411649536/problems/1437682827267686400)	 
![在这里插入图片描述](https://img-blog.csdnimg.cn/202df8a02b93456e85cbae32d61a8aa8.png)

好数是指由一对正整数 a<b 按照 a2+ab+b2 这个规则生成的数，a 和 b 就称为这个好数的源头。例如 91 就是一个好数，因为 52+5×6+62=91，于是数对（5，6）就是 91 的源头。而对于一个好数，其源头并不一定唯一，例如（1，9）就是 91 的另一个源头。

本题就要求你编写程序，判断一个给定的数字是否好，并且输出好数的所有源头。
输入格式：

输入在第一行给出一个不超过 100 的正整数 N，随后 N 行，每行给出一个不超过 104 的正整数。
输出格式：

对于每一个输入的数字，如果其是好数，则首先在一行中输出 Yes，然后每行输出它的一个源头，格式为 a b，按 a 的递增顺序输出；否则在一行中输出 No和比该数大的最小的好数，其间以空格分隔，然后每行输出这个好数的一个源头，格式同上。
输入样例：

3
1
91
50

输出样例：

No 7
1 2
Yes
1 9
5 6
No 52
2 6

# [数以类聚](https://pintia.cn/problem-sets/1437682745411649536/problems/1437682827267686401)	 
![在这里插入图片描述](https://img-blog.csdnimg.cn/7cdd22c12f614f5d9ac72f91d0b01cc4.png)

我们把所有各位数字的乘积相同的数归为一类。例如 1362 和 2332 就是同一类，因为 1×3×6×2=2×3×3×2。给定 N 个正整数，请你判断它们可以被归成多少不同的类？
输入格式：

输入在第一行给出一个正整数 N（≤105），第二行给出 N 个不超过 107 的正整数，数字间以空格分隔。
输出格式：

在一行中输出 N 个给定的整数可以归类的数量、以及规模最大的类中最小的乘积。数字间以一个空格分隔。
输入样例：

10
1234 98 329 9552 47621 8862 5539 2333 5365 463

输出样例：

7 54

样例说明：

10 个给定数字对应的各位数字乘积依次为：24、72、54、450、336、768、675、54、450、72。所以一共有 7 个不同的种类，即：24、72、54、450、336、768、675。

其中规模最大的有 2 个 54、2 个 72、2 个 450。即这 3 个种类都分别对应了 2 个数字，在规模相等、都是最大的情况下，我们输出最小的乘积 54。


# [自定义判题程序](https://pintia.cn/problem-sets/1437682745411649536/problems/1437682827267686402)	 
![在这里插入图片描述](https://img-blog.csdnimg.cn/67c71162a58343728fc5b6d88d62ab57.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/fb2ce21bd41d4acc9df3e02ee8431787.png)


在每次允许插入、删除、修改一个字符的前提下，用最少的动作把一个字符串变成另一个字符串，是一道著名的可以用动态规划解决的问题。但判题的麻烦之处在于，虽然最小代价是唯一的，但变换方法却是不唯一的。例如把 PAT 变成 PTA 最少需要 2 步，可以保持第 1 个字母不变，修改后面 2 个字母，也可以保持第 1、2 个字母不变，在 A 前面插入 T，后面删除 T。由于拼题 A 系统的默认判题程序只能通过比对输出文件来判断对错，对这种正确答案输出不唯一的题目就不能处理了，需要出题者额外编写一个自定义判题程序来解决问题。

本题就请你编写这个自定义判题程序，读入两个字符串和用户程序产生的输出结果，判断他们的程序输出是否正确。
输入格式：

输入首先在前两行分别给出两个不超过 1000 个字符、以回车结束的非空字符串，第 1 行对应初始字符串，第 2 行对应目标字符串。

随后一行给出一个正整数 N（≤100），为需要判断的提交数。

接下来是 N 个提交的输出结果，每个结果占 2 行：第 1 行给出一个整数 K（不超出 32 位 int 的范围），为用户输出的动作数；第 2 行顺次描述对初始字符串的每个字符所做的操作：

    如果这个字符不变，则在对应位置输出 0
    如果这个字符被删除，则在对应位置输出 1
    如果这个字符被改变，则在对应位置输出 2
    如果这个字符前面或者后面插入了一个字符，则在插入的位置输出 3

注意我们要求用户提交的行首尾和数字间均无空格，所以如果有多余空格应判为错误。

题目保证这个操作序列不为空。
输出格式：

对每个正确的提交，在一行中输出 AC；否则输出 WA。

注意：这里并不要求你会用动态规划求出最优解。所以对“正确提交”的判断，并不以动态规划求出的最优解为根据！ 对于用户输出的 K，如果其操作序列的确给出了 K 步操作并可以完成字符串的变换，则称为一个“可行解”。所谓“正确提交”，是指所有提交的可行解中的最优解。
输入样例：

This is a test.
Tom is a cat.
6
8
02330001100022100
8
11113330000001113300
6
022100000012200
5
033310000000200
6
0 2 2 1 000000 1 2 2 00
6
012200000022100

输出样例：

WA
WA
AC
WA
WA
AC
# [数组与链表](https://pintia.cn/problem-sets/1437682745411649536/problems/1437682827267686403) 
![在这里插入图片描述](https://img-blog.csdnimg.cn/45cfb52d72ab4da6805697363ef24567.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/1ced268b03774eda8fe29aec586bac78.png)


让我们来设计这样一种数组与链表结合的整数存储的结构 A：

这种结构首先初始化一个长度为 L0​ 的整型数组 A0​，返回给用户使用。当用户访问第 i 个元素 A[i] 的时候，如果 0≤i<L0​，则 A[i] 对应 A0​[i]，系统就返回 h0​+i×sizeof(int) 作为要访问的地址，其中 h0​ 是数组 A0​ 的起始位置，sizeof(int) 是数组元素的大小，这里元素就是 int 型，占 4 个字节。

当用户访问越界时（即 i≥L0​），系统将另外开辟一个长度为 L1​ 的数组 A1​。此时 A[i] 对应 A1​[j]（这里 i 和 j 之间的映射关系留给你去推导）。如果 0≤j<L1​，则返回 h1​+j×sizeof(int) 作为要访问的地址，其中 h1​ 是数组 A1​ 的起始位置。

当 A1​[j] 继续越界时，系统就按照上述规则继续开辟另一个长度为 L2​ 的数组 A2​，并以此类推。

本题就请你实现这个系统功能，为用户的任何一次访问返回对应元素的地址。
输入格式：

输入第一行给出两个正整数 N（≤104）和 K（≤103），分别为最多允许开出的数组个数、以及用户访问的次数。

此后 N 行，每行给出两个正整数，分别是一个数组的初始地址（≤107）和长度（≤100），其间以空格分隔。题目保证这些数组占据的空间无重叠。

最后一行顺序给出 K 个用户访问的数组下标，为区间 [0,220] 内的整数。
输出格式：

对每个用户访问，在一行中输出对应的地址。但如果用户的访问超出了 N 个数组的存储范围，则这个访问是非法的，要输出 Illegal Access，并且对这个访问不采取任何处理。

最后一行请输出上述过程中一共创建了多少个数组。
输入样例：

6 7
2048 5
128 6
4016 10
1024 7
3072 12
9332 10
2 12 25 50 28 8 39

输出样例：

2056
4020
1040
Illegal Access
3072
140
3116
5

样例说明：

访问 A[2] 即 A0​[2]，元素的地址就是 2048+2×4=2056。

访问 A[12]，则只加开 A1​ 不够，需要加开 A2​，其初始位置 h2​=4016，则 A[12]=A2​[1] 的地址就是 4016+1×4=4020。

访问 A[25]，则必须加开 A3​，其初始位置 h3​=1024，则 A[25]=A3​[4] 的地址就是 1024+4×4=1040。

访问 A[50] 超出了允许创建的数组的最大边界，所以是非法访问，新数组未创建。

访问 A[28]，则必须加开 A4​，其初始位置 h4​=3072，则 A[28]=A4​[0] 的地址就是 3072。

访问 A[8]=A1​[3]，所以地址是 128+3×4=140。

访问 A[39]=A4​[11]，地址就是 3072+11×4=3116。

上述访问一共创建了 5 个数组。

# [取帽子](https://pintia.cn/problem-sets/1437682745411649536/problems/1437682827267686404)
![在这里插入图片描述](https://img-blog.csdnimg.cn/585c2695fac84137b7a80246f387a37a.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/c68591b9cc374cd08029c7e15715ebc1.png)

拼题er们觉得戴帽子会令自己看上去很帅，所以他们不管到哪里都会戴着帽子。有一天他们去到一家餐厅，服务员把他们的帽子收集了堆起来保管。当大家要离开的时候，发现帽子被像上图那样摞起来了。于是你的任务就是帮他们排好队，使得每个人都能按顺序顺利取到自己的帽子。

已知每顶帽子的大小都不相同，并且帽子的尺寸跟帽子主人的体重有关 —— 越重的人戴的帽子就越大。
输入格式：

输入第一行给出一个正整数 N (≤104)，为拼题er的人数。随后一行给出 N 个不同的帽子尺寸，为不超过 105 的正整数，顺序是从帽子堆的底部向上给出。最后一行给出 N 个不同的体重，顺序对应编号从 1 到 N 的拼题er。体重是不超过 106 的正整数。一行中的数字以空格分隔。
输出格式：

在一行中按照取帽子的顺序输出帽子主人的编号。数字间以 1 个空格分隔，行首尾不得有多余空格。
输入样例：

10
12 19 13 11 15 18 17 14 16 20
67 90 180 98 87 105 76 88 150 124

输出样例：

3 4 8 6 10 2 1 5 9 7

样例说明：

第一顶帽子的尺寸是最大的 20，所以对应第 3 个人的最大体重 180，于是第 3 个人排在最前面。

第二顶帽子的尺寸是第 6 小的 16，对应第 6 小的体重 98，是第 4 个人，于是第 4 个人下一个走。

以此类推。
