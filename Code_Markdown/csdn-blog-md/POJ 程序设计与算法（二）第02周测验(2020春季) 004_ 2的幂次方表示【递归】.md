

```
总时间限制: 1000ms
内存限制: 65536kB
```
- 描述

    任何一个正整数都可以用2的幂次方表示。
    同时约定方次用括号来表示，即ab可表示为a(b)。由此可知，137可表示为：

      2(7)+2(3)+2(0)

    进一步：7=2^2^+2+2^0^（21用2表示） 

    所以最后137可表示为：

      2(2(2)+2+2(0))+2(2+2(0))+2(0)

    又如：1315=2^10^+2^8^+2^5^+2+1

    所以1315最后可表示为：

      2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)

**输入**
    一个正整数n（n≤20000）。
**输出**
    一行，符合约定的n的0，2表示（在表示中不能有空格）。
**样例输入**

    137

**样例输出**

    2(2(2)+2+2(0))+2(2+2(0))+2(0)

**来源**
        
    NOIP1998复赛 普及组 第一题 

题意：将一个正整数($\leq 20000$)表示成2的幂次方的和，2的幂次方的基本单位为$2^0$，$2^1$，$2^2$。由于要**符合约定的n的0，2表示**，所以这几个表示成$2(0)$、$2$、$2(1)$。

### 写法一
思路：这个题用递归很简单。先表示出基本的递归边界，然后先处理特殊的奇数情况，把所有的数都变成偶数，接下来就简单了。

对于每个偶数(除了2)，都找到小于n的最大的2的幂次方，然后递归对幂次方进行处理。如果有余值，就继续递归调用。
```cpp
#include <iostream>
using namespace std;
int n;
void solve(int n) { //将正整数表示为2的幂次方 
	if (n == 1) cout << "2(0)";
	else if (n == 2) cout << "2"; 
	else {
		if (n & 1) {
			solve(n - 1);
			cout << "+";
			solve(1);
		}
		else { //n肯定>=4
			int i, t; 
			for (i = 2; (1 << i) <= n; ++i); //找到最大的2的幂次方, 但小于n
			--i;
			cout << "2(";
			solve(i); //递归求幂次方的表示
			cout << ")";
			t = n - (1 << i);
			if (t) { //如果还有余值
				cout << "+";
				solve(t);
			}
		}
	}
}

int main() {
	cin >> n;
	solve(n);
	return 0;	
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312165907811.png)

### 写法二
看到别人写的，利用了二进制数的形式，如$137 = 1000 1001_2$，可以得到第7位、第4位、第1位有1，然后对每个位上的 $1$，继续递归。和前面的思想其实是一样的。
```cpp
#include <iostream>
using namespace std; 
inline int GetBit(int n,int i)
{
	return (n >> i ) & 1;
}
void Print(int n) {
	bool first = true; //控制格式 
	for (int i = 15; i >= 0; --i) { //2^15 > 20000
		if (GetBit(n, i)) { //得到i位的比特
			if (!first) cout << "+";
			else first = false;
			if (i == 0)
				cout << "2(0)";
			else if (i == 1)
				cout << "2";
			else {
				cout << "2(";
				Print(i);
				cout << ")";
			}
		}
	}
} 	 
int main() {
	int n;
	cin >> n;
	Print(n);	
	return 0;
}
```
