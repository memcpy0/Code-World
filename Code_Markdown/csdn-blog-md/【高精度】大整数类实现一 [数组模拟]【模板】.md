@[toc]

一道$A + B$的题目，都在$int$范围内，没有难度。但是如果 $A$ 和 $B$ 都是有 $1000$ 位的整数，就不能够直接使用已有的数据类型了。

更不用说涉及到阶乘的题目，数据增长很快，稍微大一点就超出范围了。emmm，这里说的是C++，Java有它的大整数类，Python更爽快，直接支持无限精度的整数。**大整数还可能和进制转换相关**，主要是除法和乘法。

我们需要自己手搓大整数类+四则运算。原理很简单，小学数学，用**数组模拟竖式运算**的过程。注意，这里的**大整数类存储高精度的非负整数**。

## 1. 大整数类的存储
使用数组+一个保持长度的变量`len`。**数组中的每一位代表存放的整数的每一位**。注意，==这里将整数的高位存放在数组的高位，将整数的低位存放到数组的低位==。
$e.g.$ 存储 `2319832` 到数组中，则数组为 $\{2,3,8,9,1,3,2\}$

为什么不反过来存呢？实际上除了除法外，在进行运算的过程，都是从整数的低位到高位进行枚举，顺位存储很符合思维过程。

下面是我们的结构体，加上两个初始函数，用来初始化结构体。第二个初始函数是先用字符串读入，然后转存入 $bign$ 结构体。
```cpp
struct bign {
	int d[10000];
	int len;
	bign() {
		memset(d, 0, sizeof(d));
		len = 0;
	}
	bign(char str[]) { //以字符串初始化大整数类 
		len = strlen(str);  
		for (int i = 0; i < len; ++i) 
			d[i] = str[len - i - 1] - '0'; //逆着赋值 
	}
};
```
## 2. 大整数类的比较和打印
比较函数也写在结构体里面，如果要比较两个大整数类的大小：
- 先判断两者的 $len$ 大小，不等则以长的为大；
- 相等，则从高位往低位进行比较，直到出现某一位不等，就可以判断两者的大小。
```cpp
int compare(const bign& b) { //比较和b的大小, 大于b、相等、小于b分别返回1、0、-1 
	if (len > b.len) return 1; //大于b
	else if (len < b.len) return -1; //小于b
	else {
		for (int i = len - 1; i >= 0; --i) { //从高位到低位比较
			if (d[i] > b.d[i]) return 1; //只要有1位比b大, 则大于b 
			else if (d[i] < b.d[i]) return -1; //只要有1位比b小, 则小于b 
		}
		return 0;
	}
}
```
打印函数写在结构体中，如下：
```cpp
void print() {
	for (int i = len - 1; i >= 0; --i)
		printf("%d", d[i]);	
}
```

---
## 3. 大整数类的四则运算
### 1. 高精度加法
以 $147 + 65$ 为例，看看两个整数如何相加：
- $7 + 5 = 12$，取个位数 $2$ 为该位的结果，取十位数 $1$ 为进位；
- $4 + 6 + 1 = 11$，加的时候加了进位 $1$。取 个位数 $1$ 为该位的结果，取十位数 $1$ 为进位；
- $1 + 1 = 2$，加进位 $1$，取个位数 $2$ 为该位的结果，由于十位数为 $0$，不进位。
```
    1 4 7
+     6 5
---------
    2 1 2
```
由此可以得出，对其中一位进行加法的步骤：**将该位上的两个数字与进位相加，得到的结果取个位数作为该位的结果，取十位数作为新的进位**。注意，==最后一步后，加法可能有多余的进位，将它赋给结果的最高位即可。==
```cpp
//高精度加法 
bign add(const bign &a, const bign& b) {
	bign c;
	int carry = 0; //进位
	for (int i = 0; i < a.len || i < b.len; ++i) { //以较长的为界限
		int t = a.d[i] + b.d[i] + carry; //两个对应为与进位相加
		c.d[c.len++] = t % 10; //个位数为该位结果
		carry = t / 10; //十位数为新的进位
	}
	if (carry != 0) //如果最后进位不为0, 则直接赋给结果的最高位 
		c.d[c.len++] = carry;
	return c;  
}
```
当然，这样实现必须注意：两个对象都是非负整数。==如果一方为负，则需要添加代码，**在转换为数组的构造函数那一步中，去掉其负号**，然后用高精度减法；如果都是负数，则可以去掉负号后用高精度加法，然后再把加号加回来即可。==
### 2. 高精度减法
以 $145 - 67$ 为例，看看两个整数如何相减：
- $5- 7 < 0$，不够减，因此从高位 $4$ 借 $1$，得到该位结果为 $15 - 7 = 8$；
- $3 - 6 < 0$，不够减，因此从高位 $1$ 借 $1$，得到该位结果为 $13 - 6 = 7$；
- 上下均为 $0$，结束运算。
```
    1 4 5
-     6 7
---------
      7 8
```
同样，由此可以得出，对其中某一位进行减法的步骤：**比较被减数和减数，不够减，则令被减数的高位减1，被减位加10再进行减法；如果够减，则直接减**。注意，==最后一步后，减法可能有多余的 $0$，要去除它们，但也要保证 $bign$ 有至少一位数==（可能是 $0$）。
```cpp
//高精度减法
bign sub(bign a, const bign& b) { //a-b 会修改a, 因此传递结构体而不使用引用 
	bign c;
	for (int i = 0; i < a.len || i < b.len; ++i) { //以较长的为界限
		if (a.d[i] < b.d[i]) {
			--a.d[i + 1]; //向高位借1
			a.d[i] += 10; //当前为+10 
		}
		c.d[c.len++] = a.d[i] - b.d[i]; //减法结果为当前位结果 
	} //修改了a, 但是没有修改a.len, 可能加了0 
	while (c.len - 1 >= 1 && c.d[c.len - 1] == 0) //去除高位的0, 但保证至少有一位最低位 
		--c.len;
	return c; 
}
```
最后，需要知道的是，==使用这个函数前需要`t = 被减数.compare(减数)`，如果得到`t < 0`，需要交换两个变量，保证内部的 $bign$ 为非负整数，最后输出负号和 $bign$ 的值。==

---
### 3. 高精度和低精度的乘法
低精度就是可以用基本数据类型存储的数据，而这里讲的是 $bign$ 和 $int/long\ long$ 类型的乘法。

- $7 * 35 = 245$，取个位数 $5$ 作为该位结果，高位部分 $24$ 作为进位；
- $4 * 35 = 140$，加上进位 $24$ 得 $164$，取个位数 $4$ 作为该位结果，高位部分 $16$ 作为进位；
- $1 * 35 = 35$，加上进位 $16$ 得 $51$，取个位数 $1$ 作为该位结果，高位部分 $5$ 作为进位；
- 没得乘了，此时进位不为 $0$，就把进位 $5$ 作为结果的高位。
```
    1 4 7 (bign)
*     3 5 (int)
---------
    2 4 5
+ 1 4 0
+ 3 5
---------
  5 1 4 5
```
同样，由此可以得出，对其中某一步进行乘法的步骤：**取 $bign$ 的某一位，与 $int$ 型整体相乘，所得结果的个位数作为该位结果，高位部分作为新的进位**。注意，==最后一步后，乘法可能有多余的 $0$，要去除它们，但也有保证 $bign$ 有至少一位数==（可能是 $0$）。
```cpp
//高精度和低精度的乘法
bign mul(const bign& a, int b) { //a*b bign*int
	bign c;
	int carry = 0; //进位 
	for (int i = 0; i < a.len; ++i) {
		int t = a.d[i] * b + carry;
		c.d[c.len++] = t % 10; //个位作为该位结果 
		carry = t / 10; //高位部分作为新的进位 
	}
	while (carry) { //乘法的进位可能不止一位 
		c.d[c.len++] = carry % 10;
		carry /= 10;
	}
	return c;
}
```
同样，要注意的是，==如果存在一个负数，要先记录其负号，取其绝对值代入函数；如果都是负数，和都是正数一样乘即可。==
### ★★★ 4. 高精度乘法
一般只需要上面的函数。不过说不定有这种题目，需要高精度之间的乘法。注意，这里实现的可能不是很到位，不过能够做题就可以了。

原理和 $\#3$ 讲的不一样，不过**就是竖式计算**。

使用乘数的最低位 $5$，得到的结果都**注意对齐**：
- $7 * 5 = 35$，取个位数 $5$ 作为该位结果，高位部分 $3$ 作为进位；
- $4 * 5 = 20$，加上进位 $3$ 得 $23$，取个位数 $3$ 作为该位结果，高位部分 $2$ 作为进位；
- $1 * 5 = 5$，加上进位 $2$ 得 $7$，取个位数 $7$ 作为该位结果，没有高位部分；

使用乘数的次低位 $3$，得到的结果都**注意对齐**：
- $7 * 3 = 21$，加上原来的 $3$ 得 $24$， 取个位数 $4$ 作为该位结果，高位部分 $2$ 作为进位；
- $4 * 3 = 12$，加上进位 $2$ 得 $14$，加上原来的 $7$ 得 $21$，取个位数 $1$ 作为该位结果，高位部分 $2$ 作为进位；
-  $1 * 3 = 3$，加上进位 $2$ 得 $5$，取个位数 $5$ 作为该位结果，没有高位部分。结束。

当然，也可以**按被乘数的位**来，代码就是按照这样写的。

==对齐的方法很简单，乘数的 $i$ 位和被乘数的 $j$ 位相乘，结果要和 $i + j$ 位对齐==。
```
    1 4 7 (bign)
*     3 5 (bign)
---------
    7 3 5 (c)
+ 4 4 1 
---------
  5 1 4 5 (c)
```
这段代码写起来最麻烦的，就是对齐和处理 $c.d$ 的长度。想通了这两点，还是很简单的。当然，这里还有优化的空间。
```cpp
//高精度乘法
bign superMul(const bign &a, const bign& b) { //a*b bign*bign
	bign c;
	for (int i = 0; i < b.len; ++i) {
		int carry = 0; //进位
		for (int j = 0; j < a.len; ++j) { //模拟乘法竖式，加上进位、错位
			int t = b.d[i] * a.d[j] + carry + c.d[i + j]; 
			c.d[i + j] = t % 10;
			carry = t / 10; //高位部分为新的进位 
		}
		if (carry) //b的每一位乘以a的最高位的数的进位 
			c.d[a.len + i] = carry % 10; 
	}  
	//两个非零因数相乘，积的位数要么是两个因数位数之和，要么是两个因数位数之和-1 
	c.len = a.len + b.len; 
	//检查最高位是否为0，如果为0，退一位
	//while循环可以保证即使因数是0也能输出正确的结果而不输出多余前导0 
	while (c.d[c.len - 1] == 0 && c.len - 1 >= 1) 
		--c.len;
	return c;
}
```
同样，要注意的是，==如果存在一个负数，要先记录其负号，取其绝对值代入函数；如果都是负数，和都是正数一样乘即可。==

---
### 5. 高精度与低精度的除法
这里的除法和小学学的除法一样。以 $1234 \div 7$ 为例子。
- $1$ 与 $7$ 比较，不够除，因此，该位商为 $0$，余数为1；
- 余数 $1$ 与新位 $2$ 组合成 $12$，与 $7$ 比较，够除，商为 $1$， 余数为 $5$；
- 余数 $5$ 与新位 $3$ 组合成 $53$，与 $7$ 比较，够除，商为 $7$， 余数为 $4$；
- 余数 $4$ 与新位 $4$ 组合成 $44$，与 $7$ 比较，够除，商为 $6$， 余数为 $2$； 
 
```
    0 1 7 6 (商)
  ----------
7 | 1 2 3 4 (bign)
      7
  ----------
      5 3
      4 9
  ----------     
        4 4
        4 2
  ----------
          2 (余数)
```
归纳每一步的步骤：上一步的余数乘以 $10$ 加上该步的位，得到该步临时的被除数，将其与除数比较（这里和减法一样）：如果不够除，则该位商 $0$；如果够除，商即为对应的商，余数为对应的余数。==最后一步注意除法后高位可能有多余的 $0$，要去除它们，但也要保证至少有一位数。==
```cpp
//高精度与低精度除法, 余数也是低精度的  
bign div(const bign &a, int b, int &r) { //a/b 会修改a, 因此传递结构体而不使用引用
	bign c;
	c.len = a.len; //被除数和商的每一位都是一一对应的，因此先令长度相等
	for (int i = a.len - 1; i >= 0; --i) { //从高位开始
		r = r * 10 + a.d[i]; //和上一位遗留的余数相组合
		if (r < b) c.d[i] = 0; //不够除, 该位为0
		else { //够除
			c.d[i] = r / b; //商
			r = r % b; //获得新的余数
		}
	}
	while (c.len - 1 >= 1 && c.d[c.len - 1] == 0)
		--c.len; //去除高位的0，同时至少保留一位最低位 
	return c; 
}
```
### 6. 高精度除法
这可能是最难的一部分了。但**其实和竖式运算的方法是如出一辙的，只不过这里的除数换成了一个数组，不能直接除罢了**。想想《计算机组成原理》中学到的CPU上建立除法运算的过程，几乎一样的。

被除数**从高位开始**，**和被除数对齐**，试商。但计算机不可能做“试商”，这时，我们可以采用减法来模拟：

$e.g.$ 举一个简单的例子， $1234 \div 28$：
- $28$ 和 $1234$ 从高位对齐，有 $1234 - 2800 \lt 0$，因此商的最高位为 $0$；
- $28$ 往右移动一位，有 $1234 - 280 \gt 0$，则利用 $1234$ 减去除数 $280$，一直减到被除数小于除数，减的次数
就是该位商的大小，商为 $4$，余为 $114$；
- $28$ 不动，有 $114 - 28 \gt 0$，则同上，得到商为 $4$，余 $2$。最终结果为商：$44$，余：$2$。

下面另一个例子，和前面的原理一样，==最麻烦的还是不能够直接就除，需要用减法来模拟。==
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200320220750743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
算法的步骤如下：
1、将除数移动和被除数最高位对齐，位数不够时，补0，
2、利用被除数减去除数，一直减到被除数小于除数，减的次数，就是“试商”的结果。
3、移动步数-1，重复上述步骤。

```cpp
void numcpy(const bign& b, bign& t, int rmove) { //数组右移使两个数组右端对齐
	for (int i = 0; i < b.len; ++i) 
		t.d[i + rmove] = b.d[i]; //对应的值右移n位赋给t.d数组 
	t.len = b.len + rmove; //注意长度, 减法需要
}
//高精度除法, 余数也是高精度的
bign superDiv(bign& a, bign& b) { //这里最终的a就是余数 
	bign c, temp;
	//两个非零因数相乘=除，商的位数要么是两个因数位数之差，要么是两个因数位数之差+1 
	c.len = a.len - b.len + 1; 
	//将除数移动, 与被除数最高位对齐需要的位数 
	for (int i = a.len - b.len; i >= 0; --i) { //用i控制移动的位数, 先是移动对齐最高位 
		memset(temp.d, 0, sizeof(temp.d)); //temp数组清0 
		numcpy(b, temp, i); //将除数b右移后复制给tmp数组，注意用i控制除数位数; 
		while (a.compare(temp) >= 0) {
			++c.d[i];         //减法模拟除法，并计数 
			a = sub(a, temp); //从a中减去一个temp 
		}
	} 
	while (c.d[c.len - 1] == 0 && c.len >= 2) //控制最高位的0 
		--c.len;
	return c;
}
```
## 4. 题目和总结和预告

 这里的代码有点浪费空间，用数组进行模拟，每个 $int$ 其实可以存放 $[0, 2^{31}-1]$ 范围内的数，这里就只能存放 $[0, 9]$；因此我们有两种改进的思路。
- 其一，我们用 $char$，不过不用 $char$ 数组，用 $string$，自带 $size()$，后面会写相应的模板代码的（逃）；
- 其二，我们还是用 $int$，不过不用数组，用 $vector$，亿进制（有的书也用万进制，不过还是太浪费，笑）！**逢亿进一，借一当亿**。我也会写一下。
- 最后，最简单的解决办法，使用 $java$ 的 $BigInteger$ 或者是 $python$。

这里的 $5$ 种，就是我知道的做高精度题目的方法。

最后要说的是，别看这里这样长，**这些操作的思想和竖式运算一模一样**，不过就是换成了高精度的乘数或除数后，有点麻烦罢了。

下面是洛谷的高精度的题目：
- P1601 A+B Promblem
- P2142 高精度减法
- P1303 A*B Problem
- P1255 数楼梯
- P1604 B进制星球

此外，还有hdu的1042和1061题。当然，在1061题，求 $n^n, n \ge 10^9$这种题目上，Java的 $BigInteger$ 也不能做了，没有试过 $python$——好久没有用它了啊。
