@[toc]


这一章说的是基本 `Scheme` 程序设计，重点是**构造过程抽象**。
- **基本表达式**，命名和环境
- 组合式的**求值**
- **过程**的定义
- **复合过程**求值的代换模型
- **条件表达式**和**谓词**
- 过程抽象
- 与C语言机制的比较 

黑盒抽象；约定接口；元语言抽象(控制复杂度的三个方法)

---
# 一. 构造过程抽象(1)
 
## 1. Scheme基础
`Scheme` 是**交互式语言**，其解释器运行时反复执行一个 "读入-求值-打印循环"(`Read-Evaluate-Print Loop` ，`REPL` )。每次循环：
- **读入**一个完整的**输入表达式**(即"一个程序")
- 对**表达式求值**(计算)，得到一个值(还可能有其他效果)
- **输出**求得的值(基本的值也是一个表达式)

`Scheme` 编程就是**构造各种表达式**(是一种“ 表达式语言”)，它由三类(**三个层次**的)编程机制组成：
- `基本表达式形式(Primitive Elements)`，是**构造各种程序的基础**
- `组合机制(Means of Combination)` ，用于**从较简单的表达式构造更复杂的表达式**
- `抽象机制(Means of Abstraction)` ，**为复杂的结构命名**，隐藏细节，使人可以通过简单方式使用

事实上，任何足够强大的编程语言都需要类似的三类机制。

另外，我们经常可区分`过程`(操作)和`数据`，本章主要研究过程的构造。下章则是构造数据抽象。

## 2. 与C语言对比
对比之下有这些区别：
- C是一个编译型语言
	- **程序有完整的结构**，表达式/ 语句不是程序，不能运行
	- **编制**好的程序需要经过**编译**(加工)后才能投入**运行**
- 从语言的结构看，C语言有
	- 描述**基本计算**的表达式
	- 描述**基本动作**的语句
	- 语句之上的**各种组合机制**(描述控制流)
	- 函数是语言里的**抽象机制**，用于把一段可能很复杂的计算抽象为一个简单形式的命令
 
- C语言严格地区分了“数据”和操作数据的“过程”(代码)
	- 在后面将看到，在 `Scheme`里，数据和过程(代码)可以**自然地相互转化**：数据可作为被执行的代码，代码可以作为被处理的数据。
	 

## 3. 简单表达式
看一些简单 `Scheme` 表达式及其计算：
- **数**是**基本表达式**(下面的 `>` 是提示符)
	```cpp
	> 235
	235
	```
- 简单算术表达式(简单`组合式Combination`)
	```cpp
	> (+ 137 248)
	385
	> (+ 2.9 10)
	12.9
	```
- 表达式的形式——**带括号的前缀形式**。
	- 括号里**第一个元素表示操作**(运算)，**后面是参数**(运算对象)；
	- **运算符和参数之间**、**不同参数之间**用空格分隔。

- 有些运算符**允许任意多个参数**：
	```cpp
	> (+ 2 3 4 29)
	38
	> (* 3 7 19 6 3)
	7182
	```
- 表达式可以**任意嵌套**：
	```cpp
	> (+ 2.9 (* 15 10))
	152.9
	```

- 可以写**任意复杂**的表达式(组合式)，如
`(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))`，复杂表达式难写难读。采用适当格式有利于正确书写和阅读，子表达式之间加入换行和空格符号不影响表达式的意义：
	```cpp
	(+ (* 3
		(+ (* 2 4)
			(+ 3 5)))
		(+ (- 10 7)
			6))
	```


> **C语言的表达式**：
>- C语言的表达式采用**中缀和前缀的混合形式**：
>    - 各种二元运算符和条件运算符(-:)采用**中缀形式**，运算符位于运算对象之间
>    - 函数调用是**前缀形式**，参数放在函数名后的括号内，逗号分隔
>- C  语言表达式的**表示形式不统一**，但更接近数学里的常规写法：
>   - 表达式的结构也**可以任意嵌套**
>    - 在写复杂的表达式时，也**应该采用某种格式良好的写法**
>- 由于采用中缀表示：
>    - **需要有括号机制**描述所需的运算顺序；
>    - **规定优先级**，可以减少一些写括号的麻烦；
>    - **不能表示多元运算**(如 + 和 和 *  等，只能是二元)；
>- 两种写法各有优点和缺点，需要习惯
 
 ---
## 4. 命名和环境
编程语言必须提供**为对象命名的机制**，这**是最基本的抽象机制**。

`Scheme` 把**名字标识符**称为**变量** ，其**值**就是与之关联的对象。

用 `define` 为对象值命名(给**名字关联一个值**)：
```cpp
> (define size 10)
```
可以**通过名字使用其关联值**，如：
```cpp
> size
10
> (* size 3)
30
```

可以用**任意复杂的表达式**描述要求**关联于变量的值**：
```cpp
> (define num (* size 30))
> num
300
```
如上，`num` 的值是 `300 ` 。实际上，`Scheme` 里的值可以是任何对象。
 
 
计算对象的结构可能很复杂，需要通过复杂费时的计算才能得到
- 如果每次使用时都重新计算，可能费时又费力；
- 给计算得到的结果命名，可以**很方便地多次使用**；

复杂程序通常就是为了计算(构造)出很不容易得到的对象：
- 通过**多步构造和命名**，分解构造过程，使之比较容易进行；
- 建立`名字-对象关联` 是其中最重要的抽象手段；

**构造的值可以存入变量**供以后使用，说明 `Scheme` 解释器有存储能力，这种存储称为“环境”：
- `define` 建立或修改环境中的 `名字-值关联`；
- **表达式在当前环境求值**，变量(名)的值由环境获得；
- `Scheme` **全局环境**预先定义了一批名字-对象关联，即有一批预定义的对象，主要是**预定义运算和各种过程**。我们无法准确区分，哪些是语言内建支持，哪些是指定义的过程。

> **C程序里的名字和环境**：
> - C语言没有明确的环境机制，但理解程序行为需要环境的概念：
>     - 函数、全局变量和其他**全局定义**写在代码表层。每个声明/定义给全局环境引进一个新名字(及其定义)；
>    - 函数可能有**局部定义**(参数、局部变量等)，执行**进入函数时建立局部环境**。函数里的复合结构可以有更局部的定义；
>    - **局部定义覆盖全局的同名定义**；内层局部定义覆盖外层同名定义；局部环境里的名字遮蔽外层的同名变量。
> - **表达式在当前环境中求值**，语句可能修改当前环境中有效定义的变量。
> - 注意 `Scheme`与C语言的重要差异：
>    - C变量需要定义，有类型；`Scheme` 无需说明变量，**变量无类型**；
>	- 类型确定变量可保存的值(静态性质，限定程序的动态行为)；
>	- 不说明类型，意味着**对取值的范围没有限制**(可存储任意的值)；
>	- **无类型变量带来灵活性**，也使 `Scheme` 不可能做静态类型检查


## 5. 组合式的求值
要求**求值的通常是组合式**，解释器的工作方式是：
- **求值**该组合式的**各个子表达式**；
- 将**最左子表达式的值**(运算符的值，应该是一个过程)作用于**相应的实际参数**(由**其他子表达式**求出的值)

上述规则说明计算过程的一些情况：
例：`(* (+ 2 (* 4 6)) (+ 3 5 7))`
- 组合式求值要求先求值子表达式。
因此**求值过程是递归的**(`Recursive Definition`)；
- 求值过程可以用树表示，先取得终
端(叶)**结点的值**后**向上累积**； 
- 最终**在树根得到整个表达式的值**；
- 树具有递归结构，递归处理很自然
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624230416523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70) 
组合式求值的递归**终将到达基本表达式**，**其值直接得到**：
- **数的值**是其自身(它们所表示的数值)；
- 内部**运算符等的值**是系统实现相关运算的指令序列；
- **其他名字的值由当前环境取得**，找到相应名字-值关联时取出对应的值，找不到就是错误。

如把运算符(如 `+` )和其他预定义对象(如 `define` )都看作名字；在环境中查找关联的值，统一后两种情况
- **环境**为程序里用的**名字**提供**定义**；
- 求值中遇到在当时环境里无定义的名字时报错。

**求值规则有例外**。如 `(define x 1)`  里的 `x`  不应该求值，是要求**为名字** `x` **关联一个新值**。说明 `define` **有特殊求值规则**：
- 有特殊求值规则的名字称为特殊形式( `special form` )。每个特殊形式有自己的求值规则。
- `Scheme` 有一组特殊形式，如 `define ` 。 

---
## 6. 过程定义
表达式可能变得很长，编程中经常出现重复或类似的表达式。**为控制程序复杂性，必须有抽象机制**，`Scheme` 用 "过程定义"实现这一点。

如求平方过程的定义：
```cpp
(define (square x) (* x x))
```
- 包括：**过程名，形式参数**，做什么(如何求值) 。
- 求值这种定义表达式 ，将**相应计算过程关联于名字**(这里的 `square` )

定义好的过程就**像基本操作**，可以通过名字使用：

```cpp
> (square (* (+ 3 7) 10)) ; 用于计算 用于计算
10000
> (square (* 3 (+ (square 2) 20))) ; 多次使用和嵌套 多次使用和嵌套
5184
> (define (sum-of-squares x y) ; 用于定义新过程 用于定义新过程
	(+ (square x) (square y)))
```
新定义的 `sum-of-squares` 又可以像内部操作一样用：
```cpp
> (sum-of-squares 3 4)
25
> (define (f a)
	(sum-of-squares (+ a 1) (* a 2)))
> (f 5)
136
```

**预定义基本过程**(操作)和特殊形式是**构造程序的基本构件**。可以根据需要，通过定义过程扩大这一构件集。从使用上完全看不出 `square` 是基本操作还是用户定义过程。**复合过程的使用方式和威力与基本操作一样**，是很好的语言特征。
 
过程定义是**分解和控制程序复杂性**的**最重要技术之一**。


## 7. 过程应用的代换模型(简化模型)
**组合式和复合过程**确定的计算过程是代换模型：
- ① 求出**各实际参数表达式**(子表达式)**的值**；
- ② 找到**要调用的过程的定义**(根据第一个子表达式的求值结果)；
- ③ 用**求出的实际参数**代换过程体里的**形式参数**；
-  ④ 求值过程体

例：

```cpp
;用原过程体(sum-of-squares (+ a 1) (* a 2))代换得到:
(f 5)  
(sum-of-squares (+ 5 1) (* 5 2)) 

;求值实参并代入过程体, 得到: 
(+ (square 6) (square 10))  
;求值实参并代入过程体, 得到:
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
```


代换模型给出了过程定义和过程应用的**一种语义**：
- 很多 `Scheme` 过程的行为可以用这个模型描述；
- 后面会看到，更复杂的过程需要用**扩充的语义模型**。


注意：代换模型只是为了帮助**直观理解过程应用的行为**：
- 它并没有反映解释器的实际工作过程；
- 实际解释器的情况后面讨论，基于环境实现；

这本书中要**研究解释器工作过程的一组模型**之中：
- 代换模型最简单，容易理解，但不足以解释所有的实际程序；
- 其局限性是**不能解释带有可变数据的程序**；
- 后面将介绍更精细的模型。
 
## 8. 应用序和正则序求值
解释器**先求值子表达式**(运算符和各运算对象)，而后把得到的运算应用于运算对象(实际参数)。这一做法合理，但合理的做法不唯一。

另一方式是**先不求值运算对象**，推迟到需要时再求值。按这种方式求值 `(f 5)` ，得到的计算序列：(`先展开，后归约`)

```cpp
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2)) )
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))

(+ (* 6 6) (* 10 10))
(+ 36 100)
136
```

前一方式(先**求值参数**后**应用运算符**)称为应用序求值，后一方式(完全展开之后归约)称为正则序求值。<b><font size ="3" color="red">Scheme采用应用序求值。</font></b>

## 9. 语言表达式求值
表达式求值过程就是**表达式语义的实现**。

### (1) `C`语言表达式求值
- 通过运算符的**优先级、结合性、括号**等确定计算顺序；
- 子表达式求值方式**由运算符确定**(见下)。

大部分一元/二元运算符和函数调用**采用应用序求值**：
- 先求值**作为运算对象的子表达式**；
- 而后将运算符作用，得到运算结果；
- 是递归定义的；

几个特殊运算符有各自的特殊求值规则：
- `||` 和 `&&`  先求值左边运算对象，可以确定结果就结束；
- 条件运算符 `-:` 先求值条件，而后根据条真假选择求值一个子表达式；
- 顺序运算符，先求值左边子表达式，而后求值右边子表达式；
- 各种赋值运算符和增量/ 减量运算符，被赋值变量不求值


### (2) 运算对象的求值顺序
`Scheme` 组合式可以有**多个子表达式**；C 的二元运算符有**两个运算对象**，过程**可能有多个参数**。

它们按什么顺序求值？无论是 `C`  还是 `Scheme`，都**没规定运算对象的求值顺序**。这意味着：
- 假定它们采用某种特殊顺序都是不正确且不可靠的；
- **不要写只有按特定求值顺序才能得到所需结果的表达式**！
- C语言里依赖于求值顺序的表达式：
	```cpp
	m = n++ + ++n;
	printf("%d, %d", n, n++);
	```
	这种东西“没有意义”(C语义没定义它们的语义)。


## 10. 条件表达式和谓词
复杂计算的描述中总需要**描述条件和选择**。`Scheme` 有**条件表达式**。绝对值函数可定义为：
```cpp
(define (abs x)
	(cond 
		((> x 0) x)
		((= x 0) 0)
		((< x 0) (- x))
	)
)
```
 
条件表达式的一般形式：
```cpp
(cond (<p1> <e1>) ;依次求值各个p(条件), 遇到第一个非
	  (<p2> <e2>) ;false的条件后求值对应的e, 以其值
	  ...		  ;作为整个cond表达式的值
	  (<pn> <en>)
)
```

绝对值函数还可定义为：
```cpp
(define (abs x)
	(cond ((< x 0) (- x))
		  (else x) ;else表示永远成立的条件, 只应放在最后
    )
) 				
```
简化的条件表达式形式：

```cpp
(if <predicate> 
	<consequent> 
	<alternative>)
```
一个求值整数区间和的过程如下：
```cpp
> (define (sumInt A B)
        (if (> A B)
                0
        (+ A (sumInt (+ 1 A) B))))
> (sumInt 1 5)
15
```

`cond` 和 `if` 都是特殊形式，有特殊的求值规则都是特殊形式，有特殊的求值规则。



---
**逻辑组合运算符** `and` 和 `or`  也是特殊形式，采用特殊求值方式。
```cpp
(and <e1> ... <en>)
```
逐个求值 `e` ，直到某个 `e` 求出假，或最后一个 `e` 求值完成。以**最后求值的那个子表达式的值**作为值。 
```cpp
(or <e1 > ... <en >)
```
逐个求值 `e` ，直到某个 `e` 求出真，或最后的 `e` 求值完成。以最后求值的那个子表达式的值作为值。

```cpp
(not <e>)
```

如果 `e` 的值不是真，就得真，否则得假。

求出真假值的过程称为 `谓词` 。各种关系运算符是基本谓词，可以用 `and`、`or` 、`not` 组合出各种复杂逻辑条件，可以用过程定义谓词。

## 11. 过程定义实例：牛顿法求平方根
过程很像数学函数，但它必须了**描述一种有效的计算方法**。

在数学里平方根函数通常采用**说明式的定义**：
$$\sqrt{x}\ \text{is the } y\ \text{such that } y\ge 0\ \text{and } y^2 = x$$
基于它写出的过程定义没有意义(没给出计算平方根的有效方法)：
```cpp
(define (sqrt x)
	(the y 
		(and (>= y 0) (= (square y) x))
	)
)
```

牛顿法采用猜测并不断改进猜测值的方式，做到满意为止。例如选初始猜测值 `1` 求 `2` 的平方根(改进猜测值的方法是求平均)：
```cpp
1  		(2/1) = 2  			((2 + 1)/2) = 1.5
1.5  	(2/1.5) = 1.3333  	((1.3333 + 1.5)/2) = 1.4167
1.4167  (2/1.4167) = 1.4118 ((1.4167 + 1.4118)/2) = 1.4142
1.4142 ......
```
继续这一过程，直至结果的精度满足实际需要。
 
牛顿法求平方根用 `Scheme` 实现：
- 从要求开平方的数和初始猜测值 `1`  开始；
- 如果猜测值足够好就结束；
- 否则就改进猜测值并重复这一过程。

写出的过程：

```cpp
(define (sqrt-iter guess x)
	(if (good-enough? guess x)
		guess
		(sqrt-iter (improve guess x) x)
	)
)
```

一种“ 改进” 方式是用**猜测值**和**被开方数除以猜测值**的**平均值**：

```cpp
(define (improve guess x)
	(average guess (/ x guess))
)
```

需要确定一个“足够好”的标准。如：

```cpp
(define (good-enough? guess x)
(< (abs (- (square guess) x)) 0.001))
```

用 `sqrt-iter` 定义 `sqrt` ，选初始猜测(这里用 `1`)：
```cpp
(define (sqrt x)
(sqrt-iter 1.0 x))
```

一些试验：

```cpp
> (sqrt 9)
3.00009155413138
> (sqrt (+ 100 37))
11.704699917758145
> (sqrt (+ (sqrt 2) (sqrt 3)))
1.7739279023207892
> (square (sqrt 1000))
1000.000369924366
```

牛顿法是典型的迭代式计算过程，这里用递归方式实现。它定义了几个辅助性过程，利用它们把一个复杂问题分解为一些更容易控制的部分。每个过程都有明确逻辑意义，可以用一句话明确说明。
 
---
很容易写出对应于上面 `Scheme` 程序的 C  程序。如

```cpp
int good_enough (double guess, double x) { 
	return fabs(guess*guess - x) < 0.0001; 
}
double average (double x, double y) { 
	return (x + y) / 2; 
}
double improve (double guess, double x) {
	return average(guess, x/guess);
}
double sqrt_iter (double guess, double x) {
	return good_enough(guess, x) ? guess : sqrt_iter(improve(guess,x), x);
}
double sqrt (double x) { 
	return sqrt_iter(1.0, x); 
}
```

这是在 `C`  语言里做函数式程序设计(没有赋值)。

C函数定义和 `Scheme` 过程定义的不同：
- C语言里**计算过程的抽象机制是函数**；
- C函数定义与 `Scheme` 过程定义的不同；
- **需要类型描述**(参数和返回值和变量一样有类型)；
- 用 `return` 语句描述返回值，没有 `return` 就没有返回值。

C语言的表达式和语句：
- 表达式是有关计算的描述，运行中每个表达式都算出一个值；
- 语句是命令，要求做一个动作。动作没有“值”的概念；

`Scheme` 基于表达式，**其中的每种结构都是表达式**：
- 计算就是求值，**计算一个表达式就要求出它的值**；
 
C语言(和其他常规语言)的**基本结构单元是语句**，表达式只是语句的组成部分，不能独立存在。

 
到现在为止，很容易用C语言模拟 `Scheme` 程序，后面将越来越不容易。但是贯串本书的思想仍然很有参考价值。
 
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200625223930196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
