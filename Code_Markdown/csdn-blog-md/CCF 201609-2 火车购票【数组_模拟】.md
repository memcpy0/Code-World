**问题描述**
　　请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。
　　假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。
　　购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。
　　假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。
**输入格式**
　　输入的第一行包含一个整数 $n$ ，表示购票指令的数量。
　　第二行包含 $n$ 个整数，每个整数 $p$ 在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。
**输出格式**
　　输出 $n$ 行，每行对应一条指令的处理结果。
　　对于购票指令 $p$ ，输出 $p$ 张车票的编号，按从小到大排序。
**样例输入**

```cpp
4
2 5 4 2
```

**样例输出**

```cpp
1 2
6 7 8 9 10
11 12 13 14
3 4
```

**样例说明**
　　1) 购2张票，得到座位1、2。
　　2) 购5张票，得到座位6至10。
　　3) 购4张票，得到座位11至14。
　　4) 购2张票，得到座位3、4。
**评测用例规模与约定**
　　对于所有评测用例，$1 ≤ n ≤ 100$ ，所有购票数量之和不超过100。

---
### 解法 模拟
比较麻烦的模拟题，幸好数据规模很小，可以随便写：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, p;
bool s[21][6];
int main() {
	cin >> n;
	for (int i = 0; i < n; ++i) {
		cin >> p;
		int j, k, be;
		bool flag = false;
		for (j = 1; j <= 20; ++j) {
			int cnt = 0;
			for (k = 1; k <= 5; ++k) {
				if (s[j][k] == false) ++cnt;
				else {
					if (cnt >= p) break;
					else cnt = 0;	
				}
			}
			if (cnt >= p) {
				flag = true;
				be = k - cnt;
				break;
			}
		}
		vector<int> ans;
		if (flag) { // 有相邻的位置
			for (int t = 0; t < p; ++t) {
				s[j][be + t] = true;
				ans.push_back((j - 1) * 5 + be + t);	
			}
		} else {
			for (int j = 1; j <= 20 && p; ++j) {
				for (int k = 1; k <= 5 && p; ++k) {
					if (s[j][k] == false) {
						s[j][k] = true;
						--p;
						ans.push_back((j - 1) * 5 + k);
					}
				}
			}
		}
		for (int j = 0; j < ans.size(); ++j)
			printf(" %d" + !j, ans[j]);
		cout << endl;
	}
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/3387724488ff4e3fb31d2aca2c7fcbdf.png)

