@[toc]
总时间限制:
    1000ms
内存限制:
    65536kB

**描述**

 人生来就有三个生理周期，分别为体力周期、感情周期和智力周期，**它们的周期长度分别为**23天、28天和33天。每一个周期中有一天是高峰。在高峰这天，人会在相应的方面表现出色。例如，在智力周期的高峰，人会思维敏捷，注意力容易高度集中。因为三个周期的长度不同，所以通常三个周期的高峰不会落在同一天。对于每个人，**想知道何时三个高峰落在同一天**。对于**每个周期**，会给出从当前年份的第一天开始，到出现高峰的天数（不一定是第一次高峰出现的时间）。给定一个从当年第一天开始的天数，你的任务是输出从给定时间开始（不包括给定时间），**下一次三个高峰落在同一天的时间**（距给定时间的天数）。例如：给定时间为10，下次出现三个高峰同一天的时间是12，则输出2（注意这里不是3）。

**输入**
    输入包含多组数据，每一组数据由四个整数组成，数据以-1 -1 -1 -1 结束。
    对于四个整数p, e, i和d，p, e, i分别表示体力、情感和智力高峰出现的时间（时间从当年的第一天开始计算）。d是**给定的时间**，可能小于p, e或i。**所有给定时间是非负的并且小于或等于365**，**所求的时间小于或等于21252**。

**输出**
    **从给定时间起**，下一次三个高峰同一天的时间（距离给定时间的天数）。

**样例输入**

    0 0 0 0
    0 0 0 100
    5 20 34 325
    4 5 6 7
    283 102 23 320
    203 301 203 40
    -1 -1 -1 -1

**样例输出**

    Case 1: the next triple peak occurs in 21252 days.
    Case 2: the next triple peak occurs in 21152 days.
    Case 3: the next triple peak occurs in 19575 days.
    Case 4: the next triple peak occurs in 16994 days.
    Case 5: the next triple peak occurs in 8910 days.
    Case 6: the next triple peak occurs in 10789 days.

**来源**：East Central North America 1999 

**题意**：分别给出三个周期的出现时间和起始时间点`d`，找到$\gt d \  \&\& \leq d +21252$的一天，是下一个三个周期同时出现的日子。

**思路**：三个周期的出现时间不同——如果给出的三个周期的出现时间相同，找到下一个同时出现的时间，就很简单，无非是三个数的最小公倍数，我们注意到$23*28*33=21252$，这就是第一个例子。

方法就是枚举。

### 写法一 直接枚举
直接枚举有几个坑。
- 题目说**所有给定时间是非负的并且小于或等于365**，**所求的时间小于或等于21252**，即$p,e,i,d \geq 0 \ \&\& \leq 365$，而且找到的那一天$k$ 距离 给定的$d$，有$k - d \leq 21252$。因此，时间轴的遍历，应该是$d+1$到$d+21252$。
- $d$可能小于$p, e, i$，因此$(k - p), (k-e), (k-i)$可能小于0，当然这不算什么，对取余没影响。

从$d+1$开始，到$d+21252$，枚举每一天$k$，看这一天是否是三个周期——即是否满足`(k - p) % 23 == 0 && (k - e) % 28 == 0 && (k - i) % 33 == 0`。
```cpp
#include <iostream>
using namespace std;
#define N 21252
int main() {
	int p, e, i, d, caseNo = 0;
	while (~scanf("%d%d%d%d", &p, &e, &i, &d) && p != -1) {
		for (int k = d + 1; k <= d + N; ++k) {
			if ((k - p) % 23 == 0 && (k - e) % 28 == 0 && (k - i) % 33 == 0) {
				printf("Case %d: the next triple peak occurs in %d days.\n", ++caseNo, k - d);
				break;
			}
		}
	}
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200313143914876.png)
### 写法二 枚举优化（跳着搜索）
```cpp
#include <iostream>
using namespace std;
#define N 21252
int main(){
	int p, e, i, d, caseNo = 0;
	while( cin >> p >> e >>i >>d && p!= -1) { 
		int k;
		for(k = d + 1; (k - p) % 23; ++k); //从给定的d+1天开始找到第一个体力高峰k
		for(; (k - e) % 28; k += 23);  //对每个体力高峰, 判断是否是情感高峰 
		for(; (k - i) % 33; k += 23 * 28); //对每个体力情感高峰, 判断是否是智力高峰
		printf("Case %d: the next triple peak occurs in %d days.\n", ++caseNo, k - d);
	}
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020031315313281.png)

### 最后
这个题目还有一个通解，利用数论的中国剩余定理(孙子定理)。不过我还不太了解这方面的知识，所以只提一下。
