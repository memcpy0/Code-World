> 本文属于「软件工程学习实践」系列文章之一，这一系列着重于「软件工程知识的学习与实践」。由于文章内容随时可能发生更新变动，欢迎关注和收藏[软件工程系列文章汇总目录](https://memcpy0.blog.csdn.net/article/details/121620681)一文以作备忘。需要特别说明的是，为了透彻理解与运用软件工程的相关知识，本系列文章中参考了诸多博客、教程、文档、书籍等资料，限于时间精力有限，这里无法一一列出。部分重要资料的不完全参考目录如下所示，在后续学习整理中还会逐渐补充：
> - 软件工程——面向对象和传统的方法（第8版） *Object-Oriented and Classical Software Engineering (8th Edition)* ，[美] `Stephen R. Schach` 著，邓迎春、韩松等译
> - 软件工程——理论与实践（第4版影印版）*Software Engineering: Theory and Practice (4th Edition)* ，[美] `Shari Lawrence Pfleeger, Joanne M. Atlee` 著，高等教育出版社 
> - 软件工程 第四版，齐治昌、谭庆平、宁洪编著，高等教育出版社

@[toc]

---
在本章，我们来看一下：
- **软件工程**意味着什么
- 软件工程的发展
- **好软件**意味着什么
- 一个系统方法为什么重要
- 自20世纪70年代来软件工程的变化

**软件遍及我们的世界**，有时，我们把「软件在使我们的生活更舒适、有效率的过程中所扮演的重要角色」视为当然。例如，考虑为早餐准备烤面包这样的简单任务。烤箱中的代码控制面包变褐的程度及何时成品出箱，程序调控屋子的供电，软件为我们的能源消费记帐。实际上，我们可能使用自动程序付电费、定购更多杂货甚至买新的烤箱。事实上，现在，软件或者显式的、或者在幕后，为我们生活的各方面服务，包括那些影响我们健康和财富的重要系统。因此，**软件工程显得比以往更加重要**。好的软件工程的实施，必须确保软件在引导我们的生活中做出积极的贡献。

本书着重于软件工程中的关键问题，描述了我们所知道的有关技术和工具方面的东西，以及它们是怎样影响我们建造和使用的那些产品。我们从理论和实践上来看一看：我们知道的东西、它如何应用于一个典型的软件开发或维护工程中的。我们也检查一下还不知道的东西，而这些东西将有助于使我们的产品更可靠，安全、有用和易于理解。

从考虑我们**怎样分析问题和提出解决方案**方面着手。然后我们研究一下**计算机科学问题和工程问题间的差异**。而最终的目标是**得到生成高质量软件的方案**，并且我们还考虑为这种质量做出了贡献的特征。

我们也着眼于**我们作为软件系统开发者已有的成败**。通过检查几个软件失败的例子，我们来弄明白我们已经走得多远、及为了掌握质量软件开发的艺术，我们还将必须走更远。

接着，我们考虑一下**与软件开发相关的人**。在描述**顾客、用户和开发者**的角色和职责后，我们研究系统本身。我们知道一个系统可被视作与一活动集相关、并用某种边界封装的一组对象。作为选择，我们用一个工程师的眼睛来看待一个系统；开发一个系统恰似修建一座房屋。在确定了**建立系统的系列步骤**后，我们讨论**开发小组在每步中的角色**。

最后，我们讨论一些已经对我们实施软件工程的方式，产生影响的那些变化。我们介绍Wasserman的八条思想，把我们的实践联系在一起，以形成一个连贯的整体。

# 1.1 什么是软件工程？
作为软件工程师，我们运用计算机和计算的知识来帮助解决问题。通常要处理的问题与计算机或现存计算机系统有关，但有时，问题中的潜在困难与计算机没有关系。因此，**首先理解问题的本质是很重要的**。特别地，我们必须要小心，不要把计算机和技术强加于我们遇到的每个问题上。**首先必须解决这个问题，然后如果需要，再使用技术作为工具来实现我们的解决方案**。在本书其他部分，我们假定我们的分析已经表明，某些种类的计算机系统，对解决手头的一类特别问题是必须且使人满意的。

## 解决问题
大多数问题是庞大的，有时处理起来棘手，特别是，如果它们提出了某些以前从没解决过的新东西。因此我们必须通过分析来对它开始进行调查，也就是**把问题分解成我们能理解并尽量处理的问题片**。因而，我们**能把这个大问题用小问题集和它们间的相互关系来描述**。图1.1解释了如何分析。重要的是要记住**关系**（图中的箭头，及子问题的相对位置）**跟子问题本身一样重要**。有时，正是关系保持着怎样解决大问题的线索，而不简单是子问题的本身特性。

一旦分析了问题，我们必须**从表述问题各方面的部件来构建解决方案**。图1.2解释了这个相反的过程：综合(`Synthesis`)，就是从小建筑块装配成一个大建筑。**随着分析，单个解决方案的合成可能跟寻找这些方案本身一样富有挑战性**。为了弄清为什么，考虑写一本小说的过程。字典包含了所有你可能想在作品里使用的词。但是，写作最困难的部分就是决定怎样组字成句，同样的，组句成段、章以形成这部完整的书。因此，**任何解决问题的技巧必须有两部分：分析问题以弄清它的本质，然后基于分析综合/合成出一个解决方案**。
 

 
为了有助于解决问题，我们使用各种方法（method）、工具（tool）、程序（procedure）及范例（paradigm）。一种方法（method/technique）就是一种用于产生某种结果的正式的程序（procedure）。例如，一个厨师准备调料时，他使用一系列成分并结合一套仔细排好的时、序步骤以便调料变浓但又不凝固或分散。准备调料的程序与时间选择和成分有关但可能并不依赖于使用何种类型的烹饪设备。
一件工具（tool）是一件能以更好的方式完成某件事情的设备或自动化系统。在这里“更好方式”可能意味着这件工具使用我们更准确、更有效率、或更多产、或增强了所得产品的质量。例如，我们使用打字机或键盘和打印机来写信是因为所得文档比手写更易于阅读。或者我们用一把剪刀作为一种工具是因为比起撕一张纸使用剪刀会剪得更快更直。然而，工具并不总是更好地做某件事所必须的。例如，一个烹饪方法能做出更好的调料而不是厨师所使用的罐也非勺。
一个程序（procedure）就象一个秘诀：是一致地产生特别产品的工具和方法的组合。打个比方，就象将在后面章节看到的，我们的测试计划描述了我们的测试程序；它们告诉我们在何种情形下用何种工具作用在何种数据集上以便让我们检查出软件是否满足要求。
最后，范例就象一种烹饪风格；它提供了一个特别的构建软件的方案或哲学。恰就象我们能区别出法国烹饪和中国烹饪一样，我们也能区别出象面向对象开发和过程化开发这样的范例。一种范例比不比另一个好；每一种都有它自己的优势和劣势，一个比另一个更恰当是有条件的。
软件工程师使用工具、方法、程序和范例来增强他们软件产品的质量。他们的目标就是使用有效的富有成果的途径来产生有效的问题解决方案。在后续几章中，我们将突出一些支持我们所述的开发维护活动的特别途径。
最新的一套工具和方法的指示器本书相关WWW主页上。
软件工程师的位置
为了理解一名软件工程师是怎样适合计算机世界的，让我们举例看一下另一学科。考虑化学研究和它对解决问题的作用。化学家调查化学制剂：结构、相互的作用及在行为后的原理。药剂工程师把化学家的研究运用于各种问题。化学被化学家视为研究对象。另一方面，对药剂工程师来说，化学是一门工具，被用于解决一般的问题（可能甚至在本质上不是“化学的”）。
我们可同样地看待计算。我们可能关注于计算机和程序语言本身，或者我们视它们为工具被用于设计、实现一个问题解决方案。软件工程是从后者角度来看的，就象如图1.3所示。一名软件工程师集中于把计算机作为一个解决问题的工具，而不是调查硬件的设计或证明有关算法如何工作理论。我们会在本章后面看到一名软件工程师把计算机的功能作为一般解决方案的一部分，而非计算机自身的结构或理论。



 
1.2 我们已经取得的成功
	写软件既是一门科学也是门艺术，作为一名计算机科学的学生理解这是为什么是很重要的。计算机科学家和软件工程研究员研究计算机机制，和理论化有关怎样使计算机多产有效。然而，他们也设计计算机系统并写程序以便在那些系统上能执行任务，这是一项很有艺术性、独创性、技巧性的实践工作。在一个特定的系统上或许有许多执行任务的方式，但一些比另外的更好。一种方式可能更有效率、更精确、更易修改、更易使用或更易理解。任何黑客能写出使用某物工作的代码，但是要产生健壮的、易于理解和维护、其工作起来尽可能最有效率和效果的代码，是需要有专业软件工程师的技能和理解力的。从而，软件工程将设计和开发高质量的软件。
	在调查出完成高质量软件系统要具备的东西前，让我们回顾一下我们已经取得的成功。用户对现存的软件系统满意吗？是也不是。软件使我们能比以前任何时候更快更有效的执行任务。想一下，在，例如字处理软件、电子表格软件、电子邮件、精巧电话，出现前的生活。软件在医学、农业、运输和其他大部分行业支持着生命维系或生命救治方面的进步。另外，软件已经使我们能做我们以前从没做过的事情：显微外科、多媒体教育、机器人技术……。
然而软件不是说没有自身的问题。通常系统运行却不是严密地按我们所期望的那样。我们所有人都听说过有些系统几乎就不能工作的事情。我们都写过不完善的程序：一些仍然包含失误的代码，而在偶然的评定或在只是演示一个方案可行性的时候这样的代码又是够好的。显然，在开发一个交付给用户使用的系统的时候，此种行为是不可接受的。
一类工程的一个错误与一个大的软件系统中的一个错误二者间是有很大差别的。实际上，（人们）在文献里或走廊里频繁讨论软件故障和生产无故障软件面临的困难。一些故障仅仅有点让人讨厌；而别的将花费大量的时间和金钱。还有些甚至威胁生命。补充栏1.1解释了故障（fault）、错误（error）和失败（failure）间的关系。让我们看一些失败的例子，注意发生了什么故障及为什么会这样。

























在20世纪80年代，美国国税局（IRS，the United States Internal Revenue Service）雇请Sperry公司建立联邦收入税表格自动处理系统。按照华盛顿邮报（Washington Post）的说法，“已经证明系统不足以应付工作量，并且花费了预期的近两倍的费用，不久必须被替换”（Sawyer 1985）。在1985年，为了增强原本价值1亿零3百万美元的Sperry设备又追加了9千万美元。另外，因为那些问题妨碍了在最后期限里向纳税者返还退款，IRS被迫支付了4千零2百万美元的利息及2千2百3十万美元的雇员的加班费（雇员一直努力跟上工作进度）。在1996年，形式仍没有改观。洛杉矶时报在三月二十九号报到说对于IRS的计算机现代化工作仍然没有任何高明计划，仅仅是一份6000页的技术文档。国会议员Jim Lightfoot把这项工程称为“因为计划不充分导致的仍在挣扎着的40亿美元的大惨败”（Vartabedian 1996）。我们将会在第二章看到为什么项目计划对质量软件生产是重要的。
多年来，公众在日常生活中没有异议地接受软件的灌输。但里根总统提出的“星球大战（SDI）”提升了公众对生产无故障软件系统的认识。流行报纸杂志报到表达出了在计算机科学领域的怀疑。现在，20年后，当请求美国国会为建立类似系统配发资金的时候，许多计算机科学家和软件工程师仍然相信没有任何保证充分可靠性的编写及测试软件的办法。
例如，许多软件工程师认为一个反弹道导弹系统将至少需要1千万行代码；有些估计要达到1千万行。比较起来，支持美空间航天飞行的软件至少由三百万行代码组成，包括地面上控制发射和飞行的计算机；在1985年，航天飞机（Rensburger 1985）自身有约10万行代码。因此一个反导软件系统将需要测试惊人数量的代码。而且，可靠性约束将没法测试。为了弄清为什么，考虑一下临界安全（safety-critical）软件的概念。典型地，我们说某物是临界安全（safety-critical）（例如，某物失败将对生活或健康产生威胁）的那么它至少应当有10（-9）的可靠度。象我们将在第9章看到的，这条术语意味着在10(9)小时运行中失败不能超过一次。为了观测这种程度的可靠度，我们必须运行系统至少10(9)小时以验证它没有失败。但是10(9)小时超过了114,000年——作为测试期太太长了。
我们也将在第9章看到，如果软件设计和编写不适当，有用的技术也会变得致命。例如，当Therac-25，一台化疗和X射线机，发生故障并杀死了几名病人时，医学界一片震惊。软件设计师没有预料到几个箭头键的非标准使用方式；结果，当想使用低水平剂量时，软件保持了高水平剂量的设置并发出了一束非常集中剂量的辐射。
飞行员杂志（Pilot）发表并在风险论坛（Risks Forum,Pilot 1996）报告了一个不曾预料到的使用和带来的后果的类似而危险的例子。两名苏格兰洛锡安边境区警官正在贝里克郡的荒野用雷达枪识别超速驾车者。突然他们的雷达枪锁定在速度指示超过300英里/小时处，数秒后，一架低空飞行的“鹞”式飞机飞来。这架“鹞”式飞机的目标搜索器已经识别出雷达并认为它是“敌人”的；幸运的是，这架“鹞”式飞机是非武装操作的，因为正常的行为是发射一枚自动报复性导弹！
系统不曾预料的使用应该在整个软件设计活动中考虑到。这些使用至少以两种方式处理：运用想象思考系统会怎样被滥用（跟正确使用一样），假定系统将被滥用并设计软件处理这种滥用。我们将在第八章讨论这样的方案。
尽管许多商家致力于无漏洞软件，但实际上大多的软件产品并不是远离故障的。市场力量鼓励开发者迅速交付产品，几乎没有时间彻底测试。典型的，测试小组仅能测试出最可能使用的功能，或最可能会危及、激怒用户的功能。因此，许多用户提防安装第一版代码，知道直到第二版出来前“臭虫”是不能被解决的。此外，对已确知的故障的修改有时是如此的困难以致于使得重写整个系统比修改现存代码要容易。我们将在第十一章研究软件维护的相关问题。
尽管生活中软件取得了一些非凡的成功得到了全面的认可，我们所生产的软件的质量仍然还有很大的改进空间。例如，质量缺乏变得很昂贵；故障不被觉察的时间越长，纠正起来就越昂贵。特别地，据估计，在项目初始分析过程中纠正一个犯下的错误的代价仅是在系统交付给顾客后再纠正类似的一个错误所费代价的十分之一。不幸的是我们没有在早期就抓住大部分的错误。用于测试维护期间发现的错误的纠正费用半数来源于系统生命的早期。在第十二、十三章我们考虑评价开发活动效果、改进尽早捕错过程的方式。
我们将提议的简单但强有力的技术之一就是回顾与检查的运用。许多学生习惯于独自开发、测试软件。但他们的测试效果可能比他们想象的要差。例如，Fagan研究了过去检测错误的方法。他发现通过给定测试数据并运行程序所检测出的错误仅是系统开发过程中所发现错误的五分之一。然而，同样回顾起来，同事间检查评价彼此的设计和编码，能揭开所有已发现错误的其余五分之四（Fagan，1986）。因此，仅请同事来回顾一下你工作，你的软件质量就会有戏剧性的提高。在后面的章节中，我们将学到更多这样的东西：怎样将回顾和检查过程运用于每一主要的开发步骤之后以尽可能早地发现、确定错误。我们将在第十三章了解怎样改善检查过程本身。
1.3 什么是好的软件？
	正象厂商想办法保证他们生产的产品质量一样，软件工程师也必须找到确保产品具有合意的质量和效用的方法。因此，好的软件工程必须总是包括生产质量软件的策略。但在我们想出一个策略前，必须理解质量软件意味着什么。补充栏1.2显示设想是怎样影响“质量”的意思的。在本节，我们研究是什么把好软件和坏软件区分开来的。






























Kitchenham和Pfleeger（1996）在一份《IEEE软件》的质量特刊的介绍中研究了此问题的答案。他们提出上下文（环境）有助于确定答案。在字处理软件中所能容忍的错误在临界安全或临界事务系统中就不能接受。因此，我们必须至少以三种方式考虑质量：产品质量，导致产品的过程的质量，处于它将适用的商业环境上下文中的产品的质量。
产品质量
我们可以请人们说出对软件全面的质量作出贡献的特征，但我们很可能会从我们所问的所有人那里得到不同的答案。产生这样的差别是因为特征的重要性依赖于谁在分析软件。如果软件以一种易于理解易于使用的方式完成了使用者想做的事那么使用者认为它是高质量的。然而，有时质量和功能是互相盘绕的；如果某软件难以理解或难以使用，但因它的功能而值得这样，那么它仍然被认为是高质量的。
我们设法测度软件质量，因此我们可能将一个产品和另外一个相比较。为此，我们指定一些对全面质量作出贡献的特别的方面。从而，在测度软件质量时，用户评定诸如失败次数和失败类型这样的外在特征。例如，他们可能把失败确定为次要、主要和灾难性的，并希望发生的任何失败仅是次要的。



 软件也必须由设计和编写代码的人以及程序完成后负有维护职责的人来评价。这些从业人员倾向于考虑产品的内部特征，有时甚至是在产品交付给用户之前。特别地，从业者考虑故障数量和类型作为产品质量（或缺乏）的论据。例如，开发者跟踪在需要、设计、编码检查中出现的故障的数量并用它们作为最终产品可能的质量的指示器。
因此，我们经常建立将用户外部视角和开发者的内部视角关联起来的模型。图1.5是早期质量模型的一个例子，这个模型由McCall和他的同事们建立的，显示了外部质量因素（左侧）是怎样与产品质量标准（右侧）相关的。McCall将每个右侧标准与一个指示着所表达的质量元素的程度的指标联系起来（McCall，Richards，和Walters 1977）。我们将在第十二章研究几个产品质量模型。
过程质量
	有许多活动影响最终产品质量；如果任何一些活动走偏，产品质量将受到损害。因此，许多软件工程师觉得开发和维护过程的质量跟产品质量同等重要。为该过程建模的优点之一就是我们能检查它并想法子改进它。例如，我们可以问如下的问题：
	何时何地我们可能发现一个特定种类的故障？
	在开发过程中怎样较早地发现故障？
	我们怎样固定故障容忍度以便我们最小化一个故障成为失败的可能性？
	有替代活动使得过程更有效（率）确保质量？
这些问题可适用于整个开发过程或子过程，象配置管理、重用或测试；我们将在以后章节研究这些过程。
在20世纪90年代，在软件工程中过程建模和过程改进是极力宣扬的焦点。受Deming和Juran的工作所启示，由IBM之类的公司实现，过程指导方针——如能力成熟度模型（CMM），ISO 9000和软件过程改进和能力检测（SPICE）——建议通过改进软件开发过程，我们就能改进因而产生的产品的质量。在第二章，我们将了解怎样确定相关过程活动及如何将他们对中间和最终产品的影响建立模型。第十二、十三章将深入地检查过程模型和改良结构。
商业环境上下文中的质量
	当质量评估的焦点放在产品和过程上时，我们常常用涉及故障、失败和时间选择的数学表达式来度量质量。而范围扩展到包括商业观点的情况是很少的，而在商业方面，是通过软件所内嵌的商业环境提供的产品和服务来衡量质量的。就是说，我们考虑的是产品的技术价值而不是更广泛地考虑它们的商业价值，并且我们仅仅是基于生产产品的技术质量来做决策的。换言之，我们假定改进技术质量将自动转化为商业价值。
	几位研究人员已经对商业价值和技术价值间的关系作了紧密考虑。例如，Simmons已经会见了许多澳大利亚商家以确定他们是如何做有关信息技术的商业决策的。她提出了一个理解“商业价值”对公司的含义的构架。在Favaro和Pfleeger（1997）的一份报告中，Steve Andriole，Cigna公司（一家大型美国保险公司）的首席信息官，描绘了他的公司是怎样区别技术价值和商业价值的：
我们衡量（我们的软件）质量是通过显然的衡量尺度的：根据时间先后，维护费用、修改费用等。换言之，我们基于代价参数范围里的操作性能来管理开发。我们对卖家如何提供划算的性能的关心要少于对这种努力所取得的结果的关心……商业和技术价值问题在我们内心也是亲密和宝贵的……并也是一个我们在上面集中了大量注意力的问题。我猜我惊讶地了解到公司愿意为了别的公司的技术价值而以相对的商业价值为代价与他们缔约。If anything,我们在另一方面犯了错！如果没有清晰（可预料）的商业价值（在数量表示为：被处理的主张数，等等）那么我们不能发起这项工程。我们非常郑重地工程的“有目的的”需要阶段，那时，我们问：“我们为什么需要这个系统？”及“我们为什么在意？”
	已经有几次想以定量和有意义的方式将技术价值和商业价值关联起来的尝试。例如，Humphrey，Snyder，和Willis（1991）指出，通过按照CMM“成熟”规模（将在第十二章讨论）改进开发过程，Hughes Aircraft将生产率提高了4倍，节省了几百万美元。类似地，Dion（1993）报告说，在过程改进后，Raytheon生产率加倍，且每投资一美元就得到7.7美元的回报。而位于俄克拉荷马州的Tinker空军基地的技术人员说生产率有6.35倍的改进（Lipke和Butler 1992）。
	然而，Brodman和Johnson（1995）对过程改进的商业价值做了更紧密的思考。他们调查了33个进行了某种过程改进活动的公司，并调查出了几个关键的问题。在另外的一些事情中，Brodman和Johnson问公司他们怎样定义投资回报率（ROI），一个商界清楚定义了的概念。他们指出，投资回报率的书面定义衍生于金融界，描述了根据为达到别的目的所进行的投资。也就是说，“投资必须不仅要返还原来资本而且要更多，至少要等于这笔资金投资于别的方面所赚利润加上一笔风险金（Putnam和Myers 1992）。通常，商界使用三个模型之一来评估ROI：偿还模型，会计学返回率模型和折扣兑现流模型。
	然而，Brodman和Johnson（1995）发现美国政府和美国工业界以很不相同的方式解释ROI，彼此不同，且二者也不同于标准商校的方法。政府以美元来看ROI，考虑减少动作费、预测美元储蓄及计算采用新技术的费用。政府的投资也以美元来表示，如引进新技术或发起过程改进的费用。         
	另一方面，工业界以业绩来看待投资而不是花费或美元。也就是说，公司感兴趣的是节省时间或使用更少的人力，并且他们对有关投资回报的定义反映在临死业绩这样的焦点上。在被调查的公司中，投资回报包括这样的项目：
	培训
	进度表
	风险
	质量
	生产率
	过程
	消费者
	花费
	商业
包括在定义中的花费问题涉及满足预测、改善花费效能及不超出预算，而不是减少运作费用或使工程或组织简化并更有效率。图1.6概括了许多组织在他们的ROI的定义中包括一条投资项的频率。例如，会见公司中约%5在ROI业绩计算中包括了一个质量组的业绩，约%35在考虑投资费用时包括软件费用。
观点间的差异是烦扰的，因为它意味着组织间ROI的计算是无法比较的。但是这此不同的观点的存在却有很好理由。来自缩减的进度、更高质量和增加的生产率中的美元节省被返回政府而不是订约人。另一方面，订约人经常期待竞争优势和增强的工作能力和更大的利润；因此，订约人的ROI是更有业绩——比起基于花费。特别地，更精确的费用和进度估计可能意味着消费者满意及不断的生意。并且，对于市场来说，缩减的时间跟改进了的产品质量一样也被理解为提供商业价值。
即使不同的ROI计算可对每个组织是合理的，也有人担心软件技术投资回报与金融上的ROI不同。从某种观点来看，程序成功必须向更高层次的管理汇报，很多与软件无关而是与公司的主要业务有关，例如通讯或银行。有很大内在意思上差异的相似术语的使用将引起很多混淆。因此，我们的成功标准必须不仅对软件工程和过程有意义，而且也应对软件所支持的更一般商业实践有意义。我们将在十二章的更多细节中调查这个问题并考虑使用几个通用商业价值指标来在技术选项中进行选择。
 
1.4 谁实施软件工程？
	软件开发的一个关键部分就是顾客和开发者之间的交流；如果失败，系统也将失败。在建立一个系统来帮助顾客解决问题之前，我们必须理解顾客想要和需要的东西。为了做好这一步，让我们把目光转向软件开发过程中涉及的人。
	从事软件开发的人数依赖于工程规模和困难程度。然而，无论涉及多少人，在整个工程的生命中扮演的角色是有区别的。因此，对一个大型工程，一个人或一个组可能会被安排为确定的每个角色；在一个小工程中，一个人或一个组可能一次担当几个角色。
	通常，一个项目的参与者属于三类：顾客，用户，或开发者。顾客就是为软件系统开发支付资金的公司、组织或个人。开发者就是为顾客开发软件系统的公司、组织或个人。这类人包括任何协调、指导程序员和测试人员所需要的管理人员。用户就实际使用这个系统的人员：坐在终端前或提交数据或读输出。尽管对一些工程顾客、用户和开发者是同一个人或同一个组，但通常他们是不同集合中的人。图1.7显示了三类人间的基本关系。
	顾客，控制着资金，通常谈判合同和签署接受文件。然而，有时顾客不是一名用户。例如，假定Wittenberg Water Works与Gentle Systems公司签署为前者建立计算机化记帐系统的合同。Wittenberg的总裁向Gentle Systems的代表正确地描述要求，并且签署合约。然而，这位总裁将不直接使用这套记帐系统；用户将是簿记员和财务工作人员。因此开发者正确地理解顾客和用户两者想要的和需要的东西是很重要的。
	另一方面，假定Wittenberg Water Works是如此庞大的以致于有自己的计算机系统开发部门。这个部门可能决定需要有一个自动工具来跟踪它自己的工程的花费和进度。在自身建立工具的时候，这个部门同时是用户、顾客和开发者。
 
	在最近几年，顾客、用户和开发者间简单的区别已经变得更加复杂。顾客和用户已经以各种方式涉入开发过程中。顾客可能决定购买Commercial Off-The-Shelf（COTS）软件以并入开发者将供应和支持的最终产品中。当这样的事情发生时，顾客涉及了系统体系决策，并且开发工作也有了更多的限制。类似地，开发者可以选择使用别的被称为次承包商的开发者，次承包商建立子系统并将它交付给开发者以纳入最终的产品中。次承包商可能与主开发者并肩工作，或者在不同的场所工作，同时保持他们的工作与主开发者协调一致并在开发过程后期交付子系统。子系统可能是一个一切齐全可立即使用的系统（turnkey system），在这个系统中代码被合并成一个整体（没有额外的代码以求完整）；或者子系统需要一个单独的完整性处理以建立主系统到子系统间的联接。
	因此，“系统”的概念在软件工程是很重要的，我们装配起来的硬件和软件必须与用户交互，与别的软件作业交互，与别的硬件交互，与现存数据库（例如，数据库拥有仔细确定的数据集和数据关系），甚至与别的计算机系统。所以，对任何工程，了解这个工程的边界以为其提供一个上下文（环境）是很重要的：什么需要包括在这个工程中，什么不需要。例如，假设上司要求你写一个替你办公室里人员打印付薪水的支票的程序。你必须要知道程序是否只是简单地从别的另外的系统读工作小时数并打印结果，或者是否也还要计算支付信息。类似的，你必须知道是否由程序来计算税金、养老金和退休金，或者是否这些项目的一份报告将附随于每一张付薪支票。你真正问的是：这个工程开始哪里又在哪里结束？同样的问题适用于任何系统。一个系统是一个对象和活动的集合再加把对象和活动联系在一起的关系的一个描述。典型地，我们的系统定义中，对每个活动，包括所要求的输入、所要采取的行为、和所产生的输出的一个列表。因此，为了开始，我们必须知道是否任何对象或活动已经被包含于系统中。
系统元素
	我们通过为系统各部分命名然后确定组成部分和另外组成部分如何关联来描述它。识别是分析摆在我们面前的问题的第一步。
活动和对象
首先，我们区分一下活动和对象。一个活动（Activity）就是发生于系统中的某事。活动通常被描述为一件由触发器发起的事件，它通过改变一个特征来将一件事物转换为另一事物。这种转换可能意味着一个数据元素从一个位置移到另一个位置，从一个值变为另一个值，或者与另的数据合起来为另外的活动提交输入。例如，一个数据项可能从一个文件移到另一个文件。在这种情况下，发生变化了的特征就是位置。或者这个数据项的值被增加。最后，这个数据项的地址可能和几个另外的数据项的地址被包括在参数列表中以便别的例行程序立即被调用来处理所有这些数据。
活动中涉及的元素被称为对象（object）或实体（entity）。通过，这些对象以某种方式相互关联。举例，对象可被排列在一张表或矩阵中。通常，对象聚合成记录，每个记录以一种指定的格式排列。例如，一条雇员的历史记录（称为域）可能包括着描述每位雇员的对象，如下：
First name				Postal code
Middle name				Salary per hour
Last name				Benefits per hour
Street address				Vacation hours accrued
City						Sick leave accrued
State
在记录中，不仅定义了每个域，而且也指明了每个域的尺寸及与别的域间的关系。因此，记录描述规定了每个域的数据类型、在记录中的开始位置和域的长度。依次地，因为有了每个雇员的记录，记录可被合并成一个文件，并且可以指定这个文件的特征（例如最大记录数）。
有时，对象的定义会稍有不同。在一条更大的记录中，对象被视为是独立的，而不考虑作为一个域的每一项。对象描述包括了每个对象的特征列表和使用这个对象或影响这个对象而发生的所有的活动的列表。例如，考虑“多边形对象（polygon）”。对象的描述可能说诸如边数和每边边长这样的特征。行为可能包括面积或周长的计算。甚至可能有一个称为“多边形类型（polygon type）”的特征，以便“polygon”的每个实例能被识别出何时它是，举例来说，“菱形（rhombus）”或“矩形（rectangle）”。 类型自身可能有一个对象描述；例如，“rectangle”可以由“正方形（square）”和“非正方形(not square)”组成。我们将在第四章研究需求分析时探究这些概念，并在第六章讨论面向对象开发时深入探究。
关系和系统边界
一旦实体和活动确定下来，我们将实体和它们的活动匹配。实体和活动间的关系是被清晰而仔细定义。一个实体定义包括实体来源的描述。一些项在已存在的文件中；另外的在活动期间建立。实体的目的地也是重要的。一些项仅由一项活动使用，但另一些被预定地输入别的系统。也就是说，一些来自一个系统的项被处于受检查的本系统之外范围时的活动使用。因此，我们认为我们所见的系统是有边界或分界线的。一些项跨过边界进入我们的系统而别的项是我们的系统的产品并跑出去为另外系统使用。
运用这些概念，我们可在将系统（System）定义为如下事物的集合(collection)：一个实体集、一个活动集、一个实体与活动的联系的描述，和一个系统边界的定义。这条系统的定义不仅适用于计算机系统而且也适用于在其中对象以某种方式与别的对象交互的任何事物。
1.5 一个系统的方法
为了弄明白系统定义如何工作，考虑让你身体可以吸收氧气排出二氧化碳和水的那个部分：呼吸系统。你可以很容易地定义它的边界：如果你叫出你身体的一个特别器官，你能说出它是否是呼吸系统的一部分。氧气和二氧化碳分子以明确定义了的方式通过系统的对象或实体。我们也能根据实体的交互描述系统中的活动。如果需要，我们能通过显示进入和离开它的东西解释系统；我们也能提供表格来描述所有的实体和他们所涉及的活动。图1.8解释了呼吸系统。注意到每个活动都涉及实体，并且能通过描述哪个实体充当输入、它们怎样被处理和产生了什么结果（输出）来定义。
 	我们也必须清晰地描述我们的计算机系统。我们和预期的用户来定义系统的边界：我们的工作开始和终止于哪里？另外，我们需要知道什么是处于系统边界上并因此确定输入的来来源和输出的目标。举例，在一个打印付薪支票的系统中，支付信息可来自公司计算机。系统输出可能是一组将送往邮箱以交付给适当收件人的付薪支票。在图1.9所示的系统中，我们能看到这样的边界并能理解实体、活动和他们的关系。
相关系统
边界概念是重要的，因为很少有系统是独立于其他系统的。例如，呼吸系统必须与消化系统，循环系统、神经系统及其他系统交互。没有神经系统呼吸系统不能工作；没有呼吸系统循环系统也不能工作。相互依赖可能是复杂。（的确，许多环境问题出现并加剧就是因为我们没有认识到生态系统的复杂性。）然而，一旦系统边界得到描述，我们就很容易明白什么在里面什么不在里面、什么穿越了边界。
 
	依次地，一个系统存在于另一个系统内部也是可能的。当我们描述一个计算机系统时，我们常常把焦点集中于实际上更大的一个系统的一小片上。如此的焦点可让我们定义和建立一个复杂性相对要小一点的系统包含于大系统内部。如果我们仔细地文档化影响我们系统的那些系统间的交互，那么当我们把专注于一个较大系统的这个小片时就不会丢失什么东西。
	让我们看一个怎样进行这样的工作的例子。假定我们正开发一个水文监视系统，它的数据来源于整个流域的许多观测点。在收集处进行几样计算，而结果被传到一个中央位置以得到完整的报告。这样的一个系统可以通过中央位置的一台计算机和远端的几十台较小的计算机通信来实现。许多系统活动必须考虑到，包括数据收集的方式、远端计算机执行的计算、和中央位置的信息通讯、数据库或共享文件中通讯数据的存储、从这些数据产生报告。我们可以把这个系统当作一个系统集，每一个系统完成一个特定的目标。特别地，我们可只考虑大系统的通讯方面并开发一个通讯系统来从一批远端向中央位置传输数据。如果我们小心的定义通讯和大系统间的边界，通讯系统的设计和开发工作能独立于大系统进行。
	整个水文监视系统要比通讯系统复杂得多，因此我们分别的小片的处理使得我们的工作简化不少。如果边界定义详细且正确，从较小系统建立大系统就相对容易。我们能通过分层考虑大系统来描述建立的过程，就象图1.10所描述的水文监视的例子。一个层本身就是一个系统，但每层和它所包含的也形成一个系统。图中的圈代表了各个系统的边界，整个圈集合并成整个水文监视系统。
 
	认识到一个系统容纳另一个系统是重要的，因为它反映这样的事实：在一个系统中的对象或活动是外层代表的每个系统的一部分。因为每层都引入了更多的复杂性，在每个包含更多圈的系统中理解任何一个对象或活动都变得更困难。因此，我们通过首先尽可能关注最小的系统来达到最佳的简单度和随之而来的对系统的最好的理解。
	我们用这样的观念来建立取代较老的系统的系统，或者手工或者自动的。我们需要尽可能理解新老系统是如何工作的。通常，两个系统间的差别越大，设计和开发就越困难。这种困难不仅在于人们倾向于抵制变化，而且因为差别使得理解困难。在建立或综合重要系统中，一个递增系列中间系统对构造新系统是有戏剧性帮助的。我们可能从系统A到A’到A’’再到B而不是直接A到B。例如，假如A是一个手工系统，它包含了三个主要功能，而B是一个A的自动系统版本。我们可以定义系统A’是一个功能1自动而功能2和3仍然手动的新系统。然后A’’有自动的功能1和2，而3仍是手工的。最后，B有三个自动功能。通过将从A到B的“距离”分割，我们得到一系列比整体更易处理的小问题。
	在我们的例子中，两个系统是非常相似的；功能相同，但他们实现的风格不同。然而，目标系统与现存系统常有很大不同。特别地，通常目标系统没有现存软硬件强加的限制。一个增量开发方法可能合并一系列阶段，每个阶段在前一个阶段的基础上摆脱了另外的一个限制。例如，阶段1可能增加了一块新硬件，阶段2可能替换了一套执行一个特定功能的软件，等等。系统从旧的软硬件中被慢慢拉走直到它反映了新的系统设计。
	因此，系统开发首先可被合并成一个对实际系统的改变集合，然后加入一系列变化以产生一个完整的设计计划，而不是一下子从当前跳到将来的系统。用如此方法，我们必须同时以两种不同的方式来看待系统：静态地和动态地。静态视图现在的系统正如何工作，而动态视图向我们指出系统正怎样变成它最终的样子。一个视图没有别一个是不完整的。
1.6 一个工程方法
	一旦理解了系统的本质，我们就准备开始构建。在这点上，软件工程的“工程”部分变得贴切并补足迄今为止我们已做的事情。回顾一下，我们是以“承认写软件是一门科学也是一门艺术”开始本章的。生产系统的艺术涉及软件产品的工艺。作为艺术家，我们利用已经被证明对生产有益的，高质量的产品有帮助的技术和工具。例如，我们可能使用一个优化编译器作一个工具来生成在我们使用的机器上运行得很快的程序。或者我们可能包括特别种类或搜索例程作为在我们的系统中省时省空间的技术。这些基于软件的技术被使用正象技术和工具用在精心制作优质家具或建房中。的确，一套受欢迎的的编程工具集被称为程序员工作台，因为程序员依赖它们就象一位木匠依赖于一个工作台。
	因为建立一个系统类似于建造一幢房屋，所以我们能指望房屋建造作为别的为什么“艺术的”方法对软件开发重要的例子。
建造一幢房屋
假定Chuck和Betsy Howell雇用了某人为他们建一座房屋。因为它的尺寸和复杂性，一幢房屋常常需要不止一个人在建设小组里；因此，Howell家雇用了McMullen建设公司。房屋建设涉及到的第一件事就是Howell家和McMullen间召开一次会议以便Howell家能解释他们想要什么。这次会议探究的不仅是Howell家想这房屋看起来的样子，而且也探究它应包括的特征。然后，McMullen草拟房屋的地基计划和建筑透视图。在Howell家和McMullen讨论了细节后，变化开始了。一旦Howell家认可了McMullen，建设就开始了。
	在建设过程中，Howells很可能视查建设场所，考虑他们喜欢的变化。在建设过程中几个那样的变化可能产生了，但最终房子完工了。在建设过程中和Howell家迁入之前，会检测房子的几个组成部分。例如，电工检测电线，管道工确保管道不会漏水，木匠调正木料以便地面光滑水平。最后，Howell家搬进去。如果有某物没有正确的建好，McMullen可能被召来修整，但最终，Howell家对这房屋负全部责任。
	让我们更紧密地考虑这个过程中涉及的东西。首先，因为许多人同时参与这幢房子的建设工作，文档是重要的。不仅是地基计划和建设草图是必需的，而且也必须写下细节以便象管子工和电工之类的技术人员在这幢房子成为一个整体的时把它们的产品组合在一起。
	其次，在这个过程开始时就期待Howell家描述他们的房子及直到房子完工才走开都是不合情理的。的确，Howell家可能会在建设过程中几次修改房屋的设计。这些修改可能产生于许多条件：
	起初指定的材料不再有用。例如，某些类型的顶瓦可能不再生产了。
	在Howell家看到房屋成形时可能有了新想法。例如，可能意识到额外花一小笔费用就可为厨房安上天窗。
	可用性或资金限制可能要求Howell家改动需求以满足进度或预算。例如，Howell家想订购的特定窗户在冬天房屋完成前将不能及时备好，因此库存窗户被用来替代。
	当初想好的项目或设计结果可能证明是不可施行的。例如，土壤浸透测试可能揭示房屋周围的土地不能支持Howells家所要求的浴室数。
McMullen也可能在建设已经开始后提议一些改动，或许因为一个更好的主意或者因为建设队伍的一名关键成员不能利用。McMullen和Howell家可能对房屋的一个特征改变了想法，甚至是在这个特征已经完成之后。
第三，McMullen必须提供蓝图，配线和配管道图，器具使用手册，和别的文档以便Howells迁入后能作修改或维修工作。
我们可能将建设过程概括为以下几步：
	确定、分析需要
	产生及归档房屋的全面设计
	生成房屋的详细说明
	标识、设计组成部分
	建立房屋的各组成部分
	测试房屋的各组成部分
	结合和组成部分、在住户已经迁入后做最后的修改
	由房屋居住者继续维护工作
我们已经看到参与者必须如何保持灵活性并允许建设过程中在原来的规格说明中的多个不同点上做更改。
房屋是在它所处于的社会、经济和政府结构的上下文环境中建设的，记住这点很重要。正象图1.10的水文监测系统描绘了子系统的依赖，我们必须把房屋当作一个处于更大配置中的一个子系统。例如，房屋建设是在城市或乡村的建设法规或规章的上下文环境中进行的。McMullen雇员要由城市或乡村许可，并且他们被指望按照建设标准行事。建设检查员巡视建设场所以确保建设标准得到遵守。并且建设检查员设定质量标准，这样检查成为这项工程质量保证检查点（checkpoint）。也可能有社会或惯常的限制提出了公共的或可接受的行为；例如，让前门直接对着厨房或卧室开放违反常情的。
同时，我们必须认识到我们不能正确的规定建房中的活动；我们必须为基于经验所作的决定、为处理料想不到或不标准条件而留下余地。例如，许多房屋从先存在的部件塑造而来；门已经被提供在框架里了；浴室使用预制淋浴隔间等等。但标准建屋过程可能不得不更改以适应一个不平常的的特征或要求。假定架子搭好了、干燥墙建好，底层地板被铺好，接着的步骤便是在浴室地板上铺瓷砖。建立者发现在，非常令他们沮丧的是，墙和地面都不恰是正方形的。这个问题可能不是过程欠缺的结果；房子建自于有一些自然的和制造方面变异的部分，因此.不精密的问题是会发生的。地板砖，由小正方形组成，如果以标准方式铺设将突出这种不精密。在这里，艺术和专门技术发挥了作用。修建者很可能从衬背里去掉瓷砖，每次铺一板，彼此间作小的调整以便全部的变动是对所有人（除了最有辨识能力的眼睛）觉察不到的。
因此，房屋建设是一个复杂的任务，在此期间，过程、产品或资源中有许多改变的时机，这些都通过适量的艺术和专门技术来调节。建房过程能被标准化，但总是需要内行的判断和创造力。

建立系统
软件项目也以相似于建房的过程发展。在我们的例子中，Howells是顾客和用户，而McMullen是开发者。如果Howells请McMullen建房给Howell先生的父母居住，那么用户、顾客和开发者将是有区别的。同样，软件开发涉及用户、顾客和开发者。如果我们被邀请为一个顾客开发一个软件系统，第一步就是和顾客召开会议以确定需求。需求描绘了系统，象我们在前面看到的一样。不知道边界、实体和活动，描述软件及它将怎样与环境交互是不可能的。
一旦确定了需求，我们将建立一个满足指定需求系统。就像将在第五章看到的一样，系统设计反映了从顾客的角度看起来系统的样子，因此，正象Howell家看到楼层计划和建筑草图，我们向顾客提供将采用的录象显示屏图片，生成的报告，以及任何别的用来解释用户如何与完工后系统交互的描述。如果系统有帮助手册或优先的过程，也应得到描述。开始，Howells只对房子外观和功能感兴趣，晚一些他们必须决定诸如使用铜质还是塑料管子这样的事项。同样，软件项目的系统设计阶段仅描述外形和功能。
    然后顾客复查设计。得到认可后，整个系统设计用于产生要涉及的单个程序的设计，注意这一步是在提到程序的才开始进行。除非外形和功能确定了，否则考虑编码通常没有任何意义，在房屋的例子中，我们现在将准备讨论管子类型和电线质量了。因为我们已知道在此结构中水需要流向的地方了，所以可以决定使用铜墙铁壁质还是塑料管子。同样，系统设计得到各方认可后，我们准备讨论程序，我们讨信纸的基础就是：一份很好定义了的这个作为一个系统的软件项目的描述；系统设计包括一份对涉及的功能和交互活动的完整描述。
程序写好后，在能被联接到一起前，他们被当作单纯代码来测试。测试的第一阶段我称为模块式单元测试，一旦确信这些代码工作满意，我们便把他们放于一起，并确保他们与别的代码联接起来后也能正确工作。这便是第二测试阶段，被称之为集成C或集成B测试，就像建系统时将一块片断补充到下一个片断之上。一直到整个系统是可操作的。最后测试阶段称为系统测试涉及的是整个系统的测试以确保当指定的功能和交互都被正确实现，在这个阶段，系统将和指定需求进行比较；开发者，用户核查系统是否达到了预期目标。
最后，最终产品被交付。在使用过程中，矛盾和问题揭示出来。如果我们开发的一个“交钥匙型”系统，那么交付后顾客自己对系统负责。然而，许多系统不是那样，如：如果哪里出错，或需求变化了。开发者或别的组织提供维护。
    因此，软件开发包含下列活动：
    需求分析和定义
    交流设计
    程序设计
    写程序（程序实现）
    单元测试
    整体测试
    系统交付
    维护

    理想条件下一次进行一项活动，当到达列表尾部时，人已经完成了一个软件项目。而实际上，其中许多步将被重复。例如，在得查系统设计时，你和顾客发可能发现某些需求还没有写入文档。人与顾客共同工作补充需求并可能重新设计系统，类似地，在编写和测试代码时，你可能发现一个设备并不像文档中描述的那样发挥作用。人可能不得不重新设计代码，重新考虑系统设计。或甚至回头与顾客讨论怎样满足需求。因而。我们这样来定义软件开发过程（goftware development precess）：是任何包含了上面列下来的被组织起来的产生测试后代码的凡个活动的软件开发的描述。在第二章我们将讨论建立软件时使用的几种不同的开发过程。后面章节就将考查每个子过程和他们的活动——从需求分析到维护。但在此之前，让我们看一下谁开发软件及过去的时间里的软件开发的挑战是如何变化的。
1.7 开发组的成员
    在本章较前部分，我们看到顾客、用户和开发者在与新产品的定义和建立中扮演着主要角色。开发者是软件工程师，但每位工程师可能专攻于开发的一个特定方面。让我们更详细地考虑一下开发组中成员的角色。
    许多开发过程的第一步就是弄清楚顾客想要什么并文档需求。我们已经看到，分析是一个将事物分成组成部分以便于我们能更好理解的过程。因此，开发组包括一名或多名需求分析员，他（们）与顾客一起工作，把顾客想要的东西分解成离散的需求。
    一是需求已知并被文档化，分析员与设计员一起工作以产生一个“系统将要做什么”的系统级描述。依次地设计员与程序员一起以一种程序员能写下实现指定需求的代码行的方式描述系统。

生成的代码必须被测试。通常由程序员自己做第一步测试；有时额外的测试员也被用来帮助程序员捕捉程序员忽视了的差错。当代码单元被集成到功能组时，一组测试真与实现小组一起在通过合并代码片建立系统时验证系统正确并与规格一致地工作。
当开发组对系统的功能和质量满意后，注意力便转向顾客。测试组和顾客一起工作以验证整个系统是顾客想要的东西；他们通过拿系统和当初的需求集进行比较一进行这项工作。然后，培训员向用户演示怎样使用系统。
    对很多软件系统，顾客的认可并不意味着开发者工作的结束。如果系统被交付后发现了故障，一个维护组一维护 它。此外，随着时间流逝，顾客的需求可能发生变动，相应的系统也会改动。因此，维护可能涉及分析员——他决定要增加可改动什么需求，设计员——决定系统设计中哪里应改动、程序员——实现改动测试员——确保改动后的系统仍能正确运行，和培训员——向用户解释是怎样影响系统的使用的。图1.11解释了开发组各种角色是怎样与开发步骤对应的。
    学生常独自或与小组组成项目的开发组。导师要求的文档是最少的，学生通常不需写用户手册或培训文档。而且，通常相对稳定；整个项目生命期是需求不发生变化。然后，学生建立的系统很可能在课程结束时被遗弃；他们的目的是演示能力面，不是替真正顾客解决问题。因此，对课堂项目占程序大小，系统复杂性，对文档的要求，对可维护性的要求相对要小。


图1.11开发组角色
    然而，对一个真实的顾客，系统的大小和复杂性都很大，也极要求文档和可维护性，对一个泼汲4千行代码和更多的开发组成员间的交互活动的项目来说，项目各方面的控制可能是很困难的，为了支持开发组中的每个人，有几个人可能在开发一开始就参与其中与系统打交道，并在过程中一直这样，
    图书管理员准备并保管整个系统生存期要用到的文档，包括需求规格说明书，设计描述，程序文档，培训手册，测试数据，进度等等，与图书馆管理员一道工作的是一个配置管理组。配置管理涉及到维护需求设计实现，测试间的一阶，这种交叉参考可在需求中某处变动时哪些程序需要更改，或者提议的某类改动会影响程序中哪些程序中哪些部分配置管理工作人员也协调已建立成支持的系统的不同版本。例如，一个软件系统可能支持不同的平台，或者可能交付了一系列的发行版。配置管理确保从一个平台到另一平台上功能一致。不随系统发行版而恶化。
    开发角色可由一个或几个人来承担，对小项目两三个人可以共同担负所有的角色，然而对较大项目开发组基于开发中的功能常分为不同的组。有时，维护系统的哪些人不同于当初设计或写这个系统的哪些人。对一个非常庞大的项目，顾客甚至雇用一个公司最初的开发而雇另一个公司从事维护。在后面章节中讨论开发和维护活动等。
我们将看一看每种类型的一切角色需要什么技巧。

1.8 软件工程如何变化的
    我们已经把建立软件比作建房。第三年全国有数百的房屋建起来，满意的顾客搬进去每年开发者也建立起灵敏百的软件产品，但顾客常常对结果不满意。为什么会有这样的差异？如果枚举系统开发的步骤是如此容易的，为什么作为软件工程师的我们会花如此艰难的时间来建立生产质量软件？
    回顾我们建房的例子，建设过程中，Howell一家不断地复查计划。他们也有很多机会来改米对他们所想要的东西的想法。同样地软件开发允许顾客复查每一步中的计划，及在设计上作出改动。毕竟如果开发者生产出了不满足顾客要求的不可思议的产品，最终系统将浪费了每个人的时间和努力。
    因此，灵活地运用软件工程工具和技术是重要的。过去作为开发者我们作交定顾客从一开始就知道他们想要的东西。那种稳定性通常不是事实。当项目各个阶段渐渐显露时，开始没有预料到的限制出现了。例如，为特定项目选定好软硬件后，我们可能发费顾客需求的一个改变使用一特定DBMS正确地产生普通向顾客承诺过的菜单变得困难。或者我们发现我们的系统要与之接口的系统已经改为了加工或期整数据的格式。我们甚至发现软件硬件不能工作的象卖家文档中已经承诺过的那样好。因此，我们必须记位每个项目是独特的，工具和技术必须有所选择的，把映放置于这个单独项目之上的限制。
    我们也承认，大多系统不能独自运行。它们与别的系统接口，或者接收或者提供信息。开发这样的系统是复杂的仅仅因为也要和与与之通讯的系统进行大量的协调。这种复杂在同时开发这些系统的表现的大为真切。过去开发者难以保证系统间接口文档的精确和完全。在后续章节，我们将谈一下控制接口问题。
变化的本质
    这些问题是许多影响软件开发项目成功的因素的一部分。无论采取什么方法，我们必须前后都看看。就是说，向后看一看以前的开发项目以明白我们已领会了什么，不仅是有关确保软件质量方面的，而且也有关我们的技术和工具的有效性方面的。我们必须向前看，软件开发和软件产品的使用将可能改变我们在未来的实际的方式。Wassermane197.5指出自20世纪70年代以来这些变化已经是富有戏剧性的。例如，早期应用程序设计的运行于单个处理器上，常常是一个主机。较为是一次性的，通常为一幅卡片或一个输入带，而输出是代数。系统以两种基本方式之一来设计：作为一种转换系统，输入转换为输出；或者作为一个事务，转入规定了哪个功能方没执行。现在的基于软件是远远不同并更加复杂的。典型地，他们运行在每个系统上，有时配成具有分布功能的客户一般服务的结构。软件不仅执行用户需要的主要功能，而且还有网控。安全，用户接口的表示和处理，及数据或对象管理。系统分布模型开发方法，它采用一种线性发的开发活动，一个活动只须它的前导活动完成才开始我们将在第二章研究，而这种开发方法对今天系统来说不再具有伸缩性或者说不适合，在Wasserman(1996)的Stevens演讲中，他通过标识已经影响软件工程实线的七个关键因素（在图1.12）中说明来概括了这些变化：
1、对商品而推向市场时间上的危急性
2、计算方面经济上转移；较低硬件费用和较高的开发和维护费用。
3、能有有桌面计算的利用
4、广泛的局域和广域网络互联。
5、面向对象技术的可用性和实用
6、运用窗口、图标、菜单和指针的图形用户接口（GUI）
7、软件开发的分布模型的不可能性预测性。






图1.12已经改为软件开发的关键因素
    例如，市场压力意味着商家必须在竞争对手行运之前准备好新产品和服务。否则，商业自身的变化可能产生巨大的利害。因此，传统的复查和测试技术如果需要大量不能扣除的时间以减少故障损失，效率的话将不能使用，同样，以前为改善速度或减少空间而花在代码优化上的时间可能不再是英明的投资；一块额外的硬盘或内存卡可能是此问题更便宜的解决方案。
    而且，桌面计算把开发权力放在了用户手里，他们现在用他们系统来开发电子表格和数据库应用，小程序，甚至特化用户接口和模示的实验。开发职责的转移意味着作为软件工程师的我们，很可能将建立更复杂的系统。类似地，巨大网络互联将有能力对大多用户和开发者可以利用，这使得用户在没有特别应用程序时也能更容易地查找信息。举例，搜索WWW是快速、容易并有交互的；用户再也不需要写一个数据闸应用程序来查找他或她需要的信息了。开发者也发现他们的工作加强了。而向对象技术，结合网络和用仓储库，使所开发者在新应用程序中将更大集合的可重用模块直接快速地包容进来加以利用。图形比用户接口（常用专门的工具开发）有助于在复杂应用中放置一个友好的桌面。因为我们分析问题的方工变化很复杂，我们能划分一个别系统以便我能并列地开发其子系统，这需求一种非常不同于“瀑布模型”的开发过程。我们也将在第二章中看到。对此过程我们有许多选择，其中包括一些允许我们建立原型（为与顾客用户验证需求的正确及许估设计上的灵活性，在活动中反复的过程。这些步骤有助于我们确保需求和设计在以代码实例化它们前尽可能没有毛病。
Wasserman的软件工程原则。
    Wasserman（1996）指出七个技术变化任何一个都对软件开发过程产生重大意义的影响。它们一起转变了我们工作的方式。在他的陈述中Demaero描述一种极端的转移，也说我们首先解决容易的问题；而那意味着留待解决的问题现在比以前更困难。Wasserman谈论了这种挑战，提议软件工程中有八个概念形成了软件工程有高级原则的基础。在这里我们简单介绍它，在以后面章节会回到它上面看它们应用于我们工作中哪些地方以及如何运用。
    抽象。有时，从问题的“自然状态”CVK ：象顾客或用户表达的一样一考虑也是件很让人气馁的工作。我们有分到一个以一种有效归纳层次上对问题的一个描述，这让我们可专注于问题是关键方面，而不致于陷于细节。此概念不同于转换（transforhation），转换是指我们把一个问题计成另一个我们更好理解的环境；将问题从真实世界转移到数学世界，因此我们能使用数字来解决问题。
    典型地，抽象包括确认对象的类以及更让我们将项目分组到一起；通过此方式，我们可处理更少的事务并把注意力放在每个类各项的共性上，我们可以读者论论在一个类中项的特性或展性并栓查在特性和类中的关系。例如假如我们被邀请建立一条大面复杂的河流的环境监测系统。监测设备可能得知空气质量，水质、温度、速度和别的环境特片的感尖器，但是，为达到目的，我们可选择定义一个名为“sensor”的类；此类中每项都有某种特性，不管它正监测的特征：高度、速度、电气要求，维护计划等等因了解问题内容和设计一个解决方案时我们处现这个类而非它的元素。这种方工有助于我们简化问题表述并专注于问题的本质元素或特征。
    我们也可形成抽象的层次。例如，感应的是一型电子设备，我们可能有两型感应器：水感应器和空气感应器，因此我们可形成图1.13所示的简单层次。通过隐藏一些细节，我们可将注意力集中在对象的本质上，我们必须就对象来处理并找出简单而优美的解决方案。在第5.6和7章我们将紧密地看一下抽象和信息隐藏。
    分析设计方法和概念。当你设计一个程序作为课堂作业时，你通常独自工作。你生成的文档是一份正式的给你作注解的描述：为什么会选择一个特定方法、表示名的意思、实现的是哪种算法，当和一个组来共同工作时，你必须与许多开发过程的参与者交流。大多工程师，讨论他们做哪类工程，都使哪一个标准概念帮助交流，并文档化决策。例如，一名建筑师画一张图表或蓝图，别的建筑师都能理解。更重要的是，通用概念让承继人理解建筑师的意图和想法。象我们将在第4、5、6和7章看到的，软件工程中没有相同标准并由此导致误解是今天软件工程中关键问题之一。
    分析与设计方法提供给我们不止一种交流媒介。他们允许我们建模并检查完全性和一致性。而且我们可更容易地从以前对象应用需求和设计组件，这样相对容易的提高生产率和质量。
    但在决定一套公用方法和工具前，还有许多公开的问题要解决。象我们在以后章节中将看到的，不同的工具和技术用于一个问题的不同方面，我们需要确定建模原语，以使我们用科学—技术便可抓住问题的所有重要方面。或者我们需要研究出一种能与所有方法使用的，可能以某种方式裁剪的表示技术。
    用户接口原型。原型意思是建立一个系统的一个小版本，通常只具有有限的功能，原型用于：
	帮助有户或顾客确定一个系统的关键需求
	论证一个设计或方法的可行性
 



图1.13  监测设备的简单层次
    通常，原型反复的：我们建立一个原型，评估已（就用户和顾客的反馈）考虑变动可能怎样改善产品或设计，然后建另一个原型。当我们和顾客都认为我们有了问题的一个满意的解决方案在手边时，这个反复过程便结束了。
    原型通常用于设计一个好的用户界面：User lwterface,交流中与用户交互的那部分。然而也有别的便用原型的机会，甚至在嵌入式系统（embedded system），例如，在某种意义上用户界面是应用领域和软件开发者之间的一座桥梁，原型能产生表面问题和设想，而使用别的需求分析方法可能已经不是很清楚。我们将在第4和第5章考虑用户界面原型的角色。
软件体系结构。一个系统的整体体系不仅对发现和测试系统的难易度而且也对维护和改变的速度和效力很重要。体系结构的质量能构造成破坏系统；的确，象Shaw和Garlan（1996）把体系结构单独作为一条原则来介绍，它的影响在整个开发过程中都能感觉得到。一个系统的体系结构应该反映了好的设计原则，我们将在第5、7章研究。一个系统体系结构以一套体系单元和单元间如何联系的图来描述系统。单元越独立，体系越模块化，我们就越容易设计和开发分片Wasserman（1996）指出至少有五种方式将系统分成单元：

1、模块分解：基于模块被指定的功能
2、而向数据分解S：基于外部数据结构
3、面向软件分解：基于系统必须处理的事件，
4、外部设计（side-in design）：基于用户给系统的输入
5、面向对象形设计，基于确定对象的其和相互关系

    这些方法相互并不排斥，例如，我们能用面向事件分解设计一个用户接口，用面向对象或面向数据设计数据库。我们将在后面章节中更详细地考查这些技术。这些方法的重要性在于它们对我们设计经验的捕捉，通过应用我们已做的工作和在做时学到的东西来利用过去的项目。
    软件过程（softwre process）自20世纪80年代，许多软件工程师已经仔细注意软件开发的过程（process）,和由此产生的产品开发活动中的组织和原则对软件质量和开发速度的贡献已经得到承认。然而Wasserman提到：
    应用类型和组织文化的巨大变化使得不可能说明过程本身。因此似乎软件过程不象抽象的模块化那样是软件工程的基础。（wasserman1996）
    代替地，他建议不同类型的软件需要不同的过程。特别是，Wasserman1996建议企业范围应用程序需要大量的控制，而个体或部门应用可采用快速开发如图1.14所示。
    用今天的工具，许多小或中等系统由一或两个开发者来建立，每个开发者必须担当多个角色。这个工具可能色括文本编辑与编程环境、测试支持，或许还有一个小数居库来捕获产品和过程本身的关键数据元素。因为项目的风险相对低，仅需少量的管理支持或复查。
    然而，大而复杂的系统需要更多的结构，栓查和平衡，这样的系统通常涉及许多顾客和用户，开发持续一个长的时期。而且，开发者不总是控制了整个开发，因为一些重要子系统可能由别人提供或以硬件实现。这种高风险系统需要分析和设计工具，项目管理配置管理，更完善的测试工具，更严格的系统复查和原因分析，在第二章，我们将仔细看一下几个过程选择以弄明白怎样改变过程以用于不同目的。然后，在第12、13章，我们评估一些过程的效力并看一看改进的方法。




图1.14开发的不同(Wasserman1996)
    复用（Reuse）。在软件开发和维护中，我们常通过应用以前开发中的某些共性来利用跨越应用程序的共同特征。例如，我们从一个项目到另一个项目都使用不同的操作作系统和DBMS，而不是每次都建一个新的。类似地，在我们建立和以前做过的相似但不相同的系统时我们应用需求集，设计部分，和测试脚本或数据组。Baranes和Bollinger(1991)指出，应用不是一个新观点，并提供了许多关于如何应用（不仅仅是代码）的有趣例子。
    Priteo-Diaz(1991)介绍可应用组件的概念为一种商业资产。公司和组织投次于可应用项目（item），然后在这些项目一次又一次在后来的项目里使用时获得可以计量的利润。然而，建立一个长期，有效力的应用程序是困难的，因为有几个障碍：
	有时建立一个小组件比可应用组件仓储库中搜索更快
	使组件足够通用以使未来别的开发者很容易地应用它，这需花额外的时间
	难以文档化保质程度和已做的测试，以便一名潜在应用者难对组件质量放心 
	如果一个应用组件失败或城要更新，谁来负责是不清楚的
	理解和应用别人写的组件是费钱费时的
	通常在能家长性和特殊性之间存在冲突

    我们将在第12章考查应有和的更多细节，考查几个成功应用的例子。
    度量。改良是软件工程研究的推动力：改进过程、资源和方法以便我们产生和维护更好的产品，但有时我们只是泛泛地改进目标，而没有从量上描述我们到了哪里和我们想到哪里。因此，软件度量已成为好的软件工程实践的一个关键方面，通过量我们能到哪里及我们能做什么，我们以一种允许估进展的通用数学语言找述了我们的行为和他们的结果。另外，一种数量的方法使我们可比较不同项目的进展，例如，在John Young 担任Hewlett-Packard的CEO时，他设定了“IOX”目标，对Hewlett-Packard的每个工程，不管它的应用类型或领域，在持量和生产率上都有十倍改进。（Gray and Cas well 1987）
    在较低层次的抽象中，度量有助于使过程和产品的特定特征更具可见性。反我们对其实观察的世界的理解转换成正式的数学世界中的元素，和关系常常是很有用的，因为在数学世界中我们能进一步操作元素和关系以获得更深的理解。象图1.15所示，我们能用数学和统计来解决头问题寻找趋势，或特征化一个条件（运用媒介和标准偏差）然后，新信息能映射回真实世界并被用作解决我们正在努力要解决的经验问题的方案的一部分。整个本书，我们将看到如何运用度量支持分析和作决策的例子。



图1.15使用度量来帮助找到解决方案
    工具和集成环境。很多年来，卖主以CASE工具招来顾客。在那里，标准化的集成开发环境能增强软件开发。然而我们已经看到开发者使用各种过程，方法或资源是多么的不同，因此，一个统一思想一的方法说来容易做却难。
    另一方面，研究人员已经推荐了向个基准体系，让我们可比较对照现存的和推荐的环境。这些基础标准体允许我们考查每个软件软件工程环境提供的服务并决定哪一个环境对给定问题或应用开发是最好的。
    比较工具一个主要难题就是卖主很少谈起整个开发生存周期。代替地，他们专注于小的活动集，如设计或测试，并且还取决于把被选择工具合并到开发环境的使用者。Wasswemen(1990)指出了任何工具集成中必须谈到的王个问题：
    1、平台集成：工具在一个异类网络上互操作的能力；
    2、表示集成：用户里面的共同特征
3、过程集成：工具和开发过程间的关联 
    4、数据集成：工具共享数据的方式
    5、控制集成：一个工具通知和启动另一工具中行为的能力在本书后面每一章，我们将考查支持本章陈述活动和概念的工具。你可把这里所述8个概念当作8条线过织成了本书的结构，把我们所称的软件工程的分离的活动拴在一起。当我们对软件工程了解更多之后，我们将再访这些观念来看看它们是如何统一并提升软件工程作为一门科学纪律的。
1.9 信息系统的例子       
 注：Piccadilly皮克迪利，英国的一个地区
    整部书我们将用两个例子结束每一章，一个是信息系统的另一个是实时系统的我们将章节里所描述的概念应用于每个例子的某些方面，因此你能看到概念在实践中的意义，而不仅仅是在理论上。
    我们信息系统的例子自James 和Suzanne Robertson，完全系统分析：工作手册，教科书和答案。它涉及到一个替Piccadilly电视台（一个英国地区性电视权拥有者）销售广告时段的系统的开发。图1.16说明了Piccadilly电视台收视区，象我们将看到的对电视时间的价格上的约束有很多且是变化的，因此问题即有趣又困难。在本书中，我们突出问题的各方面和它的解决方案；Robertson的书向你揭示了捕获和分析系统需求的详细的方法。
    在英国，广播委员会颁发8年特许权给一家商业电视公司，给他独有的在这个国家仔细划定的区域广播它的节目。作为回报“特权者”广播时必须使戏剧、喜剧、体育、儿童的和其他的节目达到规定了的平衡。而且，对在哪些时段播放哪些节目都有限制，对节目和商业广告的内容也规定。
    一名商业广告客户有几个触及Midlanels的观众的选择：Piccadilly电缆通道和卫星通道。然而，Piccadilly吸引了大多数观众。因此，Piccadilly必须设定阶格来吸引部分广告客户的预算。吸引广告客户注意力的方式之一是用观众收视率。（反映了全天不同时间观众的数量和类型）收视率根据节目类型、观众类型、时段、电视公司等来汇报。但广告价格不仅仅只依赖于收视率。例如，如果广告客户买了大方时数，每小时价格就会便谊些。而且，对在某些时间段广告的类型和对某类节目也有限制。例如：




图1.16 Piccadilly Television特权区
    酒精饮料的广告仅在9，PM后才可播出
    如果一名演员出现在电视上了，哪么这名演员有关广告在他出现的45分钟里不能广播
    当我们更详细操控究这个例子时，我们将提到客户外的有关广告和费用的规章。图1.17中系统情况图显示了系统边界及它如何与这些规则关联。阴影圆就是作为信息系统例子我们所关心的Piccadilly系统；系统边界就是圆周。箭头和方框显示了可能影响Piccadilly系统工作的项，但我们仅就它们的资源和目标把它们视为一个输入、输出集。
    在后面章中，我们将使阴影圆中活动和元素可见，我们将使用每章所描述的软件工程技术来考查系统的设计和开发。
1.10 实时例子
    我们的实时例子是基于Ariane-5,一种属于欧洲航天局（ESA）的空间火箭，的内嵌软件。1996年6月4日，在它的处女飞行中，Ariane-5被发射并正确运行约40秒。然后，它开始转离航向，在一个Ariane地面控制的指挥下，火箭被遥控摧毁。这颗未投保火箭的报毁不仅失去了火箭本身，而且失去了它所容纳的四颗卫星，这场灾难的代价是5亿美元。



图1.17
    软件包含于这个系统的各个方面，从火箭的导航系统到组件部分的内部运转。火箭的失败和随后的报毁引发了很多关于软件质量问题，就象我们在后面章节看到的，调查问题原因的调查委员会专注于软件质量和确实性上。在本章我们我们从火箭的商业阶价值来看质量Ariane-5的成功得到许多组织的资助：区分为航天局（ESA）CNES（法国的航天局，全面指挥Ariane）计划的一系列延期和问题的另一起，1995年一次发动机测试时氮泄露杀死了两名工程师。然而，这次六月事故是第一起将原因直接归究于软件故障的事故。
    这次事故的商业冲击在装备上超过了5亿美元，1996年Ariane-4火箭和其前期变种囊括了世界发射合同的一半以上，领先美、俄、中的发射者。因此，Ariane火箭的失败使计划的可信性和潜在生意十分危险。
    将来的生意部分建立在新火箭比前述发射者运送更重的有效载荷入轨的能力。Ariane-5设计成运载达6.8吨的单颗卫星或合重5.9吨的双卫星。到2002年止进一步的开发工作就是希望在发射能力上再增加一吨。增加了的运输能力拥有明显的优势；通常，经营者通过共享发射来减少费用，因此Ariane能一次提供几个公司有效负载的发射。
    考虑在这个例子的上下文环境里质量的意思。Ariane-5证明是顾客错误指定的需求的结果。既然这样，开发者可能会申称系统是质量的它仅仅按照了错误原规格建立。代替地，被组成调查事故原因，寻求解决灾难办法的调查委员会提到：
    委员会的裁决速建立在东西Ariane-5项目组彻底坦率的阿述和文档的基础上，从一秀贩工程工作和文档的完整性和可跟综性考虑，文档已经证明了Ariane-5计划的高质量。(Lions et al 1996)
    但从用户和顾客的观点，规格过程本应该是规格缺陷：在伤害发生前迫使顾客纠正规格（这两方面）是够好的。调查委员会承认：
   SRI（问题原因最终被定位的子系统）的提供者仅仅遵从提供给它的规格说明，这个子系统保证只要一检测到故障处理器将停止工作。产生的异常不是由于随机失败而是设计错误。故障检测到了，但没有恰当处理，因为人们已经认为：软件只有在有故障时才应考虑纠正。委员会有理由相信此观点，也在Ariane-5软件设计中被接受。委员会赞同相反的观点。软件应该被假定是不完善的，直到应用普通认可的最好的实践方未能证明它是正确的为止。（Lions et al.1996）
    在后面的章节，我们将更详细地研究这个例子，考虑全开发者和顾客的决策上有关设计测试和维护上的暗示。我们将看到开发之初可怜的系统工程是如何导致一系列可怜的决策。依次导致灾难的。另一方面，对所有受关注东西的公开，包扩ESA和调查委员，与高质量文档及一个最诚挚的快速寻求真相的愿望，导致了直接问题的快速解决和一份有效防止未来的此类问题的计划。
    系统观点让调查委员会，在开发者配合下，把Ariane-5视为一子系统集。这个集合反映了问题的分析（下如本章所述）以便开发者能从事于带有明显不同功能的子系统中。例如：
    火箭在空中资态和运动由SRI系统测定。它有自己内部计算机，在哪里，在来自一个“strop-down”惯性平台（带有激光陀螺仪和加速计）的信息的基础上计算角度和速率。一自SRI的数据通过数据总线传到板上计算机（On –Bccrd ,OBC）,OBC执行飞行程序，通过侍服阀和液压激励的控制坚固的后推器的喷嘴和Vulcain低温发动机。
    但是，方案的集合必须色括对所有组件部分的总体认识，这些部分被放于一起观察的确定把它们粘于一起的胶水是否充和适当。在Ariane-5情况里，调查委员会暗示顾客与开发者本应一起工作的找到临界软件并确保它不仅能处理预料而且非预料的行为。
    这意味着临界软件——软件故障使任务处于风险之中——必须在非常详细的层次上确定下来，异常行为必须限定，一个合理的备份策略必须将软件故障考虑进来。（Lions et al 1996）.
1.11 本章对你意味着什么？
    本章已经介绍了许多对好的软件工程研究和实践很重要的概念。你，作为单独软件开发者，能以发下方式运用这些概念：
    在有人给你一个问解决时（无论方案是否涉及软件），你能通过把它分解组件部分和组件部分间的关系来分析之。然后，你能通过解决单个子问题，合并子问题成一整体一综合出一个解决方案。
    你必须理解，需求是会变的，即使人正分析问题，正建立一个方案的时候。因此你的方案应好好文档化并有伸缩性，你应该文档化你的设想和使用的算法（以便于以后很容易地更改）
    你必须从向个方面看质量，理解技术持量和商业质量是非常不同的。
    你必须使用抽象的度量来帮助确定问题和方案的本质方面。
    记住系统边界，以便你的系统不会与别的同你正建的系统交互的相关系统重叠。
从本页起“Deveyeopment Team”秋为开发团队
1.12 本章对你的开发团队意味着什么？
    你的很多工作是在作为一个较大开发团队的一员来做的。象我们在本章看到的，开发涉及需求分析，设计、实现、测试、配置管理、质量保证等等。团体的一些人可能看你一样同时担当几个角色，项目的成功在很大程度上依赖于团队成员间的交流和协调。我们已在本章看到你可通过如下选择来帮助你成功：
    对你团队的规模、风险水平、应用领域恰当的开发过程
    被很好集成并支持项目法要求的交流类型的工具
    能提供给你尽可能多的可见度和理解的试题 和支持

1.13 本章对研究人员的意义
    本章所讨论的问题都是很好可进一步研究的主题。我们已经提到软件工程中一些公开的问题、包括：
            简化问题处理的抽象的正确层次
            使问题和方案的本质属性可见和有帮助的正确度量
            一个可使子问题能解的恰当的问题解决
            使工具集成容易有效，使项目参与者最效交流的一个公共框架或符号 
    在后面章节，我们将描述许多技术。一些使用了并被很好的证明了的软件开发实践，而别的虽被推荐但还仅在一引起小的，“玩具”的，学生项目中得到验证。我们希望引导你如何去改善人现在正做的工作，并同时激发你对在未来尝试新技术和过程的创造力和思考。

1.14 学期项目(TERM PROJCT)
    不参与开发一个软件项目（与同事一道），你不可能学会软件工程。因此本书每一章将描述一个学期项目的信息，你可和一个同不团队来执行此学期项目的开发。此项目基于一个真实机构的一个真实系统，让你经历一些非常真实的挑战、分析、设计、实践、测试和维护。此外，因为你在和一个团队共同工作，所以你将安处理团队分歧和项目管理的问题。
    这个学期项目涉及的是（在人买房进可能要和银行商议的）贷款种类。银行通过多种途径产生收入，通常是以通过以低利润从储户借钱，然后以较高的利率把把钱以银贷款方式借出去。然而，长期财产贷款（如抵押）曲型地有长达15.25或甚至30年的其限。也就是说你有15.25或30年的时间来偿还贷款：年金（你最初借的钱）十按指定率的利息，尽管来自这些贷款利息的收入是有利的，但这些贷款长时间占用资金，妨碍了银行将资金用于其它交易。因而，银行常将贷款卖给稳固的机构，取得较短时期利润一换取资本以其他方式使用的自由。
    你的学期项目的应用程序被称为Loan Arranger（贷款安全系统），也用一配合一个（虚构的）金融联全组织(Financial Consolidotion Orgahization,Fco)处理买自很行的贷款。FCO通过从银行购买贷款再出售给投资者来赚钱。银行出售贷款给FCO，作为回报获得本金。然后，象我们将看到的，FCO出售贷款给那些愿意比银行等给更长时间获得回报和投资者。
    为弄明白交易如何进行，考虑你如何获得一笔购房贷款（被称为“代押”）
你可通过付$50,000作为初次支付（称为“down payment”）并支付余下$100，000的一笔贷款一购买一幢价值$150，000的房子。你从第一国家银行（First National Bamk）得到的贷款的期限可能是30年（以5%的利息），这个术语（注terms）意味着第一国家银行给你30年（贷款期限）来偿还你借的数量（本金）加上利息（无论什么你都不用马上返还）例如，你可能通过30年里每月支付一次一偿还这$100，000，不家未付余额的利息（也就是，360次分期付款或每月一次的支付）。如果初始余额是$100，000银行使用本金量利率，你必面还清的时间及每月支付额应相同的假是未计算的支付额。
    例如，假如银行告诉你每月支付额将是$536.82，第一月的利息是（1/12）×（0.5）×($100,000),或$416.67,此支付的余下部分（$53682416.67）用来减少年金: $120.15，因此利息减少到（1/12）×（0.5）×（$100,000），或$416.67。此支付的其余部分（$536.82 416.67）用来减少本金：$120.15。第二个月，你先用$100,000减去$120.15，因此利息减少到（1/12）×（0.5）×（$100,000-120.15），或$416.17。因此，第二个月支付额中仅$416.17是利息而余下部分$120.65用于减少其余本金。整个时间上，你支付越来越少的利息而更多的用于减少本金额，等到你付清了所有本金和拥有了你的财产，摆脱清除了银行施于的累赘。
    在你正在支付期间的某个时间，第一国家银行可能将你的贷款买给了FCO。每一国家限银行与FCO商议价格。依次他，FCO可能将你的贷款卖给ABC投资公司。你每月依然“支付抵押，但你的支付进入ABC，而不是第一国家银行。通常，FCO 以”色（bwndles）“出售贷款，而不是学独的贷款”，以便投资者基于风险、涉及的本金和期望的返还来购买一个贷款的收集（collection）。换句话说，一名投资者（如ABC）能和FCO签约，并详细说明也希望投资多少钱，多长时间、愿意承担多大风险（基于偿还贷款的人或机构的历史），期望的利润。
    Loan Arranger是一个让FCO分析员以选择一色贷款来匹配一名投资者乐意的投资特征的应用程序。应用程序取FCO从借出机构购买的贷款的信息。当一名投资者详细说明了投资标准后，系统选择满足标准的最佳贷款色。在系统允许一些高级优化——诸如从那些可用贷款的子集（例如，从所有属萨诸塞分的贷款，而非全部可用贷款中）选择最好的贷款色——的时候，系统将仍然允许一名分析员手工为客户选取择在一色中的贷款。除了色选择外，系统也自动化信息管理活动，如更新银行信息，更新贷款信息，和在银行每月提供贷款信息的增加此信息）
    我们能总结这样的信息：Loan Arranger系统允许一名贷款分析员存取有关由FCO从多名借出机构购买的、打算重新色装贷款未出售给其它投资者的抵押（家庭贷款，这里简单找述为“贷款”）的信息。由FCO购买用于投资和再出售的贷款信息仓储库中的投资历组合贷款信息。另外，系统允许贷款分析员创建贷款色来卖给投资者，Loan Arranger的一名使用者是跟踪FCO购买的抵押的贷款分析员。
    后几章，我们将更深处地探究系统需求。
图1.17皮克迪利显示系统边界的上下文图


