C语言编程魔法书：基于C11标准

# 目录

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706140112595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
第一章：介绍了计算编程语言的分类；描述了C语言的历史及演化；C语言的编程思想和注意事项；讲述了我们可以用于实践的主流C语言编译器，着重介绍了GNU的来龙去脉；讲述了C语言编译器将C语言代码翻译成最终机器码的大致流程

第二章：继承上一章，大致介绍了计算机体系结构、程序执行的大致流程；然后是整数和浮点数的存储方式；然后是地址与字节对齐、字符编码、处理器大端小端序、按位逻辑运算和移位操作。这些知识都是学习C语言必备的！

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706142924247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706140207973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)


第二部分

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706140831316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706143149394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706141206766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706143620323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)


第三部分 
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706140531747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706144008639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

第4部分
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706141414957.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706144124535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)


第5部分
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706144225138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706141500459.png)

# 前言
为什么写这本书
国内市面上C语言参考书仍十分老旧
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706141902888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
为什么这个书名
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706142253557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

本书特色
最终的目的就是让读者至少能熟练掌握C语言编程，能将它灵活地运用于实际工程中![在这里插入图片描述](https://img-blog.csdnimg.cn/2021070614262634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
本书目的

最终的目的就是让读者至少能熟练掌握C语言编程，能将它灵活地运用于实际工程中


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706144356553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021070614432559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
# 1、预备知识篇

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706144733839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

快速略过这几章


## 第1章 C魔法概览

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706145219106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
### 1.1 例说编程语言
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706145806349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)


ARMv8架构处理器下的机器语言、汇编语言，加上它们相应的C语言


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706150022625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
my_sub.s

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706150304252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
汇编语言采用指令助记符的方式比写机器指令码要直观得多，而且也不容易出错

机器语言、汇编语言以及以C语言为代表的高级语言之间在表达力上的差距了
高级语言的目的就是为了给程序员提供更良好的编程工具，更简洁、更富有表达力的语言，使得我们程序员能提升生产力，并且能构思出更多精彩炫酷的应用，而不是把太多的精力都投入在如何让计算机执行的细节上。
计算功能是完全一致的
就可读性、可理解性以及编程便利性而言，显然C语言比起其他两者要强得多


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706161259566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
C语言的发明其实基于Unix操作系统
Dennis Ritchie所在的AT&T贝尔实验室用的Unix系统是完全用汇编语言写的
汇编的不足
- 不可移植
- 汇编语言本身要比高级语言精密

汇编语言面向的是底层硬件、一种过程化的编程风格的话，那么C语言就是面向数据流和算法、一种结构化的编程风格，结构化的、静态类型的编译型编程语言

用C语言编写了源代码之
后，需要通过C语言编译器进行编译，构建为相应的处理器能直接执行的机器码，然后处理器可以对生成出来的机器码进行执行
各个处理器上，处理器厂商或第三方只需要为当前处理器写一个对应的C语言编译器即可
任何符合C语言标准的程序都能在上面编译后执行
除了需要支持某些机器特定的功能和特性

K&RC语言与后来标准化的C语言有很大差异


C90

到了1989年，C语言由美国国家标准协会（ANSI）进行了标准化，此时C语言又被称为ANSI C
C语言标准作为K&R C的一个超集
尽管已经将函数定义的方式改为现在我们常用的那种方式，不过K&R的语法形式仍然兼容。

C99

引入了许多特性，包括内联函数（inline functions）、可变长度
的数组、灵活的数组成员（用于结构体）、复合字面量、指定成员的初始化器、对IEEE754浮点数的改进、支持不定
参数个数的宏定义，在数据类型上还增加了long longint以及复数类型
即便到目前为止，很少有C语言编译器是完整支持C99的

C11
到了2011年正式发布了ISO/IEC 9899：2011，简称为C11标准。C11标准新引入的特征尽管没C99相对C90引入的那么多，但是这些也都十分有用，比如：字节对齐说明符、泛型机制（generic selection）、对多线程的支持、静态断言、原子操作以及对Unicode的支持
关于C语言历史与演化进程的详细介绍可参考维基百科：https://en.wikipedia.org/wiki/C_%28programming_language%29。笔者近两年也是在不断地了解C语言标准委员会的最
新动态（可参见：http://www.open-std.org/jtc1/sc22/wg14/）

## 1.2 C语言编程的基本注意事项
可移植性  C语言被设计出来的一大初衷就是为了能将同一个源代码放到各个不同的平台上编译运行，注意C语言标准规定了哪些特性是编译器必须遵守的，哪些特性是平台或编译器自己实现的 尽量使用标准中已明文规定的编程规范，避免在不同平台可能会产生不同行为的语法特性
本书后面将会指出大部分主流平台对C语言标准中所提到的“实现定义”行为的区别
提到一些技巧来应对不同的平台特性

可维护性：一个良好
的C语言代码应该具有可读性、良好的文档化注释风格，以及较详细的设计文档
可延展性
如果我们在一个开发团队中，负责一个需要由多人合作开发的工程项目，我们写的功能模块需要与其他人写的功能模块进行对接，开发一个较大工程项目时，需要协调好各自对外的模块接口（Application Program Interface，API）
C语言没有全局名字空间（namespace）这个概念，所以命名一个对外接口也是非常重要的，否则可能会与其他功能模块的接口名发生冲突


性能
如何提升性能。需要程序员对处理器架构、硬件特性有一定了解。需要程序员对处理器架构、硬件特性有一定了解，针对实际需求灵活采用高效的算法。

## 1.3 主流C语言编译器介绍
当前主流桌面操作系统上，Visual C++、GCC以及LLVM Clang这三大编译器
VisualC++（简称MSVC）只能用于Windows操作系统，不开源——用户可以使用Visual Studio Community版本来免费使用它，商用比较麻烦。（开源 MSVC 的 C++ 标准库）


其余两个，除了可用于Windows操作系统之外，主要用于Unix/Linux操作系统，很多版本的Linux都默认使用GCC作为C语言编译器
像FreeBSD、macOS等系统默认使用LLVM Clang编译器
当前LLVM项目主要在Apple的主推下发展
在macOS中，Clang编译器又被称为Apple LLVM编译器

使用GCC与Clang编译器构建出来的应用一般没有任何限制，程序员
可以将应用程序随意发布和进行商用
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706200639455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
## 1.4 关于GNU规范的语法扩展（GNU语法扩展）
GNU是一款能用于构建类Unix操作系统的计算机软件合集
由自由软件之父Richard Stallman开创，1983年9月27日对外发布
完全由自由软件（freesoftware）构成（不等于免费）
GNU语法扩展源自于GCC编译器，在1987年发布1.0版本，称为GNU C Compiler
随后，GCC编译器前端[1]支持了C++、Objective-C/C++、Fortran、Ada、Java以及最近跃升的Go等编程语言，因此现在GCC被称为GNU Compiler Collection

在20世纪90年代，GNU C编译器就对C90标准做了相当多的语法扩展，包括复合字面量、匿名结构体和数组、可指定的初始化器等，这些语法扩展被广泛使用，尤其是大量用于Linux内核代码中，因此C99标准将这些语法特性全都列入标准之中


GCC本身是开源自由软件，很多商用编译器也基于GCC进行扩展
- ARM的RVCT（RealView Compiler Toolkit）支持GNU扩展

GCC编译器的目标代码优化能力相当高，而且还支持许多不同的处理器，当前被广泛使用并博得开发者的好评，Linux操作系统基本默认使用GCC作为默认编译器

由于GCC基于比较严格的GPL许可证（该许可证允许使用者免费使用软件，要求不能随意对它进行篡改并重新发布；如果开发者对它进行篡改，然后发布自己修改之后的软件，那么必须要把自己修改的那部分也开源出来）

因此，在2003年诞生了一个LLVM开源项目，基于更为宽松的BSD许可证（允许开发者随意对软件进行修改并重新发布，甚至可以将修改过的版本作为自主版权，深受大公司的欢迎），其编译器称为Clang——Apple对LLVM项目的投入非常大。macOS上的开发工具Xocde从4.0版本起就开始使用
Clang编译工具链，Apple将自己改写的Clang编译器称为Apple LLVM

Clang编译器并非基于GCC，它是从头开始写的，目标是尽量与GCC编译器兼容，包含大部分GNU语法扩展，含有它自己特有的C语言扩展。也有一些特性是GCC含有而Clang不具备的，这些特性一般很少使用

可以看到GNU语法扩展的适用性十分广泛
当前在做Linux/Unix、Windows上的C语言编程开发
在开发macOS/iOS应用
在开发macOS/iOS应用

完全可以毫无顾忌地使用GNU语法扩展！
最后几个章节会分别介绍GCC编译器特定的语法扩展以及Clang编译器特定的语法扩展（Clang编译器已经包含了大部分GNU语法扩展，在介绍GCC语法扩展的时候，如果当前特性Clang不支持，则会指明）
韦恩图

## 1.5 C语言构建可执行程序的流程
C语言的源文件在所有平台上都统一用.c文件表示

先用C语言把源代码写好，交给C语言编译器
C语言编译器内部分为前端和后端：
- 前端负责将C语言代码进行词法和语法上的解析，然后可以生成中间代码（不是必须的，但是它能够为程序的跨平台移植带来诸多好处，在一台计算机编译后，生成一套中间代码。然后针对不同的目标平台ARM处理器、MIPS处理器、x86处理器的二进制机器码），只需要编写相应目标平台的编译器后端即可，NxM，N+M——可以把编译器的前端与后端剥离开来，解耦合——不同处理器厂商可以针对自家的处
理器特性，对中间代码生成到目标二进制代码的过程再度进行优化
- 由C语言编译器后端生成源文件相应的目标文件，在Windows系统上往往是.obj文件；而在Unix/Linux系统上往往是.o文件

对于各个独立的目标文件，通过连接器将它们合并成一个最终可执行文件。连接器与C语言编译器是完全独立的。只要最终目标代码的ABI（应用程序二进制接口）一致（C语言与汇编语言的ABI是完全兼容的，大部分C语言编译器还支持直接内联汇编语言），我们可以把各个编译器生成的目标代码都放在一起，最后连接生成一个可执行文件（有些源代码可用GCC编译，有些使用Clang编译，还有些汇编语言源文件可直接通过汇编器生成目标代码，最后将所有这些生成出来的目标代码连接为可执行文件）

当前的C语言编译器最终翻译成的机器指令码与我们手工写汇编语言所得到的性能在大部分情况下相差无几。C语言基本能达成我们对性能的要求，而在某些对性能要求十分严苛的热点（hotspot）上，我们可以对这些功能模块手工编写汇编代码。

因此，C语言从1970年直到现在都是系统级编程的首要编程语言。


最终用户可以在当前的操作系统上加载可执行文件进行执行——操作系统利用加载器将可执行文件中相关的机器码存放到内存中来执行应用程序

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706202323201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

---
# 2. 学习C语言的预备知识
本章将主要给C语言初学者、计算机编程初学者，提供计算机编程中会涉及的基本知识。

## 2.1 计算机体系结构
一个简单的计算机系统包含了中央处理器（CPU）以及存储器和其他外部输入输出设备，在CPU内部则由计算单元、通用目的寄存器、程序序列器、数据地址生成器等部件构成
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706203128189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

### 2.1.1 贮存器（Storage）
我们在PC上使用的硬盘（Hard Disk）就是一种贮存器，也是一种存储器，它可用于持久保存数据而不丢失。通常把具有可持久保存的存储器统称为贮存器。PC上用得比较现代化的贮存器就是SSD（Solid-State Disk） 固态硬盘

贮存器就其存储介质来说属于ROM（Read-Only Memory），即只读存储器，特点是数据能持久保留——PC上的文件，即便在关闭计算机之后也一直会保存在你的硬盘上；PC上的软件往往也是以可执行文件的形式保存在硬盘上的

读写速度非常缓慢，尤其是老式的SATA磁盘，写操作则更慢——通常对ROM的数据修改都要通过先读取某段数据所在的扇区，然后对该数据进行修改，再擦除所涉及的扇区，最后把修改好的数据所包含的扇区再写回去（ROM需要擦除整个扇区再对整个扇区写入）——对于ROM来说，其扇区是有写入次数限制的，所以写入次数越多，损耗就越大

对于ROM来说，其扇区是有写入次数限制的，所以写入次数越多，损耗就越大——一个硬盘访问很慢的时候，通常就是其扇区（或磁道）已经破损严重了，这是在不断纠错并交换良好的扇区所引发的延迟

### 2.1.2 存储器（Memory）

指我们通常所说的内存或主存（Main Memory）
存储介质属于RAM（Random Access Memory）随机访问存储器（本书中存储器均表示内存RAM，将可持久保存数据的存储器都一律称
为“贮存器”）

特点是访问速度快，可对单个字节进行读写，更高效、灵活
RAM的数据无法持久化，掉电之后就会消失
RAM的成本也比ROM高昂得多（16GB的内存条与256GB SSD）

正因为RAM的访问速度快，并且离CPU更近，许多系统中都是将程序代码与数据先读取到RAM中之后再让CPU去执行处理的——即将RAM作为ROM的缓存。

在一些嵌入式系统中也有让CPU直接执行ROM中的代码并访问读ROM中常量数据的情况，这类系统中总线频率以及CPU频率都相对较低，ROM也是与CPU以SoC（System-On-Chip，系统级芯片）的方式整合在一块芯片上的，所以访问成本要低很多，有时甚至比读取RAM还更快些

### 2.1.3 寄存器（Register）
在CPU核心中的、用于暂存数据的存储单元。


一般CPU内部对数据的算术逻辑计算往往都需要通过寄存器（Register），而不是直接对外部存储器进行操作——比如，要计算一个加法或乘法计算，需要先把相关数据从外部存储器读到处理器自己的通用目的寄存器中，然后对寄存器做计算操作，再将计算结果也放入寄存器，最后将结果寄存器中的数据再写入外部存储器。

寄存器的访问速度非常快，它是这三种存储介质中速度最快的，但是数量也是最少的。

传统的32位x86处理器体系结构下，程序员一般能直接用的通用目的寄存器只有EAX、EBX、ECX、EDX、ESI、EDI、EBP这7个，ESP用于操作堆栈，往往无法用来处理通用计算。

### 2.1.4 计算单元
计算单元一般由算术逻辑单元（ALU）、乘法器、移位器构成
还包含除法器，以及用于做浮点数计算的浮点处理单元（FPU）
还包含除法器，以及用于做浮点数计算的浮点处理单元（FPU）
涉及数据读写的指令会由专门的加载、存储处理单元进行操作

### 2.1.5 程序执行流程
处理器在执行一段程序时，通常先从外部存储器取得指令，然后对指令进行译码处理，转换为相关的一系列操作——**可能是对寄存器的算术逻辑运算，也可能是对存储器的读写操作**

然后执行相关计算。最后把计算结果写回寄存器或写回到存储器

处理器在
执行一系列指令的时候并不是每条指令都必须先经过上面所描述的整个过程才能执行下一条，而是采用流水线的方式执行
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210707114116259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

一个简单的处理器执行完一条指令的完整过程：
假设从第一个取指令阶段到最后的写回阶段，这5个阶段均花费1个周期
不是采用流水线的方式，而是每完成一条指令的执行再执行下一条指令，那么每条指令的处理都需要5个周期

一旦采用流水线方式处理，那么我们可以看到，在第一条指令执行到译码阶段时，处理器可以对第二条指令做取指令操作；当第一条指令执行到执行阶段时，第二条指令执行到了译码阶段，此时第三条指令开始做取指令阶段，然后以此类推
当整条流水线填充满之后，即执行到了第5条指令，那么对于后续指令而言，处理每一条指令的时间均只需要一个周期

并不是每条指令都需要访存操作，只有当需要对外部存储器做读写操作时才会动用访存执行单元
然而大部分指令都需要写回寄存器操作
很多处理器会有空操作（NOP）指令，它仅仅占用一个时钟周期，而不会对除了指令指针寄存器（指令指针寄存器IP（X86型CPU）相当于ARM型CPU中的程序计数器PC）以外的任何寄存器产生影响

## 2.2 整数在计算机中的表示
日常用的整数都是十进制数（Decimal）
几乎所有计算机都采用二进制数（Binary）编码方式，二进制数则是逢二进一，所以在整串数中只有0和1两种数字
在计算机术语中，把二进制数中的某一位数又称为一个比特（bit），在度量上是最小的单位
一个字节由8个比特构成byte，某些单片机架构下还引入了半字节（nybble或nibble），4个比特
字（word）字在不同计算机架构下表示的含义不同
在x86架构下，一个字为2个字节；而在ARM等众多32位RISC体系结构下，一个
字表示为4个字节
计算机带宽的提升，能被处理器一次处理的数据宽度也不断提升，因此出现了双字（double word）、四字（quad word）、八字（octaword）等概念

### 2.2.1 原码表示法
无正负符号的原码，其二进制表达如上节

含有正负符号的原码，其二进制表示的最高有效位（即最左边的比特）作为一位符号位，用于表示正负号
其余各位比特表示该数的绝对值大小
十进制数6用一个8位
的原码表示为00000110；如果是-6，则表示为10000110

原码的表示非常直观，但给计算机算术运算带来了许多麻烦
上述的6与-6相加，即00000110+10000110，结果为10001100，也就是十进制数-12，显然不是我们想要的结果
如果某个处理器用原码表示二进制数，那么它参与加减法的时候，必须对两个操作数的正负符号加以判断，然后再判定使用加法操作还是减法操作，最后还要判定结果的正负符号
当前计算机的处理器往往采用补码的方式来表达带符号的二进制数

### 2.2.2 补码表示法
补码与原码一样，用最高位比特表示符号位，其余各位比特则表示数值大小

如果符号位为0，说明整个二进制数为正数或零，此时二进制补码表示法与原码一模一样；如果为1，那么表示整个二进制数为负数，为负数的时候，要求出整数的二进制补码表示，需要按以下步骤进行：
1）先将该数以绝对值的原码形式写好；
2）对整个二进制数（包括符号位），每一个比特都取反。
所谓取反就是说，原来一个比特的数值为0时，则要变1；为1时，则要变0。
变换好之后，将二进制数做加1计算，最终结果就是该负数的补码值了
+6的二进制补码跟原码一样，还是00000110
1）先将-6用绝对值+6的形式表示：00000110；2）对每个比特位取反，包括符号位在内，得到：11111001；3）将变换好的数做加1计算，最终得到：11111010

由于二进制补码的表示与通常我们可直接读懂的二进制数的表示有很大不同
给定一个二进制补码，我们往往需要先获得其绝对值大小才能知道它的具体数值：先判定符号位，如果符号位为0，那么就以通常的二进制数表示法来读即可；符号位为1，那么就以上述同样的过程得到其对应的绝对值

如果给定11111010这个二进制数，我们看到最高位符号位为1，说明是负数，我们就以上述过程来求
解：1）先将该二进制数每个比特做取反计算，得到：00000101；2）然后将变换得到的值做加1计算，最终获得：00000110。所以11111010的绝对值为00000110，即6。
1010
0110
0000
1 1111 001
0 0000 110

为什么对于二进制数来说，先减“1”取反和先取反再加“1”的结果是一样的，如何给出严格的数学证明？
另外对于x1x2x3x4这四位二进制来说，为什么加上1111之后相当于每位按位取反？为什么不考虑进位的问题？即如果x1x2x3x4为0001的话，按上述说法不考虑进位应该是1110，可加上的结果却是10000？这是什么回事？忘高手指点迷津。

这个问题确实很有意思，我的想法是这样的：
我们拿源码和补码来举例，大家可以看一下补码的产生。
我们都知道计算机只认识二进制0/1，为了表示正负，我们用最高位来区分，但是计算机还是不分正负，只认0/1。
由于用手机打字不方便，我就简述一下。
通常我们正数用原码表示，负数用补码表示，在这里为什么负数不用反码？是因为原码和反码相加结果就是一连串的1而不是0，而对二进制来说，只需要再加一个1就会让结果成为一连串0
**为了表示正负数，正负数最本质的特性就是值相同的正数和负数加起来为0**
因为**原码加补码为0**，我们已经**用原码表示了正数了**，那**补码我们就用来表示负数**
所以**求补码的过程**其实就是**正负转换的过程**
（x）>>>取反>>>加一>>>（-X）

这个过程看懂了你就明白为什么二进制数**取反加一和减一再取反**结果相同了

**从x到-x我们可以取反再加一（减1再取反），从-x到x我们可以先减一再取反或者取反再加1（逆过程为减一这个大家都懂）**
x + -x  = x + ~x + 1 = 1 000000
-x + x = -x + ~-x + 1 = 1 000000
正数取反+1得负数，负数取反+1得正数 => 你想求的相反数你可以逆着求，也可以说着取反加一这条路走下去，一直都是我们眼中的正负在转换

至于取反加一和减一取反的效果相同 => 我们从上面不难发现，一个x取反+1 = -x，那么-x-1取反，就又回到了x => 当x为正数时，-x为负数，负数减一再取反 和 负数取反加一 效果相同
当 x 为负数，同样由上面知道 负数取反+1 = 正数，于是-x为正数，正数减一再取反 相当于计算过程的逆序

x + -x = x + ~(x - 1)
-x + x = -x + ~(-x - 1) 


这个过程被解析成了两步，对于计算机来说根本没有正负之分，所以这个过程一直都是可逆的
**x取反加一变成（-x），那（-x）减一取反就为x**
如果大家还感觉不清楚，那是因为这不仅是一个双向的单行道，它还是个圈。
因为x取反加一变成了（-x），那（-x）取反加一又会变成x
负负得正大家都懂，我们的正负概念对于计算机来说，只不过是两种算法分两部进行，

对于补码表示，我们已经知道最高位比特表示符号位，其余的表示具体数值。但是这里有一个特殊情况，即符号位为1，其余位比特为都为0的情况。
一个8位二进制补码：10000000，此时它的值是多少？因为我们通过上述流程，求得其绝对值的大小也是10000000
当前大部分计算机处理器的实现将它作为-128，但估计仍然有一些处理器会把它作为-0——因为C语言标准中对于数值范围的表示已经明确表示出8位带符号的整数范围可以是-128到+127，也可以是-127到+127，但最小值不得大于-127，最大值不得小于+127

优点就是可以无视符号位，随意进行算术运算操作
6+（-6），计算结果：00000110+11111010=00000000最后，上述计算结果的最高位符号位所产生的进位被丢弃（在处理器中可能会设置相应的进位标志位）

在计算过程中，无需关心两个二进制补码的正负数的情况，也无需关心符号位所产生的影响
像计算普通二进制数一样去计算即可

把最终的计算结果拿出来判断，是正数还是负数
二进制补码会产生溢出（上溢和下溢）情况，比如两个8位二进制补码加法：120+50=01111000+00110010=10101010然而，这个数并不是170，而是-86

在C语言标准中**没有明确规定**C语言编译器的实现以及运行时环境必须采用哪种二进制编码方式，对整数类型标明最大可表示的数值范围。
目前大部分实现都是对带符号整数采用补码的表示方式

### 2.2.3 八进制数和十六进制数
十六进制数用得非常多
基数为2就是二进制；基数为10则是十进制
八进制数是逢八进一，因此每位数的范围是从0～7
十六进制数逢十六进一，因此每一位数的范围是从0到15（即0-9，A/a-F/f）

十六进制数比八进制数用得更多，因为十六进制数正好占用4个比特，即4位二进制数（范围从0000～1111）。4个比特相当于半个字节

开发工具还是程序调试工具，一般都会用十六进制数来表示计算机内部的二进制数据，这样更易读，而且也更省显示空间
一个字节原本需要8位二进制数，而十六进制数只要两位即可表示

用0或0o打头的数表示八进制数，0x打头的数表示十六进制数

## 2.3 浮点数在计算机中的表示
当前主流处理器一般都能支持32位单精度浮点数与64位双精度浮点数的表示和计算，遵循IEEE754-1985工业标准
最新的版本是2008，其中增加了对16位半精度浮点数以及128位四精度浮点数的描述，当前主流C语言编译器尚未很好地支持半精度浮点数与四精度浮点数的表示和计算

C语言标准引入了一个浮点模型，可用来表达任意精度的浮点数

IEEE754-1985中规格化（normalized）浮点数的表示法

## 2.4 地址与字节对齐
C语言是接近底层硬件的编程语言，能直接对存储器地址进行访问——在大部分处理器的操作系统应用层访问到的是逻辑地址；部分嵌入式系统由于不含存储器管理单元，因此可直接访问物理地址。

“地址”就是用来标识存储单元的一个编号。为了要访问存储器中特定单元的一个数据，我们首先要获悉该数据所在的地址，然后通过这个地址来访问它。

访问存储器，我们也简称为“访存”（MemoryAccess）。访问地址，我们也简称为“寻址”（Addressing）。一般计算机架构中都会有地址总线和数据总线——CPU先通过地址总线发送寻址信号，以指定所要访问存储器单元的地
址。然后再通过数据总线向该地址读写数据，这样就完成了一次访存操作。类似于快递送货/取件，先打电话告诉快递通信地址，然后快递员把货送到该地址（写数据），或者去该地址取件（读数据）。





