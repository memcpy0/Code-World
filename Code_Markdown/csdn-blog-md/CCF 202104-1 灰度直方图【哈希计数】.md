**问题描述**
一幅长宽分别为 $n$ 个像素和 $m$ 个像素的灰度图像可以表示为一个 $n \times m$  大小的矩阵 $A$ 。其中每个元素 $A_{ij}$ （$0\le i \lt n$、$0\le j \lt m$）是一个 $[0, L)$ 范围内的整数，表示对应位置像素的灰度值。具体来说，一个 $8$ 比特的灰度图像中每个像素的灰度范围是 $[0, 128)$ 。

一副灰度图像的灰度统计直方图（以下简称“直方图”）可以表示为一个长度为 $L$ 的数组 $h$ ，其中 $h[x]$（$0\le x \lt L$）表示该图像中灰度值为 $x$ 的像素个数。显然，$h[0]$ 到 $h[L - 1]$ 的总和应等于图像中的像素总数 $n \times m$ 。

已知一副图像的灰度矩阵 $A$ ，试计算其灰度直方图 $h[0], h[1], ..., h[L - 1]$ 。

**输入格式**
输入共 $n + 1$ 行。

输入的第一行包含三个用空格分隔的正整数 $n$ 、$m$ 和 $L$ ，含义如前文所述。

第二到第 $n + 1$ 行输入矩阵 $A$ 。第 $i+2$（$0\le i \lt n$）行包含用空格分隔的 $m$ 个整数，依次为 $A_{i0}, A_{i1}, ..., A_{i(m-1)}$ 。

**输出格式**
输出仅一行，包含用空格分隔的 $L$ 个整数
 $h[0], h[1], ..., h[L - 1]$ ，表示输入图像的灰度直方图。
 
**样例输入**

```haskell
4 4 16
0 1 2 3
4 5 6 7
8 9 10 11
12 13 14 15
```
**样例输出**

```haskell
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
 
**样例输入**

```haskell
7 11 8
0 7 0 0 0 7 0 0 7 7 0
7 0 7 0 7 0 7 0 7 0 7
7 0 0 0 7 0 0 0 7 0 7
7 0 0 0 0 7 0 0 7 7 0
7 0 0 0 0 0 7 0 7 0 0
7 0 7 0 7 0 7 0 7 0 0
0 7 0 0 0 7 0 0 7 0 0
```

**样例输出**
 
```haskell
48 0 0 0 0 0 0 29
```

 
**评测用例规模与约定**
全部的测试数据满足 $0 \lt n, m \le 500$ 且 $4 \le L \le 256$ 。


---
### 解法 哈希计数
很简单的题目，答案如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, l, c;
int main() {
	scanf("%d%d%d", &n, &m, &l);
	vector<int> h(l);
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < m; ++j) {
			scanf("%d", &c);
			++h[c];
		}
	}
	for (int i = 0; i < l; ++i) printf(" %d" + !i, h[i]);
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/23a565918d5a43b08d86e69f6999a71f.png)
