@[toc]

> `Makefile` 文件描述了 `Linux` 系统下 `C/C++` 工程的编译规则，它用来自动化编译 `C/C++` 项目。一旦编写好 `Makefile` 文件，只需要一个 `make` 命令，整个工程就开始自动编译，不再需要手动执行 GCC 命令。
> 一个中大型 `C/C++` 工程的源文件有成百上千个，它们按照功能、模块、类型分别放在不同的目录中。`Makefile` 文件定义了一系列规则，指明了源文件的编译顺序、依赖关系、是否需要重新编译等。
> 一个 `Linux C/C++` 程序员必须会编写 `Makefile` 文件，否则就玩不转中大型项目。

----
# 1. `Makefile` 文件概述
如果是在Windows下，由于IDE已经内置或者会自动生成 `Makefile`，我们无需手动编写。但是到了*nix环境下，我们则需要自己完成这些工作。所以，想要在Linux下做开发，`Makefile` 是必须掌握的一项技能。那么，什么是 `Makefile` ？

简单来说，`Makefile` 描述了整个工程的编译和链接等规则。其中包含了那些文件需要编译、那些文件不需要编译、那些文件需要先编译、那些文件需要后编译、那些文件需要重建等等。编译整个工程需要涉及到的所有命令和规则，在 `Makefile` 中都可以进行描述。`Makefile` **使我们的项目工程的编译变得自动化**，**不需要每次都手动输入一堆源文件和参数**。

以 `Linux` 下的C语言开发为例来具体说明一下，多文件编译生成一个文件，编译的命令如下所示：
```shell
gcc -o outfile name1.c name2.c ...
```
`outfile` 是要生成的可执行程序的名字，`nameN.c` 是源文件的名字。这是我们在 `Linux` 下使用 `gcc` 编译器编译 C文件的例子。**如果我们遇到的源文件的数量不多，可以选择这样的编译方式**。如果源文件非常多，就会遇到下面的问题。
- 编译的时候需要链接库。拿C语言来说，编译的时候 `gcc` 只会**默认链接一些基本的C语言标准库**，很多源文件依赖的标准库都需要我们手动链接。下面列举了一些需要手动链接的标准库：
	-  用到了数学计算库 `math` 中的函数，我们得手动添加参数 `-Im` ；
	 - 用到了小型数据库 `SQLite` 中的函数，我们得手动添加参数 `-lsqlite3` ；
	 
	 -  使用到了线程，我们需要去手动添加参数 `-lpthread` 。
	
	因为有很多文件，还有很多要链接的第三方库。所以编译时命令会很长。还可能涉及到文件链接的顺序问题，所以手动编译会很麻烦。
如果我们学会使用 `Makefile` 就不一样了，它彻底简化了编译的操作。把要链接的库文件放在 `Makefile` 中，制定相应的规则和对应的链接顺序。这样只需要执行 `make` 命令，工程就会自动编译。每次想要编译工程的时候就执行 `make` ，省略掉手动编译中的参数选项和命令，非常的方便。

- 编译大的工程会花费很长的时间。
如果我们去做项目开发，免不了要修改工程项目的源文件，每次修改后都要重新编译。一个大的工程项目里面的源文件个数可能有成百上千个。例如一个内核的源码包。要完成这样的文件的编译，消耗的时间可不是一点点。如果文件特别大的话可能要花上半天的时间。
对于这样的问题 `Makefile` 可以解决吗？当然可以，`Makefile` 支持多线程并发操作，能极大缩短编译时间，并且修改了源文件之后，编译整个工程时，`make` 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，极大解决了时间耗费的问题。

这两个是可能遇到的比较常见的问题，当然，问题还会有很多，比如：工程文件中的源文件的类型很多，编译时需要选择编译器；文件可能会分布在不同的目录中，使用时需要调整路径。

这些问题都可以通过 `Makefile` 解决。而且，文件中的 `Makefile` 只需要完成一次，一般只要不增加或者是删除工程中的文件，`Makefile` 基本上不用去修改，编译时只用一个 `make` 命令就可以完成，从而提供了极大的便利，很大程度上提高了编译的效率。

---
# 2. `Makefile` 文件中包含哪些规则？
想要书写一个完整的 `Makefile`文件，需要了解 `Makefile` 相关的书写规则。它的规则主要是两个部分组成，分别是**依赖的关系和执行的命令**，其结构如下所示：
```shell
targets : prerequisites
    command
```

相关说明如下：
- `targets` ：规则的目标文件。可以是 `Object File` **中间文件**，也可以是**可执行文件**，还可以是一个**标签**；
- `prerequisites` ：是我们的依赖文件，要生成 `targets` 需要的文件。可以是多个，也**可以是没有**；
- `command` ：`make` 需要执行的命令（任意的 **<font color="red">shell</font>** 命令）。可以有多条命令，每一条命令占一行。
- 注意：我们的**目标和依赖文件之间要使用冒号分隔开**；**命令的开始一定要使用Tab键**。

通过下面的例子来具体使用一下 `Makefile` 的规则：
- `test.c` 中代码如下：
	```c
	#include <stdio.h>
	
	int main() {
	    printf("Hello `Makefile`!\n");
	    return 0;
	}
	```
- `Makefile` 文件中添代码如下：
	```handlebars
	test : test.c
	    gcc -o test test.c
	```
	
上述代码的功能就是编译 `test.c` 文件，通过这个实例可以详细说明 `Makefile` 的具体使用。其中 `test` 是**目标文件**，也是**最终生成的可执行文件**。依赖文件就是 `test.c` 源文件。生成目标文件需要执行的操作是 `gcc -o test test.c` 。这就是 `Makefile` 的基本语法规则。 

在 **<font color="red">shell</font>** 中进入相应文件夹，输入 `make` ，得到 `test` 目标文件。过程如下：
```shell
$ make
gcc -o test test.c
$ ./test
Hello `Makefile`!
```
通过上面的例子，我们发现， `Makefile` 的规则很简单，但这并不是 `Makefile` 的全部，而是它的冰山一角。仅靠一个规则远远无法满足大的工程项目的编译。所以要学习的东西还有很多。

简单的概括一下`Makefile` 中的内容，它主要包含有五个部分，分别是：
1. 显式规则
显式规则说明：如何**生成一个或多个的目标文件**。这要由 `Makefile` 的书写者明显指出，要生成的文件、文件的依赖文件、生成的命令。
2) 隐晦规则
由于我们的 `make` 命名有自动推导的功能，所以，**隐晦的规则可以让我们比较粗糙简略地书写** `Makefile`，这是由 `make` 命令所支持的。
3) 变量定义
在 `Makefile` 中我们要定义一系列的变量，变量一般都是字符串，这有点像C语言中的宏，当 `Makefile` 被执行时，**其中的变量都会被扩展到相应的引用位置上**。
4) 文件指示
其包括了三个部分：
	- 其一：在一个 `Makefile` 中引用另一个 `Makefile`，就像C语言中的 `include` 一样；
	- 其二：根据某些情况指定 `Makefile` 中的有效部分，就像C语言中的预编译 `#if` 一样；
	- 其三：定义一个多行的命令。有关这一部分的内容，会在后续的部分中讲述。
5) 注释
`Makefile` 中只有行注释，和UNIX的Shell脚本一样，其注释是用 `#` 字符。如果要在 `Makefile` 中使用 `#` 字符，可以用反斜号进行转义，如：`\#` 。

---
# 3. `Makefile` 的工作流程
简单了解了 `Makefile` 书写规则之后，再来深入研究一下 `Makefile` 是怎样工作的。

当我们在执行 `make` 条命令的时候，`make` 就会去当前文件下找要执行的编译规则，也就是 `Makefile` 文件。我们编写 `Makefile` 时可以使用的文件的名称有：`GNUmakefile` 、`makefile` 、`Makefile` 。找文件的顺序也是这样的。

推荐使用 `Makefile`（一般在工程中都这么写，大写会比较规范）。如果文件不存在，`make` 就会给我们报错，提示：`make：*** 没有明确目标并且找不到 makefile` 。


`Makefile` 的具体工作流程可以通过下面的例子来看一下。
- 首先创建一个包含有多个源文件和 `Makefile` 的目录文件，源文件之间相互关联。在 `Makefile` 中添加下面的代码：
	```handlebars
	main : main.o test1.o test2.o
		gcc main.o test1.o test2.o -o main
	main.o : main.c test.h
		gcc -c main.c -o main.o
	test1.o : test1.c test.h
		gcc -c test1.c -o test1.o
	test2.o : test2.c test.h
		gcc -c test2.c -o test2.o
	```

在我们编译项目文件的时候，**默认情况下**，`make` **执行的是** `Makefile` **中的第一规则**（`Makefile` 中出现的**第一个依赖关系**），此规则的第一目标称之为“最终目标/终极目标”。
- 在 **<font color="red">shell</font>** 中执行 `make` 命令，可以得到可执行文件 `main` 和中间文件 `main.o, test1.o, test2.o` ，`main` 就是我们要生成的最终文件。可以发现，目标 `main` 在 `Makefile` 中是第一个目标，因此它就是 `make` 的终极目标。修改过任何C文件后，执行 `make` 都将会重建终极目标 `main` 。
- 它的具体工作顺序是：当在 **<font color="red">shell</font>** 提示符下输入 `make` 命令以后， `make` 读取当前目录下的 `Makefile` 文件，并将 `Makefile` 文件中的**第一个目标**作为其执行的“终极目标”，**开始处理第一个规则**（终极目标所在的规则）：
	- 在我们的例子中，第一个规则就是目标 `main` 所在的规则。规则描述了 `main` 的依赖关系，并定义了链接 `.o` 文件生成目标 `main` 的命令；
	- `make` 在执行这个规则所定义的命令之前，**首先处理终极目标** `main` **的所有的依赖文件**（例子中的那些 `.o` 文件）的更新规则（以这些 `.o` 文件为目标的规则）。
- 对这些以 `.o` 文件为目标的规则处理有下列三种情况：
	-    目标 `.o` 文件**不存在**，使用其描述规则创建它；
	-    目标 `.o` 文件**存在**，它所依赖的 `.c, .h` 文件中的任何一个比目标 `.o` 文件“更新”（在上一次 `make` 之后被修改）。则根据规则重新编译生成它；
	-    目标 `.o` 文件**存在**，它比任何依赖文件（`.c, .h` 文件）**更新**（它的依赖文件在上一次 `make` 之后没有被修改），则什么也不做。


通过上面的更新规则，我们可以了解到中间文件的作用，也就是编译时生成的 `.o` 文件——作用是检查某个源文件是不是进行过修改，最终目标文件是不是需要重建。

我们执行 `make` 命令时，**只有修改过的源文件或是不存在的目标文件会进行重建**，而那些没有改变的文件不用重新编译，这样在很大程度上节省时间，提高编程效率。小的工程项目可能体会不到，项目工程文件越大，效果才越明显。

当然， `make` 命令能否顺利的执行，还取决于是否制定了正确的的依赖规则、当前目录下是不是存在需要的依赖文件。只要任意一点不满足，在执行 `make` 的时候就会出错。所以完成一个正确的 `Makefile` 不是一件简单的事情。

**清除工作目录中的过程文件**
我们在使用的时候会产生中间文件会让整个文件看起来很乱，所以在编写 `Makefile` 文件时会**在末尾**加上这样的规则语句：

```handlebars
.PHONY : clean
clean:
    rm -rf *.o test
```

其中 `*.o` 是执行过程中产生的中间文件，`test` 是最终生成的执行文件。可以看到 `clean` 是独立的，不依赖任何文件，**它只是一个伪目标，不是具体的文件**。不会与第一个目标文件相关联，所以我们在执行 `make` 的时候也不会执行下面的命令。

在 **<font color="red">shell</font>** 中执行 `make clean` 命令，编译时的中间文件和生成的最终目标文件都会被清除，方便我们下次的使用。

---
# 4. `Makefile` 通配符的使用
`Makefile` 是可以使用 **<font color="red">shell</font>** 命令的，所以 **<font color="red">shell</font>** 支持的通配符在 `Makefile` 中也是同样适用的。 **<font color="red">shell</font>** 中使用的通配符有：`*, ?, [...]`。

下面具体看一下这些通配符的表示含义和具体的使用方法。
| **通配符** | **使用说明** |
|:--:|:--:|
| `*` | 匹配0个或者任意个字符
| `?` | 匹配任意一个字符
| `[]` | 把指定匹配的字符放在 [] 中

通配符可以出现在模式的**规则**中，也可以出现在**命令**中，详细的使用情况如下。

示例1：
```shell
.PHONY : clean
clean:
    rm -rf *.o test
```
这是在 `Makefile` 中经常使用的规则语句。这个实例可以说明**通配符可以使用在命令当中**，表示的是任意的以 `.o` 结尾的文件。

示例2：
```shell
test : *.c
    gcc -o $@ $^
```
这个实例可以说明，**通配符不仅可以使用在命令中，还可以使用在规则中**。如用来表示生所有的以 `.c` 结尾的文件。

但是，如果通配符使用在依赖的规则中的话，一定要注意：<font color="red">**不能通过引用变量的方式来使用通配符**</font>，如下所示。
```shell
OBJ = *.c
test : $(OBJ)
    gcc -o $@ $^
```
我们执行这个命令的时候会出现错误，提示我们没有 `*.c` 文件，实际上，我们想要表示的是当前目录下所有的 `.c` 文件，但在使用的时候并没有展开，而是直接识别成了一个文件。文件名是 `*.c` 。

如果我们就是想要**引用含有通配符的变量**，要使用一个函数 `wildcard` ，这个函数在引用变量的时候帮我们展开。把上面的代码修改一下就可以使用了。
```shell
OBJ = $(wildcard *.c)
test : $(OBJ)
    gcc -o $@ $^
```
这样再去使用的时候就可以了。调用函数的时候，会帮我们自动展开。

还有一个和通配符 `*` 类似的字符，这个字符是 `%` ，也是匹配任意个字符，使用在我们的规则当中：
```shell
test : test.o test1.o
    gcc -o $@ $^
%.o : %.c
    gcc -o $@ $^
```

 `%.o` 把我们需要的所有 `.o` 文件组合成为一个列表，从列表中挨个取出的每一个文件，`%` 表示取出来文件的文件名（不包含后缀），然后找到文件中和 `%` 名称相同的 `.c` 文件，执行下面的命令，直到列表中的文件全部被取出来为止。

这个属于 `Makefile` 的**静态模规则**：规则存在多个目标，并且**不同的目标可以根据目标文件的名字来自动构造出依赖文件**。跟多规则目标的意思相近，但是又不相同。

---
# 5. `Makefile` 变量的定义和使用
我们对变量很熟悉，它可以保存一个值或者进行运算。`Makefile` 中的变量也是这样，利用它来表示某些重复使用而又可能发生变化的内容，不仅可以节省时间，还可以避免遗漏。

## (1) 变量的定义
`Makefile` 文件中定义变量的基本语法如下：
```
变量的名称=值列表
```
- `Makefile` 中变量的使用非常简单，因为不像C语言那样要定义变量的数据类型。
- 变量的名称可以由**大小写字母、阿拉伯数字和下划线**构成。等号左右的空白符没有明确的要求，因为在执行 `make` 的时候多余的空白符会被自动的删除。
- 值列表，**既可以是零项，又可以是一项或者是多项**。如：
	```python
	VALUE_LIST = one two three
	```
- 调用变量的时候可以用 `$(VALUE_LIST)` 或者是 `${VALUE_LIST}` 来替换，**这就是变量的引用**。如：
	```shell
    OBJ = main.o test.o test1.o test2.o
    test : $(OBJ)
          gcc -o test $(OBJ) 
    ```
  这就是引用变量后 `Makefile` 的编写，比之前的编写方式要简单得多。要添加或者是删除某个依赖文件的时候，我们只需要改变变量 `OBJ` 的值就可以了。

## (2) 变量的基本赋值
知道了如何定义，下面说一下 `Makefile` 的变量的四种基本赋值方式：
-    简单赋值 ( `:=` ) ：编程语言中常规理解的赋值方式，**只对当前语句的变量有效**。
-   递归赋值 ( `=` ) ：赋值语句可能影响多个变量，**所有目标变量相关的其他变量都受到影响**。
 -    条件赋值 ( `?=` ) ：如果**变量未定义**，则使用符号中的值定义变量。如果该变量**已经赋值**，则该赋值语句无效。
 -    追加赋值 ( `+=` ) ：原变量**用空格隔开的方式追加一个新值**。


### ① 简单赋值

```shell
x := foo
y := $(x)b
x := new
test:
      @echo "y=>$(y)"
      @echo "x=>$(x)"
```
在 **<font color="red">shell</font>** 中执行 `make test` 我们会看到：
```<font color="red">shell</font>
y=>foob
x=>new
```
### ② 递归赋值
```shell
x = foo
y = $(x)b
x = new
test:
      @echo "y=>$(y)"
      @echo "x=>$(x)"
```
在 **<font color="red">shell</font>** 中执行 `make test` 我们会看到：
```<font color="red">shell</font>
y=>newb
x=>new
```
### ③ 条件赋值
```shell
x := foo
y := $(x)b
x ?= new
test:
      @echo "y=>$(y)"
      @echo "x=>$(x)"
```
在 **<font color="red">shell</font>** 中执行 `make test` 我们会看到：
```shell
y=>foob
x=>foo
```
### ④ 追加赋值
```shell
x := foo
y := $(x)b
x += $(y)
test:
      @echo "y=>$(y)"
      @echo "x=>$(x)"
```
在 **<font color="red">shell</font>** 中执行 `make test` 我们会看到：
```<font color="red">shell</font>
y=>foob
x=>foo foob
```

不同的赋值方式会产生不同的结果，我们使用的时候**应该根据具体的情况选择相应的赋值规则**。

变量使用的范围很广，它可以**出现在规则的模式中**，也可以**出现在规则的命令中**，或者是作为 `Makefile` 函数的参数来使用。总之，变量在 `Makefile` 编写中是非常广泛的、必不可少的。

另外，变量在 `Makefile` 中还有很多种类，它们的意义也各不相同。比如环境变量，自动变量，模式指定变量等。其他的变量我们会在后续介绍。



---
# 6. `Makefile` 自动化变量 
**自动化变量**可以理解为由 `Makefile` 自动产生的变量。在**模式规则**中，规则的目标和依赖的文件名代表了一类的文件，规则的命令是对所有这一类文件的描述。我们在 `Makefile` 中描述规则时，依赖文件和目标文件是变动的，显然在命令中不能出现具体的文件名称，否则模式规则将失去意义。

那么模式规则命令中该如何表示文件呢？就需要使用自动化变量，自**动化变量的取值根据执行的规则来决定**，取决于执行规则的目标文件和依赖文件。下面是对所有的自动化变量进行说明：

| **自动化变量** | **说明** |
|:--|:--|
| `$@`| 表示规则的**目标文件名**；如果目标是一个文档文件(Linux 中一般称 `.a` 文件为文档文件，也称为静态库文件），那么它代表这个文档的文件名；在多目标模式规则中，它代表的是触发规则被执行的文件名。
| `$%`|  当目标文件是一个静态库文件时，代表静态库的一个成员名。
| `$<`| 规则的**第一个依赖文件名**；如果是一个目标文件使用隐含规则来重建，则它代表由隐含规则加入的第一个依赖文件。
|`$?`|	**所有比目标文件更新的依赖文件列表**，空格分隔；如果目标文件是静态库文件，代表的是库文件（`.o` 文件）。
|`$^`	|代表的是**所有依赖文件列表**，使用空格分隔；如果目标是静态库文件，它所代表的只能是所有的库成员（`.o` 文件）名。一个文件可重复的出现在目标的依赖中，变量 `$^` 只记录它的第一次引用的情况。就是说变量 `$^` 会去掉重复的依赖文件。
| `$+` |	类似 `$^` ，但是它**保留了依赖文件中重复出现的文件**。主要用在程序链接时库的交叉引用场合。
|`$*` |	在模式规则和静态模式规则中，代表 `茎` 。`茎` 是目标模式中 `%` 所代表的部分（当文件名中存在目录时，`茎` 也包含目录部分）。


下面就自动化变量的使用举几个例子。

实例1：
```shell
test : test.o test1.o test2.o
	gcc -o $@ $^
test.o : test.c test.h
	gcc -o $@ $<
test1.o : test1.c test1.h
	gcc -o $@ $<
test2.o : test2.c test2.h
	gcc -o $@ $<
```

这个规则模式中用到了 `$@, $<, $^` 这三个自动化变量，对比之前写的 `Makefile` 中的命令，可以发现 `$@` 代表的是目标文件 `test` ，`$^` 代表的是全部的依赖文件，`$<` 代表的是依赖文件中的第一个。

我们在执行 `make` 的时候，`make` **自动识别命令中的自动化变量，并实现自动化变量中值的替换**，类似于编译C语言文件的预处理的作用。


实例2：
```shell
lib : test.o test1.o test2.o
	ar r $?
```
假如要做一个库文件，库文件的制作依赖于这三个文件。当修改了其中的某个依赖文件，在命令行执行 `make` 命令，库文件 `lib` 就会自动更新。`$?` 表示修改的文件。

在这些变量中加入字符 `D` 或者 `F` 就形成了一系列**变种的自动化变量**，这些自动化变量可以对文件的名称进行操作。下面是一些详细的描述：

|变量名 |	功能|
|:---|:--|
| `$(@D)` | 	表示**文件的目录部分**（不包括斜杠）。如果 `$@` 表示的是 `dir/foo.o` ， 那么 `$(@D)` 表示的值就是 `dir` ；如果 `$@` 不存在斜杠（文件在当前目录下），其值就是 `.` 。
|`$(@F)` | 	表示的是**文件除目录外的部分**（实际的文件名）。如果 `$@` 表示的是  `dir/foo.o` ，那么 `$@F` 表示的值为 `foo.o` 。
|`$(%D), $(%F)` | 	当以 `archive(member)` 形式的静态库为目标时，分别表示库文件成员 `member` 名中的**目录部分和文件名部分**。
| `$(<D), $(<F)` |	表示**第一个依赖文件**的目录部分和文件名部分。
| `$(?D), $(?F)` | 	分别表示**更新的依赖文件**的目录部分和文件名部分。
| `$(^D), $(^F)` |	分别表示**所有依赖文件**的目录部分和文件部分。
| `$(+D), $(+F)` | 	分别表示**所有依赖文件**的目录部分和文件部分。
| `$(*D), $(*F)` | 	分别代表 `茎` 中的**目录部分和文件名部分**



