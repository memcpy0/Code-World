> 算法导论第10章 基本数据结构
> 算法导论第22.1节 图的表示![在这里插入图片描述](https://img-blog.csdnimg.cn/4553ab9902664bed81c29eade5c658d9.png)

@[toc]

在这里，我们要讨论如何通过「使用指针的简单数据结构」来表示动态集合。虽然运用指针、可以构造多种复杂的数据结构，但这种只介绍几种基本的结构：栈、队列、链表和有根树、图。此外，还要介绍由数组构造对象和指针的方法。

# 1. 栈和队列
栈和队列都是动态集合，且在其上进行 `DELETE` 操作所移除的元素是预先设定的。在**栈** `stack` 中，被删除的是最近插入的元素：栈实现的是一种**后进先出** `last-in, first-out, LIFO` 策略。类似地，在**队列** `queue` 中，被删去的总是在集合中存在时间最长的那个元素：队列实现的是一种**先进先出** `first-in, first-out, FIFO` 策略。在计算机上实现栈和队列，有几种有效方式。这里介绍如何利用一个简单的数组实现这两种结构。
## 1.1 栈
栈上的 `INSERT` 操作称为**压入** `PUSH` ，而无元素参数的 `DELETE` 操作称为**弹出** `POP` 。这两个名称使人联想到现实中的栈，比如餐馆里堆叠的盘子，盘子拿起的次序与它们放入的次序相反，这是因为只有最上面的盘子才能被取下来。

如图10-1所示，可以用一个数组 $S[1\dots n]$ 来实现一个最多可容纳 $n$ 个元素的栈，该数组有一个属性 `S.top` ，指向最新插入的元素。栈中包含的元素为 $S[1\dots S.top]$ ，其中 $S[1]$ 是栈底元素，而 $S[S.top]$ 是栈顶元素。
![](https://img-blog.csdnimg.cn/c627f979602f4f0d8ed581cfe9aae027.png)
当 $S.top = 0$ 时，栈中不包含任何元素，即栈是**空** `empty` 的。要测试一个栈是否为空，可以用查询操作 `STACK-EMPTY` 。如果试图对一个空栈执行弹出操作，则称**栈下溢** `underflow` ，这通常是一个错误。如果 `S.top` 超过了 $n$ ，则称**栈上溢** `overflow`（下面的伪代码中不考虑栈的上溢问题）。

栈的几种操作，只需分别用几行代码来实现：
```cpp
STACK-EMPTY(S)
	if S.top == 0
		return true
	else return false

PUSH(S, x)
	S.top = S.top + 1
	S[S.top] = x

POP(S)
	if STACK-EMPTY(S)
		error "underflow"
	else S.top = S.top - 1
		return S[S.top + 1]
```
图10-1所示，为修改后的 `PUSH` 和 `POP` 操作的执行结果。三种栈操作的执行时间都为 $O(1)$ 。

## 1.2 队列
队列上的 `INSERT` 操作，称为**入队** `ENQUEUE` ，`DELETE` 操作称为**出队** `DEQUEUE` ；正如栈的 `POP` 操作一样，`DEQUEUE` 操作也没有元素参数。队列的先进先出特性，类似于收银台前排队等待结账的一排顾客。队列有**队头** `head` 和**队尾** `tail` ，当有一个元素入队时，它被放在队尾的位置，就像一个新到来的顾客排在队列末端一样；而出队的元素则总是在队头的那个，就像排在队伍前面等待最久的那个顾客一样。

图10-2表明利用数组 $Q[1\dots n]$ 来实现一个「最多容纳 $n - 1$ 个元素的队列」的一种方式。该队列有一个属性 `Q.head` 指向队头元素，而属性 `Q.tail` 则指向下一个新元素将要插入的位置。队列中的元素存放在位置 `Q.head, Q.head + 1, ..., Q.tail - 1` ，并在最后的位置“环绕”，就好像位置 $1$ 紧邻在位置 $n$ 后面形成一个环路。**当 `Q.head == Q.tail` 时，队列为空。初始时有 `Q.head = Q.tail = 1`** 。如果试图从空队列中删除一个元素，则队列发生下溢。当 `Q.head = Q.tail + 1` 时，队列是满的，此时如试图插入一个元素，则队列发生上溢。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c8b7d70ba4a94a2d88770f7f0b4c6c14.png)

在下面 `ENQUEUE, DEQUEUE` 程序中，省略了对下溢和上溢的检查（算导练习10.1-4要求给出检查两种错误情况的代码）。在下列伪代码中，假设 `n = Q.length` 。
```cpp
ENQUEUE(Q, x)
	Q[Q.tail] = x
	if Q.tail == Q.length
		Q.tail = 1
	else Q.tail = Q.tail + 1

DEQUEUE(Q)
	x = Q[Q.head]
	if Q.head == Q.length
		Q.head = 1
	else Q.head = Q.head + 1
	return x
```
图10-2所示为 `ENQUEUE, DEQUEUE` 操作的执行结果。两种操作的执行时间都为 $O(1)$ 。
 

---
# 2. 链表
**链表** `linked list` 是一种这样的数据结构，其中各对象按线性顺序排列。数组的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。链表为动态集合提供了一种简单而灵活的表示方法，并且能支持（算导10.1节）列出的所有操作（但未必非常有效）。

如图10-3所示，**双向链表** `doubly linked list` 的每个元素都是一个对象，每个对象有一个关键字 `key` 和两个指针：`next` 和 `prev` 。对象中还可以包含其他的辅助数据（或称卫星数据）。设 `x` 为链表的一个元素，`x.next` 指向它在链表中的后继元素，`x.prev` 则指向它的前驱元素。如果 `x.prev = NULL` 则元素 `x` 没有前驱，因此是链表的第一个元素，即链表的**头** `head` ；如果 `x.next = NULL` 则元素 `x` 没有后继，因此是链表的最后一个元素，即链表的**尾** `tail` 。属性 `L.head` 指向链表的第一个元素，如果 `L.head = NULL` 则链表为空。
![在这里插入图片描述](https://img-blog.csdnimg.cn/78e4283425b14f6d957ce41734f4cfb2.png)

链表可以有多种形式，它可以是单链接或双链接的，可以是已排序的或未排序的，可以是循环的或非循环的。如果一个链表是**单链接的** `singly linked` ，则省略每个元素中的 `prev` 指针。如果链表是**已排序的** `sorted` ，则链表的线性顺序与「链表元素中关键字的线性顺序」一致。据此，最小的元素就是表头元素，而最大的元素则是表尾元素。如果链表是**未排序的** `unsorted` 的，则各元素可以以任何顺序出现。在**循环链表** `circular list` 中，表头元素的 `prev` 指针指向表尾元素，而表尾元素的 `next` 指针则指向表头元素，我们可以将循环链表想象成一个各元素组成的圆环。在本节余下的部分中，我们假设所处理的链表都是未排序的、且是双链表的。

## 2.1 链表的搜索
过程 `LIST-SEARCH(L, k)` 采用简单的线性搜索方法，用于查找链表 `L` 中第一个关键字为 `k` 的元素，并返回指向该元素的指针。如果链表中没有关键字为 `k` 的对象，则该过程返回 `NULL` 。对于图10-3(a)中的链表，调用 `LIST-SEARCH(L, 4)` 返回指向第三个元素的指针，而调用 `LIST-SEARCH(L, 7)` 则返回 `NULL` 。
```cpp
LIST-SEARCH(L, k)
	x = L.head
	while x != NULL and x.key != k
		x = x.next
	return x
```
要搜索一个有 $n$ 个对象的链表，过程 `LIST-SEARCH` 在最坏情况下的运行时间为 $\Theta(n)$ ，因为可能需要搜索整个链表。

## 2.2 链表的插入
给定一个已设置好关键字 `key` 的元素 `x` ，过程 `LIST-INSERT` 将 `x` 连接到链表的前端，如图10-3(b)所示：
```cpp
LIST-INSERT(L, x)
	x.next = L.head
	if L.head != NULL
		L.head.prev = x
	L.head = x
	x.prev = NULL
```
我们知道属性符号是可以嵌套的，因此 `L.head.prev` 表示的是 `L.head` 所指向对象的 `prev` 属性。在一个含 $n$ 个元素的链表上，执行 `LIST-INSERT` 的运行时间是 $O(1)$ 。

## 2.3 链表的删除
过程 `LIST-DELETE` 将一个元素 `x` 从链表 `L` 中移除。该过程要求给定一个指向 `x` 的指针，然后通过修改一些指针，将 `x` “删除出”该链表。如果要删除具有给定关键字值的元素，则必须先调用 `LIST-SERACH` 找到该元素。
```cpp
LIST-DELETE(L, x)
	if x.prev != NULL
		x.prev.next = x.next
	else L.head = x.next
	if x.next != null
		x.next.prev = x.prev
```
图10-3 c)展示了从链表中删除一个元素的操作。`LIST-DELETE` 的运行时间为 $O(1)$ 。但如果要删除具有给定关键字的元素，则最坏情况下需要的时间为 $\Theta(n)$ ，因为需要先调用 `LIST-SEARCH` 找到该元素。
## 2.4 哨兵
如果可以忽视表头和表尾处的边界条件，则 `LIST-DELETE` 的代码可以更简单些：
```cpp
LIST-DELETE(L, x)
	x.prev.next = x.next
	x.next.prev = x.prev
```
**哨兵** `sentinel` 是一个哑对象，其作用是简化边界条件的处理。例如，假设在链表 `L` 中设置一个对象 `L.null` ，该对象代表 `NULL` ，但也具有和其他对象相同的各个属性。对于链表代码中出现的每一处对 `NULL` 的引用，都代之以对哨兵 `L.null` 的引用。如图10-4所示，这样的调整将一个常规的双向链表，转换为一个**有哨兵的双向循环链表** `circular, doubly linked list with a sentinel` ，哨兵 `L.null` 位于表头和表尾之间。属性 `L.null.next` 指向表头，`L.null.prev` 指向表尾。类似地，表尾的 `next` 属性和表头的 `prev` 属性同时指向 `L.null` 。因为 `L.null.next` 指向表头，我们就可以去掉属性 `L.head` ，并把对它的引用代替为对 `L.null.next` 的引用。图10-4(a)显示，一个空的链表只由一个哨兵构成，`L.null.next` 和 `L.null.prev` 同时指向 `L.null` 。
![](https://img-blog.csdnimg.cn/71272d6c35c24ac9b8a5817e0f3988fd.png)
`LIST-SEARCH` 的代码和之前基本保持不变，只是将对 `NULL` 和 `L.head` 的引用如前所述，加以调整：
```cpp
LIST-SEARCH(L, k)
	x = L.null.next
	while x != L.null and x.key != k
		x = x.next
	return x
```
我们使用前述的、仅含两行代码的过程 `LIST-DELETE` 可以实现元素的删除。下面的过程则实现元素的插入：
```cpp
LIST-INSERT(L, x)
	x.next = L.null.next
	L.null.next.prev = x
	L.null.next = x
	x.prev = L.null
```
图10-4展示了 `LIST-INSERT` 和 `LIST-DELETE` 在该链表实例上的执行结果。

哨兵基本不能降低数据结构相关操作的渐近时间界，但可以降低常数因子。在循环语句中使用哨兵的好处往往在于，可以使代码简洁、而非提高速度。举例来说，使用哨兵使链表的代码变得简洁了，但在 `LIST-INSERT, LIST-DELETE` 过程上仅节约了 $O(1)$ 的时间。然而，在另一些情况下，哨兵的使用使循环语句的代码更紧凑，从而降低了运行时间中 $n$ 或 $n^2$ 等项的系数。


---
# 3. 指针和对象的实现
当有些语言不支持指针和对象数据类型时，应当如何实现它们呢？这里介绍，在没有显式的指针数据类型的情况下，实现链式数据结构的两种方法。我们将利用数组和数组下标来构造对象和指针。
## 3.1 对象的多数组表示
对每个属性使用一个数组表示，可以来表示一组有相同属性的对象。图10-5说明了如何用三个数组实现图10-3(a)所示的链表。**数组 `key` 存放在动态集合中现有的关键字，指针则分别存放在数组 `next, prev` 中。对于一个给定的数组下标 `x` ，三个数组项 `key[x], next[x], prev[x]` 一起表示链表中一个对象**。根据这种解释，指针 `x` 即为数组 `key, next, prev` 的一个共同下标。
![在这里插入图片描述](https://img-blog.csdnimg.cn/ee044df42d6a43edbd33b0d4d6a2484b.png)
在图10-3(a)所示的链表中，关键字为 $4$ 的对象紧邻关键字为 $16$ 的对象之后。在图10-5中，关键字 $4$ 出现在 `key[2]` ，关键字 $16$ 出现在 `key[5]` ，因此 `next[5] = 2, prev[2] = 5` 。尽管常数 `NULL` 出现在表尾的 `next` 属性和表头的 `prev` 属性中，但我们通常用一个「不能代表数组中任何实际位置的整数」（如 $0$ 或 $-1$ 来表示）。此外变量 `L` 存放表头元素的下标。
## 3.2 对象的单数组表示
计算机内存的字，往往从整数 $0$ 到 $M - 1$ 进行编址，其中 $M$ 是一个足够大的整数。在许多程序设计语言中，一个对象在计算机内存中占据一组连续的存储单元。指针仅仅是该对象所在的第一个存储单元的地址，要访问对象内其他存储单元，可以在指针上加上一个偏移量。

在不支持显式的指针数据类型的编程环境下，我们可以采用同样的策略来实现对象，图10-6举例说明了，如何用单个数组 $A$ 存储图10-3(a)和图10-5所示的链表。==一个对象占用一段连续的子数组 $A[j\dots k]$ ，对象中的每个属性对应于从 $0$ 到 $k - j$ 之间的一个偏移量，指向该对象的指针就是下标 $j$== 。在图10-6中，对应于属性 $key, next, prev$ 的偏移量分别是 $0, 1, 2$ 。给定一个指针 $i$ ，要读取 $i.prev$ 的值，只需在指针的值 $i$ 上加上偏移量 $2$ ，所以要读取的是 $A[i + 2]$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/1094c2c7d57540bda07fb2c98ecec638.png)
这种单数组的表示法比较灵活，因为它**允许不同长度的对象存储于同一数组中**。管理一组异构的对象，比管理一组同构的对象（即所有对象有相同的属性）更困难。由于我们考虑的数据结构大多都是由同构的元素构成，因此采用对象的多数组表示法足够满足我们的需求。
## 3.3 对象的分配与释放
向一个双向链表表示的动态集合中插入一个关键字，就必须分配一个指向该链表中尚未利用的对象的指针。因此，有必要对链表表示中尚未利用的对象空间进行管理，使其能够被分配。在某些系统中，由**垃圾收集器** `garbage collector` 负责确定，哪些对象是未使用的。然而许多应用非常简单，可由自己负责将未使用的对象返回给存储管理器。我们以多数组表示的双向链表为例，探讨同构对象的分配与释放问题。

假设多数组表示法中的各数组长度为 $m$ ，且在某一时刻该动态集合含有 $n \le m$ 个元素。则 $n$ 个对象代表现存于该动态集合中的元素，而余下的 $m - n$ 个对象是**自由的** `free` ；这些自由对象可用来表示「将要插入该动态集合的元素」。

我们把自由对象保存在一个单链表中，称为**自由表** `free list` 。自由表只使用 `next` 数组，该数组只存储链表中的 `next` 指针。自由表的头保存在全局变量 `free` 中。当由链表 `L` 表示的动态集合非空时，自由表可能会和链表 `L` 相互交错，如图10-7所示。注意，**该表示中的每个对象不是在链表 `L` 中、就是在自由表中，但不会同时属于两个表**。

自由表类似于一个栈，下一个被分配的对象就是最后被释放的那个。我们可以分别利用栈操作 `PUSH, POP` 的链表实现形式、来实现分配和释放对象的过程。假设下述过程中的全局变量 `free` 指向自由表的第一个元素。
```cpp
ALLOCATE-OBJECT()
	if free == NULL
		error "out of space"
	else x = free
		free = x.next
		return x

FREE-OBJECT(x)
	x.next = free
	free = x
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/a6949e7ea8d54e4991fbe51eb7ece51c.png)
初始时自由表含有全部 $n$ 个未分配对象。一旦自由表用完，再运行 `ALLOCATE-OBJECT` 过程将提示出错。我们甚至可以让多个链表共用一个自由表。图10-8显示了两个链表和一个自由表，通过数组 `key, next, prev` 彼此交错在一起。
![在这里插入图片描述](https://img-blog.csdnimg.cn/5315b0e8edbc4fd7809f554655475c68.png)
上述两个过程运行时间都为 $O(1)$ ，因而是非常实用的。我们可以将其改造，让对象中的任意一个属性、都可以像自由表的 `next` 属性一样使用，从而使其可以对任何同构的对象组都适用。

---
# 4. 有根树的表示
上一节介绍的、表示链表的方法，可以推广到任意同构的数据结构上。本节中讨论用链式数据结构表示有根树的问题，首先讨论二叉树，然后给出针对「结点孩子数任意的有根树」的表示方法。

树的结点用对象表示。与链表类似，假设每个结点都含有一个关键字 `key` ，其余的属性包括指向其他结点的指针，它们随树的种类不同、会有所变化。

## 4.1 二叉树
图10-9展示了在二叉树 `T` 中，如何利用属性 `p, left, right` 存放指向父结点、左孩子和右孩子的指针。如果 `x.p = NULL` ，则 `x` 是根结点。如果结点 `x` 没有左孩子，则 `x.left = NULL` ，右孩子的情况与此类似。属性 `T.root` 指向整棵树 `T` 的根结点，如果 `T.root = NULL` ，则该树为空。
![在这里插入图片描述](https://img-blog.csdnimg.cn/e4dc98aa6d5940a3b9b1097fa2834efd.png)
## 4.2 分支无限制的有根树
二叉树的表示方法，可以推广到每个结点的孩子数至多为常数 $k$ 的任意类型的树：只要将 `left, right` 属性用 `child1, child2, ..., childk` 代替。当孩子的结点数无限制时，这种方法就失效了，因为我们不知道应当预先分配多少个属性（在多数组表示法中就是多少个数组）。此外，即使孩子数 $k$ 限制在一个大的常数内，但若多数结点只有少量的孩子，则会浪费大量存储空间。

所幸的是，有一个巧妙的方法可以用来表示孩子数任意的树。该方法的优势在于，对任意 $n$ 个结点的有根树，只需要 $O(n)$ 的存储空间。这种**左孩子右兄弟表示法** `left-child, right-sibling representation` 如图10-10所示。和前述方法类似，每个结点都包含一个父结点指针 `p` ，且 `T.root` 指向树 `T` 的根结点。然而，每个结点中不是包含指向每个孩子的指针，而是只有两个指针：
1. `x.left-child` 指向结点 `x` 最左边的孩子结点。
2. `x.right-sibling` 指向 `x` 右侧相邻的兄弟结点。
3. 如果结点 `x` 没有孩子结点，则 `x.left-child = NULL` ；如果结点 `x` 是其父结点的最右孩子，则 `x.right-sibling = NULL` 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/a42b7fa2d3714aa6a93565f350597a18.png)


## 4.3 树的其他表示方法
我们有时也用其他方法表示有根树。例如，我们对一棵完全二叉树使用堆来表示，堆用一个单数组加上堆的最末结点的下标来表示。（算导第21章中的）树只需向根结点方向遍历，因此只需提供父结点的指针，而没有指向孩子结点的指针。还有许多其他的表示方法，哪种方法最优取决于具体应用。


---
# 5. 图的表示
对于图 $G = (V, E)$ ，可以有两种标准表示方法。一种表示法将图作为邻接链表的组合，另一种表示法则将图作为邻接矩阵来看到。两种表示方法都可以表示无向图和有向图。邻接链表因为在表示**稀疏图**（边的条数 $|E|$ 远远小于 $|V|^2$ 的图）时非常紧凑、而成为通常的选择，之后的多数图算法都假定作为输入的图是以邻接链表方式表示的。不过，在**稠密图**（$|E|$ 接近 $|V|^2|$ 的图）的情况下，我们可能倾向于使用邻接矩阵表示法。另外，如果需要快速判断任意两个结点之间是否有边相连，可能也需要使用邻接矩阵表示法。例如，全源最短路中的两种算法，都以邻接矩阵来表示图。

对于图 $G = (V, E)$ 来说，其**邻接链表表示**由一个包含 $|V|$ 条链表的数组 `Adj` 所构成，每个结点有一条链表。对于每个结点 $u \in V$ ，邻接链表 `Adj[u]` 包含所有「与结点 $u$ 之间有边相连的结点 $v$ 」，即 `Adj[u]` 包含图 $G$ 中所有与 $u$ 邻接的结点（也可以说，该链表中包含指向这些结点的指针）。由于邻接链表代表的是图的边，在伪码里可以将数组 `Adj` 看作是图的一个属性，就如我们将边集合 $E$ 看作是图的属性一样。因此，在伪码里，我们将看到 `G.Adj[u]` 这样的表示。

图22-1(a)给出的是一个无向图，图22-1(b)给出的是图22-1(a)的邻接链表表示。类似地，图22-2(b)给出的是图22-2(a)的有向图的邻接链表表示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/fac1e0268a434e5c82530b52b0c4d9b1.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/5fc833ed452a453fbe10e169fda13eca.png)
如果 $G$ 是一个有向图，则对于边 $(u, v)$ 来说，结点 $v$ 将出现在链表 `Adj[u]` 里。因此，所有邻接链表的长度之和等于 $|E|$ 。如果 $G$ 是一个无向图，则对于边 $(u, v)$ 来说，结点 $v$ 将出现在链表 `Adj[u]` 里，结点 $u$ 将出现在链表 `Adj[v]` 里，因此所有邻接链表的长度之和等于 $2|E|$ 。但不管是有向图还是无向图，邻接链表表示法的存储空间需求均为 $\Theta(V+E)$ ，这正是我们希望的数量级。

对邻接链表稍作修改，即可用来表示**权重图**，即图中的每条边都带有一个相关的**权重**的图。该权重值通常由一个 $w : E \to \R$ 的**权重函数**给出。例如，设 $G = (V, E)$ 为一个权重图，其权重函数为 $w$ ，我们可以直接将边 $(u, v) \in E$ 的权重值 $w(u, v)$ 存放在结点 $u$ 的邻接链表里。从这种意义上，邻接链表表示法的健壮性很高，可对其简单修改、以支持许多其他的图变种。

**邻接链表的一个潜在缺陷，是无法快速判断一条边 $(u, v)$ 是否是图中的一条边**，唯一的办法是在邻接链表 `Adj[u]` 里面搜索结点 $v$ 。邻接矩阵表示则克服了这个缺陷，但付出的代价是更大的存储空间消耗（存储空间的渐近数量级更大）。关于如何在邻接链表上快速搜索边的信息，见（算导练习22.1-8）。


对于**邻接矩阵表示**来说，我们通常会将图 $G$ 中的结点编为 $1, 2, \dots, |V|$ ，这种编号可以是任意的。在进行此种编号后，图 $G$ 的邻接矩阵由一个 $|V| \times |V|$ 的矩阵 $A = (a_{ij})$ 予以表示，该矩阵满足下述条件：
$$a_{ij} =\begin{cases} 
1 \quad& 若(i,j) \in E \\
0 \quad& 其他
\end{cases}$$

图22-1 c)和图22-2 c)分别给出的是无向图22-1(a)和有向图22-2(a)的邻接矩阵表示。不管一个图有多少边，邻接矩阵的空间需求都为 $\Theta(V^2)$ 。

从图22-1 c)可知，无向图的邻接矩阵是一个对称矩阵。由于无向图中边 $(u, v)$ 和边 $(v, u)$ 是同一边，无向图的邻接矩阵 $A$ 就是自己的转置，即 $A = A^T$ 。在某些应用中，可能只需存放对角线及其以上的这部分邻接矩阵，从而将图存储空间需求减少几乎一半。

与邻接链表表示法一样，邻接矩阵也可以用来表示权重图。例如，如果 $G = (V, E)$ 为一个权重图，其权重函数为 $w$ ，则我们直接将边 $(u, v) \in E$ 的权重 $w(u, v)$ 存放在邻接矩阵中的第 $u$ 行第 $v$ 列记录上。对于不存在的边，则在相应的行列记录上存放值 `NULL` 。不过对于许多问题来说，用 $0$ 或 $\infin$ 来表示一条不存在的边可能更为便捷。

虽然邻接链表和邻接矩阵表示法，在渐近意义下至少是一样空间有效的，但邻接矩阵表示法更为简单，因此在图规模较小时，我们可能更倾向于使用邻接矩阵表示法。而且对于无向图来说，邻接矩阵还有一个优势，每个记录项只需 $1$ 位的空间。

## 表示图的属性
对图进行操作的多数算法，需要维持图中结点或边的某些属性。这些属性可以使用通常的表示法来表示，如 $v.d$ 表示结点 $v$ 的属性 $d$ 。当使用一对结点来表示一条边时，我们也可以使用同样风格的表示，例如，如果边由一种属性 $f$ ，则边 $(u, v)$ 的这种属性可以表示为 $(u, v).f$ 。对于表示和理解算法来说，这种属性表述足够清晰。

不过在算法的实际程序里面，实现结点和边的属性则完全是另外一回事。没有什么最好的方法来存放和访问结点与边的属性。对于给定的场景，我们所做出的决定可能依赖于诸多因素：使用的编程语言、需要实现的算法、程序中使用图的方式等。**如果使用邻接链表表示图，一种可能的方法是使用额外的数组来表示结点属性**，如一个与 `Adj` 数组对应的数组 $d[ 1 \dots |V| ]$ 。如果与 $u$ 邻接的结点都在 `Adj[u]` 中，则属性 $u.d$ 将存放在数组项 $d[u]$ 里。还有许多其他方法可以用来实现属性的表示。例如，在面向对象的程序设计语言里，结点属性可以表示为 `Vertex` 类下面的一个子类中的实例变量。

