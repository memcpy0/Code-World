树和图最常见的存储方式，就是使用一个邻接表（链式前向星）保存它们的边集。除非特殊声明，接下来都默认，给定 $N$ 个结点的树或图时，节点编号为 $1\sim N$ ，无向图中的边看做成对出现的无向边，树看作一张具有 $N- 1$ 条边的无向图，它们的边都存在一个邻接表（链式前向星）中，以 `head` 数组为表头，使用 `ver, edge` 数组分别存储边的终点和权值，使用 `next` 数组模拟链表指针——见[[../CSDN/数据结构和算法学习/【算法学习】图论1 图的概念]]。

---
# 树与图的深度优先遍历、树的DFS序、深度和重心
深度优先遍历就是，==在每个点 $x$ 上面对多条分支时，任意选一条边走下去，执行递归，直至回溯到 $x$ 点后，再考虑走向其他的边==，如右图所示。根据上面提到的存储方式，我们可以采用下面的代码，调用 `dfs(1)` ，对一张图进行深度优先遍历。
```cpp
void dfs(int x) {
	v[x] = 1; // 记录点x被访问过,v是visit的缩写
	for (int i = head[x]; i; i = next[i]) {
		int y = ver[i];
		if (v[y]) continue; // 点y已经被访问过了
		dfs(y);
	}
}
```
这段代码访问每个点和每条边恰好1次（如果是无向边，正反向各访问一次），其时间复杂度为 $O(M + N)$ ，其中 $M$ 为边数。以这段代码为框架，我们可以统计许多关于树和图的基本信息，包括时间戳、DFS序与时间戳/欧拉序、树的重心和直径、图的割边割点等。

更多内容见[[CSDN/数据结构和算法学习/【算法学习】搜索专题 深度优先搜索]]

## 时间戳
按照上述深度优先遍历的过程（先根遍历的DFS序），以每个节点第一次被访问（ `v[x]` 被赋值为1时）的顺序，依次给予这 $N$ 个点 $1 \sim N$ 的整数标记，该标记就被称为**时间戳**，记为 $dfn$ 。

例如，在上图中，`dfn[1]=1, dfn[2]=2, dfn[8]=3, dfn[5]=4, dfn[7]=5, dfn[4]=6, dfn[3]=7, dfn[9]=8, dfn[6]=9` 。

## 树的DFS序（这里是欧拉序）
一般来说，我们在对树进行深度优先遍历时，==对于每个节点，在刚进入递归后、以及即将回溯前各记录一次该点的编号，最后产生的长度为 $2N$ 的节点序列就称为树的DFS序（其实是欧拉序）==。
```cpp
void dfs(int x) {
	a[++m] = x; // a数组存储DFS序
	v[x] = 1; // 记录点x被访问过
	for (int i = head[x]; i; i = next[i]) {
		int y = ver[i];
		if (ver[y]) continue;
		dfs(y);
	}
	a[++m] = x;
}
```
DFS序（是欧拉序）的特点是：**每个节点 $x$ 的编号在序列中恰好出现两次**。**设这两次出现的位置为 $L[x], R[x]$ ，那么闭区间 $[L[x],\ R[x]]$ 就是以 $x$ 为根的子树的DFS序**。这使得我们在很多与树相关的问题中，可以通过DFS序**把子树统计转换为序列上的区间统计**。

树链剖分用到了DFS序（不是欧拉序）和时间戳——[[CSDN/数据结构和算法学习/算法学习笔记() DFS序、树链剖分及其应用]]。

## 树的深度
树中各个节点的深度是一种自顶向下的统计信息。起初，**我们知道根节点的深度为0，若节点 $x$ 的深度为 $d[x]$ ，则它的子节点 $y$ 的深度就是 $d[y] = d[x] + 1$** 。在深度优先遍历的过程中结合自顶向下的递推，就可以求出每个节点的深度 $d$ 。还有哪些信息一般是自顶向下进行统计的呢？
```cpp
void dfs(int x) {
	v[x] = 1;
	for (int i = head[x]; i; i = next[i]) {
		int y = ver[i];
		if (v[y]) continue;
		d[y] = d[x] + 1; // 从父节点x到子节点y递推,计算深度
		dfs(y);
	}
}
```

## 树的重心
当然，也有许多信息是自底向上进行统计的，比如以每个节点 $x$ 为根的子树大小 $size[x]$ 。对于叶子节点，我们已知以它为根的子树大小为1。若节点 $x$ 有 $k$ 个子节点 $y_1 \sim y_k$ ，并且以 $y_1 \sim y_k$ 为根的子树大小分别是 $size[y_1], size[y_2], \dots, size[y_k]$ ，则以 $x$ 为根的子树的大小就是 $size[x] = size[y_1] + size[y_2] + \dots + size[y_k] + 1$ 。。还有哪些信息一般是自底向上进行统计的呢？

对于一个节点 $x$ ，如果我们把它从树中删除，那么原来的一棵树可能会分成若干个不相连的部分，其中每一部分都是一棵子树。设 `max_part(x)` 表示在删除节点 $x$ 后产生的子树中最大的一棵的大小，使得 `max_part` 函数取得最小值的节点 $p$ 就是**整棵树的重心**。

例如上图中树的重心应该是节点1。通过下面的代码，可以统计出 $size$ 数组，并求出树的重心。
```cpp
void dfs(int x) {
	v[x] = 1; 
	size[x] = 1; // 子树x的大小
	int max_part = 0; // 删除x后分成的最大子树的大小
	for (int i = head[x]; i; i = next[i]) {
		int y = ver[i];
		if (v[y]) continue; // 点y已经被访问过了
		dfs(y);
		size[x] += size[y]; // 从子节点向父节点递推
		max_part = max(max_part, size[y]);
	}
	max_part = max(max_part, n - size[x]); // n为整棵树的节点数目
	if (max_part < ans) {
		ans = max_part; // 全局变量记录重心对应的max_part值
		pos = x;        // 全局变量pos记录重心
	}
}
```
更多见[[CSDN/数据结构和算法学习/【算法学习】树专题 树的重心]]。
## 树的直径
更多见[[CSDN/数据结构和算法学习/【算法学习】树专题 树的直径]]
## 图的连通块划分
上面的代码每从 $x$ 开始一次遍历，就会访问 $x$ 能到达的所有的点和边。因此，通过多次深度优先遍历，可以划分出一张无向图中的各个连通块——**若在无向图中的一个子图中，任意两个节点之间都存在一条路径（可以相互到达），并且这个子图是极大（不能再扩张）的，则称该子图是无向图的一个连通块**；一张不连通的无向图由2个或2个以上连通块组成，而一张无向连通图整体是一个连通块。同理，对一个森林进行深度优先遍历，可以划分出森林中的每棵树。

如下面的代码所示，`cnt` 就是无向图中包含的连通块的个数，$v$ 数组标记了每个点属于哪个连通块。
```cpp
void dfs(int x) {
	v[x] = cnt; // 标记每个点属于哪个连通块
	for (int i = head[x]; i; i = next[i]) {
		int y = ver[i];
		if (v[y]) continue;
		dfs(y);
	}
}

for (int i = 1; i <= n; ++i) // 在int main()中
	if (!v[i]) {
		++cnt;
		dfs(i);
	}
```

---
# 树与图的广度优先遍历、拓扑排序

树与图的广度优先遍历需要使用一个队列来实现。起初，队列中仅包含一个起点（例如1号节点）。在广度优先遍历的过程中，我们不断从队头取出一个节点 $x$ ，对于 $x$ 面对的多条分支，把沿着每条分支到达的下一个节点（如果尚未访问过）插入队尾，重复执行上述过程直至队列为空。

图

我们可以采用下面的代码对一张图进行广度优先遍历：
```cpp
void bfs() {
	memset(d, 0, sizeof(d));
	queue<int> q;
	q.push(1); 
	d[1] = 1;
	while (q.size() > 0) {
		int x = q.front(); q.pop();
		for (int i = head[x]; i; i = next[i]) {
			int y = ver[i];
			if (d[y]) continue;
			d[y] = d[x] + 1;
			q.push(y);
		}
	}
}
```