> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。

游戏地图用大小为 `m x n` 的网格 `grid` 表示，其中每个元素可以是墙、地板或者是箱子。

现在你将作为玩家参与游戏，按规则将箱子 `'B'` 移动到目标位置 `'T'` ：

-   玩家用字符 `'S'` 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。
-   地板用字符 `'.'` 表示，意味着可以自由行走。
-   墙用字符 `'#'` 表示，意味着障碍物，不能通行。 
-   箱子仅有一个，用字符 `'B'` 表示。相应地，网格上有一个目标位置 `'T'`。
-   玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。
-   玩家无法越过箱子。

返回将箱子推到目标位置的最小 **推动** 次数，如果无法做到，请返回 `-1`。

**示例 1：**
![600](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/sample_1_1620.png)**
```java
输入：grid = [["#","#","#","#","#","#"],
             ["#","T","#","#","#","#"],
             ["#",".",".","B",".","#"],
             ["#",".","#","#",".","#"],
             ["#",".",".",".","S","#"],
             ["#","#","#","#","#","#"]]
输出：3
解释：我们只需要返回推箱子的次数。
```
**示例 2：**
```java
输入：grid = [["#","#","#","#","#","#"],
             ["#","T","#","#","#","#"],
             ["#",".",".","B",".","#"],
             ["#","#","#","#",".","#"],
             ["#",".",".",".","S","#"],
             ["#","#","#","#","#","#"]]
输出：-1
```
**示例 3：**
```java
输入：grid = [["#","#","#","#","#","#"],
             ["#","T",".",".","#","#"],
             ["#",".","#","B",".","#"],
             ["#",".",".",".",".","#"],
             ["#",".",".",".","S","#"],
             ["#","#","#","#","#","#"]]
输出：5
解释：向下、向左、向左、向上再向上。
```
**提示：**
-   `m == grid.length`
-   `n == grid[i].length`
-   `1 <= m, n <= 20`
-   `grid` 仅包含字符 `'.'`, `'#'`,  `'S'` , `'T'`, 以及 `'B'`。
-   `grid` 中 `'S'`, `'B'` 和 `'T'` 各只能出现一个。

---
### 解法1 BFS+DFS
本题不难，只需要静下心。想一下，如果箱子可以自己移动（宝箱怪是吧），这道题目就很简单，就变成了一个简单的BFS了——之所以用BFS而非DFS，是因为使用BFS可以一层层往外扩展，从而得到**最短移动步数**。

再思考，如果加入「箱子需要人从后面推动」的条件，会有那些不同呢？——**箱子的移动受到了限制**，只有人可以到达箱子的背后时，箱子才能在这个特定方向进行移动。而「人是否可以到达箱子的背后」，这个子问题又可用一次DFS来解决。

于是，第一个思路是：==以箱子的视角进行BFS（主问题），以人的视角进行DFS（子问题），后者是前者得以移动的前提==。

想象此时箱子正位于一个狭窄的通道内，除了箱子当前位置这个状态外，人究竟是站在箱子哪一侧尤为重要，这决定了箱子可以向哪个方向继续移动。于是==箱子虽然位于同一位置，但人的位置不同，箱子其实仍处于不同的状态==。而**人的位置可以用箱子当前位置+箱子来源/去向**（刚才从什么方向被推过来；或者移动到哪里去）**两个值来描述**，如箱子是从左边过来的，则箱子当前位置的左边（箱子旧位置）就是目前人的位置。

由此，引出了本题的第二个关键点：**箱子的状态包含两个信息，箱子的位置、箱子的来源/去向（它刚刚从什么方向被推来；或者它的移动方向）**——为什么要纠结于箱子的状态？因为在箱子BFS时，需要设置 `visited` 数组来防止重复访问（防止死循环），而**是否重复的依据正是箱子的状态**。从代码的角度看，对二维数组进行访问的 `visited` 数组一般长这个样子：`boolean[][]` ，而现在它变成了这样：`boolean[][][4]` ，$4$ 是指方向信息。

当然，存储为结点时还是存**人的位置**，而非箱子来源/去向，这样可以简化代码。

我在代码实现时发现了几个关键点：
- 检查是否为箱子可以到达的合法位置，只要不是障碍物就行；
- 检查是否为**人可以到达的合法位置**，除了障碍物外，**还可能被当前的箱子挡住**。
- 在将结点加入队列时，标记其状态被访问，而非在出队时标记其被访问，**可以减少很多重复结点入队**。
- 有时可能要将箱子先推远，再推近：
```java 
[[".",".","."],
 [".",".","."],
 ["#","B","."],
 ["S","T","#"]] 
```
- ==不必刻意区分箱子是从哪个方向来的==，即赋值整数为有意义的上下左右方向。只需使用方向数组 $d$ ，**向第 $i$ 个方向移动箱子，就让当前箱子位置加上 $d[i]$ 的方向值**；**要找到人的位置，就让当前箱子位置减去 $d[i]$ 的方向值**。再对合法的箱子位置和移动方向 $i$ 加以记录即可。







 