> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给定正整数 `k` ，你需要找出可以被 `k` 整除的、仅包含数字 `1` 的最 **小** 正整数 `n` 的长度。

返回 `n` 的长度。如果不存在这样的 `n` ，就返回-1。

**注意：** `n` 不符合 64 位带符号整数。

**示例 1：**
```java
输入：k = 1
输出：1
解释：最小的答案是 n = 1，其长度为 1。
```
**示例 2：**
```java
输入：k = 2
输出：-1
解释：不存在可被 2 整除的正整数 n 。
```
**示例 3：**
```java
输入：k = 3
输出：3
解释：最小的答案是 n = 111，其长度为 3。
```
**提示：**
-   `1 <= k <= 10^5`

---
两个例子如下：
- 如果要计算 $1234 \times 6789$ 的**个位数**，该怎么算？由于**只有两个乘数的个位数会影响到乘积的个位数**，那么 $4\times 9=36$ 的个位数 $6$ 就是答案。
- 如果要计算 $1234 + 6789$ 的**个位数**，该怎么算？由于**只有两个加数的个位数会影响到结果的个位数**，那么 $4+ 9=13$ 的个位数 $3$ 就是答案。

从这两个例子得到的结论，可以被抽象成两个非常常用的两个数学等式。一般来说，涉及取模的题目，基本都会用到（上面计算的是 $m = 10$ ）：
- $(a + b)\bmod m = ((a \bmod m) + (b\bmod m)) \bmod m$ 
- $(a\times b) \bmod m = ((a\bmod m) \times (b\bmod m))\bmod m$

证明：根据**带余除法**，任意整数 $a$ 都可表示为 $a = km + r$ ，这里 $r = a\bmod m$ ，于是设 $a = k_1 m + r_1, b= k_2m+r_2$ 。
第一个等式：
$$\begin{aligned}
(a + b) \bmod m &=((k_1 + k_2) m + r_1 + r_2)\bmod m \\
&=(r_1+r_2) \bmod m \\
&=((a \bmod m) + (b\bmod m)) \bmod m
\end{aligned}$$
第二个等式：
$$\begin{aligned}
(a \times b) \bmod m &=(k_1  k_2 m^2 + (k_1r_2 + k_2r_1)m + r_1r_2) \bmod m \\
&=(r_1r_2) \bmod m \\
&=((a \bmod m) \times (b\bmod m)) \bmod m
\end{aligned}$$
---
### 解法 数学（模运算）+哈希集合
从题意可知：
- 正整数 $n$ 要被 $k$ 整除，需要余数 $r = n \bmod k$ 为 $0$ 。
- $n$ 仅包含数字 $1$ ，如 $11111 = 1111 \times 10 + 1$ 。
- $1 \le k \le 10^5$ ，则余数满足 $0\le r \lt k\le 10^5$ 。$n$ 的长度可能过大，**我们只保留 $n$ 模 $k$ 的余数 $r$ 、而不存储 $n$ 本身**。

举例：$k = 7$ ：
- **从小到大枚举 $n$ ，第一个能被 $k$ 整除的 $n$ 的长度即为答案**。
- $1 \to 11 \to 111 \to 1111 \to 11111 \to 111111$ 
- 根据上面的说明，设 $x$ 为前一次运算的结果（初始为 $1$），则下一个 $n$ 模 $k$ 的结果为 $(10 x + 1)\bmod k$ ，看它是否为0。
- $1 \to 4 \to 6 \to 5 \to 2 \to 0$ 

举例：$k = 24$
- **如果计算结果和之前的某个计算结果相同，由于计算规则不变，后面会无限重复下去，无法得到 $0$** 。
- $1 \to 11 \to 15 \to 7 \to 23 \to 15$ 

因此，==可用哈希表记录计算结果，如果算出 $0$ 之前就遇到了哈希表中的数字，则返回 $-1$== 。
```java
class Solution {
    public int smallestRepunitDivByK(int k) {
	var rec = new HashSet<Integer>();
	int x = 1 % k;
	while (x > 0 && rec.add(x))
	    x = (x * 10 + 1) % k;
	return x > 0 ? -1 : rec.size() + 1;
    }
}
```
复杂度分析：
- 时间复杂度：$O(k)$ ，为什么是 $O(k)$ ，可从解法2中看到说明。
- 空间复杂度：$O(k)$

---
### 解法2 数学（模运算）+抽屉原理
这种做法不需要使用哈希记录。我们循环 $k$ 次，如果没有算出 $0$ ，则返回 $-1$ 。因为模 $k$ 的结果在 $[0, k - 1]$ 中有 $k$ 个数字，**如果循环 $k$ 次没有找到 $0$ ，根据抽屉原理/鸽巢原理，则必然有重复的数字**。这也说明上一个算法的时间复杂度为 $O(k)$ 。

此外还可做一点优化：由于 $n$ 的个位数是 $1$ ，所以必然不是 $2$ 的倍数或 $5$ 的倍数。**如果 $k$ 是 $2$ 的倍数或 $5$ 的倍数，那么必然无解**，返回 $-1$ 。否则一定有解。证明一定有解的情形：
> 证明：根据解法2的做法，在计算过程中必然会出现两个数模 $k$ 同余（余数为 $0$ 时和 $0$ 模 $k$ 同余）。
> 设这两个数为 $a = \dfrac{10^x - 1}{9}$ 和 $b = \dfrac{10^y - 1}{9}$ ，且 $a > b$ 。那么 $a - b$ 为 $k$ 的倍数。
> 注意，$a - b = \dfrac{10^x - 10^y}{9} = 10^y \times \dfrac{10^{x - y} - 1}{9}$ 。$k$ 在没有因子 $2, 5$ 的情况下，要想整除上式，必须要整除 $\dfrac{10^{x - y} - 1}{9}$ ，这说明 $n$ 的长度可以是 $x - y$ 。

```java
class Solution {
    public int smallestRepunitDivByK(int k) {
	if (k % 2 == 0 || k % 5 == 0) return -1;
	int x = 1 % k;
	for (int i = 1; ; ++i) { // 一定有解
	    if (x == 0) return i;
	    x = (x * 10 + 1) % k;
	}
    }
}
```
复杂度分析：
- 时间复杂度：$O(k)$ 
- 空间复杂度：$O(1)$

---
### 解法3 欧拉定理
欧拉函数 *Euler's totient funciton* ，即 $\
 
设 $n$ 的长度为 $x$ ，那么 $n = \dfrac{10^x - 1}{9}$ 。$n$ 是 $k$ 的倍数，等价于 $10^x - 1$ 是 $9k$ 的倍数，即 $10^x \equiv 1\pmod {9k}$ 。
结论是：**最小的 $x$ 必然是 $\phi(9k)$ 的因子**。
反证法：如果 $\phi( 9k) = px + r\ (0 < r < x)$ ，根据欧拉定理，$$10^{\phi(9k)} \equiv (10^x)^p \cdot 10^r \equiv 10^r \equiv 1 \pmod {9k}$$
