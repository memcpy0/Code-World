> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个 `n x n` 的网格 `grid` ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：
- `0` 表示这个格子是空的，所以你可以穿过它。
- `1` 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
- `-1` 表示这个格子里有荆棘，挡着你的路。

请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：
- 从位置 `(0, 0)` 出发，最后到达 `(n - 1, n - 1)` ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 `0` 或者 `1` 的格子）；
- 当到达 `(n - 1, n - 1)` 后，你要继续走，直到返回到 `(0, 0)` ，只能向上或向左走，并且只能穿越有效的格子；
- 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 `0` ）；
- 如果在 `(0, 0)` 和 `(n - 1, n - 1)` 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。

**示例 1：**
![](https://assets.leetcode.com/uploads/2020/12/14/grid.jpg)
```java
输入：grid = [[0,1,-1],[1,0,-1],[1,1,1]]
输出：5
解释：玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。
在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。
然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。
总共捡到 5 个樱桃，这是最大可能值。
```
**示例 2：**
```java
输入：grid = [[1,1,-1],[1,-1,1],[-1,1,1]]
输出：0
```
**提示：**
- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 50`
- `grid[i][j]` 为 `-1`、`0` 或 `1`
- `grid[0][0] != -1`
- `grid[n - 1][n - 1] != -1`

---
### 解法 动态规划
当两个人当前所在格子重合时，本次移动的增量为w=grid[x1][y1]w=grid[x_1][y_1]w=grid[x1​][y1​]，否则为w=grid[x1][y1]+grid[x2][y2]w=grid[x_1][y_1]+grid[x_2][y_2]w=grid[x1​][y1​]+grid[x2​][y2​]。有荆棘的格子不考虑，正常格子分为以下四种情况进行状态转移：

1. 第一个人从上面过来，第二个人从左边过来，反映到状态上只有x1x_1x1​会变化。状态转移方程为f[x1][x2][k]=f[x1−1][x2][k−1]+wf[x_1][x_2][k]=f[x_1-1][x_2][k-1]+wf[x1​][x2​][k]=f[x1​−1][x2​][k−1]+w。
2. 第一个人从左边过来，第二个人从上面过来，反映到状态上只有x2x_2x2​会变化。状态转移方程为f[x1][x2][k]=f[x1][x2−1][k−1]+wf[x_1][x_2][k]=f[x_1][x_2-1][k-1]+wf[x1​][x2​][k]=f[x1​][x2​−1][k−1]+w。
3. 两个人都从上面过来，反映到状态上x1x_1x1​和x2x_2x2​都会变化。状态转移方程为f[x1][x2][k]=f[x1−1][x2−1][k−1]+wf[x_1][x_2][k]=f[x_1-1][x_2-1][k-1]+wf[x1​][x2​][k]=f[x1​−1][x2​−1][k−1]+w。
4. 两个人都从左边过来，反映到状态上x1x_1x1​和x2x_2x2​都不会变，只有kkk存在变化。状态转移方程为f[x1][x2][k]=f[x1][x2][k−1]+wf[x_1][x_2][k]=f[x_1][x_2][k-1]+wf[x1​][x2​][k]=f[x1​][x2​][k−1]+w。

#### 0. 解题前思考
如果只有一条路径，我们可以像[LCR 166. 珠宝的最高价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/jiao-ni-yi-bu-bu-si-kao-dpcong-hui-su-da-epvl/)那样，定义子问题为：从 $(0,0)$ 到 $(i,j)$ 可以得到的樱桃个数的最大值，即 $f[i][j]$ 。求出 $f[m-1][n-1]$ 即可知道问题答案。

考虑本题的走法，先从左上角向下或向右走到右下角，再从右下角向上或向左走到左上角，二者是正好相反的走法。这种情况下：
- 跑两次 DP？先走一遍最优路径（把 $1$ 改成 $0$ ），再走一遍（无论是从右下角走到左上角，还是干脆看做**从左上角又一次走到右下角**）剩下的最优路径？
- 这个做法是错的，如下的反例可以取到所有樱桃，但两次DP的做法没法取到所有樱桃。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202405090136563.png)

因此，我们**必须同时考虑两条路径**，考虑**两条从 $(0,0)$ 到 $(n-1,n-1)$ 的路径**，计算这两条路径的并集上樱桃个数的最大值。
#### 1. 寻找子问题
为方便描述，假设有两个人 A 和 B ，都从 $(0,0)$ 走到右下角 $(n-1,n-1)$ 。

假设 $n=3$ ，如果 A 最后一步从 $(2,1)$ 走到 $(2,2)$ ，B 最后一步从 $(1,2)$ 走到 $(2,2)$ ，我们需要计算**两人从 $(0,0)$ 分别走到 $(2,1)$ 和 $(1,2)$ 、路径并集上樱桃个数的最大值**。

我们可以定义四维DP数组 $f[x_1][y_1][x_2][y_2]$ ，表示两人从 $(0,0)$ 出发分别到达 $(x_1,y_1)$ 和 $(x_2,y_2)$ 两个位置的最大方格累加和，$f[2][2][2][2]$ 的一个子问题就是 $f[2][1][1][2]$ 。

虽然说，**这是一个和原问题相似的子问题**，但这个子问题却很难计算——==两条路径并不是互相独立的，同一个格子上的樱桃只能统计一次，我们需要考虑同一个格子重复经过的情况==。

像这样，把子问题定义成：从 $(0,0)$ 出发，A 走了 $p$ 步，B 走了 $q$ 步，分别走到 $(i_1,j_1)$ 和 $(i_2,j_2)$ 可以得到的樱桃个数的最大值。在 $p≠q$ 的情况下，比如 $p<q$ ，A 不知道哪些格子 B 已经走过了，无法计算重复经过的情况。

所以，我们把子问题定义成**两个人都走了同样的步数**，也就是 $p=q$ 的情况，**才能直接计算出重复经过的情况**，也就是两人走到同一个格子。在上面的例子中，我们需要计算两人从 $(0,0)$ 出发，**都**走了 $3$ 步，分别走到 $(2,1)$ 和 $(1,2)$ ，可以得到的樱桃个数的最大值。
#### 2. 状态定义与状态转移方程
定义 $\textit{dfs}(t,i_1,j,i_2,k)$ 表示两人从 $(0,0)$ 出发，都走了 $t$ 步，分别走到 $(i_1,j)$ 和 $(i_2,k)$ ，可以得到的樱桃个数的最大值。

状态维度有点多，能否简化？注意到，从 $(0,0)$ 出发，我们只能向下（这会让 $i$ 加一）或向右（这会让 $j$ 加一），所以 $i+j$ 就是走的步数 $t$ ，所以 $i_1$ 和 $i_2$ 是多余的，可以去掉。

于是，定义 $\textit{dfs}(t,j,k)$ 表示两人从 $(0,0)$ 出发，都走了 $t$ 步，分别走到 $(t-j,j)$ 和 $(t-k,k)$ ，可以得到的樱桃个数的最大值。考虑 A 和 B **最后一步**怎么走，也就是他们**上一步的位置**，组合有四种情况，得到4个子问题：
- 最后一步 A 往下走，B 往下走，那么问题变成两人从 $(0,0)$ 出发，都走了 $t-1$ 步，分别走到 $(t-1-j,j)$ 和 $(t−1−k,k)$ ，可以得到的樱桃个数的最大值，即 $\textit{dfs}(t-1,j,k)$ 。
- 最后一步 A 往下走，B 往右走，那么问题变成两人从 $(0,0)$ 出发，都走了 $t-1$ 步，分别走到 $(t-1-j,j)$ 和 $(t-k,k-1)$ ，可以得到的樱桃个数的最大值，即 $\textit{dfs}(t-1,j,k-1)$ 。
- 最后一步 A 往右走，B 往下走，那么问题变成两人从 $(0,0)$ 出发，都走了 $t-1$ 步，分别走到 $(t-j,j-1)$ 和 $(t-1-k,k)$ ，可以得到的樱桃个数的最大值，即 $\textit{dfs}(t-1,j-1,k)$ 。
- 最后一步 A 往右走，B 往右走，那么问题变成两人从 $(0,0)$ 出发，都走了 $t-1$ 步，分别走到 $(t-j,j-1)$ 和 $(t-k,k-1)$ ，可以得到的樱桃个数的最大值，即 $\textit{dfs}(t-1,j-1,k-1)$ 。

这四种情况取最大值，再加上 $\textit{grid}[t-j][j]$ 和 $\textit{grid}[t-k][k]$（两人位置重合时只加一个），就得到了$\textit{dfs}(t,j,k)$，即
$$\textit{dfs}(t,j,k) = \max(\textit{dfs}(t-1,j,k), \textit{dfs}(t-1,j,k-1), \textit{dfs}(t-1,j-1,k), \textit{dfs}(t-1,j-1,k-1)) + \textit{val}$$
其中
$$\textit{val} = \begin{cases} \textit{grid}[t-j][j] + \textit{grid}[t-k][k],&j \ne k\\ \textit{grid}[t-j][j],&j=k \end{cases}$$
递归边界 1：如果 $j,k,t-j,t-k,\textit{grid}[t-j][j], \textit{grid}[t-k][k]$ 中的任何一个数小于 $0$（出界或者访问到 $-1$ 格子），返回 $-\infty$ 。

递归边界 2：$\textit{dfs}(0,0,0) = \textit{grid}[0][0]$ 。

递归入口：$\textit{dfs}(2n-2,n-1,n-1)$ ，也就是答案。如果答案小于 $0$ ，说明路被荆棘（$-1$）挡住了，无法摘到任何一个樱桃，返回 $0$ 。

#### 3. 递归搜索 + 保存递归返回值 = 记忆化搜索
考虑到整个递归过程中有大量重复递归调用（递归入参相同）。由于递归函数没有副作用，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化：
- 如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 $\textit{memo}$ 数组中。
- 如果一个状态不是第一次遇到（$\textit{memo}$ 中保存的结果不等于 $\textit{memo}$ 的初始值），那么可以直接返回 $memo$ 中保存的结果。

注意：$\textit{memo}$ 数组的初始值一定不能等于要记忆化的值！例如初始值设置为 $0$ ，并且要记忆化的$\textit{dfs}(t,j,k)$ 也等于 $0$ ，那就没法判断 $0$ 到底表示第一次遇到这个状态，还是表示之前遇到过了，从而导致记忆化失效。一般把初始值设置为 $-1$ 。

Python 用户可以无视上面这段，直接用 `@cache` 装饰器。
```python
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        @cache # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）
        def dfs(t: int, j: int, k: int) -> int:
            # 不能出界，不能访问 -1 格子
            if j < 0 or k < 0 or t < j or t < k or grid[t - j][j] < 0 or grid[t - k][k] < 0:
                return -inf
            if t == 0: # 此时 j = k = 0
                return grid[0][0]
            return max(dfs(t - 1, j, k), dfs(t - 1, j, k - 1), dfs(t - 1, j - 1, k), dfs(t - 1, j - 1, k - 1)) + \
                grid[t - j][j] + (grid[t - k][k] if k != j else 0)
        n = len(grid)
        return max(dfs(n * 2 - 2, n - 1, n - 1), 0)
```

复杂度分析：
- 时间复杂度：$\mathcal{O}(n^3)$ ，其中 $n$ 为 $\textit{gird}$ 的行数和列数。由于每个状态只会计算一次，动态规划的时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。本题状态个数等于 $\mathcal{O}(n^3)$ ，单个状态的计算时间为 $\mathcal{O}(1)$ ，所以动态规划的时间复杂度为 $\mathcal{O}(n^3)$ 。
- 空间复杂度：$\mathcal{O}(n^3)$ 。保存多少状态，就需要多少空间。

#### 4. 1:1 翻译成递推
我们可以去掉递归中的「递」，只保留「归」的部分，即自底向上计算。

具体来说，f[t][j][k]f[t][j][k]f[t][j][k] 的定义和$\textit{dfs}(t,j,k)$ 的定义是一样的，都表示两人从 $(0,0,0)$ 出发，都走了 ttt 步，分别走到 (t−j,j)(t-j,j)(t−j,j) 和 (t−k,k)(t-k,k)(t−k,k)，可以得到的樱桃个数的最大值。

相应的递推式（状态转移方程）也和 dfs\textit{dfs}dfs 一样：

f[t][j][k]=max⁡(f[t−1][j][k],f[t−1][j][k−1],f[t−1][j−1][k],f[t−1][j−1][k−1])+valf[t][j][k] = \max(f[t-1][j][k], f[t-1][j][k-1], f[t-1][j-1][k], f[t-1][j-1][k-1]) + \textit{val}
f[t][j][k]=max(f[t−1][j][k],f[t−1][j][k−1],f[t−1][j−1][k],f[t−1][j−1][k−1])+val
其中

val={grid[t−j][j]+grid[t−k][k],j≠kgrid[t−j][j],j=k\textit{val} = \begin{cases} \textit{grid}[t-j][j] + \textit{grid}[t-k][k],&j \ne k\\ \textit{grid}[t-j][j],&j=k \end{cases}
val={ 
grid[t−j][j]+grid[t−k][k],
grid[t−j][j],
​
  
j

=k
j=k
​
 
但是，这种定义方式没有状态能表示递归边界，即 j=−1, k=−1j=-1,\ k=-1j=−1, k=−1 这种出界的情况。

解决办法：在每个 f[i]f[i]f[i] 的最左边和最上边各插入一排状态，那么其余状态全部向右和向下偏移一位，把 f[t][j][k]f[t][j][k]f[t][j][k] 改为 f[t][j+1][k+1]f[t][j+1][k+1]f[t][j+1][k+1]。

修改后 f[t][j+1][k+1]f[t][j+1][k+1]f[t][j+1][k+1] 表示两人从 $(0,0,0)$ 出发，都走了 ttt 步，分别走到 (t−j,j)(t-j,j)(t−j,j) 和 (t−k,k)(t-k,k)(t−k,k)，可以得到的樱桃个数的最大值。此时 f[t][0][⋅]f[t][0][\cdot]f[t][0][⋅] 和 f[t][⋅][0]f[t][\cdot][0]f[t][⋅][0] 就对应出界的情况了。

修改后的递推式为

f[t][j+1][k+1]=max⁡(f[t−1][j+1][k+1],f[t−1][j+1][k],f[t−1][j][k+1],f[t−1][j][k])+valf[t][j+1][k+1] = \max(f[t-1][j+1][k+1], f[t-1][j+1][k], f[t-1][j][k+1], f[t-1][j][k]) + \textit{val}
f[t][j+1][k+1]=max(f[t−1][j+1][k+1],f[t−1][j+1][k],f[t−1][j][k+1],f[t−1][j][k])+val
注意我们只在 fff 数组上插入了状态，这只会影响 fff 的下标，val\textit{val}val 的计算方式不变。

初始值 f[t][j][k]=−∞, f[0][1][1]=grid[0][0]f[t][j][k]= -\infty,\ f[0][1][1] = \textit{grid}[0][0]f[t][j][k]=−∞, f[0][1][1]=grid[0][0]。

答案为 max⁡(f[2n−2][n][n],0)\max(f[2n-2][n][n],0)max(f[2n−2][n][n],0)。

循环范围
代码实现时，我们还需要讨论清楚 jjj 和 kkk 的范围。

由于 i+j=ti+j = ti+j=t 且 0≤i≤n−10\le i \le n-10≤i≤n−1 且 0≤j≤n−10\le j \le n-10≤j≤n−1，联立得

max⁡(t−n+1,0)≤j≤min⁡(t,n−1)\max(t-n+1, 0) \le j \le \min(t, n-1)
max(t−n+1,0)≤j≤min(t,n−1)
对于 kkk 也同理。

此外，我们可以假定 A 走的是两条路径的下轮廓，B 走的是两条路径的上轮廓（求并集后看不出区别），所以只需计算 k≥jk\ge jk≥j 的状态。

Python3
Java
C++
Go
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        f = [[[-inf] * (n + 1) for _ in range(n + 1)] for _ in range(n * 2 - 1)]
        f[0][1][1] = grid[0][0]
        for t in range(1, n * 2 - 1):
            for j in range(max(t - n + 1, 0), min(t + 1, n)):
                if grid[t - j][j] < 0: continue
                for k in range(j, min(t + 1, n)):
                    if grid[t - k][k] < 0: continue
                    f[t][j + 1][k + 1] = max(f[t - 1][j + 1][k + 1], f[t - 1][j + 1][k], f[t - 1][j][k + 1], f[t - 1][j][k]) + \
                                         grid[t - j][j] + (grid[t - k][k] if k != j else 0)
        return max(f[-1][n][n], 0)
复杂度分析
时间复杂度：O(n3)\mathcal{O}(n^3)O(n 
3
 )，其中 nnn 为 gird\textit{gird}gird 的行数和列数。
空间复杂度：O(n3)\mathcal{O}(n^3)O(n 
3
 )。
五、空间优化
观察上面的状态转移方程，在计算 f[t]f[t]f[t] 时，只会用到 f[t−1]f[t-1]f[t−1]，不会用到比 $t-1$ 更早的状态。

因此可以像 0-1 背包那样，去掉第一个维度，倒序枚举 jjj 和 kkk。为什么要倒序请看 视频讲解：0-1 背包。

状态转移方程改为

f[j+1][k+1]=max⁡(f[j+1][k+1],f[j+1][k],f[j][k+1],f[j][k])+valf[j+1][k+1] = \max(f[j+1][k+1], f[j+1][k], f[j][k+1], f[j][k]) + \textit{val}
f[j+1][k+1]=max(f[j+1][k+1],f[j+1][k],f[j][k+1],f[j][k])+val
初始值 f[j][k]=−∞, f[1][1]=grid[0][0]f[j][k]= -\infty,\ f[1][1] = \textit{grid}[0][0]f[j][k]=−∞, f[1][1]=grid[0][0]。

答案为 max⁡(f[n][n],0)\max(f[n][n],0)max(f[n][n],0)。

Python3
Java
C++
Go
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        f = [[-inf] * (n + 1) for _ in range(n + 1)]
        f[1][1] = grid[0][0]
        for t in range(1, n * 2 - 1):
            for j in range(min(t, n - 1), max(t - n, -1), -1):
                for k in range(min(t, n - 1), j - 1, -1):
                    if grid[t - j][j] < 0 or grid[t - k][k] < 0:
                        f[j + 1][k + 1] = -inf
                    else:
                        f[j + 1][k + 1] = max(f[j + 1][k + 1], f[j + 1][k], f[j][k + 1], f[j][k]) + \
                                          grid[t - j][j] + (grid[t - k][k] if k != j else 0)
        return max(f[n][n], 0)
复杂度分析
时间复杂度：O(n3)\mathcal{O}(n^3)O(n 
3
 )，其中 nnn 为 gird\textit{gird}gird 的行数和列数。
空间复杂度：O(n2)\mathcal{O}(n^2)O(n 
2
 )。
由于从 $(N−1,N−1)$ 返回 $(0,0)$ 的这条路径，可以等价地看成从 $(0,0)$ 到 $(N−1,N−1)$ 的路径，因此问题可以等价转换成，有两个人从 $(0,0)$ 出发，向下或向右走到 $(N−1,N−1)$ 时，摘到的樱桃个数之和的最大值。

由于题目限制同一个格子只能摘取一次，我们需要找到一种方案来判断两人是否到达了同一个格子。

不妨假设两人同时出发，且速度相同。无论这两人怎么走，在时间相同的情况下，他们向右走的步数加上向下走的步数之和是一个定值（设为 kkk）。设两人的坐标为 (x1,y1)(x_1,y_1)(x 
1
​
 ,y 
1
​
 ) 和 (x2,y2)(x_2,y_2)(x 
2
​
 ,y 
2
​
 )，则 x1+y1=x2+y2=kx_1+y_1 = x_2+y_2 = kx 
1
​
 +y 
1
​
 =x 
2
​
 +y 
2
​
 =k。那么当 x1=x2x_1=x_2x 
1
​
 =x 
2
​
  时，必然有 y1=y2y_1=y_2y 
1
​
 =y 
2
​
 ，即两个人到达了同一个格子。

定义 f[k][x1][x2]f[k][x_1][x_2]f[k][x 
1
​
 ][x 
2
​
 ] 表示两个人（设为 A 和 B）分别从 (x1,k−x1)(x_1,k-x_1)(x 
1
​
 ,k−x 
1
​
 ) 和 (x2,k−x2)(x_2,k-x_2)(x 
2
​
 ,k−x 
2
​
 ) 同时出发，到达 (N−1,N−1)(N-1,N-1)(N−1,N−1) 摘到的樱桃个数之和的最大值。

如果 (x1,k−x1)(x_1,k-x_1)(x 
1
​
 ,k−x 
1
​
 ) 或 (x2,k−x2)(x_2,k-x_2)(x 
2
​
 ,k−x 
2
​
 ) 是荆棘，则 f[k][x1][x2]=−∞f[k][x_1][x_2]=-\inftyf[k][x 
1
​
 ][x 
2
​
 ]=−∞，表示不合法的情况。

枚举 A 和 B 上一步的走法，来计算 f[k][x1][x2]f[k][x_1][x_2]f[k][x 
1
​
 ][x 
2
​
 ]。有四种情况：

都往右：从 f[k−1][x1][x2]f[k-1][x_1][x_2]f[k−1][x 
1
​
 ][x 
2
​
 ] 转移过来；
A 往下，B 往右：从 f[k−1][x1−1][x2]f[k-1][x_1-1][x_2]f[k−1][x 
1
​
 −1][x 
2
​
 ] 转移过来；
A 往右，B 往下：从 f[k−1][x1][x2−1]f[k-1][x_1][x_2-1]f[k−1][x 
1
​
 ][x 
2
​
 −1] 转移过来；
都往下：从 f[k−1][x1−1][x2−1]f[k-1][x_1-1][x_2-1]f[k−1][x 
1
​
 −1][x 
2
​
 −1] 转移过来；
取这四种情况的最大值，加上 grid[x1][k−x1]\textit{grid}[x_1][k-x_1]grid[x 
1
​
 ][k−x 
1
​
 ] 和 grid[x2][k−x2]\textit{grid}[x_2][k-x_2]grid[x 
2
​
 ][k−x 
2
​
 ] 的值，就得到了 f[k][x1][x2]f[k][x_1][x_2]f[k][x 
1
​
 ][x 
2
​
 ]，如果 x1=x2x_1=x_2x 
1
​
 =x 
2
​
 ，则只需加上 grid[x1][k−x1]\textit{grid}[x_1][k-x_1]grid[x 
1
​
 ][k−x 
1
​
 ]。

最后答案为 max⁡(f[2n−2][n−1][n−1],0)\max(f[2n-2][n-1][n-1],0)max(f[2n−2][n−1][n−1],0)，取 max⁡\maxmax 是因为路径可能被荆棘挡住，无法从 $(0,0,0)$ 到达 (N−1,N−1)(N-1,N-1)(N−1,N−1)。

代码实现时，我们可以将 A 和 B 走出的路径的上轮廓看成是 A 走出的路径，下轮廓看成是 B 走出的路径，即视作 A 始终不会走到 B 的下方，则有 x1≤x2x_1\le x_2x 
1
​
 ≤x 
2
​
 ，在代码实现时保证这一点，可以减少循环次数。
