> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

厨房里总共有 `n` 个橘子，你决定每一天选择如下方式之一吃这些橘子：
- 吃掉一个橘子。
- 如果剩余橘子数 `n` 能被 2 整除，那么你可以吃掉 `n/2` 个橘子。
- 如果剩余橘子数 `n` 能被 3 整除，那么你可以吃掉 `2*(n/3)` 个橘子。

每天你只能从以上 3 种方案中选择一种方案。

请你返回吃掉所有 `n` 个橘子的最少天数。

**示例 1：**
```java
输入：n = 10
输出：4
解释：你总共有 10 个橘子。
第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。
第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）
第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。
第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。
你需要至少 4 天吃掉 10 个橘子。
```
**示例 2：**
```java
输入：n = 6
输出：3
解释：你总共有 6 个橘子。
第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）
第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）
第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。
你至少需要 3 天吃掉 6 个橘子。
```
**示例 3：**
```java
输入：n = 1
输出：1
```
**示例 4：**
```java
输入：n = 56
输出：6
```
**提示：**
- `1 <= n <= 2*10^9`

---
### 解法 记忆化搜索/最短路，附证明
有三种操作，每次操作，选择其中一种：
- 把 $n$ 减少 $1$ 。
- 如果 $n$ 能被 $2$ 整除，把 $n$ 变成 $\dfrac{n}{2}$ 。
- 如果 $n$ 能被 $3$ 整除，把 $n$ 变成 $\dfrac{n}{3}$ 。

返回把 $n$ 变成 $0$ 的最少操作次数。

**分析**
一个初步的想法是，为了让 $n$ 快速地变小，多做除法比多做减法要更好。

**引理**：在最优操作序列中，不存在「减 $1$ ，减 $1$ ，再除以 $2$ 」这样的操作。
**证明**：反证法。设当前剩下 $m$ 个橘子，先执行两次减 $1$ ，再除以 $2$ ，我们得到 $$\dfrac{m-1-1}{2} = \dfrac{m}{2}-1$$
（注意这意味着 $m$ 是偶数）。但**如果先除以 $2$ ，再减 $1$ ，同样可以得到 $\dfrac{m}{2}-1$ ，少操作一次**，矛盾。故原命题成立。

**定理**：在最优操作序列中，如果第一个不是「减 $1$ 」的操作是「除以 $2$ 」，那么当 $n$ 是偶数时，第一个操作一定是「除以 $2$ 」，当 $n$ 是奇数时，前两个操作一定是「减 $1$ ，除以 $2$ 」。

证明：反证法。在第一个不是「减 $1$ 」的操作是「除以 $2$ 」的前提下：
- 如果 $n$ 是偶数，且第一个操作不执行「除以 $2$ 」，那么要连续执行至少两次「减 $1$ 」操作才能「除以 $2$ 」，与引理不符。
- 如果 $n$ 是奇数，且第二个操作不执行「除以 $2$ 」，那么要连续执行至少三次「减 $1$ 」操作才能「除以 $2$ 」，与引理不符。

同理可证明，**在最优操作序列中，不存在「减 $1$ ，减 $1$ ，减 $1$ ，再除以 $3$ 」这样的操作序列**。

同理可证明，**在最优操作序列中，如果第一个不是「减 $1$ 」的操作是「除以 $3$ 」，那么一定会先执行 $n\bmod 3$ 次「减 $1$ 」操作，把 $n$ 变成 $3$ 的倍数，然后再执行「除以 $3$ 」**。
- 如果把 $n$ 通过减一除以 $2$ 变成 $\left\lfloor\dfrac{n}{2}\right\rfloor$ ，那么接下来要解决的问题是：把 $\left\lfloor\dfrac{n}{2}\right\rfloor$ 变成 $0$ 的最少操作次数。
- 如果把 $n$ 通过减一除以 $3$ 变成 $\left\lfloor\dfrac{n}{3}\right\rfloor$ ，那么接下来要解决的问题是：把 $\left\lfloor\dfrac{n}{3}\right\rfloor$ 变成 $0$ 的最少操作次数。
- 这些都是和原问题相似的子问题，分析和处理方法同上。

上述结论引出了以下两种方法：
- DFS 思路：记忆化搜索。
- BFS 思路：Dijkstra 算法求最短路。

#### 方法一：记忆化搜索
