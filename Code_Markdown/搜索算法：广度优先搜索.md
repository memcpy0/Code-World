在图的应用中已讲过图的广度优先搜索，树上的广度优先搜索实际上就是层次遍历。首先遍历第1层，然后第2层……同一层按照从左向右的顺序访问，直到最后一层。一棵树如下图所示，首先遍历第1层A；然后遍历第2层，从左向右遍历B、C；再遍历第3层，从左向右遍历D、E、F；再遍历第4层G。[插图]9.3.1　分支限界法分支限界法通常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。首先将根节点加入活节点表中，接着从活节点表中取出根节点，使其成为当前扩展节点，一次性生成其所有孩子节点，判断对孩子节点是舍弃还是保留，舍弃那些得不到可行解或最优解的节点，将其余节点保留在活节点表中。再从活节点表中取出一个活节点作为当前扩展节点。重复上述过程，直到找到所需的解或活节点表为空时为止。每一个活节点最多只有一次机会成为扩展节点。活节点表的实现通常有两种形式：一种是普通的队列，即先进先出队列；另一种是优先级队列，按照某种优先级决定哪个节点为当前扩展节点。根据活节点表的不同，分支限界法分为以下两种：队列式分支限界法和优先队列式分支限界法。分支限界法的解题秘笈如下。（1）定义解空间。解空间的大小对搜索效率有很大的影

响，首先要定义合适的解空间，确定解空间包括解的组织形式和显约束。解的组织形式规范为一个n元组{x1,x2,…,xn}，具体问题表达的含义不同。显约束是对解分量的取值范围的限定。（2）确定解空间的组织结构。对解空间的组织结构通常用解空间树形象地表达，根据解空间树的不同，解空间分为子集树、排列树、m叉树等。（3）搜索解空间。分支限界法指按照广度优先搜索策略，一次性生成所有孩子节点，根据约束函数和限界函数判定对孩子节点是舍弃还是保留，如果保留，则将其依次放入活节点表中，活节点表是普通队列或优先队列。然后从活节点表中取出一个节点，继续扩展，直到找到所需的解或活节点表为空时为止。如果对该问题只求可行解，则只需设定约束函数即可；如果求最优解，则需要设定约束函数和限界函数。在优先队列分支限界法中还有一个关键问题，即优先级的设定：选择什么值作为优先级？如何定义优先级？因为优先级的设计直接决定算法的效率。本节重点揭秘如何设定高效的优先级。9.3.2　队列式广度优先搜索有n个物品和1个背包，每个物品i对应的价值都为vi、重量都为wi，背包的容量为W（也可以将重量设定为体积）。每个物品只有一件，要么装入，要

么不装入，不可拆分。如何选取物品装入背包，使背包所装入物品的总价值最大？上述问题是典型的01背包问题，已经用回溯法求解过，在此先用普通队列式分支界限法求解，然后用优先队列式分支界限法求解，体会这两种算法的不同之处。1. 算法设计（1）定义问题的解空间。背包问题属于典型的01背包问题，问题的解是从n个物品中选择一些物品，使其在不超过容量的情况下价值最大。每个物品都有且只有两种状态：要么被装入背包，要么不被装入背包。那么是第i个物品被装入背包能够达到目标，还是不被装入能够达到目标呢？显然还不确定。因此，可以用变量xi表示第i种物品是否被装入背包的状态，如果用“0”表示不被装入背包，用“1”表示被装入背包，则xi的取值为0或1。第i个物品被装入背包，xi=1；不被装入背包，xi=0。该问题解的形式是一个n元组，且每个分量的取值都为0或1。由此可得，问题的解空间为{x1,x2,…,xi,…,xn}，其中显约束xi =0或1，i=1,2,3…n。（2）确定解空间的组织结构。问题的解空间描述了2n种可能的解，也可以说是n个元素组成的集合的所有子集个数。解空间树为子集树，解空间树的深度为问题的规模n

，如下图所示。[插图]（3）搜索解空间。根据解空间的组织结构，对于任何一个中间节点z（中间状态），从根节点到z节点的分支所代表的状态（是否装入背包）已确定，从z到其子孙节点的分支的状态待确定。也就是说，如果z在解空间树中所处的层次是t，则说明从第1种物品到第t-1种物品的状态已确定，只需沿着z的分支扩展确定第t种物品的状态，前t种物品的状态就确定了。在前t种物品的状态确定后，对当前已装入背包的物品的总重量用cw表示，对总价值用cp表示。• 约束条件。判断第i个物品被装入背包后总重量是否超出背包容量，如果超出，则为不可行解；否则为可行解。约束条件为cw+w[i]≤W。其中w[i]为第i个物品的重量，W为背包容量。• 限界条件。已装入物品的价值高不一定就是最优的，因为还有剩余物品未确定。目前还不确定第t+1种物品到第n种物品的实际状态，因此只能用估计值。假设第t+1种物品到第n种物品都被装入背包，对第t+1种物品到第n种物品的总价值用rp来表示，因此cp+rp是所有从根出发经过中间节点z的可行解的价值上界，如下图所示。[插图]如果价值上界小于当前搜索到的最优值（对最优值用bestp表示，初始值为0），

则说明从中间节点z继续向子孙节点搜索不可能得到一个比当前更优的可行解，没有继续搜索的必要；反之，继续向z的子孙节点搜索。限界条件为cp+rp≥bestp。注意：回溯法中的背包问题，限界条件不带等号，因为bestp被初始化为0，首次到达叶子时才会更新bestp，因此只要有解，就必然存在至少一次到达叶子。而在分支限界法中，只要cp>bestp，就立即更新bestp，如果在限界条件中不带等号，就会出现无法到达叶子的情况，比如解的最后一位是0时，例如(1,1,1,0)，就无法找到这个解向量。因为在最后一位是0时，cp+rp=bestp，而不是cp+rp>bestp，如果限界条件不带等号，就无法到达叶子，得不到解(1,1,1,0)。该算法均设置了到叶子节点判断更新最优解和最优值。这里讲解搜索过程。从根节点开始，以广度优先的方式进行搜索。根节点首先成为活节点，也是当前扩展节点。一次性生成所有孩子节点，由于在子集树中约定左分支上的值为“1”，因此沿着扩展节点的左分支扩展，则代表装入物品；由于在子集树中约定右分支上的值为“0”，因此沿着扩展节点的右分支扩展，则代表不装入物品。此时判断是否满足约束条件和

限界条件，如果满足，则将其加入队列中；反之，舍弃。然后从队列中取出一个元素，作为当前扩展节点……直到搜索过程队列为空时为止。2. 完美图解有一个背包和4个物品，每个物品的重量和价值都如下图所示，背包的容量W=10。求在不超过背包容量的前提下，把哪些物品放入背包才能获得最大价值。[插图]（1）初始化。sumw和sumv分别用来统计所有物品的总重量和总价值。sumw=13，sumv=18，sumw>W，因此不能全部装完，需要搜索求解。初始化当前放入背包的物品价值cp=0，当前剩余物品价值rp=sumv，当前剩余容量rw=W，当前处理物品序号为1且当前最优值bestp=0。解向量x[]=(0,0,0,0)，创建一个根节点Node(cp,rp,rw,id)，将其标记为A并加入先进先出队列q中。cp为装入背包的物品价值，rp为剩余物品的总价值，rw为剩余容量，id为物品号，x[]为当前解向量，如下图所示。[插图]（2）扩展节点A。队头元素A出队，该节点的cp+rp≥bestp，满足限界条件，可以扩展。rw=10>goods[1].weight=2，剩余容量大于1号物品的重量，满足约束条件，可以被放入背包，c

p=0+6=6，rp=18−6=12，rw=10−2=8，t=2，x[1]=1，解向量更新为x[]=(1,0,0,0)，生成左孩子B并将其加入q队列，更新bestp=6。再扩展右分支，cp=0，rp=18−6=12，cp+rp≥bestp=6，满足限界条件，不放入1号物品，cp=0，rp=12，rw=10，t=2，x[1]=0，解向量为x[]=(0,0,0,0)，创建新节点C并将其加入q队列中，如下图所示。[插图]（3）扩展节点B。队头元素B出队，该节点的cp+rp≥bestp，满足限界条件，可以扩展。rw=8>goods[2]. weight=5，剩余容量大于2号物品的重量，满足约束条件，cp=6+3=9，rp=12−3=9，rw=8−5=3，t=3，x[2]=1，解向量更新为x[]=(1,1,0,0)，生成左孩子D并将其加入q队列中，更新bestp=9。再扩展右分支，cp=6，rp=12−3=9，cp+rp≥bestp=9，满足限界条件，t=3，x[2]=0，解向量为x[]=(1,0,0,0)，生成右孩子E并将其加入q队列中，如下图所示。[插图]（4）扩展节点C。队头元素C出队，该节点的cp+

rp≥bestp，满足限界条件，可以扩展。rw=10>goods[2].weight=5，剩余容量大于2号物品的重量，满足约束条件，cp=0+3=3，rp=12−3=9，rw=10−5=5，t=3，x[2]=1，解向量更新为x[]=(0,1,0,0)，生成左孩子F并将其加入q队列中。再扩展右分支，cp=0，rp=12−3=9，cp+rp≥bestp=9，满足限界条件，rw=10，t=3，x[2]=0，解向量为x[]=(0,0,0,0)，生成右孩子G并将其加入q队列中，如下图所示。[插图]（5）扩展节点D。队头元素D出队，该节点的cp+rp≥bestp，满足限界条件，可以扩展。rw=3>goods[3]. weight=4，剩余容量小于3号物品的重量，不满足约束条件，舍弃左分支。再扩展右分支，cp=9，rp=9−5=4，cp+rp≥bestp=9，满足限界条件，t=4，x[3]=0，解向量为x[]=(1,1,0,0)，生成右孩子H并将其加入q队列中，如下图所示。[插图]（6）扩展节点E。队头元素E出队，该节点的cp+rp≥bestp，满足限界条件，可以扩展。rw=8>goods[3].weight=

4，剩余容量大于3号物品的重量，满足约束条件，cp=6+5=11，rp=9−5=4，rw=8−4=4，t=4，x[3]=1，解向量更新为x[]=(1,0,1,0)，生成左孩子I并将其加入q队列中，更新bestp=11。再扩展右分支，cp=6，rp=9−5=4，cp+rp<bestp=11，不满足限界条件，舍弃，如下图所示。[插图]（7）扩展节点F。队头元素F出队，该节点的cp+rp≥bestp，满足限界条件，可以扩展。rw=5>goods[3].weight=4，剩余容量大于3号物品的重量，满足约束条件，cp=3+5=8，rp=9−5=4，rw=5−4=1，t=4，x[3]=1，解向量更新为x[]=(0,1,1,0)，生成左孩子J并将其加入q队列中。再扩展右分支，cp=3，rp=9−5=4，cp+rp<bestp=11，不满足限界条件，舍弃，如下图所示。[插图]（8）扩展节点G。队头元素G出队，该节点的cp+rp<bestp=11，不满足限界条件，不扩展。（9）扩展节点H。队头元素H出队，该节点的cp+rp≥bestp，满足限界条件，可以扩展。rw=3>goods[4].weight=2，剩余容量

大于4号物品的重量，满足约束条件，令cp=9+4=13，rp=4−4=0，rw=3−2=1，t=5，x[4]=1，解向量更新为x[]=(1,1,0,1)，生成左孩子K并将其加入q队列中，更新bestp=13。再扩展右分支，cp=9，rp=4−4=0，cp+rp<bestp，不满足限界条件，舍弃，如下图所示。[插图]（10）扩展节点I。队头元素I出队，该节点的cp+rp≥bestp，满足限界条件，可以扩展。rw=4>goods[4].weight=2，剩余容量大于4号物品的重量，满足约束条件，cp=11+4=15，rp=4-4=0，rw=4−2=2，t=5，x[4]=1，解向量更新为x[]=(1,0,1,1)，生成左孩子L并将其加入q队列中，更新bestp=15。再扩展右分支，cp=11，rp=4−4=0，cp+rp<bestp，不满足限界条件，舍弃，如下图所示。[插图]（11）队头元素J出队，该节点的cp+rp<bestp=15，不满足限界条件，不再扩展。（12）队头元素K出队，扩展节点K，t=5，已经处理完毕，cp<bestp，不是最优解。（13）队头元素L出队，扩展节点L，t=5，已经处理完毕

，cp=bestp，是最优解，输出该解向量(1,0,1,1)。（14）队列为空，算法结束。3. 算法实现（1）定义节点结构体。[插图]（2）定义物品结构体。在前面处理背包问题时，使用了两个一维数组w[]、v[]分别存储物品的重量和价值，在此使用一个结构体数组来存储这些重量和价值。[插图]（3）搜索解空间。首先创建一个普通队列（先进先出），然后将根节点加入队列中，如果队列不空，则取出队头元素livenode，得到当前处理的物品序号，如果当前处理的物品序号大于n，则说明搜到最后一个物品了，不需要往下搜索。如果当前的背包没有剩余容量（已经装满）了，则不再扩展。如果当前放入背包的物品价值大于或等于最优值（livenode.cp≥bestp），则更新最优解和最优值。判断是否满足约束条件，满足则生成左孩子，判断是否更新最优值，左孩子入队，不满足约束条件则舍弃左孩子；判断是否满足限界条件，满足则生成右孩子，右孩子入队，不满足限界条件则舍弃右孩子。[插图][插图]4. 算法分析时间复杂度：算法的运行时间取决于它在搜索过程中生成的节点数。而限界函数可以大大减少所生成的节点个数，避免无效搜索，加快搜索速度。左孩子需要判断约束函数，右

孩子需要判断限界函数，那么在最坏情况下有多少个左孩子和右孩子呢？规模为n的子集树在最坏情况下的状态如下图所示。[插图]总的节点个数为20+21+…+2n=2n+1−1，减去树根节点再除以2，就得到左右孩子的个数，左右孩子的个数=(2n+1−1−1)/2=2n−1。约束函数时间复杂度为O(1)，限界函数时间复杂度为O(1)。在最坏情况下有O(2n)个左孩子需要调用约束函数，有O(2n)个右孩子需要调用限界函数，所以计算背包问题的分支限界法的时间复杂度为O(2n+1)。空间复杂度：空间主要耗费在Node节点里面存储的变量和解向量上，因为最多有O(2n+1)个节点，而每个节点的解向量都需要O(n)个空间，所以空间复杂度为O(n×2n+1)。其实让每个节点都记录解向量的办法是很笨的，我们可以用指针记录当前节点的左右孩子和父亲，到达叶子时逆向找其父亲，直到根节点，就得到了解向量，这样空间复杂度降为O(n)。9.3.3　优先队列式广度优先搜索优先队列优化以当前节点的上界为优先值，把普通队列改成优先队列，这样就得到了优先队列式分支限界法。1. 算法设计优先级的定义为活节点代表的部分解所描述的已装入物品的价

值上界，上界越大，优先级越高。活节点的价值上界up=活节点的cp+剩余物品装满背包剩余容量的最大价值rp'。约束条件：cw+w[i]≤W。限界条件：up=cp+rp'≥bestp。2. 完美图解有一个背包和4个物品，每个物品的重量和价值如下图所示，背包的容量W=10。求在不超过背包容量的前提下，把哪些物品放入背包才能获得最大价值。[插图]（1）初始化。sumw和sumv分别用来统计所有物品的总重量和总价值。sumw=13，sumv=18，sumw>W，因此不能全部装完，需要搜索求解。（2）按价值重量比非递增排序。排序后的结果如下图所示。为了程序处理方便，把排序后的数据存储在w[]和v[]数组中。后面的程序在该数组上操作即可，如下图所示。[插图]（3）创建根节点A。初始化当前放入背包的物品重量cp=0，当前价值上界up=sumv，当前剩余容量rw=W，当前处理物品序号为1，当前最优值bestp=0。最优解初始化为x[]=(0,0,0,0)，创建一个根节点Node(cp,up,rw,id)，标记为A，加入优先队列q中，如下图所示。[插图]（4）扩展节点A。队头元素A出队，该节点的up≥bestp，满足限界条

件，可以扩展。rw=10>w[1]=2，剩余容量大于1号物品的重量，满足约束条件，可以放入背包，生成左孩子，令cp=0+6=6，rw=10-2=8。那么上界怎么算呢？up=cp+rp'=cp+剩余物品装满背包剩余容量的最大价值rp'。剩余容量还有8，可以装入2、3号物品，装入后还有剩余容量2，只能装入4号物品的一部分，装入的价值为剩余容量×单位重量价值，即2×3/5=1.2，rp'=4+5+1.2=10.2，up=cp+rp'= 16.2。在此需要注意，背包问题属于01背包问题，物品要么装入，要么不装入，是不可以分割的，这里为什么还会有部分装入的问题呢？很多读者看到这里都有这样的疑问，在此不是真的部分装入了，只是算上界而已。令t=2，x[1]=1，解向量更新为x[]=(1,0,0,0)，创建新节点B并将其加入q队列中，更新bestp=6，如下图所示。[插图]再扩展右分支，cp=0，rw=10，剩余容量可以装入2、3号物品，装入后还有剩余容量4，只能装入4号物品的一部分，装入的价值为剩余容量单位重量价值，即4×3/5=2.4，rp'=4+5+2.4= 11.4，up=cp+rp'=11.4，


up>bestp，满足限界条件，令t=2，x[1]=0，解向量更新为x[]=（0,0,0,0），生成右孩子C并将其加入q队列中，如下图所示。[插图]（5）扩展节点B。队头元素B出队，该节点的up≥bestp，满足限界条件，可以扩展。剩余容量rw=8>w[2]=2，大于2号物品的重量，满足约束条件，令cp=6+4=10，rw=8−2=6，up=cp+rp'=10+5+2×3/5=16.2，t=3，x[2]=1，解向量更新为x[]=(1,1,0,0)，生成左孩子D并将其加入q队列中，更新bestp=10。再扩展右分支，cp=6，rw=8，剩余容量可以装入3号物品，4号物品部分装入，up=cp+rp'=6+5+3×4/5=13.4，up>bestp，满足限界条件，令t=3，x[2]=0，解向量为x[]=(1,0,0,0)，生成右孩子E并将其加入q队列中。注意：q为优先队列，其实是用堆实现的，如果不想搞清楚，则只需知道每次up值最大的节点出队即可，如下图所示。[插图]（6）扩展节点D。队头元素D出队，该节点的up≥bestp，满足限界条件，可以扩展。剩余容量rw=6>w[3]=4，大于3号物品的重量，满足
限界条件，可以扩展。剩余容量rw=6>w[3]=4，大于3号物品的重量，满足约束条件，令cp=10+5=15，rw=6−4=2，up=cp+rp'=10+5+2×3/5=16.2，t=4，x[3]=1，解向量更新为x[]=(1,1,1,0)，生成左孩子F并将其加入q队列中，更新bestp=15。再扩展右分支，cp=10，rw=8，剩余容量可以装入4号物品，up=cp+rp'=10+3=13，up<bestp，不满足限界条件，舍弃右孩子，如下图所示。[插图]（7）扩展节点F。队头元素F出队，该节点的up≥bestp，满足限界条件，可以扩展。剩余容量rw=2<w[4]=5，不满足约束条件，舍弃左孩子。再扩展右分支，cp=15，rw=2，虽然有剩余容量，但物品已经处理完毕，已没有物品可以装入，up=cp+rp'=15+0=15，up≥bestp，满足限界条件，令t=5，x[4]=0，解向量为x[]=(1,1,1,0)，生成右孩子G并将其加入q队列中，如下图所示。[插图]（8）扩展节点G。队头元素G出队，该节点的up≥bestp，满足限界条件，可以扩展。t=5，已经处理完毕，bestp=cp=15，是最优

解，解向量为x[]=(1,1,1,0)。注意：虽然解是(1,1,1,0)，但对应的物品原来的序号是1、4、3。节点G出队。（9）队头元素E出队，该节点的up<bestp，不满足限界条件，不再扩展。（10）队头元素C出队，该节点的up<bestp，不满足限界条件，不再扩展。（11）队列为空，算法结束。3. 算法实现（1）定义节点和物品结构体。[插图][插图]（2）定义辅助结构体和排序优先级（从大到小排序）。[插图]（3）定义队列的优先级。[插图]（4）计算节点的上界。[插图]（5）优先队列分支限界法。[插图][插图]4. 算法分析虽然在算法复杂度数量级上，优先队列的分支限界法算法和普通队列的算法相同，但从图解可以看出，采用优先队列式的分支限界法算法生成的节点数更少，找到最优解的速度更快。训练1　迷宫问题题目描述（POJ3984）：用一个二维数组表示一个迷宫，其中1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，编写程序，找出从左上角到右下角的最短路线。[插图]输入：一个5×5的二维数组，表示一个迷宫。数据保证有唯一解。输出：从左上角到右下角的最短路径，格式如以下输出样例所示。[插图]题解：本题为典型的迷宫问题，可以使用广度优先搜

索解决。定义方向数组dir[4][2]= {{1,0},{-1,0},{0,1},{0,-1}}，定义前驱数组pre[][]记录经过的节点。1. 算法设计（1）定义一个队列，将起点(0, 0)入队，标记已走过。（2）如果队列不空，则队头出队。（3）如果队头正好是目标(4, 4)，则退出。（4）沿着4个方向搜索，如果该节点未出边界、未走过且不是墙壁，则标记走过并入队，用前驱数组记录该节点。（5）转向步骤2。（6）根据前驱数组输出从起点到终点的最短路径。2. 算法实现[插图]训练2　加满油箱题目描述（POJ3635）：城市之间的油价是不一样的，编写程序，寻找最便宜的城市间旅行方式。在旅行途中可以加满油箱。假设汽车每单位距离使用一单位燃料，从一个空油箱开始。输入：输入的第1行包含n（1≤n≤1000）和m（0≤m≤10 000），表示城市和道路的数量。下一行包含n个整数pi（1≤pi≤100），其中pi表示第i个城市的燃油价格。接下来的m行，每行都包含3个整数u、v（0≤u, v<n）和d（1≤d≤100），表示在u和v之间有一条路，长度为d。接下来一行是查询数q（1≤q≤100）。再接下来的q行

，每行都包含3个整数c（1≤c≤100）、s和e，其中c是车辆的油箱容量，s是起点城市，e是终点城市。输出：对于每个查询，都输出给定容量的汽车从s到e的最便宜旅程的价格，如果无法从s到e，则输出“impossible”。[插图]题解：本题为加油站加油问题。给定n个节点、m条边，每走1单位的路径都会花费1单位的油量，并且不同的加油站价格是不同的。现在有一些询问，每一个询问都包括起点、终点及油箱的容量，求从起点到达终点所需的最少花费。可以采用优先队列分支限界法搜索。[插图]涉及两个维度的图最短路径，一个是费用，一个是地点。可以把当前节点对应的油量抽象成多个节点（例如在位置0有1升油是一个节点，在位置0有2升油是一个节点），把费用看作边，那么最少费用就可以类似Dijsktra算法那样不断地加入节点。于是得到一个扩展节点的策略：每次都加1升油；如果依靠加的油足够走到下一个节点，就走到下一个节点（减去路上消耗的油，花费不变）；在广度优先搜索中将所有可扩展的节点都加入优先队列中，如果到达终点，则返回花费。1. 算法设计（1）定义一个优先队列，将起点及当前油量、花费作为一个节点(st,0,0)入队。（2）如果队列



不空，则队头(u,vol,cost)出队，并标记该节点油量已扩展，vis[u][vol]=1。（3）如果u正好是目标ed，则返回花费cost。（4）如果当前油量小于油箱容量，且u的油量vol+1未扩展，则将该节点(u,vol+1, cost+price[u])入队。（5）检查u所有邻接点v，如果当前油量大于或等于边权w，且v节点的油量vol-w未扩展，则将该节点(v,vol-w,cost)入队。（6）转向步骤2。2. 算法优化用一个数组dp[i][j]表示在节点i、当前油量为j时的最小花费。在当前节点及油量对应的花费更小时才生成节点，生成的节点会少很多，但由于系统数据量不大，运行时间差不多。采用优化后的算法生成节点的过程如下图所示。[插图]3. 算法实现[插图][插图]9.3.4　嵌套广度优先搜索在广度优先搜索里面嵌套广度优先搜索的算法被称为嵌套广度优先搜索（或称双重广度优先搜索）。训练　推箱子题目描述（POJ1475）：想象一下，你站在一个由方格组成的二维迷宫里，这些格子可能被填满岩石，也可能没被填满岩石。你可以一步一个格子地往北、往南、往东或往西移动。这样的动作叫作“走”。其中一个空单元格包含一个箱

子，你可以站在箱子旁边，推动箱子到相邻的自由单元格。这样的动作叫作“推”。箱子除了用推的方式，不能移动，如果你把它推到角落里，就再也不能把它从角落里拿出来了。将其中一个空单元格标记为目标单元格。你的工作是通过一系列走和推把箱子带到目标格子里。由于箱子很重，所以要尽量减少推的次数。编写程序，计算最好的移动（走和推）顺序。


[插图]输入：输入包含多个测试用例。每个测试用例的第1行都包含两个整数r和c（均小于或等于20），表示迷宫的行数和列数。接下来是r行，每行都包含c个字符，每个字符都描述迷宫中的一个格子，对被填满岩石的格子用“#”表示，对空格用“.”表示。对起始位置用“S”表示，对箱子的起始位置用“B”表示，对目标单元格用“T”表示。输入端以两个0终止。输出：对于输入中的每个迷宫，都首先输出迷宫的编号。如果无法将箱子带到目标单元格里，则输出“Impossible.”，否则输出一个最小推送次数的序列。如果有多个这样的序列，则请选择一个最小总移动（走和推）次数的序列。如果仍然有多个这样的序列，则任何一个都可被接受。将序列输出为由字符N、S、E、W、n、s、e和w组成的字符串，大写字母表示推，小写字母表示走，字母分别表示北、南、东和西这4个方向。在每个测试用例之后都输出一个空行。[插图]题解：本题为推箱子问题，要求先保证推箱子的次数最少，在此基础上再让人走的总步数最少。推箱子时，人只有站在箱子反方向的前一个位置，才可以将箱子推向下一个位置，如下图所示。很明显，图中的箱子无法向上移动，因为人无法到达箱子的下面位置。因此在移


移动箱子时，不仅需要判断新位置有没有岩石，还需要判断人是否可以到达反方向的前一个位置，在两者均有效时，才会让人移动。[插图]先求解箱子到目标位置的最短路径（BFS1），在推箱子的过程中，每推一步，都根据推的方向和箱子的位置得到箱子的前一个位置，再求解人到达这个位置的最短路径（BFS2）。在BFS1里面嵌套了BFS2，属于嵌套广度优先搜索。1. 算法设计（1）定义一个标识数组vis[][]并将其初始化为0，标识所有位置都未被访问。（2）创建一个队列q维护箱子的状态，将人的初始位置(sx, sy)、箱子的初始位置(bx, by)和初始路径("")入队，标记箱子的位置vis[bx][by]=1。（3）如果队列不空，则队头now出队，否则返回false。（4）从箱子的当前位置开始，向北、南、东和西这4个方向扩展。• 得到箱子的新位置：nbx=now.bx+dir[i][0]; nby=now.by+dir[i][1]。• 得到箱子的前一个位置：tx=now.bx-dir[i][0]; ty=now.by-dir[i][1]。• 如果这两个位置有效，则执行BFS2搜索人到达箱子的前一个位置(tx, t

y)的最短路径，并记录路径path。如果BFS2搜索成功，则判断是否达到目标，如果是，则返回答案ans=now.path+path+dpathB[i]；否则标记箱子的新位置被访问vis[nbx][nby]=1，将人的新位置(now.bx,now.by)、箱子的新位置(nbx,nby)和已走过的路径(now.path+path+ dpathB[i])入队。（5）转向步骤3。2. 算法实现[插图][插图]9.3.5　双向广度优先搜索双向搜索指分别从初始状态和目标状态出发进行搜索，在中间交会时即搜索成功。从一个方向搜索时，分支数会随着深度的增加而快速增长，产生一个大规模的搜索树。而双向搜索从两个方向搜索，产生两棵深度减半的搜索树，搜索速度更快。双向搜索包括双向DFS和双向广度优先搜索。训练　魔鬼Ⅱ题目描述（HDU3085）：小明做了一个可怕的噩梦，梦见他和他的朋友分别被困在一个大迷宫里。更可怕的是，在迷宫里有两个魔鬼，他们会杀人。小明想知道他能否在魔鬼找到他们之前找到他的朋友。小明和他的朋友可以朝四个方向移动。在每秒内，小明都可以移动3步，他的朋友可以移动1步。魔鬼每秒都会分裂成几部分，占据两步之内的网

格，直到占据整个迷宫。假设魔鬼每秒都会先分裂，然后小明和他的朋友开始移动，如果小明或他的朋友到达一个有魔鬼的格子，就会死（新的魔鬼也可以像原来的魔鬼一样分裂）。输入：输入以整数T开头，表示测试用例的数量。每个测试用例的第1行都包含两个整数n和m（1<n,m<800），表示迷宫的行数和列数。接下来的n行，每行都包含m个字符，字符“.”表示一个空地方，所有人都可以走；“X”表示一堵墙，只有人不能走；“M”表示小明；“G”表示小明的朋友；“Z”表示魔鬼，保证包含一个字母M、一个字母G和两个字母Z。输出：如果小明和他的朋友能够见面，则单行输出见面的最短时间，否则输出-1。[插图]题解：已知起点（小明）、终点（小明的朋友），两者在中间遇到即见面成功，可以采用双向广度优先搜索。使用双向广度优先搜索时需要创建两个队列，分别从小明的初始位置、小明的朋友的初始位置开始，轮流进行广度优先搜索。在本题中，小明每次都可以移动3步，小明的朋友每次都可以移动1步，因此在每一轮循环中，小明都扩展3层，小明的朋友都扩展1层。在扩展时，需要检查与魔鬼的距离，判断该节点是否会被魔鬼波及。1. 算法设计（1）定义两个队列q[0]

、q[1]，分别将小明的起始位置mm和小明的朋友的起始位置gg入队，秒数step=0。（2）如果两个队列均不空，则执行步骤3，否则返回-1。（3）step++，小明扩展3步，如果搜索到小明的朋友的位置，则返回true；否则小明的朋友扩展1步，如果搜索到小明的位置，则返回true。如果在两个方向搜索时发现有一个方向为true，则返回秒数step，否则执行步骤2。2. 算法实现[插图][插图]
