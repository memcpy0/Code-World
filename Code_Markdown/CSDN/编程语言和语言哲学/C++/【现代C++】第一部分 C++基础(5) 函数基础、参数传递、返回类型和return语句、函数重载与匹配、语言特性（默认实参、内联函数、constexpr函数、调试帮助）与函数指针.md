> 本文属于「现代C++学习实践」系列文章之一，这一系列正式开始于2021/09/04，着重于**现代C++**（即C++11、14、17、20、23等新标准）和**Linux C++服务端开发**的学习与实践。众所周知，「**C++难就难在：在C++中你找不到任何一件简单的事**」。因此，本系列将至少持续到作者本人「精通C++」为止（笑）。由于文章内容随时可能发生更新变动，欢迎关注和收藏[现代C++系列文章汇总目录](https://memcpy0.blog.csdn.net/article/details/120103284)一文以作备忘。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/]。在这一仓库中，你可以看到本人学习C++的全过程，包括C++书籍源码、练习实现、小型项目等。
> <b></b> 
需要特别说明的是，为了透彻理解和全面掌握现代C++，本系列文章中参考了诸多博客、教程、文档、书籍等资料，限于时间精力有限，这里无法一一列出。部分重要资料的不完全参考目录如下所示，在后续学习整理中还会逐渐补充：
> - C++ Primer 中文版（第5版），Stanley B. Lippman、Barbara E. Moo等著，王刚、杨巨峰译，叶劲峰、李云、刘未鹏等审校，电子工业出版社；
> - 侯捷老师的公开课；
>    - C++面向对象高级开发上、下：正确理解面向对象的精神和实现手法，涵盖对象模型、关键机制、编程风格、动态分配；
>    - STL标准库与范型编程：深入剖析STL标准库之六大部件、及其之间的体系结构，并分析其源码，引导高阶泛型编程。
>    - C++新标准C++11/14：在短时间内深刻理解C++2.0的诸多新特性，涵盖语言和标准库两层
>    - C++内存管理机制：学习由语言基本构件到高级分配器的设计与实作，并探及最低阶`malloc` 的内部实现。
>    - C++ Startup揭密：C++程序的生前和死后。认识Windows平台下的Startup Code(启动码)，完全通透C++程序的整个运行过程。


@[toc]

---







### 6.5.3 `constexpr` 函数
**`constexpr` 函数** `constexpr function` 是指能用于**常量表达式**（参加**2.4.4节**）的函数。定义 `constexpr` 函数的方法类似普通函数，只是要遵循几项约定：
- 函数的返回类型、所有形参的类型，都必须是**字面值类型**（参见**2.4.4节**）；
- 函数体中必须有且只有一条 `return` 语句。此外还可以包含其他语句，只要这些语句在运行时不执行任何操作就行，如空语句、类型别名（参见**2.5.1节**）以及 `using` 声明

示例如下，把 `new_sz` 定义为无参数的 `constexpr` 函数。因为**编译器能在程序编译时验证 `new_sz` 函数返回的是常量表达式**，所以可以用 `new_sz` 函数初始化 `constexpr` 类型的变量 `foo` ：
```cpp
constexpr int new_sz() { return 42; }
constexpr int foo = new_size();	// 正确：foo是一个常量表达式
```
执行该初始化任务时，编译器把对 `constexpr` 函数的调用替换成其结果值。为了在编译过程中随时展开，**`constexpr` 函数被隐式指定为内联函数**。

**我们允许 `constexpr` 函数的返回值并非一个常量表达式**。如下所示，当 `scale` 的实参 `arg` 是常量表达式时，它的返回值 `scale(arg)` 也是常量表达式；反之则不然：
```cpp
// 如果arg是常量表达式，则scale(arg)也是常量表达式
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }
```
当我们给 `scale` 函数传入一个形如字面值 `2` 的常量表达式时，它的返回类型也是常量表达式，此时编译器用相应的结果值替换对 `scale` 函数的调用。如果用一个非常量表达式调用 `scale` 函数，比如 `int` 类型的对象 `i` ，则返回值是一个非常量表达式。可以说，**传入实参的类型决定返回值的类型**。

当把 `scale` 函数用在需要常量表达式的上下文中时，由编译器负责检查函数的结果是否符合要求，如果结果恰好不是常量表达式，则编译器报错。

### 6.5.4 把内联函数和 `constexpr` 函数放在头文件内
和其他函数不一样，**内联函数和 `constexpr` 函数可以在程序中多次定义**。毕竟编译器想要展开函数，只有函数声明是不够的，还需要函数的定义。不过对某个给定的内联函数或 `constexpr` 函数来说，**它的多个定义必须完全一致**。基于这一原因，**内联函数和 `constexpr` 函数通常放在头文件中**。

## 6.5.2节练习
练习6.43：你会把下面的哪个声明和定义放在头文件中？哪个放在源文件中？为什么？
```cpp
(a) inline bool eq(const BigInt&, const BigInt&) { ... }
(b) void putValues(int *arr, int size);
```
练习6.44：将6.2.2节的 `isShorter` 函数改写成内联函数。

练习6.45：回顾在前面的练习中你编写的那些函数，它们应该是内联函数吗？如果是，将它们改写成内联函数；如果不是，说明原因。

练习6.46：能把 `isShorter` 函数定义成 `constexpr` 函数吗？如果能，将它改写成 `constexpr` 函数；如果不能，说明原因。

【现代C++】第一部分 C++基础(5) 函数基础、参数传递、返回类型和return语句、函数重载与匹配、语言特性（默认实参、内联函数、constexpr函数、调试帮助）与函数指针

---
## 6.5.3 调试帮助

