> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个顾客访问商店的日志，用一个下标从 **0** 开始且只包含字符 `'N'` 和 `'Y'` 的字符串 `customers` 表示：
- 如果第 `i` 个字符是 `'Y'` ，它表示第 `i` 小时有顾客到达。
- 如果第 `i` 个字符是 `'N'` ，它表示第 `i` 小时没有顾客到达。

如果商店在第 `j` 小时关门（`0 <= j <= n`），代价按如下方式计算：
- 在开门期间，如果某一个小时没有顾客到达，代价增加 `1` 。
- 在关门期间，如果某一个小时有顾客到达，代价增加 `1` 。

请你返回在确保代价 **最小** 的前提下，商店的 **最早** 关门时间。

注意，商店在第 `j` 小时关门表示在第 `j` 小时以及之后商店处于关门状态。

**示例 1：**
```js
输入：customers = "YYNY"
输出：2
解释：
- 第 0 小时关门，总共 1+1+0+1 = 3 代价。
- 第 1 小时关门，总共 0+1+0+1 = 2 代价。
- 第 2 小时关门，总共 0+0+0+1 = 1 代价。
- 第 3 小时关门，总共 0+0+1+1 = 2 代价。
- 第 4 小时关门，总共 0+0+1+0 = 1 代价。
在第 2 或第 4 小时关门代价都最小。由于第 2 小时更早，所以最优关门时间是 2 。
```
**示例 2：**
```js
输入：customers = "NNNNN"
输出：0
解释：最优关门时间是 0 ，因为自始至终没有顾客到达。
```
**示例 3：**
```js
输入：customers = "YYYY"
输出：4
解释：最优关门时间是 4 ，因为每一小时均有顾客到达。
```
**提示：**
- `1 <= customers.length <= 10^5`
- `customers` 只包含字符 `'Y'` 和 `'N'` 。

---
### 解法 字符串+前后缀分解
枚举所有 $[0,n]$ 内的关门时间，我们需要知道下标 $i$ 前面的 $N$ 的个数以及 $i$ 及其后面的 $Y$ 的个数。

我们可以先统计出 $customers$ 中 $Y$ 的个数，即 $i=0$ 的代价。然后枚举 $[1,n]$ 内的 $i$ ，如果 $customers[j−1]$ 是 $N$ ，则代价加一，否则代价减一。

中途的代价的最小值对应的 $i$ 即为答案。
```cpp
class Solution {
public:
    int bestClosingTime(string customers) {
        int n = customers.size(), cost = 0;
        for (int i = 0; i < n; ++i) cost += (customers[i] == 'Y');
        int minCost = cost, minIdx = 0;
        for (int i = 1; i <= n; ++i) { // 在i=0处关门的代价
            if (customers[i - 1] == 'N') ++cost;
            else {
                --cost;
                if (cost < minCost) {
                    minCost = cost;
                    minIdx = i;
                }
            }
        }
        return minIdx;
    }
};
```
复杂度分析：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$