> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。
<p>You are given two strings <code>s</code> and <code>t</code>.</p>

<p>String <code>t</code> is generated by random shuffling string <code>s</code> and then add one more letter at a random position.</p>

<p>Return the letter that was added to <code>t</code>.</p>

 
<p><strong>Example 1:</strong></p>

```cpp
Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added. 
```

<p><strong>Example 2:</strong></p>

```cpp
Input: s = "", t = "y"
Output: "y"
```

 
<p><strong>Example 3:</strong></p>

```cpp
Input: s = "a", t = "aa"
Output: "a"
```

 
<p><strong>Example 4:</strong></p>

```cpp
Input: s = "ae", t = "aea"
Output: "a"
```

<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= s.length &lt;= 1000</code></li>
	<li><code>t.length == s.length + 1</code></li>
	<li><code>s</code> and <code>t</code> consist of lower-case English letters.</li>
</ul>

题意：`t` 字符串是 `s` 中的字符打乱后，再加一个额外的字符形成的。请找出在 `t` 中被添加的字母。

 
---
本题是[136. Single Number](https://leetcode-cn.com/problems/single-number/)的字符串版本，因此沿用[136. Single Number【哈希表/位运算/数学】简单](https://memcpy0.blog.csdn.net/article/details/106988806)的做法即是正解。
### 解法1 哈希表
先计算字符串 `s` 中各个小写字母的频数，并存储到 `cnt[]` 中。然后遍历字符串 `t` ，每遇到一个字母就减去该字母的频数一次，直到使得某个字母的频数为负数，则返回该字母作为答案。算法的时间复杂度为 $O(n + m)$ ，空间复杂度为 $O(26)$ 。
```cpp
//C++ version
class Solution {
public:
    char findTheDifference(string s, string t) {
        if (s.empty()) return t[0];
        int charset[26] = {0};
        for (const char &c : s) ++charset[c - 'a'];
        for (const char &c : t) {
            --charset[c - 'a'];
            if (charset[c - 'a'] < 0) return c;
        }
        return ' ';
    }
};
//执行用时：0 ms, 在所有 C++ 提交中击败了100.00% 的用户
//内存消耗：6.6 MB, 在所有 C++ 提交中击败了20.77% 的用户
```
---
### 解法2 位运算（最优）
和 `136. Single Number` 一样的思路和做法。具体代码如下：
```cpp
//C++ version
class Solution {
public:
    char findTheDifference(string s, string t) {
        char c = 0;
        for (const char &ch : s) c ^= ch;
        for (const char &ch : t) c ^= ch;
        return c;
    }
};
//执行用时：0 ms, 在所有 C++ 提交中击败了100.00% 的用户
//内存消耗：6.5 MB, 在所有 C++ 提交中击败了58.67% 的用户
```
