> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。

给你一个字符串 `text`，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。

**示例 1：**
```java
输入：text = "ababa"
输出：3
```
**示例 2：**
```java
输入：text = "aaabaaa"
输出：6
```
**示例 3：**
```java
输入：text = "aaabbaaa"
输出：4
```
**示例 4：**
```java
输入：text = "aaaaa"
输出：5
```
**示例 5：**
```java
输入：text = "abcdef"
输出：1
```
**提示：**
-   `1 <= text.length <= 20000`
-   `text` 仅由小写英文字母组成。

---
### 解法1 哈希表+模拟
这道题的题意很明确——给定一个字符串，要选择两个字符进行交换，这个操作最多进行一次，要求使得仅包含相同字符的子串尽可能的长。例如 $bbababaaaa$ ，可以交换第 $2$（下标从 $0$ 开始） 个字符 $a$ 与第 $5$ 个字符 $b$ ，使包含相同字符的子串最长为 $6$ ，即 $aaaaaa$ 。

我们可以进行模拟。很显然，**需要先用哈希表 $rec$ 统计每种字母的个数**。然后，为了方便处理，**我们分段统计连续字母的长度**，即将字符串变为(字母，连续出现次数)的形式，如 $aabba$ 变为 $a2b2a1$ ，并记录到 $nums$ 数组中，方便后续分类讨论：
1. 两个由同样字母（设为 $\alpha$ ）组成的子串，只隔了一个不同的字母（设为 $\mu$ ）。设后一个字母 $\alpha$ 的连续长度记录在 $nums[idx]$ 中：
    1. 如果这两个子串的总长度 $nums[idx - 2] + nums[idx]$ 小于字母 $\alpha$ 的出现次数 $rec[\alpha]$ ，则**我们可以从其他地方借过来一个 $\alpha$ ，替换掉中间的 $\mu$ ，形成一个「连续的仅包含 $\alpha$ 的子串」**，长度为 $nums[idx - 2] + nums[idx] + 1$ 。
    2. 如果这两个子串的总长度就是字母 $\alpha$ 的出现次数 $rec[\alpha]$ ，那么我们无法从其他地方借过来一个 $\alpha$ ，**要使「连续的仅包含 $\alpha$ 的子串」更长，我们可以用「左边子串的最左字母」替换中间的 $\mu$** ，长度为 $nums[idx - 2] + nums[idx] = rec[\alpha]$ 。
    3. 总的来说，得到的「尽量长的、连续的、仅包含 $\alpha$ 字母的子串」长度为 $\min(nums[idx - 2] + nums[idx] + 1,\ rec[\alpha])$ 。
2. 否则，就说明**当前字母 $\alpha$ 子串和其他 $\alpha$ 子串间隔着多个字母，或不存在其他 $\alpha$ 子串**：
    1. 如果该子串的长度小于字母 $\alpha$ 的出现次数，则**同样可以借来一个 $\alpha$ ，替换前面或后面的不同字母**，形成一个「连续的仅包含相同字母的子串」**，长度为 $nums[idx] + 1$ 。
    2. 如果该子串的长度等于字母 $\alpha$ 的出现次数，则不可以借来一个 $\alpha$ ，得到的「连续的仅包含 $\alpha$ 的子串」**，长度为 $nums[idx]  = rec[\alpha]$ 。
    3. 总的来说，得到的「尽量长的、连续的、仅包含 $\alpha$ 字母的子串」长度为 $\min( nums[idx] + 1,\ rec[\alpha])$ 。

依照上述说明，编码如下：
```cpp
class Solution {
public:
    int maxRepOpt1(string text) {
        int n = text.size();
        unordered_map<int, int> rec; // 记录每个字母出现的总次数,判断是否可以借一个字母进行替换
        for (char c : text) ++rec[c];
        int nums[n], idx = -1; // 将原来的字符串压缩为(a,1),(b,3)这种形式
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int j = i;
            while (j < n && text[j] == text[i]) ++j;
            nums[++idx] = j - i; // 记录该字母连续出现的次数
            // 两个相邻的同样字母的串只隔了一个不同的字母,小于该字母的总数时,长度为合并+1
            if (idx > 1 && nums[idx - 1] == 1 && i > 1 && text[i - 2] == text[i])
                ans = max(ans, min(nums[idx] + nums[idx - 2] + 1, rec[text[i]]));
            else ans = max(ans, min(nums[idx] + 1, rec[text[i]]));
            i = j - 1;
            // 其他情况，小于总数时，+1;
        }  
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

---
### 解法2 哈希表+滑动窗口+双指针
在解法1的基础上进行优化。还是先用哈希表或数组 $cnt$ 统计字符串 $text$ 中每个字符出现的次数，但之后不用 $nums$ 数组进行分段计数了，改为使用**滑动窗口算法**来求解由相同字符构成的最长区间。

我们先定义一个指针 $i$ ，初始时 $i = 0$ 。每一次，我们将指针 $j$ 指向 $i$ ，并不断地向右移动 $j$ ，**直到 $j$ 指向的字符与 $i$ 指向的字符不同**，此时我们得到了一个长度为 $l=j−i$ 的子串 $text[i..j−1]$ ，其中所有字符都相同。

然后我们跳过指针 $j$ 指向的字符，用指针 $k$ 继续向右移动，直到 $k$ 指向的字符与 $i$ 指向的字符不同，此时我们得到了一个长度为 $r = k - j - 1$ 的子串 $text[j+1..k-1]$ ，其中所有字符都相同。那么**最多通过一次交换操作，可得的最长单字符重复子串的长度为 $\min(l + r + 1, cnt[text[i]])$**（==将上面讨论的两种大情况合而为一==）。接下来，我们将指针 $i$ 移动到 $j$ ，继续寻找下一个子串。取所有满足条件的子串的最大长度即可。
```cpp
class Solution {
public:
    int maxRepOpt1(string text) {
        int cnt[26] = {0};
        for (char &c : text) ++cnt[c - 'a'];
        int n = text.size();
        int ans = 0, i = 0;
        while (i < n) {
            int j = i;
            while (j < n && text[j] == text[i]) ++j;
            int l = j - i; // 左边子串长度
            int k = j + 1;
            while (k < n && text[k] == text[i]) ++k;
            int r = k - j - 1; // 右边子串长度
            ans = max(ans, min(l + r + 1, cnt[text[i] - 'a']));
            i = j;
        }
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(n)$ 
- 空间复杂度：$O(C)$ 。其中 $n$ 为字符串的长度；而 $C$ 为字符集的大小，本题中 $C = 26$ 。