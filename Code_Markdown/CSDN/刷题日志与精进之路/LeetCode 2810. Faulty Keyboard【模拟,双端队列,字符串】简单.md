> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

你的笔记本键盘存在故障，每当你在上面输入字符 `'i'` 时，它会反转你所写的字符串。而输入其他字符则可以正常工作。

给你一个下标从 **0** 开始的字符串 `s` ，请你用故障键盘依次输入每个字符。

返回最终笔记本屏幕上输出的字符串。

**示例 1：**
```java
输入：s = "string"
输出："rtsng"
解释：
输入第 1 个字符后，屏幕上的文本是："s" 。
输入第 2 个字符后，屏幕上的文本是："st" 。
输入第 3 个字符后，屏幕上的文本是："str" 。
因为第 4 个字符是 'i' ，屏幕上的文本被反转，变成 "rts" 。
输入第 5 个字符后，屏幕上的文本是："rtsn" 。
输入第 6 个字符后，屏幕上的文本是： "rtsng" 。
因此，返回 "rtsng" 。
```
**示例 2：**
```java
输入：s = "poiinter"
输出："ponter"
解释：
输入第 1 个字符后，屏幕上的文本是："p" 。
输入第 2 个字符后，屏幕上的文本是："po" 。
因为第 3 个字符是 'i' ，屏幕上的文本被反转，变成 "op" 。
因为第 4 个字符是 'i' ，屏幕上的文本被反转，变成 "po" 。
输入第 5 个字符后，屏幕上的文本是："pon" 。
输入第 6 个字符后，屏幕上的文本是："pont" 。
输入第 7 个字符后，屏幕上的文本是："ponte" 。
输入第 8 个字符后，屏幕上的文本是："ponter" 。
因此，返回 "ponter" 。
```
**提示：**
- `1 <= s.length <= 100`
- `s` 由小写英文字母组成
- `s[0] != 'i'`

---
### 解法 模拟+双端队列
本题可以每次遇到 `i` 就反转前面的所有字符，但假如后一半的字符全部是 `i` ，遍历到后一半时，每次都要将前一半的字符反转一遍，这样的代价是 $O(n^2)$ 的。

我们可以把第一次遇到 `i` 反转，看作是**往字符串的头部依次添加后续字符，最后从字符串尾部往前读取全部字符**，==这样前面遍历过的字符就反转了，后续添加的字符的顺序不变==。如果再遇到 `i` ，就将后续字符添加到字符串的尾部，最后从字符串头部往后读取全部字符……如此反复反转，直到处理完全部字符。**根据最后一次遇到 `i` 决定的方向，读取全部字符**。

这可以用双端队列实现。
```cpp
class Solution {
public:
    string finalString(string s) {
        deque<char> dq;
        bool last = true;
        for (char c : s) {
            if (c == 'i') last = !last;
            else if (last) dq.push_back(c);
            else dq.push_front(c);
        }
        return last ? string(dq.begin(), dq.end()) : string(dq.rbegin(), dq.rend());
    }
};
```