> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202310131529748.png)
给你一个下标从 **0** 开始的整数数组 `nums` 。

现定义两个数字的 **串联** 是由这两个数值串联起来形成的新数字。
- 例如，`15` 和 `49` 的串联是 `1549` 。

`nums` 的 **串联值** 最初等于 `0` 。执行下述操作直到 `nums` 变为空：
- 如果 `nums` 中存在不止一个数字，分别选中 `nums` 中的第一个元素和最后一个元素，将二者串联得到的值加到 `nums` 的 **串联值** 上，然后从 `nums` 中删除第一个和最后一个元素。
- 如果仅存在一个元素，则将该元素的值加到 `nums` 的串联值上，然后删除这个元素。

返回执行完所有操作后 `nums` 的串联值。

**示例 1：**
```js
输入：nums = [7,52,2,4]
输出：596
解释：在执行任一步操作前，nums 为 [7,52,2,4] ，串联值为 0 。
 - 在第一步操作中：
我们选中第一个元素 7 和最后一个元素 4 。
二者的串联是 74 ，将其加到串联值上，所以串联值等于 74 。
接着我们从 nums 中移除这两个元素，所以 nums 变为 [52,2] 。
 - 在第二步操作中： 
我们选中第一个元素 52 和最后一个元素 2 。 
二者的串联是 522 ，将其加到串联值上，所以串联值等于 596 。
接着我们从 nums 中移除这两个元素，所以 nums 变为空。
由于串联值等于 596 ，所以答案就是 596 。
```
**示例 2：**
```js
输入：nums = [5,14,13,8,12]
输出：673
解释：在执行任一步操作前，nums 为 [5,14,13,8,12] ，串联值为 0 。 
- 在第一步操作中： 
我们选中第一个元素 5 和最后一个元素 12 。 
二者的串联是 512 ，将其加到串联值上，所以串联值等于 512 。 
接着我们从 nums 中移除这两个元素，所以 nums 变为 [14,13,8] 。
- 在第二步操作中：
我们选中第一个元素 14 和最后一个元素 8 。
二者的串联是 148 ，将其加到串联值上，所以串联值等于 660 。
接着我们从 nums 中移除这两个元素，所以 nums 变为 [13] 。 
- 在第三步操作中：
nums 只有一个元素，所以我们选中 13 并将其加到串联值上，所以串联值等于 673 。
接着我们从 nums 中移除这个元素，所以 nums 变为空。 
由于串联值等于 673 ，所以答案就是 673 。
```
**提示：**
- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= 10^4`

---
### 解法 相向双指针
使用了库函数 `to_string` 的情况如下，注意最后只剩一个元素的情况。
```cpp
class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int n = nums.size();
        long long ans = 0;
        for (int i = 0, j = n - 1; i < j; ++i, --j) {
            ans += (long long) stoll(to_string(nums[i]) + to_string(nums[j]));
        }
        if (n & 1) ans += (long long) nums[n / 2];
        return ans;
    }
};
```
如果不使用库函数，我们可以得到一个 $O(1)$ 空间的写法。由于每次操作都是取出 $nums$ 的第一个元素和最后一个元素串联，所以相向双指针模拟即可。例如 $x=15,y = 49$ 串联，结果等于 $x\cdot {10^2} + y=1549$ 。我们可以把 $y$ 不断除 $10$ ，来知道 $x$ 要乘上 $10$ 的多少次方。
```cpp
class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int n = nums.size();
        long long ans = 0;
        for (int i = 0, j = n - 1; i < j; ++i, --j) {
            int x = nums[i], y = nums[j];
            while (y) {
                x *= 10; 
                y /= 10;
            }
            ans += x + nums[j];
        }
        if (n & 1) ans += (long long) nums[n / 2];
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(n\log U)$ ，$U$ 为最大的数字的位数。
- 空间复杂度：$O(1)$