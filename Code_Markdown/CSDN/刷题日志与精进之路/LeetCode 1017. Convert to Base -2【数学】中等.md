> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个整数 `n` ，以二进制字符串的形式返回该整数的 **负二进制（`base -2`）**表示。

**注意**，除非字符串就是 `"0"`，否则返回的字符串中不能含有前导零。

<strong>示例 1：</strong>
<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>"110"
<strong>解释：</strong>(-2)<sup>2</sup> + (-2)<sup>1</sup> = 2
</pre>

<strong>示例 2：</strong>
<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>"111"
<strong>解释：</strong>(-2)<sup>2</sup> + (-2)<sup>1</sup> + (-2)<sup>0</sup> = 3
</pre>

<strong>示例 3：</strong>
<pre><strong>输入：</strong>n = 4
<strong>输出：</strong>"100"
<strong>解释：</strong>(-2)<sup>2</sup> = 4
</pre>
 
**提示：**
-   `0 <= n <= 10^9`

---
### 解法1 模拟
一般来说，我们可以把非零整数 $n$ 表示为 $2$ 的幂数和，即$$n = \sum^m_{i=0} C_i \times 2^i\quad (C_i = 0, 1)$$
而==对于「二进制数」，我们可以直观得到以下结论==：
- 对于 $2^i$ ，如果 $i$ 为偶数，此时 $2^i = (-2)^i$ 
- 对于 $2^i$ ，如果 $i$ 为奇数，此时 $2^i = (-2)^{i+1} + (-2)^i$ ，例如 $2^3 = (-2)^4 + (-2)^3$ 

就像我们不断累加 $2$ 的幂、得到和为 $n$ 一样，**运用这两个结论，我们就可以把作为 $2$ 的幂次和的 $n$ 、转为 $-2$ 的幂次和**，令 $$n = \sum^k_{i=0} C_i \times (-2)^i\quad (C_i = 0, 1)$$
做法是，对于 $n$ 二进制表示中第 $i$ 位的系数 $C_i$ ，如果 $C_i$ 不为零：
- **如果 $i$ 为偶数，则负二进制表示中「第 $i$ 位表示的值」为正数**，而我们要想累加 $2^i$ ，就要累加 $(-2)^i$ ，此时负二进制第 $i$ 位 $C_i$ 加 $1$ 。
- **如果 $i$ 为奇数，则负二进制表示中「第 $i$ 位表示的值」为负数**，而我们要想累加 $2^i$ ，就要累加 $2^i = (-2)^{i+1} + (-2)^i$ ，此时负二进制第 $i+1$ 位的系数 $C_{i+1}$ 加 $1$ ，$C_{i}$ 也加上 $1$ 。

执行上述步骤后，作为 $2$ 的幂次和的 $n$ ，就转为了 $-2$ 的幂次和。但无论是 $2$ 进制还是 $-2$ 进制，这里进制的每一位都只能为 $0$ 或 $1$（即 $C_i$ 的值）。因此我们要处理转换后的 $C_i$ 系数数组。

即需要**对 $-2$ 的幂的系数数组进行「带进位的加法」运算，进位是进在 $C_i$ 上的**。最后，只要**将 $-2$ 的幂的系数 $C_i$ 组合起来**，就是完整的「负二进制数」。

下面我们就处理进位。仔细思考一下进位规则，对于 $C \times (-2)^i$ ，有如下变换规则。
- **如果 $C$ 为奇数，则需要将等式变换为 $C \times (-2)^i = a \times (-2)^{i+1} + (-2)^i$** ，此时第 $i$ 位为 $1$ ，第 $i + 1$ 位需要加上 $a$ ；
- **如果 $C$ 为偶数，则需要将等式变换为 $C \times (-2)^i = a \times (-2)^{i+1}$** ，此时第 $i$ 位为 $0$ ，第 $i + 1$ 位需要加上 $a$

根据上面的变换规则，求出 $a$ 即可。假设当前数位上的数为 $v$ ，当前位上保留的余数为 $r$ ，在 $x$ 进制下的进位为 $a$ 。根据进位的运算规则，可知 $v = a \times x + r$ ，此时可得进位 $a = \dfrac{v - r}{x}$ 。
- 根据题意可知，「负二进制」数的每一位上保留的余数为 $0$ 或 $1$ ，因此可以计算出当前的余数 $r$ ——由于有符号整数均采用补码表示，最低位的奇偶性保持不变，因此可以直接取 $v$ 的最低位即可，由此可得到 $r = v \& 1$ 。
- 根据上述等式可知，当前数位上的数字为 $v$ 时，此时在「负二进制」下向高位的进位为 $a =\dfrac{v - (v \& 1)}{-2}$ 。
> 不直接 $r = v \%(-2)$ 的原因是，$v$ 除以 $-2$ 后可能为负数，再对 $-2$ 取余，余数将是负数！
> 正数 % 正数，结果为正数；负数 % 负数，结果为负数。正数 % 负数，结果为正数，**负数 % 正数，结果为负数**。如
> ```java
> 3 / -2 = -1...1
> -3 / 2 = -1...-1
> ```

基于以上进位规则，将变换出来的系数数组进行进位运算，即可得到完整的「负二进制」数。

整个算法过程如下：
1. 将 $n$ 转换为二进制数，并将二进制数中的每一位转换为「负二进制」中的每一位，变换后的数列为 $bits$ ；
2. 将 $bits$ 从低位向高位进行「进位」运算，即将 $bits$ 中的每一位都变为 $0$ 或者 $1$ ；
3. 去掉前导 $0$ 以后，将 $bits$ 转换为字符串返回即可。

```cpp
class Solution {
public:
    string baseNeg2(int n) {
        if (n == 0) return "0";
        int i = 0, bits[32]{0};
        for (int i = 0; i < 32 && n != 0; ++i) {
            if (n & 1) { // n二进制表示中这一位为1
                ++bits[i];
                if (i & 1) ++bits[i + 1]; // 进位在后面处理
            }
            n >>= 1;
        } 
        int carry = 0;
        for (int i = 0; i < 32; ++i) {
            int v = carry + bits[i];
            bits[i] = v & 1;
            carry = (v - bits[i]) / (-2);
        }
        int pos = 31;
        while (pos >= 0 && bits[pos] == 0) --pos;
        string ans;
        while (pos >= 0) ans.push_back(bits[pos--] + '0');
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(C)$ ，其中 $C = 32$
- 空间复杂度：$O(C)$ ，其中 $C = 32$

上述写法虽然过程清晰明了，但未免显得有点繁琐，能不能直接将「 $n$ 二进制表示的系数数列」转换为「负二进制表示的**合法**系数数列」，而跳过明确的 $C_i$ 进位运算？做法是有的。

对于 $n$ 二进制表示中第 $i$ 位的系数 $C_i$ ，
- 如果 $C_i$ 为零，则负二进制表示中也为零，不会影响到第 $i$ 位和第 $i+1$ 位。
- 如果 $C_i$ 不为零：
	- **如果 $i$ 为偶数，则负二进制表示中「第 $i$ 位表示的值」为正数**，而我们要想累加 $2^i$ ，就要累加 $(-2)^i$ ，此时负二进制第 $i$ 位 $C_i$ 加 $1$ 。 
	 在之前的做法中，$C_i$ 可能在上一步就被加上 $1$ ，这里加 $1$ 会超过范围。但此处只会**设置**为 $1$ ，不会越界，具体见下。
	- **如果 $i$ 为奇数，则负二进制表示中「第 $i$ 位表示的值」为负数**，而我们要想累加 $2^i$ ，就要累加 $2^i = (-2)^{i+1} + (-2)^i$ 。
	 之前的做法是将负二进制第 $i+1$ 位的系数 $C_{i+1}$ 加 $1$ ，$C_{i}$ 也加上 $1$ 。这可能导致当前的 $C_i$ 超过范围、可能导致下一步的 $C_{i+1}$ 也超过范围。
	 而我们这里的做法是，==凡是遇到奇数次二进制位为 $1$ 时，只在当前位 $C_i$ **设置** $1$ ，同时在原数加上 $(1 << (i +1))$ ！==
- 之后右移，去掉当前数位，保证数字大小平衡。继续按照二进制处理。 

代码如下：
```cpp
class Solution {
public:
    string baseNeg2(int n) {
        if (n == 0 || n == 1) return to_string(n);
        string ans;
        for (int i = 0; n; ++i) {
            // int r = abs(n % (-2));
            int r = n & 1; // r只能为0或1
            ans.push_back('0' + r);
            if (i & 1) n += (n & 1) << 1; // 原数加上1<<(i+1)
            n >>= 1; // 继续右移,查看n的二进制表示
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

---
### 解法2 进制转换
当基数 $x>1$ 时，将整数 $n$ 转换成 $x$ 进制的原理是：令 $n_0 = n$ ，计算过程如下:
- 当计算第 $0$ 位上的数字时，此时 $n_1 = \Big\lfloor \dfrac{n_0}{x} \Big\rfloor$  ，$n_0 = n_1 \times x + r$​ ，其中 $0 \le r < x$ ；
- 当计算第 $i$ 位上的数字时，此时 $n_{i + 1} = \Big\lfloor \dfrac{n_i}{x} \Big\rfloor$  ，$n_i = n_{i+1} \times x + r$  ，其中 $0 \le r < x$ ；
- 按照上述计算方式进行计算，直到满足 $n_{i} = 0$ 结束。
- 总体来说就是，==**除基取余，倒序排列**==。

**如果基数 $x$ 为负数，只要能确定余数的可能取值，上述做法同样适用**。根据上面各数间取余的结果，负二进制数 `% -2` 的值可能有 $0, 1, -1$ ，由于「负二进制」表示中的每一位都是 $0$ 或 $1$ ，因此在余数为 $-1$ 时（比如 $n_i$ 为负数时）要转换为 $1$ ，再使用上述做法将整数 $n$ 转换成「负二进制」。

具体转换过程如下：
- 如果 $n=0$ 则返回 `"0"` ，$n=1$ 则直接返回 `"1"` ；
- 如果 $n>1$ ，则使用一个字符串记录余数，将整数 $n$ 转换成「负二进制」，重复执行如下操作，直到 $n=0$ ；
	1. 计算当前 $n$ 的余数，由于当前的余数只能为 $0$ 或 $1$ ，由于有符号整数均采用补码表示，最低位的奇偶性保持不变，因此**直接取 $C$ 的最低位即可**，此时直接用 $n \And 1$ 即可得到最低位的余数，将余数拼接到字符串的末尾。
	2. **将 $n$ 的值减去余数，然后将 $n$ 的值除以 $-2$** 。

上述操作结束之后，将字符串翻转之后得到「负二进制」数。
```cpp
class Solution {
public:
    string baseNeg2(int n) {
        if (n == 0 || n == 1) return to_string(n);
        string ans;
        while (n) {
            // int r = abs(n % (-2));
            int r = n & 1; // r只能为0或1
            ans.push_back('0' + r);
            n = (n - r) / (-2);
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(\log n)$ ，$n$ 是给定的整数，整数 $n$ 对应的「负二进制」表示的长度为 $\log n$ 
- 空间复杂度：$O(1)$ ，除返回值外，不需要额外的空间。

---
### 解法3 数学计算
根据题意可知，$32$ 位「负二进制」数中第 $i$ 位表示 $(-2)^i$ ，当 $i$ 为偶数时，则 $(-2)^i=2^i$ ，当 $i$ 为奇数时，则 $(-2)^i = -2^i$ ，因此可以得到最大值和最小值分别如下：
- 最大值即所有偶数位都为 $1$ ，奇数位都为 $0$ ，最大值即 $0x5555 5555 = 1,431,655,765$ 。
- 最小值即所有偶数位都为 $0$ ，奇数位都为 $1$ ，最小值即 $0xAAAAAAAA=−2,863,311,530$ 

令 $\textit{maxVal} = \text{0x55555555}$ ，由于题目中 $n$ 给定的范围为 $0 \le n \le 10^9$ ，因此一定满足 $maxVal>n$ 。设 $maxVal$ 与 $n$ 的差为 $diff$ ，则此时 $\textit{diff} = \textit{maxVal} - n$ 。

如果我们将 $\textit{maxVal}$ 在「负二进制」表示下减去 $\textit{diff}$ ，那么得到的「负二进制」一定为 $n$ 的「负二进制」。**已知 $\textit{maxVal}$ 中的偶数位全为 $1$ ，奇数位全为 $0$ ，此时的减法操作可以用异或来实现**：
- **对于 $\textit{diff}$ 中偶数位为 $1$ 的位，在 $\textit{maxVal}$ 中需要将其置为 $0$** ，此时 $\textit{maxVal}$ 中偶数位全部为 $1$ ，$1 \oplus 1 = 0$ ，偶数位异或操作即可将需要的位置为 $0$ ；
- **对于 $\textit{diff}$ 中奇数位为 $1$ 的位，在 $maxVal$ 中需要将其置为 $1$** ，此时 $maxVal$ 中奇数位全部为 $0$ ，$0 \oplus 1 = 1$ ，奇数位异或操作将需要的位置为 $1$ 

根据以上推论可以知道，「负二进制」减法等同于 $maxVal⊕diff$ 。**按照上述方法可以知道 $n$ 的「负二进制」数等于 $\textit{maxVal} \oplus (\textit{maxVal} - n)$** ，我们求出 $n$ 的「负二进制」数，然后将其转换为二进制的字符串即可。
```cpp
class Solution {
public:
    string baseNeg2(int n) {
        int val = 0x55555555 ^ (0x55555555 - n);
        if (val == 0) return "0";
        string ans;
        while (val) {
            ans.push_back('0' + (val & 1));
            val >>= 1;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```
 