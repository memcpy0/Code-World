> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给定一个二进制字符串 `s` 和一个正整数 `n`，如果对于 `[1, n]` 范围内的每个整数，_其二进制表示都是 `s` 的 **子字符串** ，就返回 `true`，否则返回 `false`_ 。

**子字符串** 是字符串中连续的字符序列。

**示例 1：**
```java
输入：s = "0110", n = 3
输出：true
```
**示例 2：**
```java
输入：s = "0110", n = 4
输出：false
```
**提示：**
-   `1 <= s.length <= 1000`
-   `s[i]` 不是 `'0'` 就是 `'1'`
-   `1 <= n <= 10^9`

---
### 解法1 枚举数字+判断
从小到大枚举 $[1,n]$ 内的数，转成二进制字符串，判断是否都在 $s$ 中。一旦枚举到不在 $s$ 中的数，就立刻返回 `false` 。如果都在 $s$ 中就返回 `true` 。
> 疑问：**$n$ 不是高达 $10^9$ 吗？为什么这样做不会超时？**
```java
class Solution {
    public boolean queryString(String s, int n) {
        for (int i = 1; i <= n; ++i)
            if (!s.contains(Integer.toBinaryString(i)))
                return false; 
        return true;
    }
}
```
复杂度分析：
- 时间复杂度：$\mathcal{O}(\min(m,n)\cdot m\log \min(m,n))$ ，其中 $m$ 为 $s$ 的长度。**由下面的「精确分析」可知，至多循环 $\mathcal{O}(\min(m,n))$ 次**（即 $i$ 不超过这一数值），所以**二进制字符串的长度为 $\mathcal{O}(\log\min(m,n))$** ，每次在 $s$ 中查找需要 $\mathcal{O}(m\log \min(m,n))$ 的时间。
- 空间复杂度：$\mathcal{O}(\log n)$ 。把数字转成二进制数需要 $\mathcal{O}(\log n)$ 的空间。

---
### 解法2 反向枚举 $s$ 子串+哈希集合
反过来想，把 $s$ 的子串都转成二进制数，如果数字在 $[1,n]$ 内，就保存到一个哈希集合中。如果哈希集合的大小最终为 $n$ ，就说明 $[1,n]$ 的二进制都在 $s$ 里面。

代码实现时，设当前枚举的子串对应的下标区间为 $[i,j]$ ，手动把这段子串转成二进制数：
- 设当前得到的二进制数为 $x$ ，且下一个字符 $s[j+1]$ 为 $c$ ，那么将 $x$ 更新为 `(x << 1) | (c - '0')` ，从而 $O(1)$ 计算出子串 $[i,j+1]$ 对应的的二进制数。
- 此外，**可以跳过 $s[i]=0$ 的情况**，且 $n \ge 1$ 。例如 $s=\text{0110}$ ，从 $s[0]$ 开始和从 $s[1]$ 开始，得到的二进制数都是一样的。
- 并且，由于保证从 $s[i]=1$ 开始枚举，二进制数的大小会指数增长，**一旦 $x>n$ ，就停止枚举 $j$** 。所以对于固定的 $i$ ，至多枚举 $O(\log n)$ 个 $j$ 。

```java
class Solution {
    public boolean queryString(String S, int n) {
        var seen = new HashSet<Integer>();
        var s = S.toCharArray();
        for (int i = 0, m = s.length; i < m; ++i) {
            int x = s[i] - '0';
            if (x == 0) continue; // 二进制数从1开始
            for (int j = i + 1; x <= n; ++j) {
                seen.add(x);
                if (j == m) break;
                x = (x << 1) | (s[j] - '0'); // 子串[i,j]的二进制数
            }
        }
        return seen.size() == n;
    }
}
```
复杂度分析：
- 时间复杂度：$\mathcal{O}(m\log n)$ ，其中 $m$ 为 $s$ 的长度。对于固定的 $i$ ，内层循环的次数为 $\mathcal{O}(\log n)$ ，所以总的循环次数为 $\mathcal{O}(m\log n)$ 。
- 空间复杂度：$\mathcal{O}(\min(m\log n, n))$ ，即哈希表所需要的空间。

---
### 解法三+分析为什么「算法一」不会超时
举例说明。如果 $n=7$ ，单看闭区间 $[4,7]$ ，有 $4$ 个**互不相同的整数**，它们的二进制长度均为 $3$ 。如果要让字符串 $s$ 包含这 $4$ 个数，**$s$ 中至少要有 $4$ 个长为 $3$ 的互不相同的子串**。考虑到**这些子串可以有重叠部分**，设 $s$ 的长度为 $m$ ，则应满足 $m\ge 3 + (4-1) = 6$ ，否则直接返回 `false` 。（想象一个长为 $3$ 的滑动窗口在 $s$ 中滑动，至少要得到 $4$ 个子串）。
```java
100
101
110
111
s = 1110100
```
随着 $n$ 的变大，$s$ 的长度 $m$ 也应当随之变大。本题 $m$ 至多为 $1000$ ，而 $n$ 却高达 $10^9$  。可以预见，当 $n$ 较大时，长度 $m$ 几乎无法满足题意，可以直接返回 `false` 。但是如何精确地判断呢？

考虑到 $n+1$ 不一定是 $2$ 的幂，分两组讨论。设 $n$ 的二进制长度为 $k+1$ ，那么：
- 区间 $[2^k, n]$ 内的二进制数的长度均为 $k+1$ ，这有 $n-2^k+1$ 个，所以应满足 $m\ge k+1+(n-2^k+1-1) = n-2^k+k+1$ 。
- 区间 $[2^{k-1},2^k-1]$ 内的二进制数的长度均为 $k$ ，这有 $2^{k-1}$ 个，所以应满足 $m\ge k+(2^{k-1}-1) = 2^{k-1}+k-1$ 。
- 注意，当 $n=1$ 时，$k=0$ ，此时区间 $[2^{k-1},2^k-1]$ 不存在。直接特判这种情况，返回 $s$ 是否包含 $1$ 。

更小的区间呢？
- 注意到，**把区间 $[2^{k-1},2^k-1]$ 内的所有数字都右移一位，可以得到更小的区间 $[2^{k-2},2^{k-1}-1]$ 内的所有数字**。**如果 $s$ 包含 $[2^{k-1},2^k-1]$ 内的所有二进制数，那么必然也包含 $[2^{k-2},2^{k-1}-1]$ 内的所有二进制数，对于更小的区间，也同样包含**。
- 进一步地，由于区间 $[2^k,n]$ 内的所有数右移一位可以得到区间 $[2^{k-1},\lfloor n/2\rfloor]$ ，所以对于 $[2^{k-1},2^k-1]$ ，只需从 $\lfloor n/2\rfloor+1$ 开始考虑。
- 所以**只需要考虑 $s$ 是否包含 $[2^{k-1},2^k-1]$ 和 $[2^k, n]$ 内的所有二进制数即可**。或者说是否包含 $[2^k, n]$ 和 $[ \lfloor n / 2 \rfloor + 1, 2^k - 1]$ 。

因此，如果
$$m < \max(n-2^k+k+1,2^{k-1}+k-1)$$
可以直接返回 `false` 。

上式右边约为 $n/2$ 。即 $n > 2m$ 时可直接返回 `false` 。从而解法一的循环次数至多约为 $2m$（对此有疑问的话，可以用反证法证明）。

由于 $m\le 1000$ ，根据上式，如果 $n\ge 2014$ ，可以直接返回 `false` 。但不推荐这样写，**根据 $n$ 和 $m$ 的值来提前判断是否要返回 `false`** ，更准确。

然后，**只需要考虑长为 $k$ 和 $k+1$ 的这两组二进制数在 $s$ 中是否都有**，因此**可以用长为 $k$ 和 $k+1$ 的滑动窗口实现**，从而做到线性时间复杂度。
```java
class Solution {
    public boolean queryString(String s, int n) {
	if (n == 1) return s.contains("1");
	int k = 31 - Integer.numberOfLeadingZeros(n); // n的二进制长度减一
	if (s.length() < Math.max(n - (1 << k) + k + 1, (1 << (k - 1)) + k - 1)) return false;    
	return check(s, k, n / 2 + 1, (1 << k) - 1) && check(s, k + 1, 1 << k, n);
    }
    // 对于长为k的在[lower, upper]的内的二进制数，判断这些数s是否都有
    private boolean check(String s, int k, int lower, int upper) {
	if (lower > upper) return true;
	var seen = new HashSet<Integer>();
	int mask = (1 << (k - 1)) - 1; // k>=1
	int x = Integer.parseInt(s.substring(0, k - 1), 2); // 按二进制获取值
	for (int i = k - 1, m = s.length(); i < m; ++i) {
	    // & mask可以去掉最高比特位，从而实现滑窗的「出」
	    // << 1 || (s.charAt(i) - '0') 即为滑窗的「入」
	    x = ((x & mask) << 1) | (s.charAt(i) - '0');
	    if (lower <= x && x <= upper) seen.add(x);
	}
	return seen.size() == upper - lower + 1;
    }
}
```
复杂度分析：
- 时间复杂度：$O(m)$ ，其中 $m$ 为 $s$ 的长度。滑动窗口的时间复杂度为 $O(m)$ 。
- 空间复杂度：$O(\min(m,n))$ ，即哈希表所需要的空间。


