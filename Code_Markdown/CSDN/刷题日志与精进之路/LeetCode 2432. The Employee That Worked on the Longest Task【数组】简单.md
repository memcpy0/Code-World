> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

共有 `n` 位员工，每位员工都有一个从 `0` 到 `n - 1` 的唯一 id 。

给你一个二维整数数组 `logs` ，其中 `logs[i] = [idi, leaveTimei]` ：

-   `idi` 是处理第 `i` 个任务的员工的 id ，且
-   `leaveTimei` 是员工完成第 `i` 个任务的时刻。所有 `leaveTimei` 的值都是 **唯一** 的。

注意，第 `i` 个任务在第 `(i - 1)` 个任务结束后立即开始，且第 `0` 个任务从时刻 `0` 开始。

返回处理用时最长的那个任务的员工的 id 。如果存在两个或多个员工同时满足，则返回几人中 **最小** 的 id 。

**示例 1：**
```java
输入：n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]
输出：1
解释：
任务 0 于时刻 0 开始，且在时刻 3 结束，共计 3 个单位时间。
任务 1 于时刻 3 开始，且在时刻 5 结束，共计 2 个单位时间。
任务 2 于时刻 5 开始，且在时刻 9 结束，共计 4 个单位时间。
任务 3 于时刻 9 开始，且在时刻 15 结束，共计 6 个单位时间。
时间最长的任务是任务 3 ，而 id 为 1 的员工是处理此任务的员工，所以返回 1 。
```
**示例 2：**
```java
输入：n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]
输出：3
解释：
任务 0 于时刻 0 开始，且在时刻 1 结束，共计 1 个单位时间。
任务 1 于时刻 1 开始，且在时刻 7 结束，共计 6 个单位时间。
任务 2 于时刻 7 开始，且在时刻 12 结束，共计 5 个单位时间。
任务 3 于时刻 12 开始，且在时刻 17 结束，共计 5 个单位时间。
时间最长的任务是任务 1 ，而 id 为 3 的员工是处理此任务的员工，所以返回 3 。
```
**示例 3：**
```java
输入：n = 2, logs = [[0,10],[1,20]]
输出：0
解释：
任务 0 于时刻 0 开始，且在时刻 10 结束，共计 10 个单位时间。
任务 1 于时刻 10 开始，且在时刻 20 结束，共计 10 个单位时间。
时间最长的任务是任务 0 和 1 ，处理这两个任务的员工的 id 分别是 0 和 1 ，所以返回最小的 0 。
```
**提示：**
-   `2 <= n <= 500`
-   `1 <= logs.length <= 500`
-   `logs[i].length == 2`
-   `0 <= idi <= n - 1`
-   `1 <= leaveTimei <= 500`
-   `idi != idi + 1`
-   `leaveTimei` 按严格递增顺序排列

---
### 解法 遍历
第 $0$ 位员工的用时为 $logs[0][1]$ ，第 $i\ (i \gt 0)$ 位员工的用时为 $logs[i][1] - logs[i - 1][1]$ 。计算用时最大的员工编号，有多个用时最大的，取其中编号最小的。
```java
class Solution {
    public int hardestWorker(int n, int[][] logs) {
        int ans = logs[0][0], mt = logs[0][1];
        for (int i = 1; i < logs.length; ++i) {
            int t = logs[i][1] - logs[i - 1][1];
            if (t > mt || t == mt && logs[i][0] < ans) {
                mt = t;
                ans = logs[i][0];
            }
        }
        return ans;
    }
}
```
复杂度分析：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$ 
