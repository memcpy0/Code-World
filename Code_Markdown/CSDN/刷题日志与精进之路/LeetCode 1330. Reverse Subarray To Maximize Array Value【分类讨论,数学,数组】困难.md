> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个整数数组 `nums` 。「数组值」定义为所有满足 `0 <= i < nums.length-1` 的 `|nums[i]-nums[i+1]|` 的和。

你可以选择给定数组的任意子数组，并将该子数组翻转。但你只能执行这个操作 **一次** 。

请你找到可行的最大 **数组值** 。

**示例 1：**
```java
输入：nums = [2,3,1,5,4]
输出：10
解释：通过翻转子数组 [3,1,5] ，数组变成 [2,5,1,3,4] ，数组值为 10 。
```
**示例 2：**
```java
输入：nums = [2,4,9,24,2,1,10]
输出：68
```
**提示：**
-   `1 <= nums.length <= 3*10^4`
-   `-10^5 <= nums[i] <= 10^5`

---
### 解法 数学+分类讨论
初步分析，有以下几个关键点：
- **如果不翻转，或者整个数组翻转，或者翻转的是一个长为 $1$ 的子数组，那么 $nums$ 不变**。此时的数组值记为 $base$ 。
    例如，示例 1 的 $\textit{base}=|2-3|+|3-1|+|1-5|+|5-4|=1+2+4+1=8$ 。
- ==翻转后，子数组的「数组值」不变，但子数组头尾与「它们前后的两个元素」的差值可能发生变化==。

为了计算出最大的「数组值」，考虑翻转后与翻转前的差值 $d$ ，那么答案为 $base+d$ ，所以  $d$ 越大，答案也就越大。

假设从 $\textit{nums}[i]$ 到 $\textit{nums}[j]$ 的这段子数组翻转了，且 $1\le i < j < n-1$（其中 $n$ 为 $\textit{nums}$ 的长度）。设 $a=nums[i−1],\ b=nums[i],\ x=nums[j],\ y=nums[j+1]$ ，$a$ 为前驱，$y$ 为后继。
> 对于 $i = 0$ 或 $j =n -1$ 的翻转，单独用 $O(n)$ 的时间枚举。

翻转前，这四个数对数组值的贡献为：$$| a - b| + |x -y|$$
翻转后，顺序变为 $a,x,b,y$ ，贡献为：
$$|a - x | + |b - y|$$
得到 $$d = |a-x|+|b-y| - |a-b| - |x-y| \tag{1}$$
从而将问题转换为求 $d$ 的最大值。
> 示例1中翻转的子数组对应的 $a=2,b=3,x=5,y=4$ ，代入上式得 $d=2$ ，数组值为 $base+d=8+2=10$ 。

暴力枚举 $i,j$ 的时间复杂度为 $O(n^2)$ ，如何优化或者说化简 $(1)$ 式（本题核心）？
#### 若干恒等式
对于 $|a - b|$ ：
- 如果 $a\ge b$ ，结果就是 $a - b$ ；
- 如果 $a < b$ ，结果就是 $b - a$ ；
- 总而言之，就是大的减去小的。

所以，$$\begin{align}
|a - b| &= \max(a, b) - \min(a, b) \tag{2} \\ \\
a + b &= \max(a, b) + \min(a, b) \tag{3}
\end{align}$$
$(3) + (2)$ 得：$$a + b + |a - b| = 2\max(a, b) \tag{4}$$
$(3) - (2)$ 得：$$a + b - |a - b| = 2 \min(a, b) \tag{5}$$
恒等式 $(4), (5)$ 是化简 $(1)$ 的关键。

#### 分类讨论四个数大小关系
$a,b,x,y$ 这 $4$ 个数的大小关系一共有 $4!=24$ 种情况，例如 $a\le b\le x\le y,\ b\le x\le a \le y$ 等等。

按照这 $4$ 个数中哪两个数是最小的两个，可以分为 $C(4,2)=6$ 类，每类 $4$ 种情况。

利用**对称性**，只用讨论其中3类，就可得到另外三类的结果。
##### 第1类：$\max(a,b) \le \min(x, y)$
把 $a, b, x, y$ 画在数轴上，相当于 $a, b$ 都在 $x, y$ 的左边（或重合）。那么
$$\begin{align}d &= |a - x | + |b - y| - |a - b| - |x - y| \\
&= (x - a) + (y - b) - |a-b|- |x-y| \\
&= (x+y) - (a + b) - |a-b|-|x-y| \\
&= (x + y - |x-y|) - (a+b+|a-b|) \\
&= 2\min(x, y) - 2\max(a,b)
\end{align}$$
注意：$\max(a, b) \le \min(x, y)$ ，上式 $d \ge 0$ 。

利用对称性，对于 $\max(x, y) \le \min(a, b)$ 的四种情况，可以得到类似的结果：
$$d = 2\min(a, b) - 2\max(x, y) \ge 0$$
现在讨论了八种情况了。

##### 第2类：$\max(a, x) \le \min(b, y)$
把 $a, b, x, y$ 画在数轴上，相当于 $a, x$ 都在 $b, y$ 的左边（或重合）。那么
$$\begin{align}d &= |a - x | + |b - y| - |a - b| - |x - y| \\
&= |a-x| + |b-y| - (b-a) - (y-x) \\
&= |a-x| + |b-y| + (a+x) -(b+y) \\
&= (|a-x|+a+x) - (-|b+y| + b+y)  \\
&= 2\max(a,x) - 2\min(b,y)
\end{align}$$
注意：$\max(a, x) \le \min(b, y)$ ，上式 $d \le 0$ 。

利用对称性，对于 $\max(b, y) \le \min(a, x)$ 的四种情况，可以得到类似的结果：
$$d = 2\max(b, y) - 2\min(a, x) \le 0$$
所以这八种情况不会影响 $d$ 的最大值（注意，可以只翻转长度为 $1$ 的子数组，此时 $d = 0$ ）。现在讨论了 $16$ 种情况了。

##### 第3类：$\max(a, y) \le \min(b, x)$
把 $a, b, x, y$ 画在数轴上，相当于 $a, y$ 都在 $b, x$ 的左边（或重合）。那么
$$\begin{align}d &= |a - x | + |b - y| - |a - b| - |x - y| \\
&= (x - a) + (b - y) - (b - a) - (x - y) \\
&= 0
\end{align}$$
利用对称性，对于 $\max(b, x) \le \min(a, y)$ 的四种情况，可以得到类似的结果：
$$d = 0$$
所以这八种情况也不会影响 $d$ 的最大值。现在讨论完成 $24$ 种情况。

#### 算法实现
由于只有第 $1$ 类的情况会影响 $d$ 的最大值，为了最大化 $d$ ，在遍历 $nums$ 的所有相邻元素 $a, b$ 的同时，**维护 $\min(a, b)$ 的最大值 $mx$ ，以及 $\max(a,b)$ 的最小值 $mn$** 。

遍历结束后，如果 $mx > mn$ ，那么对应的 $a, b, x, y$ 存在，且大小关系必然属于第1类的 $8$ 种情况之一。则有：$$d = 2(mx - mn)$$
如果 $mx = mn$ ，由于 $d$ 初始值为 $0$ ，不会产生影响。

特别地，对于翻转范围在数组边界的情况（$i= 0$ 或 $j = n - 1$ ），单独遍历枚举，并更新 $d$ 的最大值。
> 根据题目的数据范围，运算结果可能超过 `int` ，但返回类型确实 `int` 。

```java
class Solution {
    public int maxValueAfterReverse(int[] nums) {
	int base = 0, d = 0, n = nums.length;
	int mx = Integer.MIN_VALUE, mn = Integer.MAX_VALUE;
	for (int i = 1; i < n; ++i) {
	    int a = nums[i - 1], b = nums[i];
	    int dab = Math.abs(a - b);
	    base += dab;
	    mx = Math.max(mx, Math.min(a, b));
	    mn = Math.min(mn, Math.max(a, b));
	    d = Math.max(d, Math.max(Math.abs(nums[0] - b) - dab, // i = 0
				     Math.abs(nums[n - 1] - a) - dab)); // j = n-1
	}
	return base + Math.max(d, 2 * (mx - mn));
    }
}
```
复杂度分析：
- 时间复杂度：$O(n)$ ，其中 $n$ 为 $nums$ 的长度。
- 空间复杂度：$O(1)$ 。仅用到若干额外变量。



 