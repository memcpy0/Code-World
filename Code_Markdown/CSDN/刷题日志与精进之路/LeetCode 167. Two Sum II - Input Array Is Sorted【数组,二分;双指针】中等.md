> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列**  ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

**示例 1：**
```java
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```
**示例 2：**
```java
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
```
**示例 3：**
```java
输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```
**提示：**
- `2 <= numbers.length <= 3 * 10^4`
- `-1000 <= numbers[i] <= 1000`
- `numbers` 按 **非递减顺序** 排列
- `-1000 <= target <= 1000`
- **仅存在一个有效答案**

---
这道题可以使用「1. 两数之和」的解法，使用 $O(n^2)$ 的时间复杂度和 $O(1)$ 的空间复杂度暴力求解，或借助哈希表使用 $O(n)$ 时间复杂度和 $O(n)$ 的空间复杂度求解。但这两种解法都针对无序数组，没利用到输入数组有序的性质，不然可以得到复杂度更优的解法。

### 解法1 二分查找
在数组中找到两个数，使得它们的和等于目标值，**可先固定第一个数，然后寻找第二个数，第二个数等于目标值减去第一个数的差**。利用数组的有序性质，通过二分查找的方法寻找第二个数。为了避免重复寻找，在寻找第二个数时，只在第一个数的右侧寻找。
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        for (int i = 0, n = nums.size(); i < n; ++i) {
            int l = i + 1, r = n - 1;
            while (l <= r) {
                int m = (r - l) / 2 + l;
                if (nums[m] == target - nums[i]) return {i + 1, m + 1};
                else if (nums[m] > target - nums[i]) r = m - 1;
                else l = m + 1;
            }
        }
        return {-1, -1};
    }
};
```
复杂度分析：
- 时间复杂度：$O(n \log n)$ ，其中 $n$ 是数组的长度。需要遍历数组一次确定第一个数，时间复杂度是 $O(n)$ ，寻找第二个数使用二分查找，时间复杂度是 $O(\log n)$ ，因此总时间复杂度是 $O(n \log n)$ 。
- 空间复杂度：$O(1)$ 。

---
### 解法2 双指针
初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。

使用双指针的实质是缩小查找范围。那会不会把可能的解过滤掉？答案是不会。**假设 $\textit{numbers}[i]+\textit{numbers}[j]=\textit{target}$ 是唯一解**，其中 $0 \leq i<j \leq \textit{numbers}.\textit{length}-1$ 。初始时两个指针分别指向下标 $0$ 和下标 $\textit{numbers}.\textit{length}-1$ ，左指针指向的下标小于或等于 $i$ ，右指针指向的下标大于或等于 $j$ 。**除非初始时左指针和右指针已经位于下标 $i$ 和 $j$ ，否则一定是左指针先到达下标 $i$ 的位置或右指针先到达下标 $j$ 的位置**。
- 如果左指针先到达下标 $i$ 的位置，此时右指针还在下标 $j$ 的右侧，$\textit{sum}>\textit{target}$ ，因此一定是右指针左移，左指针不可能移到 $i$ 的右侧。
- 如果右指针先到达下标 $j$ 的位置，此时左指针还在下标 $i$ 的左侧，$\textit{sum}<\textit{target}$ ，因此一定是左指针右移，右指针不可能移到 $j$ 的左侧。

由此可见，**在整个移动过程中，左指针不可能移到 $i$ 的右侧，右指针不可能移到 $j$ 的左侧，因此不会把可能的解过滤掉**。由于题目确保有唯一的答案，因此使用双指针一定可以找到答案。
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        int n = nums.size(), i = 0, j = n - 1;
        while (i < j) {
            int sum = nums[i] + nums[j];
            if (sum == target) return {i + 1, j + 1};
            else if (sum < target) ++i;
            else --j;
        }
        return {};
    }
};
```
复杂度分析：
- 时间复杂度：$O(n)$ ，其中 $n$ 是数组的长度。两个指针移动的总次数最多为 $n$ 次。
- 空间复杂度：$O(1)$ 。