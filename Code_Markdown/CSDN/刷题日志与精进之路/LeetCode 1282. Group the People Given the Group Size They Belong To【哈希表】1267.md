> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的[仓库](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202309111338490.png)

有 `n` 个人被分成数量未知的组。每个人都被标记为一个从 `0` 到 `n - 1` 的**唯一ID** 。

给定一个整数数组 `groupSizes` ，其中 `groupSizes[i]` 是第 `i` 个人所在的组的大小。例如，如果 `groupSizes[1] = 3` ，则第 `1` 个人必须位于大小为 `3` 的组中。

返回一个组列表，使每个人 `i` 都在一个大小为 _`groupSizes[i]`_ 的组中。

每个人应该 **恰好只** 出现在 **一个组** 中，并且每个人必须在一个组中。如果有多个答案，返回其中 **任何** 一个。可以 **保证** 给定输入 **至少有一个** 有效的解。

**示例 1：**
```js
输入：groupSizes = [3,3,3,3,3,1,3]
输出：[[5],[0,1,2],[3,4,6]]
解释：
第一组是 [5]，大小为 1，groupSizes[5] = 1。
第二组是 [0,1,2]，大小为 3，groupSizes[0] = groupSizes[1] = groupSizes[2] = 3。
第三组是 [3,4,6]，大小为 3，groupSizes[3] = groupSizes[4] = groupSizes[6] = 3。 
其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。
```
**示例 2：**
```js
输入：groupSizes = [2,1,3,3,3,2]
输出：[[1],[0,5],[2,3,4]]
```
**提示：**
- `groupSizes.length == n`
- `1 <= n <= 500`
- `1 <= groupSizes[i] <= n`

---
### 解法 哈希表
由于给定的输入一定存在有效的解，因此对于数组 $groupSizes$ 中的每个元素 $x$ ，当 $x$ 在数组中出现 $y$ 次时，$y$ 一定能被 $x$ 整除，且大小为 $x$ 的组有 $\dfrac{y}{x}$​ 个。

首先将每个人的编号按照组的大小划分，使用哈希表记录每个组的大小对应的所有人的编号。然后遍历哈希表，对于大小为 $x$ 的组，得到对应的所有人编号列表，将列表的大小记为 $y$ ，则 $y$ 一定能被 $x$ 整除，将列表分成 $\dfrac{y}{x}$ 个大小为 $x$ 的组，并将每个组添加到答案中。遍历结束之后，即完成分组。

考虑示例 1 的分组。根据数组 $groupSizes$ 得到每个组的大小对应的所有人的编号：
- 大小为 $1$ 的组对应的编号列表是 $[5]$ ，大小为 $3$ 的组对应的编号列表是 $[0, 1, 2, 3, 4, 6]$ 。将每个组的大小对应的编号列表分成特定大小的列表。
- 大小为 $1$ 的组对应的编号列表的长度是 $1$ ，因此有 $1$ 个大小为 $1$ 的组：$[5]$ 。
- 大小为 $3$ 的组对应的编号列表的长度是 $6$ ，因此有 $2$ 个大小为 $3$ 的组：$[0, 1, 2], [3, 4, 6]$ 。

最终分组情况是 $[[5], [0, 1, 2], [3, 4, 6]]$ 。
```cpp
class Solution {
public:
    vector<vector<int>> groupThePeople(vector<int>& groupSizes) {
        unordered_map<int, vector<int>> rec;
        vector<vector<int>> ans;
        for (int i{}; auto& v : groupSizes) {
            rec[v].push_back(i++);
            if (rec[v].size() == v)
                ans.push_back(exchange(rec[v], {}));
        }
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$