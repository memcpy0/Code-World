> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 。

下标 `i` 处的 **平均差** 指的是 `nums` 中 **前** `i + 1` 个元素平均值和 **后** `n - i - 1` 个元素平均值的 **绝对差** 。两个平均值都需要 **向下取整** 到最近的整数。

请你返回产生 **最小平均差** 的下标。如果有多个下标最小平均差相等，请你返回 **最小** 的一个下标。

**注意：**
- 两个数的 **绝对差** 是两者差的绝对值。
-  `n` 个元素的平均值是 `n` 个元素之 **和** 除以（整数除法） `n` 。
- `0` 个元素的平均值视为 `0` 。

**示例 1：**
```js
输入：nums = [2,5,3,9,5,3]
输出：3
解释：
- 下标 0 处的平均差为：|2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3 。
- 下标 1 处的平均差为：|(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2 。
- 下标 2 处的平均差为：|(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2 。
- 下标 3 处的平均差为：|(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0 。 
- 下标 4 处的平均差为：|(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1 。
- 下标 5 处的平均差为：|(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4 。
下标 3 处的平均差为最小平均差，所以返回 3 。
```
**示例 2：**
```js
输入：nums = [0]
输出：0
解释：
唯一的下标是 0 ，所以我们返回 0 。
下标 0 处的平均差为：|0 / 1 - 0| = |0 - 0| = 0 。
```
**提示：**
- `1 <= nums.length <= 10^5`
- `0 <= nums[i] <= 10^5`

---
### 解法 前后缀分解+O(1)空间
```cpp
class Solution {
public:
    int minimumAverageDifference(vector<int>& nums) {
        typedef long long ll;
        int n = nums.size();
        ll pre = 0, suf = 0;
        for (int v : nums) suf += v;
        int minDiff = INT_MAX, minIdx = -1;
        for (int i = 0; i < n; ++i) {
            pre += nums[i]; // 前缀和
            suf -= nums[i]; // 后缀和
            int d = abs(pre / (i + 1) - (i == n - 1 ? 0 : suf / (n - i - 1)));
            if (d < minDiff) {
                minDiff = d;
                minIdx = i;
            }
        }
        return minIdx;
    }
};
```
复杂度分析：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$