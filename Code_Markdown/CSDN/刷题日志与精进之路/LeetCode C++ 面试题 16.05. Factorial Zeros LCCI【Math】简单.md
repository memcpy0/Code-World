Write an algorithm which computes the number of trailing zeros in `n` factorial.

**Example 1:**

```swift
Input: 3
Output: 0
Explanation: 3! = 6, no trailing zero.
```

**Example 2:**

```swift
Input: 5
Output: 1
Explanation: 5! = 120, one trailing zero.
```

**Note:** Your solution should be in **logarithmic** time complexity.

题意：设计一个算法，算出正整数 `n` 的阶乘 `n!` 有多少个尾随零。算法的时间复杂度应为 $O(\log n)$ 。

---
### 解法 数学
由于数据范围为整型，显而易见，如果计算出阶乘结果然后数零，复杂度绝对爆炸！为此，我们需要对数复杂度的算法。

容易知道，阶乘中的零，是乘以 `10` 得到的，`n!` 中的每个 `0` 表示 `n!` 能被 `10` 整除一次。我们可以对 `n!` 计算因子 `10` 的个数，不过这和之前的算法没有区别。

我们继续思考——每个因子 `10` 都代表 `n!` 能被 `2` 和 `5` 整除，为此我们可以计算 `n!` 中有多少个 `2 * 5` ，或者说因数 `2` 和 `5` 的个数。由于每个偶数中都有因数 `2` ，不难察觉，因数 `2` 的个数远比 `5` 的个数多，因此我们只需要计算因子 `5` 的个数。

如果像下面的代码一样直接遍历，是可以完成这道题的：
```cpp
class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        for(long long i = 5; i <= (long long)n; i += 5){
            long long temp = i;
            while(temp % 5 == 0){
                count++;
                temp /= 5;
            }
        }
        return count; 
    }
}; 
```
提交后效率如下：
```cpp
执行用时：1828 ms, 在所有 C++ 提交中击败了38.02% 的用户
内存消耗：6.3 MB, 在所有 C++ 提交中击败了5.13% 的用户
```
当然，我们的脚步不会停止在这里。接下来仔细观察下式：
```cpp
n! = 1 * 2 * 3 * 4 * (1 * 5) * ... 
	   * (2 * 5) * ... * (3 * 5) * ... * (4 * 5) * ... * (5 * 5) 
```
有如下规律：
- 每隔 `5` 个数会出现**一个** `5` ，因此可以通过 `n / 5` 计算存在多少个 `5` ；
- 同时也会发现，每隔 `25` 个数会出现一个 `25` ，它有**两个** `5` ，而之前我们只计算了一个 `5` ，需要通过 `n / 25` 计算存在多少个 `25` 来**加上遗漏的 `5`**；
- 随后会发现，每隔 `125` 个数会出现一个 `125` ，它有**三个** `5` ，我们上面只计算了 `125` 的两个 `5` ，需要通过 `n / 125` 计算存在多少个 `125` 来**加上遗漏的 `5`**；
- $\dots\dots$

当我们计算 `count = n / 5 + n / 25 + n / 125 + ...` 时，最后分母可能过大导致溢出。将这个式子转换为 `count = n / 5 + n / 5 / 5 + n / 5 / 5 / 5 + ...` ，就可以非常简单地进行计算了。这样，第一次加上的就是每隔 `5` 个数的 `5` 的个数，第二次加上的就是每隔 `25` 个数的 `5` 的个数，依次类推……具体代码如下：
```cpp
class Solution {
public:
    int trailingZeroes(int n) { 
        int ans = 0;
        while (n / 5 > 0) {
            ans += n / 5;
            n /= 5;
        }
        return ans;
    }
}; 
```
实际效率如下：
```cpp
执行用时：0 ms, 在所有 C++ 提交中击败了100.00% 的用户
内存消耗：6.1 MB, 在所有 C++ 提交中击败了11.63% 的用户
```
