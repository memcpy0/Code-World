> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个长度为 `5` 的字符串 `time` ，表示一个电子时钟当前的时间，格式为 `"hh:mm"` 。**最早** 可能的时间是 `"00:00"` ，**最晚** 可能的时间是 `"23:59"` 。

在字符串 `time` 中，被字符 `?` 替换掉的数位是 **未知的** ，被替换的数字可能是 `0` 到 `9` 中的任何一个。

请你返回一个整数 `answer` ，将每一个 `?` 都用 `0` 到 `9` 中一个数字替换后，可以得到的有效时间的数目。

**示例 1：**
```java
输入：time = "?5:00"
输出：2
解释：我们可以将 ? 替换成 0 或 1 ，得到 "05:00" 或者 "15:00" 。注意我们不能替换成 2 ，因为时间 "25:00" 是无效时间。所以我们有两个选择。
```
**示例 2：**
```java
输入：time = "0?:0?"
输出：100
解释：两个 ? 都可以被 0 到 9 之间的任意数字替换，所以我们总共有 100 种选择。
```
**示例 3：**
```java
输入：time = "??:??"
输出：1440
解释：小时总共有 24 种选择，分钟总共有 60 种选择。所以总共有 24 * 60 = 1440 种选择。
```
**提示：**
-   `time` 是一个长度为 `5` 的有效字符串，格式为 `"hh:mm"` 。
-   `"00" <= hh <= "23"`
-   `"00" <= mm <= "59"`
-   字符串中有的数位是 `'?'` ，需要用 `0` 到 `9` 之间的数字替换。

---
### 解法1 分类讨论+乘法原理
本题只需分别计算小时和分钟的有效个数，根据乘法原理，答案为这两个个数的乘积。分类讨论如下：
- 讨论小时的可能
	1. `time[0] = '?'` ：
		1. `time[1] = '?'` ，此时小时可以任取，从 $0\sim 23$ 有 $24$ 种可能。
		2. `time[1] >= '4'` ，此时 `time[0]` 只能取 $0$ 或 $1$ ，不然会 $\gt 23$ 。
		3. `time[1] < '4'` ，此时 `time[0]` 可以取 $0, 1, 2$ 。
	2. 在 `time[0]` 不为 `'?'` 的情况下，如果 `time[1] = '?'` ：
		1. `time[0] = '2'` ，则 `time[1]` 只能取 $0 \sim 3$ 。
		2. 否则，`time[1]` 可以取 $0 \sim 9$ 。
	3. 都不为 `'?'` ，则小时只有当前 $1$ 种可能。
- 讨论分钟的可能：
	1. `time[3] = '?'` 且 `time[4] != '?'`，则 `time[3]` 可取 $0\sim 5$ 。
	2. `time[3] != '?'` 且 `time[4] = '?'` ，则 `time[4]` 可取 $0 \sim 9$ 。
	3. `time[3] = '?'` 且 `time[4] = '?'` ，则分钟可以任取，从 $0 \sim 59$ 有 $60$ 种可能。
	4. 都不为 `'?'` ，则分钟只有当前 $1$ 种可能。
```cpp
class Solution {
public:
    int countTime(string time) {
        int a = 1, b = 1;
        a = time[0] == '?' ? (time[1] == '?' ? 24 :
            (time[1] < '4' ? 3 : 2)) :
            (time[1] == '?' ? (time[0] == '2' ? 4 : 10) : 1);
        b = (time[3] == '?' ? 6 : 1) * (time[4] == '?' ? 10 : 1);
        return a * b;
    }
};
```
复杂度分析：
- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$ 

---
### 解法2 枚举+乘法原理
同样是乘法原理，但代码实现不同。我们分别枚举所有可能的小时和分钟，判断其是否满足题目给出的模式。
- 对于小时，枚举 $[0,23]$ 内的每个整数 $i$，需同时满足下面两个条件：
	- $\textit{time}[0]$ 是 $?$ 或等于 $i$ 的十位数字（$i<10$ 时为 $0$ ）。
	- $\textit{time}[1]$ 是 $?$ 或等于 $i$ 的个位数字。
- 对于分钟，枚举 $[0,59]$ 内的每个整数 $i$，需同时满足下面两个条件：
	- $\textit{time}[3]$ 是 $?$ 或等于 $i$ 的十位数字（$i<10$ 时为 $0$ ）。
	- $\textit{time}[4]$ 是 $?$ 或等于 $i$ 的个位数字。

代码实现时，可以把这两个判断逻辑合并至一个函数 $count$ 中。
```cpp
class Solution {
public:
    int countTime(string time) {
        function<int(string, int)> count = [&](string t, int period) {
            int ans = 0;
            for (int i = 0; i < period; ++i)
                if ((t[0] == '?' || t[0] - '0' == i / 10)
                    && (t[1] == '?' || t[1] - '0' == i % 10)) ++ans;
            return ans;
        };
        return count(time.substr(0, 2), 24) * count(time.substr(3), 60);
    }
};
```
复杂度分析：
- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$ 
 