> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个字符串 `s` ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

**示例 1：**
```java
输入：s = "eleetminicoworoep"
输出：13
解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
```
**示例 2：**
```java
输入：s = "leetcodeisgreat"
输出：5
解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。
```
**示例 3：**
```java
输入：s = "bcbcbc"
输出：6
解释：这个示例中，字符串 "bcbcbc" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。
```
**提示：**
- `1 <= s.length <= 5 x 10^5`
- `s` 只包含小写英文字母。

---
与本题相似的题目（前缀和+异或）如下： 
- [1177. 构建回文串检测](https://leetcode.cn/problems/can-make-palindrome-from-substring)
- [1542. 找出最长的超赞子字符串](https://leetcode.cn/problems/find-longest-awesome-substring/)
- [1915. 最美子字符串的数目](https://leetcode.cn/problems/number-of-wonderful-substrings/) 

先考虑暴力方法如何做。最直观的方法无非就是枚举所有子串，遍历子串中的所有字符，**统计元音字母出现的个数**。如果符合条件，我们就更新答案，但这样肯定会因为超时而无法通过所有测试用例。

### 解法 异或+前缀和+哈希表+字符串
回顾一下上面的操作，其实每个子串对应着一个区间，那么有什么方法可以在不重复遍历子串的前提下，快速求出这个区间里元音字母出现的次数呢？答案就是前缀和，对于一个区间，可用两个前缀和的差值，得到其中某个字母的出现次数。

这种问题其实在[LeetCode 1177. Can Make Palindrome from Substring](https://memcpy0.blog.csdn.net/article/details/131304361)中解决过。我们可对每个元音字母分别维护一个前缀和，统计每种字母在前缀中的出现次数。以字母 $a$ 为例，在计算前缀和时，如果 $s[i]=a$ 就视作 $1$ ，否则视作 $0$ 。

预处理 $s$ 的长为 $i$ 的前缀中，每种元音字母各出现多少次。定义一个 $sum[n + 1][5]$ ，$n$ 为字符串 $s$ 的长度，**$sum[i+1][j]$ 表示从 $s[0]$ 到 $s[i]$ 中，第 $j$ 个元音字母的出现次数**。假设我们需要求出 $[l, r]$ 这个区间的子串是否满足条件，只需用 $sum[r + 1][k] - sum[l][k]$ ，**在 $O(1)$ 时间得到第 $k$ 个元音字母的出现次数**。然后对每个元音字母，都判断一下是否出现偶数次即可。

==上面利用前缀和，优化了统计子串的时间复杂度==。然而，枚举所有子串的复杂度仍需要 $O(n^2)$ ，不足以通过本题，还需继续优化，避免枚举所有子串。

我们考虑枚举字符串的每个位置 $i$ ，计算以它结尾的、满足条件的最长字符串长度。其实要做的就是——找到**最小的 $j \in [0, j)$ ，满足 $sum[i + 1][k] - sum[j+1][k]$（即每个元音字母出现的次数）均为偶数**，那么以 $i$ 结尾的最长字符串 $s[j + 1, i]$ 的长度就是 $i - j$ 。

可能马上想到了==用哈希表来优化查找的复杂度==，但单独利用前缀和，**我们无法找到 $i, j$ 相关的恒等式**，像[1248. 统计「优美子数组」](https://leetcode.cn/problems/count-number-of-nice-subarrays/description/)这道题我们明确知道两个前缀的差值是恒定的。那难道就没办法了么？其实不然，这道题我们还有一个性质没有充分利用：要找的子串中，每个元音字母都恰好出现了**偶数次**。

偶数这个条件告诉了我们，对于满足条件的子串而言，**两个前缀和 $sum[i][k]$ 和 $sum[j][k]$ 的奇偶性一定是相同的**，奇数减奇数等于偶数，偶数减偶数等于偶数。因此==对前缀和稍作修改，从维护元音字母出现的次数、改作维护元音字母出现次数的奇偶性==。

这样只要实时维护每个元音字母出现的奇偶性，那么 **$s[j+1,i]$ 满足条件当且仅当对于所有的元音字母 $k$ ，$sum[i][k]$ 和 $sum[j][k]$ 的奇偶性都相等**，此时就可以利用哈希表存储每一种奇偶性（即考虑所有的元音字母）对应**最早出现的位置**，边遍历边更新答案。

题目做到这里基本上做完了，但还可以进一步优化我们的编码方式。由于**长为 $5$ 的数组中只存储 $0$ 和 $1$** ，可以压缩到一个二进制数中，二进制数从低到高第 $i$ 个比特存储第 $i$ 个元音字母出现的奇偶性。例如二进制 $10101$ 表示 $a,i,u$ 出现奇数次，其余元音字母出现偶数次。

这样就可以将 $5$ 个元音字母出现次数的奇偶性，压缩到了一个二进制数中，且连续对应了二进制数的 $[(00000)_2,(11111)_2]$ 的范围，转成十进制数即 $[0,31]$ 。因此也不再需要使用哈希表，直接用一个长度为 $32$ 的数组、来存储对应状态出现的最早位置即可。
```cpp
class Solution {
public:
    int findTheLongestSubstring(string s) {
        int n = s.size(), xor_sum = 0, ans = 0;
        vector<int> pos(1 << 5, -1);
        pos[0] = 0;
        for (int i = 0; i < n; ++i) {
            if (s[i] == 'a') xor_sum ^= 1;
            else if (s[i] == 'e') xor_sum ^= 1 << 1;
            else if (s[i] == 'i') xor_sum ^= 1 << 2;
            else if (s[i] == 'o') xor_sum ^= 1 << 3;
            else if (s[i] == 'u') xor_sum ^= 1 << 4;
            if (~pos[xor_sum]) ans = max(i + 1 - pos[xor_sum], ans);
            else pos[xor_sum] = i + 1;
        }
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(n)$ ，其中 $n$ 为 $s$ 的长度。
- 空间复杂度：$O(S)$ 。其中 $S$ 表示元音字母压缩成一个状态数的最大值
