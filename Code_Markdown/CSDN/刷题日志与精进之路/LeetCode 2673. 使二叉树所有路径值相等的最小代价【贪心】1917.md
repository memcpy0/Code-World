> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个整数 `n` 表示一棵 **满二叉树** 里面节点的数目，节点编号从 `1` 到 `n` 。根节点编号为 `1` ，树中每个非叶子节点 `i` 都有两个孩子，分别是左孩子 `2 * i` 和右孩子 `2 * i + 1` 。

树中每个节点都有一个值，用下标从 **0** 开始、长度为 `n` 的整数数组 `cost` 表示，其中 `cost[i]` 是第 `i + 1` 个节点的值。每次操作，你可以将树中 **任意** 节点的值 **增加** `1` 。你可以执行操作 **任意** 次。

你的目标是让根到每一个 **叶子结点** 的路径值相等。请你返回 **最少** 需要执行增加操作多少次。

**注意：**
- **满二叉树** 指的是一棵树，它满足树中除了叶子节点外每个节点都恰好有 2 个子节点，且所有叶子节点距离根节点距离相同。
- **路径值** 指的是路径上所有节点的值之和。

**示例 1：**
![](https://assets.leetcode.com/uploads/2023/04/04/binaryytreeedrawio-4.png)
```js
输入：n = 7, cost = [1,5,2,2,3,3,1]
输出：6
解释：我们执行以下的增加操作：
- 将节点 4 的值增加一次。
- 将节点 3 的值增加三次。
- 将节点 7 的值增加两次。
从根到叶子的每一条路径值都为 9 。
总共增加次数为 1 + 3 + 2 = 6 。
这是最小的答案。
```
**示例 2：**
![](https://assets.leetcode.com/uploads/2023/04/04/binaryytreee2drawio.png)
```js
输入：n = 3, cost = [5,3,3]
输出：0
解释：两条路径已经有相等的路径值，所以不需要执行任何增加操作。
```
**提示：**
- `3 <= n <= 10^5`
- `n + 1` 是 `2` 的幂
- `cost.length == n`
- `1 <= cost[i] <= 10^4`

---
### 解法 贪心
**提示 1**
考虑根到两个互为兄弟节点（父节点相同）的叶子的两条路径。

由于这两条路径除了**叶子节点不一样**，其余节点都一样，所以为了让这两条路径的路径和相等，**必须修改叶子节点的值**。

设叶子节点的值分别为 $x$ 和 $y$ ，假设 $x\le y$ ，是否需要同时增加 $x$ 和 $y$ 呢？

让这两条路径相等，同时修改 $x, y$ 毫无疑问是不必要的。即使考虑到要和其他路径相等，这也是不需要的，**我们只用把 $x$ 增加 $y-x$ 就行**，因为我们可以==**增加它们的祖先节点的值，使它们俩的路径和与其它的路径和相等**==，这样可以节省操作次数。

**提示 2**
对于不是叶子的兄弟节点，又要如何比较和计算呢？

和上面的分析一样，==从根到当前节点的路径，除了这两个兄弟节点不一样，其余节点都一样==。所以**把路径和从叶子往上传**，这样就可以按照提示 1 那样比较了。

示例 1 如下图，把节点 $2$ 的路径和视作 $x+5+3=x+8$ ，节点 $3$ 的路径和视作 $x+2+3=x+5$（其中 $x$ 是在节点 $2,3$ 之上的路径和，是等同的），这样可以知道需要把节点 $3$ 的值增加 $(x+8)−(x+5)=8−5=3$ 。

代码实现时，可以直接在 $\textit{cost}$ 上累加路径和。由于 $\textit{cost}$ 数组的下标是从 $0$ 开始的，所以节点编号转成下标需要减一。
```javascript
/**
 * @param {number} n
 * @param {number[]} cost
 * @return {number}
 */
var minIncrements = function(n, cost) {
    let ans = 0;
    for (let i = Math.floor(n / 2); i > 0; i--) { // 从最后一个非叶节点开始算
        ans += Math.abs(cost[i * 2 - 1] - cost[i * 2]); // 两个子结点变成一样大小
        cost[i - 1] += Math.max(cost[i * 2 - 1], cost[i * 2]); // 累加路径和
    }
    return ans;
};
```
复杂度分析：
- 时间复杂度：$\mathcal{O}(n)$ ，其中 $n$ 为 $\textit{cost}$ 的长度。
- 空间复杂度：$\mathcal{O}(1)$ 。仅用到若干额外变量。

**思考题**：如果还可以对节点值减一要怎么做？
