> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202310091341420.png)
给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明**：你不能倾斜容器。

**示例 1：**
![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```java
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```
**示例 2：**
```java
输入：height = [1,1]
输出：1
```
**提示：**
- `n == height.length`
- `2 <= n <= 10^5`
- `0 <= height[i] <= 10^4`

---
这道题目看似简单，做起来才发现不容易。分治法、动态规划都用不上，要想得到 O(n)O(n)O(n) 的解法只有使用双指针一条路。即使看了答案知道了双指针解法，你也可能并不清楚这个解法为什么正确。为什么双指针往中间移动时，不会漏掉某些情况呢？

如果没有真正理解题目，即使一次对着答案做出来了，再次遇到这个题目，还是可能做不出来。要理解这道题的正确性和原理，需要从背后的 缩减搜索空间 的思想去考虑题解。下面我将用图片解释这道题的正确性和原理。

双指针解法的正确性

作者：nettee
链接：https://leetcode.cn/problems/container-with-most-water/solutions/94102/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/

```
int maxArea(vector<int>& height) {
    int res = 0;
    int i = 0;
    int j = height.size() - 1;
    while (i < j) {
        int area = (j - i) * min(height[i], height[j]);
        res = max(res, area);
        if (height[i] < height[j]) {
            i++;
        } else {
            j--;
        }
    }
    return res;
}
```
用一句话概括双指针解法的要点：指针每一次移动，都意味着排除掉了一个柱子。

如下图所示，在一开始，我们考虑相距最远的两个柱子所能容纳水的面积。水的宽度是两根柱子之间的距离 d=8d = 8d=8；水的高度取决于两根柱子之间较短的那个，即左边柱子的高度 h=3h = 3h=3。水的面积就是 3×8=243 \times 8 = 243×8=24。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307021858354.png)



如果选择固定一根柱子，另外一根变化，水的面积会有什么变化吗？稍加思考可得：
- 当前柱子是最两侧的柱子，水的宽度 ddd 为最大，其他的组合，水的宽度都比这个小。
- 左边柱子较短，决定了水的高度为 3。如果移动左边的柱子，新的水面高度不确定，一定不会超过右边的柱子高度 7。
- 如果移动右边的柱子，新的水面高度一定不会超过左边的柱子高度 3，也就是不会超过现在的水面高度。
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307021858895.png)


由此可见，如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子的组合，其实都可以排除了。也就是我们可以排除掉左边的柱子了。

这个排除掉左边柱子的操作，就是双指针代码里的 i++。i 和 j 两个指针中间的区域都是还未排除掉的区域。随着不断的排除，i 和 j 都会往中间移动。当 i 和 j 相遇，算法就结束了。

图解双指针解法的原理
下面我们用更直观的方法来看看“排除掉一根柱子”、“指针移动”究竟代表着什么。

在这道题中，假设一共有 nnn 根柱子，编号 0,1,…,n−10, 1, \dots, n-10,1,…,n−1，高度分别为 H0,H1,…,Hn−1H_0, H_1, \dots, H_{n-1}H 
0
​
 ,H 
1
​
 ,…,H 
n−1
​
 。我们要寻找的是两根柱子 i,ji, ji,j，它们需要满足的约束条件是：

iii、jjj 都是合法的柱子下标，即 $$0≤i<n,0≤j<n0 \le i < n, 0 \le j < n0≤i<n,0≤j<n$$
iii 在 jjj 的左边，即 $i<ji < ji<j$
而我们希望从中找到容纳水面积最大的柱子 (i,j)(i, j)(i,j)。以 n=8n = 8n=8 为例，这时候全部的搜索空间是：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307021859898.png)

由于 iii、jjj 的约束条件的限制，搜索空间是白色的倒三角部分。可以看到，搜索空间的大小是 O(n2)O(n^2)O(n 
2
 ) 数量级的。如果用暴力解法求解，一次只检查一个单元格，那么时间复杂度一定是 O(n2)O(n^2)O(n 
2
 )。要想得到 O(n)O(n)O(n) 的解法，我们就需要能够一次排除多个单元格。那么我们来看看，本题的双指针解法是如何削减搜索空间的：

一开始，我们检查右上方单元格 (0,7)(0, 7)(0,7)，即考虑最左边的 000 号柱子和最右边的 777 号柱子，计算它们之间容纳水的面积。然后我们比较一下两根柱子的高度，关注其中较短的一根。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307021859328.png)



假设左边的 000 号柱子较短。根据刚才的推理，000 号柱子目前的水面高度已经到了上限。由于 777 号柱子已经是离 000 号柱子最远的了，水的宽度也最大，如果换其他的柱子和 000 号柱子配对，水的宽度只会更小，高度也不会增加，容纳水的面积只会更小。也就是说，000 号柱子和 6,5,…,16, 5, \dots, 16,5,…,1 号柱子的配对都可以排除掉了。记录了 (0,7)(0, 7)(0,7) 这组柱子的结果之后，就可以排除 000 号柱子了。这相当于 i=0i=0i=0 的情况全部被排除。对应于双指针解法的代码，就是 i++；对应于搜索空间，就是削减了一行的搜索空间，如下图所示。

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307021859226.png)


排除掉了搜索空间中的一行之后，我们再看剩余的搜索空间，仍然是倒三角形状。我们检查右上方的单元格 (1,7)(1, 7)(1,7)，即考虑 111 号柱子和 777 号柱子，计算它们之间容纳水的面积。然后，比较两根柱子的高度。

![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307021900290.png)


假设此时 777 号柱子较短。同理， 777 号柱子已经是离 111 号柱子最远的了，如果换其他的柱子和 111 号柱子配对，水的宽度变小，高度也不会增加，容纳水的面积只会更小。也就是说，777 号柱子和 2,3,…,62, 3, \dots, 62,3,…,6 号柱子的配对都可以排除掉了。记录了 (1,7)(1, 7)(1,7) 这组柱子的结果之后，就可以排除 777 号柱子了。这相当于 j=7j=7j=7 的情况全部被排除。对应于双指针解法的代码，就是 j--；对应于搜索空间，就是削减了一列的搜索空间，如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307021900653.png)



可以看到，无论柱子 iii 和 jjj 哪根更长，我们都可以排除掉一行或者一列的搜索空间。经过 nnn 步以后，就能排除所有的搜索空间，检查完所有的可能性。搜索空间的减小过程如下面动图所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307021900751.png)

实际上还有几道题也是用到了这样的 缩减搜索空间的 思想：

[167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)
[240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

方法一：双指针
说明

本题是一道经典的面试题，最优的做法是使用「双指针」。如果读者第一次看到这题，不一定能想出双指针的做法。

分析

我们先从题目中的示例开始，一步一步地解释双指针算法的过程。稍后再给出算法正确性的证明。

题目中的示例为：

[1, 8, 6, 2, 5, 4, 8, 3, 7]
 ^                       ^
在初始时，左右指针分别指向数组的左右两端，它们可以容纳的水量为 min⁡(1,7)∗8=8\min(1, 7) * 8 = 8min(1,7)∗8=8。

此时我们需要移动一个指针。移动哪一个呢？直觉告诉我们，应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由

两个指针指向的数字中较小值∗指针之间的距离 两个指针指向的数字中较小值 * 指针之间的距离
两个指针指向的数字中较小值∗指针之间的距离
决定的。如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 数字较小的那个指针。

有读者可能会产生疑问：我们可不可以同时移动两个指针？ 先别急，我们先假设 总是移动数字较小的那个指针 的思路是正确的，在走完流程之后，我们再去进行证明。

所以，我们将左指针向右移动：

[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^                    ^
此时可以容纳的水量为 min⁡(8,7)∗7=49\min(8, 7) * 7 = 49min(8,7)∗7=49。由于右指针对应的数字较小，我们移动右指针：

[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^                 ^
此时可以容纳的水量为 min⁡(8,3)∗6=18\min(8, 3) * 6 = 18min(8,3)∗6=18。由于右指针对应的数字较小，我们移动右指针：

[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^              ^
此时可以容纳的水量为 min⁡(8,8)∗5=40\min(8, 8) * 5 = 40min(8,8)∗5=40。两指针对应的数字相同，我们可以任意移动一个，例如左指针：

[1, 8, 6, 2, 5, 4, 8, 3, 7]
       ^           ^
此时可以容纳的水量为 min⁡(6,8)∗4=24\min(6, 8) * 4 = 24min(6,8)∗4=24。由于左指针对应的数字较小，我们移动左指针，并且可以发现，在这之后左指针对应的数字总是较小，因此我们会一直移动左指针，直到两个指针重合。在这期间，对应的可以容纳的水量为：min⁡(2,8)∗3=6\min(2, 8) * 3 = 6min(2,8)∗3=6，min⁡(5,8)∗2=10\min(5, 8) * 2 = 10min(5,8)∗2=10，min⁡(4,8)∗1=4\min(4, 8) * 1 = 4min(4,8)∗1=4。

在我们移动指针的过程中，计算到的最多可以容纳的数量为 494949，即为最终的答案。
 
 
证明

为什么双指针的做法是正确的？

双指针代表了什么？

双指针代表的是 **可以作为容器边界的所有位置的范围**。在一开始，双指针指向数组的左右边界，表示 **数组中所有的位置都可以作为容器的边界**，因为我们还没有进行过任何尝试。在这之后，我们每次将 **对应的数字较小的那个指针** 往 **另一个指针** 的方向移动一个位置，就表示我们认为 **这个指针不可能再作为容器的边界了**。
> 为什么对应的数字较小的那个指针不可能再作为容器的边界了？

在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。

**考虑第一步**，假设当前左指针和右指针指向的数分别为 xxx 和 yyy，不失一般性，我们假设 x≤yx \leq yx≤y。同时，两个指针之间的距离为 ttt。那么，它们组成的容器的容量为：

min⁡(x,y)∗t=x∗t \min(x, y) * t = x * t
min(x,y)∗t=x∗t
我们可以断定，**如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 x∗tx * tx∗t 了**。注意这里右指针只能向左移动，因为 **我们考虑的是第一步**，也就是 **指针还指向数组的左右边界的时候**。

我们任意向左移动右指针，指向的数为 y1y_1y 
1
​
 ，两个指针之间的距离为 t1t_1t 
1
​
 ，那么显然有 t1<tt_1 < tt 
1
​
 <t，并且 min⁡(x,y1)≤min⁡(x,y)\min(x, y_1) \leq \min(x, y)min(x,y 
1
​
 )≤min(x,y)：

- 如果 y1≤yy_1 \leq yy 
1
​
 ≤y，那么 min⁡(x,y1)≤min⁡(x,y)\min(x, y_1) \leq \min(x, y)min(x,y 
1
​
 )≤min(x,y)；

- 如果 y1>yy_1 > yy 
1
​
 >y，那么 min⁡(x,y1)=x=min⁡(x,y)\min(x, y_1) = x = \min(x, y)min(x,y 
1
​
 )=x=min(x,y)。

因此有：

min⁡(x,yt)∗t1<min⁡(x,y)∗t \min(x, y_t) * t_1 < \min(x, y) * t
min(x,y 
t
​
 )∗t 
1
​
 <min(x,y)∗t
即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，**这个左指针对应的数不会作为容器的边界了**，那么我们就可以丢弃这个位置，**将左指针向右移动一个位置**，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。

这样以来，我们将问题的规模减小了 111，被我们丢弃的那个位置就相当于消失了。此时的**左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界**，因此，我们可以继续像之前 **考虑第一步** 那样考虑这个问题：

求出当前双指针对应的容器的容量；

对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。

> 最后的答案是什么？

答案就是我们每次以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值。

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0, r = height.size() - 1;
        int ans = 0;
        while (l < r) {
            int area = min(height[l], height[r]) * (r - l);
            ans = max(ans, area);
            if (height[l] <= height[r]) ++l;
            else --r;
        }
        return ans;
    }
};
```
**复杂度分析**

- 时间复杂度：O(N)O(N)O(N)，双指针总计最多遍历整个数组一次。
    
- 空间复杂度：O(1)O(1)O(1)，只需要额外的常数级别的空间。

--- 
最大化介于两条竖线之间的矩形面积。计算面积时使用的是两条竖线中更短的那条线。

最开始，我们可以用最左边和最右边的两条线，得到最大的宽度。但是这不一定是最大的面积，因为可能存在更高的竖线。所以，我们**每次都从更短的一边向中间搜索**：
- 如果遇到更长的竖线，**比较并可能更新最大面积**；此时，如果短线变了，则换到另一边重复做同样的事情。
- 如果遇到的是更短的竖线，则短边没有变化，继续向中间搜索。

