> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个正整数数组 `arr`，考虑所有满足以下条件的二叉树：
-   每个节点都有 `0` 个或是 `2` 个子节点。
-   数组 `arr` 中的值与树的中序遍历中每个叶节点的值一一对应。
-   每个非叶节点的值等于其左子树和右子树中**叶节点的最大值**的乘积。

在所有这样的二叉树中，返回**每个非叶节点的值**的**最小可能总和**。这个和的值是一个 32 位整数。

如果一个节点有 0 个子节点，那么该节点为叶节点。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/08/10/tree1.jpg)

```java
输入：arr = [6,2,4]
输出：32
解释：有两种可能的树，第一种的非叶节点的总和为 36 ，第二种非叶节点的总和为 32 。 
```
**示例 2：**

![](https://assets.leetcode.com/uploads/2021/08/10/tree2.jpg)
```java
输入：arr = [4,11]
输出：44
```
**提示：**
-   `2 <= arr.length <= 40`
-   `1 <= arr[i] <= 15`
-   答案保证是一个 32 位带符号整数，即小于 `2^31` 。

---
### 解法1 动态规划（自上而下构建二叉树）
**数组 $arr$ 与二叉树的中序遍历的所有叶子节点对应**，并且**二叉树的每个节点都有 $0$ 个节点或 $2$ 个节点**。考虑数组 $arr$ 可以生成的所有二叉树，我们可以把 $arr$ 切分成任意两个非空子数组，分别对应左子树和右子树，然后递归地对两个非空子树执行相同操作，直到子数组大小等于 $1$ ，即叶子节点，那么一种切分方案对应一个合法的二叉树。

使用 $dp[i][j]$ 表示**子数组 $[i, j]\ (i\le j)$ 对应的子树所有非叶子节点的最小总和**，那么 $dp[i][j]$ 可以通过切分子树求得，状态转移方程如下：
$$dp[i][j] = \begin{cases}
0,\quad &i = j \\
\min_{ k \in [i,j)} (dp[i][k] + dp[k + 1][j] + m_{ik} \times m_{(k+1)j}) \quad &i < j
\end{cases}$$
其中 $m_{ik}$​ 表示子数组 $[i,k]$ 的最大值，即子树中叶子节点的最大值，可以预先计算并保存下来。
```cpp
class Solution {
public:
    int mctFromLeafValues(vector<int>& arr) {
        int n = arr.size(); // dp[i][j]表示子数组[i,j]对应的子树中所有非叶节点的最小总和
        vector<vector<int>> dp(n, vector<int>(n, INT_MAX >> 2)); 
        vector<vector<int>> mval(n, vector<int>(n)); // m[i][j]表示子数组[i,j]的最大值
        for (int j = 0; j < n; ++j) { // j在后面
            mval[j][j] = arr[j];
            dp[j][j] = 0;
            for (int i = j - 1; i >= 0; --i) { // 从小区间开始
                mval[i][j] = max(arr[i], mval[i + 1][j]);
                for (int k = i; k < j; ++k)
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +
                        mval[i][k] * mval[k + 1][j]);
            }
        }
        return dp[0][n - 1];
    }
};
```
复杂度分析：
- 时间复杂度：$O(n^3)$ ，其中 $n$  是数组 $\textit{arr}$ 的长度。三重循环需要 $O(n^3)$ 的空间。
- 空间复杂度：$O(n^2)$ 。保存 $\textit{dp}$ 和 $mval$ 需要 $O(n^2)$ 的空间。

---
### 解法2 单调栈（自下而上构建二叉树）
方法一是自上而下构建二叉树，这里可以尝试自下而上构建二叉树：
1. 选择 $arr$ 中两个相邻的值，即两个节点，将它们作为一个新节点的左子节点和右子节点。
2. **这个新节点的值为左右两个子节点的最大值**，将这个新节点在数组 $arr$ 替代这两个节点。
3. 如果 $arr$ 剩余的元素数目大于 $1$ ，执行步骤 $1$ ；否则终止，那么剩余的节点就是构建的二叉树的根节点。

问题就转换为：**给定一个数组 $arr$ ，不断合并相邻的数，合并代价为两个数的乘积，合并之后的数为两个数的最大值，直到数组只剩下一个数，求最小合并代价和**。

那么==想让合并代价和最小，值较小的叶子节点就要尽量放在底部，值较大的叶子节点就要尽量放到高处。因为越是底部的叶子节点，被用来做乘法的次数越多==。
> 假设一个数 $arr[i]\ (0< i < n - 1)$ ，满足 $arr[i - 1] \ge arr[i]$（递减）且 $arr[i] \le arr[i + 1]$（更大）。如果 $arr[i - 1] \le arr[i + 1]$ 那么优先将 $arr[i]$ 与 $arr[i - 1]$ 合并是最优的，反之如果 $arr[i - 1] > arr[i + 1]$ ，那么优先将 $arr[i]$ 与 $arr[i +1]$ 合并是最优的。因为，我们的目的就是把较小的值尽量放在底部。

按照这种思路，套用单调栈（栈元素从底到顶是严格递减的），我们遍历数组 $arr$ ，记录当前的值为 $x$ 。如果栈非空、且栈顶元素 $y \le x$ ，则说明栈顶元素（类似 $arr[i]$ ）是符合前面说的最优合并的条件，将栈顶元素 $y$ 出栈：
- 如果栈空或此时的栈顶元素 $z> x$ ，从而**按顺序的 $z,y,x$ 三个元素中**，将 $y$ 与 $x$ 合并是最优的，合并代价为 $x \times y$ ，**合并后的元素为 $\max(x, y) = x$**（现在 $x$ 等待加入栈中，其实就是**替代 $arr$ 中这两个节点 $y,x$ 为 $x$** ）；
- 否则将 $y$ 与栈顶元素 $z$ 合并是最优的，合并代价为 $y \times z$ ，合并后的元素为 $\max(y, z) = z$（事实上 $z$ 已经加入栈中，**$arr$ 中的节点 $z,y$ 替换为 $z$** ；$x$ 还要继续和栈中元素合并）；
- 总的来说，**代价要加上 $y \times \min(x, z)$ ，即将值较小的叶子节点先合并**。

重复上述过程，直到栈空或栈顶元素 $> x$ ，然后将 $x$ 入栈。

==经过以上合并过程后，栈中的元素从底到顶是严格递减的==，因此可以不断地将栈顶的两个元素出栈，合并，再入栈，直到栈元素数目小于 $2$ 。返回最终合并代价和即可。

为了方便判断，**这里在单调递减栈底加了个哨兵**，因此栈不可能为空：
```java
class Solution {
    public int mctFromLeafValues(int[] arr) {
        Stack<Integer> st = new Stack<>();
        st.push(Integer.MAX_VALUE); // st不可能为空,哨兵
        int ans = 0;
        for (int x : arr) {
            while (st.peek() <= x) { // 栈顶为y
                ans += st.pop() * Math.min(st.peek(), x); // 代价加上min(z, x)
            }
            st.push(x);
        }
        while (st.size() > 2) 
            ans += st.pop() * st.peek();
        return ans;
    }
}
```
复杂度分析：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$