> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**
![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)
```java
输入：m = 3, n = 7
输出：28
```
**示例 2：**
```java
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```
**示例 3：**
```java
输入：m = 7, n = 3
输出：28
```
**示例 4：**
```java
输入：m = 3, n = 3
输出：6
```
**提示：**
- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 10^9`

---
### 解法1 动态规划
我们用 $f(i,j)$ 表示从左上角走到 $(i, j)$ 的路径数量，其中 $i$ 和 $j$ 的范围分别是 $[0,m)$ 和 $[0,n)$ 。由于我们每一步只能从向下或者向右移动一步，因此要想走到 $(i, j)$ ，如果向下走一步，那么会从 $(i-1, j)$ 走过来；如果向右走一步，那么会从 $(i,j−1)$ 走过来。因此我们可以写出动态规划转移方程：
$$f(i,j)=f(i−1,j)+f(i,j−1)$$
需要注意的是，如果 $i=0$ ，那么 $f(i−1,j)$ 并不是一个满足要求的状态，我们需要忽略这一项；同理，如果 $j=0$ ，那么 $f(i,j−1)$ 并不是一个满足要求的状态，我们需要忽略这一项。

初始条件为 $f(0,0)=1$ ，即从左上角走到左上角有一种方法。为了方便代码编写，我们可以将所有的 $f(0, j)$ 以及 $f(i,0)$ 都设置为边界条件，它们的值均为 $1$ 。最终的答案即为 $f(m−1,n−1)$ 。
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        int dp[210][210] = {0};
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (i == 1 && j == 1) dp[i][j] = 1;
                else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        } 
        return dp[m][n];
    }
};
```
复杂度分析：
- 时间复杂度：$O(mn)$ 。
- 空间复杂度：$O(mn)$ ，即为存储所有状态需要的空间。注意到 $f(i, j)$ 仅与第 $i$ 行和第 $i-1$ 行的状态有关，因此可用滚动数组代替代码中的二维数组，使空间复杂度降低为 $O(n)$ 。此外，由于我们交换行列的值并不会对答案产生影响，因此总可以通过交换 $m$ 和 $n$ 使得 $m \leq n$ ，这样空间复杂度降低至 $O(\min(m, n))$ 。

---
### 解法2 组合数学
从左上角到右下角的过程中，我们需要移动 $m+n−2$ 次，其中有 $m-1$ 次向下移动，$n−1$ 次向右移动。因此**路径的总数就等于从 $m+n−2$ 次移动中选择 $m−1$ 次向下移动的方案数**，即组合数：
$${\Large C}_{m+n-2}^{m-1} = \binom{m+n-2}{m-1} = \frac{(m+n-2)(m+n-3)\cdots n}{(m-1)!} = \frac{(m+n-2)!}{(m-1)!(n-1)!}$$

因此我们直接计算出这个组合数即可。计算的方法有很多种：如果使用的语言有组合数计算的 API，可以调用 API 计算；如果没有相应的 API，我们可以使用 $$\frac{(m+n-2)(m+n-3)\cdots n}{(m-1)!}$$
进行计算。
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y)
            ans = ans * x / y;
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(m)$ 。由于我们交换行列的值并不会对答案产生影响，因此我们总可以通过交换 $m$ 和 $n$ 使得 $m \leq n$ ，这样空间复杂度降低至 $O(\min(m, n))$ 。
- 空间复杂度：$O(1)$ 。
 