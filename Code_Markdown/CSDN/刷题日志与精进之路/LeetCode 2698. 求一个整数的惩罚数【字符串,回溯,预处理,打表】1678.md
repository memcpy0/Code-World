> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个正整数 `n` ，请你返回 `n` 的 **惩罚数** 。`n` 的 **惩罚数** 定义为所有满足以下条件 `i` 的数的平方和：
- `1 <= i <= n`
- `i * i` 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 `i` 。

**示例 1：**
```js
输入：n = 10
输出：182
解释：总共有 3 个整数 i 满足要求：
- 1 ，因为 1 * 1 = 1
- 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。
- 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。
因此，10 的惩罚数为 1 + 81 + 100 = 182
```
**示例 2：**
```js
输入：n = 37
输出：1478
解释：总共有 4 个整数 i 满足要求：
- 1 ，因为 1 * 1 = 1
- 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。
- 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。
- 36 ，因为 36 * 36 = 1296 ，且 1296 可以分割成 1 + 29 + 6 。
因此，37 的惩罚数为 1 + 81 + 100 + 1296 = 1478
```
**提示：**
- `1 <= n <= 1000`

---
### 解法 数学+字符串+回溯
把 $i^2$ 转成字符串 $s$ ，然后写一个递归，枚举 $s$ 分割出的第一个子串、第二个子串、……，把每个子串对应的整数值 $x$ 加到 $\textit{sum}$ 中。递归到终点时，如果 $\textit{sum}=i$ ，则说明 $i$ 符合要求。
```cpp
int PRE_SUM[1001];
int init = []() {
    for (int i = 1; i <= 1000; i++) {
        string s = to_string(i * i);
        int n = s.length();
        function<bool(int, int)> dfs = [&](int p, int sum) -> bool {
            if (p == n) return sum == i; // 递归终点,i符合要求
            int x = 0;
            for (int j = p; j < n; ++j) { // 枚举分割出从 s[p] 到 s[j] 的子串
                x = x * 10 + s[j] - '0'; // 子串对应的整数值
                if (dfs(j + 1, sum + x)) return true;
            }
            return false;
        };
        PRE_SUM[i] = PRE_SUM[i - 1] + (dfs(0, 0) ? i * i : 0);
    }
    return 0;
}();
class Solution {
public:
    int punishmentNumber(int n) {
        return PRE_SUM[n];
    }
};
```
复杂度分析：
- 时间复杂度：预处理 $\mathcal{O}(U^{1 + 2\log_{10} 2})\approx\mathcal{O}(U^{1.602})$ ，其中 $U=1000$ 。对于数字 $i^2$ ，它的十进制字符串的长度为 $m=\lfloor1+2\log_{10} i\rfloor$ 。
    **划分型题目的本质就是枚举子集**，所以递归需要 $\mathcal{O}(2^m)=\mathcal{O}(i^{2\log_{10} 2})$ 的时间，对其积分可知，整个预处理需要 $\mathcal{O}(U^{1 + 2\log_{10} 2})$ 的时间。
- 空间复杂度：预处理 $\mathcal{O}(U)$ 。

还可直接打表：
```cpp
int val[] = {1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000};
class Solution {
public:
    int punishmentNumber(int n) {
        int sum = 0;
        for (int i = 0; i < 29 && val[i] <= n; ++i)
            sum += val[i] * val[i];
        return sum;
    }
}; 
```