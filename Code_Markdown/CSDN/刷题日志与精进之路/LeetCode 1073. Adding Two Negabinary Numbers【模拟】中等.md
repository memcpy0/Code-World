> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给出基数为 **-2** 的两个数 `arr1` 和 `arr2`，返回两数相加的结果。

数字以 _数组形式_ 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，`arr = [1,1,0,1]` 表示数字 `(-2)^3 + (-2)^2 + (-2)^0 = -3`。_数组形式_ 中的数字 `arr` 也同样不含前导零：即 `arr == [0]` 或 `arr[0] == 1`。

返回相同表示形式的 `arr1` 和 `arr2` 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。

**示例 1：**
```java
输入：arr1 = [1,1,1,1,1], arr2 = [1,0,1]
输出：[1,0,0,0,0]
解释：arr1 表示 11，arr2 表示 5，输出表示 16 。
```
**示例 2：**
```java
输入：arr1 = [0], arr2 = [0]
输出：[0]
```
**示例 3：**
```java
输入：arr1 = [0], arr2 = [1]
输出：[1]
```
**提示：**
-   `1 <= arr1.length, arr2.length <= 1000`
-   `arr1[i]` 和 `arr2[i]` 都是 `0` 或 `1`
-   `arr1` 和 `arr2` 都没有前导0

---
此题与[LeetCode 1017. Convert to Base -2【数学】中等](https://memcpy0.blog.csdn.net/article/details/130773366)有联系，可以参考相关题解。
### 解法 模拟
#### 1. 思路与算法
为了叙述方便，记 $arr1[i]$ 和 $arr2[i]$ 分别是 $arr1$ 和 $arr2$ 从低到高的第 $i$ 个数位。在加法运算中，我们需要将它们相加。

对于普通的二进制数相加，我们可以从低位到高位进行运算，在运算的过程中维护一个变量 $carry$ 表示进位。当运算到第 $i$ 位时，令 $x=arr1[i]+arr2[i]+carry$ ：
- 如果 $x=0,1$ ，第 $i$ 位的结果就是 $x$ ，并且将 $carry$ 置 $0$ ；
- **如果 $x = 2, 3$ ，第 $i$ 位的结果是 $x - 2$ ，需要进位，将 $carry$ 置 $1$** 。

而本题中是「负二进制数」，**第 $i$ 位对应的是 $(-2)^i$ ，而第 $i+1$ 位对应的是 $(-2)^{i+1}$ ，是第 $i$ 位的 $-2$ 倍**。因此，**当第 $i$ 位发生进位时，$\textit{carry}$ 应当置为 $-1$ ，而不是 $1$** 。

此时，$arr1[i]$ 和 $arr2[i]$ 的范围都是 $\{0, 1\}$ ，而 $\textit{carry}$ 的范围从 $\{0, 1\}$ 变成了 $\{-1, 0\}$ ，因此 $x$ 的范围从 $\{0, 1, 2, 3\}$ 变成了 $\{-1, 0, 1, 2\}$ 。那么：
- 如果 $x=0,1$ ，第 $i$ 位的结果就是 $x$ ，并且将 $carry$ 置 $0$ ；
- 如果 $x = 2$ ，第 $i$ 位的结果是 $x−2$ ，需要进位，**将 $carry$ 置 $-1$**（用于偶数位是减，用于奇数位相当于加），即**逢 $2$ 进负 $1$** ；
- 如果 $x = -1$ ，此时第 $i$ 位的结果应该是什么呢？可以发现，由于：$$-(-2)^i = (-2)^{i+1} + (-2)^i$$等式左侧表示第 $i$ 位为 $-1$ 的值，右侧表示第 $i$ 和 $i+1$ 位为 $1$ 的值。因此，==第 $i$ 位的结果应当为 $1$ ，同时需要进位，将 $\textit{carry}$ 置 $1$（注意这里不是 $-1$ ）==。
  最终，$\textit{carry}$ 的范围为 $\{-1, 0, 1\}$ ，多出一个 $x=3$ 的情况，但它与 $x=2$ 的情况是一致的。

#### 2. 细节
**在最坏的情况下，当我们计算完 $arr1$ 和 $arr2$ 的最高位的 $x$ 时，得到的结果为 $x=3$ ，此时产生 $-1$ 的进位，而 $-1$ 在之后又会产生 $1$ 的进位**，因此，答案的长度最多为 $\textit{arr}1$  和 $arr2$ 中较长的长度加 $2$ 。

题目描述中 $arr1[i]$ 和 $arr2[i]$ 表示的是 $arr1$ 和 $arr2$ 从高到低的第 $i$ 个数位，与题解相反。因此，在实际的代码编写中，使用两个指针从 $arr1$ 和 $arr2$ 的末尾同时开始进行逆序的遍历，得到逆序的答案，去除前导零，再将答案反转即可得到顺序的最终答案。
```cpp
class Solution { 
public:
    vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {
        int i = arr1.size() - 1, j = arr2.size() - 1;
        int carry = 0;
        vector<int> ans;
        while (i >= 0 || j >= 0 || carry) {
            int x = carry;
            if (i >= 0) x += arr1[i];
            if (j >= 0) x += arr2[j];
            if (x >= 2) { // 逢2进-1
                ans.push_back(x - 2);
                carry = -1;
            } else if (x >= 0) {
                ans.push_back(x);
                carry = 0;
            } else { // x = -1
                ans.push_back(1);
                carry = 1;
            }
            --i, --j;
        }
        while (ans.size() > 1 && ans.back() == 0) ans.pop_back();
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(m+n)$ ，其中 $m$ 和 $n$ 分别是数组 $arr1$ 和 $\textit{arr}2$ 的长度。
- 空间复杂度：$O(1)$ 。注意这里不包括返回值占用的空间。 