@[toc]
# 1. 题目 
[5375. 恢复数组](https://leetcode-cn.com/contest/biweekly-contest-24/problems/restore-the-array/)
 
某个程序本来应该输出一个**整数**数组。但是这个程序**忘记输出空格**了，以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 $[1, k]$ 之间，且数组中的数字**都没有前导 $0$** 。

给你字符串 `s` 和整数 `k ` 。可能会有**多种不同的数组恢复结果**。按照上述程序，请你返回**所有可能输出字符串** `s` 的数组**方案数**。

由于数组方案数可能会很大，请你返回它对 `10^9 + 7` 取余 后的结果。

示例 1：
```
输入：s = "1000", k = 10000
输出：1
解释：唯一一种可能的数组方案是 [1000]
```
示例 2：
```
输入：s = "1000", k = 10
输出：0
解释：不存在任何数组方案满足所有整数都 >= 1 且 <= 10 同时输出结果为 s 。
```
示例 3：
```
输入：s = "1317", k = 2000
输出：8
解释：可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]
```
示例 4：
```
输入：s = "2020", k = 30
输出：1
解释：唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 > 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。
```
示例 5：
```
输入：s = "1234567890", k = 90
输出：34
```
提示：

-    `1 <= s.length <= 10^5`.
-    `s` 只包含数字且不包含前导 `0` 。
-    `1 <= k <= 10^9`.


## 题意
给出一个数字字符串和一个正整数范围，用 $[1,k]$  之间的一些正整数组合成该字符串，问方案有多少个。要注意的是：这些正整数没有前导 $0$ 。

如：$2020$，由于没有空格，不知道原来的数组是什么，但是大概知道原数组中的整数范围为 $[1,30]$ ，因此方案数目为 $1$ ，原数组为 $[20,20]$。
## 思路
 
这是一道比较简单的动态规划，或者说递推。设 $dp$ 数组，其中 $0 \le i \lt n$ ，$dp[i + 1]$ 表示字符串 $s$ 中从下标 $0$ 到 $i$ 的子串，可以有多少种恢复数组的方案。

为了知道递推关系，我们用一个小例子，比如 $1234567890$ ：
```
	      1		2		3		4		5		6		7		8		9		0 
num       1		12
num             2		23
num		                3		34
num                       		4		45
num										5		56
num												6		67
num														7		78
num																8		89
num																		9		90
dp        1     1		0		0		0		0		0		0		0		0
dp        1     2		1    	0		0		0		0		0		0		0
dp        1     2		3		2   	0		0		0		0		0		0
dp        1     2		0		0		0		0		0		0		0		0
dp        1     2		0		0		0		0		0		0		0		0
dp        1     2		0		0		0		0		0		0		0		0
dp        1     2		0		0		0		0		0		0		0		0
dp        1     2		0		0		0		0		0		0		0		0
dp        1     2		0		0		0		0		0		0		0		0
```
我们可以看到，$123$ 的数组恢复方案是 $[1, 2, 3], [1, 23], [12, 3]$ 三种，$12$ 的数组恢复方案是 $[1,2], [12]$，$1$ 的数组恢复方案是 $[1]$


---
## 代码
```cpp
class Solution {
public:
    int numberOfArrays(string s, int k) {
        const int MOD = 1e9 + 7;
        int n = s.size();
        int number = 0;
        vector<int> dp(n + 1, 0);
        dp[0] = 1; //方便计算第一个字符的方案数
        for (int i = 0; i < n; ++i) {
            if (s[i] != '0') { //不是0, 就以其为数字的开头
                long long number = 0; //1 <= k <= 10^9,如果k再往后,可能溢出发生错误,因此用long long 
                for (int j = i; j < n; ++j) {
                    number = number * 10 + s[j] - '0';
                    if (number > k) break; //组合得到的数>k
                    dp[j + 1] += dp[i];
                    dp[j + 1] %= MOD;
                } 
            }
        }
        for (int i = 0; i < dp.size(); ++i)
        	cout << dp[i] << " ";
        cout << endl;
        return (dp[n] % MOD);
    }
};
```

