> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

Given an integer `rowIndex` , return the <code>rowIndex<sup>th</sup></code> row of the Pascal's triangle. Notice that the row index starts from **0**.
![](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
In Pascal's triangle, each number is the sum of the two numbers directly above it.

**Follow up:** Could you optimize your algorithm to use only $O(k)$ extra space?

**Example 1:**
```swift
Input: rowIndex = 3
Output: [1,3,3,1]
```
**Example 2:**
```swift
Input: rowIndex = 0
Output: [1]
```
**Example 3:**
```swift
Input: rowIndex = 1
Output: [1,1]
```
**Constraints:** `0 <= rowIndex <= 33`

题意：给定一个非负索引 $k$ ，其中 $k ≤ 33$ ，返回杨辉三角的第 $k$ 行。

---
### 解法1 递推
杨辉三角，是二项式系数在三角形中的一种几何排列。它是中国古代数学的杰出研究成果之一，它把二项式系数图形化，**把组合数内在的一些代数性质直观地从图形中体现出来**，是一种离散型的数与形的结合。

杨辉三角具有以下性质：
1. **每行数字左右对称**，由 $1$ 开始逐渐变大再变小，并最终回到 $1$ 。
2. 第 $n$ 行（从 $0$ 开始编号）的数字有 $n+1$ 项，前 $n$ 行共有 $\frac{n(n+1)}{2}$ 个数。
3. **第 $n$ 行的第 $m$ 个数（从 $0$ 开始编号）可表示为组合数 $\mathcal{C}(n,m)$** ，记作 $\mathcal{C}_n^m$ 或 $\binom{n}{m}$ ，即为**从 $n$ 个不同元素中取 $m$ 个元素的组合数**。我们可以用公式来表示它：$$\mathcal{C}_n^m=\dfrac{n!}{m!\times (n-m)!}$$
4. **每个数字等于上一行的左右两个数字之和**，可用此性质写出整个杨辉三角。即第 $n$ 行的第 $i$ 个数等于第 $n-1$ 行的第 $i−1$ 个数和第 $i$ 个数之和。这也是组合数的性质之一，即 $$\mathcal{C}_n^i=\mathcal{C}_{n-1}^i+\mathcal{C}_{n-1}^{i-1}$$
5. $(a+b)^n$ 的展开式（**二项式展开**）中的各项系数依次对应杨辉三角的第 $n$ 行中的每一项。

依据性质 $4$ ，我们可以一行一行地计算杨辉三角。每当我们计算出第 $i$ 行的值，可以在线性时间复杂度内计算出第 $i+1$ 行的值。
```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>> C(rowIndex + 1);
        for (int i = 0; i <= rowIndex; ++i) {
            C[i].resize(i + 1);
            C[i][0] = C[i][i] = 1;
            for (int j = 1; j < i; ++j) C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
        }
        return C[rowIndex];
    }
};
```
注意到对第 $i+1$ 行的计算仅用到了第 $i$ 行的数据，因此可以使用**滚动数组**的思想优化空间复杂度。
```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> pre, cur;
        for (int i = 0; i <= rowIndex; ++i) {
            cur.resize(i + 1);
            cur[0] = cur[i] = 1;
            for (int j = 1; j < i; ++j) cur[j] = pre[j - 1] + pre[j];
            pre = cur;
        }
        return pre;
    }
```
进一步优化：能否只用一个数组呢？递推式 $\mathcal{C}_n^i=\mathcal{C}_{n-1}^i+\mathcal{C}_{n-1}^{i-1}$ 表，当前行第 $i$ 项的计算只与上一行第 $i-1$ 项及第 $i$ 项有关。因此我们可以倒着计算当前行，这样计算到第 $i$ 项时，第 $i-1$ 项仍然是上一行的值。
```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> row(rowIndex + 1);
        row[0] = 1;
        for (int i = 1; i <= rowIndex; ++i)
            for (int j = i; j > 0; --j) 
                row[j] += row[j - 1];
        return row;
    }
};
```
复杂度分析：
- 时间复杂度：$O(\textit{rowIndex}^2)$ 。
- 空间复杂度：$O(1)$ 。不考虑返回值的空间占用。
---
### 解法2 打表
C++代码如下：
```cpp
class Solution {
private:
    vector<vector<int>> pascalTriangle = {
        {1},
        {1,1},
        {1,2,1},
        {1,3,3,1},
        {1,4,6,4,1},
        {1,5,10,10,5,1},
        {1,6,15,20,15,6,1},
        {1,7,21,35,35,21,7,1},
        {1,8,28,56,70,56,28,8,1},
        {1,9,36,84,126,126,84,36,9,1},
        {1,10,45,120,210,252,210,120,45,10,1},
        {1,11,55,165,330,462,462,330,165,55,11,1},
        {1,12,66,220,495,792,924,792,495,220,66,12,1},
        {1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1},
        {1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1},
        {1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1},
        {1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1},
        {1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1},
        {1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1},
        {1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1},
        {1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1},
        {1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1},
        {1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1},
        {1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1},
        {1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1},
        {1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1},
        {1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1},
        {1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1},
        {1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1},
        {1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1},
        {1,30,435,4060,27405,142506,593775,2035800,5852925,14307150,30045015,54627300,86493225,119759850,145422675,155117520,145422675,119759850,86493225,54627300,30045015,14307150,5852925,2035800,593775,142506,27405,4060,435,30,1},
        {1,31,465,4495,31465,169911,736281,2629575,7888725,20160075,44352165,84672315,141120525,206253075,265182525,300540195,300540195,265182525,206253075,141120525,84672315,44352165,20160075,7888725,2629575,736281,169911,31465,4495,465,31,1},
        {1,32,496,4960,35960,201376,906192,3365856,10518300,28048800,64512240,129024480,225792840,347373600,471435600,565722720,601080390,565722720,471435600,347373600,225792840,129024480,64512240,28048800,10518300,3365856,906192,201376,35960,4960,496,32,1},
        {1,33,528,5456,40920,237336,1107568,4272048,13884156,38567100,92561040,193536720,354817320,573166440,818809200,1037158320,1166803110,1166803110,1037158320,818809200,573166440,354817320,193536720,92561040,38567100,13884156,4272048,1107568,237336,40920,5456,528,33,1}};
public:
    vector<int> getRow(int rowIndex) { return pascalTriangle[rowIndex]; }
};
```
运行效率如下：
```cpp
执行用时：68 ms, 在所有 C++ 提交中击败了78.92% 的用户
内存消耗：31.2 MB, 在所有 C++ 提交中击败了93.44% 的用户
```
---
### 解法3 组合公式+线性递推
使用组合数学的知识获取杨辉三角的指定行，可以和组合公式联系起来： $$C(n, i) = \frac{n!}{i ! \times (n -i)!}$$ 
通过改变 $n, i$ 的值，可以得到杨辉三角的表格：

| $n, i$ | 0 | 1 | 2 |3  | 4 |
|:--:|:--:|:--:|:---:|:--:|:--:|:--:|
| 0 | 1 |
| 1 | 1 | 1
| 2 | 1 | 2 | 1
| 3 | 1 | 3 | 3 | 1|
| 4 | 1 | 4 | 6 | 4 | 1

我们可以得到**同一行的相邻组合数**的关系，第 $n$ 行的第 $i + 1$ 项 $\frac{n!}{(i + 1)! \times (n - i - 1)!}$ 是第 $i$ 项 $\frac{n!}{i!\times (n - i)!}$ 的 $\frac{n - i}{i + 1}$ 倍。利用上述公式，我们可以在线性时间计算出第 $n$ 行的所有组合数。
```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) { 
        vector<int> ans;
        long long cur = 1;
        for (int i = 0; i <= rowIndex; ++i) {
            ans.push_back((int)cur);
            cur = cur * (rowIndex - i) / (i + 1); //必须这样写,不然可能运算错误
        }
        return ans;
    }
};
```
复杂度分析：
- 时间复杂度：$O(\textit{rowIndex})$ 。
- 空间复杂度：$O(1)$ 。不考虑返回值的空间占用。

