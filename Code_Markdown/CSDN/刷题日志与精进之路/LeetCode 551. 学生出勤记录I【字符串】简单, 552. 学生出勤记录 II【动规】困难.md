> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

# [551. 学生出勤记录 I](https://leetcode.cn/problems/student-attendance-record-i/)
给你一个字符串 `s` 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
- `'A'`：Absent，缺勤
- `'L'`：Late，迟到
- `'P'`：Present，到场

如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励：
- 按 **总出勤** 计，学生缺勤（`'A'`）**严格** 少于两天。
- 学生 **不会** 存在 **连续** 3 天或 **连续** 3 天以上的迟到（`'L'`）记录。

如果学生可以获得出勤奖励，返回 `true` ；否则，返回 `false` 。

**示例 1：**
```c
输入：s = "PPALLP"
输出：true
解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。
```
**示例 2：**
```c
输入：s = "PPALLL"
输出：false
解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。
```
**提示：**
- `1 <= s.length <= 1000`
- `s[i]` 为 `'A'`、`'L'` 或 `'P'`

### 解法 直接遍历
这道题中，只要字符串中 `A` 的出现次数 `<= 1` 、而且不会出现 `LLL...` 这种连续的 `L` 子串（多个间断的 `L or LL` 是允许的），学生就会得到奖赏。
> 众所周知，如果一个学生连着迟到三次"LLL"就无法评优，但是如果他选择翘课而不是迟到"LAL"，那么他可以评优😀！

代码如下所示，注意**提前退出**：
```cpp
class Solution {
public:
    bool checkRecord(string s) {
        int a = 0; //absent
        for (int i = 0, n = s.size(); i < n; ++i) {
            if (s[i] == 'A' && ++a >= 2) return false;
            else if (s[i] == 'L' && i < n - 2 && s[i + 1] == 'L' && s[i + 2] == 'L') return false;
        }
        return true;
    }
};
```
运行效率如下：
```cpp
执行用时：0 ms, 在所有 C++ 提交中击败了100.00% 的用户
内存消耗：6.2 MB, 在所有 C++ 提交中击败了36.65% 的用户
```
不过这样写，看起来太不优雅了，修改一下一行搞定：
```cpp
class Solution {
public:
    bool checkRecord(string s) {
        // return count(s.begin(), s.end(), 'A') <= 1 && s.find("LLL") == string::npos;
        return s.find("LLL") == -1 && s.find('A') == s.rfind('A');
    }
};
```
效率没有什么变化，虽然调用函数内部遍历了多次。

Java的一行解法如下：
```java
class Solution {
    public boolean checkRecord(String s) {
        return s.indexOf('A') == s.lastIndexOf('A') && s.indexOf("LLL") == -1;
    }
}
```

---
# [552. 学生出勤记录 II](https://leetcode.cn/problems/student-attendance-record-ii/)
可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
- `'A'`：Absent，缺勤
- `'L'`：Late，迟到
- `'P'`：Present，到场

如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励：
- 按 **总出勤** 计，学生缺勤（`'A'`）**严格** 少于两天。
- 学生 **不会** 存在 **连续** 3 天或 **连续** 3 天以上的迟到（`'L'`）记录。

给你一个整数 `n` ，表示出勤记录的长度（次数）。请你返回记录长度为 `n` 时，可能获得出勤奖励的记录情况 **数量** 。答案可能很大，所以返回对 `109 + 7` **取余** 的结果。

**示例 1：**
```c
输入：n = 2
输出：8
解释：
有 8 种长度为 2 的记录将被视为可奖励：
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" 
只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
```
**示例 2：**
```c
输入：n = 1
输出：3
```
**示例 3：**
```c
输入：n = 10101
输出：183236316
```
**提示：**
- `1 <= n <= 10^5`

## 思考：1. 寻找子问题
本题要构造长为 $n$ 的字符串 $s$ ，同时满足：
- $s$ 至多包含 $1$ 个 $A$ 。
- $s$ 不包含 $LLL$ ，也就是说，至多有 $2$ 个连续的 $L$ 。

考虑**按顺序**一个一个地填入字母。在这个过程中，为了判断**是否填完了**、和**可以填哪些字母**，我们需要知道：
- **还剩下多少个字母需要填**。
- **已经填了多少个 $A$**（即**缺勤次数**）。如果之前填过 $A$ ，那么后续不能填 $A$ 。
- **相邻位置上有多少个连续 $L$**（即**结尾连续迟到次数**）。如果之前连续填了 $2$ 个 $L$ ，那么当前位置不能填 $L$（由于不会记录连续迟到次数等于或多于 $3$ 的情况，因此<font color="red"><b>非结尾的连续迟到次数一定少于</b></font> $\color{red}{3}$ ，只需要记录结尾连续迟到次数即可）。

**从右往左**（反过来也可以）填入字母。一开始，右边填的字母不含 $A$ ，且右一个填的字母不是 $L$ 。考虑 $s$ 的最后一个位置填什么字母。
- 填 $P$ ，接下来要解决的问题是：在右边填的字母不含 $A$ ，且上一个填的字母不是 $L$ 的情况下，继续向左填字母，能构造多少个长为 $n−1$ 的字符串。
- 填 $A$ ，接下来要解决的问题是：在右边填的字母包含 $A$ ，且上一个填的字母不是 $L$ 的情况下，继续向左填字母，能构造多少个长为 $n−1$ 的字符串。**在这种情况下，后续位置不能填 $A$** 。
- 填 $L$ ，接下来要解决的问题是：在右边填的字母不含 $A$ ，且上一个填的字母是 $L$ 的情况下，继续向左填字母，能构造多少个长为 $n−1$ 的字符串。如果继续填 $L$ ，问题变成，在右边填的字母不含 $A$ ，且右边相邻位置有 $2$ 个连续 L 的情况下，继续向左填字母，能构造多少个长为 $n−2$ 的字符串。在这种情况下，下一个位置不能填 $L$ 。

这些问题都是**和原问题相似的、规模更小的子问题**，可以用递归解决。
> 注：**从右往左思考，主要是为了方便把递归翻译成递推**。从左往右思考也是可以的。

## 思考 2. 状态定义与转移方程
根据上面的讨论，我们需要在递归过程中跟踪以下信息：
- 还**剩下** $i$ 个字母需要填。
- 右边填了 $j$ 个 $A$ 。
- 右边相邻位置有 $k$ 个连续 $L$ 。

因此，定义**状态**为 $dfs(i,j,k)$ ，表示在在右边填了 $j$ 个 $A$ ，且右边相邻位置有 $k$ 个连续 $L$ 的情况下，继续向左填字母，能构造多少个**长为 $i$ 的字符串**。其中 $0≤i≤n,\ 0≤j≤1,\ 0≤k≤2$ 。

接下来，思考如何从一个状态转移到另一个状态。考虑长为 $i$ 的字符串的最后一个位置填什么字母：
- 填 $P$ ，接下来要解决的问题是：在右边填了 $j$ 个 $A$ ，且右边相邻位置有 $0$ 个连续 $L$ 的情况下，继续向左填字母，能构造多少个长为 $i−1$ 的字符串，即 $dfs(i−1,j,0)$ 。
- 如果 $j=0$ ，那么可以填 $A$ ，接下来要解决的问题是：在右边填了 $1$ 个 $A$ ，且右边相邻位置有 $0$ 个连续 $L$ 的情况下，继续向左填字母，能构造多少个长为 $i−1$ 的字符串，即 $dfs(i−1,1,0)$ 。
- 如果 $k<2$ ，那么可以填 $L$ ，接下来要解决的问题是：在右边填了 $j$ 个 $A$ ，且右边相邻位置有 $k+1$ 个连续 $L$ 的情况下，继续向左填字母，能构造多少个长为 $i−1$ 的字符串，即 $dfs(i−1,j,k+1)$ 。

<font color="red"><b>由于最后一个位置填的字母不同，所以三种情况互相独立，根据加法原理，将上述方案数相加</b></font>，即为 $dfs(i,j,k)$ 。

递归边界：$dfs(0,j,k)=1$ 。如果能递归到 $i=0$ 的状态，说明我们找到了一个合法方案，返回 $1$ 。

递归入口：$dfs(n,0,0)$ ，也就是答案。

当 i=0 时，没有任何出勤记录，此时 ‘A’ 的数量和结尾连续 ‘L’ 的数量一定是 0，因此动态规划的边界情况是 dp[0][0][0]=1。

当 1≤i≤n 时，dp[i][][] 的值从 dp[i−1][][] 的值转移得到，计算每个状态的值需要考虑第 i 天的出勤记录：

如果第 i 天的出勤记录是 ‘P’，则前 i 天和前 i−1 天的出勤记录相比，‘A’ 的数量不变，结尾连续 ‘L’ 的数量清零，因此对 0≤j≤1，有
dp[i][j][0]:=dp[i][j][0]+ 
k=0
∑
2
​
 dp[i−1][j][k]
如果第 i 天的出勤记录是 ‘A’，则前 i 天和前 i−1 天的出勤记录相比，‘A’ 的数量加 1，结尾连续 ‘L’ 的数量清零，此时要求前 i−1 天的出勤记录记录中的 ‘A’ 的数量必须为 0，否则前 i 天的出勤记录至少有 2 个 ‘A’，不满足可奖励的条件，因此有
dp[i][1][0]:=dp[i][1][0]+ 
k=0
∑
2
​
 dp[i−1][0][k]
如果第 i 天的出勤记录是 ‘L’，则前 i 天和前 i−1 天的出勤记录相比，‘A’ 的数量不变，结尾连续 ‘L’ 的数量加 1，此时要求前 i−1 天的出勤记录记录中的结尾连续 ‘L’ 的数量不超过 1，否则前 i 天的出勤记录的结尾至少有 3 个 ‘L’，不满足可奖励的条件，因此对 0≤j≤1 和 1≤k≤2，有
dp[i][j][k]:=dp[i][j][k]+dp[i−1][j][k−1]
上述状态转移方程对于 i=1 也适用。

计算长度为 n 的所有可奖励的出勤记录的数量，即为计算 dp[n][][] 的所有元素之和。计算过程中需要将结果对 10 
9
 +7 取模。

根据上述思路，可以得到时间复杂度和空间复杂度都是 O(n) 的实现。

Java
C#
JavaScript
Python3
C++
C
Golang
class Solution {
    public int checkRecord(int n) {
        final int MOD = 1000000007;
        int[][][] dp = new int[n + 1][2][3]; // 长度，A 的数量，结尾连续 L 的数量
        dp[0][0][0] = 1;
        for (int i = 1; i <= n; i++) {
            // 以 P 结尾的数量
            for (int j = 0; j <= 1; j++) {
                for (int k = 0; k <= 2; k++) {
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD;
                }
            }
            // 以 A 结尾的数量
            for (int k = 0; k <= 2; k++) {
                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD;
            }
            // 以 L 结尾的数量
            for (int j = 0; j <= 1; j++) {
                for (int k = 1; k <= 2; k++) {
                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD;
                }
            }
        }
        int sum = 0;
        for (int j = 0; j <= 1; j++) {
            for (int k = 0; k <= 2; k++) {
                sum = (sum + dp[n][j][k]) % MOD;
            }
        }
        return sum;
    }
}
注意到 dp[i][][] 只会从 dp[i−1][][] 转移得到。因此可以将 dp 中的总天数的维度省略，将空间复杂度优化到 O(1)。

Java
C#
JavaScript
Python3
C++
C
Golang
class Solution {
    public int checkRecord(int n) {
        final int MOD = 1000000007;
        int[][] dp = new int[2][3]; // A 的数量，结尾连续 L 的数量
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            int[][] dpNew = new int[2][3];
            // 以 P 结尾的数量
            for (int j = 0; j <= 1; j++) {
                for (int k = 0; k <= 2; k++) {
                    dpNew[j][0] = (dpNew[j][0] + dp[j][k]) % MOD;
                }
            }
            // 以 A 结尾的数量
            for (int k = 0; k <= 2; k++) {
                dpNew[1][0] = (dpNew[1][0] + dp[0][k]) % MOD;
            }
            // 以 L 结尾的数量
            for (int j = 0; j <= 1; j++) {
                for (int k = 1; k <= 2; k++) {
                    dpNew[j][k] = (dpNew[j][k] + dp[j][k - 1]) % MOD;
                }
            }
            dp = dpNew;
        }
        int sum = 0;
        for (int j = 0; j <= 1; j++) {
            for (int k = 0; k <= 2; k++) {
                sum = (sum + dp[j][k]) % MOD;
            }
        }
        return sum;
    }
}
复杂度分析

时间复杂度：O(n)。动态规划需要计算 n 天的状态，每天的状态有 2×3=6 个，每天的状态需要 O(1) 的时间计算。

空间复杂度：O(1)。使用空间优化的实现，空间复杂度是 O(1)。

方法二：矩阵快速幂
我们还可以使用矩阵快速幂来求解，该方法可以将方法一的时间复杂度由 O(n) 降为 O(logn)。

为了使用矩阵快速幂，需要将方法一的动态规划表示中的 j 和 k 合并到一个维度，即动态规划的状态为：dp[i][j×3+k] 表示前 i 天有 j 个 ‘A’ 且结尾有连续 k 个 ‘L’ 的可奖励的出勤记录的数量，其中 0≤i≤n，0≤j≤1，0≤k≤2，0≤j×3+k<6。

在新的动态规划状态定义下，边界情况是 dp[0][0]=1，当 1≤i≤n 时，状态转移方程如下：

⎩
⎨
⎧
​
  
dp[i][0]=dp[i−1][0]+dp[i−1][1]+dp[i−1][2]
dp[i][1]=dp[i−1][0]
dp[i][2]=dp[i−1][1]
dp[i][3]=dp[i−1][0]+dp[i−1][1]+dp[i−1][2]+dp[i−1][3]+dp[i−1][4]+dp[i−1][5]
dp[i][4]=dp[i−1][3]
dp[i][5]=dp[i−1][4]
​
 
令 dp[n] 表示包含 6 个元素的行向量：

dp[n]=[ 
dp[n][0]
​
  
dp[n][1]
​
  
dp[n][2]
​
  
dp[n][3]
​
  
dp[n][4]
​
  
dp[n][5]
​
 ]
我们可以构建这样一个递推关系：

dp[n]=dp[n−1]× 
⎣
⎡
​
  
1
1
1
0
0
0
​
  
1
0
0
0
0
0
​
  
0
1
0
0
0
0
​
  
1
1
1
1
1
1
​
  
0
0
0
1
0
0
​
  
0
0
0
0
1
0
​
  
⎦
⎤
​
 
因此：

dp[n]=dp[0]× 
⎣
⎡
​
  
1
1
1
0
0
0
​
  
1
0
0
0
0
0
​
  
0
1
0
0
0
0
​
  
1
1
1
1
1
1
​
  
0
0
0
1
0
0
​
  
0
0
0
0
1
0
​
  
⎦
⎤
​
  
n
 
令：

M= 
⎣
⎡
​
  
1
1
1
0
0
0
​
  
1
0
0
0
0
0
​
  
0
1
0
0
0
0
​
  
1
1
1
1
1
1
​
  
0
0
0
1
0
0
​
  
0
0
0
0
1
0
​
  
⎦
⎤
​
 
因此只要我们能快速计算矩阵 M 的 n 次幂，就可以得到 dp[n] 的值，然后计算可奖励的出勤记录的数量。如果直接求取 M 
n
 ，时间复杂度是 O(n)，可以定义矩阵乘法，然后用快速幂算法来加速这里 M 
n
  的求取。计算过程中需要将结果对 10 
9
 +7 取模。

Java
C#
JavaScript
Python3
C++
C
Golang
class Solution {
    static final int MOD = 1000000007;

    public int checkRecord(int n) {
        long[][] mat = {{1, 1, 0, 1, 0, 0},
                        {1, 0, 1, 1, 0, 0},
                        {1, 0, 0, 1, 0, 0},
                        {0, 0, 0, 1, 1, 0},
                        {0, 0, 0, 1, 0, 1},
                        {0, 0, 0, 1, 0, 0}};
        long[][] res = pow(mat, n);
        long sum = Arrays.stream(res[0]).sum();
        return (int) (sum % MOD);
    }

    public long[][] pow(long[][] mat, int n) {
        long[][] ret = {{1, 0, 0, 0, 0, 0}};
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, mat);
            }
            n >>= 1;
            mat = multiply(mat, mat);
        }
        return ret;
    }

    public long[][] multiply(long[][] a, long[][] b) {
        int rows = a.length, columns = b[0].length, temp = b.length;
        long[][] c = new long[rows][columns];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                for (int k = 0; k < temp; k++) {
                    c[i][j] += a[i][k] * b[k][j];
                    c[i][j] %= MOD;
                }
            }
        }
        return c;
    }
}
复杂度分析

时间复杂度：O(logn)。

空间复杂度：O(1)。

作者：力扣官方题解
链接：https://leetcode.cn/problems/student-attendance-record-ii/solutions/942386/xue-sheng-chu-qin-ji-lu-ii-by-leetcode-s-kdlm/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
