> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

我们对 `0` 到 `255` 之间的整数进行采样，并将结果存储在数组 `count` 中：`count[k]` 就是整数 `k` 在样本中出现的次数。

计算以下统计数据:
-   `minimum` ：样本中的最小元素。
-   `maximum` ：样品中的最大元素。
-   `mean` ：样本的平均值，计算为所有元素的总和除以元素总数。
-   `median` ：
    -   如果样本的元素个数是奇数，那么一旦样本排序后，中位数 `median` 就是中间的元素。
    -   如果样本中有偶数个元素，那么中位数`median` 就是样本排序后中间两个元素的平均值。
-   `mode` ：样本中出现次数最多的数字。保众数是 **唯一** 的。

以浮点数数组的形式返回样本的统计信息 `[minimum, maximum, mean, median, mode]` 。与真实答案误差在 `10-5` 内的答案都可以通过。

**示例 1：**
```java
输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
解释：用count表示的样本为[1,2,2,2,3,3,3,3]。
最小值和最大值分别为1和3。
均值是(1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375。
因为样本的大小是偶数，所以中位数是中间两个元素2和3的平均值，也就是2.5。
众数为3，因为它在样本中出现的次数最多。
```
**示例 2：**
```java
输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,4.00000,2.18182,2.00000,1.00000]
解释：用count表示的样本为[1,1,1,1,2,2,3,3,3,4,4]。
最小值为1，最大值为4。
平均数是(1+1+1+1+2+2+2+3+3+4+4)/ 11 = 24 / 11 = 2.18181818…(为了显示，输出显示了整数2.18182)。
因为样本的大小是奇数，所以中值是中间元素2。
众数为1，因为它在样本中出现的次数最多。
```
**提示：**
-   `count.length == 256`
-   `0 <= count[i] <= 10^9`
-   `1 <= sum(count) <= 10^9`
-    `count` 的众数是 **唯一** 的

---
### 解法 模拟+统一中位数计算
根据题意可知，需要计算样本数组的五个统计值，根据定义分别进行模拟计算即可。**最小值一定是最小的非零 `count[i]` 代表的值 `i` ，无需重复比较**。众数则是具有最大 `count[i]` 的 `i` 。

特别注意，本题稍微难点的就是**中位数的计算**。考虑奇偶就显得比较复杂，我们可以统一处理。==无论样本数是奇数还是偶数，中位数的左边和右边的长度一定相等，都等于 $(n - 1) / 2$== 。考虑从两边删除，中间剩余的就是中位数。
```java
class Solution {
    public double[] sampleStats(int[] count) {
        int n = 0, min = -1, max = 0, mode = 0;
        long sum = 0;
        for (int i = 0; i < 256; ++i) {
            if (count[i] == 0) continue;
            n += count[i];
            sum += (long)i * count[i];
            if (min == -1) min = i; // 不要重复计算min值
            max = i;
            if (count[i] > count[mode]) mode = i; // 找到众数
        } 
        int i = 0, j = 255;
        // 从左边跳过最多(n-1)/2个数
        for (int t = n - 1 >> 1; t >= count[i]; t -= count[i++]);
        // 从右边跳过最多(n-1)/2个数
        for (int t = n - 1 >> 1; t >= count[j]; t -= count[j--]);
        // 中间两位数(可能是同一个数)求平均
        return new double[]{min, max, (double) sum / n, (i + j) / 2.0, mode};
    }
}
```
复杂度分析：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$
