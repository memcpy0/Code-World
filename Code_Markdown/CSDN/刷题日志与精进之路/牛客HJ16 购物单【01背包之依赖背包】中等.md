### 描述
王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：
|主件| 附件|
|:---|:---|
|电脑 |打印机，扫描仪
| 书柜 |图书
|书桌 | 台灯，文具
| 工作椅 | 无

如果要买归类为附件的物品，必须先买该附件所属的主件，且每件物品只能购买一次。

每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。

王强查到了每件物品的价格（都是 10 元的整数倍），而他只有 N 元的预算。除此之外，他给每件物品规定了一个重要度，用整数 1 **~** 5 表示。他希望在花费不超过 N 元的前提下，使自己的满意度达到最大。

满意度是指所购买的每件物品的价格与重要度的乘积的总和，假设设第 $i$ 件物品的价格为 $v[i]$ ，重要度为 $w[i]$ ，共选中了 $k$ 件物品，编号依次为 $j_1​,j_2​,...,j_k$ ​，则满意度为：$v[j_1​]∗w[j_1​]+v[j_2​]∗w[j_2​]+…+v[j_k​]∗w[j_k​]$ 。（其中 $*$ 为乘号）。请你帮助王强计算可获得的最大的满意度。

### 输入描述：
输入的第 1 行，为两个正整数N，m，用一个空格隔开：  （其中 N （ N<32000 ）表示总钱数， m （m <60 ）为可购买的物品的个数。）

从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q  （其中 v 表示该物品的价格（ v<10000 ）， p 表示该物品的重要度（ 1 **~** 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件， q 是所属主件的编号）
### 输出描述：
输出一个正整数，为张强可以获得的最大的满意度。
### 示例1
输入：
```java
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
```
输出：
```
2200
```
### 示例2
输入：
```java
50 5
20 3 5
20 3 5
10 3 0
10 2 0
10 1 0
```
输出：
```java
130
```
说明：
由第1行可知总钱数N为50以及希望购买的物品个数m为5；
第2和第3行的q为5，说明它们都是编号为5的物品的附件；
第4~6行的q都为0，说明它们都是主件，它们的编号依次为3~5；
所以物品的价格与重要度乘积的总和的最大值为 `10*1+20*3+20*3=130`

---
### 解法 01背包变体
其实这题就是0-1背包问题。首先来看一下经典背包问题，稍作修改就可以得出这题的解答
> 问题描述：有一个背包可以装物品的总重量为 `W` ，现有 `N` 个物品，每个物品中 `w[i]` ，价值 `v[i]` ，用背包装物品，能装的最大价值是多少？

购物车本质上还是0-1背包问题，只不过多了主件和附件。假设先不看附件，那么就和0-1背包一样了。因为附件不能单独出现，要依赖于主件。==对应于背包问题，主件的个数就是物品的个数，考虑每个主件可能出现的情况==。下面的例子当中物品的个数就是3：  
```
1000 5  
800 2 0  
400 5 1  
300 5 1  
400 3 0  
500 2 0
```
考虑每个物品时，可能出现的情况有五种：**1、主件，2、主件+附件1，3、主件+附件2，4、主件+附件1+附件2**，不一定每种情况都出现，只有当存在附件时才会出现对应的情况。即：
```java
dp[i][j] = max(物品不放入背包，主件，主件+附件1，主件+附件2，主件+附件1+附件2)
```
随便写的代码如下：
```cpp
#include <iostream>
#include <vector>
using namespace std;
int n, m;
const int maxm = 100, maxn = 33000;
int ps[maxm], vs[maxm], qs[maxm];
int dp[maxn];
vector<int> slav[maxm]; // 每个主件可能的附件
int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        cin >> vs[i] >> ps[i] >> qs[i];
        if (qs[i]) // 附件
            slav[qs[i]].push_back(i); // 主:附
    }
    for (int i = 1; i <= m; ++i) {
        for (int j = n; j >= vs[i]; --j) {
            if (qs[i]) continue; // 附件不考虑,在对应主件中考虑
            dp[j] = max(dp[j], dp[j - vs[i]] + vs[i] * ps[i]); // 只买主件
            if (slav[i].size() >= 1) { // 1个附件
                int k = slav[i][0];
                if (j >= vs[i] + vs[k])
                    dp[j] = max(dp[j], dp[j - vs[i] - vs[k]]  // 主件+附件1
                        + vs[i] * ps[i] + vs[k] * ps[k]);
            }
            if (slav[i].size() == 2) { // 2个附件
                int k = slav[i][1];
                if (j >= vs[i] + vs[k])
                    dp[j] = max(dp[j], dp[j - vs[i] - vs[k]]  // 主件+附件2
                        + vs[i] * ps[i] + vs[k] * ps[k]);
                int t = slav[i][0];
                if (j >= vs[i] + vs[k] + vs[t]) // 主件+附件1+附件2
                    dp[j] = max(dp[j], dp[j - vs[i] - vs[k] - vs[t]]  
                        + vs[i] * ps[i] + vs[k] * ps[k] + vs[t] * ps[t]);
            }
        }
    }
    cout << dp[n];
    return 0;
}
```