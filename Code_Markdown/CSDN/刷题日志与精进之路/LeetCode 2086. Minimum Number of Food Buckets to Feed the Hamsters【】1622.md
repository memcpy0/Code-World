> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。


给你一个下标从 **0** 开始的字符串 `street` 。`street` 中每个字符要么是表示房屋的 `'H'` ，要么是表示空位的 `'.'` 。

你可以在 **空位** 放置水桶，从相邻的房屋收集雨水。位置在 `i - 1` **或者** `i + 1` 的水桶可以收集位置为 `i` 处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集 **两个** 房屋的雨水。

在确保 **每个** 房屋旁边都 **至少** 有一个水桶的前提下，请你返回需要的 **最少** 水桶数。如果无解请返回 `-1` 。

**示例 1：**

**输入：**street = "H..H"
**输出：**2
**解释：**
我们可以在下标为 1 和 2 处放水桶。
"H..H" -> "HBBH"（'B' 表示放置水桶）。
下标为 0 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。
所以每个房屋旁边都至少有一个水桶收集雨水。

**示例 2：**

**输入：**street = ".H.H."
**输出：**1
**解释：**
我们可以在下标为 2 处放置一个水桶。
".H.H." -> ".HBH."（'B' 表示放置水桶）。
下标为 1 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。
所以每个房屋旁边都至少有一个水桶收集雨水。

**示例 3：**

**输入：**street = ".HHH."
**输出：**-1
**解释：**
没有空位可以放置水桶收集下标为 2 处的雨水。
所以没有办法收集所有房屋的雨水。

**示例 4：**

**输入：**street = "H"
**输出：**-1
**解释：**
没有空位放置水桶。
所以没有办法收集所有房屋的雨水。

**示例 5：**

**输入：**street = "."
**输出：**0
**解释：**
没有房屋需要收集雨水。
所以需要 0 个水桶。

**提示：**

- `1 <= street.length <= 105`
- `street[i]` 要么是 `'H'` ，要么是 `'.'` 。

O(1)空间，但要修改字符串：
```cpp
class Solution {
public:
    int minimumBuckets(string hamsters) {
        int n = hamsters.size();
        if (n == 1) {
            if (hamsters[0] == 'H') return -1;
            else return 0;
        } 
        size_t pos = hamsters.find("HHH");
        if (pos != string::npos) return -1; // 无解
        if (hamsters[0] == 'H' && hamsters[1] == 'H' ||
            hamsters[n - 2] == 'H' && hamsters[n - 1] == 'H') return -1;
        
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (hamsters[i] == 'H') {
                if (i >= 1 && hamsters[i - 1] == 'B') continue; // 有桶了

                if (i + 1 < n && hamsters[i + 1] == '.') {
                    hamsters[i + 1] = 'B';
                    ++ans;
                } else if (i >= 1 && hamsters[i - 1] == '.') {
                    hamsters[i - 1] = 'B';
                    ++ans;
                }
            }
        }
        return ans;
    }
};
```
无需修改字符串，用一个int记录前一个桶的位置即可。当遍历到房子 i 时，如果前一个桶的位置是 i - 1 ，那就不用放桶。