 Given an array `nums`, write a function to move `all 0's` to the end of it while **maintaining the relative order** of the non-zero elements.

**Example:**
```swift
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
```
**Note:**
- You must do this **in-place** without making a copy of the array.
 - Minimize the total number of operations.

题意：题目给出一个数组，两个要求：将所有 `0` 移动到数组末尾；保持非零元素的顺序。希望能够原地修改，使用 `O(1)` 空间。

---
### 解法1 辅助空间
这个题一看就是双指针问题，但写起来还不是那么好写。先用开 `O(N)` 空间的做法。将非 `0` 元素存到另外一个 `vector` 中，然后再复制回来：
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {  
        vector<int> t(nums.size(), 0);
        int len = 0;
        for (const auto i : nums) 
           if (i) t[len++] = i;
        nums = t;  
    }
}; 
```
执行结果如下，空间复杂度为 $O(n)$ ：
```cpp
执行用时 :8 ms, 在所有 C++ 提交中击败了91.45% 的用户 
内存消耗 :10.2 MB, 在所有 C++ 提交中击败了5.32%的用户
```
---
### 解法2 双指针
先满足一个需求(将非 `0` 元素置于数组前面并保持相对顺序)，再满足另一个需求(将 `0` 放在数组后面)。用的是快慢指针的技巧，或者说是快指针+慢区间。

`k = 0` 为一个慢指针，指向**非零元素区间的下一个元素位置**，`[0, k)` 指示一个非零元素的区间。而 `i` 为快指针，遍历到第 `i` 个元素后，就要保证 `[0...i]` 中的所有非零元素都按照顺序排列在 `[0,k)` 中：
-  `nums[i]` 不为0，就在找到的非零元素区间之后的一个元素位置（即 `k` 处）记录它，慢区间扩展一位，`k` 自加一，指向下一个位置；
- `nums[i]` 为 `0`，`i` 就继续往后移动。

**这样就保证了快指针始终大于等于慢指针，因为慢指针只会在扩展的时候移动**。也不会出现后面的非 `0` 元素覆盖了前面的非零元素的情况，**因为慢指针已经向后移动了**。解释如下：
- 如果一路遇到的都是非 `0` 元素，那么 `k, i` 就会一起向前移动，原地赋值，从而扩展非 `0` 区间；
- 出现错位或者是 `i > k` ，是因为遇到 `0` 元素。此时 `k` 指向 `0` 元素，`i` 继续移动，直到指向非 `0` 元素，这时 `i > k` ，`i` 和 `k` 之间都是 `0`。然后 `nums[k++] = nums[i]` ，使得 `k` 位置非零，扩展非 `0` 区间；**但是也有 `nums[i] != 0`**，之后 `i` 继续向后移动。因此慢指针 `k` 之前的所有元素都是非零的；当前指针 `i` 和慢速指针 `k` 之间**可能有非 `0` 元素**。
- 当 `i` 到达数组的末尾之后，所有非零元素都已经按照原始顺序移动到数组的开头。要满足第二个需求“将所有的 `0` 移动到末尾”，只需将 `[k...nums.size)` 区间用 `0` 填充即可。

```cpp
class Solution {
public:
	void moveZeroes(vector<int>& nums) {  
        //[0, k)保存非零元素
        //遍历到第i个元素后, 保证[0...i]中所有非0元素都按照顺序排列在[0...k)中
        int k = 0;
        for (int i = 0; i < nums.size(); ++i)
            if (nums[i] != 0) nums[k++] = nums[i];
        //将[k..nums.size()]区间的值赋值为0
        //遍历结束之后，k值表示为非0的个数，再次遍历，从k位置往后此时都应该为0
        for (int i = k; i < nums.size(); ++i) nums[i] = 0;
     }
};
```
这一算法将空间优化到 $O(1)$ ，时间复杂度为 $O(n)$ :
- 如果是全部为 `0` 的数组，那么第一个循环不会出现赋值，第二个循环会填充 `N` 个 `0` ；
- 全部非 `0` 的数组，第一个循环会把每个非零元素赋给自己，第二个循环不会进行；
- 数组 `k` 个非零元素，就会赋值 `k` 次，填充 `nums.size() - k` 个 `0` 。

执行结果如下：
```cpp
执行用时 :8 ms, 在所有 C++ 提交中击败了91.45% 的用户
内存消耗 :10.1 MB, 在所有 C++ 提交中击败了5.32%的用户
```

---
### 解法3 优化时间
这里的 `k` 和 `i` 和上面的语义相同，只是用了**交换**的思想：**如果当前的元素 `nums[i]` 非 `0` ，它的正确位置最多是当前位置或更早的位置(即 `k` 指向的位置)**，然后将 `k` 和 `i` 指向的元素交换。

`k` 可能指向非零元素，也可能指向 `0` ，**但不会将非零元素交换到后面**。因为 **`k` 指向处理过的非零元素区间后一个元素，即未处理区间的头一个元素**。
- 如果 `k` 指向非 `0` 元素，这个元素没有处理，那么 `i` 只会等于 `k` ，就会原地交换，扩展非零区间，`k` 和 `i` 都指向下一个元素；
- 如果 `k` 指向 `0` 元素，那么 `i` 就会继续移动，直到指向非零元素，这时 `i > k` ，**`i` 和 `k` 之间都是零**，然后交换，`i` 位置也成为 `0` ，`k` 位置非 `0` ，扩展非零区间。之后 `k` 和 `i` 都向后移动。

换句话说，代码会保持： 慢指针 `k` 之前的所有元素都是非零的；当前指针 `i` 和慢速指针 `k` 之间的**所有元素都是零**。最后 `i` 超出范围时，`[k, i)` 都为零，完美满足题目要求。从而优化了两种情形，只有全部非零时才和上面的方法一样，为最坏时间复杂度：
- 如果是全部为 `0` 的数组，那么不会交换；
- 全部非 `0` 的数组，为最坏复杂度，每次都交换；
- 数组 `k` 个非零元素，就会交换 `k` 次。

```cpp
class Solution {
public:
	void moveZeroes(vector<int>& nums) { //k为慢指针 
         for (int i = 0, k = 0; i < nums.size(); ++i) 
             if (nums[i])
                 swap(nums[k++], nums[i]);
    }
}
```
执行效率如下：
```cpp
执行用时 :4 ms, 在所有 C++ 提交中击败了99.28% 的用户
内存消耗 :10.1 MB, 在所有 C++ 提交中击败了5.32%的用户
```
---
### 解法4 最后的优化
如果 `i` 和 `k` 位置相同就不进行交换，位置不同的时候交换。然后 `k++` ，非零区间扩展。当然，这种细微的优化效果不会太大。
```cpp
class Solution {
public:
	void moveZeroes(vector<int>& nums) { //k为慢指针   
        for (int i = 0, k = 0; i < nums.size(); ++i)
        	if (nums[i]) {
                if (i != k) swap(nums[k], nums[i]);
                ++k;
            }
    }
};
```
执行结果如下：
```cpp
执行用时 :4 ms, 在所有 C++ 提交中击败了99.27% 的用户
内存消耗 :11.3 MB, 在所有 C++ 提交中击败了5.18%的用户
```
 
