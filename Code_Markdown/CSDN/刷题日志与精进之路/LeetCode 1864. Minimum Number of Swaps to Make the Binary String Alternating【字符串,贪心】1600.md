> 本文属于「征服LeetCode」系列文章之一，这一系列正式开始于2021/08/12。由于LeetCode上部分题目有锁，本系列将至少持续到刷完所有无锁题之日为止；由于LeetCode还在不断地创建新题，本系列的终止日期可能是永远。在这一系列刷题文章中，我不仅会讲解多种解题思路及其优化，还会用多种编程语言实现题解，涉及到通用解法时更将归纳总结出相应的算法模板。
> <b></b>
> 
> 为了方便在PC上运行调试、分享代码文件，我还建立了相关的仓库：[https://github.com/memcpy0/LeetCode-Conquest](https://github.com/memcpy0/LeetCode-Conquest)。在这一仓库中，你不仅可以看到LeetCode原题链接、题解代码、题解文章链接、同类题目归纳、通用解法总结等，还可以看到原题出现频率和相关企业等重要信息。如果有其他优选题解，还可以一同分享给他人。
> <b></b>
> 
> 由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[征服LeetCode系列文章目录](https://memcpy0.blog.csdn.net/article/details/119656559)一文以作备忘。

给你一个二进制字符串 `s` ，现需要将其转化为一个 **交替字符串** 。请你计算并返回转化所需的 **最小** 字符交换次数，如果无法完成转化，返回 `-1` 。

**交替字符串** 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 `"010"` 和 `"1010"` 属于交替字符串，但 `"0100"` 不是。

任意两个字符都可以进行交换，**不必相邻** 。

**示例 1：**
输入：s = "111000"
输出：1
解释：交换位置 1 和 4："1_**1**_10_**0**_0" -> "1_**0**_10_**1**_0" ，字符串变为交替字符串。
 
**示例 2：**
```js
输入：s = "010"
输出：0
解释：字符串已经是交替字符串了，不需要交换。
```
**示例 3：**
```js
输入：s = "1110"
输出：-1
```
**提示：**
- `1 <= s.length <= 1000`
- `s[i]` 的值为 `'0'` 或 `'1'`
 
---
### 解法 贪心+字符串
这一题我没有做出来，后来看到别人的解法才知道怎样做。具体来说，由于只有 `0, 1` 两种字符，而且要交替出现，因此==一个字符串最终的交替形式就只可能有两种==，一定是 $\texttt{1010}\cdots$ 或者 $0101⋯$ 。
 
- 首先统计原字符串中 `0, 1` 的个数，**如果 `0, 1` 的个数之差的绝对值大于 `1` ，就不可能有交替形式**。
- 然后，如果 `0, 1` 字符个数相等，就构造出以 `0` 开头和以 `1` 开头的交替字符串，分别看原字符串和这两个字符串的不同字符个数是多少，得到**最小的不同字符个数** `num` ；
    - 如果 `0` 的个数大于 `1` 的个数，就构造出以 `0` 开头的交替字符串，同样计算出不同字符个数 `num` ；
    - 如果 `1` 的个数大于 `0` 的个数，就构造出以 `1` 开头的交替字符串，同样计算出不同字符个数 `num` 。
- 最后，返回**不同字符个数 `num / 2`** ，这就是所需的交换次数。

具体代码如下：
```cpp
class Solution {
private:
    int countDiff(const string &s, const string &t) {
        int ans = 0;
        for (int i = 0, n = s.size(); i < n; ++i) if (s[i] != t[i]) ++ans;
        return ans;
    }
public:
    int minSwaps(string s) {
        int zeros = 0, ones = 0, n = s.size(), diffs;
        for (const char &c : s) if (c == '0') ++zeros; 
        ones = n - zeros; 
        if (abs(ones - zeros) > 1) return -1; 
        string t(n, '0');
        if (ones > zeros) {
            for (int i = 0; i < n; i += 2) t[i] = '1';
            diffs = countDiff(s, t);
        } else if (ones < zeros) {
            for (int i = 1; i < n; i += 2) t[i] = '1';
            diffs = countDiff(s, t);
        } else {
            for (int i = 0; i < n; i += 2) t[i] = '1';
            diffs = countDiff(s, t);
            t = string(n, '0');
            for (int i = 1; i < n; i += 2) t[i] = '1';
            diffs = min(diffs, countDiff(s, t));
        }
        return diffs / 2;
    }
};
```
上面的写法还是太复杂了，**既然一个字符串的交替形式只有两种，那就直接比较 $s$ 和这两种形式**，看哪种相差的字符数更小即可。
```cpp

```
---
### 解法2 贪心+数学
解题思路
遍历计算字符串中0和1的个数num0,num1,奇数位上1的个数odd1.
如果num0与num1的差值的大于1,不满足条件,直接返回-1
如果字符串长度是偶数,就会有两种排序方式"0101..." "1010...",假如是0开头,奇数位上就应该都是0,我们只需要返回奇数位上的1的个数;假如是1开头,奇数位上就应该都是1,我们只需要返回奇数位上的0的个数,所以就只需要返回odd1和n/2 - odd1的最小值,就是代表哪种交换方式代价最小.
如果字符串长度是奇数,就只有一种排序方式"1010..."或"0101...",如果num0比num1大的话,就应该是以0开头,否则就应该是1开头,假如是0开头,奇数位上就应该都是0,我们只需要返回奇数位上的1的个数;假如是1开头,奇数位上就应该都是1,我们只需要返回奇数位上的0的个数.
代码
class Solution {
    public int minSwaps(String s) {
        int n = s.length();
        int num0 = 0;//0的个数
        int num1 = 0;odd1 = 0;//1的个数,奇数位1的个数
        int ans = n;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '1') {
                num1++;
                if (i % 2 == 0) {
                    odd1++;
                }
            }
            else {
                num0++;
            }
        }  
        if (Math.abs(num0 - num1) > 1) {
            return = -1;
        }      
        if (n % 2 == 0) {
            ans = Math.min(odd1, n/2 - odd1);
        }
        else {
            if (num0 > num1) {
                ans = odd1;
            }
            else {
                ans = num1 - odd1;
            }
        }        
        return ans;
    }
}
复杂度分析
时间复杂度:只需要一次遍历,O(N)
空间复杂度:只需要常数个变量,O(1)

 