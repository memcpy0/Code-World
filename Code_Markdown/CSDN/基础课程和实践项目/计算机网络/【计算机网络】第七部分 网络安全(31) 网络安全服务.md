@[toc]


第30章介绍了密码学，本章讨论密码学在网络安全中的一些应用。首先，我们介绍网络
中典型的安全服务，然后说明如何用密码学提供这些服务。在本章末，我们还讨论对称与非
对称密钥的分发问题。本章为第 32章提供必要的基础，在第32章讨论因特网中的安全问题。
31.1
网络安全服务种类
网络安全能提供如图 3 1.1所示的五种服务。
其中的四种服务与使用网络的报文交换有关：
报文保密性、完整性、鉴别和不可否认。第五
种服务是提供实体的鉴别或认证。
31.1.1
报文保密性
报文保密性
(message confidentiality or
privacy) 是指发送方和接收方期望保持机密。
图 3 1.1报文或实体有关的安全服务
传输的报文必须只对预定的接收方有意义。对
所有其他人，报文都是毫无意义的。当顾客与银行通信时，他期望通信是保密的。
31.1.2
报文完整性
完整性
(message
integrity) 是指数据到达接收方时必须和它们发送时保持一致。在传输
过程中不能发生意外的或者恶意的改变。随着越来越多的货币交易在因特网上进行，完整性
变得至关重要。例如，如果请求转账 $100变成请求$10 000或$100000 ，这将是灾难性的。在
安全通信中必须保证报文的完整性。
31.1.3
报文鉴别
除了报文完整性之外，报文鉴别
(message
authentication) 是指接收方需要确认发送者的
身份，而不是未发送该报文的冒充者。
31.1.4
不可否认性
不可否认性
(nonrepudiation) 是指接收方必须能够证明报文来自特定的发送方。发送方
无泣否认他事实上已经发送过的报文。证明的责任落在接收方身上。例如，当顾客发送一份
报文要求将资金从一个账户转到另一个账户时，银行必须拥有该顾客确实请求转账的证据。
31.1.5
实体鉴别
在实体鉴别(或用户认证)中，实体或用户在访问系统资惊(例如，文件)之前核实身
份。例如，需要访问学校资源的学生在登录过程中必须被核实身份，这是为保护学校与学生
的利益。
31.2
报文保密性
如何实现报文保密性的观念数千年来都没有改变：报文必须在发送方加密而在接收方解

637
密。也就是说，报文必须处理成未授权人员无法理解的形式。良好的保密技术能够在一定程
度上保证入侵者(窃听者)无法理解报文的内容。正如第 30章讨论的那样，这可用对称密钥
加密或非对称密钥加密。我们复习这两种技术。
31.2.1 对称密钥密码学的保密性
尽管现代的对称密钥算怯比长期历史以来所用的秘密写法复杂得多，但基本原理是一致
的。为了用对称密钥密码学中的密钥提供保密性，发送方与接收方必须共享密钥。在过去，
两个特定人员(例如，两个朋友或一个统帅和军队的首领)可能当面交换个人的密钥，今天
的通信不可能提供这样的机会。如一个居住在美国的人不可能与居住在中国的人碰面交换密
钥。更进一步，上亿人之间的通信不是一个小数目。
为了能使用对称密钥密加密，我们需要解决密钥共享问题。这可用会话密钥
(session key)
来完成。这个会话密钥仅在一次会话期间使用，正如我们将在后面将看到的，会 i舌密钥本身
要使用非对称密钥加密方法进行交换。图 3 1. 2表示了 Alice和 Bob之间双方发送保密报文所用的
会话对称密钥。垃意：虽然今天我们不推荐采用对称密钥实施双方通信，但对称密钥的性质
允许双方实施通信。使用两个不同的密钥更安全，因为如果一个密钥被泄露，那么在另一方
向的通信保密性还依旧存在。
a) Alice到Bob通信所用的共享密钥
量
共享密钥
 
密文
数据流
b) Bob到 Alice通信所用的另一个不同的共享密钥
图 3 1. 2
在双方采用对称密钥报文的保密'性
对称密钥加密仍是报文保密性的主要方法，其原因是它的效率。特别是对于长报文，对
称密钥加密比非对称密钥加密的效率更高。
3 1. 2.2
非对称密钥密码学的保密性
在对称密钥加密中，我们提到密钥交换是通过非对称密钥加密的保密性来完成。在非对
称密钥加密过程中，没有共享密钥，而公钥是公开分发的。
Bob创建两个密钥：一个是私钥，
另一个是公钥。他保留私钥用于解密，向所有人公布他的公钥。公钥仅用于加密，而私钥仅
用于解密。公钥锁定报文，私钥解锁报文。
Alice与 Bob之间双向通信需要二对密钥。当 Alice 向 Bob发送报文时，她使用 Bob的公钥。
当 Bob向 Alice发送报文时，他使用 Alice的公钥。如图 3 1. 3所示。
非对称密钥加密的保密性存在两个问题：第一，该方怯基于用长密钥进行复杂的数学计
算。就是说，对于长报文，系统效率较低 p
它只适用于短报文的加密。第二，报文的发送还
需要接收方的公钥。例如，
Alice到 Bob的通信，
Alice需要确信Bob的公钥是真实的，因为 Eve
可用 Bob的名义发布她自己的公钥。在本章后面将看到，系统需要信任。
638
第七部分网络安全
AJice
密文
数据流
a) Alice~ Ij Bob的通信使用 Bob的密钥对
同困山
密文
数据流
b) Bob到]Alice的通信使用 A lice的密钥对
国
Bob
Bob
图 3 1.3使用非对称密钥对的报文保密性
31.3
报文完整性
加密与解密提供保密性，但没有提供完整性(i ntegrity) 。但在有些场合下，我们甚至不
要求保密性而要求完整性。例如，
Alice立下关于她死后财产分配的遗嘱。遗嘱不要求保密性，
死后任何人都可查阅遗嘱。但必须要保持遗嘱的完整性，
Alice不希望遗嘱的内容有任何篡改。
另一个例子，假定Alice发送一个报文通知银行工作人员 Bob支付给Eve咨询费，该报文不需要
对Eve保密，因为她知道要付钱给她。但是，报文需要安全不能被篡改，特别不能被Eve篡改。
31.3.1
文档与指纹
保持文档完整性的一个方怯是使用指纹
(fingerprint) 。如果Alice需要确保文档的内容不
被非住篡改，她可在文档末端按下她的指纹。
Eve不能篡改该文档的内容，或者伪造文档，因
为她不可能伪造Alice的指纹。要确信文档没有被篡改可比较文档上的 Alice的指纹与文件上的
Alice的指纹。如果它们是不同的，则该文档不是Alice的。
为了保持丈档的完整性，需要文档与指纹两者。
31.3.2
报文与报文摘要
电子文档与指纹等价于报文
(message) 和报文摘要
(message
digest) 。为了保持报文的
完整性需要使用称为散列函数
(hash function) 的算法，创建报文的压缩映像用作指纹。图
3 1. 4表示了报文、散列函数与报文摘要。
31.3.3
差异
文档/指纹对与报文/报文摘要对有一些相似之
处，但也有一些差异。文档与指纹在物理上是连在
一起的，而且两个都不需要保密，而报文与报文摘
要是彼此独立的(发送) ，最重要的是报文摘要保密。如果需要通过通信通道发送报文摘要，
那么报文摘要需要置于安全的地方加以保密或加密。
报文
(文档)
图 3 1.4
报文与报文摘要
第31 "l李网络安全服务
639
报文摘要需要保密。
31.3.4创建和检验报文摘要
报文摘要在发送方站点创建，它与报文一起发送到接收方。为了检验报文或文档的完整
性，接收方对报文使用相同的散列函数算法再次产生报文摘要，与接收到的摘要比较。如果
两份摘要完全相同，则接收方确信原有报文没有被改变。当然，我们假定摘要是加密发送。
图 3 1. 5表示了这个思想。
a
31.3.5
散到函数准则
巴
图 3 1. 5
检验完整性
旦
-…、
满足安全要求的散列函数必须有三个条件：单向性、抗弱碰撞攻击和抗强碰撞攻击。如
图 3 1. 6所示。
单向性
散列函数必须具有单向性
(one-wayness) ，用
单向散列函数创建的报文摘要。不能从报文摘要
中重新求出原来的报文。要百分之百做出单向散
列函数有时是困难的。准则表明如果已知报文摘
图 3 1.6
散列函数准则
要，贝 IJ 求出原来的报文极其困难或不可能。这种情况与文档/指纹类似，没有一个人能从指纹
求出文档。
例 31.1
能否将传统的无损压缩方法作为一个散列函数?
解：
不可以。因为无损压缩报文是可逆的，可对压缩报文进行解压缩求出原来的报文。
例 31.2
能否用校验和方法作为一个散列函数?
解：
可以，校验和函数是不可逆的。它满足第一个条件，但是不能满足其余的条件。
抗弱碰撞攻击
散列函数第二个准则是抗弱碰撞攻击
(weak collision) ，确保一个报文不容易被伪装。如
果Alice创建报文和摘要，并向 Bob发送这两者。
Eve不容易创建另一个报文，对它进行散列产
生完全相同的报文摘要。换言之，任意给定一个报文以及该报文创建的摘要，不可能找到另
一个报文，它的摘要与前一摘要相同，这在计算上是不可行的或很困难的。
640
第七部分网络安全
当两个不同的报文能创建相同的摘要时，我们称为碰撞。在弱碰撞中，已知一个报文摘
要，某人想创建一个报文具有完全相同摘要是极其不可能的。散列函数必须具有抗弱碰撞攻
击性质。
抗强碰撞攻击
散列函数第三个准则是抗强碰撞攻击
(strong collision) ，确保任意二个不同报文，不会
有相同的报文摘要。需要这个准则是为了保证报文发送方 Alice不能伪造她自己的报文引起问
题。如果Alice可创建具有相同摘要的两个不同报文，她可否认发给Bob的第一个报文，声明
她仅向 Bob发送了第二个报文。
因为这种类型碰撞的概率比前一种情况更高，所以称为强碰撞。对方可创建两个不同报
文具有相同的摘要。例如，当报文摘要位长较短时，
Alice完全有可能创建具有相同摘要的两
个不同的报文。她发送第一个报文给Bob ，而自己保存第二个报文。以后 Alice可以说第二个
报文是她原来同意的文挡。
假定创建具有相同文摘的两份不同的遗嘱。当遗嘱执行时，第二份遗嘱呈给继承人。因
为两份遗嘱的摘要是相同，偷换成功。
31.3.6
触列算法： SHA-1
虽然已设计出许多散列算怯，但常用的是 SHA-1 o
安全散到算法 1
(Secure Hash
Algorithm, SHA-1) 是美国国家标准与技术协会
(NIST) 修订版，井由联邦信息处理标准
(FIPS)
发布。
该算陆与其他算捧一样，其要点都遵循同一个概念。每一个算撞都创建N位长的摘要。一
个报文被分成多个块，每块512位。如果报文长不是512位的倍数，填充0扩充成 512位的整数
倍。如图 3 1. 7所示。
多个 5 1 2位的报文
报文摘要
图 3 1.7
创建报文摘要
在N位的缓冲器预置一个初始值。算法将该初始值与报文的第一个512位通过杂凑运算生
成第一个N位的中间报文摘要，然后该中间报文摘要与第二个512位的块通过杂凑运算生成第
二个N位的中间报文摘要。第n一 1 个N位中间报文摘要与第n个512位的块通过杂凑运算生成第n
个N位的中间报文摘要。最后一个块处理所生成的摘要就是整个报文的摘要。
SHA-1 算榕的摘
要长度是 160位
(5个字，每宇 32位)。
SHA-1 算法是对超过512位的报文创建N位报文摘妥。
SHA - 1 算法的报文摘妥是 160位
(5个字，每字 32位)。
641
31 .4
字扩展
在处理前，需要对块进行扩展，一个块是由 512位或 16个 32位宇组成，但在处理阶段要求
80个字。因此 16个字块需要扩展到 80个字，即宇0到宇79 。
每块的处理过程
图 3 1. 8表示了每块处理过程总的概要。处理过程共计 80步。每一步将扩展块中的一个字
与一个 32位常数进行杂凑运算创建一个新的摘要。开始时，摘要字的值
(A 、
B 、
C 、
D和 E)
保存在 5个临时变量中，处理结束(第 79步)
时，这些变量与第79步生成的值相加。每步详
细情况超出了本书讨论的范围。我们只需了解
每一步中一个数据字与一个常数通过杂凑运算
创建一个结果送到下一步。
网络安全服务
要「
摘
τ
始于
初霄
或
T
果
T
结
T
的
T
块
T
一
一
A
前「
第31 章
眼泪酬犁gd柑崎
报文鉴别
散列函数保证报文的完整性，它保证报文
不被篡改，但是散列函数不能鉴别报文发送者
的身份。当 Alice 向 Bob发送报文时，
Bob需要
知道是否真的来自 Alice ，还是 Eve伪造的。为
了提供报文鉴别，
Alice需要提供证据证明该报
文确实是 Alice发送的，而不是其他人假冒的。
散列函数本身不能提供这样的证明，由散列函
数创建的摘要称为修改检测码( modification
detection code, MDC) 。这个码可检测报文中
的任何修改。
MAC
为了提供报文鉴别，我们需要将修改检测
码改变成报文鉴别码
(message authentication code, MAC) 0
MDC使用无密钥散列函数，
MAC使用密钥散列函数。密钥散列函数包括当创建摘要时在发送方与接收方之间的对称密钥。
图 3 1.9表示了 Alice如 f可使用密钥散列函数鉴别她的报文以及Bob如何核实报文的真实'性。
Alicc
图 3 1. 8
SHA-l算法中一个块处理过程
Bob
国 3 1. 9
Alice创建MAC和Bob检验MAC
报文与
MAC
642
第七部分网络安全
Alice使用她与 Bob之间的对称密钥
(KAB ) 和密钥散列函数生成MAC ，然后她将原来的报
文与这个MAC一起发送给Bob.
Bob接收到报文与 MAC后，他将报文与 MAC分离。他利用对
称密钥对报文应用同一密钥散列函数获得新的MAC ，井将它与接收到的MAC比较。如果相同，
报文没有被修改，而发送方确实是 Alice 。
HMAC
当今所用的 MAC有多种实现方法，但是近几年来已设计出一些基于无密钥散列函数的
MAC ，如 SHA-l 。这个思想是散列 MAC (hashed MAC) ，称为 HMAC ，它直接使用任何标准
的无密钥散列函数，如 SHA-l.
HMAC用无密钥散列函数对报文与对称密钥串进行运行创建
嵌入的MAC ，图 3 1. 10表示了该思想。将预先假定的对称密钥的副本链接到报文，对这样的链
接使用无密钥散列函数，如 SHA斗。其结果是一个中间 HMAC ，再用密钥(同一密钥)与它
链接，使用同一散列算怯获得的最后结果就是HMAC 。
接收方接收到这个HMAC和报文。接收方从接收到的报文创建自己的 HMAC ，并比较这
两个HMAC是否一致来核实报文的完整性并鉴别原有数据。注意：
HMAC详细情况比我们此
处介绍的要复杂得多。
自" [
HMAC
图 3 1.1 0 HMAC
31.5
数字签名
虽然 MÞ_C能提供报文完整性与报文鉴别，但它有一个缺点。它必须要在发送方与接收方
之间建立对称密钥。此外，数字签名可使用一对非对称密钥(一个公钥与一个私钥)。
我们都熟知签名的概念，在文档上签名表示该文档是我们发出的，或是被我们认可的。
签名向接收方证实文档来自正确的实体。当一个顾客在支票上签上他的名字时，银行需要通
过检验确信该支票是由那位顾客签发的，而不是其他人签发的。换言之，核实文档上的签名
是鉴别符号，即核实文档是否可信的。考虑一个艺术家在一幅绘画作品上签名，如果作品上
签名是可信的，就是说这幅绘画作品确实是这个艺术家的作品。
当 Alice 向 Bob发送报文时，
Bob需要通过检验核实发送方。他需要确信报文来自 Alice而
不是窃听者Eve.
Bob可请求 Alice在报文上进行电子签名。换言之，电子签名可证明 Alice发送
报文的真实性。我们称这种类型的签名为鼓字签名
(digital signature) 。
31.5.1
比较
在继续讨论前，我们考虑两种签名类型的差别：手书签名和数字签名。
包含性
手书签名包含在文档中，它是文档的一部分。当我们填写支票井在支票上签名肘，签名
不是独立部分。另一方面，当我们数字地签署文档时，我们将签名作为独立文档发送。发送
方发送两个文档：报文与签名。接收方接收到两个文档，井核实签名是否属于假定的发送方。

643
如果是真的，保存报文；否则拒绝。
验证方法
两种不同签名类型的第二个不同点是验证方法。在手书签名中，当接收方接收到文档时，
她将文档的签名与文件中的签名比较。如果相同，则文档是可信的。接收方需要有文件上这
个签名的副本用于比较。在数字签名中，接收方接收到报文和签名。没有什么地方保存签名
副本。接收方需要对报文与签名的组合用验证技术去核实其真实性。
关系
在手书签名中，签名与文档之间构成一对多的关系。例如，某人有一个签名，可用于签
发多张支票、多个文档等等。在数字签名中，签名与文档之间是一对一的关系。每个文档有
它自己的签名，一个文档的签名不能用于另一个文档。如果 Bob一个接着一个地接收到来自
Alice的二个文档，他不能用第一个报文的签名去验证第二个报文。每一个报文需要新的签名。
二重性
两种不同签名类型的另一个不同是称为二重性的性质。在手书签名中，被签文档的签名
可用文件上原来的签名来识别。在数字签名中，除非在文档上有时间因素(如时间戳) ，否则
没有这样的特性。例如，假定 Alice发送一个文档指示Bob付款给Eve 。如果Eve截取文档与签
名，稍后她重发再从Bob处获得付款。
31.5.2
需要密钥
在手书签名中，签名好像一个属于文档签名者的专用"私钥"。签名者用它签名文档，任
何其他人都不具有这样的签名。签名的副本好像是一个公钥，任何人都可以用它与原有签名
进行比较来验证文档。
在数字签名中，签名者用她的私钥(即应用签名算陆)签名文档。另一方面，验证者用
签名者的公钥(即应用验证算诠)验证文档。
我们能否用秘密(对称)密钥来实现签名与验证签名呢?回答是否定的，有几点理由。
第一，秘密密钥只有通信两个实体(例如，
Alice与 Bob) 知道，于是如果Alice需要签名另一
个文档发送给Ted ，又需要另一个秘密密钥。第二，正如我们将要看到的，为一次会话创建的
秘密密钥包括了鉴别，鉴别通常是用数字签名实现。这样就形成了恶性循环。第三，
Bob可用
他与 Alice之间秘密密钥，伪装Alice发送文档给Ted 。
数字签名需要一个公钥系统。
31.5.3
过程
数字签名有两种：一种是对整个文档签名，另一种是对文档摘要签名。
签名整个文档
签名整个文档可能比较容易，但效率低。签名文档是用发送方的私钥加密，而验证一个
文档则用发送方的公钥进行解密。签名与验证，如图 3 1.1 1 所示。
我们应该区分数字签名中所用的私钥和公钥与保密性加密中所用的私钥与公钥。在保密性
过程中，使用接收方的私钥与公钥。发送方用接收方的公钥加密，接收方用自己的私钥解密。
在数字签名中。使用发送方的私钥与公钥。发送方用她的私钥，而接收方用发送方的公钥。
在加密系统中，我们使用接收方的私钥与公钥。
在数字签名中，我们使用发送方的私钥与公钥。
644
第七部分网络安全
回ω
Bob
签名的文档
数据流
图 3 1.1 1
在数字签名中，签名报文本身
签名报文摘要
在前面加密系统中提到，报文很长时，使用公钥的效率很低。在数字签名系统中，报文
通常是很长的，但我们还必须使用公钥。解决办越不是签名整个报文，而是签名报文摘要。
我们已知道，精心计算的摘要与报文是一对一的关系。发送方签名报文摘要，接收方验证报
文摘要的签名。图 3 1.1 2表示了数字签名系统中的签名摘要。
签名
验证
Alice
a
报文与签名
后的摘要
图 3 1.1 2
数字签名系统中的签名摘要
在 Alice站点从报文中创建报文摘要，然后用 Alice的私钥签名摘要，再向 Bob发送报文和
签名后的摘要。在本章后面将会看到这个过程与系统有关，不同系统有一些差异。例如，在
创建摘要前可能还有一些附加的计算，或者使用其他的密钥。在某些系统中，签名是一组值。
在Bob站点，首先用同一个散列函数从接收到的报文中创建摘要。然后对鉴别和摘要进行
计算。验证过程还将标准应用于计算结果以确定签名的真实性。如果是可信的，接收报文$
否则拒绝。
31
. 5.4服务
数字签名提供安全系统五种服务中三种：报文的完整性、报文鉴别和不可否认性。注意：
数字签名方案没有提供保密的通信。如果要求保密，那么报文和签名必须用秘密密钥加密或
公钥加密系统进行加密。
报文完整性
如果我们签名整个报文，那么就保持了报文的完整性。因为如果报文被修改了，那么就
不能得到相同的签名。当今的数字签名方案在签名与验证算法中使用散列函数，保持报文的
完整性。
当今的数字签名提供报文完整性。
第31 拿网络安全服务
645
报文鉴别
一个安全的签名方案如手书签名一样(任何人都不易模仿)能提供报文鉴别。
Bob因为可
用 Alice的公钥验证Alice发送的报文，
Alice的公钥不可能创建出用 Eve的私钥相同的签名。
数字签名提供报文鉴别。
报文不可否认性
如果 Alice签名一个报文，事后又否认它，
Bob是否可证明 Alice的确签名过?例如， Alice
发送一个报文给银行工作人员 Bob请求从她的账号转 $10 000到 Ted的账号，事后Alice是否可
赖掉她发送过该报文?到目前为止我们这个方案，
Bob可能有一个问题，
Bob必须保留文件上
的签名和以后要用的 Alice的公钥，使用它们可以创建原始报文以证明文件中的报文与新创建
的报文是相同的。因为 Alices可在这个期间更换她的私钥/公钥，还可声称文件包含的签名是
不可信的，所以这是不可行的。
一种解决办怯是要有一个可信任的第三方。人们在他们活动中形成一个可信任方。在第
32章中，我们将看到，可信任方可解决许多问题如安全服务和密钥交换。图 3 1.1 3表示了可信
任方如何防止Alices否认她发送过的报文。
Bob
Alice, Bob, M, ST
圈 3 1.1 3
使用可信任中心防否认
Alices对报文签名
(SA) 并向可信任中心发送报文、
Alices和 Bob标识符以及签名。可信
任中心验证 Alices的公钥有效后，通过 Alices的公钥验证报文是来自 Alices 。然后可信任中心
保存报文副本、发送方标识符、接收方标识和时间戳在档案中。可信任中心使用它的私钥创
建报文的另一个签名
(ST) 。然后，中心向 Bob发送该报文、新的签名、
Alices的标识符和Bob
标识符。
Bob用可信任中心的公钥验证报文。
如果将来 Alices否认她发送过该报文，可信任中心可出示一份保存的报文副本。如果 Bob
的报文是保存在信任中心的报文副本，因 IJAlices将无法争辩。为了使每一报文都是可信任的，
在下一节对方案增加加密/解密。
用可信任的第二方提供不可否认性。
31.5.5
签名方案
最近几十年来，逐渐地设计出一些签名方案。其中有些已实现，如 RSA 与 DSS
(数字签
名标准)方案。后者可能成为今后的标准，而这些方案的讨论超出了本书范围。
31.6
实体鉴别
实体鉴别是让一方证明另→方的身份的一种技术。一个实体可以是人、进程、客户机或
服务器，需要证明身份的实体称为申请者
(claimant) ，试图证明申请者身份的一方称为验证
646
第七部分网络安全
者( verifier)。当 Bob试图证明 Alices身份时，
Alices是申请者，
Bob是验证者。
报文鉴别与实体鉴别
(entity authentication) 有两点不同。第一，报文鉴别不提供实时性，
实体鉴别是实时性。在前者，
Alices 向 Bob发送报文，
Bob鉴别报文时，在通信过程中 Alices可
以出现也可以不出现。而 Alices请求实体鉴别时，在Bob鉴另Ij Alices之前，没有实际的报文通
信。在鉴别过程中，
Alices需要在线井参与其中。只有Alices被鉴别后，
Alices与 Bob之间才可
进行报文通信。当一份电子邮件从 Alices发送到 Bob时，需要报文鉴别。而当 Alices从一部自
动取款机提取现金时，需要实体鉴别。第二，报文鉴别只简单鉴别一个报文，对每一个新报
文需要重复鉴别，而实体鉴别在一次会话期间证实申请者身份。
在实体鉴别中，验证者必须精确验证申请者的身份。鉴别实体依靠三种基本途径之一实
现：所知的、所有的和固有的特征。
·所知的
这是只有申请者所知的或所掌握的，用于验证者检验申请者所有的"物"。例
如，口令、个人识别号
(PIN) 、密钥和私钥。
·所有的
这是所具有的东西，可证明申请者身份的。例如，护照、驾驶证、身份证、信
用卡和智能卡。
·固有的特征
这是申请者的固有特征。例如，手写签名、指纹、语音、脸型、视网膜图
样和笔迹。
31.6.1
口令
口令
(password) 是实体鉴别最简单的与最古老的方告。它是申请者拥有的东西，当用
户需要访问系统资源(登录)肘，每个用户有公开的用户标识符和专用的口令。我们将这种
鉴别方案分成二组：固定口令
(fixed password) 和一次性口令
(one-time password) 。
固定口令
在这个组中，口令是固定的。每次访问都用相同的口令，可是这种方会遭受到各种攻击。
·窃听。 Eve可注视Alices输入口令。多数系统不显示用户输入的口令字符作为安全措施。
窃听有更加多样的形式。例如，
Eve可使用在线窃听，拦截报文，由此捕获口令为她
所用。
·窃取口令。
Eve直接偷取口令是第二种攻击。
Alices不写下口令，而记住她自己的口令，
这样可防止窃取口令。所以口令应是简单的，或是Alices易记住熟悉的对象，但它易受
到其他类型的攻击。
·访问文件。
Eve像程序员那样操作系统，获取访问存储口令的文件。
Eveì卖取该文件井搜
索Alices 口令，甚至篡改它。为了防止这类攻击，采用文件读/写保护。但是，多数系统
需要这种类型的文件有公开的可读性。
·猜测。
Eve可登录系统，用字符的各种不同组合猜测 Alices的口令。如果用户使短口令
(少数几个字符) ，特别容易遭受攻击。如果口令选用某些平凡的记号，如她的生日、孩
子的名字或她喜欢的明星，也易遭受攻击。为了防止猜测，推荐使用长的随机口令，这
样的口令就不明显。但这样的随机口令也存在问题：
Alices要在某处存储该口令，这样
使她不会忘记它，这又会受到窃取口令攻击。
一个更安全的办怯是将口令的散列存储在口令文件中(不用口令明文存储)。任何用户都
可读取文件内容，但由于散列函数是单向的，几乎不可能猜测出口令值。即使Eve窃取口令文
件，散列函数阻止她访问系统。但是，会遭受到另一种类型称为字典攻击
(dictionary attack)
的攻击。在这种攻击中，
Eve不考虑用户 ID而穷举搜索用户口令。例如，口令是 6位数字，
Eve可建立一张6位数字表
(000000到 999999) ，然后对每个数字应用散列函数得到一散列值，

647
形成一张一百万个散列值的表。她再用读取到的加密口令文件第二列的项与她自己形成的散
列值表比较，看哪些密文重合。这可在 Eve专用的计算机上脱机编程完成。找到匹配后， Eve
联机使用口令访问系统。我们将会看到这种攻击在第三种方法中更加困难。
另一种方战称为掺杂
(salting) 口令。当创建口令时，一种称为掺杂的随机数与口令链接，
然后对掺杂口令应用散列运算。用户 ID、掺杂与散列存储在文件中。现在，当用户请求访问
时，系统获取掺杂，并将它与接收到的口令链接，用该链接做出散列，然后与存储在文件中
的散列比较。如果匹配，准予访问$否则拒绝。掺杂使字典攻击更加困难。如果原有的口令
是6位数字，而掺杂是4位数字，那么散列是在 10位数字上运算。这就是说，
Eve要做出一张 10
兆项的表。做出比较长。如果掺杂是一个很长的随机数，掺杂口令是很有效的。
UNIX操作系
统使用这种方怯的变种。
另一种方法是两种认证技术的组合。这种类型鉴别的一个很好的实例是ATM卡与 PIN
(个人识别号)结合使用。
ATM卡属于"所有的"类，而 PIN属于"所知的"类。
PIN实际上
是口令，它增强了卡的安全性。如果卡被偷窃，除非知道PIN ，否则卡不能使用。但是习惯上
PIN为自己易于记忆通常较短，这又易受到猜测攻击类型的攻击。
一次性口令
这个方案的口令只使用一次，称为一次性口令
(one-time password) 。一次性口令使窃听
与窃取失效，但是这种方案很复杂。留在某些专著中讨论。
31.6.2
询问-应答
在口令鉴别中，申请者通过提供她的密码(口令)证明她的身份。但是，由于申请者出
示这个密码，密码可能被入侵者截取。在询问-应答鉴别
(challenge-response authentication)
中，申请者可不泄露密码证明自己身份。换言之，申请者不用向验证者出示密码，验证者或
者可得到它或者可找到它。
在询问一应答鉴别中，申请者不用泄露密码就可证明自己的身份。
询问是一个随时间变化的值，它是由验证者发送的一个随机数或时间戳。申请者对询问使
用一个特定的函数，并向验证者发送其结果，这称为应答。应答表示了申请者已经知道密码。
询问是验证者发送的一个随时间变化的值，响应是对询问使用一个特定的函数。
I
使用对称密钥加密
第一类中，使用对称密钥加密实现询问一应答鉴别。在这一类中，申请者与验证者共享一
个秘密密钥。函数是应用于询问的加密算棒，图 3 1.1 4表示了这种方法。图 3 1.1 4中的第一个报
文不属于询问一应答部分，它仅是通知验证者申请者想要询问。第二个报文是询问 ，
R8是验证
者为询问申请者随机选取的一个瞬时值。申请者使用只有申请者和验证者知道的共享密钥加
密瞬时值
(nonce) ，井向验证者发送其结果。验证者解密该报文，如果解密得到的瞬时值与
验证者发送的瞬时值相同，贝 IJ 同意Alices访问。
注意：在这个过程中，申请者与验证者必须保存保密所用的对称密钥，验证者必须保留
用于鉴别申请者的瞬时值直到应答已经返回。
读者可能已注意到了使用瞬时值可以防止Eve重发第三个报文。
Eve不可能重发第三个报
文，伪装成这是一个新的鉴别请求，因为一且Bob接收到应答，
RB的值就不再有效，下次要
用新的值。
648
第七部分网络安全
Bob (服务器)
Alices (用户)
Alice
KAB
图 3 1.1 4
使用瞬时值的询问-应答鉴别
这一类中的第二种方棒，随时间变化的值是时间戳，因为时间戳显然随时间变化。在这
种方法中，询问报文是验证者向申请者发送的当前时间。但是，这是假定客户机与服务器的
时钟是同步的，申请者知道当前时间。这就是说，不需要询问报文。第一个报文与第三个报
文可结合，其结果是用一个报文、对隐含询问的应答和当前时间完成鉴别。图 3 1. 15表示了这
种方法。
Bob (服务器)
Alices (用户)
KAB
图 3 1.1 5
使用时间戳的询问-应答鉴别
使用密钥散到函数
实体鉴别不用加密/解密方桂，而是使用密钥散列函数
(MAC) 。这个方也有两个优点。
第一，加密/解密算怯不能进入某些国家。第二，使用密钥散列算法可保持询问与应答报文的
完整性，井同时使用密钥。让我们观察使用密钥散列函数如何创建带有时间戳的询问报文，
图 3 1.1 6表示了该方案。
Alices (用户)
Ali臼 T
I 自+
T I
散列
Bob (服务器)
图 3 1.1 6
使用密钥散列函数的询问-应答鉴别
注意在这种情况中，时间戳同时作为明文和用密钥散列函数杂凑的文本发送。当 Bob接收
到该报文肘，他提取出明文T ，对它使用密钥散列函数，然后将计算结果与接收到的散列比较
来确定Alices的真实性。
使用非对称密钥加密
不用对称密钥加密，我们使用非对称密钥加密对实体进行鉴别。此时的密码必需是申请
者的私钥，申请者要向每个人公开与她自己私钥有关的可用的公钥。这就是说，验证者用申
请者的公钥加密询问，然后申请者用她的私钥解密。对询问的应答是解密的询问。我们说明
第 31 拿网络安全服务
649
了两种方法：一种用于单向鉴别，另一种用于双向鉴别。在第一种方法中，
Bob用 Alices的公
钥加密询问，
Alices用她的私钥解密报文，并向 Bob发送瞬时值。图 3 1.1 7表示了这种方怯。
Bob (服务器)
Alices (用户)
图 3 1.1 7
使用非对称密钥鉴别
使用数字签名
我们可用数字签名进行实体鉴别。在这种方法中，我们让申请者使用她的私钥签名，而
不是用私钥解密。图 3 1.1 8表示了这种方法，
Bob用明文询问，
Alices签名应答。
Bob (服务器)
Alices (用户)
图 3 1.1 8
用数字签名鉴别
31.7
密钥管理
我们已经在本章讨论了对称密钥密码学和非对称密钥密码学的应用，但未讨论对称密钥
密码学中的秘密密钥和非对称密钥密码学中的公钥是如何分发和维护的。本节我们讨论这两
个问题，首先讨论对称密钥的分发，然后讨论非对称密钥的分发。
31.7.1 对称密钥的分发
我们已知道当加密与解密大的报文肘，对称密钥密码学比非对称密钥密码学更有效。但
对称密钥密码学在双方之间需要一个共享的秘密密钥。
如果 Alice需要与N个人交换保密报文，那么她需要N个不同的密钥。如果N个人需要彼此
通信，要多少个密钥?总的密钥数共计N(N一 1)/2。因为每个人需要与其他N一 1 个人通信，但
由于密钥可共享，所以仅需要N(N-1)/2个密钥。这就是说，如果 1 百万人需要彼此通信，则每
个人需要约50万个不同的密钥。因为N个实体要求的密钥数近似于厅，这通常认为是~问题。
密钥的个数不是唯一存在的问题，还有密钥的分发问题。如果Alice与 Bob想要通信，则
他们需要以某种方法交换密钥。如果 Alice要与 1 百万个人通信，她如何与 1 百万个人交换 l 百
万个密钥?使用因特网没有一个明确的安全方住。
显然，我们需要一个维护与分发密钥的有效方法。
650
第七部分网络安全
密钥分发中心： KDC
一个实际的解决方案是使用一个称为密钥分发中心
(key distribution center, KDC) 的可
信任方。为了减少密钥的个数，每个人建立一个带有KDC的共享密钥，如图 3 1.1 9所示。
在KDC与每一个成员之间建立一个私钥。
 
Alice 与 KDC 有一个私钥，我们称为 KAlice 0
Alice 卓忌 、 ?fY
M/，运~B曲
Bob与 KDC有一个棚，称为 KBOb~等。现在
Ann 丛鸟飞--二 型二hi…且 G叫
的问题 Alice 如何向 Bob发送保密的报文?其
，括三k
v
一一-
过程如下：
：
KT，饵，/'
KOC
、、可
1. Alice 向 KDC发送一个请求，表明她需
M 品"'
\aBeuy
要和Bob之间的会话(暂时的)密钥，
2 . KDC 向 Bob通告Alice的请求$
图 3 1.1 9 KDC
3. 如果Bob同意，则在两者之间创建一个会话密钥。
用 KDC在Alice与Bob之间创建的密钥用于KDC鉴别 Alice和Bob ，并防止Evefi!i装他们中的
任一个。在本章的后面，我们将讨论在Alice和Bob之间创建一个会话密钥。
会话密钥
KDC为每个成员创建一个秘密密钥，该秘密密钥仅用于成员与 KDC之间，而不是用在两
个成员之闹。如果 Alice需要与 Bob保密通信，她需要在她自己，与 Bob之间的一个秘密密钥。
双方之间的对称会话密钥仅使用一次 。
使用前面讨论过的实体鉴别思想可以提出多种不同的方法创建会话密钥。
让我们讨论最简单的一种，如图 3 1. 20所示。尽管这个系统有些缺点，但它表明了思想实
质。更复杂的方法可在一些安全书籍中找到。
KDC
Bob
图 3 1. 20
使用 KDC在 Alice与 Bob之间创建会话密钥
·步骤 10
Alice 向 KDC发送明文报文以获得她和 Bob之间的对称会话密钥。报文包含了她
的注册身份(图中的 Alice) 和 Bob的身份(图中的 Bob) 。该报文没有加密，是公开的。
KDC并不关心这些。
·步骤 20
KDC接收到报文，生成了所谓的票证
(ticket) 。该票 i正是用 Bob的密钥
(KB )
加密的。票证包含了 Alice和 Bob的身份，以及会话密钥
(KAB ) 。带有会话密钥副本的票
证发送给Alice o
Alice接收到该报文，对它进行解密，得到会话密钥。她无法解密 Bob的
票证，因为票 i正是给Bob的，不是给Alice的。注意：在该报文中采用了两次加密，票证
是加密的，整个报文也是加密的。在第二个报文中，
Alice被KDC鉴别，因为只有 Alice
能用她的带有KDC的密钥打开整个报文。

651
·步骤 3 0 Alice 将票证发送给 Bob o
Bob打开票证，知道Alice需要使用 KAB作为会话密钥来
向他发送报文。注意：在这个报文中
，
Bob被KDC鉴别，因为只有 Bob能打开票证。因
为 Bob被KDC鉴别，他也被信任 KDC的 Alice鉴别。同样的方法，
Alice也能被Bob鉴别，
因为 Bob信任 KDC ，
KDC 向 Bob发送票证，该票证包括了 Alice的身份。
Kerberos
Kerberos是一个鉴别协议，同时又是一个 KDC ，它已经变得十分流行。包括 Windows
2000在内的几个操作系统都使用 Kerberos 0
Kerberos是根据希腊神话中为冥王哈得斯守门的三
头狗命名的。这个协议最初麻省理工学院设计出来的，目前已经经历了好几个版本。这里只
讨论最常用的第4版。
服务器
Kerberos协议中包括三个服务器：一台
鉴别服务器
(AS) ，一台票证授予服务器
(TGS)
和一台用来向他人提供服务的实际的(数据)服务
器。在我们所给出的一些实例及其插图中，
Bob是实
际的服务器，
Alice是一个请求服务的用户。图 3 1. 21
显示了这三台服务器之间的关系。
·鉴别服务器
(AS) 是 Kerberos协议中的 KDC 。
每个用户在 AS 中进行注册，井被分配一个用
户身份和口令。
AS拥有一个包含这些用户身
份和相应口令的数据库。
AS 验证用户，发布
Alice和TGS之间使用的会话密钥，并发送一张
给TGS使用的票证。
·票证授予服务器
(TGS) 为实际服务器
(Bob)
1.请求TGS的票证
2. Al i ce与 TGS之间的
会 i舌密钥以及 TGS
的票证
3 请求Bob的票证
ii
AS
E
lS
4.A l ice与 Bob之间的会
活峦钥以及Bob的票证
5 请求服务
6 提供服务
Bob (服务器)
图 3 1. 21
Kerberos服务器
发布票证。它还提供Alice和 Bob之间的会话密钥
(KAB )
0
Kerberos将用户验证与票证发
布分离开来。通过这种方式，尽管 Alice只与 AS验证了一次她的 ID ，但是她可以与TGS
联系多次以获得不同的实际服务器的票证。
·实际服务器
(Bob) 为用户
(Alice) 提供服务。
Kerberos设计成一个诸如 FTP的客户/服
务器的程序，用户可以采用客户端进程访问服务器进程。
Kerberos不是用来进行人对人
的鉴别的。
操作
客户端进程
(Alice) 可以通过六个步骤，访问运行在实际服务器上的进程，如图
3 1. 22所示。
·步骤 10
Alice用明文向 AS发送她的请求，使用的是她注册的身份。
·步骤 20
AS发送一份用 Alice的对称密钥 KA加密过的报文。该报文包括两项：一份 Alice
用来与TGS联系时所使用的会话密钥矶和一张TGS 的票证。该票证是用 TGS的对称密钥
KTG加密的。
Alice不知道KA' 但是当报文到这时，她输入她的口令。如果口令正确，口
令和相应的算住一起会生成凡，口令立即被销毁，它不发送给网络，也不驻留在终端，
它只是暂时用来生成凡。现在，进程使用 KA来解密发送的报文，从而得到 Ks和票证。
·步骤 3 。现在，
Alice 向 TGS发送三项内容。第一项是从AS接收的票证，第二项是实际服
务器
(Bob) 的名称，第三项是采用 Ks1J口密的时间戳。时间戳用来制止Eve的重放攻击。
·步骤4。现在，
TGS发送两张票证，每张都包括Alice和Bob之间的会话密钥 KAB。给Alice
的票证采用 Ks加密，给Bob的票证采用 Bob的密钥 KB进行加密。住意 ：
Eve无法得到 KAB'
因为她不知道 Ks或KBo 她不能重放步骤 3 ，因为她无法用新的时间戳(她不知道 Ks ) 来
652
第七部分网络安全
替换真正的时间戳。即使她很快，即在时间戳超时之前发送了步骤 3 的报文，她得到的
仍然是相同的她无怯解密的两张票证。
·步骤 50
Alice发送Bob的带有用 KAB加密的时间戳的票证。
·步骤6 0 Bob 通过将时间戳加 l 来确认接收。报文用 KAB加密后发送给Alice 。
服务器
(Bob)
Alice
国 国
图 31.22
Kerberos实例
使用不同的服务器
注意：如果Alice需要从不同的服务器接收服务，那么她只需要重复
最后的四步(步骤 3- 步骤 6) 。最初的两步已经验证了 Alice的身份，不需要重复。
Alice通过
重复步骤3- 步骤 6 ，就可以让TGS发布多个服务器的票证。
领域
Kerberos允许AS和TGS 的全球发布，每个系统称为一个领域
(realm) 。用户可以
获得本地服务器或远程服务器的票证。例如，在第二种情况下，
Alice可能要求她的本地TGS
发行一张由远程TGS接收的票证。如果该远程TGS在本地TGS 中进行了注册，那么本地TGS 可，
以发布这张票证，
Alice从而可以使用该远程TGS来访问远程的实际服务器。
31.7.2
公钥分发
在非对称密钥密码学中，人们不需要知道对称共享密钥。如果 Alice想给 Bob发送报文，
她只需要知道 Bob的公钥，该公钥是公开的，任何人都能得到。如果Bob想给Alice发送报文，
他只需要知道 Alice的公钥，她的公钥也是任何人都知道的。在公钥加密中，每个人都隐藏私
钥，并将公钥公开发布。
在公钥密码学中，任何人都可以访问其他人的公钥，公钥是公开发布的。
公钥像秘密密钥一样为应用需要而分发，让我们简要讨论公钥分发的方法。
公钥发布
最简单的方陆是公开发布公钥。
Bob可把他的公钥放在他的Web网站或在本地的与全国的
报纸上公布。当 Alices 向 Bob发送保密报文时，她从Bob的网站或报纸上得到他的公钥，甚至
她可以发报文询问。图 3 1. 23表示这种情形。
第 31 章网络安全服务
653
但是，这种方越是不安全的，会遭受到假冒。例如，
Eve可将她自己的公钥作为 Bob公钥
的一个公开的发布，在 Bob做出反应前，破坏可能发生。
Eve可氓淆 Alices发给 Bob的报文。
Eve也可用一个相应的私钥签名一个文档，使每个人相信文档是 Bob签名。如果 Alices直接向
Bob 询问公钥，也易受到攻击。
Eve可截取Bob的应答，用她的公钥取代 Bob的公钥。
可倍任中心
一个更安全方法要有一个可信任中心保存公钥的目录，这个目录像电话搏一样是动态更
新的。每个用户可选取一个私钥/公钥对，保留私钥并将公钥插入目录。可信任中心要求每个
用户在中心注册井检验他或她的身份。目录可由可信任中心公开发布，中心也应答有关公钥
的查问。图 3 1. 24表示了这个概念。
' '
、
I
,
飞
I
!
••
I
、、.
/
<iÞ
、、、
I
I
_,'
、.、、
I
, "
、、、、
"，'
,.
'"
,·
,,.
,,.
,'J-
4·''·
、
，明月
1L
叫e
·e.
, ••
B?M3M
,
h, ••
，EE舅
•••
-\i
、、、·.
、、.
、、、.·
、.
、.
、"
、·
目录
Bob
E
可信任中心
图 3 1.24
可信任中心
图 3 1. 23
发布公钥
受控制的可信任中心
如果对公钥的分发增加一些控制，那么可以得到更高级的安全。公钥发布可包括时间戳和
权威机构的签名从而可防止应答的截取与修改。如果Alices需要知道Bob的公钥，她可以向中心
发送一个包括Bob名和时间戳的一个请求。中心用 Bob公钥应答原有的请求而时间戳用中心的私
钥签名。
Alices使用大家都知道的中心公钥解密报文并获得Bob公钥。图 3 1. 25表示了这种情况。
Alice
图 3 1. 25
受控制的可信任中心
认证中心
如果请求的个数很多，前述的方怯在中心形成沉重的负担，另一种选择创建公钥的认证。
654
第七部分网络安全
Bob需要做两件事情：他需要人们知道他的公钥，他还需要确保任何人无故获得以 Bob名义伪
造的公钥。
Bob可以去认证中心
(certification authority, CA) ，认证中心是一个联邦或州级组
织，用来将公钥与实体绑定，并且发布一份证书。该CA本身有一个众所周知的无法伪造的公
钥。
CA核实 Bob的身份
(identication)
(采用图片 ID和其他证据)。然后向 Bob索要公钥井将
其写在证书上。为防止证书被伪造，
CA根据证书生成一份摘要并用它的私钥对摘要进行加密。
现在Bob可以上传明文形式的证书和加密后的报文摘要。任何人只要想得到)Bob的公钥，都可
以下载证书和加密后的摘要。然后根据证书生成摘要，并使用 CA的公钥对加密的摘要进行解
密。对两份摘要进行比较，如果它们相等，就说明证书是有效的，没有冒充者假装 Bob 。图
3 1. 26表示这个概念。
目录
图 3 1.26
认证中心
X.509
尽管采用 CA解决了伪造公钥的问题，但是它出现了副作用。每份证书可能有不同
的格式。如果Alice想使用程序自动下载属于不同人的不同的证书和摘要，程序可能无法做到这
一点。一份证书中的公钥可能是一种格式，另一份可能又是另一种格式。公钥可能在一份证书
中位于第一行，在另一份中就有可能位于第三行。任何要普遍使用的事物都必须有统一的格式。
要消除这种副作用，
ITU制定了一个称为 X.509的协议，该协议经过一些修改已经被因特
网所采纳。
X.509协议采用结构化方式描述证书的规范。它使用一个熟知的称为 ASN.l 的协议
来定义C程序员非常熟悉的宇段。
·版本。这个字段定义认证X.509的版本号。版本号从0开始，现在的版本号是2
(第3版本)。
·系列号。这个字段定义赋给每个证书的一个号码，其值对每个发出的证书是唯一的。
·签名。这个字段标识签名证书所用的算棒，名字是不适当的。为这个签名所需的参数也
在这个字段定义。
·签发者。这个字段定义发布证书的认证中心的名称。该名称通常是一个由国家、州、组
织机构和部门等定义的有层次的串。
·有效期。这个字段定义证书有效期的起始和结束时间。
·主体。这个字段定义公钥所有者的实体，它也是一个层次串。宇段部分定义了称为公用
名的字段，它是密钥的观看者真实名。
·主体的公钥。这个字段定义主体的公钥，证书的核心。这个字段也定义主体的算撞(例
如，
RSA) 和它的参数。

655
·签发者唯一的标识符。这是一个可选宇段，它允许两个发布者具有相同的发布者宇段的
值，如果发布者唯一的标识符是不同的。
·主体唯一的标识符。这个可选字段允许两个主体具有相同的主体字段的值，如果主体唯
一的标识符是不同的。
·扩展项。这个字段允许发布者为证书增加更多的私有信息。
·加密。这个字段包含算怯标识符、其他宇段的安全散列和该散列的数字签名。
公钥基础设施
(PKI)
当人们想统一地使用公钥时，会遇到一个类似于密钥分发的问题。人们发现不能仅有一
个KDC来应答请求，而是需要很多服务器。另外，人们发现最佳方案是将服务器配置为层次
关系。类似地，公钥查询的一种解决方案是采用称为公钥基础设施
(public key infrastructure,
PKI)的层次化结构。图 3 1. 27表示了这种层次结构的例子。
图 3 1. 27
PKI层次结构
在第一级中，拥有一个根CA来验证第二级CA ，这些 1 级的CA可以在一个很大的地理区域
或逻辑区域的范围内运作。
2级的 CA可以在一个相对较小的地理区域内运作。
在这个层次结构中，每个人都信任根节点。但人们可以信任也可以不信任中间的 CA 。如
果Alice需要得到jBob的证书，她可以找发布该证书的某个地方的CA ，但Alice不一定信任该CA 。
在层次结构中，
Alice可以通过上一级CA来验证原始的 CA 。该查询可以一直进行到根CA 。
