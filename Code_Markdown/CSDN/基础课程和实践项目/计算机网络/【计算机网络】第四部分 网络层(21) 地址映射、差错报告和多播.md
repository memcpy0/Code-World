@[toc]


对于下图中的网络：
![在这里插入图片描述](https://img-blog.csdnimg.cn/35b9dd6f06364f39a3fd68147aef458d.png)
从协议栈的层次上看数据的流动：
![在这里插入图片描述](https://img-blog.csdnimg.cn/a08360094b424b068f5a60872f2ab5ef.png)
从虚拟的IP层上，只能看到IP数据报的流动，路由器只根据**目的站IP地址的网络号**进行路由选择：
![在这里插入图片描述](https://img-blog.csdnimg.cn/1392ce1a11044700b14261299bd1d1e3.png)
在具体的物理网络的链路层，则只能看见MAC帧的流动，而看不见IP数据报：
![在这里插入图片描述](https://img-blog.csdnimg.cn/bcc9bb187b794951b5cd0c8cb5dbcdb8.png)

在第20章中讨论了网络层的主要协议——网际协议 `IP`，它被设计为尽力传递协议，没有如流控制和差错控制等一些特性，**它是使用逻辑寻址的主机到主机的协议**。==IP层抽象的互联网屏蔽了下层很复杂的细节，我们现在在抽象的网络层上讨论问题，就能够使用统一的、抽象的IP地址，研究主机和主机或主机和路由器之间的通信==。

然而，为了使IP协议满足今天的网际互连的更多需求，还需要其他协议的帮助。
- 一些协议需要用来创建**物理地址和逻辑地址之间的映射**——**IP分组使用逻辑地址（主机到主机）**，而这些分组需要封装成帧，**帧需要物理地址（节点到节点）**。为此而设计的一个协议称为**地址解析协议** `Address Resolution Protocol, ARP` ，它完成逻辑地址到物理地址的映射。有时我们还需要逆映射，即物理地址到逻辑地址。例如，为引导一个无盘网络或给主机租用IP地址的目的，设计了三个协议：RARP、BOOTP、DHCP。
- 网际协议缺少流控制和差错控制，从而产生了另一个协议：ICMP，**它提供差错警告，报告在网络上或目的端、发生拥塞和差错的类型**。
- IP最初是为单播传送而设计的，即一个源端和一个目的端。由于因特网对多播传送的极大需求，也就是一个源端和多个目的端。因此，**IGMP提供了IP的一种多播能力**。

这里将在某些方面详细讨论ARP、RARP、BOOTP、DHCP和IGMP等协议，也讨论ICMPv6，当IPv6运行时它将也运行。**IMCPv6将ARP、ICMP和IGMP合并在一个协议中**。
```cpp
ARP和RARP的讨论可在下列请求评论中找到:
826, 903, 925, 1027, 1293, 1329, 1433, 1868, 1931, 2390
BOOTP和DHCP的讨论可在下列请求评论中找到:
951, 1048, 1084, 1395, 1497, 1531, 1532, 1533, 1534, 1541, 1542, 2131, 2132
ICMP的讨论可在下列请求评论中找到:
777, 792, 1016, 1018 , 1256, 1788, 2521
IGMP的讨论可在下列请求评论中找到:
966, 988, 1054, 1112, 1301, 1458, 1469, 1768, 2236, 2357, 2365, 2502, 2588
```

---
# 21.1 地址映射
互联网是由一些物理网络和网际互联设备（如路由器）所组成。从源主机发送的分组在到达目的主机之前，可能要经过许多不同的物理网络。==在网络级上，主机和路由器用它们的逻辑（IP）地址进行标识==。但是分组都要通过物理网络到达这些主机和路由器。==在物理级上，主机和路由器用它们的物理地址标识==。
![在这里插入图片描述](https://img-blog.csdnimg.cn/d0af718391d44b19a70a4cf52abe62aa.png)
**物理地址** `physical address` 就是本地地址，它的管辖范围是本地网络。物理地址在本地范围内是唯一的，但在全局上并不必如此，之所以称为**物理地址**，是由于**物理地址通常（并非永远）是用硬件实现的**。物理地址的例子是以太网协议中48位的MAC地址，它被写入在主机或路由器的网卡 `NIC` 上。

物理地址和逻辑地址是两种不同的标识符。这两个我们都需要，==因为一个物理网络，如以太网可以在同一时间在网络层使用两个不同的协议，如IP和IPX（Novell）==；同样的，==在网络层的分组，使用IP，也可以通过不同的物理网络，如以太网和LocalTalk（Apple）传输==。

这就是说，将分组传递到一台主机或路由器，需要两级地址：逻辑地址和物理地址。既需要能将一个逻辑地址映射成为它相应的物理地址，反过来的映射也是需要的，这可使用静态和动态映射。
- **静态映射** `static mapping` 是创建一个表，它将一个逻辑地址与物理地址联系起来，这个表存储在网络上的每个机器上。例如，每个机器知道其他机器的IP地址，但却不知道其物理地址，可通过查表得知物理地址。==这样做有某些局限性，因为物理地址可能因以下原因而发生变化==。
	（1）一个机器可能会更换网卡，结果得到了一个新的物理地址；
	（2）在某些局域网中，如LocalTalk，每当计算机加电时，其物理地址都要改变一次。
  （3）移动的计算机，可以从一个物理网络转移到另一个物理网络，这就引起物理地址的改变。要完成这些变化，静态映射必须周期性地改变，这给网络增加了非常大的开销。

- **动态映射** `dynamic mapping` 中，每当一个机器知道两个地址（逻辑地址和物理地址）中的一个时，就可使用协议将另一个求出。

## 21.1.1 逻辑地址到物理地址的映射：ARP
任何时候，当主机或路由器有数据报要发送到另一个主机或路由器时，它必须有接收方的逻辑（IP）地址。**如果发送方是主机，它可从DNS求得逻辑地址**（见25章）；**如果发送方是路由器，它可从路由选择表求得**（见22章）。但是，**IP数据报必须封装成帧，才能通过物理网络**，即发送方必须有接收方的物理地址——==不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址==。

==主机或路由器发送一个ARP查询分组，该分组包括发送方的物理地址和IP地址、以及接收方的IP地址，**因为发送方不知道接收方的物理地址，查询将在网络上广播**==（图21.1）。网络上的每个主机或路由器，都接收和处理这个ARP查询分组，但只有预期的接收者才能识别它的IP地址，并发回ARP响应分组，**这个分组使用「接收到的查询分组中的物理地址」，直接用单播发送给查询者。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/e0506bf61d414c4b8ec024e389924041.png)
图21.1a中，左边系统 $A$ 有一个分组，要传递给IP地址为 `141.23.56.23` 的另一个系统 $B$ 。系统 $A$ 需要将分组传送给它的数据链路层，进行实际的传递，但它不知道接收方的物理地址。它使用ARP服务，请求ARP协议发送一个广播ARP请求分组，以查询IP地址为 `141.23.56.23` 的系统的物理地址。

在该物理网络上的每个系统，都接收到此分组，但只有系统 $B$ 才回答，如图21.1b所示，系统 $B$ 发送一个包含它的物理地址的ARP回答分组。现在，系统 $A$ 可使用接收到的物理地址，来发送到该目的地的所有分组。
![在这里插入图片描述](https://img-blog.csdnimg.cn/d04773c6e8f3420fbb4822300be0de14.png)
应注意的问题是，==ARP解决的是**同一个局域网上的主机或路由器**的IP地址和硬件地址的映射问题==。如果所要找的主机和源主机不在同一个局域网上，那么就要通过ARP，找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。==从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的==，只要主机或路由器要和本网络上的、另一个已知IP地址的主机或路由器进行通信，ARP协议就会自动地将该IP地址，解析为链路层所需要的硬件地址。

**为什么不直接使用硬件地址进行通信**？原因是，==由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信，就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事==。现在，**由于连接到因特网的主机都拥有统一的IP地址，它们之间的通信，就像连接在同一个网络上那样简单方便**，而调用ARP来寻找某个路由器或主机的硬件地址，都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。
### 1. （ARP）高速缓存器
如果系统 $A$ 对发送到系统 $B$ 的每个分组，都需要广播一个ARP请求，那么对ARP协议的使用就是低效率的。它可能有对自己IP分组的广播。为了解决这一问题，ARP协议可使用高速缓存器，因为一个系统通常发送多个分组到同一目的地（局部性原理）。

每一个主机都设有一个**ARP高速缓存** `ARP cache` ，里面存储有其所在的局域网上的、各主机和路由器的、IP 地址到硬件地址的映射表。==接收到ARP回答的系统，将它的映射存储在高速缓存器中，保持20分钟到30分钟（除非高速缓存已满）==。**在以后发送ARP请求之前，系统先在它的高速缓存器中检查，是否可找到它的映射**。

例如，当主机 $A$ 欲向本局域网上的某个主机 $B$ 发送IP数据报时，就先在其ARP高速缓存中查看，有无主机 $B$ 的IP地址。如有，就可查出其对应的硬件地址。再将此硬件地址写入MAC帧，然后通过局域网，将该MAC帧发往此硬件地址。

### 2. ARP分组格式
图21.2表示了ARP的分组格式：
![在这里插入图片描述](https://img-blog.csdnimg.cn/866a3a2c6f9b45a9a78321821837f831.png)
ARP分组具有下列字段：
- **硬件类型**。16位字段，用来定义**运行ARP的网络类型**。每个局域网基于其类型被指定一个整数。例如，以太网是类型 $1$ 。==ARP可使用在任何物理网络上==。
- **协议类型**。16位字段，用来定义**协议的类型**。例如，对于IPv4协议，这个字段是 $0800_{16}$ 。==ARP可用于任何高层协议==。
- **硬件长度**。8位字段，用来定义**以字节为单位的物理地址的长度**。例如，对于以太网，这个值是 $6$ 。
- **协议长度**。8位字段，用来定义**以字节为单位的逻辑地址的长度**。例如，对于IPv4协议，这个值是 $4$ 。
- **操作**。16位字段，用来定义**分组的类型**。已定义了两种类型：ARP请求 $1$ 和ARP回答 $2$ 。
- **发送方硬件地址**。可变长字段，用来定义**发送方的物理地址的长度**。例如，以太网这个字段是 $6$ 字节。
- **发送方协议地址**。可变长字段，用来定义**发送方的逻辑地址的长度**。例如，对于IPv4协议，这个字段是 $4$ 字节。
- **目标硬件地址**。可变长字段，用来定义**目标的物理地址的长度**。例如，对以太网这个字段是 $6$ 字节。对ARP请求报文，这个字段为全 $0$ ，因为发送方不知道目标的物理地址。
- **目标协议字段**。可变长字段，用来定义**目标的逻辑地址的长度**。例如，对于IPv4协议，这个字段是 $4$ 字节。

### 3. ARP封装成帧
**ARP分组是直接封装在数据链路帧中**。例如图21.3中，ARP分组封装在以太网的帧中。注意，类型字段指明了此帧所携带的数据是ARP分组。
![在这里插入图片描述](https://img-blog.csdnimg.cn/0864d45425c849169beb5cbec70b475c.png)
### 4. 操作过程
讨论在一个典型的互联网上，ARP是如何工作的。首先，描述所包含的一些步骤，然后讨论主机或路由器所需要使用ARP的四种情况。在ARP过程中，需要进行如下几个步骤：
1. 发送方知道目标的IP地址。我们将简要考察发送方如何得到这个地址；
2. IP请求ARP协议产生一个ARP请求报文，填入发送方的物理地址、发送方的IP地址、目标的IP地址。目标的物理地址字段则填入 $0$ ；
3. 将这个报文发送给数据链路层，在这个层它被封装成帧，**使用发送方的物理地址为源地址，而将物理广播地址作为目的地址**；
4. 每个主机和路由器都接收到这个帧。因为这个帧包含了广播目的地址，所以所有站点都将此报文送交给ARP。除了目标机器外，所有的机器都丢弃该分组。目标机器识别这个IP地址；
5. 目标机器用ARP回答报文进行应答，此回答报文包含它的物理地址。报文使用单播；
6. 发送方接收到这个回答报文，它现在知道了目标机器的物理地址；
7. 携带发送给目标机器数据的IP数据报，现在封装成帧，用单播发送给目的端。

下列是可使用ARP服务的四种不同的情况（图21.4）：
1. 发送方是一个主机，它希望将分组发送给同一个网络上的另一个主机。在这种情况下，~~必须将物理地址映射为逻辑地址，并将该逻辑地址作为数据报头部的目的IP地址~~ ==它将要发送的数据报头部的目的IP地址，就是必须映射为物理地址的那个逻辑地址==；
2. 发送方是一个主机，它希望将分组发送给另一个网络上的另一个主机。在这种情况下，该主机查找它的路由表，找出到达这个目的地的下一跳（即路由器）的IP地址。如果该主机没有路由表，它就要查找默认路由表的IP地址。==这个下一跳路由器的IP地址，就是必须映射为一个物理地址的那个逻辑地址==；
3. 发送方是一个路由器，它已经接收到了一个数据报，要将该数据报发送给另一个网络上的一个主机。它先检查它的路由表，找出下一跳（即路由器）的IP地址。==这个下一跳路由器的IP地址，就是必须映射为物理地址的那个逻辑地址==。
4. 发送方是一个路由器，它已经收到了一个数据报，要将该数据报发送给同一网络上的一个主机。==数据报的目的IP地址，就是必须映射为物理地址的那个逻辑地址==。 
![在这里插入图片描述](https://img-blog.csdnimg.cn/a5d890b071804e0fa328642a3133d0ee.png)

【例21.1】一个主机的IP地址为 $130.23.43.20$ ，物理地址为 $B2:34:55:10:22:10$ ，它有一个分组想要发送给另一个主机 ， 其IP地址为 $130 . 23 . 43 . 25$ ， 物理地址为 $A4:6E:F4:59:83:AB$（第一个主机并不知道该物理地址） 。两个主机在同一个网络上。试说明ARP请求与回答分组如何封装在以太网帧中。
答：图21.5显示了ARP请求与回答分组。注意：此时ARP数据字段是28个字节，而单个地址不适合用4字节表示界限，这就是我们为什么不以4字节界限表示这些地址。
![在这里插入图片描述](https://img-blog.csdnimg.cn/bceee5c1c41a457b89a7914faad03d4f.png)
### 5. 代理ARP
有一种称为**代理ARP**的技术，可用来产生子网化的效果。**代理ARP** `proxy ARP` 是可以代表一组主机的ARP。每当运行代理ARP的路由器，接收到一个寻找这些主机中的一个主机的IP地址的ARP请求时，路由器就发送一个ARP回答，宣布**它自己的硬件（物理）地址**。当这个路由器收到真正的IP分组后，它就将这个分组发送给相应的主机或路由器。

图21.6中给出一个实例。安装在右边的主机只回答目标IP地址为 $141.23.56.23$ 的ARP请求。但是，管理员可能需要创建一个子网、而不改变整个系统来识别出子网的地址。一个解决问题的方法是，==**增加一个运行代理ARP的路由器**，在这种情况下，这个路由器代表所有安装在子网上的主机==。当路由器接收到一个ARP请求时，如果其目标IP地址与「它所代表的主机之一的地址」相匹配（$141.23.56.21, 141.23.56.22, 141.23.56.23$），则它发送一个ARP回答，并宣布其硬件地址作为目标硬件地址；当该路由器收到IP分组，它就将该分组发送给相应的主机或路由器。
![在这里插入图片描述](https://img-blog.csdnimg.cn/5209bd2ae7dc44249865ce11115a3f13.png)

## 21.1.2 物理地址映射到逻辑地址：RARP、BOOTP、DHCP
有两种可能的场合，当一个主机知道它的物理地址，但不知道其逻辑地址：
1. 无盘站点正在被引导，站点可以通过检查其接口，得到它的物理地址，但不知道它的逻辑地址；
2. 一个组织机构没有足够的IP地址分配给每个站点，只能按需分配。站点可发送它的物理地址，并请求延续一个短暂的时间。

### 1. RARP
**反向地址解析协议** `Reverse Address Resolution Protocol, RARP` 是为仅知道物理地址的机器，寻找它的逻辑地址而设计的。==每个主机或路由器都被指定一个或多个逻辑（IP）地址，这些地址是唯一的，并与机器的物理（硬件）地址无关==。

要创建一个IP数据报，主机或路由器就要知道它自己的IP地址，一个机器的IP地址，通常可从存储在磁盘文件中的配置文件中读出。但是，一个无盘机器通常是从ROM引导的，ROM只有少量的引导信息。ROM是由厂商安装的，它不包括IP地址，因为在网络上的IP地址是由管理员分配的。

机器可以得到其物理地址（例如，读它的NIC），这在本地是唯一的。然后就可以使用RARP协议，从物理地址获取逻辑地址。先是创建一个RARP请求，并在**本地网络**上广播。在本地网络上，知道所有IP地址的另一个机器就用RARP回答来响应。==**请求的机器必须运行RARP客户程序，而响应的机器必须运行RARP服务器程序**==。

==RARP协议有一个严重的问题：在数据链路层进行广播，其广播地址在以太网中是全 $1$ ，而且不能通过网络边界==。即，**如果网络管理员有多个网络或多个子网，就需要为每个网络或子网指定一个RARP服务器**。正是这个原因，使得RARP几乎不再使用，而被BOOTP和DHCP两个协议取代。

### 2. BOOTP
**引导程序协议** `Bootrap Protocol, BOOTP` 是一种**客户机/服务器协议**，使用BOOTP协议时，一般包括自举协议服务端 `Bootstrap Protocol Server` 和自举协议客户端 `Bootstrap Protocol Client` 两部分。设计这个协议是为了提供**物理地址到逻辑地址的映射**，它可以让无盘站点从一个中心服务器上获得IP地址，为局域网中的无盘工作站分配动态IP地址，并不需要每个用户去设置静态IP地址。

要注意的是，**BOOTP是一个应用层协议**，网络管理员可以将客户机和服务器放置在同一网络或不同网络上，如图21.7所示。==**BOOTP报文被封装在UDP分组中**，而UDP分组本身被封装在IP分组中==。

当客户机既不知道它自己的IP地址（源地址），也不知道服务器的IP地址（目的地址）时，它是如何发送IP数据报的？**客户机简单地使用全 $0$ 作为源地址，全 $1$ 作为目的地址**。客户机获取IP地址的过程如下：
- 首先，由BOOTP启动代码启动客户端，这个时候客户端还没有IP地址；
- 客户端使用广播形式，以IP地址 $255.255.255.255$ 向网络中发出IP地址查询要求；
- 接着，运行BOOTP协议的服务器接收到这个请求，会根据请求中提供的MAC地址找到客户端，并发送一个含有IP地址、服务器IP地址、网关等信息的FOUND帧；
- 最后，客户端会根据该FOUND帧，通过专用TFTP服务器下载启动镜像文件，模拟成磁盘启动。

BOOTP优于RARP的一点是：==客户机与服务器都是应用层的进程，当在其他应用层进程中时，客户机可以在一个网络上，而服务器在相隔多个其他网络的另一个网络上==。但是，必须要解决一个问题，因为客户机不知道服务器的IP地址，所以**BOOTP请求是广播的**，而**广播的数据报不可能通过任何路由器**。

解决这个问题==必须要有一个中间媒介==，可以用一个主机（或者配置为在应用层操作的一个路由器）作为中继。在这种情况下，该主机称为**中继代理** `relay agent` ，==中继代理知道BOOTP服务器的单播地址==。当它接收到这种类型的分组时，它在单播的数据报中封装报文，并向BOOTP服务器发送请求。**任何一台路由器，都可以路由携带单播目的地址的分组，并传送到BOOTP服务器**。BOOTP服务器知道来自中继代理的报文，因为在请求报文中有一个字段定义了中继代理的IP地址。在接收到回答之后，中继代理向BOOT客户机转发它。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2122f678899d42128c2b2b23d306e70c.png)

BOOTP不是一个**动态配置协议** `dynamic configuration protocol` 。当客户机请求其IP地址时，BOOTP服务器查找一个表，寻找与客户机物理地址相匹配的IP地址。这意味着，==客户机的物理地址与IP地址的绑定必须已经存在，绑定是预先确定的==。

但是，如果一个主机从一个物理网络移动到另一个物理网络时，情况又如何？如果主机想要一个临时的IP地址又如何？==BOOTP不能处理这些问题，因为表中的物理地址和IP地址的绑定，在网络管理员改动之前，是静态的、固定的，BOOTP是一个**静态配置协议**==。
### 3. DHCP
**动态主机配置协议** `Dynamic Host Configuration Protocol, DHCP` 已设计出来，提供静态的和动态的地址配置，可以是人工的或自动的。DHCP是一个局域网的网络协议，和BOOTP一样使用UDP协议工作，主要有两个用途：给**内部网络或网络服务供应商**自动分配IP地址；给**用户或内部网络管理员**作为对所有计算机作中央管理的手段，在[**RFC 2131 Dynamic Host Configuration Protocol**](https://www.rfc-editor.org/info/rfc2131)中有详细的描述。
- **静态地址配置**：这种DHCP的性能与BOOTP相同，它与BOOTP向后兼容，即一个运行BOOTP客户机的主机，可以向一个DHCP服务器请求一个静态地址。**DHCP服务器有一个数据库，静态地绑定物理地址和IP地址**。
- **动态地址配置**：DHCP有第二个数据库，它拥有一个可用的IP池，这一个数据库使DHCP成为动态的。当DHCP客户机请求一个临时的IP地址时，DHCP服务器就查找可用的（即尚未使用的）IP地址池，然后指定一个在**可协商的期间内**有效的IP地址。
当DHCP客户机向DHCP服务器发送请求时，**服务器首先检查它的静态数据库**，如果其中存在所请求的物理地址的项目，则返回**该客户的永久IP地址**。反之，如果静态数据库中没有该项目，服务器就从可用的IP地址池中，**选择一个IP地址，并将这个地址指定给该用户**，然后将该主机加到动态数据库中。即 ==**首先静态查找，其次动态分配**==。
当主机从一个网络移到另一个网络，或连接到一个网络后又断开连接时（如同一个用户和服务提供者的关系），DHCP是需要动态的，**DHCP在有限的期间提供临时IP地址**。
从可用IP地址池指定的地址是临时地址，DHCP服务器发出**租用** `lease` 是对特定期间而言的。**当租用期到时，客户机或停止使用这个IP地址，或更新其租用**。服务器对这个更新选择同意或不同意。如果服务器不同意，客户机就停止使用该地址。
- 人工的和自动的配置。BOOTP协议的一个主要问题是「人工配置IP地址到物理地址的映射表」。即，每当物理或IP地址有变化时，网络管理员必须人工地修改。而DHCP协议则既允许人工配置，也允许自动配置，即静态地址可人工创建也可自动创建。

DHCP有3个端口，其中UDP67和UDP68为正常的DHCP服务端口，分别作为 `DHCP Server` 和 `DHCP Client` 的服务端口；546号端口用于 `DHCPv6 Client` ，而不用于 `DHCPv4` ，是为`DHCP failover` 服务，这是需要特别开启的服务，是用来做“双机热备”的。


---
# 21.2 ICMP
如20章所述，IP协议是一个**尽力传递的服务**，它将一个数据报从它原始的源端传递到最终的目的端。IP提供了**不可靠、无连接的数据报传递**，这样的设计是为了有效地利用资源。但是它有两个缺点：缺少差错控制和辅助机制。
- **IP协议没有差错报告或差错纠正机制**，如果出现某些差错将会发生什么？如果路由器找不到一个可以到达最终目的端的路由器，或者因生存时间字段为 $0$ 、而必须丢弃一个数据报时，将会发生什么？如果最终目的主机在预先设定的时间内，不能收到所有的数据报分段，因此将一个数据报的全部分段都丢弃时，又会发生什么？这些情况中都出现了差错，而IP协议没有内在的机制，可以通知发送该数据报的主机。
- **IP协议还缺少一种为主机和管理员提供查询能力的机制**。主机有时需要确定一个路由器或另一个主机是否是活跃的，网络管理员有时需要从另一个主机或路由器得到信息。

为了提高IP数据报成功交付的机会、弥补上述两个缺陷，网际层的**因特网控制报文协议** `Internet Control Message Protocol, ICMP` 被设计出来，它是TCP/IP协议族的一个子协议，配合IP协议进行使用，用于**在主机、路由器之间传递控制消息**。ICMP允许主机或路由器报告差错情况和有关异常情况，其功能主要有：
- 侦测远端主机是否存在
-  建立及维护路由资料 
- 重导资料传送路径（ICMP重定向）
- 资料流量控制

> 控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

ICMP不是高层协议，而是IP层的协议。**ICMP报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发送出去**。
## 21.2.1 报文类型
ICMP报文分为两大类：**差错报告报文** `error-reporting message` 和**查询报文** `query message` ：
- 差错报告报文负责向路由器或主机报告，在处理一个IP数据报时可能碰到的一些问题。
- **查询报文是成对出现的**，帮助主机或网络管理员从一个路由器或另一个主机得到特定的信息。例如，节点能够发现它们的邻站。此外，主机能够发现和知道「在它们的网络上的一些路由器的情况」，而一些路由器能帮助一个节点改变报文的路由。

## 21.2.2 报文格式
ICMP报文有一个 **$8$ 字节的头部**和一个**可变长的数据部分**。虽然每一种报文类型的头部的格式都是不同的，但是**最前面的 $4$ 字节对所有类型都是统一的格式**，即类型、代码和检验和——第一个字段（$1$ 字节）是ICMP的类型，它定义**报文的类型**。代码字段（$1$ 字节）指定了**发送此特定报文类型的原因**，最后一个共同的字段（$2$ 字节）是校验和字段，**头部其余部分对每种ICMP报文类型都是特定的**。如图21.8所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/fd3f0265aa1249bf9d7e6b099e1a2c3a.png)

在差错报文的数据部分所携带的信息，可找出引起差错的原始分组。在查询报文的数据部分，则携带了基于查询类型的额外信息。

## 21.2.3 差错报告
ICMP的主要责任之一就是差错报告。虽然现代技术已经制造出很可靠的传输介质，但差错还是存在的，因此必须进行处理。如在第20章中讨论的，IP是不可靠、无连接、尽力传递的协议，即IP不考虑差错校验、报告和差错控制，ICMP就是为弥补这一缺点而诞生的。然而，==ICMP不能纠正差错，它只是报告差错，**差错纠正留给高层协议去完成**==。

**在ICMP中，差错报文总是发送给原始的源端**，因为在数据报中关于路由唯一可用的信息，就是源IP地址和目的IP地址。ICMP使用源IP地址，将差错报文发送给数据报的源端（发送方）。

ICMP差错报告报文共有 $5$ 种：目的端不可达、源端抑制、时间超过、参数问题、改变路由（重定向）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/293a465cd7b54ba09257ac26fc56c5e7.png)
关于ICMP差错报文有下列要点：
- ==对于携带ICMP差错报文的数据报，不再产生ICMP差错报文==；
- ==对于分段的数据报文，如果不是第一个分段则不产生ICMP差错报文==；
- 对于多播地址的数据报文，不产生差错报文；
- 具有特殊地址，如 $127.0.0.0$ 或 $0.0.0.0$ ，不产生ICMP差错报文。

注意，所有差错报文都包括一个**数据部分**，这个数据部分包括**原始数据报的头部**+**原数据报中前 $8$ 个字节的数据**——加上原始数据报中的头部，可以给出原始的源端地址，它接收差错报文，这就是关于数据报本身的信息；加上 $8$ 个字节，是因为这 $8$ 个字节提供了关于端口号（UDP和TCP）和序列号（TCP）的信息，这些将在23章中学到，==有了这些信息，源端就可以将差错情况通知给协议（TCP或UDP）==。ICMP形成差错分组，然后再封装成IP数据报（见图21.10）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/32af01bb191b44fe8283d46a98108e24.png)

### 1. 目的端不可达
当路由器不能够给数据报找到路由，或主机不能传递数据报时，就丢弃这个数据报。然后，这个路由器或主机就发回**目的端不可达报文** `destination-unreachable message` 给发出该数据报的源主机。注意，==目的端不可达报文或者由路由器，或者由目的主机创建==。

### 2. 源端抑制
IP协议是一个无连接协议。在产生数据报的源端，转发数据报的路由器以及处理数据报的目的主机之间，并没有通信关系。这种由于缺乏通信，引起的一个问题就是**缺少流量控制**。IP在协议中没有嵌入流量控制机制。在运行IP时，缺乏流量控制会产生的一个主要问题**拥塞**。源主机从来不知道某些路由器或目的主机，是否已经被过多的数据报造成超载；源主机从来不知道它产生的数据报是否太快，以至于路由器来不及转发或目的主机来不及处理。

==缺乏流量控制，可能会在路由器或目的主机中产生拥塞==。路由器或主机中的队列长度（缓存）是有限的，这种队列是为到来的数据报等待转发（对于路由器）或等待处理（对于主机）而设置的。**如果数据报的接收速率比它们被转发或处理的速率快得多，则队列会溢出**，这时路由器或主机别无选择，只能将某些数据报丢弃。

ICMP的**源端抑制报文** `source-quench message` 就是**为了给IP增加一种流量控制机制**而设计的。==当路由器或主机因拥塞而丢弃数据报时，它就向数据报的发送方发送源端抑制报文==，这一报文有两个目的——第一，**它通知源端数据报已被丢弃**；第二，**它警告源端，在路径的某处出现拥塞，因而源端必须放慢（抑制）发送过程**。

### 3. 时间超时
**时间超时报文** `time-exceeded message` 是在两种情况下产生的：
- 其一，如22章中看到的，路由器使用路由表，以找出必须接收此分组的下一跳（下一个路由器），如果一个或多个路由表中出现差错，那么一个分组就可能在一个回路或循环中，从一个路由器到下一个路由器，或无休止地通过一系列的路由器。20章中看到的，==每个数据报都有生存时间的字段控制这种情况，当数据报通过路由器时，这个字段的值减一。收到数据报的路由器在发现这个字段的值为 $0$ 时，就丢弃这个数据报。但是，当丢弃这样数据报时，就要由路由器向源端发送一个时间超时报文==。
- 其二，当组成一个报文的所有分段，未能在某一时限内到达主机时，也要产生时间超时报文。

### 4. 参数问题
当数据报在因特网上传输时，在其头部中出现的任何二义性，都可能产生严重的问题。如果路由器或目的主机发现了这种二义性问题，或在数据报的某个字段中缺少某个值，它就丢弃这个数据报，并向源端发送**参数问题报文** `parameter-problem message` 。

### 5. 重定向
当路由器要将分组转发到另一个网络时，它必须知道下一个适当的路由器的IP地址。如果发送方是主机，情况也是这样的。路由器和主机都必须有一个路由表，以便找出下一个路由器的地址。而在22章中将看到，==路由器还要参与（动态的）路由选择更新过程，并且其更新被认为是瞬时完成的==。

但是，为了提高效率，**主机都不参与路由选择更新过程**，因为在因特网上的主机数量比路由器要多出很多，动态地更新主机的路由表会产生不可接受的通信量。

主机通常使用静态路由选择——==当主机开始联网工作时，其路由表中项目的个数是很有限的，它通常只知道默认路由器这一个路由器的IP地址==。因此，当主机向另一个网络发送数据报时，就将此数据报发给了这个错误的路由器。在这种情况下，收到此数据报的路由器，会将该数据报转发给正确的路由器。但是，==**要更新主机中的路由表，它就要向主机发送重定向报文**==，重定向的概念如图21.11所示。主机 $A$ 想要向主机 $B$ 发送数据报。路由器R2显然是最有效的路由选择，但是主机 $A$ 没有选择路由器R2，数据报发送到路由器R1而不是R2。==R1在查找路由表后，发现分组应当走R2，它把分组发送到R2，并同时向主机发送重定向报文，这时主机 $A$ 的路由表就被更新了==：
![在这里插入图片描述](https://img-blog.csdnimg.cn/7ac299632ba84d1ab27b2a76f7aaec82.png)
## 21.2.4 查询
除了差错报告外，ICMP还能对某些网络问题进行诊断，这是通过使用由**四对不同报文**组成的查询报文来完成的——回送请求和回答报文、时间戳请求和回答报文、掩码地址请求和回答报文、路由器询问和通告报文。如图21.12所示，**这种类型的ICMP报文中，一个节点发送出报文，然后由目的节点用特定的格式进行回答**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/b55ef7bfc44d48adbaa0cd014a2b2c2d.png)
查询报文封装在IP分组中，然后再将IP分组封装在数据链路层的帧中。然而，**在这种情况下，原始IP字节没有包括在报文中**，如图21.13所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/3808880aa7d9412cb095c1453737755d.png)
### 1. 回送请求和回答
**回送请求报文** `echo-request message` 和**回送回答报文** `echo-reply message` 是为诊断目的而设计的。网络管理员和用户都可以使用这对报文发现网络问题。

回送请求和回送回答，组合起来确定了两个系统（主机或路由器）是否彼此能通信，即**可用来确定是否能在IP级通信**。因为ICMP报文被封装成IP数据报，发送回送请求的机器在收到回送回答报文时，就证明了==在发送方和接收方之间能够使用IP数据报进行通信==。此外，还证明了==中间的一些路由器能够接收、处理和转发IP数据报==。

今天，大多数系统都提供 `ping` 命令，它可以创建一系列（不仅仅是一个）回送请求或回送回答报文，提供统计信息。

### 2. 时间戳请求和回答
两个机器（主机或路由器）可使用**时间戳请求**和**时间戳回答报文** `timestamp request and timestamp reply messages` 来确定，IP数据报在两个机器之间往返所需的时间。它也可用作两个机器之间的时间同步。

### 3. 地址掩码请求和回答
主机可能知道它的IP地址，但可能不知道相应的掩码。例如，主机知道它的IP地址是 $159.31.17.24$ ，但可能不知道它的掩码是 $/24$ 。为了求得它的掩码，主机应向*局域网上的路由器*发送**地址掩码请求报文** `address-mask request message` 。如果主机知道该路由器的地址，它就直接向路由器发送该请求；如果它不知道地址，它就广播该报文。路由器接收到地址掩码请求报文后，用**地址掩码回答报文** `address-mask reply message` 进行响应，向主机提供所需的掩码。将这个掩码应用到完整的IP地址上，就可求得子网的地址。

### 4. 路由器询问和通告
如同在重定向报文的讨论中那样，主机如果想将数据发送给另一网络上的主机，就需要知道连接到它自己网络上的路由器的地址。另外，**该主机还需要知道这些路由器是否正常工作**。**路由器询问报文**和**路由器通告报文** `router-solicitation message and router-advertisement message` 就用于这种情况。主机可将路由器询问报文进行广播（或多播），收到询问报文的一个或多个路由器，就使用路由器通告报文，广播其路由选择信息。==即使在没有主机询问时，路由器也可周期性地发送路由器通告报文==。注意：路由器在发送通告报文时，不仅通告自己的存在，还通告了它所知道的、所有在这个网络上的路由器。

### 5. 校验和
10章中就已经知道了校验和的概念和思想。在ICMP中，校验和的计算包括了整个报文（头部和数据）。

【例21.2】图21.14表示了对一个简单的回送请求报文的校验和计算的实验。我们随机选定标识符为1，而序列号为9。**将报文划分为16位（2字节）的字，将这些字相加，然后将其和取反**。现在发送方就可将此值放置在校验和字段。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f333a6bc730c469fb3701c7f6034e254.png)

## 21.2.5 调试工具
有许多工具可用来调试因特网，我们可以确定主机或路由器是否能正常工作、做出响应，还可以跟踪分组的路由。这里介绍ICMP所采用的两个调试工具：`ping` 和 `traceroute` 。在对多个协议讨论之后，将在后面几部分介绍更多的调试工具。

### 1. `Packet InterNet Groper, Ping` 程序
 *ping* 程序可用来测试**两个主机之间的连通性**，它使用了ICMP回送请求与回送回答报文。==*ping* 程序是应用层直接使用网络层ICMP的例子，它没有通过运输层的TCP或UDP==。此处观察 *ping* 程序如何用于ICMP分组。

源主机发送ICMP回送请求报文（类型 $8$ ，代码 $0$），如果目标机器正常工作，则它用ICMP回送回答报文响应。 *ping* 程序在回送请求报文和回送回答报文中**设置标识符字段**，并以序列号 $0$ 开始，每发送一个新的报文，该序列号加一。注意： *ping* 程序能计算出往返时间，***ping* 程序在报文数据部分插入发送时间**。往返时间 `RRT` 的值是收到回答报文的时间减去发送请求报文时间的值。

【例21.3】用 *ping* 程序测试服务器 `fhda.edu` 。结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/82d3b4ab4bc84ab38c0a1a4faedcf4b9.png)
*ping* 程序发送报文的序列号从 $0$ 开始，每次探测给出这次的往返时间。封装了ICMP报文的IP数据报的 `TTL`（生存时间）字段已被置为 $62$ ，这就是说该分组的传输不能超过 $62$ 跳。

一开始 *ping* 程序定义数据部分为 $56$ 个字节，IP数据报总长度为 $84$ 字节。这是显然的，因为我们要增加ICMP头部 $8$ 字节和IP头部 $20$ 字节，所以其结果是 $84$ 字节。但是需要注意，每次探测中 *ping* 程序定义的字节个数为 $64$ ，这是ICMP分组的总长度 $56+8$ 。（？）

如果不用中断键（如 `CTRL+C`）停止 *ping* 程序，它会一直下去。当程序被中断后，它打印出检查的统计结果。它告诉我们发送的分组数、接收到的分组数、总的时间、往返最小/最大平均时间，有些系统还可以打印出更多的信息。

### 2. `Traceroute` 程序
UNIX中的 *traceroute* 程序或Windows中的 *tracert* 程序，是一个UDP提供服务的应用程序（见23章），可用于**追踪一个分组从源端到目的端所经过的路由**，让我们知道信息从计算机到互联网另一端的主机是走的什么路径。当然，每次数据包由某一同样的出发点 `source` 到达某一同样的目的地 `destination` 走的路径可能不一样，但基本来说大部分时候所走的路由是相同的。*traceroute* 程序的应用，与20章中的IP数据报的松散路由选项、严格路由选项类似。

给定图21.15中的网站拓扑结构，表述 *traceroute* 程序的基本过程。我们知道主机 $A$ 向主机 $B$ 发送一个分组，要经过路由器R1和路由器R2。但是，**多少情况下我们并不知道网络拓扑结构，主机 $A$ 到主机 $B$ 可能存在多条路由**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2c0b20267c7944ad9fb8bf3126b51a37.png)
==*traceroute* 和ICMP一起使用，**它巧妙地利用时间超时 `ICMP TTL-expired (type 11)` 与目的端不可达两种ICMP错误报文 `ICMP port-unreachable (type 3, code 3)`，以及IP分组的 `TTL`（生存时间）字段，通过发送小的数据包到目的设备直到其返回，找出分组经过的路由**==。***traceroute* 程序还会测量其需要多长时间**，对一条路径上的每个设备，*traceroute* 要测 $3$ 次。输出结果中包括每次测试的时间 `ms` 和设备的名称（如有的话）及其IP地址。
1. *traceroute* 程序用下列步骤求得路由表R1的地址，和主机 $A$ 到路由器R1的往返时间。
    a. 主机 $A$ 上的 *traceroute* 程序，利用UDP协议发送一个分组到目的主机 $B$ ，==该报文被封装在 **`TTL` 字段值为 $1$ 的IP分组**中==。程序记住发送分组的时间。
    b. 路由表R1接收到分组，并将 `TTL` 的值减一成为 $0$ ，然后路由器R1丢弃该分组（由于 `TTL` 字段的值为 $0$），并发送一个时间超过ICMP报文（类型 $11$ ，代码 $0$）表示 `TTL` 的值为 $0$ 、该分组已被丢弃。
    c.  主机 $A$ 上的 *traceroute* 程序接收到该ICMP报文，并利用封装了ICMP报文的IP分组的~~目的~~（源）地址，求得路由器R1的IP地址。程序也记住分组到达的时间，这个时间与 a 步记下的时间差就是往返时间。
==*traceroute* 程序重复步骤 a 到 c 三次，求得一个较好的平均往返时间==。第一次往返时间可能会比第二次或第三次长，因为第一次需用ARP程序查找R1的物理地址，而第二次和第三次往返时，ARP在它的高速缓存中有该地址。
2. *traceroute* 程序重复上面的步骤，求得R2的地址，以及主机 $A$ 到R2的往返时间。但是，==这一步中 `TTL` 字段设置为 $2$== 。因此R1转发这个报文，而R2丢弃它并发送时间超时ICMP报文。
3. *traceroute* 程序重复步骤2，求得主机 $B$ 的地址，以及主机 $A$ 到主机 $B$ 的往返时间。==当主机 $B$ 接收到分组时，`TTL` 值减一，但主机 $B$ 不丢弃该报文，因为它已经到达了它的最终目的地==。
问题是，此时的ICMP报文如何发送回到主机 $A$ ？*traceroute* 程序在此处采用了一种不寻常的策略——==**将UDP分组的目的端口 `UDP port > 32768` 设置为UDP协议不支持的端口**==。当主机 $B$ 接受到该分组，它找不到接收该传递的应用程序。它丢弃该分组，并发送一个ICMP目的端不可达报文（类型 $3$ ，代码 $3$）到主机 $A$ 。注意，**这种情形在路由器R1和R2不会发生，因为路由器不检查UDP的头部**。*traceroute* 程序记录到达的IP数据报的目的地址和往返时间。==接收到代码为 $3$ 的目的端不可达的ICMP报文，就表示已求得全部路由，此时不需要再发送分组==。

注意，有时我们 *traceroute* 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。
 
总的来说，源端（主机或路由器） `source` 发出 `UDP packet` ，源端端口 `source port` 使用随机的任何大于 $32768$ 的高段端口，目的端口 `destination port` 从 $33434$ 开始，每发送一个探测 `probe` 就依此递增，直至 $33434+29$（`cisco router` 上使用 `extended-traceroute` 命令，可以修改这个起始的 $33434$ 端口），同时 `TTL` 从 $1$ 开始依此递增，直至 $1+29=30$（最多送 $30$ 个探测)。中间的路由器送回 `ICMP TTL-expired` ， 使源端主机得知中间的每一个路由器， 最后的目的端 `destination` 送回 `TTL-expired` 和 `ICMP port unreachable` （因为任何主机上，都没有应用使用 `UDP port# > 32768` 这样的高段端口）。

所以，==如果中间某处封掉 `UDP port > 32768` 将导致  *traceroute* 不工作 ；封掉 `TTL-expired` 会使 `source` 看不到中间的路由器（有的路由器根本不支持回送 `TTL-expired` ）；封掉 `type 3,  code 3` ，可能看不到 `destination` 。==

另外需要知道的是，由于回送 `TTL-expired` 的信息需要CPU生成一个分组，必须打断CPU。为保证其它工作的正常进行，`cisco router` 每隔一秒才处理 *traceroute* ，所以在 `source` 上可能看到中间一路 `* * *` ，但却看得到最后的 `destination` ，这时应知道原因是**中间的路由器的CPU太忙**，或者**中间的路由器不回送 `TTL-expired` 包**。

【例21.4】我们用 *traceroute* 程序求计算机 `voyager.deanza.edu` 到服务器 `fuda.edu` 的路由，下面表示其结果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/767708b2d17c46f0b15da6115be3322d.png)
命令后无序列的行表示了目的端是 $153.18.8.1$ ， TTL值是 $30$ 跳，该分组包含 $38$ 个字节：IP头部 $20$ 个字节、UDP头部 $8$ 个字节和应用数据 $10$ 个字节。***traceroute* 程序使用应用数据存储分组的轨迹。**
- 第一 行表示访问第一个路由器，该路由器名称是 `Dcore.fuda.edu` ，其IP地址 $153.18.31.254$ 。第一个往返时间是 $0.995ms$ ，第二个往返时间是 $0.899ms$ ，第三个往返时间是 $0.878ms$ 。
- 第二行表示访问第二个路由器，该路由器名称是 `Dbackup.fhda.edu` ，其IP地址为 $153.18.251.4$ ，也显示了三个往返时间。
- 第三行表示目的主机。我们知道这是目的主机，因为没有更多的行。 目的主机是服务器 `fhda.edu` ，但 它的名称是 `tiptoe.fuda.edu` ，其IP地址为 $153.18.8.1$ ，也显示了三个往返时间。

【例21.5】追踪一个较长的路由，到 `xerox.com` 的路由。此处从源端到目的端有 $17$ 跳。注意，**有些往返时间看起来非常异常，这可能是路由器太忙不能立即处理分组**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/9c6ae0be263d4749bc76b8a09ab47101.png)

---
# 21.3 IGMP
**IP协议可用到两种类型的通信：单播和多播**。单播是一个发送方和一个接收方之间的通信，它是一对一的通信。但是，有些过程有时需要将同一个报文同时发送给许多的接收方，这称为[**多播**](https://en.wikipedia.org/wiki/Multicast) `multicasting` ，即一对多的通信。

多播有许多的应用，例如，将股票价格的变动同时通知给许多的证券经纪人，将旅行的取消同时通知许多旅行经理，其他一些应用包括远程学习和视频点播等。

==对于因特网上的多播，我们需要具有**路由「多播分组」能力**的路由器，这些路由器的路由表必须由某些**多播路由协议**更新==，这些多播路由协议将在第22章中讨论。
## 21.3.1 组管理
**因特网组管理协议** `Internet Group Management
Protocol, IGMP` 是多播中一个**必要的、但不是充分的**协议（正如我们将会看到的，多播也包含其他的协议），它规定了「**处于不同网段的主机**」**如何进行多播通信**。在IP协议中，IGMP是一个**辅助协议**，用于**主机向任一个直接相邻的路由器报告组成员情况**。

IGMP不是一个多播路由协议，而是一个**管理组成员** `group membership` 的协议。==在任何网络中，都存在有一个或多个多播路由器，把多播分组分发给主机或其他的路由器==。IGMP协议为**多播路由器** `multicast server` 提供关于「连接到网络上的主机（路由器）成员状态」的信息，用来在「IP主机」与「直接相邻的组播路由器」之间建立、维护组播组成员关系。**所有参与组播的主机必须实现IGMP**。需要注意的是，IGMP不包括「组播路由器之间的组成员关系信息」的传播与维护，这部分工作由**各组播路由协议**完成。

一个多播路由器每天可以接收到数以千计的、属于不同组的多播分组。如果一个路由器不了解主机的成员状态，它就必须广播所有的分组，这造成通信量的大量增加并浪费带宽。一个较好的解决方法是，在网络中保存一份组列表，该列表中至少有一个忠实的成员，==IGMP帮助多播路由器创建和更新这个表——与每个路由器接口有关的忠实成员的列表==。

 
在详细说明IGMP协议之前，大体介绍IGMP——IGMP可分为两个阶段：
- 第一阶段：当某个主机加入新的多播组时，该主机应向「**多播组的多播地址**」发送IGMP（成员报告）报文，声明自己要成为该组的成员。==本地的多播路由器收到IGMP 报文后，将组成员关系转发给因特网上的其他多播路由器==。
- 第二阶段：因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。==只要某个组有一个主机响应，那么，多播路由器就认为这个组是活跃的==。但一个组在经过几次的探询后，仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。

IP多播的几个特点是：多播使用组地址，**IP使用 $D$ 类地址支持多播**；**多播地址只能用于目的地址，而不能用于源地址**；永久组地址由因特网号码指派管理局IANA负责指派；动态的组成员；使用硬件进行多播。
![在这里插入图片描述](https://img-blog.csdnimg.cn/88ae8a5890a046aebf0fb3863efb9ce4.png)

## 21.3.2 IGMP报文
IGMP有两种版本，讨论现在的版本是IGMPv2，它有三种类型的报文 `message` ：**查询** `query` 、**成员报告** `membership report` 和**离开报告** `leave report` ，其中的**查询报文** `query message` 有两种类型：**普通的** `general` 和**特殊的** `special` 。图21.16如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/ffc6284d143a4d5e9c666ba0f7701d38.png)
## 21.3.3 报文格式
图21.17显示了IGMPv2的报文格式：
- **类型**。$8$ 位字段，定义报文类型，如表21.1所示。类型的值用十六进制或二进制标记法表示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/bc3b3a49d54a421d8b8612de34356e01.png)

- **最大响应时间**。$8$ 位字段，定义**回答一个查询所需的时间** ，该值以**十分之一秒**为单位。例如，如果其值为 $100$ ，即是 $10$ 秒。在查询报文中，该值非零；在其余两个类型的报文中，其值为零。稍后我们会看到它的应用。
- **校验和**。$16$ 位字段，校验和以 $8$ 字节的报文计算。
- **组地址**。对于普通的查询报文，这个字段的值为 $0$ ；在特殊查询、组成员报告、离开报告报文中，这个值定义为**组标识符** `groupid`（组的多播地址）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/e1f648ea0be8448da0888f101b383e80.png)

## 21.3.4 IGMP操作
主机或多播路由器在一个组中，可能存在成员关系。==当一个主机有成员关系时，就意味着它的一个进程（一个应用程序）接收到来自某一组的多播分组==。==当一个多播路由器具有成员关系时，就意味着一个「连接到它的其他接口的网络」接收到这些多播分组==。我们说该主机或路由器对该组有**加入**请求。**在这两种情况下，主机和路由器保存一个组标识符表，并将它们的关系中继给分发路由器。**

例如，对图21.18中的网络来说，**路由器R是分发路由器**，其余两个多播路由器R1和R2依赖于路由器R维护的组列表，它们可能是这个网络中路由器R的接收者；对其他网络的这些组来说，R1和R2可能是分发路由器，它们不在本网络上。
![在这里插入图片描述](https://img-blog.csdnimg.cn/014a165104c54e87aa4f99a2a48913d1.png)
**IGMP是本地运行的**。连接到网络的多播路由器有一个组多播地址表，该表内至少有一个忠实的成员。**对每一组，都有一个路由器负责将多播分组分发给指定的那个组**。这就是说，如果与网络相连的多播路由器有三个，**它们的组标识符 `groupid` 都是相互排斥的**。如图21.18中，只有路由器R分发其多播地址为 $225.70.8.20$ 的分组。

### 1. 加入一组
一个主机或路由器可加入一组。每个主机维护一个组内成员进程表，**当一个进程要加入到一个新组时，它就向主机发送请求，该主机就在它的表中增加该进程的名字、所请求的组的名字**——==如果这是在该特殊组中的第一个成员关系的请求，则该主机就向多播路由器发送一个成员关系报告报文；如果这不是第一个成员关系，则不需要发送成员关系报告，因为主机已是组的成员，它已经接受了这个组的多播分组==。

IGMP协议要求发送**两次**成员关系报告，在几分钟内一个接着一个地发送两次。这样，如果第一个丢失或损坏了，第二个可代替它。
### 2. 离开一组
当主机发现没有进程对一个特殊的组有加入请求时，它就发送一个离开报告。同样的，==当路由器发现，没有一个「与网络连接的接口」对一个特殊的组有加入请求时，它就发送一个关于该组的离开报告==。

但是，当一个多播路由器接收到一个离开报告时，因为报告只是来自一个主机或路由器，可能还有其他主机或路由器依然存在、对该组有加入请求，所以它不可能立即从它的多播地址表中清除该组。为了确保这样做，==路由器发送一个特殊查询报文，并插入有关该组的组标识符或**多播地址** `multicast address`== 。对任意主机或路由器，路由器允许有一个规定的时间，对主机或路由器做出响应，如果在这规定时间内没有接收到加入请求（成员关系报告），那么路由器就假定网络中没有忠实的成员，并从它的列表中清除该组。

### 3. 监视成员关系
主机或路由器可通过发送成员关系报告报文，加入到一个组中，也可以通过发送一个离开报告离开一个组。但是，**发送这两种类型的报告是不够的**。考虑这样一种情形，==只有一个主机对一个组中有加入请求，但是该主机关闭或从系统中删除，多播路由器将永远接收不到离开报告==。这个如何处理？

做法是，==多播路由器负责监视局域网上的所有主机或路由器，以发现它们是否愿意继续它们在一个组中的成员关系==——这个路由器周期性地（默认值为 $125$ 秒）发送一个普通的查询报文，普通查询报文没有定义一个特殊的组。在这个报文中，组地址字段被设置为 $0.0.0.0$ ，这就是说，**查询成员关系的延续，需要考虑一个主机所加入的所有的组，而不是仅一个组**。

路由器期待从多播地址表中的每个组得到一个回答，即使一个新组也不例外。查询报文的最大响应时间为 $10$ 秒（字段中的值为 $100$ ，以十分之一秒为单位）。**当主机或路由器接收到普通查询报文时，如果它对一个组有加入请求，它就用一个成员关系报告来响应**。但是==如果这是一个公用的加入请求（例如，两个主机对同一组有加入请求）时，只有一个响应发送到那个组，以防止不必要的通信量==，这称为**延迟响应**。注意，必须仅有一个路由器发送查询报文（通常称为查询路由器），后面讨论这个问题。

### 4. 查询响应
为了防止不必要的通信，IGMP使用**延迟响应策略** `delayed response strategy` 。**当一个主机或路由器接收到查询报文后，它并不立即响应，而是经过一定的时间间隔后才发出响应**。具体来说，每个主机或路由器使用一个随机数建立一个计时器，计时器在 $1$ 秒到 $10$ 秒之间，截止时间可以以 $1$ 秒或更小的时间为步长。**对多播组地址表中的每一个组设置一个计时器**。例如，计时器对第一个组可用 $2$ 秒截止，但对第三个组可用 $5$ 秒截止。

**每个主机或路由器在它的计时器截止之前，一直等待**，直到它的计时器截止时间到了，才发送一个成员关系报告报文。在等待过程中，如果另一个主机或路由器的计时器对同一个组截止得较早，该主机或路由器就发送一个成员关系报告，**报告是广播的**。正等待的主机或路由器接收到报告，而且知道不需要为同一个组发送一个重复报告，这样等待站点就取消它的相应的计时器。

【例21.6】设想网络有三个主机，如图21.19所示。在时刻 $0$ ，接收到查询报文，每一个组的随机延迟时间（以十分之一秒为单位）在该组地址后面表出，如图所示。试说明其报告序列。
![在这里插入图片描述](https://img-blog.csdnimg.cn/279d55e1ab6a4399b2cc4d9ce72aa4a7.png)

解：事件发生的序列如下：
- a. 时刻 $12$ ：此时主机 $A$ 中的组地址 $228.42.0.0$ 的计时器截止，发送一个成员关系报告。路由器和每个主机（包括主机 $B$ ）接收到这个报告，这样主机 $B$ 删除组地址 $228.42.0.0$ 的计时器。
- b. 时刻 $30$ ：此时主机 $A$ 中的组地址 $225.14.0.0$ 的计时器截止，发送一个成员关系报告。路由器和每个主机（包括主机 $C$）接收到这个报告，这样主机 $C$ 删除组地址 $225.14.0.0$ 的计时器。
- c. 时刻 $50$ ：此时主机 $B$ 中的组地址 $238.71.0.0$ 的计时器截止，发送一个成员关系报告。路由器和每个主机接收到这个报告。
- d. 时刻 $70$ ：此时主机 $C$ 中组地址 $230.43.0.0$ 的计时器截止，发送一个成员关系报告。路由器和每个主机（包括主机 $A$ ）接收到这个报告，主机 $A$ 删除组地址 $230.43.0.0$ 的计时器。

注意，如果每个主机为多播地址表中的每个组地址，都发送一个报告，则将是 $7$ 个报告，而用这种策略只发送 $4$ 个报告。

### 5. 查询路由器
查询报文可以生成许多响应。为了防止不必要的通信，IGMP为每个网络设计了一个路由器，作为**查询路由器** `query router` ，**只有这个路由器发送查询报文**。其他路由器都是被动的，它们接收响应并更新它们的列表。

## 21.3.5 封装
IGMP报文封装在IP报文中，而IP数据报本身又封装在帧中，如图21.20：
![在这里插入图片描述](https://img-blog.csdnimg.cn/493213be7bee4c76805a86eb6838187c.png)
### 1. 在网络层封装
==对于IGMP协议，IP分组的协议字段的值是 $2$== 。在协议字段中携带这个值的每个IP分组，都需要给IGMP协议传送数据。==当这个IGMP报文被封装在IP数据报中时，`TTL` 的值必须为 $1$ ，这是必须的==。因为IGMP的域是局域网，IGMP报文不能传送到局域网之外，**`TTL` 的值为 $1$ 保证了报文不能离开这个局域网**，因为第一个路由器就将此值减小为 $0$ ，因而就将其丢弃。

表21.2显示了每一种类型的报文的目的IP地址：
- 查询报文是用多播地址 $224.0.0.1$ 进行广播，所有主机和路由器都将接收到该报文。
- 成员关系使用与「被报告的多播地址（组标识符）」相同的目的地址进行广播，==接收到该分组的每个站点（主机或路由器）可立即确定（从头部）哪个组报告已经被发送==。由于前面已讨论过，相应的未发送报告的计时器可以被删除。站点不需要打开该分组去寻找**组标识符，这个地址被复制在一个分组中，它是报文本身的一部分，也是IP头部的一个字段**。复制可以防止差错。
- 离开报告报文用多播地址 $224.0.0.2$ 广播（这个子网上的所有路由器），因此路由器都接收到这类报文，主机也都接收到这类报文，但不理它。
![在这里插入图片描述](https://img-blog.csdnimg.cn/70e5dda4eb804e8fbe5c07facef33457.png)
### 2. 在数据链路层封装
在网络层，IGMP报文封装在IP分组中，作为IP分组处理。但是，因为IP分组有一个多播IP地址，所以ARP协议不能找到在数据链路层转发该分组的对应的MAC（物理）地址。接着发送的事情，依赖于下面的数据链路层是否支持物理多播地址。

==大多数局域网支持物理多播寻址，以太网就是其中的一种==。以太网的物理地址（MAC地址）是 $6$ 字节（$48$ 位）。如果以太网地址的前 $25$ 位是 $00000001 00000000 01011110 0$ ，它定义TCP/IP协议的物理多播地址。余下的 $23$ 位可用来定义一个组。==要将IP多播地址转换为以太网地址，多播路由器就要提取 $D$ 类IP地址中的最低的 $23$ 位，并将其插入到以太网物理地址中==（如图21.21所示）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/069c01a130f74e97910f89316a9b911e.png)
但是，D类IP地址的组标识符是 $28$ 位长，这就是说有 $28-23=5$ 位未使用，就==表示了 $2^5 = 32$ 个IP级的多播地址映射到一个物理的多播地址==。换言之，映射是多对一、而非一对一。如果D类地址中的组标识符的最左 $5$ 位不全为 $0$ ，主机就可能接收到并不是真正属于它所涉及到的组的分组。为此，==主机必须检查IP地址，并丢弃任何不属于它的分组==。其他局域网也支持同样的概念，但映射的方法可以不同。

以太网的多播物理地址范围：`01: 00: 5E: 00: 00: 00 ~ 01: 00: 5E: 7F: FF: FF` 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/d109ab4540c34e6f96ddc9dc21f7bff3.png)
【例21.7】将多播IP地址 $230.43. 14.7$ 转换成以太网多播物理地址。
解：可用2个步骤来完成：
（1）我们用十六进制写出IP地址的最右 $23$ 位。这可将最右边 $3$ 个字节变换成十六进制，然后，如果最左边的数字大于或等于 $8$ ，则将该数减去 $8$ 。在本例中，其结果是  `2B: 0E: 07` 。
（2）将(1)步所得的结果加到开始的以太网多播地址 `01: 00: 5E: 00: 00: 00` ，其结果是 `01: 00: 5E: 2B: 0E: 07` 。

【例21.8】将多播IP地址 `238.212. 24.9` 转换成以太网多播地址。
解：
（1）用十六进制表示的最右边 $3$ 个字节是 $D4: 18: 09$ 。我们需将最左边的数字减去 $8$ ，其结果是 $54: 18: 09$ 。
（2）将(1)步所得的结果加到以太网多播的开始地址，其结果是 `01: 00: 5E: 54: 18: 09` 。

大多数广域网不支持物理多播地址。要通过这样的网络发送多播分组，就要使用称为**隧道技术** `tunneling` 的过程——==将多播分组封装成单播分组、并通过网络发送，然后在另一端，这个分组又转换成多播分组==。如图21.22所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/e91c4d3c09d342f9b7b49c72c3a335c7.png)

## 21.3.6 `Netstat` 应用程序
*netstat* 应用程序可用来**得到「接口所支持的多播地址」**。

【例21.9】我们使用带有三个选项的 *netstat* 命令。选项 *-n* 是以数字形式显示IP地址、选项 *-r* 显示路由表、选项 *-a* 显示所有的地址（单播和多播地址）。注意：这里仅给出与我们讨论有关的项目。`Destination` 定义目的地址，`Gateway` 定义路由器，`Iface` 定义接口，`Mask` 定义掩码，`Flag` 定义标记。标记 `U` 表示该路由可使用，标志 `G` 表示该路由是一个网关（路由器）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/9300815fce2a4518bff54ff66f554241.png)
注意：多播地址用彩色表示。具有从 $224 . 0 . 0 . 0$ 到 $239.255.255.255$ 多播地址的任何分组都被屏蔽，并传递给以太网接口。

---
# 21.4 ICMPv6
在20章中讨论过IPv6，在TCP/IP协议族的版本6中，被修改的另一协议是ICMP（ICMPv6）。这个新版本与版本4的策略和目的一样，**修改ICMPv4使得它更加适合IPv6**。此外，在版本4中的一些独立协议，现在成为**网际控制报文协议** `Internet-working Control Message Protocol, ICMPv6` 的一部分，图21.23比较了版本4和版本6的网络层。
![在这里插入图片描述](https://img-blog.csdnimg.cn/0450abc0a86345608e177d316c5a5691.png)
版本4的ARP和ICMP协议合并到ICMPv6，RARP协议从这个协议族中取消了，因为它很少使用，而且BOOTP具有与RARP相同的功能。

正如ICMPv4那样，我们将ICMP报文分为两大类，但是，每一类都比前面版本有更多的报文类型。

## 21.4.1 差错报告
正如讨论IPv4和ICMPv4时看到的，ICMP的一个主要职责就是**报告差错**。有五种差错类型：目的端不可达、分组太大、时间超时、参数问题和重定向。ICMPv6组成差错分组，再封装成IP数据报，然后传递给产生差错的数据报的源端。

表21.3对ICMPv4和ICMPv6的**差错报告报文** `error-reporting message` 进行了比较。**在版本6中源端抑制报文被取消了**，因为在这个版本中，优先级和流标号字段允许路由器控制拥塞，并将最不重要报文丢弃，不需要通知发送方将速率放慢。**增加了分组太大报文**，因为在IPv6中分段是发送方的责任，如果发送方没有对分组长度做出正确的判断，路由器就没有任何选择，只能丢弃分组，并发送差错报告报文给发送方。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c28ea987d18a403aa99f1dc2a5d8906d.png)
### 1. 目的端不可达
**目的端不可达报文** `destination-unreachable message` 的概念和ICMPv4完全相同。
### 2. 分组太大
这是增加到版本6的一个新的报文类型。如果路由器接收到一个数据报，它大于数据报能够通过网络的最大传输单元 `MTU` ，那么就要发生两件事——第一，路由器要丢弃该数据报；第二，要发送差错分组，即**分组太大报文** `packet-too-big message` 给源端。
### 3. 时间超时
这个报文与版本4相似。
### 4. 参数问题
这个报文与版本4相应的报文相似。
### 5. 重定向
**重定向报文** `redirection message` 的目的与版本4相同。
## 21.4.2 查询
除了差错报告外，ICMP还能诊断某些网络问题。这是通过**查询报文** `query message` 来完成的。已定义了四组报文：回送请求和回答、路由器询问和回答、邻站询问和通知、组成员关系。

表21.4显示了版本4和版本6的查询报文的比较。ICMPv6取消了两组查询报文：时间戳请求和回答、地址掩码请求和回答。取消前者是因为，**它们在其他协议（如TCP）中已实现了，同时也因为在过去没有使用过它们**；取消后者是因为，地址的子网部分允许用户使用多达 $2^{32} - 1$ 个子网，因此定义在IPv4中的子网掩码，在这里是不需要的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/d4770830f21e48b687bfe8112f0cb308.png)

### 1. 回送请求和回答
回送请求和回答报文的格式和思路，与版本4一样。
### 2. 路由器询问和通告
路由器询问和通告报文的格式和思路，与版本4一样。
### 3. 邻站询问和通告
如前所述，版本4的网络层包含一个独立的协议，称为ARP。在版本6中，这个协议取消了，而它的任务并入到ICMPv6中。思路完全相同，只是报文格式改变了。
### 4. 组成员关系
如前所述，版本4的网络层包含一个独立的协议，称为IGMP。在版本6中，这个协议取消了，而它的任务并入到ICMPv6中。其目的完全相同。
