客户不小心重启了服务器 A，然后它就再也无法和服务器 B 通信了。由于这两台服务器之间传输的是关键数据，现场工程师又一时查不出原因，所以客户异常恼火。

问题听起来并不复杂，考虑到起因是服务器 A 的重启，所以我收集了它的网络
配置（见图 1）。
```java
[root@A ~]# ifconfig |egrep "HWaddr|inet addr"
eth0 Link encap:Ethernet HWaddr 00:0C:29:CB:74:A9
inet addr:192.168.26.131 Bcast:192.168.26.255 Mask:255.255.255.0
eth1 Link encap:Ethernet HWaddr 00:0C:29:CB:74:B3
inet addr:192.168.174.131 Bcast:192.168.174.255 Mask:255.255.255.0
eth2 Link encap:Ethernet HWaddr 00:0C:29:CB:74:BD
inet addr:192.168.186.131 Bcast:192.168.186.255 Mask:255.255.255.0
[root@A ~]# route |grep default
default 192.168.26.2 255.255.255.0 UG 0 0 0 eth0
```
图 1
服务器 B 的网络配置则简单很多，只有一个 IP 地址 192.168.182.131，子网掩
码也是 255.255.255.0。当我们在 A 上 ping B 时，网络包应该怎么走？

一般情况下，**像 A 这类多 IP 的服务器是这样配路由的**：
- 假如自身有一个 IP和对方在同一子网，就从这个 IP 直接发包给对方。
- 假如没有一个 IP 和对方同子网，就走默认网关。在这个环境中，A 的 3 个 IP 显然都与 B 属于不同子网，那就**应该走默认网关**了。

会不会是 A 和默认网关的通信出问题了呢？我从 A 上 ping了一下网关，结果却是通的。难道是因为网关没有把包转发出去？或者是 ping 请求已经被转发到 B 了，但 ping 回复在路上丢失？我感觉自己已经走进死胡同。==每当到了这个时候，我就会想到最值得信赖的队友——Wireshark==。

我分别在 eth0、eth1、和 eth2 上抓了包。最先查看的是连接默认网关的 eth0，
出乎意料的是，上面竟然一个相关网络包都没有。而在 eth1 上抓的包却是图 2 的
表现：A 正通过 **ARP 广播**查找 B（192.168.182.131）的 MAC 地址，试图绕过默认网关直接与 B 通信。这说明了什么问题呢？
图 2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122255002.png)
这说明 **A 上存在一项符合 192.168.182.131 的路由，促使 A 通过 eth1 直接与
B 通信**。我赶紧逐项检查**路由表**，果然发现有这么一项（见图 3）：
```java
[root@A ~]# route |egrep "Dest|168.182"
Destination Gateway Genmask Flags Metric Ref Use Iface
192.168.182.0 * 255.255.255.0 U 0 0 0 eth1
```
图 3
因为 192.168.182.131 属于 192.168.182.0/255.255.255.0，所以就会走这条路由。

由于**不同子网所配的 VLAN 也不同，所以这些 ARP 请求根本到达不了 B**。ping 包就更不用说了，它从来就没发出来过。客户赶紧删除了这条路由，两台服务器
的通信也随即恢复。

为什么 A 重启之后会多了这条莫名其妙的路由呢？根据客户回忆，他们以前
的确是配过该路由的，后来删掉了，不知道为什么配置文件里还留着。今天的重
启加载了一遍配置文件，所以这条路由又出现了。你也许会问，为什么不从一开
始就仔细检查路由表呢？这样就不至于走错胡同，连抓包和 Wireshark 都省了。
我当时也是这样反省的，**但现实中要做到并不容易**。

且不说一开始并没有怀疑到路由表，就算怀疑了也不一定能看出问题来。在这个案例中，系统管理员和现场工程师都检查过路由表，但无一例外地忽略了出问题的一项。这是因为真实环境中的路由表有很多项，在紧张的电话会议上难以注意到多出了异常的一项。而且子网掩码也不是 255.255.255.0 那么直观。假如本文所用的 IP 保持不变，但子网掩码变成 255.255.248.0，路由表就成了图 4 所示的样子。
```java
[root@A ~]# netstat –rn
Kernel IP routing table
Destination Gateway Genmask Flags MSS Window irtt Iface
192.168.168.0 0.0.0.0 255.255.248.0 U 0 0 0 eth1
192.168.176.0 0.0.0.0 255.255.248.0 U 0 0 0 eth1
192.168.184.0 0.0.0.0 255.255.248.0 U 0 0 0 eth2
192.168.24.0 0.0.0.0 255.255.248.0 U 0 0 0 eth0
```
图 4
在这个输出中，难以一眼注意到 192.168.176.0 就适用于目标地址 192.168.182.131，至少对我来说是这样的。

我们能从这个案例中学习到什么呢？最直接的启示便是翻出简历，投奔甲方去。这样就可以在搞砸系统的时候，义正词严地要求乙方解决了。假如你固执地想继续当乙方，那就开始学习 Wireshark 吧。**再有经验的工程师也有犯迷糊的时候**，而 Wireshark 从来不会，它随时随地都能告诉你真相，不偏不倚。