@[toc]


下列是有关SNMP、MIB和SMI有关的请求评论：

```clike
1065, 1067, 1098, 1155, 1157, 1212, 1213, 1229, 1231, 1243, 1284, 1351, 1352,
1354, 1389, 1398, 1414, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449,
1450, 1451, 1452, 1461, 1472, 1474, 1537, 1623, 1643, 1650, 1657, 1665, 1666,
1696, 1697, 1724, 1742, 1743, 1748, 1749
```

我们将**网络管理** `network management` 定义为==用于监视、检测、配置和故障发现及修理的网络组件，以满足组织机构所规定的一组要求，这些要求能使网络顺利、高效地运行，为用户提供预定的服务质量==。**为了达到这个任务，网络管理系统使用软件、硬件以及人工参与来实现**。本章首先简要讨论网络管理系统的功能，然后介绍最常用的网络管理系统——简单网络管理协议 `SNMP` 。

---
# 28.1 网络管理系统
网络管理系统的功能分为五大类：配置管理、故障管理、性能管理、安全管理和计费管理，如图28.1所示。
![图28.1](https://img-blog.csdnimg.cn/9ea453f78106446288af21d234eca195.png)
## 28.1.1 配置管理
大型网络通常是由上千个物理地或逻辑地相互连接在一起的实体组成。在网络建立时，这些实体有一个初始的配置，但随着时间可能会改变。台式计算机可能由其他计算机取代，应用软件可能更新为新的版本，用户也可能由一组移动到另一组。任何时候，**配置管理** `Configuration Management` 系统==必须知道「每个实体的状态」及「其与其他实体的关系」==，配置管理可划分成两个系统：**重新配置**和**文档资料**。

### 1. 重新配置
重新配置是指**调整网络组件与特性**，在大型网络可能每天都在发生。重新配置有三种类型：硬件重新配置、软件重新配置与用户账号重新配置。
- **硬件重新配置**包括硬件的所有变化。例如，台式计算机可能被其他计算机取代，一个路由器可能需要从网络的一个部分移动到另一个部分，某个子网可能增加到网络上或从网络上删除。所有这些都需要网络管理及时关注。==在大型网络中，必须有专职技术人员快速和高效地进行重新配置==。令人遗憾的是，**这种类型的重新配置不是自动的，而需按情况手工处理**。
- **软件重新配置**包括软件的所有变化。例如，新软件可能需要安装在服务器或客户机上，操作系统需要更新。幸好，**大多数的软件重新配置都是自动的**。例如，为了更新某些或所有客户机上的一个应用程序，我们可以从服务器上下载它的电子版本。
- ==**用户账号重新配置**不是简单地在系统上增加或删除用户，还必须考虑用户作为个人和作为一组的成员权限==。例如，某个用户可以对有些文件有读和写的权限，但对另外一些文件仅有读的权限。**某种程度上，用户账号重新配置是自动的**。例如在学院或大学中，每一季度或每一学期的开始，会将新生增加到系统中，根据新生所选择的课程或所从事的专业，通常将他们分成组。

### 2. 文档资料
==原始网络配置和每次变化，都必须有详细的记录。这是说要有硬件、软件和用户账号文档==。
- **硬件文档** `hardware documentation` 通常包含两组文档：**映照和说明**。**映照**追踪硬件的每一部件及其与网络连接，也可==有一个总映照，说明每个子网之间的逻辑关系；还可有第二个总映照，它说明每个子网的物理位置==。然后，==对于每个子网，有一个或多个说明了所有设备的映照==。这些映照使用的标准，应易于被当前的或以后的人们阅读和理解，
仅有映照还是不够的，硬件的每一部件也需要有**说明文档**。连接网络的每一部件必须有一组说明，这些说明包含部件类型、序列号、制造厂商（地址和电话号码）、购买日期、保修卡等信息。
- 所有软件也需要有记录，**软件文档**包含的信息有软件型号、版本、安装日期和许可证。
- 多数操作系统有一个允许进入用户账号和权限的文件的程序，管理人员必须确保对这些文件进行更新和维护。==有些操作系统在两个文档中记录访问权限：一个表示**所有文件和每一个用户的访问类型**；另一个表示**访问一个具体文件的用户列表**==。

## 28.1.2 故障管理
当前复杂的网络是由数百个、有时是数千个组件组成的，网络的正确运行取决于各个组件的正确运行、以及相互之间的正确运行。**故障管理** `Fault Management` 就是处理这个问题的网络管理，一个有效的故障管理系统有两个子系统：再生的故障管理和主动故障管理。
### 1. 再生的故障管理
==**再生的故障管理系统**负责故障的检测、隔离、纠正和记录，它使用短期解决办法处理故障==。

故障定义为系统的一种不正常的工作情况，故障可能中断通信或产生过多的差错。当一种故障发生的时候，系统或完全停止工作或产生过多的错误。故障的最好例子是通信介质被损坏。

再生的故障管理系统所采取的第一步是**检测故障准确的位置**；第二步是**隔离故障**，如果故障被隔离，则通常仅有少数用户受影响。隔离后，立即通知受影响的用户，并给出一个纠正错误的大致时间；第三步是**纠正故障**，这可包含替换和修理故障的部分。==故障纠正后，必须被记录在文档中，这个记录必须表明故障的准确位置、可能引起的原因或修复故障的措施、成本和每步花费的时间==。文档极其重要，有下列几点理由：
- 故障可能重复发生，文档有助于网络管理人员或技术人员解决同样的类似问题；
- **同一类故障的频率是系统中较重要问题的指示**，如果某一故障在一个组件中经常发生，就应该用另一个组件去更换它，或者改变整个系统不要使用那种组件。
- **统计是对网络管理和性能管理有帮助的另一个部分**。

### 2. 主动故障管理
==**主动的故障管理**是防止故障发生，尽管通常这是不可能的，但有些故障还是可预知的、可制止的==。例如，制造商指定一个部件或一个部件中某部分的有效期，在到达有效期之前，更换它是一种好的策略。再例如，如果在网络某一特定点经常有故障发生，那么在重新配置网络时，注意防止故障再一次发生也是明智的。
## 28.1.3 性能管理
与故障管理有着密切关系的是**性能管理** `Performance Management` ，**它试图监视和控制网络，确保网络尽可能有效地运行**。性能管理试图通过一些可测量的量（如能力、通信量、吞吐量、响应时间等）来量化性能。
### 1. 能力
性能管理系统必须监视的一个要素是网络的能力。每个网络的能力都是有限的，性能管理必须确保使用不能超过这个能力。例如，如果一个局域网设计为 $100$ 个站点的平均数据速率是 $2Mbps$ ，则连接到这个网络 $200$ 个站点就不能正确地运行，数据速率将会下降甚至还可能发生拥塞。
### 2. 通信量
通信量按两种方法测量：内部的和外部的。**内部通信量**是用网络内部传送分组（或字节）的个数来度量；**外部通信量**是用网络与外部交换分组（或字节）的个数来度量。系统在负载重的峰值期间，如果出现过多的通信量，拥塞就会发生。
### 3. 吞吐量
我们可测量单独一台设备（如路由器）或部分网络的吞吐量。性能管理监视吞吐量，确保它不降低于不可接受的水平。
### 4. 响应时间
通常将**从用户请求服务到服务被准许的时间**称为（用户）**响应时间**，其他一些因素如能力、通信量会影响响应时间。性能管理监视**平均响应时间**和**峰值时刻响应时间**。响应时间的增加是一个非常严重的情况，它表示网络正朝着超过它的能力方向工作。
## 28.1.4 安全管理
**安全管理** `Security Management` 是**根据预定的负责策略，监视对网络的访问**。在第31、32章讨论安全问题，尤其是网络安全问题。
## 28.1.5 计费管理
**计费管理** `Accounting Management` **通过费用控制用户访问网络资源**。根据计费管理，个人用户、部门、公司甚至工程等，都需要对从网络上得到的服务付费。付费不必须现金支付，为预算目的他可以记入部门或公司的账单上。今天，组织机构使用计费系统由下列原因：
- 它防止用户独占有限的网络资源；
- 它防止用户无效地使用系统；
- 网络管理员可以按需对网络使用，做出短期和长期的计划。

---
# 28.2 简单网络管理协议 `SNMP`
**简单网络管理协议** `Simple Network Management Protocol, SNMP` 是 ==**使用TCP/IP协议族，对互联网上的设备进行管理的一个框架**，它提供一组基本的操作来监控和维护互联网==。

## 28.2.1 概念
SNMP使用**管理器**和**代理**的概念，==管理器通常是一台主机，控制和监视一组代理，代理通常是路由器==（图28.2）。
![图28.2](https://img-blog.csdnimg.cn/6381f26387ae4e30952c24c2cdeda1ac.png)

SNMP是应用级协议，它用少数几个管理器控制一组代理。==该协议设计在应用级，因此它能监控不同厂商制造的设备，而这些设备可以安装在不同的物理网络上==。即，SNMP使管理任务与「被管理设备的物理特性和联网技术」没有关系，它可以用于「由不同厂商制造的路由器相互连接在一起、形成的不同局域网和广域网」组成的异构互联网中。

### 1. 管理器和代理
称为**管理器** `manager` 的管理站是**运行SNMP客户程序的主机**，称为**代理**的被管理站是**运行SNMP服务器程序的路由器（或主机）**。管理是通过管理站与代理之间的简单交互来实现的。
- ==代理在数据库中保存性能信息，管理器使用该数据库中的值==。例如，路由器可将接收到的和转发的分组数，存储成适当的变量。管理器可读取和比较这两个变量，以便确定路由器是否拥塞。
- ==管理器也可使路由器完成某些动作==。例如，路由器定期检查一个重新启动计数器的值，看它何时应当重新启动自己。例如，当计数器的值为 $0$ 时，就应该引导自己。管理器可使用这个特性，在任何时候从远处重新引导这个代理，它只要发送一个分组，就迫使这个计数器的值为 $0$ 。
- ==代理也可参加到管理过程中==。在代理上运行的服务器程序可检查环境，如果发现有异常现象，就可发送一个称为**陷阱** `trap` 的警告报文给管理器。

总之，SNMP管理是基于三个基本思想：
1. 管理器检查代理的方法是**发出请求，得到能反映代理行为的信息**；
2. 管理器可以「**重新设置在代理数据库中的某些值**」，强迫代理完成一个任务；
3. 代理参与管理过程的方法是**向管理器发送异常情况的警告**。

## 28.2.2 管理组件
为了完成管理任务，SNMP还使用另外两个协议：**管理信息结构** `Structure of Management Information, SMI` 和**管理数据库** `Management Information Base, MIB` 。即==在因特网上的管理是通过SNMP、SMI、MIB三个协议共同协作完成的==，如图28.3所示。下面详细阐述三个协议之间的交互作用。
![](https://img-blog.csdnimg.cn/bb426af6f1974d8aa0caf254ad1b2a0e.png)
### 1. SNMP的作用
SNMP在网络管理中起着一些很特殊的作用，==它定义从管理器到代理、从代理到管理器发送分组的格式，还解释产生的结果并创建统计表==（时常借助其他的管理软件）。==交换的SNMP分组包括**对象（变量）名及它们的状态（值）**，SNMP负责读取和改变这些值==。

### 2. SMI的作用
要使用SNMP，我们需要有一些规则，需要**命名对象的规则** ` rules for naming objects` 。命名规则这一点尤其重要，因为**在SNMP中的对象是有层次结构的**（一个对象可能有一个父对象和一些子对象）。对象名字的一部分可从父对象名字继承。

我们还须有规则来**定义对象的类型** `rules to define the type of the objects` 。SNMP能处理哪些类型的对象？SNMP可以处理简单类型还是结构类型？有多少种简单类型可用？这些类型的大小 `the sizes of these types` 是多少？这些类型的定义域 `the range of these types` 是什么？此外，这些类型如何编码？

==因为我们不知道发送、接收或存储这些值的计算机的结构，我们必须有通用的规则==。例如，发送计算机是一个大型计算机，能将整数存储为 $8$ 字节数据，而接收计算机是一个小型的计算机，仅能将整数存储为 $4$ 字节数据。

**SMI是定义这些规则的协议**。但我们必须明白：SMI只定义了规则，它没有定义在一个实体中应管理多少个对象、或哪个对象使用什么类型、或被管理对象的命名、或对象与值之间的关联。**SMI是给对象命名和定义对象数据类型的规则集合** `rules to name objects and to list their types` ，它定义**对象命名、数据类型（包括长度和定义域）**、展示**如何编码对象和值**的一般规则 `the general rules for naming objects, defining object types (including range and length), and showing how to encode objects and values` 。对象与数据类型的关联不是由SMI完成的 `The association of an object with the type is not done by SMI` 。
### 3. MIB的作用
我们期望清晰地了解另一个所需协议。对每个被管理的实体，**这个协议必须定义对象的数量，按照SMI定义的规则命名它们，并为每个命名对象关联一个类型** `associate a type to each named object` 。这就是MIB协议，MIB对每个实体创建一组对象，这类似于数据库（主要是数据库中的元数据、名称和类型，没有值）`MIB creates a set of objects defined for each entity similar to a database` 。MIB在一个被管理的实体中，创建一个「命名对象、它们的类型以及它们之间的关系」的集合。
### 4. 类比
在较详细讨论这三个协议之前，先给出一个类比。这三个网络管理组件类似于当我们用计算机语言编写程序来解决问题时所需要的（事物）。

在编写程序前，必须预先定义程序设计语言的语法（如C语言或Java语言），语言还定义变量的结构（简单的、结构的、指针等）以及如何给变量命名。例如，一个变量名字长度需要 $1$ 到 $N$ 个字符，以一个字母开始，后跟数字、字母字符。语言还定义所用的数据类型（整数型、浮点数型、字符型等）。==在程序设计中，规则是由语言来定义的。而在网络管理中，规则由SMI来定义==。

大多数程序设计语言要求在每个具体的程序中声明变量，其内容包括变量的名字及其类型。例如，如果某程序有二个变量：一个名字为 `counter` ， 数据类型是整数型；另一个名字为 `grades` ， 数据类型是字符型，那么在程序开始时这二个变量必须声明：

```cpp
int counter;
char grades [40];
```
> 注意：这些声明给变量命名（`counter` 和 `grades` ），并定义每个变量的数据类型。由于在程序设计语言中，数据类型是预先定义的，所以程序知道每个变量的定义域与大小。

==MIB在网络管理中负责类似的任务，MIB给每个对象命名并定义对象的类型==。因为SMI定义了类型，所以SNMP知道其定义域与大小。

在编制程序的声明后，程序要编写语句来存储值到变量，如有需要，还要更新其值。SNMP在网络管理中负责类似的任务，==SNMP根据SMI定义的规则，对MIB已声明的对象的值进行存储、更新和解释== `SNMP stores, changes, and interprets the values of objects already declared by MIB according to the rules defined by SMI` 。

我们比较网络管理任务与编写程序的任务。
- 两个任务都需要规则。在网络管理中，它由SMI处理。
- 两个任务都需要变量声明。在网络管理中，它由MIB处理。
- 两个任务都需要用语句来执行动作。在网络管理中，它由SNMP处理。

### 5. 概要
在详细地讨论每个组件之前，我们用一个简单的情况说明每个组件涉及到的内容，这仅是概要的内容，后面将展开详述。管理器站点（SNMP客户）想要发送一个报文给代理站点（SNMP服务器），查找代理接收到的「UDP用户数据报的个数」。图28.4表示每步的概要。
![图28.4 管理概要](https://img-blog.csdnimg.cn/0314da427e654bc09a902b3d3aff0aa9.png)

MIB负责查找「保存接收到的UDP用户数据报个数的对象」。在另一个嵌入协议的帮助下，SMI负责给对象名编码。SNMP负责创建一个称为 `GetRequest` 的报文，并封装已编码的报文。实际上，事情比概述复杂得多，但我们首先需要每个协议的更多细节。
## 28.2.3 管理信息结构
管理信息结构第二版 `The Structure of Management Information, version 2, SMIv2` 是网络管理中的一个组件。它的功能是：
1. 给对象命名；
2. 定义可在对象中存储的数据类型，
3. 给出如何对「在网络上传输的数据」进行编码的方法。

**SMI是SNMP的一个指南**。它强调了处理对象的三个属性 `three attributes to handle an object` ：**名字、数据类型和编码方法**（如图28.5所示）。
![图28.5 对象属性](https://img-blog.csdnimg.cn/08dae617fdde491c8b026c51d27cc07f.png)
### 1. 名字
**SMI要求每一个被管理对象（如一个路由器、一个路由器中的变量、一个值）具有一个唯一的名字**。为了在全局给对象命名，SMI使用**对象标识符** `object identifier` ，它是基于树结构的分层次标识符（如图28.6所示）。

树结构从一个未命名的根开始。每一个对象可用一个「点分隔开的整数序列 `a sequence of integers separated by dots` 」来定义，树结构也可用一个「点分隔开的文本名字序列 `a sequence of textual names separated by dots` 」来定义。**整数-点表示法** `integer-dot representation` 是SNMP使用的一种方法，人们使用**名字-点表示法** `name-dot notation` 。例如，下面是同一对象的两种不同的表示法：
![图28.6 对象标识符](https://img-blog.csdnimg.cn/0d0f54e7707849b4b55ddd7ddcd853ab.png)
==所有被SNMP管理的对象都有一个对象标识符，在SNMP中使用的对象位于 `mib-2` 对象的下面，所以它们的标识符都从 $1.3.6. 1.2.1$ 开始==。

### 2. 类型
对象的第二个属性是在这个对象中存储的数据类型。为了定义数据类型，
SMI使用抽象语法表示法 `Abstract Syntax Notation` 时，ASN. l)的一些基本定义，但还增加了几个新的定义。换言之，SMI既是ASN.l 的一个子集，又是ASN.1 的一个超集。

SMI使用两大类数据类型：简单的和结构化的。我们先定义简单类型，然后讨论如何从简单类型构造出结构化类型(如图28.7所示)。
- 简单数据类型
(simple data type)
是原子数据类型。
这些类型中一些是直接取自 ASN.1 ，另一些是 SMI增加的。
表 28.1 给出了最重要的一些类型。前 5 个取自 ASN.l ，后 7
个是 SMI定义的。
表 28.1
数据类型
![图28.7](https://img-blog.csdnimg.cn/acc72e29d7e840b8b24e2801043b96d3.png)

 
 - 结构化类型
将简单的和结构化的数据类型结合起来，就可构成新的结构化数据类型。
SMI定义了两种结构化数据类型
(structured data type)： sequence和 sequence of。
• Sequence 。 一个 sequence数据类型是一些简单数据类型的组合，不必都是相同类型。它
与C编程语言中使用的 struct或record的概念相似 。
• Sequence of。一个sequence of数据类型是所有相同类型的简单数据类型的组合，或所有
相同类型的 sequence数据类型的组合。它与C编程语言中使用的 array的概念相似。
图28.8说明了数据类型。
a) 简单变量
c) Sequence
b) Sequence of
(简单变量)
(sequences)
图28.8
概念性的数据类型
编码方法
SMI使用另一个标准，即基本编码规则
(Basic Encoding Rule, BER) ，对数据进行编码
井将编码后的数据在网络上传输。
BER规定每一块数据都要被编码成三
元组的格式：标签 、
长度和值，如图
28.9所示。
·标签是一个字节的字段，它定义
图28.9 编码格式
了数据类型。它由 3个子字段组成：
类
(2位)、格式( 1 位)和~字
(5位)。类子字段定义数据的作用域。共定义4类：通用
类
(00) 、应用类
(01) 、特定上下文类( 10) 和专用类( 11 )。通用数据类型来自
ASN.l
(lNTEGER 、
OCTET STRING和 Objectldentifier) 。应用数据类型是由 SMI增加
的
(IPAddress 、
Counter 、
Gauge和TimeTicks) 。有 5种特定上下文数据类型，其意义随
着协议的不同而不同，专用数据类型是特定厂商使用的。
格式子宇段指出数据是简单的
(0) 还是结构化的( 1 )。编号子字段将简单的或结构化的
数据进一步划分成一些子组。例如，在通用类中，对于简单格式，
INTEGER 的值是 2 ，
OCTET STRING的值是4等。表28.2给出本章所使用的数据类型，以及其标签的二进制和十六
进制数。
 
数据类型的代码
表 28.2
标签(十六进制)
 
数据类型
·长度字段是一个或多个字节。如果是一个字节，则最高位必定是0 ，其余7位定义数据长
度。如果大于一个字节，则第一个字节的最高位必定是 1 ，其他7位则定义在定义这个长
度时所需的字节个数。图28.10说明了长度字段的意义。
 
图28.10
长度格式
·值字段按照在BER中定义的规则将数据的值进行编码。
我们给出一些例子来说明这三个字段(标签、长度和值)是如何定义对象的。
例 28.1
图28.11 表示了如何定义整数(lNTEGER)
14 。
例 28.2
图28.12表示了如何定义串类型
 
图28.11
例28. 1 整数 14
图28.12
f列282 串
"HI"
例 28.3
图28.13表示了如何定义对象标识符1. 3.6.1
(i so.org.dod.i nternet) 。
例 28.4
图28.14表示了如何定义 IP地址 13 1. 2 1.1 4.8 0

图28.14
例28.4IP地址 13 1. 2 1. 14.8
28.2.4管理信息数据库
(MIB)
管理信息数据库版本 2
(MIB2) 是网络管理中的第二个组件。每个代理都有它自己的
MIB2 ，这是管理器能够管理的所有对象的集合。在MIB 中的对象分成 10个不同的组：
system 、
interface 、
address
translation 、
ip 、
icmp ，
tcp 、
udp 、
egp 、
transmission和 snmp 。这些组都在
对象标识符树中的mib-2对象的下面(如图28.15所示)。每一个组定义一些变量和(或)表。
4
7
II
12
图28.15 mib-2
下列是一些对象的简要说明：
• sys
这个对象
(system) 定义了关于整个节点(系统)的通用信息，如名字、位置和生
命周期。
• if
这个对象
(interface) 定义了关于整个节点所有接口的信息，如接口数、物理地址
和 IP地址。
• at
这个对象
(address translation) 定义了关于ARP表的信息。
• ip
这个对象定义了有关 IP的信息，如路由表和 IP地址。
• icmp 这个对象定义了有关 ICMP的信息，如已发送和己接收到的分组个数和产生总差错
数。
• tcp
这个对象定义了有关TCP的信息，如连接表、超时值、端口数及已发送和已接收到
的分组个数。
• udp 这个对象定义了有关 UDP的信息，如端口数及已发送和已接收到分组的个数。
• snmp 这个对象定义了有关 SNMP本身的信息。
访问 M 旧变量
我们用 udp组作为例子，说明如何访问不同的变量。在 udp组中有4个简单变量和一个记录
(表)序列，图28.16给出这些变量和表。
我们将说明如何访问每一个实体。
简单变量。要访问任何简单变量，我们用组的 id
(1. 3.6.2. 1. 7) 后面跟着该变量的 id ，下
586
第六部分应用层
面表示如何访问每一个变量。
udplnDatagrams =争1. 3.6. 1. 2. 1. 7.1
udpNoPorts 司1. 3.6. 1. 2. 1. 7.2
udplnErrors =辛1. 3.6. 1. 2. 1.7.3
udpOutDatagrams 司1. 3.6. 1. 2. 1. 7.4
地址
端口
图28.16
udp~且
但是，这些对象标识符定义的是变量而不是实例(内容)。要给出每一个变量的实例或内
容，必须增加一个实例后缀。一个简单变量的实例后缀是一个0。换言之，要给出以上变量的
实例，使用下列方法：
udplnDatagrams. "0" =争1. 3.6. 1. 2. 1. 7. 1. 0
udpNoPorts."O" =争1. 3.6. 1. 2. 1.7.2.0
udplnErrors. "0" =争1. 3.6. 1. 2. 1. 7.3.0
udpOutDatagrams. "0" 斗1. 3.6. 1. 2. 1.7.4.0
表要标识一个表，首先使用表id。如图28.17所示，
udp组只有一个表(id为 5) 。
因此，要访问这个表，使用下面形式：
udpTable =争1. 3.6. 1. 2. 1. 7.5
但是，这个表不是树结构的叶子级，我们不能访问这个表 p
因此如下定义在这个表
(id为
1 )中的项目(序列) ：
udpEntry =辛1. 3.6. 1. 2. 1.7.5.1
这个项目也不是一个叶子级，我们不能访问它。因此需要定义这个项目中的每一个实体
(字段)。
udpLocalAddress =辛1. 3.6. 1. 2. 1. 7.5. 1.1
udpLocalPort =辛1. 3.6. 1. 2. 1. 7.5. 1. 2
这两个变量在树的叶子上。虽然能访问它们的实例，但需要定义是哪一个实例。在任何
时候，这个表对每一个本地地址/本地端口对可以有多个值。要访问表中的一个特定实例(行),
应当给以上 id加上索引。在MIB 中，数组的索引不是整数(像大多数的编程语言那样)。这些
索引是基于在这些项目中的一个或多个字段的值。在我们的例子中，
udpTable的索引是基于
本地地址和本地端口号。例如，图28.18显示一个具有4行的表和每一个字段的值。每一行索
引是这两个值的组合。
要访问第一行本地地址的实例，使用标识符加上实例的索引：
udpLocalAddress.18 1.23.45.14.23 =争1. 3.6. 1. 2.7.5. 1. 1.18 1. 23.45.14.23
 
图28.17
udp的变量和表
注意：并非所有表的索引都是这样，有些索引使用一个字段的佳，有些使用两个字段的
值，等等。
 
图28.18
udpTable的索引
28.2.5
字典排序
关于 MIB变量的一个有趣问题就是对象标识符(包括实例标识符)是按字典的顺序排列
的。表顺序是按照列-行规则，这就是说，要按逐列的顺序。而在每一列中，必须从顶到底，
如图28.19所示。
字典排序
(lexicographic ordering) 能使一个管理器在定义了第一个变量后，可一个一个
接着地访问一组变量，在下一节我们将会在GetNextRequest命令中看到这→点。
 
## 28.2.6 SNMP
,,
图28.19
字典排序
SNMP在因特网的网络管理中使用 SMI和MIBo
SNMP是一个应用程序，它允许：
1.管理器读取代理定义的一个对象的
UDP连接
f直$
2.管理器将一个值存储在代理定义的
一个对象中 g
3. 代理将关于异常情况的告警报文发
送给管理器。
PDU
SNMP 版本 3 定义了 8 种报文(或
PUD)： GetRequest 、
GetNextRequest 、
GetBulkRequest 、
SetRequest 、
Response 、
Trap 、
InformRequest 军口 Report
(如图
28.20所示)。
GetRequest (请求读取) GetRequest
SN如1P
管理器
客户
E
SNMP
代理
到另 一管理器
到另一管理器
图28.20 SNMP PDC
PDU报文是由管理器(客户机)发送给代理(服务器) ，用来读取一个变量或一组变量。
GetNextRequest (读取下一个请求)
PDU报文是由管理器发送给代理，用来读取一个变量
的值。所要读取的值是PDU中定义的0均ectId后面对象的值，它主要是用来读取一个表中的项
目的值。如果管理器不知道该项目的索引，它就不能读这个值。但是，它可以使用
GetNextRequest井定义表的 Objec tI d。因为第一个项目的0均 ectld是紧跟在表的0均 ectId后面，
因此第一个项目的值立即返回了。管理器可使用这个ObjectId来得到下一个项目的值，等等。
GetBulkRequest (读取大量请求)
PDU报文是由管理器发送给代理，用来读取大量数据。
它可用来取代多个 GetRequest和 GetNextRequest PDU 。
SetRequest (设置请求)
PDU报文是由管理器发送给代理，用来设置(存储)一个变量
的值。
Response (响应)
PDU报文是由代理发送给管理器以响应GetResponse和GetNextRequest,
它包含管理器所请求的变量的值。
Trap (陆阱)
(也称为 SNMP版本2的Trap ，
k人区别 SNMP版本 1 的Trap)
PDU报文是由代
理发送给管理器，用来报告一个事件。例如，如果代理重新启动，它通知管理器并报告重新
启动的时间。
InformRequest (读取信息)
PDU报文是由一个管理器发送给另一个远程管理器，用来获
得远程管理器所控制的代理的某些变量的值。
Report (报告)
PDU用来报告管理器
之间错误类型。
格式
8种 SNMP PDU的格式如图28.21所示。
在图28.21 中，除GetBulkRequest有两处不
同外，其他PDU都相同。
各字段列出如下：
.PDU类型
(PDU
type) 。这个字段定
义PDU类型(如表28.4所示)。
·请求标识
(Request ID) 。这个字段
是序列号，由管理器在 Request PDU
中使用，而代理在响应中重复它，它
用来使响应和请求相匹配。
·错误状态
(Error status) 。这是只用于Response PDU 中的一个整数，它给出代理报告的
错误类型。在 Request PDU 中它的值是0 ，表28.3列出了可能出现的错误类型。
 
不同处：
l 除GetBul kRequest外，对于所有的请求报文错误状
态和错误索引值都是0 ，
2.在GetBulkRequest中用一次最多可以取团的MIB对象数
(nonrepeater) 字段代替错误状态字段，用其他岛但对
象能被取回的最大次数字段代替错误索引字段。
变量绑定列表
网络管理
图28.21
SNMP PDU格式
 
错误类型
表28.3
 
·一次最多可以取回的 MIB对象数
(Nonrepeater) 。这个字段只存在于 GetB ulkRequest
PDU中，代替错误状态字段，在请求PDU 中色的值是空。
·错误索引
(Error index) 是一个偏移量，它告诉管理器哪一个变量引起这个错误。
·其他MIB对象能被取回的最大次数
(M缸- repitetion) 。这个字段只存在于Ge由吐kR吨uestPDU
中，代替错误索引宇段，在请求PDU中它是空的。
·变量绑定列表
(VarBindList) 。这是管理器希望读取或设置的一组具有相应值的变量，
在 GetRequest和 GetNextRequest 中它的值是空。在TrapPDU 中，它给出了与一个特定
PDU有关的变量和值。
报文
SNMP不发送单个PDU ，而是将它嵌入到一个报文中发送。
SNMPv3 中的报文是由四个元
素组成：版本、头部、安全参数和数据(包含已编码的PDU) ，如图28.22所示。
因为不同报文中的这些元素的长度是不同的，所以 SNMP使用 BER标准对每个元素进行编
## 28.2.7 
码。记住 BER使用标签和长度来定义一个值。版本定义当前版本
(3) 。头部包含报文标识符、
报文最大长度(回答的最大长度)、报文标记
(OCTET STRING数据类型的一个 8位组，其中
每一位定义安全类型，如保密、鉴别或其他信息)以及报文安全性模型(定义安全协议)。报
文安全参数用于创建报文摘要(见第 31 章)。数据包括PDU 。如果数据是加密的，则存在有关
加密引擎的信息(执行加密的管理器程序)和加密前后关系(加密类型)后跟被加密的 PDU 。
如果数据没有加密，则数据就是PDU 。
为了定义 PDU的类型，
SNMP使用一个标签。该类是上下文敏感的
(10) ，格式是结构化
的(1)，不同类型的报文编号是0 ， 1, 2, 3, 5, 6.7和 8
(如表28.4所示)。
注意：
SNMPv1 定义标签A4作为陷阱，目前已不用了
。

图28.22
SNMP 报文
表 28.4
SNMP报立的代码

例 28.5
在本例中，管理器站点
(SNMP客户机)使用 GetRequest报文读取路由器接收到的一些
UDP数据报。
仅有一个变量绑定表项，与这个信息相应 MIB 变量是 udpInDatagram ，其对象标识符是
1. 3.6.1. 2.1. 7. 1. 0 。管理器打算读取一个值(而不是存储一个值) ，因此值定义为0的空实体。
591
图28.23 说明了分组与 sequence的分级性质的慨念。我们用白色与最里面的框表示 sequence ，
而用其他灰色框表示UDP 。
变量绑定表只有一个绑定变量。变量类型 06 ，长度为 09 。变量类型 05 ，长度为 00 。整个
变量绑定是 seque盯 e ，长度为 OD l6
(13) 。变量绑定表也是 sequence ，长度为 OF 16
(1 5) 。
GetRequest PDU是长度为1D 16
(29) 。
此处，有 3个OCTET STRING是关于安全参数、安全模型和标记的，还有2个 interger定义
最大长度
(1024 )和报文 ID
(64) 。头部是 sequence ，长度为 12 ，为简化用空白省赂。整个报
文是一个 sequence ，长度为 52个字节。
图28.24表示了管理器站点（客户机）向代理（服务器）发送实际的报文。
![图28.24 GetRequest报文](https://img-blog.csdnimg.cn/177c1b26b86248e9a0b48703ca8343b0.png)

 
图28.23
例28.5
UDP端口

## 28.2.8 UDP端口
**SNMP在两个熟知端口 $161$ 和 $162$ 上使用UDP的服务**，熟知端口 $161$ 由服务器（代理）使用，而熟知 $162$ 端口由客户（管理器）使用。

代理（服务器）在端口 $161$ 发出一个**被动打开**，然后它就等待从管理器（客户）来的连接。管理器（客户）使用临时端口发出一个**主动打开**。==客户向服务器发送请求报文，使用临时端口作为源端口、而熟知端口 $161$ 作为目的端口==。服务器向客户发送响应报文，使用熟知端口 $161$ 作为源端口、而临时端口作为目的端口。

管理器（客户）在端口 $162$ 发送一个**被动打开**，然后它就等待从代理（服务器）来连接。==代理（服务器）只要有一个 `Trap` 报文要发送，就使用临时端口发出一个主动打开==。**这个连接是单向的，从服务器到客户**（图28.25）。
![图28.25 SNMP的端口号](https://img-blog.csdnimg.cn/ed2d7f8660c34e8c84000b4fe1e59f75.png)
**在SNMP中的客户/服务器机制与其他协议不同**。此处，**客户和服务器都使用熟知端口**。此外，**客户和服务器都必须不停地运行**。其原因是请求报文由管理器（客户）发出，而 `Trap` 报文由代理（服务器）发出。
## 28.2.9 安全性
SNMPv3与SNMPv2的主要差别是提高了安全性。SNMPv3提供两类安全：**通用的和专用的** `general and specific` 。SNMPv3提供了报文鉴别、安全性与管理器授权 `message authentication, privacy, and manager authorization` 。这三个方面的问题将在[第31章]()中讨论。另外，SNMPv3允许管理器远程修改安全配置，即管理器不必物理存在于管理器站点 `the manager does not have to be physically present at the manager station` ，或者说在管理器站点的管理器可以没有物理设备。

