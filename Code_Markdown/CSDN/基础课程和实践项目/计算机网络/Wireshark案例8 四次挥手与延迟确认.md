上个月收到了一封读者来信，说我上本书中的一个截图似乎有些问题，与TCP协议不相符。**理论上TCP断开连接时的四次挥手应该是图1这样的（假设是服务器先要求断开）**。
图1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307071718046.png)
**现实抓到的大多数网络包中，X和Y的值也符合这个公式**。如图2所示，你可以把这些数字套进图1的X和Y计算一下，看看是否符合规律。
图2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307071719308.png)

可是这位读者发现上本书中却有图3这样的一张图。仔细看42号包的Ack=442，按照上面的理论它本应该是Ack=442+1=443的，难道是客户端忘记做X+1了？
图3
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307071725901.png)
这封来信让我十分震惊，因为该图本身演示的是FTP协议，没想到这位读者连传输层的细节都研究了，如此精细的读法让我觉得写书压力好大；而且这个发现十分中肯，我也觉得是客户端忘记作X+1了，出版之前竟然没注意到这个bug。

书中出了差错还不算是最糟糕的，更大的问题是在很多机器上抓包都发现了这个现象。你可不要小瞧它，四次挥手时用错Ack值会有什么后果呢？**它可能导致TCP连接断开失败，留下一个本不应该存在的连接，久而久之就会导致新连接建立失败。那就属于大bug了**，得赶紧上报才行。奇怪的是我做了几个实验都发现能成功断开，难道是我对协议的理解有偏差吗？

在接下来的几天里，我仔细地查阅了TCP的多个RFC版本，比如RFC793、1323、5681等，企图找出一个相关的解释，但都没有找到。几天后我跟Patrick（是的，就是我上本书中介绍的那位奇人）聊天时提到了这件事情，老人家很快就回答，“**你考虑过延迟确认对四次挥手的影响吗？这个包一点问题都没有哦**。”延迟确认我当然知道了，它省掉了四次挥手中的第二个包，变成下面图4的样子。
图4
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307071730765.png)
我在生产环境中也抓到过这个现象。见图5的33、34、35号包，就符合上述的模型。可是这跟图3的现象还是不一样啊。
图5
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307071732422.png)

Patrick进一步点拨，如果拿掉图3中的42号包，不就跟图5的延迟确认场景一模一样吗？**也是用三个包完成了挥手**。那42号包又是怎么多出来的呢？我很快也想通了：**这些包是在服务器上抓的，网络上又存在延迟，所以跟客户端上看到的顺序可能不一样**。我的眼睛看着服务器上抓的包，脑子却从客户端的角度思考，所以才会被混淆。那在客户端上看到的包应该是怎样的呢？

发挥一下想象力，真相应该如图6所示，网络延时导致41号包和42号包在传输时发生了时间上的“交叉”。**从客户端的角度看，41号包和42号包的顺序应该颠倒一下才对**。也就是说**42号包根本就没有参与四次挥手过程，它只是用来确认收到40号包而已，但由于网络延迟使它到达服务器时排在了41号包后面，所以看上去就像挥手过程的一部分。更巧的是延迟确认把四次挥手减少成3个包，所以就更有迷惑性了**。
图6
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307071739973.png)

多谢这位眼尖的读者。虽然没有发现大bug，但这个发现对我们做网络分析非常有借鉴意义。在本书后面的一些文章中，还会讲到类似的情况。如果你在这里已经觉得有点晕了，建议再细细阅读一遍。**作为Wireshark熟练工，必须能从一端抓到的网络包中推测出另一端的概况，才能分析出那些最复杂的问题**。

