@[toc]

在因特网模型的应用层中，许多应用都遵循客户机/服务器模式。**客户端/服务器应用程序**可以分为两类：一种直接被用户使用，例如电子邮件；另一种是支持其他应用程序的应用程序，如**域名系统** `Domain Name System, DNS` 就是一种支持程序，它被其他的应用程序使用，例如电子邮件。

图25.1举例说明了，**DNS客户端/服务器程序**如何支持「电子邮件程序找到电子邮件接收者的IP地址」。==电子邮件程序的用户可以知道接收者的电子邮件地址，但是IP协议需要知道IP地址。DNS客户端程序就向DNS服务器发送查询请求，获取与电子邮件地址相对应的IP地址==。
![在这里插入图片描述](https://img-blog.csdnimg.cn/0eb65600e95e44ec9c6ea600bcaeff50.png)
为了识别一个实体，TCP/IP协议使用IP地址，唯一地确定一台主机到因特网的连接。然而，**人们更喜欢名字而不是数字地址**，所以需要一种能够完成「**名字到地址**」或「**地址到名字**」的映射的系统。==域名系统就用唯一的、用户友好的名字，标识因特网上的每一台主机==。

在因特网发展初期，使用一个**主机文件** `host file` 完成映射。主机文件只有两列：名字和地址。**每台主机可以将主机文件存储在主机磁盘中**（Windows 7/10/11系统中，主机文件在 `C:\Windows\System32\drivers\etc` 中），并以一个标准主机文件为依据，定期地进行更新。当程序或用户需要将某一名字映射到一个地址时（或相反），主机就查询主机文件并找到相应的映射。 

但目前，不再可能用一个单独的主机文件，将每个地址与名字关联起来，反过来也是一样，主机文件会因为太大而无法存储在每一台主机中。另外，也不能每次在发生变化时，更新世界上所有的主机文件。

一种解决方案是**将全部主机文件存储在一台单独的计算机中**，允许每一台需要映射的计算机访问这个集中化的信息。但是，即使这样也会在因特网上产生非常大的通信量。

另一种解决方案也是目前所使用的，是**将这种巨大的信息数据分割成许多更小的部分，并将每一部分存储在不同的计算机中**。采用这种方式，需要映射的计算机可寻找到最近一台持有所需信息的计算机。**域名系统**就使用这种方法。

本章先讨论DNS的概念和信息，然后描述DNS协议本身。
> 下面是与DNS相关的RFC：
> ```cpp
> 799, 811, 819, 830, 881, 882, 883, 897, 920, 921, 1034, 
> 1035, 1386, 1480, 1535, 1536, 1537, 1591, 1637, 1664, 
> 1706, 1712, 1713, 1982, 2065, 2137, 2317, 2535, 2671
> ```
> 有时间可以看一眼。

---
# 25.1 名字空间
==为实现无二义性，分配给机器的名字必须从**名字空间** `name space` 中仔细地选择，该名字空间**完全控制**对名字和IP地址的绑定==。即，因为地址是唯一的，所以名字也必须是唯一的。名字空间将每个地址映射到一个唯一的名字，它可以按两种方式组织：平面的 `flat` 和层次的 `hierarchical` 。

## 25.1.1 平面名字空间
在**平面名字空间** `flat name space` 中，一个名字分配给一个地址。空间中的名字是一个*无结构的字符序列* `sequence of characters without structure` 。名字之间可能有、也可能没有公共部分，即使有公共部分，也没有实际含义。平面名字空间的缺点是，==它必须集中控制，才能避免二义性和重复，因而不能用于如因特网这样的大规模系统中==。

## 25.1.2 层次名字空间
在**层次名字空间** `hierarchical name space` 中，每个名字由几个部分组成。第一部分可以定义组织的性质，第二部分可以定义一个组织的名字，第三部分可以定义组织的部门等等。==在这种情况下，**分配和控制名字空间的机构就可以分散化**，涉及名字的各种任务也可分散化==。中央管理机构可以分配名字的一部分，这部分定义组织的性质和组织的名字，**名字其他部分的分配可交给这个组织自身**。这个组织可以给名字加上后缀（或前缀）来定义主机或者其他资源，这个组织的管理机构不必担心，「为一个主机选择的后缀」会被其他组织所采用，因为即使地址的某一部分相同，整个地址也是不同的。

例如，假定两个学院和一个公司，都将它们的一台计算机命名为 `challenger` ，第一个学院由中央管理机构分配的名字是 `fhda.edu` ，第二个学院获得的名字是 `berkeley.edu` ，而公司获得的名字是 `smart.com` 。当这些组织的每一个，在已有的名字上加上名字 `challenger` 后，得到了三个不同的名字：`challenger.fhda.edu, challenger.berkeley.edu, challenger.smart.com` 。这些名字是唯一的，不需要由中央管理机构来分配。**中央管理机构只控制名字的一部分，而不是整个名字**。

---
# 25.2 域名空间
为了获得层次结构的名字空间，设计了**域名空间** `domain name space` 。==在这种设计方式中，所有的名字由根在顶部的倒置树结构== `an inverted-tree structure with the root at the top` ==定义，该树最多有 $128$ 级：$0$ 级（根节点）$\sim 127$ 级==（见图25.2所示）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/6ec13c4be63c4f8eb754a9b44a16938e.png)
## 25.2.1 标号
树上的每一个节点有一个**标号** `label` ，==标号是一个最多为 $63$ 个字符的字符串，**根结点的标号是空字符串（空串）**==。DNS要求**每一个节点的子节点**（从同一节点分支出来的节点）**有不同的标号**，这样就确保了域名的唯一性。

## 25.2.2 域名
树上的每个节点都有一个域名。一个完全的**域名** `domain name` 是**用点 `.` 分隔的标号序列**。约定俗成地，==域名总是从节点向上读到根节点，最后一个标号是根节点的标号（空）==，这表示一个完全的域名总是以一个空标号结束，也意味着**最后一个字符是一个点 `.`** ，因为空字符串表示什么也没有。图25.3给出了某些域名。
![在这里插入图片描述](https://img-blog.csdnimg.cn/fdc40d7fd7f54c6385be96113516d0e7.png)
### 1. 全称域名
==如果一个标号序列由「主机标号、以及向上到达根节点所经过的各级节点的标号」组成，且以一个空字符串结束，则称它为**全称域名**== `fully qualified domain name, FQDN` 。**全称域名**是包含一台主机全名的域名，它包含所有的标号，从最具体的到最一般的标号，并**能唯一地定义一台主机的名字**。例如，域名 `challenger.atc.fhda.edu.` 是一个全称域名，代表安装在 `De Anza` 大学的高级技术中心 `ATC` 的、一台名字为 `challenger` 计算机。

**DNS服务器只能匹配一个FQDN到一个IP地址** `A DNS server can only match an FQDN to an
address` 。注意：名字必须以空标号结束，但是由于空标号表示空，所以这种标号以一个点 `.` 结束。

### 2. 部分域名
如果一个域名不是以空字符串结束，则称为**部分域名** `partially qualified domain name, PQDN` 。部分域名起始于一个节点，但没有到达根节点，它不全部包括主机到根节点之间所有节点的标号。==当这个需要解析的名字属于和客户机相同的站点时，使用部分域名。这种情况下，解析程序（即DNS客户端）能够提供省略的部分，称为**后缀** `suffix` ，以创建FQDN==。

例如，如果在 `fhda.edu.` 站点的一个用户，想要获取 `challenger` 计算机的IP地址，用户就可定义这个部分域名 `challenger` 。在将域名地址传送到DNS服务器之前，DNS客户端在部分域名 `challenger` 后加上后缀 `atc.fhda.edu.` 。图25.4表示了一些FQDN和PQDN。
![在这里插入图片描述](https://img-blog.csdnimg.cn/11dc55358f924acc82814de4f6826007.png)
**DNS客户端通常会保存一个后缀列表**。下面这些是 `De Anza` 大学的后缀列表。空后缀表示什么也没有，当用户定义一个全称域名的时候，就会加上这个后缀。
```cpp
atc.fhda.edu
fhda.edu
null
```
## 25.2.3 域
==**域** `domain` 是域名空间的一棵子树。这个域的名字是子树顶部节点的域名==。图25.5列出了一些域。注意：一个域本身也可以再划分为多个域，即**子域** `subdomain` 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/601176f127754924b88653e5515bfe09.png)

---
# 25.3 名字空间的分布
必须将域名空间所包含的信息存储起来。然而，只使用一台计算机存储如此大容量的信息，效率非常低、不安全。效率低主要是因为**响应来自世界各地的请求，会给系统造成非常大的负荷**，不安全主要是因为**任何故障将使整个数据库无法使用**。
## 25.3.1 名字服务器的层次结构
解决这些问题的办法是，==将信息分布在多台称为**DNS服务器** `DNS server` 的计算机中==。

一种方法是，将整个空间划分为多个基于第一级的域，即让根节点保持不动，但创建许多「与第一级节点一样多的域（子树）」。这样创建的域会很大，==DNS允许将域进一步划为更小的域（子域），每一台服务器对一个大的域或者较小的域是负责的（授权的）==，即**与建立名字的层次结构（域名空间）一样，也建立了服务器的层次结构**（见图25.6）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/8b440cc5600a440dab618685bc9d68a8.png)
## 25.3.2 区域
==既然完整的域名层次结构不能保存在单一的服务器上，那么它被分在多个服务器上，**一个服务器负责或授权的范围**称为**区域** `zone`== 。我们可以将一个区域定义为「整个树中的一个连续的部分」。
- 如果服务器负责一个域，且这个域没有进一步被划分为更小的子域，**此时域和区域是相同的**。服务器有一个数据库，称为**区域文件**，它保存这个域中所有节点的信息。
- 如果服务器将它的域划分为多个子域，并将其部分授权委托给其他服务器，那么域与区域就不同了。  ==在子域节点的信息会存放在较低层次的服务器中，原来的服务器则保存「到这些较低层次服务器的某种引用 `reference`」==。当然，原来的服务器并不是完全不负责任，它仍然拥有一个区域，只是将详细的信息保存在较低层次的服务器上（图25.7）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c01150e718b04537b5fe5fc9b90ab03b.png)
一台服务器可以划分自己的部分域 `divide part of its domain` 并委托责任，但仍然为它自己保存一部分域。在这种情况下，它的区域是由「具有详细信息的那部分域（这部分域没有被委托）」以及「对已授权部分的引用 `references to those parts that are delegated` 」所组成。

## 25.3.3 根服务器
**根服务器** `root server` 是指==它的区域由整棵树组成的服务器==。**根服务器通常不保存关于域的任何信息**，只是将其委托（授权）给其他服务器，并保存与这些服务器的参照关系。目前有多个根服务器，**每一台都覆盖了整个域名空间**，这些服务器分布在世界各地。
## 25.3.4 主服务器和辅助服务器
DNS定义了两种类型的服务器：主服务器和辅助服务器。
- **主服务器** `primary server` 是指==存储了授权区域有关文件的服务器== `A primary server is a server that stores a file about the zone for which it is an authority` ，它负责创建、维护和更新区域文件，并将区域文件存储在本地磁盘中。
- **辅助服务器** `secondary server` ==负责从另一个服务器（主服务器或辅助服务器）传输一个区域的全部信息，并将文件存储在它的本地磁盘中==。
- **辅助服务器既不创建也不更新区域文件**。如果需要更新，则必须由主服务器来完成，由主服务器发送更新的版本到辅助服务器中。
- 主服务器能够从磁盘文件中装载所有信息，辅助服务器从主服务器中装载信息。当辅助服务器从主服务器中下载信息时，这称为**区域的传递**。

主服务器和辅助服务器对它们所服务的区域都有控制权。**这种设计思想并不是把辅助服务器置于一个较低的授权层次上，而是为了建立数据的冗余备份**，这样当一台服务器出现故障时，另一台服务器可以继续为客户机服务。注意：==一台服务器可能是某个特定区域的主服务器，同时也是另一个区域的辅助服务器==。所以，当提到一个服务器作为主服务器或辅助服务器时，需要说清楚所指的是哪个区域。

---
# 25.4 因特网中的DNS
DNS是一种可以在不同平台上使用的协议。在因特网中，域名空间（树）被划分为三个部分：**通用域**、**国家域**和**反向域**（图25.8）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/cc0e54147538495d9c7fe7772ee6504f.png)
## 25.4.1 通用域
**通用域** `generic domain` 按照「已经注册主机的一般行为」对主机进行定义 `define registered hosts according to their generic behavior` 。树中的每个节点定义一个域，每个节点都是到域名空间数据库的一个索引（图25.9）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/8f8089c397534226af6e8a9b2ff47624.png)我们从这棵树中可以看出，在通用域中的第一层允许有 $14$ 个可能的标号，这些标号描述了表25.1中列出的组织机构类型。
![在这里插入图片描述](https://img-blog.csdnimg.cn/69bfb175340548f6be110f482ee1a896.png)

## 25.4.2 国家域
**国家域** `country domain` 这一部分，**使用两个字母的国家缩写**（例如 `us` 代表美国），==（国家域的）第二级标号可以是组织机构，或者更具体一些，由各个国家自己指定==。例如，美国使用州的缩写作为国家域的子域划分（如 `ca.us.` ）。

图25.10展示了国家域部分。地址 `anza.cup.ca.us` 可以理解为美国加州的 `Cuperetino` 的 `De Anza` 学院。
![在这里插入图片描述](https://img-blog.csdnimg.cn/07cd7eb221fb4ed587b8f1ab6a4c98b5.png)

## 25.4.3 反向域
**反向域** `inverse domain` **用于将地址映射为名字**。例如，==当服务器接收到客户机完成某项任务的请求时，就会发生这种情况==。尽管服务器中有一个包含着授权客户的列表文件，但文件中只列出了客户机的IP地址（从接收到的IP分组中提取出来）。为了确定该客户端是否在授权列表中，服务器就用它的解析程序，向DNS服务器发送一个查询，并请求将地址映射为名字。

这种类型的查询，称为**反向**或**指针查询** `inverse or pointer query, PTR` 。为了处理一个指针查询，在域名空间中要增加一个反向域，并且其==第一级节点称为 `arpa`（由于历史原因），第二级仍是单（个）节点，称为 `in-addr`（用于反向地址）==，域的其他部分定义IP地址。

**处理反向域的服务器也是层次结构的**。这意味着地址的网络号比子网号的层次更高（位于更上层），而子网号所处的层次要高于主机号所处的层次。同样，为整个网站服务的服务器应该比为子网服务的服务器，处于更高层次。==与通用域或国家域相比，这种配置方法使得反向域看起来是倒置的==（但从上到下，都是从大范围到小范围）。按照**由下到上读取标号的约定**，一个IP地址如 `132.34.45.121`（一个 $B$ 类地址，网络号是 `132.24`）会读取为 `121.45.34.132.in-addr.arpa` 。参见图25.11关于反向域配置说明的图例。
![在这里插入图片描述](https://img-blog.csdnimg.cn/04e0528f30894a20931c015b36339bf6.png)

---
# 25.5 解析
将名字映射为IP地址，或将IP地址映射为名字的过程，称为**名字-地址解析**。

## 25.5.1 解析程序
DNS是一个客户机/服务器程序。==需要将地址映射为名字或将名字映射为地址时，主机要调用一个称为**解析程序** `resolver` 的DNS客户程序==（即DNS客户端称为**解析程序**）：
1. 解析程序用一个**映射请求** `mapping request` ，访问最近的一个DNS服务器。
2. 如果服务器含有该消息，它就满足解析程序的请求；否则，它将解析程序交付给其他的服务器，或者查询其他的服务器来提供这种信息。
3. 当解析程序接收到映射后，它解释这一响应，以确定它是一个真正的解析，还是一个差错，最后将结果传递给发出这一请求的进程。

## 25.5.2 名字到地址的映射
**多数情况下，解析程序将域名提交给服务器，请求给出对应的IP地址**。这种情况下，服务器检查通用域或国家域，以查找相应的映射。
- 如果域名来自于通用域部分，解析程序就会收到一个域名，如 `chal.atc.fhda.edu.` 。由解析程序将这个查询发送到本地DNS服务器进行解析。如果本地服务器不能解析这一查询，它或者把解析程序提交给其他的服务器，或者直接询问其他的服务器。
- 如果域名来自于国家域部分，那么解析程序会接收到类似于 `ch.fhda.cu.ca.us.` 形式的域名，处理过程与上相同。

## 25.5.3 地址到名字的映射
客户机向服务器发送IP地址，请求映射为域名。如前所述，这被称为一个**PTR查询**。要回复这种查询，DNS使用反向域。然而，==在这种请求中，IP地址必须反过来，并且将 `in-addr` 和 `arpa` 两个标号附加在最后，以创建能够被反向域这一部分接收的域==。例如，如果解析程序接收到的IP地址为 `132.34.45.121` ，那么**解析程序会首先将地址反过来，然后在发送之前附加两个标号**，发送的“域名”是 `121.45.34.132.in-addr.arpa.` ，它由本地DNS接收并解析。

## 25.5.4 递归解析
客户端（解析程序）可以从一个名字服务器中请求一个递归的应答 `a recursive answer` ，这意味着**解析程序期望服务器提供最终的答案**。如果服务器是这一域名的授权服务器，它会检查它的数据库并做出响应；如果服务器不是授权服务器，它会把请求发送给另一服务器（通常是父服务器），并等待响应。如果父服务器是授权服务器，它就做出响应；否则，它仍然把这个查询发送给另一个服务器。==当这个查询最终得到解析后，响应就后向传送，直到最终到达发出请求的主机==。这就是**递归解析** `recursive resolution` ，如图25.12。
![在这里插入图片描述](https://img-blog.csdnimg.cn/8fb849d052b64f1980220b4af8a7a543.png)
## 25.5.5 迭代解析
如果客户端（解析程序）没有请求一个递归的应答，那么映射可以迭代的形式进行 `the mapping can be done iteratively` 。如果服务器是该名字的授权服务器，那么它发送应答；如果它不是，它就返回它认为「可以解析该查询的服务器的IP地址」（给客户端），由客户端负责向第二台服务器重复发送请求。如果新的地址解析服务器能够解析这一名字，那么它就用IP地址响应这一请求；否则，它向客户端返回新服务器的IP地址。这时，客户端必须向第三台服务器重复该请求。==这一过程称为**迭代解析** `iterative resolution` ，因为客户端向多台服务器重复同样的请求==。在图25.13中，客户端在从 `mcgraw.com` 服务器得到应答之前，向四台服务器发送了查询请求。
![在这里插入图片描述](https://img-blog.csdnimg.cn/9c84b7794d374bc5bf3f0a111e119657.png)
## 25.5.6 高速缓存
每当服务器接收到查询一个不属于自己域的名字时，它需要搜索自己的数据库，以查找一台服务器的IP地址。缩短这一查询时间，能提高效率。DNS使用一种称为**高速缓存** `caching` 的机制，处理这一问题。

当一个服务器向另一个服务器请求映射、并得到回应时，它在将该回应发送给客户端之前，先将这一信息存储在高速缓存中。如果同一客户端或者另一个客户端请求同一映射时，它会检查其高速缓存、并解决这一问题。然而，==要通知客户这一响应来自于高速缓存、而不是来自于授权的信息源，该服务器会将这一响应标志为**非授权性的**== `unauthoritative` 。

高速缓存能加速解析过程，但仍存在问题。**如果一台服务器长时间缓存一个映射时，可能会发送给客户端一个过期的映射**。为了防止这一情况，使用了两个技巧：
- 第一个，授权服务器总是将称为**生存时间** `TTL` 的信息添加在映射上，生存时间定义了接收服务器可以将信息放入高速缓存的时间（以秒计。==超过这一时间，该映射就变为无效，而任何查询必须再次发送到授权服务器==。
- 第二个，DNS要求每一台服务器对它缓存的每一个映射，保留一个 `TTL` 计数器，高速缓存会定期检查，并清除掉 `TTL` 已经过期的那些映射。

---
# 25.6 DNS报文
==DNS有两种类型的报文：查询和响应，这两种类型的报文具有相同的格式==。**查询报文** `query message` 由头部和**查询记录** `question records` 组成；**响应报文** `response message` 由头部、查询记录、**响应记录** `answer records` 、**授权记录** `authoritative records` 和**附加记录** `additional records` 组成（图25.14）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f963835484654f6e85e9b4a2441ff232.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/bcadff2ba10f496f8b039d64b7a818ef.png)
## 1. 头部
查询和响应报文的头部格式相同，查询报文头部的某些字段设置为 $0$ 。头部为 $12$ 个字节，格式如图25.15所示：
- 客户端使用**标识**子字段来匹配对查询的响应，客户端每次发送查询时，会使用不同的标识号。服务器在对应的响应中会重复这一编号。
- **标记**是子字段的集合，这些子字段定义了报文的类型（查询或者响应）、响应的类型、期望的解析类型（递归或者迭代）等。
- **查询记录数**是指==该报文中查询部分所含请求的数量==。
- **响应记录数**是指==响应报文中响应部分所含应答记录的数量==，在查询报文中它的值为 $0$ 。
- **授权记录数**是指==响应报文中授权部分所含授权记录的数量==，在查询报文中它的值为 $0$ 。
- 最后一项，**附加记录数**是指==响应报文中附加部分所含附加记录的数量==，在查询报文中它的值为 $0$ 。

## 2. 查询部分
它由一条或多条查询记录组成，查询和响应报文都含有这一部分。下一节中讨论查询记录。
## 3. 响应部分
它由一条或多条资源记录组成，它仅存在于响应报文中。这一部分包括**从服务器到客户端（解析器）的应答**。下一节中讨论资源记录。
## 4. 授权部分
它由一条或多条资源记录组成，它仅存在于响应报文中。这一部分给出了**用于查询的一台或多台授权服务器的信息**（域名）。
## 5. 附加消息部分
它由一条或多条资源记录组成，它仅存在于响应报文中。这一部分给出了**有助于解析程序的附加信息**，例如，服务器可以在授权部分，为解析程序提供授权服务器的域名，并且把「同一授权服务器的IP地址」包含在附加信息部分中。
 
---
# 25.7 记录的类型
从25.6节可以看出，DNS使用了两种类型的记录。在查询和响应报文的查询部分，使用了**查询记录**；在响应报文中的响应、授权、附加消息部分，使用了**资源记录**。
## 25.7.1 查询记录
客户机使用**查询记录** `question record` 从服务器获取信息，它包含了域名。
## 25.7.2 资源记录
每一个域名（在树中的每个节点）都与一个**资源记录** `resource record` 相关联。服务器数据库包含了所有的资源记录，服务器还返回资源记录给客户机。

---
# 25.8 注册机构
新的域名是怎样加入到DNS中呢？这是通过**注册机构** `registrar` 来完成的，一个熟知的商业实体是因特网名字和编号分配组织 `ICANN` 。==注册机构首先确认询问的域名是唯一的，然后将它输入到DNS数据库中，这是需要收费的==。

现在，有很多的注册机构，它们的名字和地址可以在网站[https://www.intenic.net](https://www.internic.net/)中找到。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f510ac4e98604b4e8089f909a7767744.png)

为了能够注册，组织机构需要给出它的服务器的主机名和IP地址 `the name of its server and the IP address
of the server` 。例如，一个新的商业机构名为 `wonderful` ，它有一台名为 `ws` 的服务器，IP地址为 `200.200.200.5` ，就需要将以下的信息交给一个注册机构。
```cpp
Domain name: WS.wonderful.com
IP address: 200.200.200.5
```
---
# 25.9 动态域名系统 `DDNS`
在设计DNS时，没有人预料到会有如此多的地址变化 `address changes` 。在DNS中，有了一个变化时，例如增加一台新主机、移除一台主机或改变一个IP地址，就必须对DNS主文件 `the DNS master file` 进行更改。这些类型的变化，涉及许多手工的更新。因特网今天的规模，已经不允许使用这种手工操作。

DNS主文件必须能动态更新。**动态域名系统** `Dynamic Domain Name System, DDNS` 就是为满足这种需求而设计的。==在DDNS中，当名字和地址之间的绑定确定时，通常是由DHCP（第21章）给主DNS服务器发送这种消息，主服务器更新这一区域==。通知辅助服务器的方法，可以以**主动方式**或者以**被动方式**——在主动通知方式中，主服务器向辅助服务器发送关于区域变化的报文；在被动通知方式中，辅助服务器定期地检查是否有任何变化。**无论使用哪一种方式，当得到变化的通知时，辅助服务器会请求整个区域的信息（区域传输）**。

为了提供安全性，以防止对DNS记录的非授权更改，DDNS可以使用鉴别机制。

---
# 25.10 封装
DNS可以使用UDP或者TCP协议。在这两种情况下，**服务器使用的熟知端口号是 $53$** 。当响应报文的长度小于 $512$ 字节时，就使用UDP。因为大多数UDP分组有 $512$ 字节分组大小的限制；如果响应报文的长度大于 $512$ 字节，则必须使用TCP连接。在这种情况下，可能会发生以下两种情况：
- ==如果解析服务器预先知道响应报文超过 $512$ 字节，那么它必须使用TCP连接==。例如，如果辅助名字服务器（作为客户端）需要从主服务器进行区域传输，那么必须使用TCP连接，因为被传输的信息通常是超过 $512$ 字节的。
- ==如果解析程序不知道响应报文的大小，那么可以使用UDP端口==。但是，如果响应报文超过 $512$ 字节，那么服务器会截断这一报文。**此时解析程序会开启TCP连接，并重复该请求**，从服务器中获得完整的响应。


