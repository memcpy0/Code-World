@[toc]


网络利用硬件和软件的组合，将数据从一个地点发送到另一地点。硬件由「能够将信号从网络的一点传输到另一点的物理设备」组成，软件由指令集合组成，它使我们所期待的来自网络的服务成为可能。

可将网络的任务与运用计算机解决数学问题的任务进行比较。计算机解决数学问题时，最基础的工作是由计算机硬件完成的。然而，如果只使用硬件，这将是一项十分冗长乏味的工作。如果软件能够掌握这些情况，那么就可以很容易完成这些任务。在最高层，程序能够指导问题解决的过程。而像实际的硬件该如何完成任务之类的细节问题，则留给「由更高的层来调用的软件层」来完成`thedetailsofhowthisisdonebytheactualhardwarecanbelefttothelayersofsoftwarethatarecalledbythehigherlevels`。

计算机网络的情形与之相似。例如，将一份电子邮件从世界上的一个地点发送到另一个地点的任务，可以划分成几个子任务，每个子任务都是由一个强立的软件包来完成。每一份软件都使用另一软件包提供的服务来完成自己的工作。在最底层，将一个信号或一组信号从源计算机发送到目的计算机。

本章给出**网络层次**`thelayersofanetwork`的总体概念，并讨论每一层各自的功能。这些层在以后的各章中详细描述。

---
#2.1任务分层
**在日常生活中就使用层次的概念**。举个例子，有两位朋友通过邮寄信件互相通信。如果没有邮局提供的服务，将信件发送给朋友的过程将是十分复杂的。图2.1显示了该任务是如何完成的。
![图2.1发送信件所包含的任务](https://img-blog.csdnimg.cn/eea4d2c779f04a9a9a3e3508f4cea40f.png)


## 2.1.1发送方、接收方和载体
在图2.1中有一个发送方、接收方和传输信件的载体。**任务具有层次结构**。下面按顺序描述一下在发送方发生的活动。
-高层：发送方写信，将信件装入信封，写下发送方和接收方的地址，将信件投入信箱。
-中间层：信件被邮递员取出并送到邮局。
-低层：邮局对信件进行分拣。邮车转运信件。
-路途中：然后，邮件走上到达接收方的路途。在到达接收方的本地邮局的路途中，它实际上还要经过中央邮局。另外，信件可能是通过卡车、火车、飞机、船或者以上交通工具的组合进行转运的。

下面按顺序描述一下在接收方发生的活动。
-低层：邮车将信件转运到邮局。
-中间层：信件分拣后递送到接收方的信箱。
-高层：接收方取出信件，打开信封，读信。

## 2.1.2层次结构
根据分析，在发送方有三个不同的活动，在接收方也有另外三个活动。在发送方和接收方之间转运信件的任务是**由邮车**完成的。==不能一眼看出来的是，这些任务必须按照给定的层次顺序完成==。在发送方，信件必须是先写出、投进邮箱，然后才能让邮递员拣起再递送到邮局。在接收方，信件必须先放入接收方信箱，然后才能被接收方取出并被阅读。

## #服务
在高层的发送方使用中间层提供的服务，中间层使用低层提供的服务，低层使用邮车提供的服务。在接收方，每一层都使用其直接下层提供的服务。

1990年以前，在数据通信和网络文献资料中、占有主要地位的分层结构模型是**开放系统互联**`OpenSystemInterconnection,OSI`模型。大家都认为OSI模型会成为数据通信的最终标准，但这种情况没有出现。**TCP/IP协议族成为了占统治地位的业务体系结构**，因为该协议族已在因特网中被大量采用，并对其已作过广泛测试，而OSI模型却从未完全实现过。本节简要讨论OSI模型，然后集中关注TCP/IP协议族。

现在人们说到TCP/IP时，指的已经不止是TCP和IP两个协议，而是包括了==ApplicationLayer、TransportLayer、InternetLayer和NetworkAccessLayer==的四层模型。TCP处于TransportLayer，而IP处于InternetLayer。鲜为人知的是，一开始这两个协议并没有分层，而是合在一起的。当时的计算机科学家JonPostel对此批评说：
>“Wearescrewingupinourdesignofinternetprotocolsbyviolatingtheprincipleoflayering.SpecificallywearetryingtouseTCPtodotwothings:serveasahostlevelendtoendprotocol,andtoserveasaninternetpackagingandroutingprotocol.Thesetwothingsshouldbeprovidedinalayeredandmodularway.Isuggestthatanewdistinctinternetworkprotocolisneeded,andthatTCPbeusedstrictlyasahostlevelendtoendprotocol.”（我们违背了分层原则，从而搞砸了网络协议的设计。具体来说，我们正在尝试使用TCP来做两件事：作为一个主机级别的端到端协议；同时也作为网络的分组和路由协议。这两件事本应该用分层和模块化的形式来实现。我建议设计一个新的网络互联协议，并且把TCP严格限制为主机级别的端到端协议。）
—JonPostel,IEN2,1977

这个建议一年后被采纳了，第三版的协议决定把TCP和IP分离开来，并且延续至今。无巧不成书，JonPostel恰好是Vinton的高中同学，也是阿帕网项目的同事。他在1998年因病去世时，Vinton为他写了一篇感人至深的讣告，并且作为RFC2468发布。据我所知，这是唯一一篇无关技术的RFC。对一位计算机科学家来说，这也许是最有意义的纪念方式。我们今天还可以通过http://tools.ietf.org/html/rfc2468阅读它。

TCP/IP的设计非常成功。30年来，底层的带宽、延时，还有介质都发生了翻天覆地的变化，顶层也多了不少应用，但TCP/IP却安如泰山。它不但战胜了国际标准化组织的OSI七层模型，而且目前还看不到被其他方案取代的可能。第一代从事TCP/IP工作的工程师，到了退休年龄也在做着朝阳产业。

令人费解的是，现在的大学课程还在介绍OSI七层模型。它和TCP/IP模型的对应关系如图2所示。因为OSI模型的层数太多，很多学生根本理解不了，甚至连顺序都记不住。于是老师们就用“AllPeopleSeemToNeedDataProcessing”来帮助记忆，因为这7个单词的首字母和OSI模型每一层的首字母是一样的。大学的应试教育由此可见一斑。**更奇怪的是学生们走出校园后，会发现这个笨重的七层模型已经没有市场**。

虽然历史上它得到过官方的大力支持，但是市场明显更青睐TCP/IP四层模型。
图2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131623532.png)
按理说OSI是权威组织，它所设计的模型应该是科学的。为什么反而会不受欢迎呢？很多专家都对此有过评论，其中以普度大学特聘教授DouglasComer的批评最为激烈。他曾经在一篇文章里这样写过：“最近有了一些惊人的发现：我们都知道这个七层模型是由一个小组（见图3）完成的，但大家不知道的是，这个小组有一天深夜在酒吧里谈论美国的娱乐八卦。他们把迪斯尼电影里7个小矮人的名字写在餐巾纸上，有个人开玩笑说7对于网络分层是个好数字。第二天上午在标准化委员会的会议上，他们传阅了那张餐巾纸，然后一致同意昨晚喝醉时的重大发现。那天结束时，他们又给七个层次重新起了听上去更科学的名字，于是模型就诞生了。
图3
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131624691.png)
这个故事告诉我们：如果你是标准委员会中的工程师，请不要和同事喝酒—深
夜在酒吧里开的一个拙劣玩笑，却可能成为业界几十年挥之不去的噩梦。”

Douglas是网络界德高望重的前辈，他回到普度大学之前曾是Cisco的Vice
PresidentofResearch，同时也是久负盛名的技术作家，所以他的观点很有代表性。而当时业界普遍对待OSI模型的抵触态度，更是一个有力的佐证。幸好到了今天，**OSI模型几乎名存实亡了，它对我们的影响只停留在还没来得及更新的教科书上**。

---
#2.2OSI模型
国际标准化组织`ISO`成立于1947年，它是一个致力于在世界范围内建立统一国际标准的多国组织。一个能包含络通信各方面的ISO标准是**开放系统互联模型**（见图2.2），它最初于20世纪70年代形成。==**开放系统**`opensystem`是一组协议，它允许任何两个不同系统进行相互通信，而不管其底层结构如何==。建立OSI模型的目的是**使不同系统间的通信变得容易，而不要求对其底层软硬件的逻辑结构做任何改动**。

**OSI模型并不是一个协议，而是一个模型**。利用该模型可以理解并设计一个灵活、健壮和**可互操作**的网络体系结构。
![图2.2OSI模型](https://img-blog.csdnimg.cn/e6082568dea94f75af440e0e97800d4b.png)

OSI模型提供了**一个用来进行网络系统设计的层次化框架**。它由$7$个相互独立、但又有互相关联的层次组成，每一层都定义了「通过网络传递信息`theprocessofmovinginformationacrossanetwork`的流程」的一部分（见图2.2）。深刻理解OSI模型的基本概念是探索数据通信领域知识的一个坚实基础。
## 2.2.1层次化体系
OSI模型由$7$个有序的层组成：物理层（第一层）、数据链路层（第二层）、网络层（第三层）、传输层（第四层）、会话层（第五层）、表示层（第六层）以反应用层（第七层）。图2.3表示了当一个报文从设备$A$到设备$B$传输时所涉及的层次。**当报文从设备$A$到设备$B$时，它可能通过许多中间节点。这些中间节点通常只涉及OSI模型的前三层**。
![图2.3OSI模型中层次间的交互](https://img-blog.csdnimg.cn/ecabc61feb2f45a2862cfb21c70c8798.png)
在建立模型的过程中，设计者将传输数据的过程归结为一些最基本的元素。他们确定了具有相关用途的网络功能，并将这些功能归类到一些独立的功能组。**这些功能组就形成了各个层次**，每一层都定义了一系列与其他层次不同的功能。==通过这种方式进行功能定义和局部化，使设计者能建立一个既全面、又有灵活性的体系结构。最重要的是，OSI模型允许在不兼容系统之间的完全透明化==。

在单台机器中，每一层调用下一层提供的服务。例如，第三层使用第二层提供的服务，同时也向第四层提供服务。在两台机器之间，一台机器上的第$x$层与另一机器的第$x$层进行通信，这种通信由一系列称为**协议**的规则和约定来控制。每台机器上在特定层次进行通信的进程称为**对等进程**`peer-to-peerprocess`。因此，**机器间的通信就是一个使用「适用于给定层次的协议」的对等过程**`Communicationbetweenmachinesisthereforeapeer-to-peerprocessusingtheprotocolsappropriatetoagivenlayer`。
## 2.2.2对等过程
在物理层，通信是直接发生的。在图2.3中，设备$A$将位流传送到设备$B$（通过中间节点）。但是，在更高层次中，通信必须先在设备$A$中从上层传到下层，再传输到设备$B$，然后在设备$B$中再从下层传输到上层。在发送端，每一层都在从直接上层传来的报文加上自己的信息，并将整个分组传到它的直接下层。

在第一层，整个分组被转换成可以传输到接收端设备的形式。在接收端，报文被一层一层地打开，每一层接收并提取对它有意义的数据。例如，第二层将提取对它有意义的数据，并将剩下的传输给第三层。第三层提取对它有意义的数据，并将剩下的传输给第四层，依此类推。

## #1.层间接口
发送设备将数据和网络信息从高层向低层传递，而接收设备将这些信息由低层向高层传递，这个过程是通过相邻两层的**接口**`interface`来实现的。==每一层的接口都定义了该层必须向上层提供的信息和服务，良好定义的接口和层功能可使网络模块化==——只要某一层仍能为上一层提供所期望的服务，该层功能的具体实现就可以在不改变周围层次的基础上进行修改和替换。
## #2.层次组织
$7$个层次分属于$3$个子功能组。第一层、第二层和第三层（物理层、数据链路层和网络层）是**网络支持层**，**它们处理从一个设备到另一个设备数据传输的物理方面问题**（比如，电气特性、物理连接、物理寻址、传输的时序和可靠性）。第五层、第六层和第七层（会话层、表示层和应用层）可认为是**用户支持层**，**它们允许不相关的软件系统间的互操作**。第四层即传输层，将这两个子功能组连接起来，并保证下层是以上层能够使用的形式传输的。

OSI的高层常通过软件来实现，而低层则是由硬件和软件混合实现，但物理层几乎都是由硬件实现。在图2.4中描述了OSI层次的整体结构，`D7`指第七层的数据，`D6`指第六层的数据，依此类推。整个过程从第七层（应用层）开始，然后一层层向下移动。在每一层，数据单元可能被加入**头部**`header`或者**尾部**`trailer`，**通常仅在第二层加上尾部**。当格式化的数据单元经过物理层（第一层）时，它被转换成电磁信号，并在物理链路上传输。
![图2.4使用OSI模型的传输过程](https://img-blog.csdnimg.cn/236530aaeb4844959bdb59f0c964b3a1.png)

到达目的地后，信号传入第一层并被重新转换成数字形式。然后，数据单元由下向上传到OSI各层。当每一数据块到达下一个更高层时，在发送端对应层次附加的头部和尾部就被除去，并执行该层相应的动作。**数据到达第七层时，报文又回到应用层的格式，并可以为接收者使用**。
## 2.2.3封装
图2.4揭示了OSI模型中数据通信的另一个方面：封装。在第七层的一个分组（头部和数据）封装在第六层的一个分组中，第六层的整个分组封装在第五层的一个分组中，依此类推。换言之，==第$N-1$层的分组中的数据部分是第$N$层的完整分组（数据、头部、也可能有尾部）==。

这种概念称为**封装**`encapsulation`，第$N-1$层不知道被封装分组中，那些部分是数据，那些部分是头部或尾部。**对于第$N-1$层来说，来自第$N$层的分组是作为一个整体单元处理的**。

---
#2.3OSI模型的各层功能
在本节中，简要描述OSI模型每一层的功能。
## 2.3.1物理层
**物理层**`physicallayer`包含那些在物理介质上传输位流所必需的功能。==它定义了「接口与传输介质」的机械和电气特性（机械和电气规范），也定义了物理设备和接口为了传输而必须执行的过程和功能==。图2.5表示了对应传输介质与数据链路层的物理层的位置。
![图2.5物理层](https://img-blog.csdnimg.cn/6f6594a272f14c67a25678d249674320.png)
**物理层负责单个比特从一个节点到另一个节点的传递**。物理层考虑以下一系列问题：
-**接口与介质的物理特性**。物理层定义了设备与传输介质之间的接口特性，也定了传输介质的类型。
-**位的表示**。物理层的数据是没有任何解释的**位**`bit`流（由$0$和$1$所组成的序列）。要进行传输，位必须编码成信号一一电信号或光信号。物理层定义**编码**`encoding`的类型（如何将$0$和$1$转换成信号）。
-**数据速率**。**传输速率**`transmissonrate`，即每秒发送的位数，也在物理层定义。换言之，**物理层也定义一个位持续多长时间**。
-**位同步**。发送方与接收方不仅使用相同的比特率，还必须位同步。换言之，**发送方的时钟与接收方的时钟必须同步**。
-**线路配置**。物理层涉及设备与介质的连接。==在点到点配置中，两个设备通过一条专用链路连接。在多点配置中，许多设备共享一条链路==。
-**物理拓扑结构**。**物理拓扑结构定义如何将设备连接成网络**。设备的连接方式可以是网状拓扑结构（每台设备均与其他设备连接）、星型拓扑结构（通过中心设备与其他设备连接）、环状拓扑结构（每台设备与下一台设备连接以组成一个环）和总线拓扑结构（每台设备都在一条公共链路上）。
-**传输方式**。物理层也定义两台设备之间的传输方向：单工、半双工和全双工。在单工方式中，只有一个设备能发送，另一个设备只能接收。单工方式是单向通信。在半双工方式中，两台设备都能发送和接收，但不能在同一时刻。在全双工（或双工）方式中，两个设备能在同一时刻发送与接收。

## 2.3.2数据链路层
**数据链路层**`datalinklayer`将「物理层一一对数据不做任何改动的传输通道」变成可靠的链路，这样可以将物理层的数据无差错地传递给上层（网络层）。图2.6表明了数据链路层与网络层及物理层之间的关系。
![图2.6数据链路层](https://img-blog.csdnimg.cn/3f4054a2fad74e679ce656dc9e5f3d4f.png)
**数据链路层负责帧从一跳（节点）到下一跳（节点）的传递**。数据链路层的具体职责如下：
-**成帧**。数据链路层将「接收到的来自网络层的位流」划分成称为**帧**`frame`的易处理数据单元。
-**物理寻址**。如果帧是发送给网络中不同系统，则数据链路层在帧的头部添加发送方的物理地址与接收方的物理地址。如果帧要发往发送方网络之外的系统，那么接收方的地址就是「连接一个网络到下一个网络的设备的地址」。
-**流量控制**。如果接收方接收数据的速率小于发送方发送的速率，那么数据链路层就会采用流量控制机制，以防止接收方过载。
-**差错控制**。数据链路层增加一些机制，用来**检测与重发损坏帧或丢失帧**，从而增加了物理层的可靠性。还用了一个机制**防止重复帧**。差错控制通常是**在一个帧的结束处增加一个尾部**来处理。
-**访问控制**。当两台或多台的设备连接到同一条链路上肘，数据链路协议必须能决定，在任意时刻由哪一台设备来获取对链路的控制权。

图2.7说明了数据链路层的**跳到跳传递**`hop-to-hopdelivery`，或者称为**节点到节点传递**`node-to-nodedelivery`。
![图2.7跳到跳传递](https://img-blog.csdnimg.cn/e4f8f1a0d0914ccc8233f96e36a6e76f.png)如图2.7所示，两个相邻节点在数据链路层通信。节点$A$发送数据到节点$F$，要经过三次传递。首先，节点$A$的数据链路层发送一个帧到节点$B$（路由器）的数据链路层，其次节点$B$的数据链路层发送一个新帧到节点$E$的数据链路层，最后节点$E$数据链路层发送一个新帧到节点$F$的数据链路层。注意：**三个节点之间交换的帧具有不同的头部值**。从$A$到$B$，以$B$作为目的地址和以$A$作为源地址；从$B$到$E$，以$E$作为目的地址和以$B$作为源地址；从$E$到$F$，以$F$作为目的地址和以$E$作为源地址。如果差错检测包括帧的头部，则尾部的值也可以是不同`Thevaluesofthetrailerscanalsobedifferentiferrorcheckingincludestheheaderoftheframe`。
## 2.3.3网络层
**网络层**`networklayer`负责**将分组从源地址传递到目的地址**，可能会通过多个网络（链路）。尽管数据链路层会监视同一个网络（链路）上两个系统之间分组的传递，但是还需要网络层确保每个分组能够从出发点到达目的地。

如果两个系统连接在同一条链路上，则通常不需要网络层。然而，==如果两个系统在不同的网络（链路）上、并通过网络（链路）之间的设备连接，通常就需要网络层，以完成源端到目的端的传递==。图2.8表示了网络层与数据链路层、传输层的关系。
![图2.8网络层](https://img-blog.csdnimg.cn/e10b0162230e4af6b3ffc284eb452573.png)

网络层负责将各个分组从源地址传递到目的地址。网络层的具体任务是：
-**逻辑寻址**。==物理寻址负责处理本地网络寻址问题，它由数据链路层完成==。**如果一个分组通过网络边界，就需要另一个寻址系统来帮助区分源与目的系统**。网络层给来自上一层的分组增加一个头部，它包括发送方与接收方的逻辑地址。在后面讨论逻辑地址。
-**路由选择**。当一些强立网络或链路连接在一起构成一个互联网（一个由网络连成的网络）或一个更大的网络时，连接设备（称为路由器或网关）把分组送到它们的最终目的地，网络层的功能之一是提供这种机制。图2.9说明了网络层端到端的传递。
如图2.9所示，现在我们需要一个源到目的传递。节点$A$的网络层发送一个分组到节点$B$的网络层，当分组到达路由器$B$时，则该路由器按照该分组的最终目的地（节点$F$）做出决定。
在以后，会看到路由器$B$利用它的路由表寻找下一跳的路由器，该路由器是$E$。所以，节点$B$的网络层发送分组到节点$E$的网络层，节点$E$的网络层再发送分组到节点$F$的网络层。
![在这里插入图片描述](https://img-blog.csdnimg.cn/b9523bc2e5b14767a24aaa301e9e2409.png)

## 2.3.4传输层
**传输层**`transportlayer`负责**整个报文的进程到进程传递**`process-to-processdelivery`，进程是主机上运行的应用程序。==尽管网络层监管各个分组的源端到目的端传递`source-to-destinationdelivery`，但是它并不了解这些分组之间的相互关系。网络层独立处理每个分组，就像每个分组都属于一个独立报文一样，不管实际上是否这样==。传输层正好相反，**它确保整个报文无差错、并按顺序地到达目的地，且在源到目的层次进行差错控制和流量控制**。图2.10表示了传输层与网络层及会话层的关系。
![图2.10传输层](https://img-blog.csdnimg.cn/7b9dabdd5f2648c687af72448a846409.png)

传输层负责一个报文从一个进程到另一个进程的传递。传输层的具体任务如下：
-**服务点寻址**。常常会有许多程序同时在一台计算机上运行，因此==源端到目的端的传递就意味着，不仅是从一台计算机传递到另一台计算机，而是从一台计算机上的一个特定进程（运行的程序）传递到另一台计算机上的一个特定进程（运行的程序）==。因此，**传输层信息的头部就必须包含服务点地址**（也叫端口地址）。网络层将每个分组传送到指定的计算机上，而传输层则将整个报文传送给该计算机上的指定进程。
-**分段和组装**。将报文分解成可传输的片段，并且给这些片段编上序号。这些序号不仅使传输层可以**在接收端将报文正确地组装**，而且可以用来**标识和替换传输中丢失的分组**。
-**连接控制**。传输层可以是无连接的或面向连接的。无连接的传输层将每个片段作为一个独立的分组，并将它传递到目的机器的传输层。而面向连接的传输层，在传递分组之前，需要与目的机器的传输层建立一条连接，所有数据被传输后，该连接择放。
-**流量控制**。如同数据链路层一样，传输层担负流量控制的责任。然而，**这一层的流量控制是在端到端上，而不是在单条链路上**。
-**差错控制**。如同数据链路层一样，传输层担负差错控制的责任。然而，**这一层的差错控制是在进程到进程上，而不是在单条链路上**。==发送方的传输层确保整个报文无差错（损坏、丢失或重复）地到达接收方的传输层，通常通过**重发**来纠正差错==。图2.11说明了传输层进程到进程的传递。
![图2.11一个报文的进程到进程的可靠传递](https://img-blog.csdnimg.cn/fe3f3a8261ed45a7ac758b403c226294.png)


## 2.3.5会话层
前面$3$层（物理层、数据链路层和网络层）提供的服务对某些进程是不需要的。==**会话层**`sessionlayer`是网络的**对话控制器**，它建立、维护和同步通信系统间的交互操作==`Itestablishes,maintains,andsynchronizestheinteractionamongcommunicatingsystems`。

会话层负责对话控制和同步。会话层的具体任务是：
-**对话控制**。**会话层负责建立、管理和终止会话**，允许两个系统进入会话，也负责进入和退出系统。它允许两个进程之间以半双工（一次一个方向）或全双工（一次两个方向）方式进行通信。
-**同步**。会话层允许一个进程在数据流中增加**检查点**或**同步点**`synchronizationpoint`。例如，假定一个系统要传输$2000$页的一个文件，为了确保每收到$100$页就独立地进行确认，每$100$页后应适当插入一个检查点。在这种情况下，如果传输到第$532$页发生崩溃，则在第$501$页处开始重传，而第$1$页到第$500$页不必重传。图2.12描述了会话层与传输层及表示层的关系。
![图2.12会话层](https://img-blog.csdnimg.cn/7ec7fd5ac1ba4779bdf309529711647d.png)
## 2.3.6表示层
**表示层**`presentationlayer`涉及两个系统之间交换信息的语义和语法。图2.13描述了表示层与会话层及应用层的关系。
![图2.13表示层](https://img-blog.csdnimg.cn/a604fe3ba6a34065ac4faed268c918e0.png)

**表示层负责翻译、加密和压缩数据**。表示层的具体任务是：
-**翻译**。两个系统中的进程（运行程序）通常以字符串、数字等格式来交换信息。在传输前，信息必须变换成位流。因为不同计算机采用不同的编码系统，因此**表示层负责不同编码方法之间的互操作**——==发送方的表示层将信息从发送方使用的格式转换成一个公共格式。接收方机器的表示层将公共格式转换成接收方使用的格式==，从而提供不同数据表示的独立性。
-**加密**。为了传输敏感信息，一个系统必须保证秘密。**加密**是指==发送方将原来的信息转换成另一种形式，并在网络上发送转换后的形式==。解密是==将信息转换回它的原始形式==。
-**压缩**。数据压缩减少需要传输数据的位数。**数据压缩对于多媒体（如文本、音频和视频）的传输显得特别重要。**

## 2.3.7应用层
**应用层**`applicationlayer`使得用户（不管是人还是软件）可以访问网络。它**提供了用户接口和服务支持**。比如电子邮件、远程文件访问与传输、共享数据库管理以及其他分布式信息服务。

图2.14说明了应用层与用户和表示层的关系。在许多现有的应用服务中，图中只表示了三种：`X.400`（报文处理服务）、`X.500`（目录服务）和文件传输、访问和管理`filetransfer,access,andmanagement,FTAM`。图中用户正在使用`X.400`发送电子邮件。
![图2.14应用层](https://img-blog.csdnimg.cn/fe6414583386477eb094396d9d35c2de.png)
应用层负责向用户提供服务。应用层的具体服务如下：
-**网络虚拟终端**。==一个网络虚拟终端是物理终端的软件版本，允许用户登录到一台远程主机上==。为此，应用程序在远程主机上创建终端的软件仿真。用户计算机只与这个软件终端对话，而软件终端与主机对话，反之亦然。而远程主机认为自己是在与自己的一个终端通信，因而允许用户登录。
-**文件传输、访问和管理**。这项应用允许用户访问远程计算机上的文件（进行修改或读取数据），从远程计算机上检索文件，以及管理或控制远程计算机上的文件。
-**邮件服务**。提供电子邮件存储转发的基础。
-**目录服务**。提供分布式数据库资源、以及对不同对象和服务的全球信息的访问。

## 2.3.8各层功能小结
图2.15对每层的功能做了小结。
![图2.15各层功能小结](https://img-blog.csdnimg.cn/52b6b7f609da45acad48c148d086f7ae.png)

---
#2.4TCP/IP协议族
**TCP/IP协议族**`TCP/IPprotocolsuite`是在OSI模型**之前**开发的，所以**TCP/IP协议族的层次与OSI模型的层次并不严格对应**。

TCP/IP协议族由$4$个层次组成：**主机到网络层、互联网层、传输层和应用层**`host-to-network,internet,transport,andapplication`。然而，当TCP/IP与OSI模型比较时，则可以说==主机网络层相当于物理层和数据链路层的组合，互联网层等价于网络层，应用层基本上完成了会话层、表示层和应用层的工作，而TCP/IP中的传输层负责会话层的部分功能==。

所以==不妨假定TCP/IP协议族由$5$层组成：物理层、数据链路层、网络层、传输层和应用层。前面$4$层提供**物理标准、网络接口、网际互联和传输功能**，它相应于OSI模型前的$4$层。OSI模型最上面的$3$层由TCP/IP一个称为应用层==（见图2.16）==的单一层来表示==。

**TCP/IP是由相互作用的模块组成的分层协议，每一层提供一个特定的功能，但它们不需要相互依赖**。尽管OSI模型指定了属于每一层的功能，但**TCP/IP协议族的各层却包含一些相对独立的协议**，这些协议依据系统的需要能棍合与匹配。术语*分层*意指==每个上一层协议是由一个或多个下层协议支持的==。

在传输层，TCP/IP定义了$3$个协议：传输控制协议`TCP`、用户数据报协议`UDP`和流控制传输协议`SCTP`。在网络层，由TCP/IP定义的主要协议有网际协议`IP`，尽管还有支持数据运行的其他协议。

网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。一个协议族，比如TCP/IP，是一组不同层次上的多个协议的组合。TCP/IP通常被认为是一个四层协议系统，如图1-1所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202109060.png)
每一层负责不同的功能：
1)链路层，有时也称作**数据链路层**或**网络接口层**，通常包括**操作系统中的设备驱动程序和计算机中对应的网络接口卡**。它们一起处理与电缆（或其他任何传输媒介）的**物理接口细节**。
2)网络层，有时也称作互联网层，处理**分组在网络中的活动**，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。
3)运输层主要为**两台主机上的应用程序**提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。
-TCP为两台主机提供高可靠性的数据通信。它所做的工作包括**把应用程序交给它的数据分成合适的小块交给下面的网络层**，确认接收到的分组，**设置发送最后确认分组的超时时钟**等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。
-而另一方面，UDP则为应用层提供一种**非常简单的服务**。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。**任何必需的可靠性必须由应用层来提供**。
这两种运输层协议分别在不同的应用程序中有不同的用途，这一点将在后面看到。
4)应用层负责处理**特定的应用程序细节**。几乎各种不同的TCP/IP实现都会提供下面这些通用的应用程序：
-Telnet远程登录。
-FTP文件传输协议。
-SMTP简单邮件传送协议。
-SNMP简单网络管理协议。
另外还有许多其他应用，在后面章节中将介绍其中的一部分。

假设在一个局域网（LAN）如以太网中有两台主机，二者都运行FTP协议，图1-2列出了该过程所涉及到的所有协议。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202113929.png)
这里，我们列举了一个FTP客户程序和另一个FTP服务器程序。大多数的网络应用程序都被设计成客户—服务器模式。服务器为客户提供某种服务，在本例中就是访问服务器所在主机上的文件。在远程登录应用程序Telnet中，为客户提供的服务是登录到服务器主机上。

在同一层上，双方都有对应的一个或多个协议进行通信。例如，某个协议允许TCP层进行通信，而另一个协议则允许两个IP层进行通信。
-在图1-2的右边，我们注意到应用程序通常是一个用户进程，而下三层则一般在（操作系统）内核中执行。尽管这不是必需的，但通常都是这样处理的，例如UNIX操作系统。
-在图1-2中，顶层与下三层之间还有另一个关键的不同之处。应用层关心的是应用程序的细节，而不是数据在网络中的传输活动。下三层对应用程序一无所知，但它们要处理所有的通信细节。

在图1-2中列举了四种不同层次上的协议。FTP是一种应用层协议，TCP是一种运输层协议，IP是一种网络层协议，而以太网协议则应用于链路层上。**TCP/IP协议族是一组不同的协议组合在一起构成的协议族。尽管通常称该协议族为TCP/IP**，但TCP和IP只是其中的两种协议而已（该协议族的另一个名字是Internet协议族(InternetProtocolSuite)）。

网络接口层和应用层的目的是很显然的—**前者处理有关通信媒介的细节**（以太网、令牌环网等），而后者处理某个特定的用户应用程序（FTP、Telnet等）。但是，==从表面上看，网络层和运输层之间的区别不那么明显。为什么要把它们划分成两个不同的层次呢==？为了理解这一点，我们必须把视野**从单个网络扩展到一组网络**。

在80年代，网络不断增长的原因之一是大家都意识到只有一台孤立的计算机构成的“孤岛”没有太大意义，于是就**把这些孤立的系统组在一起形成网络**。随着这样的发展，到了90年代，我们又逐渐认识到这种由单个网络构成的新的更大的“岛屿”同样没有太大的意义。于是，人们**又把多个网络连在一起形成一个网络的网络**，或称作互连网(internet)。**一个互连网就是一组通过相同协议族互连在一起的网络**。

构造互连网最简单的方法是把两个或多个网络通过路由器进行连接。它是一种特殊的用于网络互连的硬件盒。路由器的好处是**为不同类型的物理网络提供连接**：以太网、令牌环网、点对点的链接和FDDI（光纤分布式数据接口）等等。

这些盒子也称作IP路由器（IPRouter），但我们这里使用路由器(Router)这个术语。从历史上说，这些盒子称作网关（gateway），在很多TCP/IP文献中都使用这个术语。现在网关这个术语只用来表示**应用层网关：一个连接两种不同协议族的进程**（例如，TCP/IP和IBM的SNA），它为某个特定的应用程序服务（常常是电子邮件或文件传输）。

图1-3是一个包含两个网络的互连网：一个以太网和一个令牌环网，通过一个路由器互相连接。尽管这里是两台主机通过路由器进行通信，**实际上以太网中的任何主机都可以与令牌环网中的任何主机进行通信**。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202116126.png)
在图1-3中，我们可以划分出端系统（Endsystem）（两边的两台主机）和中间系（Intermediatesystem）（中间的路由器）。**应用层和运输层使用端到端（End-to-end）协议**。在图中，**只有端系统需要这两层协议**。但是，==网络层提供的却是逐跳（Hop-by-hop）协议，两个端系统和每个中间系统都要使用它==。

在TCP/IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是**并不提供任何可靠性保证**。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。由此可见，**运输层和网络层分别负责不同的功能**。

从定义上看，==一个路由器具有两个或多个网络接口层（因为它连接了两个或多个网络）==。任何具有多个接口的系统，英文都称作是多接口的(multihomed)。==一个主机也可以有多个接口，但一般不称作路由器,除非它的功能只是单纯地把分组从一个接口传送到另一个接口==。同样，路由器并不一定指那种**在互联网中用来转发分组的特殊硬件盒**。大多数的TCP/IP实现**也允许一个多接口主机来担当路由器的功能，但是主机为此必须进行特殊的配置**。在这种情况下，我们既可以称该系统为主机（当它运行某一应用程序时，如FTP或Telnet），也可以称之为路由器（当它把分组从一个网络转发到另一个网络时）。在不同的场合下使用不同的术语。

互联网的目的之一是**在应用程序中隐藏所有的物理细节**。虽然这一点在图1-3由两个网络组成的互联网中并不很明显，但是应用层不能关心（也不关心）一台主机是在以太网上，而另一台主机是在令牌环网上，它们通过路由器进行互连。随着增加不同类型的物理网络，可能会有20个路由器，但应用层仍然是一样的。物理细节的隐藏使得互联网功能非常强大，也非常有用。

连接网络的另一个途径是使用网桥。**网桥是在链路层上对网络进行互连**，而**路由器则是在网络层上对网络进行互连**。==网桥使得多个局域网（LAN）组合在一起，这样对上层来说就好像是一个局域网==。

**TCP/IP倾向于使用路由器而不是网桥来连接网络**，因此我们将着重介绍路由器。文献[Perlman1992]的第12章对路由器和网桥进行了比较。
## 1.3TCP/IP的分层
在TCP/IP协议族中，有很多种协议。图1-4给出了本书将要讨论的其他协议。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202120950.png)

## 2.4.1物理层和数据链路层
![图2.16TCP/IP和OSI模型](https://img-blog.csdnimg.cn/c6a009eb2dce49e19820e6346d8a3a1d.png)
**在物理层和数据链路层中，TCP/IP不定义任何协议**，它支持所有标准和专门协议，采用TCP/IP互联的网络可以是局域网或广域网。
## 2.4.2网络层
在网络层（或者更确切地说**互联网络层**），TCP/IP支持网际协议`InternetworkingProtocol,IP`。**IP使用$4$个支持协议：ARP、RARP、ICMP和IGMP**。这些协议中的每个，都将在后面更详细地介绍。

## #(1)网际协议
**网际协议是TCP/IP协议使用的传输机制**。它是一个不可靠、无连接数据报协议，即**尽力传递**`best-effortdelivery`服务——尽力一词的意思是，IP不提供差错检测和跟踪。IP假定了底层是不可靠的，因此尽最大努力传输到目的地，但没有保证。

IP传输的数据称为**数据报**`datagram`，每一个数据报都独立地传输。数据报可以沿着不同的路由传输，有可能不按顺序到达，或者重复出现。==IP没有路由跟踪，因此一且这些数据报到达目的地，它们没有重新排序的功能==。

然而，IP的这一局限功能并不被认为是一个缺点，==因为它提供了基本的传输功能，使用户只需自由添加「已知应用所必需的那些设施」，就可以获得最大的效率==。IP将在[【计算机网络】第四部分网络层(20)IP协议](https://memcpy0.blog.csdn.net/article/details/122375582)中讨论。

**IP是网络层上的主要协议，同时被TCP和UDP使用**。TCP和UDP的每组数据都通过**端系统和每个中间路由器中的IP层**在互联网中进行传输。在图1-4中，我们给出了一个直接访问IP的应用序。这是很少见的，但也是可能的（==一些较老的选路协议就是以这种方式来实现的==。当然新的运输层协议也有可能使用这种方式）。

## #(2)地址解析协议
**地址解析协议**`AddressResolutionProtocol,ARP`**将逻辑地址与物理地址相联系起来**。在一个典型的物理网络中，比如说一个局域网，链路上的每一个设备都用物理地址或站点地址来标识，这个地址通常印记在网络接口卡`NIC`上。**ARP用于已知「节点的因特网地址」、寻找「该节点的物理地址」**。将在[【计算机网络】第四部分网络层(21)地址映射、差错报告和多播](https://memcpy0.blog.csdn.net/article/details/122274218)讨论ARP。

**逆地址解析协议**`ReverseAddressResolutionProtocol,RARP`**允许主机在仅知道物理地址的情况下寻找因特网地址**。如果主机是第一次连接到网络上或启动一台无盘计算机时，就要使用该协议。也在[(21)](https://memcpy0.blog.csdn.net/article/details/122274218)讨论RARP。

ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，**用来转换IP层和网络接口层使用的地址**。
## #(3)因特网控制报文协议
**因特网控制报文协议**`InternetControlMessageProtocol,ICMP`是由主机和网关所使用的一种机制，用来**向发送方**通知数据报所发生的问题。ICMP在[(21)](https://memcpy0.blog.csdn.net/article/details/122274218)讨论。

**ICMP是IP协议的附属协议**。IP层用它来与其他主机或路由器**交换错误报文和其他重要信息**。==尽管ICMP主要被IP使用，但应用程序也有可能访问它==。分析两个流行的诊断工具，Ping和Traceroute，它们都使用了ICMP。
## #(4)因特网组报文协议
**因特网组报文协议**`InternetGroupMessageProtocol,IGMP`用于将一个报文同时发送给**一组接收者**。在[(22)](https://memcpy0.blog.csdn.net/article/details/122184175)讨论IGMP。

IGMP是Internet组管理协议。**它用来把一个UDP数据报多播到多个主机**。广播（把一个UDP数据报发送到某个指定网络上的所有主机）和多播的一般特性。
## 2.4.3传输层
传输层在TCP/lP中用两个协议表示：TCP和UDP。IP是主机到主机协议`host-to-hostprotocol`，这就是说它可以将分组从一个物理设备传递到另一个物理设备。**UDP和TCP则是负责将报文从一个进程（运行程序）传递到另一个进程的传输层协议**`transportlevelprotocol`。现在还设计出了一个新的协议STCP，以满足某些较新的应用需要。
## #(1)用户数据报协议
用户数据报协议`UserDatagramProtocol,UDP`是两个标准的TCP/IP传输层协议中较简单的一个。==它是一个进程到进程的协议，仅将端口号、校验和、差错控制及信息长度添加到来自上一层的数据中==。UDP在第23章中讨论。

在DNS域名系统，TFTP：简单文件传送协议，以及第16章BOOTP：引导程序协议介绍使用UDP的应用程序。
## #(2)传输控制协议
**传输控制协议**`TransmissionControlProtocol,TCP`为应用程序提供了**完整的传输层服务**。TCP是一个**可靠的流传输协议**，流这个词在这里表示面向连接：在传输的两端可以传送数据以前，必须先建立连接。

在每个传输的发送端，TCP划分数据流为称为**片段**的更小的数据单元，每个片段都包括**一个用来在接收后重新排序的序号**，以及**对接收到片段的确认序号**。片段将包含在IP数据报中，通过互联网传输。在接收端，TCP收集每个到来的数据报，然后基于序号对传输重新排列。TCP在第23章中讨论。

我们将介绍一些TCP的应用。如Telnet和Rlogin、FTP以及SMTP等。这些应用通常都是用户进程。
## #(3)流控制传输协议
**流控制传输协议**`StreamControlTransmissionProtocol,SCTP`对较新应用提供支持，比如因特网上的音频传输。它结合了UDP和TCP最好的特点，在第23章中讨论。
## 2.4.4应用层
在TCP/IP中的应用层相当于OSI模型中的会话层、表示层和应用层的组合。这一层定义了许多协议。在后面几章中，将讨论多个标准协议。

---
#2.5寻址
采用TCP/IP协议的互联网使用$4$层地址：**物理（链路）地址**`physical(link)address`,**逻辑（IP）地址**`logical(IP)address`，**端口地址**`portaddress`和**专用地址**（见图2.17）。
![图2.17TCP/IP的地址](https://img-blog.csdnimg.cn/070b9c45ef9d44a1a2362d040debe83e.png)
**每种地址都与TCP/IP层次结构中的某个特定层有关**，如图2.18所示。
![图2.18TCP/IP的地址与层的关系](https://img-blog.csdnimg.cn/9f6424409c56416a940222b19034f57a.png)
## 2.5.1物理地址
**物理地址**`PhysicalAddresses`也称为**链路地址**`linkaddress`，==它是局域网或广域网定义的节点地址，包含在数据链路层所用的帧中，是最低级的地址。物理地址在网络（LAN或者WAN）中使用，**这类地址的长度和格式是可变的**，它们与网络有关==。例如，以太网使用$6$个字节（$48$位）物理地址，在网络接口卡`NIC`上标明。然而，LocalTalk（Apple）使用$1$个字节的动态地址，它每次在站点开始到来时改变。

【例2.1】在图2.19中，物理地址为$10$的节点发送一个帧到物理地址为$87$的节点，这两个节点通过链路连接（总线拓扑结构的LAN）。==在数据链路层，该帧的头部含有物理（链路）地址，它们是需要的地址，头部还含有该层其他必要的信息。**尾部通常是为了差错检测需要的附加位**==。
如图2.19所示，具有物理地址为$10$的计算机是发送方，而具有物理地址为$87$的计算机是接收方。==发送方的数据链路层接收来自上一层的数据，把它封装在一个帧中、并添加头部和尾部==，其头部包含接收方和发送方的物理（链路）地址，作为信息的一个部分。注意：**大多数情况下，数据链路协议的目的地址置于源地址之前**，在本例中地址$87$在地址$10$之前。
已经说明总线拓扑结构为单一的局域网，帧在两个方向传播（左和右），向右传播的帧被送到网络上每一个站。凡是物理地址不是$87$的站都放弃这个帧，这是由于目的地址与它们的物理地址不相同，而==具有目的地址的计算机发现帧中的目的地址与自己相同，就检验该帧、去掉头部和尾部，提取出数据部分、向上层传递==。
![图2.19物理地址](https://img-blog.csdnimg.cn/bfcd60fac5ea42ab860efd19e7dd7646.png)
【例2.2】将在[第13章](https://memcpy0.blog.csdn.net/article/details/123059031)看到，大多数局域网使用$48$位（六个字节）的物理地址，该地址被写作$12$个十六进制的数字，每个字节（两个十六进制数）用冒号分隔开，例如：`07:01:02:01:2C:4B`。

## 2.5.2逻辑地址
**逻辑地址**`LogicalAddresses`对于全世界通信是必需的，它与下层的物理网络无关。**物理地址不适用于互联网的环境，其中的不同网络可能有不同地址格式**，因此需要有全世界的寻址系统，其中每台主机有唯一的标记，而不管下面的物理网络。为此，设计了逻辑地址，因特网的逻辑地址现在流行的是$32$位地址，它唯一定义了连接到因特网的一台主机。**因特网上没有两台主机具有相同的IP地址**。

【例2.3】图2.20表示，用两个路由器连接三个局域网所组成的互联网的一个部分。每台设备（路由器和计算机）都有一对地址（逻辑的和物理的）用作连接。此时，每台计算机仅连接到一条链路，因此它只有一对地址。然而，路由器连接$3$个网络（图中仅连接$2$个），因此每一个路由器有$3$对地址，每个连接用一对。==对每一个连接，每个路由器必须有一个单独的物理地址，虽然这一点可能很明显，但是为什么对每一连接，每个路由器并不需要一个逻辑地址？这一点可能并不明显==。当讨论路由选择时，这些问题将在[【计算机网络】第四部分网络层(22)传递、转发和（单播/多播）路由选择](https://memcpy0.blog.csdn.net/article/details/122184175)中讨论。
![图2.20IP地址](https://img-blog.csdnimg.cn/3ba03c816fc54dfea7c66a4620dbe934.png)
逻辑地址$A$和物理地址$10$的计算机，想要发送一个分组到逻辑地址$P$和物理地址$95$的计算机。此处用文字表示逻辑地址，用数字表示物理地址，但是需要注意的是，这两个地址实际上都是数字，这将在后面看到。
-发送方在网络层封装这个分组，并添加两个逻辑地址$A,P$，**注意在多数协议中，逻辑源地址在逻辑目的地址之前**（**与物理地址刚好相反**）。
-在该分组传递之前，网络层必须要寻找下一跳的物理地址。网络层查阅它的路由表（见[第22章]((https://memcpy0.blog.csdn.net/article/details/122184175))），并找到下一跳的逻辑地址为$F$（路由器$1$），再通过前面提到的ARP，发现路由器$1$的物理地址是$20$。
-网络层将这个地址传给数据链路层，接着在该层用目的物理地址$20$和源物理地址$10$封装该分组为帧。
-==该帧被LAN1中所有设备接收到，但除掉路由器$1$发现帧中的目的物理地址与它自己的物理地址相同外，其余的设备都废弃该帧==。
-路由器$1$拆封该帧为分组，并读出逻辑地址$P$。==由于目的逻辑地址与路由器的逻辑地址不相同，路由器知道该分组需要转发==。路由器查询它的路由表并应用ARP，发现下一跳目的物理地址（路由器$2$），创建封装该分组的一个新帧，并发送到路由器$2$。注意：该帧中的物理地址发生变化——源物理地址由$20$变为$99$，目的物理地址由$20$（路由器$1$的物理地址）变成$33$（路由器$2$的物理地址）。**源和目的逻辑地址必须保持相同，否则该分组将会被丢失**。
-路由器$2$有相似的过程，物理地址将被改变、并向目的计算机发送一个新帧。当帧到达目的地，被拆封为分组。==目的逻辑地址$P$与计算机逻辑地址相同，由分组拆封数据，并传递给上一层==。

注意：虽然**跳到跳时**物理地址改变了，但源到目的逻辑地址保持相同。在后面，也有例外的情况。

**互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址）**。IP地址长32bit。
Internet地址并不采用平面形式的地址空间，如1、2、3等。IP地址具有一定的结构，五类不同
的互联网地址格式如图1-5所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202127656.png)
这些32位的地址通常写成四个十进制的数，其中每个整数对应一个字节。这种表示方法称作“点分十
进制表示法（Dotteddecimalnotation）”。例如，作者的系统就是一个B类地址，它表示为：140.252.13.33。

**区分各类地址的最简单方法是看它的第一个十进制整数**。图1-6列出了各类地址的起止范围，其中第一个十进制整数用加黑字体表示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202128854.png)
需要再次指出的是，==多接口主机具有多个IP地址，其中每个接口都对应一个IP地址==。

由于互联网上的每个接口必须有一个唯一的IP地址，因此**必须要有一个管理机构为接入互联网的网络分配IP地址**。这个管理机构就是互联网络信息中心（InternetNetworkInformationCentre），称作InterNIC。**InterNIC只分配网络号。主机号的分配由系统管理员来负责**。

Internet注册服务(IP地址和DNS域名)过去由NIC来负责，其网络地址是nic.ddn.mil。1993年4月1日，InterNIC成立。现在，NIC只负责处理国防数据网的注册请求，所有其他
的Internet用户注册请求均由InterNIC负责处理，其网址是：rs.internic.net。
事实上InterNIC由三部分组成：注册服务（rs.internic.net），目录和数据库服务（ds.internic.net），以及信息服务（is.internic.net）。有关InterNIC的其他信息参见习题1.8。

有三类IP地址：**单播地址**（目的为单个主机）、**广播地址**（目的端为给定网络上的所有主机）以及**多播地址**（目的端为**同一组内的所有主机**）。在介绍IP选路以后将进一步介绍子网的概念。
## 2.5.3端口地址
**端口地址`PortAddresses`标识一台主机的进程**。IP地址和物理地址对于从源主机到目的主机的数据传输是必需的，但是到达目的主机不是因特网数据通信的最终目标。只将数据从一台计算机传输到另一台计算机、而不做其他事情，是不完整的传输。今天，计算机能同时运行多个进程，**因特网通信最终目的是进程到进程的通信**。例如，计算机$A$使用TELNET与计算机$C$通信，同时计算机$A$使用文件传输协议`FTP`与计算机$B$通信。为了使这些进程同时接收数据，需要有一种方法标记不同的进程。换言之，需要地址标识符。在TCP/IP分层体系结构中，赋予进程的标识符称为**端口地址**，它的长度是$16$位。

TCP和UDP采用16bit的端口号来识别应用程序。那么这些端口号是如何选择的呢？
-**服务器一般都是通过知名端口号来识别的**。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23，每个TFTP(简单文件传送协议)服务器的UDP端口号都是69。**任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号**。这些知名端口号由Internet号分配机构（InternetAssignedNumbersAuthority,IANA）来管理。
>到1992年为止，知名端口号介于1～255之间。256～1023之间的端口号通常都是由Unix系统占用，以提供一些特定的Unix服务—也就是说，提供一些只有Unix系统才有的、而其他操作系统可能不提供的服务。现在IANA管理1～1023之间所有的端口号。
>**Internet扩展服务与Unix特定服务之间的一个差别**就是Telnet和Rlogin。它们二者都允许通过计算机网络登录到其他主机上。Telnet是采用端口号为23的TCP/IP标准且几乎可以在所有操作系统上进行实现。相反，Rlogin最开始时只是为Unix系统设计的（尽管许多非Unix系统现在也提供该服务），因此在80年代初，它的有名端口号为513。

-客户端通常对它所使用的端口号并不关心，只需保证该端口号在本机上是唯一的就可以了。客户端口号又称作临时端口号（即存在时间很短暂）。这是因为**它通常只是在用户运行该客户程序时才存在，而服务器则只要主机开着的，其服务就运行**。大多数TCP/IP实现**给临时端口分配1024～5000之间的端口号**。大于5000的端口号是为其他服务器预留的（Internet上并不常用的服务)。我们可以在后面看见许多这样的给临时端口分配端口号的例子。
Solaris2.2是一个很有名的例外。通常TCP和UDP的缺省临时端口号从32768开始。在E.4节中，详细描述系统管理员如何对配置选项进行修改以改变这些缺省项。

大多数Unix系统的文件/etc/services都包含了人们熟知的端口号。为了找到Telnet服务器和域名系统的端口号，可以运行以下语句：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202133588.png)
保留端口号：Unix系统有保留端口号的概念。只有具有超级用户特权的进程才允许给它自己分配一个保留端口号。这些端口号介于1～1023之间，一些应用程序（如有名的Rlogin，26.2节）将它作为客户与服务器之间身份认证的一部分。

有一些标准的简单服务几乎每种实现都要提供。在本书中我们将使用其中的一些服务程序，而客户程序通常选择Telnet。图1-9描述了这些服务。从该图可以看出，当使用TCP和UDP提供相同的服务时，一般选择相同的端口号。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202145704.png)
>如果仔细检查这些标准的简单服务以及**其他标准的TCP/IP服务**（如Telnet、FTP、SMTP等）的端口号时，我们发现它们都是奇数。这是有历史原因的，因为这些端口号都是从NCP端口号派生出来的（NCP，即网络控制协议，是ARPANET的运输层协议，是TCP的前身）。NCP是单工的，不是全双工的，因此**每个应用程序需要两个连接，需预留一对奇数和偶数端口号**。当TCP和UDP成为标准的运输层协议时，**每个应用程序只需要一个端口号**，因此就使用了NCP中的奇数。

【例2.4】图2.21表示了两台计算机通过因特网进行通信。发送计算机此时使用$3$个端口地址$a,b,c$、同时运行$3$个进程，接收计算机用$2$个端口地址$j,k$，也同时运行$2$个进程。发送计算机中的进程$a$需要与接收计算机中的进程$j$进行通信。注意：==虽然两台计算机运行同一个应用程序，比如FTP，但由于一个是客户进程，另一个是服务进程，它们的端口地址是不同的==（在第23章中讨论）。
为了表示数据从进程$a$传递到进程$j$而不是进程$k$，传输层对来自应用层的数据添加**两个端口地址**$a,j$，即将源和目的地址封装在分组中。然后，网络层对来自传输层的分组，用**源和目的逻辑地址**$A,P$封装在另一个分组中。最后，该分组用**下一跳的源和目的物理地址**封装在帧中。此处没有表示物理地址，因为在因特网范围内从跳到跳它们是要改变的。==注意：虽然从跳到跳物理地址要改变，但**从源到目的逻辑地址和端口地址保持不变**==。后面也有一些例外的情况。
![图2.21端口地址](https://img-blog.csdnimg.cn/934267767d2944bd88b9e13bcfc12ff4.png)
【例2.5】在第23章将会看到，$16$位端口地址用一个十进制数表示，例如$753$。
## 2.5.4专用地址
**专用地址是一个面向用户的地址**，有些面向用户的应用被设计为专用地址。例如，电子邮件的地址（例如`forouzan@fhda.edu`）和统一资源定位符`URL`（例如`www.mhhe.com`）。前一个地址定义邮件接发者（见[【计算机网络】第六部分应用层(26)远程登录、电子邮件与文件传输](https://memcpy0.blog.csdn.net/article/details/122896909)），后一个是在万维网中寻找一个文档（见[【计算机网络】第六部分应用层(27)万维网与超文本传输协议（HTTP协议）](https://memcpy0.blog.csdn.net/article/details/122906589)）。这些地址，**由发送计算机转换成对应的端口地址和逻辑地址**（见[【计算机网络】第六部分应用层(25)域名空间](https://memcpy0.blog.csdn.net/article/details/122887505)）。

尽管通过IP地址可以识别主机上的网络接口，进而访问主机，但是人们最喜欢使用的还是主机名。在TCP/IP领域中，**域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息**。我们在第14章将详细讨论DNS。

现在，我们必须理解，任何应用程序都可以**调用一个标准的库函数**来查看**给定名字的主机的IP地址**。类似地，**系统还提供一个逆函数—给定主机的IP地址，查看它所对应的主机名**。大多数使用主机名作为参数的应用程序**也可以把IP地址作为参数**。例如，在第4章中当我们用Telnet进行远程登录时，既可以指定一个主机名，也可以指定一个IP地址。



---
## 2.6封装
当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图1-7所示。TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCPsegment）。IP传给网络接口层的数据单元称作IP数据报(IPdatagram)。通过以太网传输的比特流称作帧(Frame)。更准确地说，图1-7中IP和网络接口层之间传送的数据单元应该是**分组**（packet）。分组**既可以是一个IP数据报**，也可以是**IP数据报的一个片（fragment）**。在11.5节讨论IP数据报分片的详细情况。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202136936.png)
图1-7中帧头和帧尾下面所标注的数字是典型以太网帧首部的字节长度。在后面的章节中我们将详细讨论这些帧头的具体含义。

以太网数据帧的物理特性是**其长度必须在46～1500字节之间**。我们将在4.5节遇到最小长度的数据帧，在2.8节中遇到最大长度的数据帧。

UDP数据与TCP数据基本一致。唯一的不同是UDP传给IP的信息单元称作UDP数据报（UDPdatagram），而且UDP的首部长为8字节。

回想1.3节中的图1-4，由于TCP、UDP、ICMP和IGMP都要向IP传送数据，因此**IP必须在生成的IP首部中加入某种标识，以表明数据属于哪一层**。为此，**IP在首部中存入一个长度为8bit的数值，称作协议域**。1表示为ICMP协议，2表示为IGMP协议，6表示为TCP协议，17表
示为UDP协议。

类似地，**许多应用程序都可以使用TCP或UDP来传送数据。运输层协议在生成报文首部时要存入一个应用程序的标识符**。TCP和UDP都用一个16bit的端口号来表示不同的应用程序。TCP和UDP把源端口号和目的端口号分别存入报文首部中。

网络接口分别要发送和接收IP、ARP和RARP数据，因此也必须在以太网的帧首部中加入某种形式的标识，以指明**生成数据的网络层协议**。为此，以太网的帧首部也有一个16bit的**帧类型域**。

## 2.7分用
当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing），图1-8显示了该过程是如何发生的。
图1-8以太网数据帧的分用过程
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202138503.png)
>**为协议ICMP和IGMP定位一直是一件很棘手的事情。在图1-4中，把它们与IP放在同一层上，那是因为事实上它们是IP的附属协议**。但是在这里，我们==又把它们放在IP层的上面，这是因为ICMP和IGMP报文都被封装在IP数据报中==。
>
>对于ARP和RARP，我们也遇到类似的难题。在这里把它们放在以太网设备驱动程序的上方，**这是因为它们和IP数据报一样，都有各自的以太网数据帧类型**。但在图2-4中，我们又把ARP作为以太网设备驱动程序的一部分，放在IP层的下面，其原因在逻辑上是合理的。
>
>这些分层协议盒并不都是完美的。

当进一步描述TCP的细节时，我们将看到协议确实是通过目的端口号、源IP地址和源端口号进行解包的。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202147930.png)

## 2.8实现
既成事实标准的TCP/IP软件实现来自于位于伯克利的加利福尼亚大学的计算机系统研究小组。从历史上看，软件是随同4.xBSD系统（BerkeleySoftwareDistribution）的网络版一起发布的。它的源代码是许多其他实现的基础。

图1-10列举了各种BSD版本发布的时间，并标注了重要的TCP/IP特性。列在左边的BSD网络版，其所有的网络源代码可以公开得到：包括协议本身以及许多应用程序和工具（如Telnet和FTP）。

在本书中，我们将使用“伯克利派生系统”来指SunOS4.x、SVR4以及AIX3.2等那些基于伯克利源代码开发的系统。这些系统有很多共同之处，经常包含相同的错误。

起初关于Internet的很多研究现在仍然在伯克利系统中应用—新的拥塞控制算法（21.7节）、多播（12.4节）、“长肥管道”修改（24.3节）以及其他类似的研究。

## 2.9应用编程接口
使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口：TransportLayerInterface）。前者有时称作“Berkeleysocket”，表明它是从伯克利版发展而来的。后者起初是由AT&T开发的，有时称作XTI（X/Open运输层接口），以承认X/Open这个自己定义标准的国际计算机生产商所做的工作。XTI实际上是TLI的一个超集。

本书不是一本编程方面的书，但是偶尔会引用一些内容来说明TCP/IP的特性，不管大多数的API（socket）是否提供它们。所有关于socket和TLI的编程细节请参阅文献[Stevens1990]。

图1-11是本书中所有的例子运行的测试网络。为阅读时参考方便，该图还复制在本书扉页前的插页中。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307202148800.png)

在这个图中（作者的子网），大多数的例子都运行在下面四个系统中。图中所有的IP地址属于B类地址，网络号为140.252。所有的主机名属于.tuc.noao.edu这个域（noao代表NationalOpticalAstronomyObservatories，tuc代表Tucson）。例如，右下方的系统有一个完整的名字:svr4.tuc.noao.edu，其IP地址是：140.252.13.34。每个方框上方的名称是该主机运行的操作系统。这一组系统和网络上的主机及路由器运行于不同的TCP/IP实现。

需要指出的是，noao.edu这个域中的网络和主机要比图1-11中的多得多。这里列出来的只是本书中将要用到的系统。

在3.4节中，我们将描述这个网络所用到的子网形式。在4.6节中将介绍sun与netb之间的拨号SLIP的有关细节。2.4节将详细讨论SLIP。
## 习题
1.1请计算最多有多少个A类、B类和C类网络号。
1.2用匿名FTP（见27.3节）从主机nic.merit.edu上获取文件nsfnet/statistics/
history.netcount。该文件包含在NSFNET网络上登记的国内和国外的网络数。画一坐标系，横坐标代表年，纵坐标代表网络总数的对数值。纵坐标的最大值是习题1.1的结果。如果数据显示一个明显的趋势，请估计按照当前的编址体制推算，何时会用完所有的网络地址（3.10节讨论解决该难题的建议）。

1.3获取一份主机需求RFC拷贝[Braden1989a]，阅读有关应用于TCP/IP协议族每一层的稳健性原则。这个原则的参考对象是什么？

1.4获取一份最新的赋值RFC拷贝。“quoteoftheday”协议的有名端口号是什么？哪个RFC对该协议进行了定义？
1.5如果你有一个接入TCP/IP互联网的主机帐号，它的主IP地址是多少？这台主机是否接入了Internet？它是多接口主机吗？

1.6获取一份RFC1000的拷贝，了解RFC这个术语从何而来。

1.7 与Internet协会联系，isoc@isoc.org或者+17036489888，了解有关加入的情况。

1.8用匿名FTP从主机is.internic.net处获取文件about-internic/information-about-the-internic。