在古希腊神话中，冥界的大门由一头烈犬看守。此犬长有三个头，兢兢业业地守在冥河边，从没有灵魂能在它醒着时逃离。这头烈犬就是 Kerberos，安全守卫的象征。古希腊人下葬时要放好蜜饼，就是为了讨好它。现代游戏里也有它的英姿，比如《英雄无敌》里以一敌多的地狱烈犬。

本文要介绍的身份认证协议也叫 **Kerberos，它有着非常广泛的应用**，比如 Windows 域环境的身份认证就会用到它。我们用域账号登录电脑，就在不知不觉间完成了一次 Kerberos 认证过程。

**Kerberos 的认证结果是双向的**—当账号 A 访问资源 B 时，不但 B 要确保 A
并非冒充，而且 A 也要查明 B 不是假货。我们一般只知道前者，比如前文提到的
CIFS 服务器就要在 Session Setup 中对造访者验明正身。后者则很少被提及，因为**人们一般不会怀疑自己要访问的资源是假的**。其实后者还是很有必要的，举一个例子：如果你老板伪造了一台网络打印机，但是你没法确认它的真假，就可能把求职信打到他办公室里去，然后就真的得出去求职了。西游记中其实也出现需要相互认证的场景，比如如来佛祖要认出假冒的访问者六耳猕猴，唐僧师徒也要识别山寨的“资源”小雷音寺。

双向认证的方式不止一种，**最简单的做法是互报密码**。这个过程就像电影中用暗号接头。A 说：“江南风光好”，B 说：“遍地红花开”。如果双方都核对无误，就可以激动地握手“同志，我可找到你了！”假如其中一方报错暗号，则接头失败。

这种方式的弊端很多，**最大的问题是不方便管理**。比如在一个数百名员工共享几百台机器的环境中，当新加入一名员工时，就得在几百台机器上更新账号信息。相信没有管理员能忍受这样的环境。

有没有办法做得更好呢？==Kerberos 采用的方法是引入一个权威的第三方来负责身份认证。这个第三方称为 KDC，它知道域里所有账号和资源的密码==。假如账号 A 要访问资源 B，只要把 KDC 拉出来证明双方身份就行了。在这种机制下，A 和 B 都没必要知道对方的密码，完全依赖 KDC 就可以。

原理说起来简单，通过程序实行起来可就难了。事实上由于 Kerberos 过于复
杂，从来没有一位技术作家能把它简单地表述出来。最文艺的 Kerberos 诠释当属
麻省理工学院编的一出话剧，搜索一下“Kerberos 四幕话剧”就能找到它，但其实理解这话剧还是不容易。幸好有了 Wireshark 之后，可以使 Kerberos 的认证过程变得清晰很多。

在下面的实验中，账号 A 是我的域账号 linp1，资源 B 是一台叫 CAVA 的 Windows 服务器。账号 A 访问资源 B 其实就是 linp1 登录 CAVA 的过程。
**第一步，账号 A 和 KDC 互相认证。**

这可以看成一道有趣的小学奥数题：已知世界上只有 A 和 KDC 知道 A 的密码，如何利用该密码互相证明自己的身份？你也许会想到孔明和周瑜在手心对字，直接向对方亮出 A 的密码。==但在网络环境中不能这样做，因为如果其中一方是假的，不就被套到真密码了吗==？==既要做到不说出密码，又要让对方知道自己拥有密码，应该怎样实现==？Kerberos 自有一套严密的办法。
1. 账号 A 利用 hash 函数把密码转化成一把密钥，我们称它为 Kclt。
2. 用 Kclt 把当前时间戳加密，生成一个字符串。我们用“{时间戳} Kclt”来表示它。
3. 把上一步生成的字符串“{时间戳} Kclt”、账号 A 的信息，以及一段随机字符串发给 KDC。这样就组成了 Kerberos 的身份认证请求 AS_REQ。我们用下面这个公式来表示这个请求。
    AS_REQ =“{时间戳} Kclt”，“账 号 A 的信息”，“随机字符串”

如图 1 所示，我实验室中的账户名字为 linp1，本次生成的随机字符串是
136224786。
图 1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131600939.png)
4. KDC 收到 AS_REQ 之后，先读到账号 A 的信息“linp1”，于是便调出 A的密码，再用**同样的 hash 函数**转化为 Kclt。有了 Kclt 就可以解开“{时间戳} Kclt”了，如果能解开则说明该请求是由账号 A 生成的，因为其他账号不可能有 Kclt 可以加密。

    Kerberos 为什么要选用时间戳来加密，而不是其他呢？原因就是**黑客可能在网络上截获字符串“{时间戳} Kclt”，然后伪装成账户 A 来骗认证**。这种方式称为重放攻击。重放攻击的伪装过程需要一段时间，所以 **KDC 把解密得到的时间戳和当前时间作对比，如果相差过大就可以判断是重放攻击了**。假如采用与时间无关的字符来加密，则无法避开重放攻击，这就是**我们必须在域中同步所有机器时间的原因**。
5. 接下来轮到 KDC 向账号 A 证明自己的身份了，**上文提到的随机字符串就用在这里**。理论上 KDC 只要用 Kclt 加密随机字符串，再回复给账号 A 就可以证明自己的身份了。因为假的 KDC 是没有 Kclt 的，账户 A 拿到回复之后解不出那个随机字符串，就知道 KDC 有假。

总结以上过程，==账号 A 和 KDC 都没有向对方发送密码，所以即便一方是假的也不会泄露信息==。而如果双方都是真的，则实现了互相认证，可以算是完美了。不过这个机制下的 KDC 会非常忙碌，假设每次认证都得调出账号密码、hash、解密……而且每个客户端一天可能要验证数十次，那域中就得配备大量的 KDC 才负担得起。有没有办法进一步改进呢？Kerberos 为此设计了一个精巧的方法。
1. **KDC 生成两把一样的密钥 Kclt-Kdc，作为以后账户 A 和 KDC 之间互相认证之用**，这样就省去了调出账号 A 的密码和 hash 等工作。按理说其中一把Kclt-Kdc 要发给账户 A 保管，另一把由 KDC 自己保管。但==保管密钥对忙碌的KDC 来说也是一个负担==，所以它决定委托给账户 A 保管，==以后账号 A 每次需要KDC 的时候，再把这把密钥还回来==。这个办法听上去不太靠谱，万一有个假冒的账户 A 交回来一把假密钥怎么办？为了避免这个问题，KDC 把自己的密码 hash 成 Kkdc，然后用它加密那把委托给 A 的密钥。Kerberos 里把这个委托的密钥称为TGT（Ticket Granting Ticket），可以用下面的公式来表示。
    ==TGT = {账户 A 相关信息，Kclt-kdc} Kkdc==
    
    有了这个委托保存的机制，**KDC 只需记得自己的 Kkdc，就能解开委托给所有账号的 TGT，从而获得与该账号之间的密钥**。通过这个机制，KDC 的工作负担就大大降低了。

    总结下来，KDC 回复给账户 A 的 AS_REP 应包含以下信息（见图 2）。AS_REP=TGT, {Kclt-kdc,时间戳，随机字符串}Kclt
    图 2
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131606288.png)
b．账户 A 收到 AS-REP 之后利用 Kclt 解密“{Kclt-kdc,时间戳，随机字符串} Kclt”。**通过解开来的随机字符串和时间戳来确定 KDC 的真实性**，然后把 Kclt-kdc 和 TGT 保存起来备用。

第二步，**账号 A 请 KDC 帮忙认证资源 B**。
1. 这时应该发什么给 KDC 呢？首先 TGT 是肯定要交还给 KDC 的，其次还有账户 A 的相关信息、当前时间戳，以及**要访问的资源 B 的信息**（见图3）。这个请求在 Kerberos 中称为 TGS-REQ，可以用下面的公式表示。
    TGS_REQ = TGT，{账户 A 相关信息，时间戳}Kclt-kdc，“资源 B 相关信息”
    图 3
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131611423.png)
2. KDC 收到 TGS-REQ 之后，先用 Kkdc 解密 TGT 得到 Kclt-kdc，再用 Kclt-kdc 解密出账号 A 的相关信息和时间戳来验证其身份。==一旦认定账号 A 为真，就要想办法帮助 A 和 B 互相认证了==。
3. KDC 生成两把同样的密钥供 A 和 B 之间使用，我们就称这个密钥为 Kclt-srv吧。其中一把密钥直接交给账号 A，另一把委托 A 转交给资源 B。为了确保 A 不会受到假的资源 B 所骗，Kerberos 把 B 的密码 hash 成 Ksrv，然后用它加密那把委托 A 转交给 B 的 Kclt-srv，成为一张只有真正的 B 能解密的 Ticket。总结起来，KDC 给账号 A 的回复可以表示如下（见图 4）。
    Ticket = {账号 A 的信息，Kclt-srv} Ksrv
    TGS_REP = {Kclt-srv}Kclt-kdc, Ticket
    这里的“账号 A 的信息”可不仅仅包括名字，连 A 所在的 Domain Groups 都包含在里面。所以如果 A 属于很多个 groups，TGS_REP 包会非常大。
    图 4
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131615124.png)
4. 账号 A 收到 TGS_REP 之后，先用 Kclt-kdc 解开{Kclt-srv}Kclt-kdc，从而得到Kclt-srv。Ticket 留着发给资源 B。==接下来如果需要多次访问资源 B，都可以使用同一个 Ticket，而不需要每次都向 KDC 申请，这也大大降低了 KDC 的负担==。

**第三步，账号 A 和资源 B 互相认证。**
1. 到这一步就简单了。账号 A 给资源 B 发送“{账号 A 的信息，时间戳}Kclt-srv”以及上一步收到的 Ticket。这个请求称为 AP_REQ。AP_REQ = “{账号 A 的信息，时间戳} Kclt-srv”，Ticket
2. 如果资源 B 是假的，它是解不开 Ticket 的。**如果资源 B 是真的，它可以用自己的密码生成 Ksrv 来解开 Ticket**，从而得到 Kclt-srv。有了 Kclt-srv就可以解开“{账号 A 的信息，时间戳} Kclt-srv”部分。这样资源 B 就可以确定账号 A 为真，然后 回复 AP_REP 来证明自己也是真的。
    AP_REP = {时间戳}Kclt-srv
3. 账号 A 利用 Kclt-srv 来解密 AP_REP，再通过得到的时间戳来判断对方是否为真。

第三步是抓不到网络包的，因为这个实验过程是用户 linp1 登录 Windows 服务器 CAVA，第三步没有发生在网络上。假如接下来用户 linp1 访问 CAVA 之外的其他资源，比如访问网络共享，我们就能在 Session Setup 里找到 AP_REQ 和AP_REP 了。如图 5 所示，我在 Session Setup AndX Request 包中点开Security Blob，就把 AP_REQ 显示出来了。
图 5
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131617603.png)

如果这是你第一次认识 Kerberos，我估计已经看得云里雾里了。请相信这是
人类的正常反应，我给好几批工程师培训过 Kerberos，几乎没有人能很快理清楚
的。图 6 是整个认证过程的流程图，也许对理解会有所帮助。
图 6
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131617931.png)
当你完全理解 Kerberos 之后，可能会意识到一个问题：不对啊，那么多加密信息都被 Wireshark 显示出来了，还有 什么安全可言？其实我是用 linp1 的密码生成了一个 keytab 文件，再用它来解密的。具体操作如下。
1. 参照 Wireshark 的官方说明生成 keytab 文件，步骤请参考 http://wiki.wireshark.org/Kerberos。
2. 把这个文件和网络包放到同一个目录里。
3. 打开 Wireshark 的 Edit-->Preferences-->Protocols-->KRB5 菜单，在图 7 所示的窗口勾上两个选项，然后输入 keytab 文件的名字。
    图7
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131618690.png)
4. 打开网络包，就能看到解密后的内容了。

这也是我喜欢 Wireshark 的原因之一，即使像 Kerberos 这么复杂的协议，它也能完全解析出来。这简直是域管理员的福音。我稍作回忆，就能想到很多处理过的 Kerberos 相关例子。

**案例 1**：某客户可以用 `\\<IP 地址>` 访问某文件服务器，但用了 `\\<域名>` 则不能访问。
用了 Wireshark 抓包才知道，客户端用 IP 访问时用了 NTLM 作身份验证，而
用域名访问时则用 Kerberos。由于两种验证方法机制不同，所以结果也不一样。比如==当客户端和服务器的时间没有同步时，Kerberos 会认为该访问是重放攻击而拒绝访问，但 NTLM 不会==。

**案例 2**：一个域账号明明被加到某个组里，该组也被赋予访问文件夹的权限，但是该账号就是访问不了这个文件夹。
用 Wireshark 解密了 AP_REQ 之后，并没有看到那个组。很可能是用户登录
（获得包含组信息的 ticket）之后，才被加到那个组里的。让该用户注销后再登录，获得新 Ticket 就好了。

**案例 3**：某台客户端加入域失败，查了很久都没找到原因。
用了 Wireshark 之后，在包里发现 “KRB5KRB_ERR_RESPONSE_TOO_BIG”的错误信息（见图 8）。利用该报错很快就从微软的网站上找到了解决方案。
图 8
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131619075.png)
