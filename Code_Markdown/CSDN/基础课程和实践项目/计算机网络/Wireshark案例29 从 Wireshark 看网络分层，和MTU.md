对于刚上网络课的学生来说，最难理解的莫过于网络分层了。

“只不过是传输一些数据，为什么要分那么多层次呢？”这是大学里一直困扰我的问题。虽然课本在此处花费了不少笔墨，但还是过于抽象，**我始终无法想像一个网络包里的层次究竟是什么样子。这对一名网络工程师来说是不可接受的**，就像连器官都分不清楚的医生，谁能放心让他做手术呢？幸好后来遇到 Wireshark，才算解开了这个疑问。

前文已经介绍过 NFS 协议，**我们便以它为例来学习网络分层**。图 1 是客户端
10.32.106.159 往服务器 10.32.106.62 上写文件时抓的网络包。
图 1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130909740.png)

这 5 个包大概做了下面这些事。
客户端：“我想创建 test.txt。”
服务器：“创建成功啦（该文件的 file handle 是 0xf87a7de0，点开包才能看到）。”
客户端：“我想写 28 个字节到该文件里（这些字节显示在图 1 的右下角）。”
服务器：“收到啦。”
服务器：“写好啦。”
其中第 3 个包（编号为 15）的详情如图 2 所示。Wireshark 已经形象地把这
个包的内容用分层的结构显示出来。
图 2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130910409.png)
- 应用层：由于 **NFS 是基于 RPC 的协议**，所以 **Wireshark 把它分成 NFS 和
RPC 两行来显示**。仔细检查这一层的详细信息，会发现==它只专注于文件操
作，比如读或者写，而对于数据传输一无所知==。点开“+”号便能看到这
个写操作的详情，比如用户的 UID、文件的 file handle 和要写的字节数等。
- 传输层：这一层用到了 TCP 协议。应用层所产生的数据就是由 TCP 来控制传输的。点开 TCP 层前的“+”号，我们可以看到 Seq 号和 Ack 号等一系列信息，它们用于网络包的排序、重传、流量控制等。==虽然名曰“传输层”，但它并不是把网络包从一个设备传到另一个，而只是对传输行为进行控制==。真正负责设备间传输的是下面两层。TCP 是非常有用的协议，也是本书的重点。
- **网络互连层**（网络层）：在这个包中，本层的主要任务是把 TCP 层传下来的数据加上目标地址和源地址。有了目标地址，数据才可能送达接收方；而有了源地址，接收方才知道发送方是谁。
- **网络接口层**（数据链路层）：从中可以看到相邻两个设备的 MAC 地址，因此该网络包才能以接力的方式送达目标地址。

从这个例子中，我们可以看到网络分层就像是有序的分工。每一层都有自己的责任范围，上层协议完成工作后就交给下一层，最终形成一个完整的网络包。这个过程可以用图 3 表示。
图 3
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130913018.png)
现在回想起来，如果当时老师能打开 Wireshark，让我们看到**这些实实在在的
分层**，我也不会困惑那么久了（假如那天我没有逃课的话）。不过教科书上有一个例子，倒的确是很有助于理解分层的，这么多年之后我还记得它—有位经理想给另一个城市的经理寄个文件，过程大概如图 4 所示。
图 4
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130914964.png)
这个场景中的 4 个角色可以对应网络的 4 个层次，每个角色都有自己的分工，
最终完成文件的送达。分工会带来很多好处，因为每个人都可以专注自己擅长的
领域，更好地服务他人。经理不一定要学会开车，就像写 NFS 代码的程序员可以完全不懂路由协议。秘书可以服务多名经理，正如 TCP 层可以支持很多应用层协议。

如果让邮递员包揽秘书的工作，是否也可以呢？说不定也能做到，虽然听上去很滑稽。历史上还真存在过这种情况—TCP 和 IP 刚发明的时候就是合在一层的，后来才拆成两层。那么，如果在经理和秘书之间加个助理，专门负责检查错别字，会有问题吗？与很多官僚作风严重的机构一样，多盖一个章就要多花一些
时间。还记得 20 世纪那场 OSI 七层模型与 TCP/IP 模型的竞争吗？**最终胜出的就是分层更简单的 TCP/IP 模型**。要知道网络分层的目的并不仅仅是完成任务，而是要用最好的方式来完成。

理解了分层的基本概念，我们再来看看复杂一点的情况。如果这个写操作比
较大, 变成 8192 字节，TCP 层又该如何处理？是否也是简单地加上 TCP 头就交
给网络互连层（网络层）呢？答案是否定的。因为**网络对包的大小是有限制的**，其最大值称为 MTU，即“最大传输单元”。**大多数网络的 MTU 是 1500 字节**，但也**有些网络启用了巨帧（Jumbo Frame），能达到 9000 字节**。一个 8192 字节的包进入巨帧网络不会有问题，但到了 1500 字节的网络中就会被丢弃或者切分。==被丢弃意味着传输彻底失败，因为重传的包还会再一次被丢弃。而被切分则意味着传输效率降低==。

由于这个原因，TCP 不想简单地把 8192 字节的数据一口气传给网络互连层，而是根据双方的 MTU 决定每次传多少。**知道自己的 MTU 容易，但对方的 MTU如何获得呢**？如图 5 所示，==在 TCP 连接建立（三次握手）时，双方都会把自己的MSS（Maximum Segment Size）告诉对方==。MSS 加上 TCP 头和 IP 头的长度，就得到 MTU 了。
图 5
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130917534.png)
在第一个包里，客户端声明自己的 MSS 是 8960，意味着它的 MTU 就是
8960+20（TCP 头）+20（IP 头）=9000。在第二个包里，服务器声明自己的 MSS 是 1460，意味着它的 MTU 就是 1460+20+20=1500。图 6 是 TCP 连接建立之后的写操作，我们来看看究竟是哪个 MTU 起了作用。

客户端在包号 46 创建了 abc.txt，然后通过 48、49、51、52、54 和 55 共 6 个
包完成了这个 8192 字节的写操作。这些包的大小符合接收方的 MTU 1500 字节（见图 6 中划线的 Total Length: 1500），而不是发送方本身支持的 9000 字节。也就是说，接收方的 MTU 起了决定作用。
图 6
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130918096.png)
假如把客户端和服务器的 MTU 互换一下，这时客户端最大能发出多少字节
的包呢？答案还是 1500。因为无论接受方的 MTU 有多大，发送方都不能发出超
过自己 MTU 的包。我们可以得到这样的结论：**发包的大小是由 MTU 较小的一方决定的**。

这个例子告诉我们，分层之间的关系还不仅是分工。==某些分层的协议，比如
TCP，甚至会主动为下一层着想，从而避免很多问题==。当然这个方案还不算完美。

如果网络路径上存在着一个 MTU 小于 1500 的设备，这个包还是可能被丢弃或者切分。正如 Wikipedia 所说，“There is no simple method to discover the MTU of links”。

一个分层的概念就写了这么多，你或许早就开始纳闷：为什么网络要设计得
如此复杂？又是分层又是分组的。其实当我被各种难题搞得焦头烂额的时候，也
有过这个想法，但无奈这就是现实—**假如没有这么复杂的设计，网络就不会如
此强大，也达不到今天的规模**。从另一个角度考虑，正是复杂的设计才让我们有了这份工作，感谢祖师爷们赐饭。