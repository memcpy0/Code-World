书上错了吗？看上去很美好，用了却有上当的感觉——这种心理落差不仅存在于淘宝买家秀。对Wireshark初学者来说，第一次看到网络包的时候也会有失落感，甚至怀疑以前看的书是错的。

在某些网络书中，一个简单的TCP传输过程如图1所示。
图1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081529190.png)
由图1可见，客户端每传两个数据包，服务器就立即Ack一下表示已经收到。比如Ack3表示收到了1号和2号两个包，正在期待3号包；Ack5表示又收到了3号和4号两个包，正在期待5号包。

**像图1这样美好的景象在数据接收方（即本文中的服务器）抓到的包中的确能看到**，比如图2就很符合。**23号包的“Seq=8413，Len=1448”，两者之和恰好等于24号包的“Ack=9861”，所以24号包就是对23号包（以及22号包）的确认**。有兴趣的话可以把图2所有包都对照一下，看看是不是非常吻合图1的模型。
图2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081531097.png)
然而这只是从数据接收方的角度所看到的。要知道网络上存在延迟，所以**在数据发送方（即本文中的客户端）抓到的网络包就没这么理想了**。想象一下，同样是图1中的那些包，算上网络延迟的传输过程会是什么样子的？请看图3，这些Ack包到达客户端时会滞后一些，所以**客户端发完6号包才收到Ack3，发完8号包才收到Ack5**。虽然看上去有点“答非所问”，但这是完全符合TCP协议的。因此==建议初学者最好两边同时抓包，对照着看，以免产生误解==。
图3
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081532951.png)

按理说图3这种交叉斜线的表示方法是最精确的，我在书中为什么很少采用呢？因为本书介绍的是Wireshark，而用Wireshark打开一个包只能看到一边的情况，所以我宁愿只站在其中一边的角度来画图，这样会更接近在Wireshark中看到的样子。当然选择哪一边也很有讲究，假如从一开始就站在数据发送方（即本文中的客户端）的角度看，读者一定会觉得有点乱，模型图请看图4。
图4
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081533237.png)
从Wireshark上看真实的包就更乱了，图5就是一个在数据发送方上抓到的包。其中7号包是“Seq=263611，Len=249”，两者之和263860远远大于8号包的“Ack=3284”，可见Ack包严重滞后了。我在上一本书中尽量避免引入这样的截图，就是担心读者被这迟来的Ack混淆了。然而**丑媳妇是早晚要见公婆的，当我们的研究深入到一定程度，两边抓到的网络包都必须学会面对。有的时候甚至只能分析看上去混乱的那一边**，接下来的两篇文章就是这样。
图5
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081534080.png)
假如本文的内容让你觉得有点犯迷糊，可能需要停下来慢慢消化，甚至多读两遍。理解了这个，才能翻到下一篇，看看如何计算“在途字节数”。
> 在本文的例子中，假定数据传输方向是从客户端到服务器，而且服务器每收到两个数据包就Ack一次。实际环境中不一定是这样的方向，也不一定是这样的Ack频率。图中用简单的数字来表示一个包当然不够精确，**理论上应该用Seq、Len和Ack来表示才最科学，不过这样的好处是更加直观**。

### 计算“在途字节数”
我一直谨记斯蒂芬•霍金的金玉良言——每写一道数学公式就会失去一半读者。不过为了深度分析网络包，有时候是不得不计算的，好在小学一年级的加减法就够用了。

**网络的承载量就是一个需要计算的值**。怎样理解这个概念呢？如图1所示，一架波音747能够承载上万个小包裹，而一架无人机只能承载一个，这就反映了它们不同的承载量。换个角度，也可以说**承载量就是处于运输工具中的货物量，即已经从源仓库发货，但还没有到达目的地的包裹数量**。图1

和运输机类似，网络承载量也可以用**已经发送出去，但尚未被确认的字节数**来表示。在英文技术文档中，形象地用“bytes in flight”来描述它，我觉得用“在途字节数”来翻译最好。

飞机如果超载了，是会发生严重事故的。而**在途字节数如果超过网络的承载能力，也会丢包重传**，这就是我们需要计算它的原因。怎么计算呢？假如网络上只有一个TCP连接在通信，那么还可以通过**带宽和延迟**来计算最多能承载多少在途字节数。而实际环境往往如图2所示，同一条网络路径是由多台主机之间共享的，根本不知道多少比例的带宽是分配给某个TCP连接。这时候就需要用到网络神器Wireshark来分析了。
图2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081536926.png)
分析之前要先抓包。应该在哪一端抓呢？我们先两边都尝试一下。上文《书上错了吗？》已经交代过，**网络延迟会导致同样的网络包在两端体现出不同的顺序**，并用下面的图3演示。
图3
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081548605.png)
我在图3的服务器上**随机**挑选一个时间点并标志为T1。由于服务器在该点之前收到8号包并立即回复了“Ack9”（表示9号之前的包都收到了），所以在途字节数为0。也就是说，**在数据接收方抓的包里是看不到在途字节数的**，没有分析意义。

接着我在图3的客户端**随机**挑选一个时间点并标志为T2，由于在该时间点之前10号包已经发出去，但==收到的“Ack7”只表示7号之前的包都收到了，也即意味着7、8、9、10号包都还没有确认，所以在途字节数就是这4个包所携带的数据量==。这说明**在数据发送方抓到的包才能用来分析在途字节数**。

从模型图中理解了原理，接下来就可以用Wireshark来分析真实的包了。图4是在客户端（数据发送方）抓到的，如果我们想知道第0.400000秒时的在途字节数，应该如何计算呢？
图4
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081538182.png)

在该时间点之前客户端发送的是10号包，即“Seq=265248，Len=180”字节，表示**序号在265248+180=265428之前的字节已经发送出去了**。而第0.400000秒之前服务器的Ack为3284，表示**序号在3284之前的字节已经收到了**。那么在途字节数就是265428−3284=262144字节。如果要归纳出一条公式，可以表示成：
**在途字节数=Seq+Len−Ack**
其中Seq和Len是来自上一个数据发送方的包，而Ack则来自上一个数据接收方的包。我们再拿第0.500000秒来练习一下，套用公式可以算出在途字节数应该是266816+361−5033=262144，与第0.400000秒的一样多。

理解了在途字节数的计算方式，就可以翻到下一篇《估算网络拥塞点》了。要是还不太理解，建议多读两遍。
## 估算网络拥塞点
前两篇写了那么多，其实都是为了给本文的话题作铺垫。这个话题就是**网络拥塞点——当发送方一口气向网络中注入大量数据时，就可能超过该网络的承受能力而导致拥塞，这个足以触发拥塞的数据量就称为拥塞点**[2]。

从定义上看，拥塞点和上文所介绍的“在途字节数”是不是有关系呢？确实有关系。假如把网络路径想象成一条河流，发送方是水源，接收方是入海口，**那在途字节数就是河里的水量。当水源的流速超过了入海口的流速，河里的水量就会越来越多，直至溢出**。所以大致可以认为，==发生拥塞时的在途字节数即是该时刻的网络拥塞点==。明白了这一点，**估算拥塞点**就可以简化成**找出拥塞时刻的在途字节数了**。

那又如何在Wireshark中找到拥塞时刻呢？众所周知，==拥塞的特征是连串丢包，丢包之后就会重传==，而Wireshark是能够标识出重传包的。因此我们可以根据这个规律来寻找：
1. **先从Wireshark中找到一连串重传包中的第一个**
2. 再根据该重传包的Seq值找到其原始包
3. **最后计算该原始包发送时刻的在途字节数**。由于==网络拥塞就是在该原始包发出去的时刻发生的==，所以这个在途字节数就大致代表了拥塞点的大小。

具体操作步骤如下。
1．在Wireshark上单击Analyze菜单，再单击Expert Info选项，得到图1的重传统计表。
图1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081542918.png)

2．点击第一个重传包No.1225，可见它的Seq=1012852。于是用 `tcp.seq==1012852` 作为过滤条件，见图2。
图2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081542598.png)

3．点击Apply过滤之后得到了**原始包**No.1053，见图3。
图3
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081543410.png)
4．选定1053号包，然后点击Clear清除过滤。可见**上一个来自服务器端的包是1051号包**，见图4。图45．利用上文《计算“在途字节数”》的公式，可知当时的在途字节数为1012852（No.1053的Seq）+816（No.1053的Len）−910546（No.1051的Ack）=103122字节。

就这样，该时刻的拥塞点被估算出来了。这个方法不一定很精确，但是绝对有参考意义。**我们最好多次采样，然后选定一个合适的值作为该连接的拥塞点**。什么样的值才算合适？**我个人认为不应该取平均值，而应该取一个偏小的**。比如说10次采样中有5次是32KB，5次是40KB，那宁愿把拥塞点定为32KB，而不是平均值36KB。

为什么要如此保守呢？这得从估算拥塞点的目的开始说起。==我们辛辛苦苦地估算它，是为了能把发送窗口限制在这个拥塞点以下，从而避免拥塞，提高传输性能==。限制在32KB以下时可以完全消除拥塞，而假如取了个平均值36KB，那就只能减少二分之一的拥塞。

我在上一本书中已经详细分析过，**每一次拥塞带来的性能影响都很大，即使千分之一的概率都足以导致性能大滑坡，保守一点还是值得的**。至于估算结束后，如何在系统中把窗口限制在拥塞点以下，不同的操作系统有不同的方法，Windows环境可以参考KB224829的步骤。
> 本文的“拥塞点”翻译自英文文档中的“congestionpoint”，表示的是一个阈值。在中文文档中也常用“拥塞点”来表示“发生拥塞的节点”，即“congestionnode”。在此要把定义交代清楚，以免发生误解。

## 顺便说说LSO
当你开始动手估算网络的拥塞点，**很可能会遇到一个诡异的现象**，比如下面这个例子。我找到了一个重传包的序号为491，其Seq号为349974，便以此作为过滤条件，如图1所示。
图1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081546957.png)
点击Apply过滤，可是结果却只见重传包，不见原始包，如图2所示。是什么原因导致了这个现象呢？
图2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081547201.png)
一般有下面3个可能：
1. 这个包是在接收方抓的，**看不到已经在路上丢失的原始包是正常的**；
2. 开始抓包的时候，**原始包已经传完了**，看不到它也是合理的；
3. Wireshark出了bug，把一个正常包标记成［TCP Fast Retransmission］了。

不过我遇到的情况并不符合这3个可能。原始包实际上已经抓到了，只是用它的Seq号过滤不出来而已。我是怎么知道原始包已经抓到的呢？请看图3，我把过滤条件改成 `tcp.seq<349974` ，发现客户端最后发送的一个包是“Seq=348586，Len=2776”，正好包含了我们想要寻找的原始包 `Seq==349974，Len=1388` 的所有字节。
图3
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081550319.png)

我一开始觉得很奇怪，这个TCP连接的MSS（最大数据段长度）是1388，怎么会有Len=2776（即1388的两倍）的包出现呢？后来读到了Wikipedia上的一个条目，才知道这就是传说中的LSO（Large Segment Offload）。目前我还没有听到过“信达雅”的翻译，所以还是以LSO来称呼它吧。

LSO是什么呢？它是为了拯救CPU而出现的一个创意。随着网络进入千兆和万兆时代，CPU的工作负担明显加重了。625MB/s的网络流量大约需要耗费5GHz的CPU，这已经需要一个双核2.5GHzCPU的全部处理能力了。为了缓解CPU的压力，最好把它的一些工作**外包**（offload）给网卡，比如**TCP的分段工作**。
- 传统的网络工作方式是这样的：应用层把产生的数据交给TCP层，**TCP层再根据MSS大小进行分段（由CPU负责）**，然后再交给网卡。而启用LSO之后，**TCP层就可以把大于MSS的数据块直接传给网卡，让网卡来负责分段工作了**。比如本例子中的“Seq=348586，Len=2776”，最后会被网卡分成“Seq=348586，Len=1388”和“Seq=349974，Len=1388”两个包。**由于在发送方抓包时相当于站在CPU的视角，所以看到的是一个分段前的大包**。假如是在接收方抓包，就是网卡分段后的两个小包了[3]。本文用到的这个例子还是比较小的数据块，**我还经常抓到比这个大十倍以上的**。前几天@阿里技术保障还在微博上发了一篇文章，也介绍了这个技术。
- 在过去几年中，我经常在估算拥塞点时遭遇LSO，这就需要**先想象出它分段后的样子**，然后再用老办法计算。我也有过**多次利用LSO做性能调优**的经历，比如VMware上的虚拟网卡有时候是性能瓶颈，关闭LSO反而性能会更好。

LSO的配置方式很简单，Windows上只需要在网卡的高级属性中找到LargeSendOffload项就行了（见图4）。
图4
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307081555833.png)
**在启用巨帧（JumboFrame）的网络中也能看到很大的TCP包，但那种包是不需要再分段的，所以发送方和接收方看到的都一样**。