@[toc]

在因特网模型中，主要的网络协议是**网际协议** `Internet Protocol, IP` 。在这一章中，我们首先讨论**互联网和网络层协议的一般问题**。然后讨论**IPv4（版本4）**，进一步学习这一协议的下一代**IPv6**。最后，讨论**从IPv4过渡到IPv6的策略**。没有IPv5，**因为IPv5是基于「从未实现过的OSI模型」的实验性协议**。

IPv4的讨论可从下列RFC找到：
```cpp
760, 781, 791, 815, 1025, 1063, 1071, 1141, 1190, 1191, 1624, 2113
```
IPv6的讨论可以下列RFC找到：
```cpp
1365, 1550, 1678, 1680, 1682, 1683, 1686, 1688, 1726, 1752, 1826, 1883, 1884,
1886, 1887, 1955, 2080, 2373, 2452, 2463, 2465, 2466, 2472, 2492, 2545, 2590
```

---
# 20.1 网际互联
**网络的物理层和数据链路层在本地运行**，这两层共同负责**网络相邻节点间的数据传递**。如图20.1所示。这个互联网是由五个网络组成的：四个局域网和一个广域网。如果主机 $A$ 需要发送一个数据分组到主机 $D$ ，该分组首先需要从 $A$ 到达 $S1$（一个交换机或路由器），然后从 $S1$ 到达 $S3$ ，最后从 $S3$ 到达主机 $D$ ，即数据分组经过三个链路进行传递。**在每条链路中，包括两个物理层和数据链路层**。
![](https://img-blog.csdnimg.cn/b0cdd05f7c0346bda0adcf1dbcbb6744.png)
然而，这里有个很大的问题。当数据到达 $S1$ 的接口 $f1$ 时，$S1$ 如何知道应该从 $f3$ 接口将其发送出去？**在数据链路层（或物理层）并没有规则来帮助 $S1$ 做出正确的决策**。而且，**帧也没有携带任何路由选择信息**，帧中只包含主机 $A$ 的MAC地址（源地址）和 $S1$ 的MAC地址（目的地址）。对于一个局域网或广域网，**传递意味着通过一条、 而不是多条链路传送帧**。

## 20.1.1 网络层需求
为了解决通过多条链路进行传递的问题，就设计了网络层（有时称为互联网络层）。==网络层不仅负责**主机间的传递**，而且负责**通过路由器或交换机对分组进行路由选择**==。图20.2说明增加了一个网络的同一互联网络。
![](https://img-blog.csdnimg.cn/b8ded9fb5c10449183a369b62706c060.png)
图20.3说明了==在源端、路由器端、目的端的网络层功能总的思想==：
- **在源端的网络层，负责将来自另一个协议**（如一个传输层协议或一个路由协议）**的输入数据生成一个分组，分组头部包含源和目的逻辑地址、以及其他信息。网络层负责检验路由表来寻找路由选择信息**（如分组出去的接口或下一节点的物理地址）。**如果分组太大，那么就得对其进行分段**（后面会讨论）。
- **交换机或路由器中的网络层，负责对分组进行路由选择**。当一个分组到达时，路由器或交换机就从它的路由选择表中，为该分组找到一个必须将其发送出去的接口。**改变头部的某些内容后的分组，按路由选择信息再传送给数据链路层**。
- **目的端的网络层负责地址验证**。它确保分组中的目的地址与主机地址是相同的。**如果分组是一个分段，网络层就等待所有的分段到达后，再对其进行重组，然后再将重组后的分组交给传输层**。
![](https://img-blog.csdnimg.cn/0a38c0a2af74497da5f0d20d03ea3fb8.png)

## 20.1.2 作为数据报网络的因特网
因特网的网络层是一种**分组交换网络**。在[【计算机网络】第二部分 物理层和介质(8)](https：//blog.csdn.net/myRealization/article/details/122158560) 交换讨论了交换，交换可以分为三大类：电路交换、分组交换和报文交换。分组交换使用的是**虚电路方法或数据报**的方法。

在网络层，因特网使用**数据报交换**方法。它利用网络层所定义的全球地址，从源端到目的端来路由分组。
## 20.1.3 作为无连接网络的因特网
分组传递能够利用**面向连接的网络服务**来实现，也可利用**面向无连接的网络服务**来实现。我们选择了后者。
- 在**面向连接的服务** `connection oriented service` 中，源端在发送一个分组之前，首先与目的端建立一个连接。在连接建立后，分组就可以按顺序，依次从相同的源端发送到相同的目的端。==在这种情况下，分组间就存在一种关系，它们沿相同的路径按顺序发送，**一个分组与其前后的分组、在逻辑上连接在一起**==。当一个报文的所有分组都传递完毕后，连接就会终止。
在一个面向连接的协议中，**当一个连接建立之后，对那些具有相同源和目的地址的分组序列，只会进行一次路由策略**。交换机不会为每个单独的分组重复计算路由。这种类型的服务，用在类似**帧中继**和**ATM**等<u>虚电路分组交换</u>方法中。
- 在**无连接的服务** `connectionless service`中，==网络层协议独立地对待每个分组，而且每个分组与任何其他分组没有联系，一个报文中分组可能会、也可能不会沿同样的路径到达其目的地==。这种类型的服务用于<u>数据报分组交换</u>方法中。
**因特网在其网络层，就采用这种类型的服务**。这样做的原因是：因特网是由许多异构网络所组成的，因此在没有提前弄清网络特性的前提下，在源端和目的端建立一个连接几乎是不可能的。

---
# 20.2 IPv4
I P是T C P / I P协议族中最为核心的协议。**所有的 T C P、U D P、I C M P及I G M P数据都以I P数据报格式传输**（见图 1 - 4）。许多刚开始接触 T C P / I P的人对I P提供不可靠、无连接的数据报传送服务感到很奇怪，特别是那些具有 X . 2 5或S N A背景知识的人。
- 不可靠（u n r e l i a b l e）的意思是它不能保证 I P数据报能成功地到达目的地。 **I P仅提供最好的传输服务**。如果发生某种错误时，==如某个路由器暂时用完了缓冲区， I P有一个简单的错误处理算法：丢弃该数据报，然后发送 I C M P消息报给信源端==。任何要求的可靠性必须由上层来提供（如T C P）。
- 无连接（c o n n e c t i o n l e s s）这个术语的意思是 **I P并不维护任何关于后续数据报的状态信息**。每个数据报的处理是相互独立的。这也说明， **I P数据报可以不按发送顺序接收**。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此 B可能在A到达之前先到达。

在本章，简要介绍 I P首部中的各个字段，讨论 **I P路由选择**和子网的有关内容。还要介绍两个有用的命令： i f c o n f i g和n e t s t a t。关于I P首部中一些字段的细节，将留在以后使用这些字段时再进行讨论。 RFC 791[Postel 1981a]是I P的正式规范文件。
## 3.2 IP首部
I P数据报的格式如图3 - 1所示。普通的I P首部长为2 0个字节，除非含有选项字段。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307232227349.png)
分析图3 - 1中的首部。**最高位在左边，记为 0 bit；最低位在右边，记为31 bit**。

4个字节的32 bit值以下面的次序传输：首先是 0～7 bit，其次8～15 bit，然后1 6～23 bit，最后是24~31 bit。**这种传输次序称作 big endian字节序**。由于==T C P / I P首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序==。以其他形式存储二进制整数的机器，如little endian格式，则**必须在传输数据之前把首部转换成网络字节序**。
- 目前的协议版本号是4，因此I P有时也称作I P v 4。3 . 1 0节将对一种新版的I P协议进行讨论。
- 首部长度指的是首部占 **32 bit字**的数目，包括任何选项。由于它是一个 4比特字段，因此首部最长为`60=14*5`个字节。在第8章中，我们将看到**这种限制使某些选项如路由记录选项在当今已没有什么用处**。普通I P数据报（没有任何选择项）字段的值是 5。
- 服务类型（TO S）字段包括一个 **3 bit的优先权子字段**（现在已被忽略），**4 bit的TO S子字段**和1 bit未用位但必须置0。4 bit的TO S分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4 bit中只能置其中1 bit。如果所有4 bit均为0，那么就意味着是**一般服务**。 RFC 1340[Reynolds and Postel 1992] **描述了所有的标准应用如何设置这些服务类型**。RFC 1349[Almquist 1992]对该R F C进行了修正，更为详细地描述了 TO S的特性。

图3 - 2列出了对不同应用建议的 TO S值。在最后一列中给出的是十六进制值，因为这就是在后面将要看到的t c p d u m p命令输出。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307232232436.png)
Te l n e t和R l o g i n这两个交互应用要求最小的传输时延，因为人们主要**用它们来传输少量的交互数据**。另一方面， F T P文件传输则**要求有最大的吞吐量**。==最高可靠性被指明给网络管理（S N M P）和路由选择协议==。用户网络新闻（ Usenet news, NNTP）是唯一要求最小费用的应用。

现在大多数的T C P / I P实现都不支持TO S特性，但是4.3BSD Reno以后的新版系统都对它进行了设置。另外，**新的路由协议如 O S P F和I S - I S都能根据这些字段的值进行路由决策**。
> 在2 . 1 0节中，我们提到S L I P一般提供基于服务类型的排队方法，允许对交互通信数据在处理大块数据之前进行处理。由于大多数的实现都不使用 TO S字段，因此这排队机制由S L I P自己来判断和处理，驱动程序先查看协议字段（确定是否是一个 T C P段），然后检查T C P信源和信宿的端口号，以判断是否是一个交互服务。一个驱动程序的注释这样认为，这种“令人厌恶的处理方法”是必需的，因为大多数实现都不允许应用程序设置TOS字段。

总长度字段是指整个 I P数据报的长度，以字节为单位。==利用首部长度字段和总长度字段，就可以知道 I P数据报中数据内容的起始位置和长度==。由于该字段长 1 6比特，所以 I P数据报最长可达 6 5 5 3 5字节（回忆图 2 - 5，超级通道的 M T U为6 5 5 3 5。它的意思其实不是一个真正的M T U—它使用了最长的I P数据报）。**当数据报被分片时，该字段的值也随着变化**，这一点将在11 . 5节中进一步描述。

尽管可以传送一个长达 6 5 5 3 5字节的 I P数据报，但是大多数的链路层都会对它进行分片。而且，主机也要求不能接收超过 5 7 6字节的数据报。**由于 T C P把用户数据分成若干片，因此一般来说这个限制不会影响 T C P**。在后面的章节中将遇到大量使用 U D P的应用（ R I P，T F T P，B O O T P，D N S，以及S N M P），它们都限制用户数据报长度为 5 1 2字节，小于5 7 6字节。但是，事实上现在大多数的实现（特别是那些支持网络文件系统 N F S的实现）允许超过 8 1 9 2字节的I P数据报。

==总长度字段是 I P首部中必要的内容，因为一些数据链路（如以太网）需要填充一些数据以达到最小长度==。尽管以太网的最小帧长为 4 6字节（见图 2 - 1），但是 I P数据可能会更短。**如果没有总长度字段，那么 I P层就不知道4 6字节中有多少是I P数据报的内容**。

**标识字段唯一地标识主机发送的每一份数据报**。通常**每发送一份报文它的值就会加 1**。在11 . 5节介绍分片和重组时再详细讨论它。同样，在讨论分片时再来分析标志字段和片偏移字
段。
> RFC 791 [Postel 1981a]认为标识字段应该由让IP发送数据报的上层来选择。假设有两个连续的I P数据报，其中一个是由T C P生成的，而另一个是由U D P生成的，那么它们可能具有相同的标识字段。尽管这也可以照常工作（由重组算法来处理），但是在大多数从伯克利派生出来的系统中，每发送一个I P数据报，I P层都要把一个内核变量的值加1，不管交给IP的数据来自哪一层。内核变量的初始值根据系统引导时的时间来设置。

T T L（t i m e - t o - l i v e）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。T T L的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。**当该字段的值为 0时，数据报就被丢弃，并发送 I C M P报文通知源主机**。第 8章我们讨论Tr a c e r o u t e程序时将再回来讨论该字段。

我们已经在第 1章讨论了协议字段，并在图 1 - 8中示出了它如何被 I P用来对数据报进行分用。**根据它可以识别是哪个协议向 I P传送数据**。

首部检验和字段是根据I P首部计算的检验和码。它不对首部后面的数据进行计算。 I C M P、
I G M P、U D P和T C P在它们各自的首部中均含有同时覆盖首部和数据检验和码。
为了计算一份数据报的 I P检验和，首先把检验和字段置为 0。然后，对首部中每个 16 bit
进行二进制反码求和（整个首部看成是由一串 16 bit的字组成），结果存在检验和字段中。当
收到一份 I P数据报后，同样对首部中每个 16 bit进行二进制反码的求和。由于接收方在计算过
26使用TCP/IP详解，卷1：协议
下载
程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，
那么接收方计算的结果应该为全 1。如果结果不是全 1（即检验和错误），那么I P就丢弃收到的
数据报。但是不生成差错报文，由上层去发现丢失的数据报并进行重传。
I C M P、I G M P、U D P和T C P都采用相同的检验和算法，尽管 T C P和U D P除了本身的首部和
数据外，在I P首部中还包含不同的字段。在 RFC 1071[Braden, Borman and Patridge 1988]中有
关于如何计算 I n t e r n e t检验和的实现技术。由于路由器经常只修改 T T L字段（减 1），因此当路
由器转发一份报文时可以增加它的检验和，而不需要对
I P整个首部进行重新计算。 R F C
1141[Mallory and Kullberg 1990]为此给出了一个很有效的方法。
但是，标准的BSD实现在转发数据报时并不是采用这种增加的办法。
每一份 I P数据报都包含源 I P地址和目的 I P地址。我们在 1 . 4节中说过，它们都是 32 bit的
值。
最后一个字段是任选项，是数据报中的一个可变长的可选信息。目前，这些任选项定义
如下：
• 安全和处理限制（用于军事领域，详细内容参见 RFC 1108[Kent 1991]）
• 记录路径（让每个路由器都记下它的 I P地址，见7 . 3节）
• 时间戳（让每个路由器都记下它的 I P地址和时间，见7 . 4节）
• 宽松的源站选路（为数据报指定一系列必须经过的 I P地址，见8 . 5节）
• 严格的源站选路（与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能
经过其他的地址）。
这些选项很少被使用，并非所有的主机和路由器都支持这些选项。
选项字段一直都是以 32 bit作为界限，在必要的时候插入值为 0的填充字节。这样就保证
I P首部始终是32 bit的整数倍（这是首部长度字段所要求的）。
3.3 IP路由选择
从概念上说， I P路由选择是简单的，特别对于主机来说。如果目的主机与源主机直接相
连（如点对点链路）或都在一个共享网络上（以太网或令牌环网），那么I P数据报就直接送到
目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。大多
数的主机都是采用这种简单机制。
在本节和第9章中，我们将讨论更一般的情况，即 I P层既可以配置成路由器的功能，也可
以配置成主机的功能。当今的大多数多用户系统，包括几乎所有的 U n i x系统，都可以配置成
一个路由器。我们可以为它指定主机和路由器都可以使用的简单路由算法。本质上的区别在
于主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报。内含路由器
功能的主机应该从不转发数据报，除非它被设置成那样。在 9 . 4小节中，我们将进一步讨论配
置的有关问题。
在一般的体制中，I P可以从T C P、U D P、I C M P和I G M P接收数据报（即在本地生成的数据
报）并进行发送，或者从一个网络接口接收数据报（待转发的数据报）并进行发送。
I P层在
内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报
来自某个网络接口时， I P首先检查目的I P地址是否为本机的I P地址之一或者I P广播地址。如果
确实是这样，数据报就被送到由 I P首部协议字段所指定的协议模块进行处理。如果数据报的
第3章 IP：网际协议使用27
下载
目的不是这些地址，那么（ 1）如果I P层被设置为路由器的功能，那么就对数据报进行转发
（也就是说，像下面对待发出的数据报一样处理）；否则（ 2）数据报被丢弃。
路由表中的每一项都包含下面这些信息：
• 目的I P地址。它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标
志字段来指定（如下所述）。主机地址有一个非0的主机号（见图1 - 5），以指定某一特定的
主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）。
• 下一站（或下一跳）路由器（ next-hop router）的I P地址，或者有直接连接的网络 I P地
址。下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下
一站路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。
• 标志。其中一个标志指明目的 I P地址是网络地址还是主机地址，另一个标志指明下一
站路由器是否为真正的下一站路由器，还是一个直接相连的接口（我们将在
9 . 2节中
详细介绍这些标志）。
• 为数据报的传输指定一个网络接口。
I P路由选择是逐跳地（ h o p - b y - h o p）进行的。从这个路由表信息可以看出， I P并不知道到
达任何目的的完整路径（当然，除了那些与主机直接相连的目的）。所有的I P路由选择只为数
据报传输提供下一站路由器的 I P地址。它假定下一站路由器比发送数据报的主机更接近目的，
而且下一站路由器与该主机是直接相连的。
I P路由选择主要完成以下这些功能：
1) 搜索路由表，寻找能与目的 I P地址完全匹配的表目（网络号和主机号都要匹配）。如果
找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标
志字段的值）。
2) 搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目
指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。目的网络上的所
有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表
目进行寻径的。
这种搜索网络的匹配方法必须考虑可能的子网掩码。关于这一点我们在下一节中进行
讨论。
3) 搜索路由表，寻找标为“默认（ d e f a u l t）”的表目。如果找到，则把报文发送给该表目
指定的下一站路由器。
如果上面这些步骤都没有成功，那么该数据报就不能被传送。如果不能传送的数据报来自
本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。
完整主机地址匹配在网络号匹配之前执行。只有当它们都失败后才选择默认路由。默认
路由，以及下一站路由器发送的 I C M P间接报文（如果我们为数据报选择了错误的默认路由），
是I P路由选择机制中功能强大的特性。我们在第 9章对它们进行讨论。
为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是
I P路由选择机制
的另一个基本特性。这样做可以极大地缩小路由表的规模，比如 I n t e r n e t上的路由器有只有几
千个表目，而不会是超过 1 0 0万个表目。
举例
首先考虑一个简单的例子：我们的主机 b s d i有一个I P数据报要发送给主机 s u n。双方都在
28使用TCP/IP详解，卷1：协议
下载
同一个以太网上（参见扉页前图）。数据报的传输过程如图 3 - 3所示。
当I P从某个上层收到这份数据报后，它搜索路由表，发现目的 I P地址（1 4 0 . 2 5 2 . 1 3 . 3 3）在
一个直接相连的网络上（以太网 1 4 0 . 2 5 2 . 1 3 . 0）。于是，在表中找到匹配网络地址（在下一节
中，我们将看到，由于以太网的子网掩码的存在，实际的网络地址是 1 4 0 . 2 5 2 . 1 3 . 3 2，但是这
并不影响这里所讨论的路由选择）。
数据报被送到以太网驱动程序，然后
作为一个以太网数据帧被送到 s u n主机上
（见图 2 - 1）。I P数据报中的目的地址是
s u n的I P地址（1 4 0 . 2 5 2 . 1 3 . 3 3），而在链
路层首部中的目的地址是 48 bit的s u n主
机的以太网接口地址。这个 48 bit的以太
网地址是用 A R P协议获得的，我们将在
下一章对此进行描述。
现在来看另一个例子：主机 b s d i有一份I P数据报要传到f t p . u u . n e t主机上，它的I P地
址是1 9 2 . 4 8 . 9 6 . 9。经过的前三个路由器如图 3 - 4所示。首先，主机b s d i搜索路由表，但是没有
找到与主机地址或网络地址相匹配的表目，因此只能用默认的表目，把数据报传给下一站路
由器，即主机 s u n。当数据报从 b s d i被传到s u n主机上以后，目的 I P地址是最终的信宿机地
址（1 9 2 . 4 8 . 9 6 . 9），但是链路层地址却是 s u n主机的以太网接口地址。这与图 3 - 3不同，在那里
数据报中的目的I P地址和目的链路层地址都指的是相同的主机（ s u n）。
图3-4 从b s d i 到f t p . u u . n e t
(192.48.96.9)的初始路径
第3章 IP：网际协议使用29
下载
图3-3 数据报从主机bsdi到sun的传送过程
目的网络=
140.252,13,0
以太网140.252.13
链路层
首部
目的
目的
IP首
部
下一站=
140.252.104.2
(默认)
下一站=
140.252.13.33
(默认)
链路层
首部
IP
首部
链路层
首部
IP
首部
目的以太网=以太网的140.252.1.4
目的IP=192.48.96.9
下一站=
140.252.1.4
(默认)
下一站=
140.252.1.183
(默认)
IP
首部
目的IP=192.48.96.9
目的IP=192.48.96.9
目的以太网=以太网的140.252.13.33
以太网，140.252.13
以太网，140.252.1
调制解
调器
调制解
调器
当s u n收到数据报后，它发现数据报的目的 I P地址并不是本机的任一地址，而 s u n已被设
置成具有路由器的功能，因此它把数据报进行转发。经过搜索路由表，选用了默认表目。根
据s u n的默认表目，它把数据报转发到下一站路由器 n e t b，该路由器的地址是1 4 0 . 2 5 2 . 1 . 1 8 3。
数据报是经过点对点 S L I P链路被传送的，采用了图 2 - 2所示的最小封装格式。这里，我们没有
给出像以太网链路层数据帧那样的首部，因为在 S L I P链路中没有那样的首部。
当n e t b收到数据报后，它执行与 s u n主机相同的步骤：数据报的目的地址不是本机地址，
而n e t b也被设置成具有路由器的功能，于是它也对该数据报进行转发。采用的也是默认路由
表目，把数据报送到下一站路由器 g a t e w a y（1 4 0 . 2 5 2 . 1 . 4）。位于以太网 1 4 0 . 2 5 2 . 1上的主机
n e t b用A R P获得对应于1 4 0 . 2 5 2 . 1 . 4的48 bit以太网地址。这个以太网地址就是链路层数据帧头
上的目的地址。
路由器g a t e w a y也执行与前面两个路由器相同的步骤。它的默认路由表目所指定的下一
站路由器 I P地址是 1 4 0 . 2 5 2 . 1 0 4 . 2（我们将在图 8 - 4中证实，使用 Tr a c e r o u t e程序时，它就是
g a t e w a y使用的下一站路由器）。
对于这个例子需要指出一些关键点：
1) 该例子中的所有主机和路由器都使用了默认路由。事实上，大多数主机和一些路由器
可以用默认路由来处理任何目的，除非它在本地局域网上。
2) 数据报中的目的I P地址始终不发生任何变化（在 8 . 5节中，我们将看到，只有使用源路
由选项时，目的 I P地址才有可能被修改，但这种情况很少出现）。所有的路由选择决策都是基
于这个目的I P地址。
3) 每个链路层可能具有不同的数据帧首部，而且链路层的目的地址（如果有的话）始终
指的是下一站的链路层地址。在例子中，两个以太网封装了含有下一站以太网地址的链路层
首部，但是S L I P链路没有这样做。以太网地址一般通过 A R P获得。
在第9章，我们在描述了 I C M P之后将再次讨论 I P路由选择问题。我们将看到一些路由表
的例子，以及如何用它们来进行路由决策的。
3.4 子网寻址
现在所有的主机都要求支持子网编址（ RFC 950 [Mogul and Postel 1985]）。不是把I P地址
看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。
这样做的原因是因为 A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为
22 4- 2和21 6- 2。事实上，在一个网络中人们并不安排这么多的主机（各类 I P地址的格式如图1 - 5
所示）。由于全0或全1的主机号都是无效的，因此我们把总数减去 2。
在I n t e r N I C获得某类I P网络号后，就由当地的系统管理员来进行分配，由他（或她）来决
定是否建立子网，以及分配多少比特给子网号和主机号。例如，这里有一个
B类网络地址
（1 4 0 . 2 5 2），在剩下的16 bit中，8 bit用于子网号，8 bit用于主机号，格式如图 3 - 5所示。这样
就允许有2 5 4个子网，每个子网可以有 2 5 4台主机。
图3-5 B类地址的一种子网编址
30使用TCP/IP详解，卷1：协议
下载
B类
16位
8位
8位
主机号
子网号
网络号=140.252
许多管理员采用自然的划分方法，即把 B类地址中留给主机的 16 bit中的前8 bit作为子网
地址，后8 b i t作为主机号。这样用点分十进制方法表示的 I P地址就可以比较容易确定子网号。
但是，并不要求A类或B类地址的子网划分都要以字节为划分界限。
大多数的子网例子都是 B类地址。其实，子网还可用于 C类地址，只是它可用的比特数较
少而已。很少出现 A类地址的子网例子是因为 A类地址本身就很少（但是，大多数 A类地址都
是进行子网划分的）。
子网对外部路由器来说隐藏了内部网络组织（一个校园或公司内部）的细节。在我们的
网络例子中，所有的 I P地址都有一个B类网络号1 4 0 . 2 5 2。但是其中有超过 3 0个子网，多于4 0 0
台主机分布在这些子网中。由一台路由器提供了 I n t e r n e t的接入，如图3 - 6所示。
在这个图中，我们把大多数的路由器编号为 Rn，n是子网号。我们给出了连接这些子网的
路由器，同时还包括了扉页前图中的九个系统。在图中，以太网用粗线表示，点对点链路用
虚线表示。我们没有画出不同子网中的所有主机。例如，在子网 1 4 0 . 2 5 2 . 3上，就超过5 0台主
机，而在子网1 4 0 . 2 5 2 . 1上则超过1 0 0台主机。
与3 0个C类地址相比，用一个包含 3 0个子网的B类地址的好处是，它可以缩小 I n t e r n e t路由
表的规模。B类地址1 4 0 . 2 5 2被划分为若干子网的事实对于所有子网以外的 I n t e r n e t路由器都是
透明的。为了到达 I P地址开始部分为 1 4 0 . 2 5 2的主机，外部路由器只需要知道通往 I P地址
1 4 0 . 2 5 2 . 1 0 4 . 1的路径。这就是说，对于网络 1 4 0 . 2 5 2只需一个路由表目，而如果采用 3 0个C类
地址，则需要 3 0个路由表目。因此，子网划分缩减了路由表的规模（在 1 0 . 8小节中，我们将
介绍一种新技术，即使用 C类地址也可以缩减路由表的规模）。
子网对于子网内部的路由器是不透明的。如图 3 - 6所示，一份来自 I n t e r n e t的数据报到达
g a t e w a y，它的目的地址是 1 4 0 . 2 5 2 . 5 7 . 1。路由器g a t e w a y需要知道子网号是 5 7，然后把它
送到k p n o。同样，k p n o必须把数据报送到R 5 5，最后由R 5 5把它送到R 5 7。
图3-6 网络noao.edu（140.252）中的大多数子网安排
第3章 IP：网际协议使用31
下载
3.5 子网掩码
任何主机在引导时进行的部分配置是指定主机 I P地址。大多数系统把 I P地址存在一个磁
盘文件里供引导时读用。在第 5章我们将讨论一个无盘系统如何在引导时获得 I P地址。
除了I P地址以外，主机还需要知道有多少比特用于子网号及多少比特用于主机号。这是
在引导过程中通过子网掩码来确定的。这个掩码是一个 32 bit的值，其中值为 1的比特留给网
络号和子网号，为 0的比特留给主机号。图 3 - 7是一个B类地址的两种不同的子网掩码格式。第
一个例子是n o a o . e d u网络采用的子网划分方法，如图 3 - 5所示，子网号和主机号都是 8 bit宽。
第二个例子是一个B类地址划分成10 bit的子网号和6 bit的主机号。
图3-7 两种不同的B类地址子网掩码的例子
尽管I P地址一般以点分十进制方法表示，但是子网掩码却经常用十六进制来表示，特别
是当界限不是一个字节时，因为子网掩码是一个比特掩码。
给定I P地址和子网掩码以后，主机就可以确定 I P数据报的目的是：(1)本子网上的主机；
(2)本网络中其他子网中的主机；(3)其他网络上的主机。如果知道本机的 I P地址，那么就知道
它是否为A类、B类或C类地址(从I P地址的高位可以得知)，也就知道网络号和子网号之间的分
界线。而根据子网掩码就可知道子网号与主机号之间的分界线。
举例
假设我们的主机地址是 1 4 0 . 2 5 2 . 1 . 1（一个B类地址），而子网掩码为2 5 5 . 2 5 5 . 2 5 5 . 0（其中8
b i t为子网号，8 bit为主机号）。
• 如果目的I P地址是1 4 0 . 2 5 2 . 4 . 5，那么我们就知道 B类网络号是相同的（ 1 4 0 . 2 5 2），但是
子网号是不同的（1和4）。用子网掩码在两个I P地址之间的比较如图3 - 8所示。
• 如果目的 I P地址是1 4 0 . 2 5 2 . 1 . 2 2，那么B类网络号还是一样的（ 1 4 0 . 2 5 2），而且子网号也
是一样的（1），但是主机号是不同的。
• 如果目的I P地址是1 9 2 . 4 3 . 2 3 5 . 6（一个C类地址），那么网络号是不同的，因而进一步的
比较就不用再进行了。
图3-8 使用子网掩码的两个B类地址之间的比较
32使用TCP/IP详解，卷1：协议
下载
16位
8位
8位
8位
10位
16位
B类
子网掩码
子网掩码
B类
网络号
网络号
子网号
主机号
主机号
子网号
B类网络号末尾
指明的子网号末尾
8位
8位
16位
网络号相符
子网号不相等
B类
B类
子网掩码
给定两个I P地址和子网掩码后，I P路由选择功能一直进行这样的比较。
3.6 特殊情况的IP地址
经过子网划分的描述，现在介绍 7个特殊的I P地址，如图3 - 9所示。在这个图中， 0表示所
有的比特位全为 0；- 1表示所有的比特位全为 1；n e t i d、s u b n e t i d和h o s t i d分别表示不为全0或全
1的对应字段。子网号栏为空表示该地址没有进行子网划分。
图3-9 特殊情况的IP地址
我们把这个表分成三个部分。表的头两项是特殊的源地址，中间项是特殊的环回地址，
最后四项是广播地址。
表中的头两项，网络号为 0，如主机使用B O O T P协议确定本机I P地址时只能作为初始化过
程中的源地址出现。
在1 2 . 2节中，我们将进一步分析四类广播地址。
3.7 一个子网的例子
这个例子是本文中采用的子网，以及如何使用两个不同的子网掩码。具体安排如图
3 - 1 0
所示。
图3-10 作者所在子网中的主机和网络安排
如果把该图与扉页前图相比，就会发现在图 3 - 1 0中省略了从路由器 s u n到上面的以太网之
间的连接细节，实际上它们之间的连接是拨号 S L I P。这个细节不影响本节中讨论的子网划分
第3章 IP：网际协议使用33
下载
IP 地
址
可
以
为
描
述
网络号
子网号
主机号
源 端
目的端
0
0
O K
不可能
网络上的主机（参见下面的限制）
0
主机号
O K
不可能
网络上的特定主机（参见下面的限制）
1 2 7
任何值
O K
O K
环回地址（2 . 7节）
- 1
-1
不可能
O K
受限的广播（永远不被转发）
n e t i d
-1
不可能
O K
以网络为目的向n e t i d广播
n e t i d
s u b n e t i d
-1
不可能
O K
以子网为目的向n e t i d、s u b n e t i d广播
n e t i d
- 1
-1
不可能
O K
以所有子网为目的向 n e t i d广播
以太网，子网140.252.1
以太网，子网140.252.13.32
作者所在子网140.252.13
SLIP子网
问题。我们在4 . 6节讨论A R P代理时将再回头讨论这个细节。
问题是我们在子网 1 3中有两个分离的网络：一个以太网和一个点对点链路（硬件连接的
S L I P链路）（点对点链接始终会带来问题，因为它一般在两端都需要 I P地址）。将来或许会有
更多的主机和网络，但是为了不让主机跨越不同的网络就得使用不同的子网号。我们的解决
方法是把子网号从 8 bit扩充到11 b i t，把主机号从 8 bit减为5 bit。这就叫作变长子网，因为
1 4 0 . 2 5 2网络中的大多数子网都采用 8 bit子网掩码，而我们的子网却采用 11 bit的子网掩码。
RFC 1009[Braden and Postel 1987]允许一个含有子网的网络使用多个子网掩码。新
的路由器需求RFC[Almquist 1993]则要求支持这一功能。
但是，问题在于并不是所有的路由选择协议在交换目的网络时也交换子网掩码。
在第1 0章中，我们将看到R I P不支持变长子网，R I P第2版和O S P F则支持变长子网。在
我们的例子中不存在这种问题，因为在我的子网中不要求使用RIP协议。
作者子网中的I P地址结构如图3 - 11所示，11位子网号中的前8 bit始终是1 3。在剩下的3 bit
中，我们用二进制 0 0 1表示以太网，0 1 0表示点对点 S L I P链路。这个变长子网掩码在 1 4 0 . 2 5 2网
络中不会给其他主机和路由器带来问题—只要目的是子网1 4 0 . 2 5 2 . 1 3的所有数据报都传给路
由器s u n（I P地址是1 4 0 . 2 5 2 . 1 . 2 9），如图3 - 11所示。如果 s u n知道子网 1 3中的主机有 11 bit子
网号，那么一切都好办了。
图3-11 变长子网
1 4 0 . 2 5 2 . 1 3子网中的所有接口的子网掩码是 2 5 5 . 2 5 5 . 2 5 5 . 2 2 4，或0 x ffffff e 0。这表明最右边
的5 bit留给主机号，左边的27 bit留给网络号和子网号。
图3 - 1 0中所有接口的I P地址和子网掩码的分配情况如图 3 - 1 2所示。
图3-12 作者子网的IP地址
第1栏标为是“主机”，但是s u n和b s d i也具有路由器的功能，因为它们是多接口的，可
以把分组数据从一个接口转发到另一个接口。
这个表中的最后一行是图 3 - 1 0中的广播地址 1 4 0 . 2 5 2 . 1 3 . 6 3：它是根据以太网子网号
（1 4 0 . 2 5 2 . 1 3 . 3 2）和图3 - 11中的低5位置1（1 6＋8＋4＋2＋1＝3 1）得来的（我们在第 1 2章中将
看到，这个地址被称作以子网为目的的广播地址（ subnet-directed broadcast address））。
34使用TCP/IP详解，卷1：协议
下载
8位=13
11位
16位
B类
子网掩码
5位
子网号ID
网络号=140.252
主机号ID
主机
IP地址
子网掩码
网络号 子网号
主机号
注
释
在子网1上
在作者所在子网上
在以太网上
点对点
点对点
以太网上的广播地址
3.8 ifconfig命令
到目前为止，我们已经讨论了链路层和 I P层，现在可以介绍 T C P / I P对网络接口进行配置
和查询的命令了。i f c o n f i g( 8 )命令一般在引导时运行，以配置主机上的每个接口。
由于拨号接口可能会经常接通和挂断（如
S L I P 链路），每次线路接通和挂断时，
i f c o n f i g都必须（以某种方法）运行。这个过程如何完成取决于使用的 S L I P软件。
下面是作者子网接口的有关参数。请把它们与图 3 - 1 2的值进行比较。
环回接口（2 . 7节）被认为是一个网络接口。它是一个 A类地址，没有进行子网划分。
需要注意的是以太网没有采用尾部封装（ 2 . 3节），而且可以进行广播，而 S L I P链路是一
个点对点的链接。
S L I P接口的标志L I N K 0是一个允许压缩s l i p的数据（C S L I P，参见2 . 5节）的配置选项。其
他的选项有 L I N K 1（如果从另一端收到一份压缩报文，就允许采用 C S L I P）和L I N K 2（所有
外出的I C M P报文都被丢弃）。我们在4 . 6节中将讨论S L I P链接的目的地址。
安装指南中的注释对最后这个选项进行了解释：“一般它不应设置，但是由于一些
不当的ping操作，可能会导致吞吐量降到0。”
b s d i是另一台路由器。由于- a参数是S u n O S操作系统具有的功能，因此我们必须多次执
行i f c o n f i g，并指定接口名字参数：
这里，我们看到以太网接口（ w e 0）的一个新选项： S I M P L E X。这个4 . 4 B S D标志表明接
口不能收到本机传送的数据。在 B S D / 3 8 6中所有的以太网都这样设置。一旦这样设置后，如
果接口发送一帧数据到广播地址，那么就会为本机拷贝一份数据送到环回地址（在 6 . 3小节我
们将举例说明这一点）。
在主机s l i p中，S L I P接口的设置基本上与上面的b s d i一致，只是两端的I P地址进行了互换：
slip % /sbin/ifconfig sl0
sl0: flags=1011<UP,POINTOPOINT,LINK0>
inet 140.252.13.65 --> 140.252.13.66 netmask ffffffe0
最后一个接口是主机 s v r 4上的以太网接口。它与前面的以太网接口类似，只是 S V R 4版
的i f c o n f i g没有打印R U N N I N G标志：
svr4 % /usr/sbin/ifconfig emd0
emd0: flags=23<UP,BROADCAST,NOTRAILERS>
inet 140.252.13.34 netmask ffffffe0 broadcast 140.252.13.63
第3章 IP：网际协议使用35
下载
在所有接口报告的选项
i f c o n f i g命令一般支持 T C P / I P以外的其他协议族，而且有很多参数。关于这些细节可
以查看系统说明书。
3.9 netstat命令
n e t s t a t( 1 )命令也提供系统上的接口信息。 - i参数将打印出接口信息， - n参数则打印出
I P地址，而不是主机名字。
这个命令打印出每个接口的 M T U、输入分组数、输入错误、输出分组数、输出错误、冲
突以及当前的输出队列长度。
在第9章将用n e t s t a t命令检查路由表，那时再回头讨论该命令。另外，在第 1 3章将用
它的一个改进版本来查看活动的广播组。
3.10 IP的未来
I P主要存在三个方面的问题。这是 I n t e r n e t在过去几年快速增长所造成的结果（参见习题
1 . 2）。
1) 超过半数的B类地址已被分配。根据估计，它们大约在 1 9 9 5年耗尽。
2) 32 bit的I P地址从长期的I n t e r n e t增长角度来看，一般是不够用的。
3) 当前的路由结构没有层次结构，属于平面型 ( f l a t )结构，每个网络都需要一个路由表目。
随着网络数目的增长，一个具有多个网络的网站就必须分配多个 C类地址，而不是一个 B类地
址，因此路由表的规模会不断增长。
无类别的域间路由选择 C I D R（Classless Interdomain Routing）提出了一个可以解决第三
个问题的建议，对当前版本的 I P（I P版本4）进行扩充，以适应 2 1世纪I n t e r n e t的发展。对此我
们将在1 0 . 8节进一步详细介绍。
对新版的 I P，即下一代 I P，经常称作 I P n g，主要有四个方面的建议。 1 9 9 3年5月发行的
IEEE Network (vol.7, no.3)对前三个建议进行了综述，同时有一篇关于 C I D R的论文。 R F C
1454 [Dixon 1993]对前三个建议进行了比较。
1) SIP，简单I n t e r n e t协议。它针对当前的I P提出了一个最小幅度的修改建议，采用 6 4位地
址和一个不同的首部格式（首部的前 4比特仍然包含协议的版本号，其值不再是 4）。
2) PIP。这个建议也采用了更大的、可变长度的和有层次结构的地址，而且首部格式也不
相同。
3) TUBA ， 代 表“ TCP and UDP with Bigger Address ”， 它基 于 OSI 的 C L N P
（Connectionless Network Protocol，无连接网络协议），一个与I P类似的O S I协议。它提供大得
多的地址空间：可变长度，可达 2 0个字节。由于C L N P是一个现有的协议，而 S I P和P I P只是建
议，因此关于C L N P的文档已经出现。RFC 1347[Callon 1992]提供了T U B A的有关细节。文献
[Perlman 1992]的第7章对I P v 4和C L N P进行了比较。许多路由器已经支持 C L N P，但是很少有
主机也提供支持。
36使用TCP/IP详解，卷1：协议
下载
4) TP/IX，由RFC 1475 [Ullmann 1993]对它进行了描述。虽然S I P采用了64 bit的址址，但
是它还改变了T C P和U D P的格式：两个协议均为 32 bit的端口号，64 bit的序列号，64 bit的确
认号，以及T C P的32 bit窗口。
前三个建议基本上采用了相同版本的 T C P和U D P作为传输层协议。
由于四个建议只能有一个被选为 I P v 4的替换者，而且在你读到此书时可能已经做出选择，
因此我们对它们不进行过多评论。虽然 C I D R即将实现以解决目前的短期问题，但是 I P v 4后继
者的实现则需要经过许多年。
3.11 小结
本章开始描述了 I P首部的格式，并简要讨论了首部中的各个字段。我们还介绍了 I P路由
选择，并指出主机的路由选择可以非常简单：如果目的主机在直接相连的网络上，那么就把
数据报直接传给目的主机，否则传给默认路由器。
在进行路由选择决策时，主机和路由器都使用路由表。在表中有三种类型的路由：特定
主机型、特定网络型和默认路由型。路由表中的表目具有一定的优先级。在选择路由时，主
机路由优先于网络路由，最后在没有其他可选路由存在时才选择默认路由。
I P路由选择是通过逐跳来实现的。数据报在各站的传输过程中目的 I P地址始终不变，但
是封装和目的链路层地址在每一站都可以改变。大多数的主机和许多路由器对于非本地网络
的数据报都使用默认的下一站路由器。
A类和B类地址一般都要进行子网划分。用于子网号的比特数通过子网掩码来指定。我们
为此举了一个实例来详细说明，即作者所在的子网，并介绍了变长子网的概念。子网的划分
缩小了I n t e r n e t路由表的规模，因为许多网络经常可以通过单个表目就可以访问了。接口和网
络的有关信息通过 i f c o n f i g和n e t s t a t命令可以获得，包括接口的 I P地址、子网掩码、广
播地址以及M T U等。
在本章的最后，我们对I n t e r n e t协议族潜在的改进建议—下一代I P进行了讨论。
习题
3.1 环回地址必须是1 2 7 . 0 . 0 . 1吗？
3.2 在图3 - 6中指出有两个网络接口的路由器。
3.3 子网号为16 bit的A类地址与子网号为8 bit的B类地址的子网掩码有什么不同？
3.4 阅读RFC 1219 [Tsuchiya 1991]，学习分配子网号和主机号的有关推荐技术。
3.5 子网掩码2 5 5 . 2 5 5 . 0 . 2 5 5是否对A类地址有效？
3.6 你认为为什么3 . 9小节中打印出来的环回接口的 M T U要设置为1 5 3 6？
3.7 T C P / I P协议族是基于一种数据报的网络技术，即 I P层，其他的协议族则基于面向连接的
网络技术。阅读文献[Clark 1988]，找出数据报网络层提供的三个优点。

**网际协议第4版** `lnternet Protocol version4, IPv4` 是TCP/IP协议使用的传输机制，图20.4表示了IPv4在TCP/IP协议族中的位置。
![](https://img-blog.csdnimg.cn/8231d4ef90864948b2e89cb6dee6f996.png)

**Pv4是一种不可靠的、无连接数据报协议**一一**尽力传递** `best-effort delivery` 。尽力传递这一词，是指==IPv4协议不提供差错控制、或流量控制（除在头部差错检测外），IPv4假定底层是不可靠的，因此尽力传输到目的地，但没有保证==。**当可靠性很重要时，IPv4必须与一个可靠协议（如TCP）配合起来使用**。

理解尽力传递的常见例子是邮局。邮局尽力传递邮件，但不是永远成功。如果一封未挂号的信遗失，那只能由发信人、或可能的收信人来发现遗失或损坏的情况。

**IPv4是使用<u>数据报分组交换网</u>的无连接协议**，这就是说每一分组独立进行处理，而每一分组使用不同的路由传送到目的端。这表明了，如果一个源端向同一目的端发送许多数据报，那么这些数据报有可能不按顺序到达、有一些数据报也可能遗失、而有些在传输过程中可能受损坏。此时，IPv4要依靠高层的协议解决这些问题。

## 20.2.1 数据报
IPv4层的分组称为**数据报** `datagram` ，图20.5表示了IPv4数据报的格式。
![](https://img-blog.csdnimg.cn/5ba03d91e16f44eca72930ed6ca320c4.png)
**数据报是一个可变长分组**，由两个部分组成：头部和数据。头部长度可由 $20$ 到  $60$ 个字节组成，包含有**与路由选择和传输有关的重要信息**。==习惯上在TCP/IP中都以4个字节表示头部==。按顺序简要地介绍每个字段。

### 1. 版本 `VER` 。
这 $4$ 位字段定义IPv4版本。目前版本是 $4$ ，但在不久版本 $6$ 将取代版本 $4$ 。==这个字段向处理机所运行的IP软件，指明该IPv4数据报是版本 $4$ 格式，所有字段都要按版本 $4$ 的协议来解释==。**如果计算机使用其他版本，则丢弃数据报、而非错误地解释**。

### 2. 头部长度 `HLEN` 
这 $4$ 位字段以 $4$ 字节，**定义数据报头部的总长度**。这个字段是**必需的**，因为头部长度是可变的（在 $20$ 到 $60$ 个字节之间)。当没有选项时，头部长度是 $20$ 个字节，而这个字段的值是 $5\ (5 \times 4 = 20)$ 。当选项字段为最大值时，这个字段的值是 $15\ (15 \times 4= 60)$ 。

### 3. 服务
IETF已经改变了这个 $8$ 位字段的解释与名称，这个字段以前称为服务类型 `service type` 、现称为差分服务 `differentiated service` 。图 20.6显示了这两种解释。
![](https://img-blog.csdnimg.cn/1b11ca1d626d4494bc40c23a4627c850.png)
- **服务类型**：在这种解释中，前面的 $3$ 位称为**优先位**，而后面的4位称为服务类型 `type of service, TOS` ，最后 $1$ 位未使用。
	- a. 优先 `Precedence` 是3位的子字段，其值由 $0$（二进制 $000$）到 $7$（二进制 $111$）。优先子字段定义了**在出现如拥塞等问题时数据报的优先级**。==当路由器出现拥塞、必须丢弃一串数据报时，最低优先值的数据报将首先被丢弃==。在因特网中，有一些数据报比另一些更为重要。例如，用于网络管理的数据报，要比向一组人发送可选信息的一些数据报，紧迫得多和重要得多。
	- b. TOS位是一个 $4$ 位的子字段，每一位都有其特殊的意义。==虽然每一位可以是 $1$ 或 $0$ ，但在一个数据报中的这 $4$ 个位中，只能有一位的值为 $1$== ，表20.1给出了位模式及其解释。
![在这里插入图片描述](https://img-blog.csdnimg.cn/01ea7c22619c407482d1bcebea86ba45.png)
	每次仅当一位置 $1$ ，有 $5$ 种不同的服务。应用程序可以请求「一个特定类型的服务」，但某些应用的默认值，如表20.2所示。
![](https://img-blog.csdnimg.cn/6f7764624eea4547a54665c4f4eb16db.png)
从表 20.2中可清楚地看到，==交互式活动、需要立即引起注意的活动与需要立即响应的活动都要求最小延迟；发送块数据的活动要求最大吞吐量；管理活动要求最高的可靠性；后台活动要求最小成本==。
<b></b>
<b></b>

- **差分服务**：在这种解释下，前 $6$ 位组成**码点** `codepoint` 子字段，而后 $2$ 位不用。码点子字段可有两种使用方法：
	- a. 当最右边 $3$ 位都是 $0$ 时，最左边 $3$ 位与**服务类型解释中的优先位**相同。即它与原来的解释相同；
	- b. 当最右边 $3$ 位不全为 $0$ 时，则 $6$ 位==由因特网或本地机构，按表20.3赋予的优先级定义 $64$ 种服务==。第一类包含 $32$ 种服务类型，第二与第三类分别包含 $16$ 种服务。第一类 $(0, 2 , 4,…, 62)$ 由因特网工程任务组 `IETF` 分配，第二类 $(3 , 7 , 11 ,15,…, 63)$ 由本地组织机构使用，第三类 $(1 , 5, 9,…, 61)$ 是临时的用作实验目的。
请注意，这些数字不是连续的。如果它们是，第一类将从 $0$ 到 $31$ ，第二类从 $32$ 到 $47$ ，第三类从 $48$ 到 $63$ 。这将与TOS的解释不兼容，因为 `XXX000`（包括 $0, 8, 16, 24\mid 32, 40 \mid 48, 56$）将分为三类。相反，在这种分配方法中，所有这些服务都属于类别 $1$ 。注意：这些分配还未最后定下来。
![表20.3 码点的值](https://img-blog.csdnimg.cn/cbc7087f8ca6420aa37bc70aaa5d4468.png)

### 4. 总长度
这个 $16$ 位字段，定义了一个**以字节计的、IPv4数据报的总长度（头部加上数据）**。为了找到**从上层来的数据长度**，可以将总长度减去头部长度（`数据长度=总长度-头部长度`）。将 `HLEN` 字段的值乘以 $4$ 就可得到头部长度。因为这个字段是 $16$ 位长，因此IPv4数据报长度限制在 $65 535  = 2^{16} - 1$ 字节，其中头部占 $20$ 到 $60$ 字节，剩下的是从上层来的数据。

一个长度为 $65535$ 字节的数据报，在今天的技术看来很长，但在不久的将来数据报的长度可能会增大。因为底层技术允许具有更大的吞吐量（更高带宽的网络）。在下一节讨论分段时将会看到，==某些网络不能将 $65 535$ 字节的数据报，封装成它们的帧。要通过这些网络，就必须将这些数据报进行分段==。

人们可能会问，为什么需要这个字段。当一台机器（路由器或主机）接收到一个帧时，它除去头部和尾部、并转发此数据报。那么为什么要使用一个并不需要的字段？回答是：在许多情况下，我们的确不需要这字段的值。**但有些情况下，封装在一个帧中的并不仅仅是数据报**。例如，==以太网协议对「能够封装在一个帧中的数据」有最小值和最大值的限制（$46$ 到 $1500$ 个字节），当数据报的长度小于 $46$ 字节时，它必须增加一些填充字节，才能满足这个要求。在这种情况下，当机器将数据分离出来 `decapsulates the datagram` 时，它必须检查数据报的总长度，以便确定实际的数据长度和填充字节的长度==（图20.7）。
![图 20.7 一个小的数据报封装在以太网帧中](https://img-blog.csdnimg.cn/9a007be5a0fa4478b2ff8e0941e41c78.png)

### 5. 标识、标记、分段偏移
这三个字段用于分段中，在下一节讨论。
### 6. 生存时间
**一个数据报在它通过互联网时，必须具有有限的寿命**。这个字段最初设计时，是打算保持一个时间戳，由每一个经过的路由器将此值减 $1$ ，当时间戳的值变为 $0$ 时，即丢弃该数据报。但对于这种方案，所有机器必须是同步的，井且还必须知道一个数据报从一个机器到另一个机器所花费的时间。

现在，这个字段基本上是**用来控制一个数据报所通过路由器的最大跳数**（路由器数）。
1. 当源端发送数据报时，它在此字段存入一个数，这个数值约为任何两个主机之间的路由器数量的两倍。
2. 处理数据报的每一个路由器将此数值减 $1$——==当路由器接收到一个数据报时，它先将此字段的值减 $1$ 。如果减 $1$ 之后此字段的值为 $0$ ，路由器就丢弃该数据报==。

**这个字段是必需的**，因为因特网中的一些路由表可能会出故障。如果发生故障，一个数据报就可能在两个或更多的路由器之间，传输很长时间、但永远传输不到目的端。这个字段**限制了数据报的寿命**。

这个字段的另一个用途是**故意限制分组的行程**。例如，==如果源端想将分组限制在局域范围内，就可将此字段置为 $1$ 。当分组到达第一个路由器时，这个值就减为 $0$ ，因而数据报就被丢弃了==。

### 7. 协议
这个 $8$ 位字段定义了**使用此IPv4层服务的高层协议**。来自高层一些协议如 `TCP、UDP、ICMP, IGMP` 等的数据，能够封装到IPv4数据报中。这个字段指明，**IPv4数据报必须传递到的、最终的目的协议**。即，==由于IPv4协议携带「来自高层不同协议的数据」，这个字段的值对接收方的网络层了解「数据属于哪个协议」很有帮助==（见图20.8）。 
![图 20.8 协议字段和封装的数据](https://img-blog.csdnimg.cn/cab357b6dca949e9837a192cd09e0ca2.png)
对于不同的高层协议，这个字段的取值如表20.4所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/fff8c6fe6ce948d7aecb7fb20d97bf37.png)
### 8. 校验和
校验和的概念及其计算将在本章的后面讨论。
### 9. 源地址
这个 $32$ 位的字段定义了源端的IPv4地址，在IPv4数据报从源主机到目的主机传输期间，**这个字段必须保持不变**。
### 10. 目的地址
这个 $32$ 位的字段定义了目的端的 IPv4地址，在IPv4数据报从源主机到目的主机传输期间，**这个字段必须保持不变**。

【例20.1】到达的一个IPv4分组的前 $8$ 位如下：$01000010$ 。接收方是否应丢弃该分组？为什么？
解：这个分组有错误，其中最左的 $4$ 位是版本，它是正确的。下一个 $4$ 位是 $0010$ ，则表明它是一个无效长度 $2 \times 4=8$ 。而头部的最小字节数是 $20$ 。因此，这个分组在传输过程中被损坏了。

【例20.2】在一个IPv4分组中，头部长度字段的值用二进制表示为 $1000$ ，试问这个分组携带的选项是几个字节？
解：头部长度值是 $8$ ，说明头部的总字节数为 $8 \times 4=32$ ，前面的 $20$ 个字节是基本头部，后面的 $12$ 个字节是选项。

【例20.3】在一个IPv4分组中，头部长度字段的值是 $5$ ，而总长度字段的值是 $0x0028$ ，试问这个分组携带的数据是多少字节?
解：头部长度字段值为 $5$ ，就是说头部的总字节数为 $5 \times 4=20$（无选项）。总长度是 $40$ 字节，也就是说，这个分组携带 $40-20=20$ 个字节的数据。

【例20.4】一个IPv4分组已到达，最前面几个十六进制数字如下：
```cpp
0x4500 0028 0001 0000 0102...
```
在丢弃这分组之前，它还能跳几次？数据是属于上层的哪一个协议?
解：为了求生存时间字段，我们跳过 $8$ 个字节（$16$ 个十六进制数字)。生存时间字段是第 $9$ 个字节，它的值是 $01$ ，这就是说分组仅能跳一次。协议字段是下一个字节 $02$ ，也就是说上层协议是IGMP（见表20.4）。

## 20.2.2 分段
**一个数据报可以通过几个不同的网络进行传输**，每一个路由器将它所接收的帧拆封成IPv4数据报，对它进行处理，然后再将它封装成另一个帧。==接收到的帧的格式和长度，取决于「此帧刚经过的物理网络所使用的协议」，发出去的帧的格式和长度则取决于「此帧将要经过的物理网络所使用的协议」==。例如，如果一个路由器将一个局域网连接到一个广域网，那么它接收到的帧是一个局域网格式的帧，发出去的帧是广域网的格式。

### 1. 最大传输单元 `MTU`
每一个数据链路层协议都有其自己的帧格式，这格式中定义的一个字段是**数据字段的最大长度**，即**最大传输单元** `Maximum Transfer Unit, MTU` 。即，==当数据报封装成帧时，该数据报的总长度必须小于这个最大数据长度==。这是由网络所使用的硬件和软件给出的限制所定义的（见图20.9） 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/995a8954f7854a9a899da956b27d1d1e.png)
**`MTU` 的值取决于物理网络协议**。表20.5显示了不同协议的 `MTU` 值。
![表 20.5  某些网络的 MTU值](https://img-blog.csdnimg.cn/23810cdc8f9841308f5f41d361cc34b0.png)

为了**使IPv4协议与物理网络无关**，协议设计者决定使IPv4数据报的最大长度等于最大传输单元，其目前定义值是 $65 535$ 字节。如果使用具有此值的MTU协议，那么可使传输更加有效。然而，==对其他一些物理网络，我们就要将数据报进行分割，使其能够通过这些网络，这个过程称为分段== `fragmentation` 。

**源通常不会对IPv4分组进行分段**，而传输层将把数据分割成IPv4和使用中的数据链路层可以容纳的大小。当对一个数据报进行分段时，**每个分段都有其自己的头部**，其中大部分的字段是重复的，**但有些发生了变化**。如果一个己分段的数据报遇到一个更小MTU的网络，那么**已分段的数据报还可再进行分段**。换句话说，数据报在到达最终的目的端之前，可能经过多次分段。

在IPv4中，数据报可能被主机、或其路径中的任何路由器进行分段。然而，**数据报的重组只能在目的主机上进行**，==因为每个分段都是一个独立的数据报，被分段的数据报可以沿着不同的路径传输，因此不能控制或保证一个分段的数据报会走哪一条路径，而属于同一数据报的所有分段，最后都必须到达目的主机==。所以，从逻辑上说应当在最终的目的端进行重组。一个更强的目的是**在传输期间重组分组将会带来效率的降低**。

当对数据报进行分段时，头部中的某些部分需要被复制到所有的分段中。如下一节中所
见，**选项字段可以被复制，也可以不被复制**。==对一个数据报进行分段的主机或路由器，必须改变三个字段的值：标志、分段偏移和总长度==（没有标识）。当然，不管是否进行分段，**校验和的值总是重新计算的**。

### 2. 与分段相关的字段
与IPv4数据报的分段和重组相关的字段是：**标识、标记和分段偏移**。
- **标识**。这个 $16$ 位字段，标识一个从源主机发出的数据报。==当数据报离开源主机时，这个标识与源IPv4地址必须唯一地定义这个数据报==。为了保证唯一性，IPv4协议使用一个计数器来标识数据报。当IPv4协议发送数据报时，就将该计数器的当前值复制到标识字段中，并将此计数器的值加 $1$ 。只要此计数器保存在主存储器中，唯一性就得到保证。
==当数据报分段时，标识字段的值就复制到所有的分段中。即所有的分段都有与原始的数据报相同的标识号==。**该标识号有助于在目的端重组数据报**，目的端知道，「所有具有相同标识值的分段」必须重组成一个数据报。
- **标记**。这是一个 $3$ 位的字段。
	- 第一位保留为以后用；
	- 第二位称为"不分段位" `do not fragment  bit` ，**如果其值是 $1$ ，则机器就不能将该数据报进行分段**。此时，==如果无法通过任何可用的物理网络，对此数据报进行传递，则它就丢弃该数据报，并向源主机发送一个ICMP差错报文==（见[【计算机网络】第四部分 网络层(21) 地址映射、差错报告和多播]()）；**如果其值为 $0$ ，则根据需要对数据报进行分段**；
	- 第三位称为"多分段位" `more fragment bit` 。**如果其值为 $1$ ，则表示此数据报不是最后的分段**，在该分段后还有更多的分段；**如果其值为 $0$ ，则表示它是最后一个或唯一的分段**（见图 20.10）。
![图 20.10 标记字段](https://img-blog.csdnimg.cn/4208bc57ec7e403ea2694b900f799dc9.png)
- **分段偏移**。这个 $13$ 位的字段，表示**这个分段在整个数据报中的相对位置**。它是在原始数据报中的数据偏移量，**以 $8$ 字节为度量单位**。图20.11说明了一个具有 $4000$ 字节的数据报被划分为三个分段。
![图 20.11 分段示例](https://img-blog.csdnimg.cn/aec83946592b44d6bd1c746c935d5f69.png)
原始数据报的字节编号从 $0\sim 3 999$ ，第一个分段携带的数据是 $0 \sim 1399$ 字节。对于这个数据报，分段的偏移量为 $0/8=0$ ，第二分段携带的数据是字节 $1400\sim 2799$ ，对于这个数据报其偏移量为 $1400/8=175$ 。最后，第三个分段携带的数据是字节 $2 800\sim 3 999$ ，其偏移量为 $2800/8=350$ 。
	请记住，偏移量是以 $8$ 字节为单位的。这样做是因为偏移字段的长度只有 $13$ 位，不能用来表示一个大于 $8191$ 的字节数。因此，==将数据报进行分段的主机或路由器，必须这样选择每个分段的长度，即**第一个字节编号能被 $8$ 整除**==。

图20.12表示了图20.11中分段的扩展图。注意：**所有分段的标识字段的值都相同**。还要注意，除最后一个分段外，所有分段的标记中的值都是设置为**多分段** `more fragment bit` 。每一个分段的偏移字段的值也在图中表示。
![图 20.12 分段的细节示例](https://img-blog.csdnimg.cn/3a892d712f3e4a7fba73171d1fb57829.png)
图20.12还表示了，**一个分段本身再进行分段时会发生什么**。在这种情况下，**分段偏移值永远是相对于原始的数据报**。例如，图20.12中的第二个分段又划分为两个长度分别为 $800$ 字节和 $600$ 字节的分段，但这些分段的偏移量所表示的位置都相对于原始的数据。

显然，==即使每一个分段走不同的路径，并在到达时失序，最终目的主机也能用收到的这些分段（假定没有丢失）重组成原始数据报==。所使用的策略如下：
1. 第一个分段的偏移字段的值为 $0$ ；
2. 将第一个分段长度除以 $8$ ，其结果就是第二个分段的偏移值；
3. 将第一个和第二个分段的总长度除以 $8$ ，其结果为第三个分段的偏移值；
4. 继续以上过程，最后一个分段的多分段位的值为 $0$ 。

【例20.5】到达的一个分组的 $M$ 位的值是 $0$ ，试问这是第一个分段还是中间的分段，还是最后的分段？我们是否知道这个分组已被分段？
解：如果M位是 $0$ ，这就是说**不存在更多的分段，该分段是最后的一个分段**。但是，我们不能说原来的分组是否已被分段。**一个没有分段的分组，也会被认为是最后一个分段**。

【例20.6】到达的一个分组的 $M$ 位的值是 $1$ ，试问这是第一个分段还是中间的分段，还是最后的分段？我们是否知道这个分组已被分段？
解：如果 $M$ 位是 $1$ ，这就是说==至少还有一个分段，这个分段是第一个或中间的分段，而不是最后的分段。但我们不知道它是第一个分段还是中间分段，还需要有更多的信息（分段偏移值）==，见例20.7。

【例20.7】到达的一个分组的 $M$ 位的值是 $1$ ，而偏移值是 $0$ ，试问这是第一个分段还是最后的分段，或是中间的分段?
解：因为 $M$ 位是 $1$ ，它或是第一个分段或是中间分段。由于偏移值为 $0$ ，因此它是第一个分段。

【例20.8】到达的一个分组的偏移值是 $100$ ，试问第一个字节的编号是什么？我们能知道最后一个分段的编号吗？
解：为了求第一个字节的编号 `the number of the first byte` ，我们将偏移值 `offset` 乘 $8$ ，这就说第一个字节的编号是 $800$ 。但我们不能确定最后字节的编号，除非知道数据的长度。

【例20.9】到达的一个分组的偏移值是 $100$ ，而 `HLEN` 字段值为 $5$ ，总长度字段的值是 $100$ 。试问第一个字节和最后字节的编号是多少?
解：第一个字节的编号是 $100 \times 8=800$ ，总长度是 $100$ 个字节，头部长度是 $5 \times 4 =20$ 个字节，这就是说这个数据报有 $80$ 个字节。如果第一个字节的编号是 $800$ ，则最后字节的编号是 $879$ 。

## 20.2.3 校验和
在[【计算机网络】第三部分 数据链路层(10) 检错与纠错]()中，已讨论过校验和总的思想及其计算方法，在IPv4分组中的校验和的计算方法，与之相同——首先，**将校验和字段置为 $0$** ；然后，**将整个头部划分为 $16$ 位的部分，并将各部分相加**；最后，**将计算结果（和）取反码**，插入到校验和字段中。

**IPv4分组中的校验和只对头部进行，而不在数据部分进行**。这有两点很充足的理由。首先，==所有将数据封装在IPv4数据报中的高层协议中，都有覆盖整个分组的校验和，因此，IPv4数据报的校验和就**不必校验所封装的数据部分**==；其次，==每经过一个路由器，IPv4数据报的头部就要改变一次、但数据部分不改变，因此，**校验和只对发生变化的部分进行校验**。如果包含数据部分，则每一路由器必须重复计算整个分组的校验和，这就表示每个路由器要花费更多的处理时间==。

【例20.10】图20.13表示对「没有选项的IPv4首部」计算校验和。首部分成多个 $16$ 位的部分。将所有这些部分相加，再将得到的和取反码。将其结果插入到校验和字段中。
![图20.13 IPv4中校验和的计算](https://img-blog.csdnimg.cn/7163299cabc34d1ea8f9c74ce32cc9d7.png)

## 20.2.4 选项
IPv4数据报的头部由两部分组成：固定部分与可变部分。固定部分的长度是 $20$ 个字节，已在前一节讨论过。**可变部分由若干选项组成**，它最长可达 $40$ 个字节。

选项正如其名字所隐含的，它对每个数据报来说井不是必需的。**这些选项用于网络测试和调试**。==虽然选项并非IPv4数据报必需的部分，但选项处理却是IPv4软件的必需部分，这表示所有的标准必须能够处理选项，如果这些选项出现在头部中==。

每个选项详细的讨论已超出范围。在图20.14中给出选项的分类，并对每项进行了简要地说明。
![图 20.14 IPv4中选项的种类](https://img-blog.csdnimg.cn/b2584eaca7034aae81d980a9eace7779.png)

### 1. 无操作
**无操作选项** `no-operation option` 是一个 $1$ 字节选项，用做**选项之间的填充符** `used as a filler between options` 。
### 2. 选项结束
**选项结束选项** `end-of-option option` 也是一个 $1$ 字节，用于**选项字段结束时的填充**。但是，它只能用做最后一个选项 `It, however, can only be used as the last option` 。
### 3. 记录路由
一个**记录路由选项** `record route option` 是用来**记录因特网路由器（处理数据报）** `record the Internet routers that handle the datagram` 。它可列出多达 $9$ 个路由器地址，它用于调试和管理目的。
### 4. 严格源路由
源端使用**严格源路由选项** `strict source route option` ，用来**预先确定数据报在因特网中传送时的路由**。由于几个原因，源端确定路由是很有用的——发送方可以选择一个「具有特定服务类型的路由」，如最小延迟或最大吞吐量。此外，出于发送端的目的，它还可选择一条「更加安全或更加可靠的路由」。例如，发送方可以选择某条路由，使得数据报不经过对手的网络。

==如果一个数据报指明了一个严格的源路由，该数据报就必须经过选项中定义的所有路由器==。若路由器的IPv4地址未列入到数据报中，则该数据报就一定不能通过此路由器。==若一个数据报通过一个未列入的路由器，则该路由器将数据报丢弃井发出差错报文==。
### 5. 松散的源路由
**松散的源路由选项** `loose source route option` 与严格源路由选项相似，但更加宽松。**必须访问表中的路由器**，但数据报还可以访问其他的路由器。
### 6. 时间戳
**时间戳选项** `timestap option` 用来**记录一个路由器处理数据报的时间**。时间是世界时，从午夜开始以毫秒计。==知道一个数据报的处理时间，将有助于用户和管理者对因特网上的各个路由器的行为进行跟踪==。我们能够估计一个数据报从一个路由器到另一个路由器所需的时间。说估计是因为，虽然所有的路由器都使用世界肘，但它们的本地时钟可能没有进行同步。

---
# 20.3 IPv6
TCP/IP协议族中的网络层协议现在是IPv4（网际协议，版本4），IPv4提供在因特网中系统之间的、主机到主机的通信 `the host-to-host communication between systems in the Internet` 。虽然IPv4设计得很好，但自从20世纪70年代IPv4问世以来，数据通信已经有了很大的发展。

IPv4有一些缺点（列出如下），这使得它对飞速发展的因特网有些不适应。
- 虽然有许多近期的解决方案，如子网化、无类寻址和NAT，但在因特网中**地址耗尽**，还依旧是一个长期的问题。
- 因特网必须能**适应实时音频和视频传输**。这种类型的传输要求「最小延迟的策略和预留资源 `minimum delay strategies and reservation of resources` 」，而这些在 IPv4的设计中并没有提供。
- 对于某些应用，因特网必须能够对数据进行**加密和鉴别** `encryption and authentication` ，IPv4不提供数据的加密和鉴别。

为了克服这些缺点，IPv6（网际协议，版本6 `Internetworking Protocol, version 6` ），也称为下一代网际协议 `Internetworking Protocol, next generation, IPng` 被提出，并已成为标准。在IPv6中，网际协议修改了很多，以便适应因特网不可预见的增长。
- IP地址格式和长度、以及分组的格式都改变了。
- 相关的一些协议，如ICMP也修改了。网络层的其他一些协议，如ARP、RARP和 IGMP，则被取消或包含在ICMPv6协议之中（见[【计算机网络】第四部分 网络层(21) 地址映射、差错报告和多播](https://memcpy0.blog.csdn.net/article/details/122274218)）。
- 路由选择协议，如RIP和OSPF（见[【计算机网络】第四部分 网络层(22) 传递、转发和路由选择]()）也进行了少量的修改以适应变化。

通信专家预计，IPv6及其相关协议将很快地取代当前的IP版本。但对IPv6的采用进展很慢，原因是==其发展的最初动机，即IPv4地址耗尽，已经通过无类寻址和NAT等短期策略得到了弥补==。但是，因特网快速应用的发展和新的服务的出现，如移动IP、IP电话和IP移动电话，最终要求用IPv6全部代替IPv4。在本节中，先讨论**IPv6** ，然后研究**从IPv4过渡到IPv6的一些策略**。

## 20.3.1 优点
与IPv4相比，下一代IP或IPv6具有如下的优点：
- **更大的地址空间**。正如[【计算机网络】第四部分 网络层(19) 逻辑寻址]()中讨论的那样，IPv6地址是 $128$ 位长。与 $32$ 位地址相比，其地址空间增加了很多（$2^{96}$）；
- **更好的头部格式**。IPv6使用了新的头部格式，==其选项与基本头部分开，如果需要，**可将选项插入到基本头部与上层数据之间**==。这就简化和加速了路由选择过程，因为大多数的选项不需要由路由器检查。
- **新的选项**。IPv6有一些新的选项来实现附加的功能。
- **允许扩充**。如果新的技术或应用需要时，IPv6允许协议进行扩充。
- **支持资源分配**。在IPv6中，==服务类型字段被取消了，但增加了一种机制（称为**流标号**），使得源端可以请求对分组进行特殊的处理==。这种机制可用来支持像实时音频和视频的通信量。
- **支持更多的安全性**。在IPv6中的加密和鉴别选项提供了分组的保密性和完整性。

## 20.3.2 分组格式
IPv6分组格式如图20.15所示，每个分组由「**必须要有的基本头部**和**紧接其后的有效载荷**」所组成，有效载荷由两部分组成：**可选的扩展头部**和**来自上层的数据**。基本头部占用 $40$ 字节，而扩展头部和来自上层的数据，可以包含多达 $65535$ 字节的信息。
![图20.15 IPv6数据报头部和有效载荷](https://img-blog.csdnimg.cn/e270c0d7c40c41fd90d56a626089efac.png)

### 1. 基本头部
图20.16说明了具有 $8$ 个字段的**基本头部** `base header` 。这些字段如下：
![图20.16 IPv6数据报的格式](https://img-blog.csdnimg.cn/714bcbf117084fa5a1bb8da55dd6983f.png)
- **版本**。这个 $4$ 位字段定义了IPv6的版本号。对IPv6，其值为 $6$ 。
- **优先级**。这个 $4$ 位字段定义了**当发生通信量拥塞时的分组的优先级**，在后面讨论这个字段。
- **流标号** `flow label` 。一个 $3$ 字节（$24$ 位）的字段，它用来**对特殊的数据流提供专门处理**。在后面讨论这个字段。
- **有效载荷长度**。这 $2$ 字节的有效载荷长度 `payload length` 字段，定义了不包括基本头部在内 `excluding the base header` 的IP数据报的总长度。
- **下一个头部**。一个 $8$ 位的字段，它定义了**数据报中跟随在基本头部之后的头部**。下一个头部或者是「IP所使用的可选的扩展头部」，或者是UDP或TCP等封装数据包的报头。**每一个扩展头部也包含这个字段**。表20.6给出了下一个头部的值。注意：在版本 $4$ 中这个字段称为协议。
- **跳数限制**。这个 $8$ 位的跳数限制 `hop limit` 字段，与IPv4中的生存时间 `TTL` 字段所起的作用是一样的。
- **源地址**。该字段是一个 $16$ 字节（$128$ 位）的因特网地址，它是用来识别数据报的原始源端。
- **目的地址**。该字段是一个 $16$ 字节（$128$ 位）的因特网地址，通常用来识别数据报的最终目的地。然而，==如果使用了源路由选择，那么该字段就包含了下一个路由器的地址==。
![表 20.6](https://img-blog.csdnimg.cn/22d65abd47c8489097a1350b8e376dc3.png)


### 2. 优先级
IPv6分组的优先级字段定义==从相同源端发出的每一个分组、相对于其他分组的优先级==。例如，如果由于拥塞原因，两个连续的数据报中必须丢弃一个，则具有较低的**分组优先级** `packet priority` 的数据报将被丢弃。

IPv6将通信量划分为两大类：**可进行拥塞控制的**和**不可进行拥塞控制的**。
#### (1) 可进行拥塞控制的通信量
如果源端在出现拥塞时，能够适应这种情况，使其通信量下降，则此通信量称为**可进行拥塞控制的通信量** `congestion-controlled traffic` 。例如，使用滑动窗口协议的TCP协议，能够很容易地对通信量进行响应。众所周知，==在可进行拥塞控制的通信量中，分组可以延迟到达、或丢失、或不按序接收==。可进行拥塞控制的数据被指定为从 $0$ 到 $7$ 的优先级，如表20.7所示。优先级 $0$ 是最低的，优先级 $7$ 是最高的。
![表 20.7 可进行拥塞控制的通信量的优先级](https://img-blog.csdnimg.cn/dcb57a255a544d6faa84a9f68a7f576c.png)
优先级描述如下;
- **未指明的通信量** `No specific traffic` 。当不需要定义优先级时，就将优先级 $0$ 分配给分组。
- **后台数据** `Background data` 。这个组（优先级 $1$ ）定义的数据通常是**在后台传递**，新闻的传递是一个很好的例子。
- **不关注的数据通信量** `Unattended data traffic` 。==如果用户并不等待（关注）要接收的数据，则分组将被指定优先级 $2$ ，电子邮件就属于这类==。一个用户将电子邮件发送给另一个用户，但接收者并不知道电子邮件马上到达。此外，电子邮件通常在转发之前要经过存储，有少量延迟并不要紧。
- **关注的批量数据通信量** `Attended bulk data traffic` 。==当传送批量数据、而用户正在等待（关注）接收这个数据（可能会有些延迟时），则这种传送数据协议就使用优先级 $4$  ，FTP和HTTP属于这组==。
- **交互式通信量** `Interactive traffic` 。在这一组中，需要与用户交互的协议，如TELNET被指定为第二高的优先级。
- **控制通信量** `Control traffic` 。**控制通信量的优先级最高**，路由选择协议（如 OSPF和RIP）以及管理协议（如SNMP）都使用这个优先级。

#### (2) 不可进行拥塞控制的通信量
这指的是**期望最小延迟的通信量类型**，==丢弃分组是不希望出现的，在大多数情况下重传也是不可能的。即，源端不能使自己适应拥塞，实时音频和视频是这类通信量很好的例子==。

优先级号 $8$ 到 $15$ 被指定给**不可进行拥塞控制的通信量** `noncongestion-controled traffic` 。虽然还没有特殊的标准指定给这类数据，但优先级的指定是基于「**当丢弃一些分组时，接收到的数据的质量会有多大的影响**」来确定的。包含较低冗余度的数据（如低保真音频或视频）给予较高优先级，包含较高冗余度的数据（如高保真音频或视频）可以给予较低的优先级（$8$），见表20.8。
![表20.8 不可进行拥塞控制通信量的优先级](https://img-blog.csdnimg.cn/485595b48f0e4c279a20ab4868654f33.png)
### 3. 流标号
从**特定源端**向**特定目的端**发送的分组序列，如果需要路由器的特殊处理，则称为**分组流**。==**源地址与流标号的值组合**唯一地定义了一个分组流==。

==对路由器来说，一个流是共享某些特性的分组序列==。例如，经过相同路径、使用相同的资源、具有相同安全性等等。==**支持流标号处理的路由器有一个流标号表**，这个表为每一个活动的流标号设置一个项目，每一个项目定义相应的流标号所需的服务==。当路由器收到一个分组时，它就从其流标号表中，找出「在分组中定义的流标号值」所对应的项目。但注意：==**流标号本身并不给流标号表项目提供信息**，信息是由其他方法提供的，如逐跳选项或其他协议==。
- 在最简单形式中，**流标号可用来加速路由器对分组的处理**。当路由器收到一个分组时，它不用查找路由表、并用路由选择算法确定下一跳的地址，而是可以很容易地在流标号表中找到下一跳的地址。
- 在更复杂的形式中，**流标号可用来支持实时音频和视频的传输**。特别是数字形式的实时音频或视频，需要高带宽、大缓存、长处理时间等资掘。进程可以事先对这些资掘进行预留，以保证实时数据不会因资源不够而被延迟。使用实时数据和预留这些资源，需要IPv6外的一些其他协议，如实时协议 `RTP` 和资源预留协议 `RSVP` 。

为了有效地使用流标号，已定义了三个原则：
1. **流标号由源主机指定给分组**，这个标号是在 $1$ 到 $2^{24} - 1$ 之间的随机数。==当己存在的流仍处于活跃状态时，源端一定不能给新的流重复使用一个用过的流标号==；
2. 如果主机不支持流标号，它就将这个字段置为 $0$ 。如果路由器不支持流标号，它就简单地忽略它；
3. ==所有属于同一个流的分组，必须具有相同的源地址、相同的目的地址、相同的优先级和相同的选项==。

### 4. IPv4头部和IPv6头部的比较
表20.9比较了IPv4和IPv6分组的头部。
![表 20.9 IPv4和 IPv6分组头部的比较](https://img-blog.csdnimg.cn/bd09e7083e8345a895c41186f670ba56.png)
1. IPv6**取消了头部长度字段**，因为在此版本中**头部长度是固定的**；
2. IPv6**取消了服务类型字段**，优先级和流标号字段合在一起，取代服务类型字段的功能；
3. IPv6**取消了总长度字段**，替代的是**有效载荷长度字段**；
4. 在IPv6中的基本头部中**取消了标识 、标记和偏移字段**，这些都包含在分段扩展头部中；
5. 在IPv6 中，将 `TTL` 字段**称为跳数限制字段**；
6. 协议字段被**替换为下一个头部字段**；
7. **取消了头部校验和**，因为校验和自上层协议提供，因此这一层不需要了；
8. IPv4的选项字段在IPv6中被实现为扩展头部

## 20.3.3 扩展头部
基本头部的长度是固定的 $40$ 字节，但是要使IP数据报有更多的功能，在基本头
部的后面还可增加多达 $6$ 个**扩展头部** `extension header` 。这些头部中的许多都
是IPv4的选项，图20.17给出了扩展头部的 $6$ 种类型。
![图 20.17 扩展头部的类型](https://img-blog.csdnimg.cn/57d9b1011b5d458cabce286c85cf356a.png)
### 1. 逐跳选项
==当源端需要将信息传递给「数据报经过的所有路由器」时，就需要使用**逐跳选项**== `hop-by-hop option` 。到目前为止，只定义了三种选项：`Pad1, PadN` 和**特大有效载荷** `jumbo payload` 。Pad1选项是 $1$ 字节长，其作用是为了对齐。PadN在概念上与Pad1相似，其差别是当两个或更多字节需要对齐时，就要使用PadN。特大有效载荷选项用来定义比 $65535$ 字节更大的有效载荷。
### 2. 源路由选择
源路由选择扩展头部将「IPv4严格的源路由和松散的源路由的概念」结合在一起。
### 3. 分段
**分段** `fragmentation` 的概念与IPv4中的一样，**但分段发生的地方却不同**。在IPv4中，==如果数据报长度超过「数据报所要经过的网络的MTU」时，源端或路由器就需要将其进行分段==。**在IPv6中，只有原始的源端才能进行分段**，源端必须使用**路径MUT发现技术** `path MTU discovery technique` ，找出在其路径上的任何网络所支持的最小MTU，然后源端利用得到的这个知识进行分段。
### 4. 鉴别
**鉴别** `authentication` 扩展头部有双重目的：它证实报文发送者并**保证数据的完整性**。当在[【计算机网络】第七部分 网络安全(31)]()中讨论网络安全性时，再讨论这个扩展头部。
### 5. 加密的安全有效载荷
**加密的安全有效载荷** `encrypted security payload, ESP` 是一个扩展，它**提供保密性**并能防止窃听。在[【计算机网络】第七部分 网络安全(31)]()中讨论这个扩展头部。
### 6. 目的端选项
**目的端选项** `destination option` 用于**当源端需要将信息仅传递给目的端，中间的各路由器则不允许读取这些信息**。

### 7. IPv4选项和IPv6扩展头部的比较
表20.10比较了IPv4中的选项和IPv6中的扩展头部。
![表 20.10 IPv4选项和 IPv6选项的比较](https://img-blog.csdnimg.cn/b044710e8c9946fdb742bae69ca280aa.png)
1. 在 IPv4中的**无操作和选项结束选项**，被替换成IPv6中的**Pad1和PadN选项**；
2. 在 IPv6中，**没有记录路由选项**，因为它未被使用；
3. 在 IPv6中，**没有实现时间戳选项**，因为它未被使用；
4. 在 IPv6中，**源路由器选项**称为源路由扩展头部；
5. 在IPv4中的基本头部的**分段字段**，已经移到IPv6中的分段扩展头部
6. 在IPv6中的**鉴别扩展头部是新的**；
7. 在IPv6中，**加密的安全有效载荷扩展头部是新的**

---
# 20.4 IPv4到IPv6的过渡
因为因特网上的系统非常多，所以从IPv4过渡到IPv6不能突然发生。要使每一个在因特网中的系统从IPv4过渡到IPv6 ，需要花费相当长的时间。这种过渡必须平滑的，以防止IPv4和IPv6系统间出现任何问题。IETF已经设计了三种策略来使这一过渡时期更加平滑（图20.18）。
![图 20.18 三种过渡策略](https://img-blog.csdnimg.cn/abafa2406c98415bacf1987c83fc7120.png)
## 20.4.1 双协议栈
IETF推荐所有的主机在完全过渡到第6版之前，使用一个**双协议栈** `dual stack` 。换言之，一个站应同时运行IPv4和IPv6，直到整个因特网使用IPv6。图20.19给出了双协议栈的配置示意图。
![图 20.19 双协议栈](https://img-blog.csdnimg.cn/78412cec43df449b86a300bd97dadaf8.png)
**当把分组发送到目的端时，为了确定使用哪个版本，主机要向DNS进行查询**。如果DNS返回一个IPv4地址，那么源主机就发送一个IPv4分组；如果返回一个IPv6地址，就发送一个IPv6分组。

 
## 20.4.2 隧道技术
==当两台使用IPv6的计算机要进行相互通信，但其分组要通过使用IPv4的区域时，就要使用**隧道技术** `tunneling` 这种策略==。要经过该区域，该分组必须具有IPv4地址。因此，当进入这种区域时，IPv6分组要封装成IPv4分组；而当分组离开该区域时，再去掉这个封装。这就好像IPv6分组进入隧道一端，而在另一端流出来。为了更清楚地说明，如何利用IPv4分组携带IPv6分组，其协议的值设置成 $41$ `To make it clear that the IPv4 packet is carrying an IPv6 packet as data, the protocol value is set to 41` 。隧道技术如图20.20所示。
![图20.20 隧道策略](https://img-blog.csdnimg.cn/edb0a9896f154f35a44753d817c31821.png)
## 20.4.3 头部转换
当因特网中绝大部分已经过渡到IPv6，但一些系统仍然使用IPv4时，需要使用**头部转换** `header translation` 。发送方想使用IPv6 ，但接收方不能识别IPv6，**这种情况下使用隧道技术无法工作**，因为分组必须是IPv4的格式，才能被接收方识别。在此情况下，**头部格式必须通过头部转换彻底改变**，IPv6的头部就转换成IPv4的头部（见图 20.21）。
![图 20.21 头部转换](https://img-blog.csdnimg.cn/b0151d8f4076466caf2fed63c8f76961.png)
头部转换使用被映射的地址，将IPv6地址转换成IPv4地址。表20.11列出了将IPv6分组头部转换为IPv4分组头部、所使用的一些规则。
![表 20.11 头部转换](https://img-blog.csdnimg.cn/554f2e572dae4a2e8d6a447a882a2ef8.png)
1. 用提取**最右边 $32$ 位**的方法，将IPv6被映射的地址改变为IPv4地址
2. 将IPv6优先级字段的值丢弃；
3. 将IPv4的服务类型置为 $0$ ；
4. 计算IPv4的校验和，并插入到相应的字段中；
5. 忽略IPv6的流标号；
6. 兼容的扩展头部要转换成选项，插入到IPv4的头部中；
7. 计算出**IPv4头部的长度**，将其插入到相应的字段中；
8. 计算出**IPv4分组的总长度**，将其插入到相应的字段中
 

