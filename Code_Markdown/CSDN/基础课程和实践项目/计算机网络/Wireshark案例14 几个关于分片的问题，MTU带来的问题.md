上篇文章《一个你本该能解决的问题》被一些技术圈的朋友转载后，收到了不少网友提问。我从中挑了几个最有代表性的，在本文一并回答了，希望也是你感兴趣的。

### 问题1：为什么要分片？
20世纪60年代以前，数据通信是依靠**电路交换技术**的，根本没有分片一说，比如传统电话。**由于电路交换的双方要独占链路，所以利用率很低**，直到PaulBaran和DonaldDavies发明了**分组交换**的概念，**把数据分割成小包后才实现了链路共享**。

既然要分割，就得先确定一个包的大小，有趣的是当时这两位独立发明人都在实验室中选择了128字节作为一个传输单位。不过到了20世纪80年代的**以太网**中，就发展到**以1500字节作为最大传输单位了**，即MTU（Maximum Transmission Unit）为1500。

**刨去20字节的头部，一个IP包最多可以携带1500-20=1480字节的数据**。当要传输的数据块超过1480字节时，网络层就不得不把它分片，**封装成多个网络包**。

### 问题2：发送方是怎样确定分片大小的？
一般来说，**发送方是依据自身的MTU来决定分片大小的**。图1演示了一块数据被MTU为1500的发送方分割成了23个分片的样子。我们可以从“off=0”、“off=1480”、“off=2960”等偏移量计算出这些分片所携带的数据量都为1480字节，和问题1中的分析一致。
图1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091544591.png)
不过你如果经常分析各种环境中的包，会发现**有些分片并不是携带1480字节，而是更大或者更小**。这是因为有些网络是JumboFrame（巨帧）或PPPOE之类的，**它们的MTU并不是1500**。

于是问题来了，**MTU不一致的两个网络之间要通信怎么办**？比如启用巨帧之后的MTU是9000字节，那从发送方出来的包就有9000字节，万一经过一个MTU只有1500字节的网络设备，**还是可能被重新分片甚至丢弃**。这种情况下发送方要怎样决定分片大小，才能避免因为MTU不一致而出问题呢？

比较理想的办法是**先通过Path MTU Discovery协议来探测路径上的最小MTU，从而调节分片的大小**。可惜该协议是依靠ICMP来探测的，会被很多网络设备禁用，所以不太可靠。

总而言之，**目前发送方没有一个很好的机制来确定最佳分片大小**，所以实施和运维人员配置MTU时必须慎之又慎，**尽量使网络中每个设备的MTU保持一致**。在以后的文章中我会分享一些由于MTU配置出错而导致的问题。

### 问题3：接收方又是靠什么重组分片的？
假如分片都到达接收方了，要如何重组它们呢？从图1可见每个分片都包含了“off=xxxx,ID=008c”的信息，**接收方就是依据这两个值，把ID相同的分片按照off值（偏移量）进行重组的**。

原理非常简单，唯一的问题是**接收方如何判断最后一个分片已经到达，应该开始重组了**。请看图2所示的最后一个分片，也即第29号包，它包含了一个“More fragments=0”的Flag，表示**它是最后一个分片**，因此接收方可以开始重组了。
图2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091546571.png)
而其他的分片，比如图3的28号包却包含了一个“More fragments=1”的Flag，因此接收方知道后续还有更多分片，所以**先缓存着不重组**。==有一个网络攻击方式就是持续发送“More fragments”为1的包，导致接收方一直缓存分片，从而耗尽内存==。
图3

### 问题4：TCP是如何避免被发送方分片的？
==TCP可以避免被发送方分片，是因为它主动把数据分成小段再交给网络层==。**最大的分段大小称为MSS（Maximum Segment Size）**，它相当于把MTU刨去IP头和TCP头之后的大小，所以**一个MSS恰好能装进一个MTU中**。
图4
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091547110.png)

图4演示了MSS和MTU的关系。有的时候TCP头不只20字节，所以会侵占一些MSS的空间，比如图5的例子中就占用12字节作为TCPOptions，那传输层真正用来承载数据的就剩下1500-20-20-12=1448字节了。**这些字节数都能在Wireshark中看到**。这就是为什么我向网络教师们大力推荐Wireshark，演示时真是一目了然。
图5
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091548516.png)

**UDP则没有MSS的概念，一股脑交给网络层，所以可能被分片。分片和重组都会影响性能**，所以UDP在这一点上比TCP落后一些。

### 问题5：那TCP又是怎样适配接收方的MTU的？
问题4只分析了**为什么TCP包不会被发送方的网络层分片**。那万一接收方的MTU比发送方的小怎么办？比如发送方启用了巨帧（Jumbo Frame），把MTU提高到9000字节，但接收方还停留在1500字节的情况。

这个问题其实在我的上一本书中提到过，**TCP建立连接时必须先进行三次握手**（如图6所示），**在前两个握手包中双方互相声明了自己的MSS**，客户端声明了MSS=8960，服务器声明了MSS=1460。三次握手之后，客户端知道自己的MTU比服务器的大，如果发一个9000字节的包过去很可能在路上就被分片或丢弃。于是在这个连接中，**客户端会很识相地把自己的MSS也降到1460字节，从而适配了接收方的MTU**。
图6
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091549722.png)
TCP在避免分片这一点上已经做得足够用心，发送方和接收方都考虑到了。然而网络上的隐患防不胜防，**假如路径上有个交换机的MTU比发送方和接收方的都小，那还是会出问题**。
### 问题6：为什么UDP比TCP更适合语音通话？
如果把UDP和TCP想象成两位搬运工，前者的风格就是盲目苦干，搬运过程中丢了东西也不管；而后者却是小心翼翼，丢了多小的东西都要回去捡。**假如某个应用环境允许忽视质量，只追求速度，那UDP就是一个更好的选择**。语音传输正符合这种情况，因为它最在乎的不是音质，而是延迟。

**采用UDP传输时，如果有些包丢失，应用层可以选择忽略并继续传输其他包**。由于一个发音会被采样到很多个包中，所以丢掉其中一些包只是影响到了音质，却能保障流畅性。

而采用TCP传输时，**出现丢包就一定要重传，重传就会带来延迟**。这是TCP与生俱来的特点，即使应用层想忽略丢包都没办法。前文说过TCP的优点是可靠，有丢包重传机制，这个优点在语音传输时就变成了缺点。通话延迟的后果很严重，比如你在语音聊天时对女神说，“这是我的头像，牛吧？”如果在“头”和“像”之间恰好多出一段延迟，对方听上去就可能变成“这是我的头，像～牛吧？”然后给你回一句，“很像！”

### MTU导致的悲剧
MTU带来的问题实在太多了，但凡做过运维、实施或者技术支持的工程师，或多或少都会遇到。一个典型的MTU问题发生在类似图1的环境中，即**两个子网的MTU大小不一样**。
图1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091552931.png)
当客户端发给服务器的巨帧经过路由器时，**或者被丢包，或者被分片**。这取决于该巨帧是否在网络层携带了DF（Don’t fragment）标志。**如果带了就被丢弃，如果没带就被分片**。从Wireshark上很容易看到DF标志，如图2中的方框内所示。
- 分片的情况往往被忽略，因为它只影响一点点性能，大多数时候甚至察觉不出。
- 丢包的情况就无法忽略了，因为丢包之后再重传多少遍都没用，会一直丢，整个传输就像掉进了黑洞，所以往往会导致严重的后果。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091553187.png)
图2

我有个实验环境恰好就是图1这样的，可以来做个实验加深理解。我从客户端给服务器发送了两个ping请求，**第一个携带1472字节，第二个携带1473字节，并都用了“-f”参数设置了DF标志**。命令及结果请看图3，第一个ping成功，第二个则失败了。
图3
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091555354.png)

由于**ICMP头为8字节，IP头为20字节**，所以第一个ping请求在网络层的长度为1472+8+20=1500字节，第二个ping请求则为1473+8+20=1501字节。我的路由器MTU是1500字节，不难理解第一个ping请求的长度没有超过MTU，所以可以传输成功；而**第二个ping请求的长度超过了路由器出口的MTU，又不允许被切分，所以不能传输成功**。在图3底部可以看到路由器提示了“Packet needs to be fragmented but DF set”。

这个过程的网络包可以从图4中看到，请注意**最后一个包是路由器回复的**“Fragmentation needed”，而不是服务器回复的。假如ping的时候没有用“-f”设置DF标志，那么1473字节也是能ping成功的，只是在路上会被切分成两个包。
图4
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091556778.png)
理论说起来很简单，实验做出来也不难，但在生产环境中的症状就没这么明显了，**要发现MTU问题往往需要一些想象力**。我收藏了不少MTU相关的案例，在本文挑出三个最有代表性的来分享。
### 案例1
用户浏览某些共享目录时客户端会死机，浏览其他目录则不会。碰到这种症状，**恐怕没有人会想到是MTU导致的**，所以经过长时间徒劳无功的排错之后，工程师不得不抓了个包。这个包是在服务器上抓的（因为客户端死机，根本没法抓），如图5所示，服务器回复的包“Seq=193，Len=1460”在持续重传，但客户端一直没有确认，似乎是发生丢包了。从图5底部还可以看到这个包携带的信息是该目录的子文件（夹）列表。
图5
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091557469.png)

导致丢包的可能性有很多，我为什么认定是MTU导致的呢？推理过程如下。1．==如果端口被防火墙阻止了也可能丢包，但是会从三次握手时就开始丢，而不是等到浏览目录的时候==。
2．如果网络拥塞也可能丢包，但一段时间后能恢复，而不是这样持续地丢。3．丢的那个包携带了1460字节（相当于占满了整个1500字节的MTU），算是比较大的。而没被丢弃的2号包和4号包都携带了很少的字节数，**只丢大包的症状说明很可能就是MTU导致的**。
4．我用“ping -l 1472 -f”测试，果然失败了。逐渐减小每次ping的长度，到了1400字节左右才成功，这说明**网络上有个设备的MTU比较小**。
5．于是把服务器上网卡的MTU相应改小，问题果然就消失了。
6．之所以浏览其他目录没有死机，**可能是因为这些目录中的子文件（夹）比较少，凑不满一个大包**。

我曾经访问公司内网时出现问题，在抓包里也看到类似于图5的症状，后来也是通过修改MTU解决的。
### 案例2
客户端的MTU为1500字节，服务器端的MTU为9000字节，平时连接正常。运维人员听说**两端的MTU最好一致**，所以把客户端的MTU提高到9000字节，没想到连接反而出问题了。虽然该案例听上去不太科学，但如果网络路径上有个设备的MTU是1500字节，这个问题就真会发生。

**原先客户端和服务器在三次握手时，双方会“协商”使用一个1460字节（MTU-TCP头-IP头）的MSS**，所以可以顺利通过那个MTU为1500的网络设备。如果两端都是9000字节了，那三次握手时就会得到8960字节的MSS，因此通不过那个网络设备。
### 案例3 无法完成Kerberos身份认证
在客户端抓到的包如图6所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307091615909.png)

由图6可见客户端在持续地向KDC发送TGS-REQ，但是收不到任何回复。本来碰到这种情况最好在KDC上也抓个包看看的，但是KDC一般不让人登上去。怎么办呢？

从这几个网络包里是挖掘不出更多线索了，我们只能推测哪些因素会导致TGS-REQ得不到回复。有一个可能是**端口被防火墙封掉**，但那样的话之前的其他Kerberos包（比如AS-REQ）也得不到回复，不可能走到TGS-REQ这一步，因此防火墙可以排除。

还有一个可能就是MTU导致的丢包了，假如网络路径上有个交换机的MTU偏小，**大包无法通过就可能出现此症状**。仅从Wireshark中我们无法判断是客户端发给KDC时丢包了，还是KDC回复客户端时丢包了，只能先试着把客户端的MTU改小一点，问题果然就消失了。

**其实利用“ping -f -l <字节数>”试探出路径上的最小MTU也可以，前提是网络中没有禁用ICMP**。
