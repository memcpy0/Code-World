问，“林工，被损坏的帧在Wireshark中是长什么样子的？”我一时竟不知如何 回答，因为虽然阅包无数，但从来没有留意过里面有受损的，更不知道它们长成什么样 子。后来仔细一想，才意识到受损的帧本来就不会显示在Wireshark上。为什么呢？这 涉及**数据链路层的错误检测机制FCS**（Frame Check Sequence）：每个帧在发送前都 会被发送方校验一次，然后生成4个字节的FCS存在帧尾。接收方拿到帧之后，又会用 相同的算法再做一次校验并生成FCS。假如这次生成的FCS和帧尾携带的不一致，就说 明该帧已被损坏，应该丢弃了。

图1表示了一个以太网帧的部分组成，**由于校验是由网卡完成的，所以在主机上抓包一般看不到FCS区域，只能看到灰色的4个区域**。受损的 帧则所有区域都看不到，因为整个被网卡丢弃了。 
图1 
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307071710275.png)
既然如此，我们怎样才能判断有帧损坏呢？**有的时候抓包分析即可**，比如我抓包发现实 验室里的一台机器会随机丢包，即便在没什么流量的时候都会丢。因此我判断丢包不是 拥塞导致的，而是硬件问题导致了帧损坏，后来换了根光纤线果然就好了。

**如果不想抓 包，可以在交换机接口上检查FCS的错误统计**，比如下面的show int输出。Linux上的 netstat -i命令输出综合了多种错误，其中也包括FCS。 
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307071711746.png)

以上这套理论我一直深信不疑，没想到上周偶然抓到的一个包却差点颠覆信仰。请仔细 看图2中部的大方框，我竟然在一台普通主机上抓到了一个帧检验序列（FCS）错误。 既然FCS有错，表示帧已经损坏了，为什么没被网卡丢弃呢？还有一点很奇怪的，就是 在那些没有损坏的帧里并没有看到FCS信息（截屏就不贴出来了）。既然要显示就全部 显示，为什么只显示出错的FCS呢？ 
图2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307071713284.png)

这个现象已经诡异到不能用现成的理论来解释了，难道是Wireshark的误报吗？我仔细 观察了图2方框内的几个值，发现还真的是：在UDP层看到的长度为28字节，算上IP头 就是28+20=48字节，再算上帧头就是48+14=62字节。怎么可能抓到74字节呢？多出来 的这12字节无法解释来源。我只能猜测这台主机出了问题，把其他帧里的12字节算到这个帧里了。因此Wireshark才会在帧尾看到一些多余的字节，就错误地当作FCS显示出 来了。

假如这个猜测是对的，那应该还能看到一些帧是有缺失字节的。 没想到真的有，请看图3的351号包。“UDP Length：40”表明UDP层应该携带40-8 （UDP头）=32字节才对，但图3底部的UDP层却只携带了20字节的数据，说明有12个 字节莫名其妙地丢失了。我没有证据表明这12个字节一定就是图2多出来的那些，但很 可能就是。由于这些字节的“漂移”，导致这两个包也是异常的，所以是个大问题。后来 客户更换了IO模块，问题就消失了。
图3 
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307071714282.png)

Wireshark就是这么神奇。虽然它也有犯错的时候，但是由于包里方方面面的信息都能 呈现出来，所以我们可以进行各种推理，从而判断出真正的问题所在。==**每一次推理都是 对网络基础知识的复习过程，非常有价值**==。
