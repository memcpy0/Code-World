服务器作为互联网上极为重要的一个环节，提供了网络用户所需要的各种资源，例如文件、数据库、视频等。虽然结构上与普通的 PC 机相同，但是服务器的目的是为了对外提供服务。为了保证服务器能够提供高可靠的服务，在处理能力和稳定性方面都有较高的要求。常见的服务器包括网页服务器、文件服务器、域名服务器和代理服务器等。**由于服务器的重要性，它往往更容易成为攻击者的目标**。

来研究一些针对各种服务器的攻击技术。首先来介绍一种最为典型的攻击技术：**拒绝服务攻击**。这种技术由来已久，在大概 10 多年前的时候，曾经有一条关
于服务器攻击的新闻轰动一时。当时正是我刚刚涉足网络安全这个领域的时候，很巧的是这个发起攻击的黑客和我都在同一个城市。当时的新闻是这样报道这一案件的，“从 2004年 10 月起，北京一家音乐网站连续 3 个月遭到一个‘僵尸网络’的‘拒绝服务’攻击，造成经济损失达 700 余万元。日前，经公安部、省公安厅和唐山警方的努力，隐藏在唐山的神秘黑客浮出水面。”

在这一章中，我们将会就“拒绝服务攻击”进行讲解，并将在 Wireshark 的帮助下一层层地揭开它神秘的面纱。本章将围绕以下主题进行讲解和学习：
- 拒绝服务攻击的相关理论；
- 使用 Hping 发起 SYN flooding 攻击；
- Wireshark 的流量图功能；
- SYN flooding 攻击解决方案。
 
## 12.1 拒绝服务攻击的相关理论
**服务器所面临的最大威胁当数拒绝服务攻击**，拒绝服务攻击其实是**一类攻击**的合称。所有这种类型的攻击的目的都是相同的，那就是要是**使受攻击的服务器系统瘫痪或服务失效**，从而使合法用户无法得到相应的资源。

虽然服务器的功能多种多样，但是这些差异都是表现在应用层，无论它们使用的是什么应用程序，但最终都会使用到传输层的协议。而传输层常用的协议只有 TCP 和 UDP 两种。因此==攻击者只需要研究这两个协议的缺陷，就几乎可以实现对所有类型服务器的攻击==。

目前已经出现了很多种类型的拒绝服务攻击方式，我们只挑选其中最为典型的两种 SYN flooding 攻击和 UDP flooding 攻击进行讲解。其中 **SYN flooding 攻击是针对 TCP 协议的**，它的主要目的是**占用目标上所有可用的连接请求**。而 UDP flooding 攻击则是针对 UDP 协议的，主要目的是**耗尽目标所在网络的带宽**。

### 12.1.1 TCP 连接的建立方式
**TCP 协议在进行通信之前需要先建立连接**，例如一个客户机和一个服务器之间在发送实际的数据之前，**会互相向对方发送控制数据包**。这个过程使得客户机和服务器都进入连接状态，然后就可以进行数据交换了，我们称其为 3 次握手。握手过程一旦完成，客户机和服务器之间就建立好了一个连接，因此我们在描述 TCP 协议时会说这是一个面向连接的协议。

但需要注意，==这个连接仅仅对于这两个客户机和服务器才有效，而在网络中负责将这些数据进行转发的路由器，甚至完全不知道这个连接的存在==。通常客户端需要 3 次握手才能和服务端建立一个 TCP 连接，这个过程如图 1 所示。
图 1 TCP 的 3 次握手过程
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190035875.png)
3 次握手的第 1 次握手由客户端发起，客户端产生一个 SYN 数据包并将其发送给服务端。在这个 SYN 数据包中，客户端完成了如下的工作。
1．第 1 次握手
（1）客户端产生一个初始序列号（ISN），但在默认情况下，Wireshark 中不会显示序列号的真实值，而是显示一个 3 次握手的相对值，例如图 2 中的“Sequence number：0”。
图 2 客户端产生相对初始序列号(ISN)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190037748.png)
很多时候这个相对值并不利于分析问题，不过我们可以修改这个设置，方法是依次单击菜单栏上的“编辑”→“首选项”，然后在弹出的首选项窗口左面一栏中依次选中“Protocols”→“TCP”，然后取消右侧“Relative sequence numbers”的勾选（见图 3）。
图 3 在首选项中修改相对初始序列号(ISN)
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190037461.png)
转换之后就可以看到初始序列号的真实值，如图 4 所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190038897.png)
图 4 显示的真实初始序列号(ISN)
（2）客户端将要发送的数据包中的 **tcp.flags.syn 位设置为 1**。
（3）客户端将要发送的数据包中 **tcp.flags 的其他位（tcp.flags.ack）设置为 0**。
（4）客户端将设置**要发送的数据包中 tcp.window_size 的值，其目的是向服务端提供自己当前缓冲区的大小**，这里的值为 `tcp.window_size_value == 65535` ，TCP 最大片段大小 (MSS) 为 1440，表示客户端可以**接受** 65535/1440=45 个数据包。
（5）客户端会根据实际设置 tcp.options，例如最大片段大小(MSS)、No-Operation (NOP)、**window scale**、timestamps 和 **SACK permitted 等值**
然后客户端将设置好的数据包发送给服务端。

2．第 2 次握手
当服务端收到了来自客户端的请求之后，**如果同意建立连接的话**，就会按照如下设置进行应答。
（1）服务端产生一个 ISN 值，将==要发送的数据包中 tcp.seq 的值设置为这个 ISN 值==。
（2）服务端**将接收到的数据包中的初始序列号加 1**，然后将这个值赋值给**要发送的数据包中的 tcp.ack 位**。
（3）服务端将**要发送的数据包中 tcp.window_size_value 的值设置为 8192**。
（4）==将要发送的数据包中的 tcp.flags.syn 和 tcp.flags.ack 的值都设置为 1==。
（5）设置要发送的数据包中的 tcp.options 的值来回应客户端。
接下来，服务器会将这个设置完毕的数据包发送给客户端。

3．第 3 次握手
现在客户端已经与服务端**成功的交换了信息**，两者可以建立 TCP 连接了。
（1）客户端将收到服务器发来的数据包中的 ISN 的值加 1 之后，赋值给要发送的数据包中 tcp.seq=3613047130，将收到的数据包中的 tcp.seq 加 1 之后，赋值给要发送的数据包中 tcp.ack=2581725270。
（2）客户端设置**要发送的数据包中 tcp.flags.ack == 1**。
（3）客户端会**再次发送窗口大小的值**，设置要发送的数据包中 tcp.window_size_value 。
最后客户端将这个设置好的数据包发送到服务端。现在我们已经了解了 TCP 3 次握手的建立过程了，接下来就来了解攻击者是如何利用它的。
### 12.1.2 SYN flooding 攻击
这种攻击最早出现于 1996 年，当时大量的网站服务器都遭受到了这种 SYN flooding 攻击。这种攻击利用了 TCP 连接的 3 次握手，但这个握手过程是建立在理想状态下的，而==在实际状态下当服务器收到了来自客户端发送的 SYN 请求之后，会发出一个 SYN-ACK 回应，是连接进入到了半开状态==，但这个回应很有可能会因为网络问题无法达到客户端。

所以此时需要给这个半开的连接设置一个计时器，==如果计时完成了还没有收到客户端的 ACK 回应，就会重新发送 SYN-ACK 消息，直到超过一定次数之后才会释放连接==。服务器需要为每一个半开连接分配一定的系统资源，所以**当出现数量众多的半开连接时，服务器就会因为资源耗尽，进而停止对所有连接请求的响应**。

所以攻击者可以向服务器发送大量的 SYN 请求但不响应 SYN-ACK 回应，甚至**直接伪造 SYN 请求的源地址**，这样服务器发回的 SYN-ACK 回应也不会得到任何的回应。这就是 SYN flooding 攻击。而==这种攻击技术实现起来十分简单，只需要构造带有 SYN 请求的数据包发往目标服务器即可==。
## 12.2 模拟 SYN flooding 攻击
### 12.2.1 构造一个仿真环境
如图 5 所示，我们在这次实验中需要使用两个虚拟机，一个是 Kali Linux 2，另一
个是 Windows 2003，考虑到这次试验要消耗大量的系统资源，所以这个实验中我们不使用 ENSP，而是在 VMware 中载入两台设备。即便如此，在使用虚拟设备时，由于产生的数据包数量众多，Wireshark 也经常会出现假死状态。
图 5 实验中需要的虚拟机
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190109942.png)
这里面我们将 Kali Linux 2 和 Windows 2003 的网络连接方式都设置为 NAT，IP 获取方式都设为自动获取 IP（DHCP 分配），在本次实验中，其中 Kali Linux 2 分配的地址为192.168.32.129，而 Windows 2003 被分配的地址为 192.168.32.132。
### 12.2.2 使用 Hping3 发起 SYN flooding 攻击
这次我们采用 **Kali Linux 2 中自带的 hping3 来进行一次拒绝服务攻击**。这是一款用于生成和解析 TCP/IP 协议数据包的开源工具，之前推出过 hping 和 hping2 两个版本，目前最新的版本是 hping3。利用这款工具我们可以快速定制数据包的各个部分，hping3 也是一个命令式的工具，其中的各种功能要依靠设置参数来实现。**启动 hping3 的方式就是在 Kali Linux2 中启动一个终端，然后输入“hping3”即可**：
```js
root@kali:~# hping3
hping3>
```
鉴于 hping3 的参数数目众多，我们可以参考这个工具的帮助文件，参看帮助的方法是在终端中启动输入“hping3 --help”，因为这个帮助较长，所以我们这里只讲述与 TCP 协议相关的部分。

下面给出了 hping3 中关于 TCP 和 UDP 部分的帮助：
UDP/TCP 模式
```bash
-s --baseport base source port (default random)
// 缺省随机源端口
-p --destport [+][+]<port> destination port(default 0) ctrl+z inc/dec
// 缺省随机源端口
-k --keep keep still source port // 保持源端口
-w --win winsize (default 64) // win 的滑动窗口。windows 发
送字节(默认 64)
-O --tcpoff set fake tcp data offset (instead of tcphdrlen / 4)
// 设置伪造 tcp 数据偏移量(取代 tcp 地址长度除以 4)
-Q --seqnum shows only tcp sequence number // 仅显示 tcp 序列号
-b --badcksum (尝试)发送具有错误 IP 校验和数据包。许多系统将修复发送数据包的 IP校验和。所以你会得到错误 UDP/TCP 校验和。
-M --setseq 设置 TCP 序列号
-L --setack 设置 TCP 的 ack ------------ (不是 TCP 的 ACK 标志位)
-F --fin set FIN flag
-S --syn set SYN flag
-R --rst set RST flag
-P --push set PUSH flag
-A --ack set ACK flag ------------ （设置 TCP 的 ACK 标志 位）
异步社区云云云(18169257213) 专享 请尊重版权
12.3 使用 Wireshark 的流向图功能来分析 SYN flooding 攻击 175
-U --urg set URG flag // 一大堆 IP 包头的设置
-X --xmas set X unused flag (0x40)
-Y --ymas set Y unused flag (0x80)
--tcpexitcode 使用 last tcp-> th_flags 作为退出码
--tcp-mss 启用具有给定值的 TCP MSS 选项
--tcp-timestamp 启用 TCP 时间戳选项来猜测 HZ/uptime
```
这种攻击方式中，攻击方会向目标端口发送**大量设置了 SYN 标志位的 TCP 数据包**，受攻击的服务器会根据这些数据包建立连接，并将连接的信息存储在连接表中，而攻击方不断地发送 SYN 数据包，很快就会将连接表填满，此时受攻击的服务器就无法接收新来的连接请求了。

好了，现在我们就利用刚刚介绍过的 hping3 参数来构造一次基于 TCP 协议的拒绝服务攻击。在 Kali Linux 2 中打开一个终端，然后在终端中输入：
```js
hping3 -q -n --rand-source -S -p 80 --flood 192.168.32.132
```
这时攻击就开始了，在这个过程中你可以随时使用 Ctrl+C 组合键来结束这次攻击。
## 12.3 使用 Wireshark 的流向图功能来分析 SYN flooding 攻击
使用 Wireshark 将捕获到的数据包打开并进行分析。这个数据文件中捕获到的数据包跟前面提到的几种泛洪攻击有相同的地方，都是间隔时间短，发送数量大。所以也可以使用第 9 章讲过的统计功能来分析这个攻击。不过这次我们考虑使用 Wireshark 的另一个功能：流向图（flow graph）。

首先查看这种来自同一个地址的 SYN flooding 攻击，使用 Wireshark 捕获这些伪造的请求。如果想要更好地了解网络中发生了什么，可以绘制出 TCP 端点之间的数据流，那一切就更直接明了。Wireshark 中提供了一个 TCP 流向图，这是它的一个相当强大的功能。

现在可看到网络中有大量来自 1.1.1.1 与服务器 192.168.32.132 之间的通信。我们来看看这一切在流向图中是如何显示的。使用流向图的步骤如下所示。
（1）在 Wireshark 中打开刚刚捕获的数据包。
（2）单击菜单“统计”下的“流向图（flow graph）”菜单项，就会弹出 Wireshark 流向图。在这个 Wireshark 流向图中**有若干选项可以使用**，下面是这些选项的作用。
- “显示过滤器的限制”单选框，Wireshark 会根据抓包文件中经过显示过滤器过滤的数据包来生成流向图。
- “流类型”下拉列表框，这里面包含“ALL Flows”“ICMP Flows”“ICMPv6 Flows”
“TCP FLows”“UIM Flows”。其中的“ALL Flows”会**针对抓包文件中的所有数据
包**或者**经过显示过滤器过滤的数据包**来生成总体的流向图。而“TCP FLows”针对**抓包文件中的所有数据包**或者**所有经过显示过滤器过滤的数据包**，来生成包含 TCP标记、序列号、ACK 号以及报文段长度的 TCP 流向图。

现在我们看到的就是将网络通信以流向图的方式展现出来，在图 6 中给出了 1.1.1.1 和 192.168.32.132 之间的所有通信。
图 6 Wireshark 中的流向图
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190112626.png)
我们可以看到在图 6 中 1.1.1.1 向 192.168.32.132 发送了大量的 SYN 请求，但却没有任何的下一步行动。==不过如果攻击者在攻击时伪造了随机源地址，此时如果再使用流向图进行查看的话，同样可以看到大量的地址只向服务器发送了一个 SYN 请求==。在流向图中可以看到两点，**一是短时间出现了大量的数据包，二是这些数据包并没有后续**，如图 7 所示。
图 7 Wireshark 中的多地址流向图
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190112298.png)
需要注意的是，如果攻击者伪造了大量的源地址，这种情况下在数据流图中显示的信息起来就会很难理解。尤其是因为里面出现的大量地址，导致这个图的横轴变得十分长。
所以这种情况我们可以优先考虑使用**前面统计功能中端点对话**（见图 8）。
图 8 统计功能中端点对话
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190112856.png)

在这个端点会话的 IPv4 标签中，**可以看到大量的 IP 地址都只发送了一个数据包**。在实际的网络通信中，这显然是不正常的。
## 12.4 如何解决 SYN Flooding 拒绝服务攻击
根据我们之前的分析可以看出来，这种攻击的特点就是会发送一个 SYN 数据包，之后就没有其他行为了。为此我们研究出如下的几种方案，当前防护 SYN Flooding 的手段主要有 3 种。
（1）**丢弃第一个 SYN 数据包**：这种方法最为简单，就是当服务器对收到 SYN 数据包的地址进行记录，丢弃从某个 IP 地址发来的第一个 SYN 数据包。因为攻击者在进行攻击时，往往只会发送一个 SYN 数据包之后就没有后续动作了，而如果这个 IP 地址真的希望和服务器建立连接的话，一定会再次发送 SYN 数据包过来。但是这样做的缺陷也很明显，由于每次都需要发送两次 SYN 数据包才能建立连接，从而导致用户的体验非常差。
（2）**反向探测**：这种方法就是向 SYN 数据包的源地址**发送探测包**，然后再根据源地址的反应来判断数据包的合法性。
（3）**代理模式**：就是把防火墙作为代理，然后由防火墙代替服务器和客户机建立连接。**当双向连接建立成功之后，再进行数据的转发**。这样一来就可以拦截企图要发起 SYN Flooding 攻击的客户机。
## 12.5 在 Wireshark 中显示地理位置
前面介绍了拒绝服务攻击（DoS），这种攻击的发起端通常是一台设备。现在黑客设计了一种更高级的攻击方法：分布式拒绝服务攻击（Distributed Denial of Service，DDoS），==这种攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动 DDoS 攻击，从而成倍地提高拒绝服务攻击的威力==。相比起拒绝服务攻击来说，分布式拒绝服务攻击（DDoS）更加难以防御，这是因为发起攻击的源头往往来自于世界各地，图 9 给出了 2016 年 10 月 21 日美国 Dyn 公司遭受 3 波“分布式拒绝服务”攻击时的来源分布图。
图 9 “分布式拒绝服务”（DDoS）攻击时的来源分布
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190114028.png)
这个图看起来是不是很酷？其实我们在 Wireshark 中也可以实现类似的功能，虽然**默认版本中并不能显示数据包的来源地址和目的地址**，但是这一点可以通过插件实现。

在 Wireshark 首选项中，我们可以对 IP 协议的一些功能进行调整（见图 10）。
图 10 IP 协议的一些功能
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190114835.png)
“Enable GeoIP Lookups”表示显示数据包的地理位置，这个功能其实是通过 IP 地址转换得来的。首先并不是所有的 Wireshark 版本都支持这个功能，我们可以在“帮助”→“关于 Wireshark”中来查看其是否支持显示地址位置。**如果如图 11 所示包含了“with GeoIP” 字段，就表示当前版本具备这个功能**。
图 11 查看 Wireshark 是否支持显示数据包的地理位置
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190114372.png)
2.6 版本之后的 Wireshark 和之前的版本发生一定了变化，因此设置开始不同。但是 IP 地址和地理位置的对应关系仍然需要数据库文件的支持，目前 maxmind 公司提供了一个比较优秀的 IP 对应地理位置的数据库。如图 12 所示，你可以在 maxmind 网站下载一个免费的数据库。
图 12 maxmind 公司提供的 IP 对应地理位置的数据库
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190115360.png)
这个页面提供了 binary 和 csv 两种不同格式，这里面我们选择 csv 格式，并需要将 3 个数据库下载到本地并解压。
图 13 下载 MaxMind 数据库
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190115625.png)
图 14 下载的 3 个文件
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190115490.png)
使用解压缩工具将这 3 个文件进行解压，之后会得到 3 个文件夹，每个文件夹中包含一个.mmdb 类型的数据库文件。启动 wireshark 图形化界面，单击菜单栏上的“帮助”→“关于”，然后再选择“文件夹”（Folders）选项卡，找到如图 15 所示的 Personal configuration 文件夹。
图 15 Personal configuration 文件夹
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190115010.png)
然后单击 Personal configuration，点击这个链接将会打开一个目录，如图 16 所示。
图 16 打开的 Personal configuration 文件夹
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190116983.png)
如图 17 所示，在这个目录中新创建一个名为 GeoIPdb 的文件夹。
图 17 新创建的 GeoIPdb 文件夹
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190116104.png)
如图 18 所示，将刚才下载并解压缩的 3 个文件复制到新建立的 GeoIPdb 文件夹中。
图 18 将下载的文件复制到 GeoIPdb 文件夹
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190116580.png)
如图 19 所示，在 Wireshark 中依次单击“编辑”→“首选项”→“Name Resolution”，
然后单击“GeoIP database directories”后面的“Eidt”按钮。
图 19 在 Wireshark 中设置地理位置的解析
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190116009.png)
在这个对话框中单击“+”按钮，然后在弹出的 Windows 文件对话框中选中 IP 对应地理位置的数据库所在的目录。
图 20 在 Wireshark 中设置地理位置数据库的位置
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190117521.png)
现在我们选择一个数据包，然后打开其中的 IP 协议层，你将会看到多了一个解析信息，图 21 **显示了数据包的来源地理地址和目的地理地址**。
图 21 在 IP 层显示的地理位置
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190117050.png)
## 12.6 小结
我们介绍了针对服务器的攻击方式——SYN Flooding 攻击，**这种攻击方式是建立在传输层的 TCP 协议上的**。本章我们首先介绍了 TCP 协议连接的建立过程，这个过程平时也称为 3 次握手，而 **SYN Flooding 攻击就是向目标服务器发送大量的 SYN 握手请求**。然后我们在 Kali Linux2 平台中演示了如何进行这种攻击，同时也使用 Wireshark 的流向图对这种攻击进行了分析。还介绍了如何在 Wireshark 添加一个显示地理位置的插件，这个功能在分析分布式拒绝服务攻击时是相当有用的。

通过实例讲解了 TCP 协议中连接的建立和数据的传输。从这开始我们将要介绍传输层的另一个协议——UDP。虽然与 TCP 一样位于传输层，==UDP 协议却不需要建立连接就可以传输数据，而且少了很多的控制机制，因而传输速度高于 TCP
协议，所以也得到了广泛的使用==。

不过，UDP 协议也面临着一个和 TCP 协议一样的威胁，那就是泛洪攻击。不过**不同于 TCP 协议占用服务器连接数的方式**，UDP 协议因为不需要建立连接，所以**攻击者将目标转向了带宽**，==他们构造大量体积巨大的 UDP 数据包并发往目标，从而导致目标网络的瘫痪==。

由于依赖 UDP 的应用层协议五花八门，差异极大，因此**针对 UDP Flooding 的防护非常困难**。会在 Wireshark 中绘图功能的帮助下来分析 UDP Flooding 攻击。涉及的主要内容如下：
- UDP Flooding 的相关理论；
- 模拟 UDP Flooding 攻击；
- Wireshark 中的绘图功能；
- 绘制专业的图表。

## 14.1 UDP Flooding 的相关理论
### 14.1.1 UDP 协议
UDP 是一个设计极为简洁的协议，**控制选项较少**，因此在数据传输过程中延迟小、**数据传输效率高**，这也是当前最为热门的通信工具 QQ 选用了 UDP 作为传输层协议的重要原因。
图 14-1 中给出了一个数据包在传输层使用 UDP 协议封装时所添加的内容，其中最为重要的信息就是应用程序使用的端口。
图 14-1 在 Wireshark 中显示的 UDP 协议封装
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190901823.png)
这里面添加的传输层的内容主要包括源端口、目的端口、长度和校验码 4 个部分。
① Source Port 表示这个数据包的源端口，大小为 2 字节，当不需要对方回应时，可以全部为 0。
② Destination Port 表示目的端口号，大小为 2 字节。
③ Length 表示长度，大小为 2 字节，表示 UDP 报文的长度。
④ Checksum 表示校验码，接收方以此来判断传输中是否有错。
这里需要注意的是，==通常两个互相通信的程序所使用的端口号往往是不同的。如果数据包的源主机是服务器，则所使用的源端口往往要遵循标准（例如，HTTP 就使用 80 端口）==。

例如图 14-1 中就指出了这个数据包源端口是 4025，访问的服务器目标端口为 8000。
### 14.1.2 UDP Flooding 攻击
UDP 是一个无连接的传输层协议，所以在数据传输过程，不需要建立连接和进行认证。==攻击者只需要向目标发送大量巨大的 UDP 数据包，就会使目标所在的网络资源被耗尽==。

UDP Flooding 是一种传统的攻击方式，近年来黑客经过精心设计，又创造了新的攻击方法。就在 2018 年的 2 月 28 日，Memcache 服务器被曝出存在 **UDP 反射放大攻击漏洞**。

攻击者可利用这个漏洞来发起大规模的 DDoS 攻击，从而影响网络正常运行。漏洞的形成原因为 Memcache 服务器的 UDP 协议支持的方式不安全，默认配置中将 UDP 端口暴露给外部链接。攻击者向端口 11211 上的 Memcache 服务器发送小字节请求，但 UDP 协议并未正确执行，因此 Memcache 服务器并未以类似或更小的数据包予以响应，而是==以有时候比原始请求大数千倍的数据包予以响应。由于数据包的原始 IP 地址能轻易被欺骗，也就是说攻击者能诱骗 Memcache 服务器将过大规模的响应数据包发送给另外一个 IP 地址==即
DDoS 攻击的受害者的 IP 地址。这种类型的 DDoS 攻击被称为“反射型 DDoS”或“反射 DDoS”，响应数据包被放大的倍数被称为 DDoS 攻击的“放大系数”。

所有放大攻击背后的想法都是一样的。攻击者使用源 IP 欺骗的方法向有漏洞的 UDP服务器发送伪造请求。==UDP 服务器不知道请求是伪造的，于是礼貌地准备响应。当成千上万的响应被传递给一个不知情的目标主机时，这个攻击问题就会发生==。
## 14.2 模拟 UDP Flooding 攻击
虽然传统的UDP Flooding 已经很少在实际中遇到，但是这种攻击方式的原理值得研究，所以本节我们以这种攻击方式进行研究。

考虑到这次实验要消耗大量的系统资源，所以这个实验中我们不使用 ENSP。在这次试验中我们需要使用两个虚拟机，一个是 Kali Linux 2，另一个是 Windows 2003，这两个系统的设置和11 章相同即可。即便如此，在使用虚拟设备时，由于产生的数据包数量众多，而且十分巨大，Wireshark 也经常会出现假死状态。
图 2 实验中需要的虚拟机
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190905318.png)
这次我们采用 Kali Linux 2 中自带的 Hping3 来进行一次拒绝服务攻击。在第 12 章中我们对这个工具的简单用法进行了讲解。现在我们就==利用刚刚介绍过的 hping3 参数来构造一次基于 UDP 协议的拒绝服务攻击==，在 Kali Linux 2 中打开一个终端，然后在终端中输入：
```
hping3 -q -n -a 10.0.0.1 --udp -s 53 -p 68 --flood 192.168.1.102 -d 1000
```
现在攻击就开始了，在这个过程中可以随时使用 Ctrl+C 组合键来结束，在攻击的同时我们使用 Wireshark 捕获这个过程产生的数据包。
## 14.3 使用 Wireshark 的绘图功能来分析 UDP Flooding 攻击
我们将使用 Wireshark 将捕获到的数据包打开并进行分析，这个数据文件中捕获到的数据包（见图 14-3）跟前面的几种泛洪攻击有相同的地方，都是间隔时间短，发送数量大。所以也可以使用前面的统计功能来分析这个攻击。
图 14-3 使用 Wireshark 捕获到的数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190906134.png)
在这个文件中，攻击者只将自己的地址伪装成 1.1.1.1，因而我们能很容易地找出攻击的数据包。但这里面有一点需要注意的是，**这些攻击的数据包除了使用 UDP 协议之外，还在应用层使用 DNS 协议**。这是为什么呢？我们可以在数据包列表面板中点击一个数据包，查看里面的详细信息（见图 14-4）。
图 14-4 使用 Wireshark 查看数据包的 Queries 部分
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190906830.png)
点击打开数据包之后，我们现在可以看到这个数据包的 UDP 协议的头部分显示了这个数据包的源端口为 53，目的端口为 68。值得注意的是，在这个数据包中的 DNS 部分包含了大量的数据，这里面的 Queries 里面本来是用来实现域名查询的，但这里面显示的信息却是没有任何意义的。我们在图 14-5 中的数据包细节面板中再查看一下详细信息。
图 14-5 使用 Wireshark 查看数据包的数据部分
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190908758.png)
从图 14-5 中我们看到每个数据包的数据部分都是大量的“58”，攻击者这样做的目的是什么呢？

现在我们使用 Wireshark 中提供的绘图功能来直观地查看这些数据包对网络造成了什么影响。Wireshark 中提供的绘图功能可以用更直观的形式展示数据包的数量。我们利用菜单栏上的“统计（statistics）”→“IO 图表（IO graph）”选项来生成一个图表，打开的“IO图表”对话框如图 14-6 所示。
图 14-6 Wireshark 中的绘图功能
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190908610.png)
这个图形的横轴表示时间，现在纵轴表示的是所有的数据包。我们可以重新定义纵轴的值，例如我们来创建一个显示 UDP 和 TCP 重传数据包数量的图形。显示数据包需要使用到系列，首先添加 UDP 系列，纵轴的值表示在某一时间点捕获到的 UDP 数据包的数量。
（1）选中当前图标中所有分组，然后单击左下方的“−”，删除掉原有的系列（见图 7）。
图 7 删除掉原有的系列
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190908043.png)
（2）如图 14-8 所示，单击左下角“+”，就可以添加一个新的系列，添加的过程如下。
图 8 添加一个新的系列
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190909973.png)
（3）在“Graph Name”名称处为序列添加一个名字“UDP”。
（4）在“Display Filter”显示过滤器中添加一个符合过滤器规则的字符串，本例中是“udp”。
（5）如图 14-9 所示，在“Color”处为生成折线选择颜色，这里我们选择红色。
图 9 为生成折线选择颜色
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190909445.png)
（6）在“Style”选择样式，我们默认使用 Line，Wireshark 中支持的绘图形式如图 10 所示。
图 14-10 Wireshark 中支持的图表形式
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190909681.png)
这里面样式的含义如下所示。
- line：折线图。
- Impulse：脉冲图。
- bar：柱形图。
- stacked bar：堆积柱形图。
- dot：点图。
- square：方块图。
- diamond：钻石图。

其实 dot、square、diamond 的表现形式几乎是相同的，只不过表示数据点的时候，dot用的是圆点，square 用的是方块，而 diamond 用的菱形。
（7）选择序列的意义。例如“Packets”是表示数据包的数量，Bytes 和 Bits 分别使用字节和位来表示捕获到数据包的数量。另外这里面还有其他几个函数，分别是 sum()、count()、max()、min()和 avg()，这些函数需要和后面的 y 字段一起才能起作用（见图 11）。
图 11 选择系列的意义
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190911195.png)
- SUM( )：这是一个实现求和的函数。
- count( )：用来表示在时间间隔内出现的次数。
- MIN( )：用来表示在时间间隔内出现的最小值。
- AVG( )：用来表示在时间间隔内出现的平均值。
- MAX( )：用来表示在时间间隔内出现的最大值。

这里面我们选择“Bytes”，也就是产生数据包的大小。
（8）选择时间间隔，这个值也是横轴的刻度，如图 12 所示。
图 12 选择时间间隔
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190911720.png)
（9）如图 13 所示，当要在这个图形中显示这个序列时，可以选中名称列前面的多选框“Enabled”。
图 13 选中名称列前面的多选框“Enabled”
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190911636.png)
（10）这时可以观察到生成的图表如图 14-14 所示。
（11）“Save as”可以将这个图形保存成各种常见格式的文件，例如 pdf 或者 bmp 等。现在，在生成的图表中，我们直接就看到了这个从第 10 秒开始一直到第 40 秒的时候，网络中被占用的带宽迅速达到了高峰期，大概在第 18 秒的时候，达到了每秒 4.8×107 Bytes，也就是 480 兆 Bytes 每秒。如果长时间保持这种情形的话，网络设备将无暇处理其他流量，并最终导致网络瘫痪。另外这种攻击也会导致依靠会话转发的网络设备性能降低甚至会话耗尽。
图 14 生成的图表
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190915273.png)
## 14.4 如何防御 UDP Flooding 攻击
目前，==防火墙是防御 UDP Flooding 的主要设备==，而它主要采用限流和指纹学习两种方式来实现防御。限流方式简单直接，就是设法将链路中的 UDP 报文控制在合理的带宽范围内。通常的控制方式主要有以下几种。
- **基于目的 IP 地址的限流**，例如在 14.3 节中，我们就可以对去往“192.168.1.102”的 UDP 数据包进行统计并限流（见图 14-15），如果超过了指定值，则将后来的 UDP 报文丢弃。
    图 15 统计到达目的地址的 UDP 数据包
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190916967.png)

- **基于目的安全区域的限流**，即以某个安全区域作为统计对象，对到达这个安全区域的 UDP 流量进行统计并限流，超过部分丢弃。而安全区域（Security Zone），也称为区域（Zone），是一个逻辑概念，==用于管理防火墙设备上安全需求相同的多个接口，也就是说它是一个或多个接口的集合==。
- **基于会话的限流**，即对每条 UDP 会话上的报文速率进行统计，如果会话上的 UDP 报文速率达到了告警阈值，这条会话就会被锁定，后续命中这条会话的 UDP 报文都被丢弃。当这条会话连续 3 秒或者 3 秒以上没有流量时，防火墙会解锁该会话，后续命中该会话的报文可以继续通过。

除了这种简单粗暴的限流机制之外，在华为公司编写的《华为防火墙技术漫谈》中还提到了另一种更有建设性的思路：指纹学习。==指纹学习是通过分析 UDP 报文中的数据内容来判断它是否异常==。防火墙首先会对发往某个服务器的 UDP 报文进行统计，当达到指定阈值时，就会开始进行指纹学习。如果这些报文携带的数据具有相同特征，就会被学习成指纹。后续的报文如果具有与此指纹相匹配的特征就会被当成攻击报文而丢弃。

例如，我们之前使用 Hping3 所构造的 UDP Flooding 报文，就都拥有相同的数据部分。随意打开任何一个 UDP 报文都可以看到如图 14-16 所示的内容。
图 16 查询 UDP 数据包中的指纹
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190917593.png)
从这些数据包中，我们就可以将数据部分的这些连续的“58”作为指纹提取出来。相比起限流方式，这种方法更为完善。目前，==指纹学习功能是针对 UDPFlooding 攻击的主流防御手段==，在华为防火墙产品中得到了广泛应用。
## 14.5 amCharts 的图表功能
Wireshark 中自带的图表功能虽然很强大，但看起来并不美观，这里我们使用一个在线的工具 amCharts 来帮助生成美观的图表，这是一个十分专业的图表生成工具。如果你希望在测试报告中使用图表的话，那么 amCharts 是一个相当不错的选择。

这里我们使用另外一个数据文件“http& TCP”来生成图表，这个数据文件中包含 HTTP 和 TCP 重传类型的数据包。我们首先将在 Wireshark 中生成图表的数据导出，这个过程很简单，只需要在生成图表右下方的“复制”按钮（见图 17）。
图 17 复制图表中的数据
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190917032.png)
使用这些数据在 amCharts 生成图表的过程如下所示。
（1）如图 14-18 所示，访问在线网址 live.amcharts.com，选择其中的“Make a Chart”。
图 18 选中其中的“Make a Chart”
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190919010.png)
（2）选中要创建图表的类型，这里面我们选择线形图（Line）（见图 14-19）。
图 19 选中要创建图表的类型
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190919010.png)
（3）图 14-20 给出图表的操作界面，这个界面一共分成左、中、右 3 个部分。
图 20 图表的操作界面
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190920020.png)
（4）如图 14-21 所示，通过 Delete column 删除掉数据区域的所有数据。
图 21 删除掉原有数据
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190920572.png)
（5）全部删除之后，选中右侧的 Import 按钮，并将从 Wireshark 复制来的数据粘贴进去，单击“Import”（见图 22）。
图 22 导入新数据
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190920561.png)
（6）在“Import Data”中选中“Finished”。
（7）依次选中“General Settings”→“Category field”，然后选中其中的“Interval start”。
图 23 选择行数据
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190920597.png)
（8）接下来在左侧选中 Graphs，然后选中其中的 AmGraph-1，将其中的 Title 选项更改为 HTTP。
（9）选中中间的“DATA FIELDS”，然后在移动到“Value Field”中选中 HTTP（见图 24）。
图 24 将 HTTP 的值作为系列
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190921433.png)
（10）可以看到右侧显示了 HTTP 的图表，如图 25 所示。
图 25 添加了 HTTP 系列生成的图表
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190921295.png)
（11）按照步骤 8 中的方法再选中 AhGraph-2，然后将 Title 设置为 “TCP Retransmissions”，然后选中中间的“DATA FIELDS”，然后再移动到“Value Field”中选中 Retransmissions。最后生成的图表如图 26 所示。
图 26 添加了 HTTP 系列和重传系列的图表
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190921472.png)

（12）最后，你可以在 Titles 中 Title-1 的 Text 中修改图表的名称，原来为 Chart Title，我们修改为 HTTP&Retransmissions（见图 14-27）。
图 14-27 修改图表的标题
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307190922576.png)
也可以根据自己的需求将这个图表设计得更加美观。
## 14.6 小结
在这一章中重点讲解了 UDP Flooding 攻击的原理与实现方法，并使用 Wireshark中的图表功能对这种攻击的技术进行了分析。最后重点介绍了 Wireshark 中自带的图表功能以及 amCharts 的使用方法，毕竟当我们在编写工作报告时，一个美观大方的图表将会是十分重要的。
