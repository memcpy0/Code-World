就是这些最基础的问题，却常常把简历精英们难住。本文要介绍的便是其中的一道。问题：两台服务器A和B的网络配置如下（见图1），B的子网掩码本应该是255.255.255.0，被不小心配成了255.255.255.224。它们还能正常通信吗？
图1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122225735.png)
很多应聘者都会沉思良久（他们一定在心里把我骂了很多遍了），然后给出下面这些形形色色的答案。
答案1：“A和B不能通信，因为……如果这样都行的话，子网掩码还有什么用？”（这位的反证法听上去很有道理！）
答案2：“A和B能通信，因为它们可以通过ARP广播获得对方的MAC地址。”（那子网掩码还有什么用？楼上的反证法用来反驳这位正好。）
答案3：“A和B能通信，但所有包都要通过默认网关192.168.26.2转发。”（请问这么复杂的结果你是怎么想到的？）
答案4：“A和B不能通信，因为ARP不能跨子网。”（这个答案听上去真像是经过认真思考的。）

以上哪个答案是正确的？还是都不正确？如果这是你第一次听到这道题，不妨停下来思考一下。真相只有一个，应聘者的答案却是五花八门。可见对网络概念的理解不容含糊，否则差之毫厘，谬以千里。要知道，这还只是基本的路由交换知识，假如涉及复杂概念，结果就更不用说了。问题是即便我们对着教材咬文嚼字，也不一定能悟出正确答案。这个时候，==就可以借助Wireshark的抓包与分析功能了。我手头就有两台Windows服务器==，已经按照面试题配好网络。如果你以前没有用过Wireshark，就开始第一次亲密接触吧。
1.从http://www.wireshark.org/download.html免费下载安装包，并在服务器B上装好（把所有可选项都装上）。
2.启动Wireshark软件，单击菜单栏上的Capture，再单击Interfaces按钮（见图2）。
图2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122225777.png)

3.服务器B上的所有网卡都会显示在弹出的新窗口上（见图3），在要抓包的网卡上单击Start按钮。
图3
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122226291.png)

4.**在服务器B上pingA的IP地址，结果是通的**（见图4）。该操作产生的网络包已经被Wireshark捕获。
图4
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122226283.png)
5.在Wireshark的菜单栏上，再次单击Capture，然后单击Stop。
6.在Wireshark的菜单栏上，单击File，再单击Save，把网络包保存到硬盘上（这一步并非必需，但存档是个好习惯）。
7.收集每台设备的MAC地址以备分析。·服务器A:00:0c:29:0c:22:10·服务器B:00:0c:29:51:f1:7b·默认网关:00:50:56:e7:2f:88现在可以分析网络包了。如图5所示，Wireshark的界面非常直观。最上面是PacketList窗口，它列出了所有网络包。在PacketList中选定的网络包会详细地显示在中间的PacketDetails窗口中。由于我在PacketList中选定的是3号包，所以图5中看到的就是Frame3的详情。最底下是PacketBytesDetails窗口，我们一般不会用到它。
图5
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122227505.png)
接下来看看每个包都做了些什么。1号包（见图6）：
图6
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122228286.png)
服务器B通过ARP广播查询默认网关192.168.26.2的MAC地址。**为什么我ping的是服务器A的IP，B却去查询默认网关的MAC地址呢**？这是因为==B根据自己的子网掩码，计算出A属于不同子网，跨子网通信需要默认网关的转发。而要和默认网关通信，就需要获得其MAC地址==。

2号包（见图7）：
图7
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122228156.png)
默认网关192.168.26.2向B回复了自己的MAC地址。为什么这些MAC地址的开头明明是“00:50:56”或者“00:0c:29”，Wireshark上显示出来却都是“Vmware”？**这是因为MAC地址的前3个字节表示厂商。而00:50:56和00:0c:29都被分配给Vmware公司**。这是全球统一的标准，所以Wireshark干脆显示出厂商名了。

3号包（见图8）：
图8
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122229945.png)
B发出ping包，指定DestinationIP为A，即192.168.26.129。但**DestinationMAC却是默认网关的00:50:56:e7:2f:88**（Destination MAC可以在图8中的PacketDetails中看到）。这表明B希望默认网关把包转发给A。至于默认网关有没有转发，我们目前无从得知，**除非在网关上也抓个包**。

4号包（见图9）：
图9
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122230000.png)

B收到了A发出的ARP广播，这个广播查询的是B的MAC地址。这是因为==在A看来，B属于相同子网，同子网通信无需默认网关的参与，只要通过ARP获得对方MAC地址就行了==。这个包也表明**默认网关成功地把B发出的ping请求转发给A了，否则A不会无缘无故尝试和B通信**。

5号包（见图10）：
图10
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122231855.png)
B回复了A的ARP请求，把自己的MAC地址告诉A。这说明**B在执行ARP回复时并不考虑子网**。虽然ARP请求来自其他子网的IP，但也照样回复。

6号包（见图11）：
图11
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122232636.png)
B终于收到了A的ping回复。从MAC地址00:0c:29:0c:22:10可以看出，这个包是从A直接过来的，而不是通过默认网关的转发。

7、8、9、10号包（见图12）：图12都是重复的ping请求和ping回复。**因为A和B都已经知道对方的联系方式，所以就没必要再发ARP了**。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122232472.png)

分析完这几个包，答案出来了。原来通信过程是这样的：==B先把ping请求交给默认网关，默认网关再转发给A。而A收到请求后直接把ping回复给B，形成图13所示的三角形环路==。不知道你答对了吗？
图13
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307122233967.png)
通过这道题，不知道你是否已经感受到了Wireshark的神奇？如果有兴趣进一步练习，**不妨也搭个环境，把这道题里A和B的掩码互换一下。看看这次还能ping通吗**？如果不能，原因又在哪里？==其实做题对Wireshark只是大材小用，它还可以用于学习复杂的协议，或者解决隐蔽的难题==。

互换后不能ping通。因为B发出ping时，发现自己与A不在同个子网内，所以要发给默认网关，先ARP查询默认网关的MAC地址，把包发给默认网关，默认网关转发；而A也会发现自己与B不在同个子网内，它收到B的？