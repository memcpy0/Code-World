@[toc]

> 本文属于「计算机网络学习实践」系列文章之一。这一系列着重于计算机网络知识的学习与实践。由于文章内容随时可能发生更新变动，欢迎关注和收藏[计算机网络系列文章汇总目录](https://memcpy0.blog.csdn.net/article/details/119996282)一文以作备忘。此外，在本系列文章中，为了透彻理解网络知识，本人参考了诸多博客、教程、文档、书籍等资料。以下是本文的不完全参考目录，在后续学习中还会逐渐补充：
> - 图解TCP/IP 第五版，[日]竹下隆史等著，人民邮电出版社
> - Wireshark网络分析从入门到实践，李华峰、陈虹，人民邮电出版社
> - 计算机网络 第七版，谢希仁 
> - Wireshark网络分析就这么简单：TCP 的连接启蒙 到 重传的讲究
> - Wireshark网络分析从入门到实践


@[toc]

经常会在访问某个网站时，却不小心下载了木马的情形。尤其让人感到郁闷的是，下载木马的过程完全是不可见的。不过即便如此，**这个木马文件仍然需要以数据包的形式进行传输**，所以我们完全可以用 Wireshark 来检测到它。

最初设计 Wireshark 的目的是用来检查网络中的问题，不过随着使用者技能的不断娴熟，他们也发现了 Wireshark 还可以胜任更多的任务，而**网络取证**就是其中重要的一项。取证者只需要监控网络中的通信，就可以清楚地发现网络中用户的行为。例如某个用户从外网下载了什么文件，或者它通过电子邮件向外发送了什么文件等。

既然用户可能是使用各种不同的应用程序传输的文件，为什么 Wireshark 都可以对其进行解析呢，有人可能会此感到困惑。其实==这些应用程序在应用层可能使用不同的协议，但它们在传输数据时传输层采用的大多数采用的是 TCP 协议==，只不过一个完整的文件会被分割成多个数据包进行传输。这些有顺序的数据包就被称作流，而 **Wireshark 中提供了一个“流跟踪（TCP Stream）”功能**。利用这个功能，Wireshark 就可以**将捕获到所有的通信数据包重组成完整的会话或者文件**。就如下主题展开介绍：
- TCP 中的数据传输；
- Wireshark 中的 TCP 流功能；
- 网络取证实践。
# 13.1 TCP 的数据传输
我们对 TCP 连接的建立方式已经不陌生了，现在来了解一下 TCP 连接建立之后的数据传输。当客户端和服务端之间建立好连接之后，就可以通过这个连接来传递数据了。客户端和服务端可以同时通过这个连接向对方发送消息。**TCP 在进行数据的传输时提供了可靠的数据传输服务**，这一点指的是**彼此通信的应用进程可以通过 TCP 无错的顺序传递所有数据**，**中间不会有字节的丢失或重复**。但是 TCP 协议仅仅能保证全部数据传递的准确性，对传输的速度是不能保证的。

下面具体分析一下 TCP 数据传输的过程，这是一个由服务器向客户端传递数据的实例。
（1）服务器在发送的数据包中设置 **tcp.flags.push = 1，tcp.flags.ack =1**。图 1 就给出了一个设置了 tcp.flags.push 和 tcp.flags.ack 标志位的数据包实例。
图 1 设置 tcp.flags.push = 1，tcp.flags.ack =1 的数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200005872.png)
（2）服务器会**将要传输的数据添加到数据包的 Data 部分**（见图 2）。
图 2 数据包的 Data 部分
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200006169.png)
（3）服务器将这个数据包发送出去。在这个网络数据传输过程中，有用的 Wireshark 显示过滤器包括以下几个。
- data：只显示包含数据的数据包（见图 3）。
    图 3 使用 data 作为显示过滤器
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200006660.png)
- `data && ip.addr==10.0.0.221` 。
- `tcp.flags.push == 1`。
- `tcp.flags.push == 1 && ip.addr==10.0.0.221` 。
- `tcp.flags == 0x0018`：显示所有的 PSH，ACK 数据包。
- `tcp.flags == 0x0011`：显示所有的 FIN 和 ACK 数据包。
- `tcp.flags == 0x0010`：显示所有的 ACK 数据包。
## 13.2 Wireshark 中的 TCP 流功能
在上一节中已经了解了 TCP 数据包中是如何传输数据的，当我们在监测一个网络时这一点是十分有用的。如果我们需要在网络中进行取证，那么**查看这些数据的具体内容则是十分重要的**，例如一台主机向外部传输数据时，到底传输的是一张图片，还是一个木马文件呢？

下面给出在 Wireshark 中还原数据的方式，我们仍然使用 Wireshark 官方提供的样例包。首先选中数据包列表中一个任意的会话数据包，在这个数据包中单击鼠标右键，然后在弹出的菜单中依次选中“追踪流”→“TCP 流”。==这种方法在检测 TCP 流的内容时是一种绝佳的选择，它避免了我们对数据包进行逐个检查的烦琐操作==。尤其是在服务器和客户端之间出现故障的时候，使用这种方法非常有用。

如图 4 所示，Wireshark 中的 File 菜单提供了“Export Objects”功能，这个功能可以导出 HTTP 和 TCP 数据流中的文件。 
图 4 Wireshark 中的“Export Objects”功能
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200008069.png)
但这种方法经常会出现错误，造成导出的文件并不完整，因此我们再介绍另外一种方法。

我们以 http_witp_jpegs.cap 为例，在这次传输过程中由服务端向客户端传送了一个文件，这里就以还原这个文件为例。如图 5 所示，其中序号为 269 的数据包中内容如下。
图 5 选中序号为 269 的数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200008996.png)
如图 6 所示，我们在这个数据包上单击鼠标右键，然后再依次选中“追踪流”|“TCP 流”。
图 6 选中“追踪流”|“TCP 流”
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200009454.png)
==当我们对一个数据包进行“追踪流”的操作时，这时就会自动创建并应用一个显示过滤器==。图 7 就展示了一个应用了“追踪流”窗口。注意在这个数据流被选中之后创建显示过滤器的语法。
图 7 追踪数据流 
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200009902.png)

整个数据流会在一个单独的窗口中显示出来，这个窗口中的全部数据以两种颜色显示，==其中红色用来标明从源地址前往目的地址的流量，而蓝色用来区分出相反方向也就是从目的地址到源地址的流量==。通常连接是由客户端主动发起的，因此显示的颜色为红色，如图 8 所示。
图 8 整个数据流的内容
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200010630.png)
我们需要过滤掉其中的 GET 请求，具体方法是单击左侧的下拉列表框，然后选中 “10.1.1.1-10.1.1.101”（见图 9）。
图 9 选择单向数据流
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200010086.png)
然后在右侧的“显示和保存数据为”后选择“原始数据”（见图 10）。
图 10 显示和保存为“原始数据”
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200010208.png)
保存的时候，你可以随意指定一个文件名，但是扩展名需要指定为.bin，例如Capture_picture.bin。这个文件中除了包含目标图片之外，还包含了一些多余的数据，接下来就需要使用 WinHex 将其去除掉。

WinHex 是一款极为精巧的文件编辑工具，你可以在互联网上很容易地下载到它，大小只有几 MB。如图 11 所示，我们使用 WinHex 打开 Capture_picture.bin，可以看到这个文件中包含了一些跟图片无关的头部信息，现在需要将这些信息去除掉。
图 11 在 WinHex 打开 Capture_picture.bin
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200012408.png)
仔细观察 Wireshark 中解析的数据流，**在“Content-Type: image/jpeg”后面就是图片的实际内容**，在中间有两个换行符。换行符对应的是“0D 0A”，我们在 WinHex 找到“Content-Type: image/jpeg”，其中的图片是由“0D 0A 0D 0A”后面的内容构成。我们先找到“0D 0A 0D 0A”（见图 12），然后将其前面（包含“0D 0A 0D 0A”）的所有内容全部删除。
图 12 删除掉无关内容
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200012786.png)
这个文件比较方便的是没有多余的尾部信息，所以在去除头部信息之后，我们就可以将这个文件保存为图片了，这里起名为 Capture_picture.jpeg，如图 13 所示。
图 13 将文件保存起来
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200012914.png)
下面你就可以使用任意的一个图片查看工具来查看这张图片。
## 13.3 网络取证实践
好了，现在我们已经知道如何从网络通信中导出文件了，这其实也正是网络取证工作中重要的一个环节。那么现在不妨将学到的内容进行应用，这一方面可以帮助我们巩固前面的知识，另一方面也可以熟悉一下网络取证工作的思路。

这里我向你推荐一个很有意思的网站，名为 Network Forensics Puzzle Contest，在这个网站提供了一些很专业的题目**帮助我们学习 Wireshark 的使用**。国内很多安全类比赛的题目也都源于这个网站。我们来看一下里面提供的第一个网络取证题目：Ann 使用 AIM 做了什么？题目信息如下：
Anarchy-R-Us 公司怀疑他们的雇员 Ann Dercover 是一个为竞争对手工作的特工，她有
机会获得公司的重要机密。安全人员担心 Ann Dercover 有可能会泄露这些机密。这些安全人员一直在监视 Ann Dercover 的活动，但是到目前为止还没有任何可疑的行为。不过就在今天，一个从未使用过的笔记本电脑连接到了公司的无线网络中，工作人员推测是有人在停车场中使用它，因为大楼内部没有任何陌生人。而 Ann Dercover 的计算机（192.168.1.158）则将一些信息通过无线网络发送到这台计算机，而之后不久她就消失了。“我们捕获到了他们通信时的数据包”安全人员说，“但是我们并不知道发生了什么，你能帮忙吗？”

好了，现在你就是这个安全取证工作人员，现在你的任务就是弄清楚 Ann 在和谁联系，她发送了什么，并取得如下的证据。
（1）和 Ann 通信的好友（buddy）叫什么名字？
（2）在这次通信时发出的第一条消息是什么？
（3）Ann 传送了一个文件，这个文件的名字为什么？
（4）这个文件中 Magic number ①是什么（即最前面的 4Bytes）？
> ① Magic number，即幻数，它可以用来标记文件或者协议的格式，很多文件都有幻数标志来表明该文件的格式。一般而言，硬盘数据恢复软件（如 EasyRecovery），就是靠分析磁盘上的原始数据，然后根据文件幻数来试图匹配文件格式，从而尝试识别出磁盘中那些已经从文件系统登记表中删除的文件（真实的文件内容可能没有被覆盖）。

（5）这个文件的 MD5 值为多少？ 
（6）这个文件的内容是什么？
我们先来看第一个题目，和 Ann 通信的好友（buddy）叫什么名字？首先使用 Wireshark 打开刚刚捕获到的 evidence01.pcap 文件。现在我们可以肯定的是，Ann 使用了某种通信工具在和外界进行通信，那么她使用的是什么呢？ICQ、Skype 还是 QQ？（注意，其实这个问题在题目中已经给出了答案，这里为了拓宽读者的思路，所以假设事先不知道结果。）这里我们可以在数据包中来一查究竟。经过仔细观察之后，我们除了开始的一些 ARP 和 TCP数据包之外，==第 23 个数据包显示使用了 SSL 协议，这是一个加密的格式，我们猜测这就是 Ann 在和外界通信时产生的数据包==。虽然它的内容采用了加密的格式，但是它的 IP 协议头部却给带来了我们了一个惊喜，这个数据包的目的地址是 64.12.24.50（见图 14）。
图 14 查看到的目的地址
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200014745.png)
在前面的章节中，我们已经为 Wireshark 添加了显示地理位置的插件，所以这里可以
直接查看这个数据包的目的地址（见图 15）。
图 15 目的地址的详细信息
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200014603.png)
这里我们看到了这个数据包发往了“AOL Transit Data Network”，国内的用户对于 AOL可能有些陌生，不过它在美国可是非常有名的。不过我们可以求助于搜索引擎，在百度里面搜索“AOL 通信工具”，很快就得到了有用的信息（见图 16）。
图 16 在百度中搜索到的 AOL 信息
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200014003.png)
原来这就是 Ann 所使用的通信工具——AIM，另外我们还查询到了这个工具使用的是443 端口。那么接下来就好办了，Wireshark 早就已经提供了对 AIM 信息的解析方法。**这里我们只需要将 SSL 加密的数据包重新解析为 AIM 格式即可**。首先在第 23 个数据包上单击鼠标右键，然后选择“Decode as”选项，就可以打开相应的对话框了（见图 17）。
图 17 Wireshark 的“Decode as”窗口
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200016041.png)
这个对话框一共分成 5 个部分，第 1 个 Field 表示使用端口的类型，第 2 个 Value 表示使用的端口值，第 3 个 Type 表示类型，第 4 个为默认的解析协议，第 5 个为用户要指定的解析协议。对这里面的信息进行修改，我们的目的是**凡是使用 443 端口的通信都使用 AIM 进行解析。那么将 Field 修改为 TCP Port，将 Value 修改为 443，将 Current 修改为 AIM**（见图 18）。
图 18 将 SSL 加密的数据包重新解析为 AIM 格式
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200016955.png)

好了设置完成之后，我们就可以单击 Save 按钮保存设置，然后在数据包列表面板中查看所有的信息。这里面原来显示为 SSL 的数据包，现在都已经显示为 AIM 信息了（见图 19）。
图 19 转换格式之后的数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200017035.png)
好了，现在我们回到第一个问题上来，和 Ann 通信的好友（buddy）叫什么名字？找到第一条“AIM Messaging”，也就是第 25 个数据包，展开里面的信息，你会发现它分成了两层“AOL Instant Messenger”和“AIM Messaging，Outgoing”（见图 20）。我们依次展开两层，很快就找到了答案。Ann 联系的好友的名称原来就是 Sec558user1。
图 20 显示的 Buddy 字段内容
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200017990.png)
第 2 个问题是在这次通信时发出的第一条消息是什么？这个问题就简单多了，展开第一条 AIM Messaging 这个数据包的 TLV 部分，即可得到答案（见图 21）。
图 21 这次通信时发出的第一条消息
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200017954.png)
第 3 个问题，Ann 传送了一个文件，这个文件的名字为什么？我们在 Wireshark 中使用“data”作为显示过滤器来查看哪些数据包中包含的数据（见图 22）。
图 22 使用“data”作为显示过滤器
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200017642.png)
在这里面选择一个数据包，然后单击鼠标右键选择 Follow→TCP Stream，打开的窗口如图 23 所示。好了，其实我们不用提取这个文件，就已经看到了这个文件的名称是 recipe.docx 了。
图 23 在 TCP 数据流中看到的文件名
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200018070.png)
第 4 个问题，这个文件中 Magic number 是什么（最前面的 4Bytes）？我们按照第 2 节中介绍的方法将数据流中的文件提取出来，将这个文件保存为 evidence01.raw，然后使用 winhex 打开，这个文件实际内容是从 recipe.docx 后面开始的，根据题目中给出的提示答案为最前面的 4 个 bytes，所以是“50 4B 03 04”（见图 24）。这里面涉及一些文件格式方面的知识，大家如果感兴趣的话可以去参考一些相关的资料。 
图 24 文件最前面的 4Bytes
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200018329.png)
然后我们将这个 PK 前面的部分删除掉，再保存为 recipe.docx（见图 25）。
图 25 保存的 recipe.docx
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200018218.png)
第 5 个问题是这个文件的 MD5 值是多少？
计算 MD5 的值其实和 Wireshark 没有什么关系，但是在取证方面却很重要，这相当于给文件添加了一个身份证，以防止它被篡改。你可以使用任何的 MD5 工具来计算它的 MD5 值，这个题目最后的答案为 8350582774e1d4dbe1d61d64c89e0ea1，如图 26 所示。
图 26 计算文件的 MD5 值
第 6 个问题，这个文件的内容是什么？在解答第 4 个问题的时候，我们已经将网络中
的 TCP 数据流保存成 recipe.docx，现在只需要打开这个 word 文档，就可以看到里面的内
容了，如图 27 所示。
图 27 还原的 word 文档
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307200018476.png)
好了，整个探案过程到此为止了，是不是很有感觉很有意思呢？
## 13.4 小结
SYN Flood 攻击技术，这种技术是建立在 TCP 连接的 3 次握手过程之上的。紧随其后地介绍了 TCP 数据的传输，并**详细讲解了 Wireshark 中的数据流功能，利用这个功能可以监控整个网络中传输的文件**。最后将学到的知识进行了实践，这里提供了一个非常优秀的 Wireshark 学习网站。还有很多极为优秀的测试题目，可以借此体会一下职业的安全取证专家是如何工作的。

---
# 1. TCP/IP网络模型
**同一台设备上的进程间通信**有许多方式，如操作系统中学到的管道、消息队列、共享内存、信号量等；**不同设备上的进程间通信**就需要使用网络通信。由于设备是多种多样的，要兼容这些设备，就协商出了一套**通用的网络协议**。

这一个网络协议是**分层**的，每一层都有各自的作用和职责，下面对每一层进行介绍。

## 1.1 应用层
**最上层的**、也是我们能**直接接触到的**，就是**应用层** `Application Layer` 。电脑或手机使用的应用软件，只要是联网的，都是在应用层实现。当两个不同设备的应用需要通信时，应用就把应用数据传给下一层——即**传输层**。

因此，应用层只需要专注于为用户提供应用功能，而不用关心数据是如何传输的。类似于我们寄快递，只用把包裹交给快递员，由快递员和快递公司负责运输传送，我们自己不需要关心快递是如何被传输的。

此外，应用层工作在操作系统的用户态，传输层及以下则工作在内核态。
## 1.2 传输层
应用层的数据包会交给传输层，**传输层** `Transport Layer` 则为应用层提供网络支持。
![](https://img-blog.csdnimg.cn/a47c1918aabd45feac531e0709de2756.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_20,color_FFFFFF,t_70,g_se,x_16)

传输层有两个极其重要的**传输协议**，分别是TCP和UDP。
- `TCP (Transmission Control Protocol)` 全称为**传输层控制协议**。大部分应用使用的都是TCP，比如HTTP应用层协议。TCP相比UDP多了很多特性，比如**流量控制**、**超时重传**、**拥塞控制**等，这些都是为了保证数据包能可靠地传输给对方。
- `UDP (User Datagram Protocol)` 全称为**用户数据报协议**。它相对而言就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方。但它实时性相对更好，传输效率更高。
UDP也可以实现可靠传输，只要把TCP的特性在应用层实现就可以。只是要实现一个商用的可靠UDP，也不是一件简单的事情。

应用需要传输的数据可能十分庞大，如果直接传输就不好控制。因此当传输层的数据包大小超过MSS（TCP最大报文段长度），就要把数据包分块。这样，即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在TCP中，我们把每个分块称为一个**TCP段** `TCP Segment` 。

当设备作为接收方时，传输层则负责把数据包传给应用。但是一台设备上可能有许多应用在接收或传输数据，因此要用一个编号将应用区分开来。这个编号就是**端口**。比如80端口通常是Web服务器用的，22端口通常是远程登录服务器用的。而浏览器中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。

由于传输层的报文中会携带端口号，因此接收方可以识别出，该报文是发送给哪个应用。

## 1.3 网络层
刚接触TCP/IP网络模型时可能顾名思义，认为传输层负责将数据从一个设备传输到另一个设备，然而这是错的。

现实场景中的网络是错综复杂的，中间有各种各样的线路和分叉口，如果一个设备的数据要传输给另一个设备，就需要在各个路径和节点间进行选择。然而传输层的设计理念是简单、高效、专注（用面向对象的话来说就是**单一职责原则**和**依赖倒转原则**），如果传输层还负责这一块功能，就有点违背设计原则了。

即，我们不希望传输层协议处理太多的事，它只需要服务好应用、作为应用间数据传输的媒介、帮助实现应用到应用的通信即可。实际的传输功能就交给下一层，也就是**网络层** `Internet Layer` 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/031199f994624b378059650f8ff87065.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_20,color_FFFFFF,t_70,g_se,x_16)

网络层最常使用的是 `IP (Internet Protocol)` 即**网际互连协议**。IP协议会将传输层的报文作为数据部分，再加上IP包头组装成**IP报文**，如果IP报文大小超过MTU（以太网中一般为1500字节），就会**再次进行分片**，得到一个即将发送到网络的IP报文。
![在这里插入图片描述](https://img-blog.csdnimg.cn/3e7987545db44d57a72f684b14cc6a7c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_20,color_FFFFFF,t_70,g_se,x_16)
网络层负责将数据从一个设备传输到另一个设备，世界上这么多设备，如何找到目标设备呢？由此，网络层需要一个区分设备的编号——即**IP地址**。

对于IPv4协议，IP地址共32位，分成四段、每段8位。然而有了一个单纯的IP地址虽然做到了区分设备，但是寻址起来特别麻烦。世界上那么多设备，难道一个个去匹配？时间复杂度太高了！

为此将IP地址分成两种意义：
- 一个是**网络号**，标识该IP地址属于哪个**子网**；
- 一个是**主机号**，标识同一子网下的不同**主机**；

怎样分的呢？还需要配合**子网掩码**才能算出IP地址的网络号和主机号。然后在寻址的过程中，**先匹配到相同的网络号，才会去找对应的主机**。
> 对应到算法中，类似**分块+索引**算法，将时间复杂度从 $O(2^{32})$ 降低到 $O(2^m + 2^n)\ (m + n = 32)$ 。

除了寻址能力，IP协议还有另一个重要能力，即**路由**。实际场景中，两台设备几乎不会是用一条网线连接起来的，它们之间通过许多网关、路由器、交换机等网络设备连接起来，于是就有很多条路径。因此，当数据到达一个网络节点时，就需要通过算法决定下一步走哪条路径。

所以，**IP协议的寻址**作用是**告诉我们去往下一个目的地该朝哪个方向（子网和主机）走**、**路由**作用是**根据「下一个目的地」选择路径**。寻址像是导航，目的地就是IP地址，路由则是导航中具体操作方向盘。

---
## 1.4 数据链路层
实际场景中，网络并非是一个整体。比如武大和西电就不属于一个网络。所以数据不仅要在同一网络的设备间进行传输，还要跨网络进行传输。

一旦数据需要跨网络传输，新的问题就浮出水面了——如何连接这两个网络呢？简单，只需要有一个设备同时在两个网络当中，这个设备一般是**路由器**，路由器可以通过**路由表**计算出下一个要去的IP地址。

只是路由器怎么知道IP地址是哪个设备的呢？这就需要一个专门的层来标识网络中的设备，让数据在链路中传输而不至于失去方向，这就是**数据链路层** `Data Link Layer` ，它主要为网络层提供链路级别传输的服务。
![在这里插入图片描述](https://img-blog.csdnimg.cn/bb25061c08c44d18b7f14291b8c2aab1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_20,color_FFFFFF,t_70,g_se,x_16)
每一台设备上的网卡都有一个MAC地址，它就是用来**唯一标识设备**的。路由器计算出下一个目的地的IP地址，再通过**ARP协议**找到该目的地的MAC地址，这样就知道这个IP地址是哪个设备了。

---
## 1.5 物理层
当数据准备从设备发送到网络时，需要把数据包转换成电信号，让其在物理介质中传输。这一层就是**物理层** `Physical Layer` ，它主要为数据链路层提供二进制传输的服务。
![在这里插入图片描述](https://img-blog.csdnimg.cn/ed8fdbcd73e1435b9e584a002144e1e1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_20,color_FFFFFF,t_70,g_se,x_16)

## 1.6 总结
综上所述，网络协议由上到下分成5层，分别是应用层、传输层、网络层、数据链路层、物理层。
```clike
UDP的讨论可在下列请求评论中找到:
769
TCP的讨论可在下列请求评论中找到:
675, 700, 721, 761, 793, 879, 896, 1078, 1106, 1110, 1144, 1145, 1146,
1263, 1323, 1337, 1379, 1644, 1693, 1901, 1905, 2001, 2018, 2488, 2580
SCTP的讨论可在下列请求评论中找到：
2960, 3257, 3284, 3285, 3286, 3309, 3436, 3554, 3708, 3758
```

这里开始**给出传输层** `transport layer` **存在的基本理由**，即**进程到进程传递的必要性**。主要讨论这类传递产生的问题，并讨论解决这些问题的方法。

在因特网模型中，传输层有三种协议：UDP、TCP和SCTP。**首先讨论UDP协议**，它是这三种中比较简单的一种协议。我们看到了如何使用这个非常简单的传输层协议，它缺少其他两个协议的一些特性。
 
**然后讨论TCP协议**，它是一种复杂的传输层协议。我们将了解到之前介绍的概念如何应用于TCP，并将有关TCP中拥塞控制和服务质量的讨论放在[第24章](https://memcpy0.blog.csdn.net/article/details/123029798)，因为这两个问题同样适用于**数据链路层和网络层**。

**最后讨论新的传输层协议SCTP** ，它是为像多媒体这样的多接口与多流应用 `multihomed, multistream applications` 而设计的。

---
# 23.1 进程到进程的传递
数据链路层负责「链路上的两个相邻节点之间」的**帧传递**，这称为**节点到节点的传递**。网络层负责两台主机之间的**数据报传递**，这称为**主机到主机的传递**。然而，因特网中的通信并不是定义为两个节点或两个主机之间的数据交换。**实际的通信是发生在两个进程（应用程序）之间的**，我们需要**进程到进程的传递** `process-to-process delivery` 。

但是，在任何时刻，在源主机上可能运行着多个进程，并且在目的主机上也运行着多个进程。为了完成传递过程，我们需要一种机制，将源主机上运行的某个进程的数据，发送到目的主机上运行的对应进程上。

传输层负责进程到进程的传递，即进程之间的分组传递以及部分消息传递。后面将会看到**两个进程以客户/服务器的方式通信**。图23.1 表示了三种传送类型以及它们的应用范围。
![图23.1 数据传送类型](https://img-blog.csdnimg.cn/1a2e9aeb1bc3423caf2873d283cf50c6.png)
## 23.1.1 客户/服务器模式
虽然有多种方法可以实现进程到进程的通信，但**最常用的一个方法**是通过**客户/服务器模式** `client-server paradigm` 。本地主机上的进程称为客户 `client` ，它通常需要「来自远程主机上的进程」提供的服务，这个远程主机称为**服务器** `server` 。

**这两个进程（客户和服务器）有相同的名字**。例如，如果要从远程机器上获得日期和时间，我们需要在本地主机上运行 `Daytime` 客户进程，和在远程机器上运行 `Daytime` 服务器进程。

目前的操作系统支持多用户和多程序运行的环境。一个远程计算机在同 一时间可以运行多个服务器程序，就像许多本地计算机可在同一时间运行一个或多个客户应用程序一样。因此，对通信来说，我们必须确定义：
1. 本地主机
2. 本地进程
3. 远程主机
4. 远程进程

### 1. 寻址
每当需要传送信息到多个目的地之中的某一特定目的地时，就需要一个地址。==在数据链路层，如果连接不是点到点的，则需要一个MAC地址，从**多个节点**中选择一个节点==。数据链路层的帧需要一个目的端MAC地址用于传送数据，以及一个源地址用于下一节点的回答。

==在网络层，需要一个IP地址来选择**数百万主机**之中的一个主机==。网络层中的数据报需要目的IP地址用于传送数据，需要源IP地址用于接收目的主机的回答。

==在传输层，需要一个称为**端口号** `port number` 的传输层地址，利用这一地址从**目的主机上运行的多个进程**中选择相应的进程==。目的端口号用于传送，而源端口号用于接收回答。

在因特网模型中，端口号是在 $0\sim 65535$ 之间的 $16$ 位整数。
- **客户程序用端口号定义它自己**，这个端口号是由「运行在客户主机上的传输层软件」随机选择的，这是**临时端口号** `ephemeral port number` 。
- **服务器进程也必须用一个端口号定义它自己**，但这个端口号不能随机选择。如果服务器站点的计算机运行一个服务器进程，并随机分配一个数字作为端口号，那么在客户站点的进程想访问该服务器、并使用其服务时，将不知道此端口号。当然，一个解决方法是发送一个特殊分组、并请求一个特定服务器的端口号，但是这需要更多的开销。
因特网决定给服务器使用全局端口号：它们称为**熟知端口号** `well-known port number` 。但这条规则也有例外，例如，有一些客户端也被分配了熟知端口号 `there are clients that are assigned well-known port numbers` 。**每一个客户进程都知道相应服务器进程的熟知端口号**。例如，前面所讨论的 `Daytime`客户进程可以使用临时（暂时）端口号 $52000$ 来表示自己，但服务器 `Daytime` 进程就必须使用熟知（永久的）端口号 $13$ 。图23.2表示了这一概念。
![图23.2 端口号](https://img-blog.csdnimg.cn/6f38fbb157e74cd39fac7d0c2e7fdd6e.png)

现在必须搞清楚，**在选择数据的最终目的端时，IP地址和端口号起着不同的作用**——目的IP地址在世界范围的不同主机中确定一个主机。但主机被选定后，端口号定义了在该特定主机上的多个进程中的一个进程（见图23.3）。
![图23.3IP地址与端口号](https://img-blog.csdnimg.cn/eb903a71d2db435badab5e8962af2f85.png) 
### 2. IANA范围
**因特网号码分配管理局** `Internet Assigned Number Authority, IANA` 已经把端口编号划分为三种范围：**熟知的、注册的**和**动态的**（**私有的**) ，如图23.4所示：
- **熟知端口** `well-known ports` 。端口号的范围是 $0\sim 1023$ ，由IANA分配和控制。这些是熟知端口。
- **注册端口** `registered ports` 。端口号的范围是 $1024\sim 49151$ ，IANA不分配或也不控制。**它们可在IANA注册以防重复**。
- **动态端口** `dynamic ports` 。端口号的范围是 $49152\sim 65535$ 。这一范围内的端口号**既不受控制也不需要注册**，可以由任何进程使用。它们是临时端口。
![图23.4 IANA定义的范围](https://img-blog.csdnimg.cn/b6b83fb82cfd45238c6d209b10bfa660.png)
### 3. 套接字地址
==进程到进程的传递需要有两个标识符，**IP地址和端口号**，它们各用在一端以建立**一条连接**==。一个IP地址和一个端口号结合起来称为**套接字地址** `socket address` 。==客户套接字地址唯一定义了客户机进程，而服务器套接字地址唯一地定义了服务器进程==（见图23.5所示）。
![图23.5套接字地址](https://img-blog.csdnimg.cn/713905ab4919422a9ff9143e2c631a6e.png)
**传输层协议需要一对套接字地址**：客户套接字地址和服务器套接字地址。这四条信息是IP头部和传输层协议头部的组成部分。**IP头部包含IP地址**，而**UDP或TCP头部包含端口号**。
 
## 23.1.2 复用与分离
寻址机制允许通过传输层进行复用和分离 `The addressing mechanism allows multiplexing and demultiplexing by the transport layer` ，如图23.6所示。
### 1. 复用
在发送方站点，**可能有多个进程要发送分组**。但是，**在任何时候只有一个传输层协议**。==这是一种多对一的关系，因而需要复用==——传输层协议接收来自不同进程的报文，这些进程由「分配给它们的端口号」进行区分。添加了头部以后，传输层把分组发送给网络层。
### 2. 分离
 在接收方站点，**也只有一个传输层协议**，但是**有多个进程可能要接收分组**。==这是一对多的关系，因而需要分用==——传输层接收来自网络层的数据报。经过纠错和去除头部以后，传输层根据端口号，将每个报文传递到适当的进程。
![图23.6 复用与多路分离](https://img-blog.csdnimg.cn/d158952c0a5e4000aa83f9e73c1c90ae.png)

## 23.1.3 无连接服务与面向连接的服务
传输层协议可以是无连接的或面向连接的服务。
### 1. 无连接服务
在**无连接服务** `connectionless service` 中，分组从一方发送给另一方，不需要建立连接和释放连接。**分组没有编号**。它们可能被延迟、丢失或无序到达，也没有确认过程。下面会看到，在因特网模型中，其中的一个传输层协议UDP就是无连接的。
### 2. 面向连接的服务
在**面向连接的服务** `connection-oriented service` 中，首先在发送方和接收方之间建立一个连接，然后传送数据，最后释放连接。下面将看到，TCP和SCTP都是一种面向连接的协议。
## 23.1.4 可靠服务与不可靠服务
**传输层服务可以是可靠的或不可靠的**：
- ==如果应用层程序需要可靠性，我们使用可靠的传输层协议==，通过在传输层实现流量控制和差错控制来获得这种可靠性。这意味着**一种较慢和更复杂的服务**。
- 另一方面，==如果应用程序不需要可靠性==，因为它使用自己的流量和差错控制机制、或者它需要快速服务、或者服务的本质特性不要求流量和差错控制（如实时应用），==那么就可以使用不可靠服务==。

在因特网中，有三种不同的传输层协议，前面已提到过。UDP是无连接的和不可靠的，而TCP和SCTP则是面向连接的和可靠的。这三种协议都能与应用层程序的需要相对应。

一个疑问是：*如果数据链路层是可靠的，并且已经有了流量控制和差错控制，那么还需要在传输层进行流量控制和差错控制吗*？回答是需要的。因为==在数据链路层的可靠性存在于两个节点之间，而我们需要端到端的可靠性，并且因为因特网的网络层是不可靠的（尽力传递），所以必须在传输层实现可靠性==。要知道，数据链路层的差错控制并不能保证传输层的差错控制，让我们看一下图23.7。
![图23.7 差错控制](https://img-blog.csdnimg.cn/131a3b7752344efc855e1981c2803af3.png)
下面将看到，TCP中的流量和差错控制是通过**滑动窗口协议**实现的，就像在[【计算机网络】第三部分 数据链路层(11) 数据链路控制](https://memcpy0.blog.csdn.net/article/details/123156008)中已经讨论过的那样。但是，**窗口是面向字符而不是面向帧的**。
## 23.1.5 三种协议
**原始的TCP/IP协议族在传输层只规定了两个协议：UDP和TCP**。在讨论TCP以前，首先关注这两个协议中较简单的UDP。然后在本章中也讨论新设计的传输层协议SCTP。图23.8表示了这些协议在TCP/IP协议族中的位置。
![图23.8 在TCP/IP协议族中UDP、TCP和SCTP的位置](https://img-blog.csdnimg.cn/1b868e9141ca4402a29ec4df0c888bf1.png)
听说现在的年青人可以用手机摇到妹子，可惜在我们那个年代，手机的主要
功能只有两个—**电话和短信**。人们凭直觉决定该打电话还是发短信，却很少去深究这两者的本质差别。

**打电话时要先拨号，等接通之后才开始讲话**。如果有人还没拨号就对着电话自言自语，旁人一定会觉得很诡异。而发短信时根本不用考虑对方在干嘛，直接发出
去就是了。这两种方式的本质差别就是，打电话时要先“建立连接”（即拨号），而短信不需要。**建立连接需要花费一些时间，但也意味着更加可靠**。我们可以在电话上确保对方已经听明白。而短信就不行了，发送之后并不知道对方是否及时收到，也不知道有没有产生误解。有一个笑话这样调侃短信所引发的事故—出差的丈夫一大早就给妻子发了条短信“I had a wonderful night, and really wish you were here”。不幸的是，他少打了最后一个“e”，这个误会估计需要一个面对面的连接才能化解。

**网络的传输层和手机一样用于传递信息**。它也有两种方式—TCP 和 UDP，其中 TCP 是基于连接的，而 UDP 不需要连接。它们各自支持一些应用层协议，**但也有些协议是两者都支持的**，比如 DNS。我们==正好可以用 DNS 来比较 TCP 和
UDP 的差别==。

---
# 23.2 用户数据报协议（UDP）
**用户数据报协议** `User Datagram Protocol, UDP` 称为**无连接不可靠传输层协议** `connectionless, unreliable transport protocol` 。==它除了**提供进程到进程通信**、而不是主机到主机通信外，就没有给IP服务增加任何东西。此外，它还**完成非常有限的差错检验**==。

*如果UDP功能如此差，那么为什么进程还要使用它*？它有缺点但也有优点——**UDP是一个非常简单的协议，开销最小**。如果一个进程想发送很短的报文，而且不在意可靠性，就可以使用UDP。使用UDP发送一个很短的报文，在发送方和接收方之间的交互，要比使用TCP或SCTP时少得多。
## 23.2.1 熟知端口号
表23.1列出了UDP使用的一些熟知端口号。**有些端口号是UDP和TCP都可使用的**。稍后讨论TCP肘，将讨论它们。

|  端口 | 协议 | 说明 |
|:---|:---|:--|
| $13$ | `Daytime` | `Returns the date and the time` |
| $17$ | `Quote` | `Returns a quote of the day` |
| $19$ | `Chargen` | `Returns a string of characters` |
| $53$ | `Nameserver` | `Domain Name Service` |
| $67$ | `BOOTPs` | `Server port to download bootstrap information` |
| $68$ | `BOOTPc` | `Client port to download bootstrap information` |
| $69$ | `TFTP` | `Trivial File Transfer Protocol` |
| $111$ | `RPC` | `Remote Procedure Call` 
| $123$ | `NTP` | `Network Time Protocol` 
| $161$ | `SNMP` | `Simple Network Management Protocol` 
| $162$ | `SNMP` | `Simple Network Management Protocol (trap)` 
 ![表 23.1 UDP使用的熟知端口](https://img-blog.csdnimg.cn/db8eef7b798b46be87ed67e04602ddba.png)
【例23.1】在UNIX中，熟知端口号存储在 `/ect/services` 文件中，这个文件的每行给出服务器名和熟知端口号。我们可用 `grep` 命令提取该行所对应的应用。下面表示了FTP的端口。注意：FTP可使用 UDP或TCP的端口 $21$ 。SNMP使用两个端口号（$161$ 和 $162$），在[第28章]()中看到每一个用于不同目的。
```clike
$ grep ftp /etc/services
ftp		21/tcp
ftp		21/udp

$ grep snmp /etc/services
snmp		161/tcp		#Simple Nel Mgml Proto
snmp		161/udp		#Simple Nel Mgmt Proto
snmptrap	162/udp 	#Traps for SNMP
```
## 23.2.2 用户数据报
UDP分组称为**用户数据报** `user datagram` ，**有 $8$ 字节的固定头部**（TCP固定头部是 $20$ 字节！）。图23.9说明了用户数据报的格式（很简单！  ）。用户数据报共有下列字段：
- **源端口号**。这是在源主机上运行的进程使用的端口号。它有 $16$ 位长，这就表示端口号可以从 $0$ 到 $65535$ 。==如果源主机是客户端（当客户进程发送请求时），那么大多数情况下这个端口号就是暂时端口号，它由该进程请求，由源主机上运行的UDP软件进行选择==。如果源主机是服务器（当服务器进程发送响应时），那么在大多数情况下这个端口号是熟知端口号。
- **目的端口号**。这是在目的主机上运行的进程使用的端口号。它有 $16$ 位长。如果目的主机是服务器（当客户进程发送请求时），那么在大多数情况下这个端口号是熟知端口号。==如果目的主机是客户端（当服务器进程发送响应时），那么大多数情况下这个端口号是暂时端口号。在这种情况下，服务器将它接收到的请求分组中的暂时端口号复制下来==。
- **长度**。这是一个 $16$ 位字段，它定义了**用户数据报的总长度（头部加上数据）**。$16$ 位可定义的总长度是从 $0$ 到 $65 535$ 字节。但是，总长度必须比这个小。因为UDP数据报存放在**总长度为 $65535$ 字节的IP数据报**中。

**UDP用户数据报的长度字段实际上是没有必要的**：用户数据报封装成IP数据报，==在IP数据报中有一个字段定义总长度，IP数据报还有一个字段定义头部长度。所以，如果将上述第一个字段的值减去第二个字段的值，就能求得「封装在IP数据报中的UDP数据报」的长度==。

但是，UDP协议设计者认为，**目标UDP根据UDP用户数据报中提供的信息计算数据长度，比要求IP软件提供这一信息更有效**。应该当记得，当IP软件把UDP用户数据报提交给UDP层时，它已经除去了IP头部。
- 校验和。这个字段用来**校验整个用户数据报（头部加数据）出现的差错**。校验和将在下一节讨论。
![图23.9 用户数据报格式](https://img-blog.csdnimg.cn/f526dd5499444ccb93fffb462b8a9ad5.png)
## 23.2.3 校验和
在[【计算机网络】第三部分 数据链路层(10) 检错与纠错](https://memcpy0.blog.csdn.net/article/details/123102281)中，已讨论过校验和的概念与计算方法，还讨论过**如何计算IP和ICMP分组的校验和**。现在，讨论**如何计算UDP的校验和**（注意**进位回滚**）。

UDP校验和的计算与IP和ICMP校验和的计算不同。这里==校验包括三个部分：伪头部、UDP头部和从应用层来的数据==。**伪头部** `pseudoheader` 是**IP分组的头部的一部分**，用户数据报封装在IP分组中，其中有些字段要填入 $0$ `The pseudoheader is the part of the header of the IP packet in which the user datagram is to be encapsulated with some fields filled with 0s `（见图23.10）。
![图23.10 用于校验和计算的伪头部](https://img-blog.csdnimg.cn/b644e9f9698d484f8b484b131966a092.png)

==如果校验和不包括伪头部，用户数据报也可能是安全的和正确地到达。但是，如果IP头部受到损坏，那么它可能被提交到错误的主机==。

**（在伪头部中）增加协议字段，可确保这个分组是属于UDP**，而不是属于其他传输层协议。在后面将会看到，如果一个进程既可用UDP又可用TCP ，则端口号可以是相同的。==UDP的协议字段一直是 $17$ ，如果在传输过程中这个值改变了，在接收端计算校验和时就可检测出来，UDP就可丢弃这个分组==。这样就不会传递给错误的协议。

注意伪头部字段和「IP头部最后 $12$ 字节」的相似性。

【例23.2】图23.11给出了只有 $7$ 个字节数据的、很小的用户数据报的校验和计算。因为数据的字节数是奇数，因此为了计算校验和就要加上填充。**当用户数据报要传递给IP时，就将伪头部和填充丢弃**。
![图23.11 简单UDP用户数据报的校验和计算](https://img-blog.csdnimg.cn/0ce99c418fe6495ca9c3e980de215e94.png)
### 可选的校验和
校验和的计算、以及在用户数据报中包括的校验和都是**可选的**。==如果不进行校验和的计算，则这个字段就填入全 $1$== 。注意：计算得到的校验和永远不会是全 $1$ ，因为这就是说和是全 $0$ ，这是不可能的——由于它要求字段的值为全 $0$ ，这是不可能的。
## 23.2.4 UDP的操作
UDP使用了传输层共同的一些概念。简要讨论这些概念，然后在下一节介绍TCP协议时展开讨论。
### 1. 无连接服务
如前所述，UDP提供无连接服务。这表示**UDP发送出去的每一个用户数据报都是一个独立的数据报**。不同的用户数据报之间没有关系，即使它们都来自相同的源进程、并发送到相同的目的程序。**用户数据报不进行编号**。此外，也没有像TCP协议那样的连接建立和连接终止，这就表示，**每一个用户数据报可以沿着不同的路径传递**。

无连接的一个结果就是，==使用UDP的进程不能向UDP发送数据流，也不能期望UDP将这个数据流分割成许多不同的、相关联的用户数据报==。相反，每一个请求必须足够小，使其能够装入到用户数据报中，**只有那些发送短报文的进程才应当使用UDP**。
### 2. 流量控制和差错控制
UDP是一个简单的、不可靠的传输协议，**它没有流量控制，因而也没有窗口机制**。如果到来的报文太多肘，接收方可能会溢出。**除校验和外，UDP也没有差错控制机制**，这就表示发送方不知道报文是否丢失、还是重复传递。当接收方使用校验和检测出差错时，就悄悄地将此用户数据报丢弃。

缺少流量控制 `flow control` 和差错控制 `error control` ，就表示使用 UDP的进程必须要提供这些机制。
### 3. 封装和拆封
要将报文从一个进程发送到另一个进程时，UDP协议就要在IP数据报中封装和拆封报文。
### 4. 排队
我们已经提到过端口，但没讨论端口的实际实现。**在UDP中，队列是与端口联系在一起的**（见图23.12所示）。注意：==即使当一个进程想与多个进程通信肘，它也只得到一个端口号，最后往往也只有一个出队列和一个入队列== `queue` 。
![图23.12 UDP中的队列](https://img-blog.csdnimg.cn/c3b7659c363d4eb0b90b95a495858a2a.png)
在客户机端，当进程启动时，它从操作系统请求一个端口号。一些实现会创建与每个进程关联的一个出队列和入队列 `an incoming and an outgoing queue` 。而有些实现只创建与每一个进程相关的入队列。==在多数情况下，由客户打开的队列由暂时端口号来标识，**只要进程在运行，这些队列就起作用**。当进程终止时，队列就撤销==。客户进程使用「在请求中指明的源端口号」，将报文发送到出队列。UDP逐个将报文取出，加上UDP头部递交给IP。出队列可能发生溢出。**如果发生溢出，操作系统就要求客户进程在继续发送报文之前要等待**。

当报文到达客户端时，UDP要检查一下，以确认对应于「该用户数据报中目的端口号字段」指明的端口号是否创建了入队列。==如果有这样的入队列，UDP就将接收到的用户数据报，放在该队列的末尾；如果没有这样的队列，UDP就丢弃该用户数据报，并请求ICMP协议、向服务器发送端口不可达报文==。所有发送给一个特定客户程序的入报文，不管是来自相同的服务器还是不同的服务器，都被放在同一个队列中。入队列可能会溢出，**如果发生溢出，UDP就丢弃此用户数据报，并请求向服务器发送端口不可达报文**。

在服务器端，创建队列的机制是不同的。用最简单形式，**服务器在它开始运行时，就用它的熟知端口请求入队列和出队列**。只要服务器运行，队列就一直是打开的。

当报文到达服务器进程时，UDP要检查一下，以确认对应于「该用户数据报中目的端口号字段」指明的端口号是否创建了入队列。==如果有这样的队列，UDP就将接收到的用户数据报，放在该队列的末尾。如果没有这样的队列，UDP就丢弃该用户数据报，并请求ICMP协议向客户端发送一个端口不可达报文==。一个特定服务器程序的所有入报文，不管是来自相同的客户还是不同的客户机，都放入同一队列。入队列可能溢出，**如果发生溢出，UDP就丢弃这个用户数据报，并请求向客户发送端口不可达报文**。

当服务器想要回答客户时，它就使用「在请求报文中指明的源端口号」，将报文发送到出队列。UDP逐个将报文取出，加上UDP的头部，递交给IP。出队列可能溢出，**如果发生溢出，操作系统就要求服务器进程在继续发送报文之前要等待**。
## 23.2.5 UDP的使用
下列是UDP协议的某些应用：
- UDP适用于这样的进程，**它需要简单的请求-响应通信，而较少考虑流量控制和差错控制**。对于需要传送成块数据的进程，如 FTP（见[【计算机网络】第六部分 应用层(26) 远程登录、电子邮件与文件传输](https://memcpy0.blog.csdn.net/article/details/122896909))，则通常不使用它；
- UDP适用于**具有内部流量控制和差错控制机制的进程**。例如，简单文件传输协议 `TFTP` 的进程，就包括流量控制和差错控制，它能够很容易地使用UDP；
- 对多播来说，UDP是一个合适的传输协议。**多播能力已被嵌入在UDP软件中，但没有嵌入在TCP软件中**；
- UDP可用于**管理进程**，如SNMP（见[第28章]()）；
- UDP可用于**某些路由选择更新协议**，如路由选择信息协议 `RIP`（[第22章]()）。

说到 UDP，就不得不拿 TCP 来对比。谁叫它们是竞争对手呢？前文提到过 **UDP 无需连接，所以非常适合 DNS 查询**。图 1 和图 2 是分别在基于UDP 和 TCP 时执行 DNS 查询的两个包，前者明显更加直截了当，两个包就完成了。
基于 UDP 的查询:
图 1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131125049.png)
基于 TCP 的查询：
图 2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131125956.png)

UDP 为什么能如此直接呢？其实是**因为它设计简单，想复杂起来都没办法**—在 UDP 协议头中，只有端口号、包长度和校验码等少量信息，总共就 8 个字节。
小巧的头部给它带来了一些优点。
- 由于 UDP 协议头长度还不到 TCP 头的一半，所以**在同样大小的包里，UDP包携带的净数据比 TCP 包多一些**。
- 由于 UDP 没有 Seq 号和 Ack 号等概念，无法维持一个连接，所以**省去了建立连接的负担**。这个优势在 DNS 查询中体现得淋漓尽致。

当然简单的设计不一定是好事，更多的时候会带来问题。
1. **UDP 不像 TCP 一样在乎双方 MTU 的大小**。它拿到应用层的数据之后，直接打上 UDP 头就交给下一层了。那么超过 MTU 的时候怎么办？在这种情况下，**发送方的网络层负责分片，接收方收到分片后再组装起来**，这个过程会消耗资源，降低性能。图 3 是一个 32 KB 的写操作，根据发送方的 MTU 被切成了 23 个分片。
    图 3
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131126717.png)
2. **UDP 没有重传机制，所以丢包由应用层来处理**。如下面的例子所示，某个写操作需要 6 个包完成。当基于 UDP 的写操作中有一个包丢失时，客户端不得不重传整个写操作（6 个包）。相比之下，基于 TCP 的写操作就好很多，只要重传丢失的那 1 个包即可。
    基于 UDP 的 NFS 写操作（见图 4）：
    图 4
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131127946.png)

    基于 TCP 的 NFS 写操作（见图 5）：
    图 5
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131127796.png)
    也许从这个例子你还感受不到明显的差别，试想一下，在高性能环境中，一个写操作需要数十个包来完成，UDP 的劣势就体现出来了。
3. **分片机制存在弱点，会成为黑客的攻击目标**。接收方之所以知道什么时候该把分片组装起来，是因为**每个包里都有 “More fragments”的 flag**。1 表示后续还有分片，0 则表示这是最后一个分片，可以组装了。如果黑客持续快速地发送 flag 为 1 的 UDP 包，接收方一直无法把这些包组装起来，就有可能耗尽内存。图 6 左边是 NFS 写操作中 7～28 号分片的 flag，右边是 29 号分片（最后一个分片）的 flag。
    图 6
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131128427.png)

关于 UDP 就简单介绍这么多。虽然我觉得这个协议实在没多少可谈的，但关
于 UDP 和 TCP 的争论一直是某些论坛的热门话题。了解了 UDP 的工作方式，也算学会一门伪装成大牛的手艺。下次再有人宣称“UDP 的性能比 TCP 更好”时，
你可以不紧不慢地告诉他，“也不尽然，我来给你举一个 NFS 丢包的例子……”。

---
# 23.3 TCP
讨论的第二个传输层协议，称为**传输控制协议** `Transmission Control Protocol, TCP` 。与UDP一样，TCP是一个进程到进程（程序到程序）的协议，所以它使用端口号。但与UDP不同的是，**TCP是面向连接的协议**。为发送数据，它在两个TCP之间建立一个虚拟连接。另外，**TCP在传输层使用流量控制和差错控制机制**。

简单地说，**TCP被称为面向连接的、可靠的传输协议**。它为IP服务增加了面向连接和可靠性的特性。
## 23.3.1 TCP服务
在详细讨论TCP之前，解释TCP向应用层进程提供的服务。
### 1. 进程到进程的通信
像UDP一样，TCP用端口号提供进程到进程的通信。表23.2列出了TCP使用的一些熟知端口号。
```bash
C:\Users\21839>users --help
Usage: users [OPTION]... [FILE]
Output who is currently logged in according to FILE.
If FILE is not specified, use /var/run/utmp.  /var/log/wtmp as FILE is common.

      --help     display this help and exit
      --version  output version information and exit

C:\Users\21839>telnet
欢迎使用 Microsoft Telnet Client

Escape 字符为 'CTRL+]'

Microsoft Telnet> ?/help 

命令可能是缩写。支持的命令为:

c    - close                    关闭当前连接
d    - display                  显示操作参数
o    - open hostname [port]     连接到主机(默认端口 23)。
q    - quit                     退出 telnet
set  - set                      设置选项(键入 'set ?' 获得列表)
sen  - send                     将字符串发送到服务器
st   - status                   打印状态信息
u    - unset                    解除设置选项(键入 'set ?' 获得列表)
?/h  - help                     打印帮助信息

C:\Users\21839>nslookup --help 
默认服务器:  UnKnown
Address:  10.80.13.1

> 127.0.0.1
服务器:  UnKnown
Address:  10.80.13.1

名称:    localhost
Address:  127.0.0.1

C:\Users\21839>finger

显示与运行手指服务的指定系统上某个用户有关
的信息。输出因远程系统而异。

FINGER [-l] [user]@host [...]

  -l        以长列表格式显示信息。
  user      指定需要其信息的用户。省略 user 参数
            将显示与指定主机上所有用户有关的信息。
  @host     指定需要其用户信息的远程系统上的服务器。

C:\Users\21839>arp

显示和修改地址解析协议(ARP)使用的“IP 到物理”地址转换表。

ARP -s inet_addr eth_addr [if_addr]
ARP -d inet_addr [if_addr]
ARP -a [inet_addr] [-N if_addr] [-v]

  -a            通过询问当前协议数据，显示当前 ARP 项。
                如果指定 inet_addr，则只显示指定计算机
                的 IP 地址和物理地址。如果不止一个网络
                接口使用 ARP，则显示每个 ARP 表的项。
  -g            与 -a 相同。
  -v            在详细模式下显示当前 ARP 项。所有无效项
                和环回接口上的项都将显示。
  inet_addr     指定 Internet 地址。
  -N if_addr    显示 if_addr 指定的网络接口的 ARP 项。
  -d            删除 inet_addr 指定的主机。inet_addr 可
                以是通配符 *，以删除所有主机。
  -s            添加主机并且将 Internet 地址 inet_addr
                与物理地址 eth_addr 相关联。物理地址是用
                连字符分隔的 6 个十六进制字节。该项是永久的。
  eth_addr      指定物理地址。
  if_addr       如果存在，此项指定地址转换表应修改的接口
                的 Internet 地址。如果不存在，则使用第一
                个适用的接口。
示例:
  > arp -s 157.55.85.212   00-aa-00-62-c6-09.... 添加静态项。
  > arp -a                                  .... 显示 ARP 表。
```
![表23.2 TCP使用的熟知端口](https://img-blog.csdnimg.cn/630ad12926984a06b9ce78000dd7211b.png)

### 2. 流传递服务
与UDP不同，**TCP是一个面向流的协议**。在UDP中，进程（应用程序）发送一些具有预先规定界限 `predefined boundaries` 的报文给UDP进行传递。UDP将它自己的头部添加到这些报文中每一个报文上，并将它们传递到IP进行传输。来自进程的每一个报文被称为一个用户数据报，并最后变成一个IP数据报。IP和UDP都无法识别数据报之间的任何关系 `Neither IP nor UDP recognizes any relationship between the datagrams` 。
 
另一方面，**TCP允许发送进程以字节流 `a stream of bytes` 形式传递数据，并且接收进程也以字节流形式接收数据**。TCP建立一种环境，在这种环境中，两个进程好像由一根假想的"管道"连接，这个管道通过因特网传送这些进程的数据。这种假想的环境，如图23.13所示。发送进程产生（写入）字节流，而接收进程消费（读出）这些字节流。
![图23.13 字节流传递](https://img-blog.csdnimg.cn/be9cb780d9ed44cdbbb44b5d89a4d6e5.png)
#### (1) 发送和接收缓冲区
==因为发送和接收进程可能以不同的速度写入和读出数据，所以 TCP需要缓冲区来存储== `TCP needs buffers for storage` 。每一个方向都存在一个缓冲区：**发送缓冲区**和**接收缓冲区**（稍后会看到，这些缓冲区也用于TCP流量和差错控制机制）。实现缓冲的一种方法是，**使用一字节存储单元的循环数组** `use a circular array of 1-byte locations` ，如图23.14所示。

为了简化，只画出了两个缓冲区，每个缓冲区 $20$ 个字节。通常情况下，缓冲区是成百或上千个字节，这取决于实现方法。这里表示的缓冲区大小是相同的，实际上并非总是如此。
![图23.14 发送与接收缓冲区](https://img-blog.csdnimg.cn/d0ca49e9e254490d8ddcd76bc43c9e2f.png)
图23.14中表示了在一个方向上数据的移动。在发送端，缓冲区有三种类型的存储单元：白色的部分是空存储单元，可以由发送进程（生产者）填充。==灰色的部分用于保存已经发送、但还没有得到确认的字节，TCP在缓冲区中保留这些字节，直到收到确认为止==。有色部分是将由TCP发送的字节 `The colored area contains bytes to be sent by the sending TCP` 。但是，在后面将会看到，TCP可能只能发送灰色部分。这可能是由于接收进程缓慢、或者可能是网络中发生的拥塞。还要注意，==灰色存储单元的字节被确认后，这些存储单元可以回收、并且对发送进程可用，这就是我们表示一个环形缓冲区的原因==。

接收端的缓冲区操作比较简单。环形缓冲区分成两个区域（表示为白色和灰色）。白色区域包含空存储单元，可以由从网络上接收的字节进行填充。灰色区域表示接收到的字节，可以由接收进程读出。==当某个字节被接收进程读出以后，这个存储单元可被回收，并加入到空存储单元池中==。
#### (2) 段
尽管缓冲能够处理生产进程速度和消费进程速度之间的不相称问题，但在发送数据之前，还需要多个步骤。

IP层作为TCP服务的提供者，需要以分组的方式、而不是字节流的方式发送数据。==在传输层，TCP将多个字节组合在一起成为一个分组，这个分组称为**段**== `segment` 。

TCP给每个段添加头部（为了控制的目的），并将该段传递给IP层。**段被封装到IP数据报中，然后再进行传输**。整个操作对接收进程是透明的。稍后，会看到==这些段可能被**无序接收、丢失、或者损坏**和重发。所有这些均由TCP处理，接收进程不会觉察到任何操作==。图23.15表示了在缓冲区中如何从字节生成段。
![图23.15 TCP中的段](https://img-blog.csdnimg.cn/59f58b7c3a9741a1b92c2b86e99e7dee.png)
> 注意：**段的大小不必相同**。为了简单起见，在图23.15中只表示了一个包含 $3$ 个字节的段和另一个包含 $5$ 个字节的段。实际的段可能包含数百（或者数千）个字节。
### 3. 全双工通信
TCP提供**全双工服务** `full-duplex service` ，即**数据可以在同一时间双向流动**。**每一方TCP都有发送和接收缓冲区，它们能在双向发送和接收段**。
### 4. 面向连接的服务
与UDP不同，TCP是一种面向连接的协议。站点 $A$ 的一个进程要发送和接收来自站点 $B$ 的另外一个进程的数据时，步骤如下：
1. 在两个TCP之间建立一个连接；
2. 在两个方向交换数据；
3. 连接终止。

> 注意：**这是一个虚连接，而不是一个物理连接**。TCP段封装成IP数据报，并且可能被无序地发送、或丢失或被破坏，然后重发。每个段都可以通过不同的路径到达目的端。==虽然不存在物理连接，但TCP会建立一种面向字节流的环境，在这种环境中，**TCP能承担「按顺序传递这些字节到其他站点的任务」**==。这就好像建立了横跨多个岛屿的一座桥，以单一的连接从一个岛屿到另一个岛屿传送所有字节。

### 5. 可靠的服务
TCP是一种可靠的传输协议。它使用**确认机制**来检查数据是否安全和完整地到达。在后面进一步讨论差错控制的特点。

## 23.3.2 TCP特点
为了提供上一节中提到的服务，TCP有几个特性，本节将简要概述这些特性，并在后面进行详细讨论。
### 1. 序号系统
虽然TCP软件能够记录被其发送或接收的段，但是在段的头部没有段序号 `segment number` 字段。相反，有两个字段，称为**序号** `sequence number` 和**确认号** `acknowledgment number` 。**这两个字段指的是字节序号，而不是段序号**。
### 2. 字节序号
**TCP给在一个连接中传输的所有数据字节编号** `TCP numbers all data bytes that are transmitted in a connection` 。**在每个方向上序号都是独立的**。当TCP接收来自进程的一些数据字节时，它会将其存储在发送缓冲区中、并给它们编号。

==不必从 $0$ 开始编号，TCP在 $0$ 到 $2^{32}-1$ 之间生成一个随机数，作为第一个字节的序号==，例如，如果随机数是 $1057$ ，并且发送的全部字节个数是 $6000$ ，那么这些字节序号是 $1 057 \sim 7056$ 。下面将会看到，**字节序号用于流量和差错控制**。==序号字节被编号后，TCP对发送的每一个段分配一个序号，每个段序号是这个段中的第一个字节的序号==。

【例23.3】假设一个TCP连接正在传送一个 $5 000$ 字节的文件，第一个字节序号是 $10 001$ 。如果数据被分成 $5$ 个段，每一个数据段携带 $1000$ 字节，试问每个段的序列号是什么？
解：每个段的序号如下所示：
- 段 $1 →$ 序号：$10001$（范围：$10001\sim 11000$）
- 段 $2→$ 序号：$11 001$（范围：$11001\sim 12000$）
- 段 $3 →$ 序号：$12001$（范围：$12001\sim 13000$）
- 段 $4→$ 序号：$13 001$（范围：$13 001\sim 14000$）
- 段 $5 →$ 序号：$14001$（范围：$14001\sim 16000$）

当一个段携带数据和控制信息（捎带）时，它使用一个序号。**如果一个段没有携带用户数据，那么它逻辑上不定义序号**，虽然字段存在，但值是无效的。然而，==有些段当仅携带控制信息时，也需要有一个序号用于接收方的确认。**这些段用做连接建立、连接终止或连接废弃**== `connection establishment, termination, or abortion` 。这些段中的每一个，好像携带一个字节那样使用一个序号，但都没有实际的数据，如果随机产生的序号是 $x$ ， 则第一个数据字节的编号是 $x+1$ ，字节 $x$ 被认为是一个伪字节 `phony byte` ，用于控制段打开一个连接 `used for a control segment to open a connection` ，我们不久将会见到。
### 3. 确认号
正如前面讨论的那样，TCP中的通信是全双工的；当建立一个连接时，双方同时都能发送和接收数据。**每一方对字节编号，通常使用不同的起始字节号**，每一方向的序号表明了该段所携带的第一个字节的序号 `The sequence number in each direction shows the number of the first byte carried by the segment` 。

每方也使用一个确认号来确认它已收到的字节。但是，确认号定义了「**该方预期接收的下一个字节的序号**」`the number of the next byte that the party expects to receive` 。另外，**确认号是累积的** `cumulative` ，这意味：==接收方记下它已安全而且正确地接收到的最后一个字节的序号，然后将它加 $1$ ，并通告这个结果作为确认号==。在这里，术语"累积"指的是，如果一方使用 $5 643$ 作为确认号，则表示它已经接收了所有从开始到序号为 $5 642$ 的字节。但要注意，这并不是指接收方已经接收了 $5 642$ 个字节，因为第一个字节的编号通常并不是从 $0$ 开始的。
### 4. 流量控制
与UDP不同的是，TCP提供流量控制。**数据的接收方控制发送方发送数据的数量**，这样做是为了**防止接收方数据溢出**。序号系统允许使用面向字节的流量控制。
### 5. 差错控制
为了提供可靠的服务，TCP有一个差错控制机制。虽然**差错控制以段作为差错检测（丢失或损坏段）的数据单元**，稍后我们将会看到**面向字节的差错控制**。
### 6. 拥塞控制
与 UDP不同的是，TCP考虑网络中的拥塞。==发送方发送的数据量不仅由接收方控制（流量控制），而且还要由网络中的拥塞程度决定==。即发送窗口 $=\min (rwnd, cwnd)$ 。

在我的实验室中，客户端 10.32.106.159 向 DNS 服务器10.32.106.103 发起一个 DNS 查询，以期获得 paddy_cifs.nas.com 所对应的 IP 地址。
1．DNS 默认使用 UDP 的情况下（见图 1）：
```bash
[root@shifm1 ~]# nslookup
> paddy_cifs.nas.com
Server: 10.32.106.103
Address: 10.32.106.103#53
Name: paddy_cifs.nas.com
Address: 10.32.106.77
>exit
```
图 1
这个过程的所有网络包如图 2 所示：

图 2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130921838.png)
2．**用 set vc 强制 DNS 使用 TCP 的情况下**（见图 3）：
```java
[root@shifm1 ~]# nslookup
> set vc
> paddy_cifs.nas.com
Server: 10.32.106.103
Address: 10.32.106.103#53
Name: paddy_cifs.nas.com
Address: 10.32.106.77
>exit
```
图 3
这个过程的所有网络包如图 4 所示：
图 4
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130924384.png)
从这两种情况的截图可以看到，真正起查询作用的只有两个 DNS 包。
客户端：“paddy_cifs.nas.com 的 IP 是多少啊？”
服务器：“是 10.32.106.77。”
在使用 UDP 的情况下，的确只用这两个包就完成了 DNS 查询。但==在使用 TCP时，要先用 3 个包（包号 1、2、3）来建立连接。查询结束后，又用了 4 个包（包号 7、8、9、10）来断开连接==。Wireshark 把这两种情况的差别完全显示出来了。

我们可以从中看到连接的成本远远超过 DNS 查询本身，这对繁忙的 DNS 服务器来说无疑是巨大的压力。**如果你的 DNS 还在使用 TCP，该考虑更改了**。连接当然要付出代价，但带来的好处也很多，这就是为什么多数应用层协议还是基于 TCP 的原因。在以后的章节里，将从 Wireshark 看到 TCP 的巨大优势，

不过在此之前，**一定要理解 TCP 的工作原理**。Wireshark 上能看到很多 TCP 参数，**理解了它们就是学习 TCP 最好的开始**。图 5 是 10.32.106.159 往 10.32.106.62 传数据的过程。我已经把一些参数用黑框标志出来，以便阅读时参照。
图 5
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130925581.png)
- Seq：表示该数据段的**字节序号**，如图 5 中的 Seq＝3681。
    **TCP 提供有序的传输**，所以每个数据段都要标上一个序号。==当接收方收到乱序的包时，有了这个序号就可以重新排序了==。我们不一定要知道 Seq 号的起始值是怎么算出来的，但**必须理解它的增长方式**。如图 6 所示，数据段 1 的起始 Seq 号为 1，长度为 1448（意味着它包含了 1448 个字符），那么数据段 2 的 Seq 号就为 1+1448=1449。数据段 2 的长度也是 1448，所以数据段 3 的 Seq 号为 1449+1448=2897。也就是说，**一个 Seq 号的大小是根据上一个数据段的 Seq 号和长度相加而来的**。
    图 6
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130926571.png)
    图 5 的 Wireshark 截屏也显示了相同的情况，51 号包的 Seq=3681，Len=1448，所以 52 号包的 Seq=3681+1448=5129。这个 Seq 号是由这两个包的发送方，也就是 10.32.106.159 维护的。
    
    ==由于 TCP 是双向的，在一个连接中双方都可以是发送方，所以各自维护了一个 Seq 号==。53 号包和 56 号包的 Seq 号是 10.32.106.62 维护的，由于 53 号包的 Seq=885，Len=0，所以 56 号包的 Seq=885+0=885。
- Len：该数据段的长度，如图 5 中的 Len=1448，**注意这个长度不包括 TCP 头**。图 5 中虽然 10.32.106.62 发出的两个包 Len=0，**但其实是有 TCP 头的**。头部本身携带的信息很多，所以**不要以为 Len=0 就没意义**。
- Ack：**确认号**，如图 5 中的 Ack＝6577，**接收方向发送方确认已经收到了哪些字节**。比如甲发送了“Seq: x Len: y”的数据段给乙，那**乙回复的确认号就是 x+y，这意味着它收到了 x+y 之前的所有字节**。同样以图 5 为例，52 号包的 Seq=5129，Len=1448，所以来自接收方的 53 号包的 Ack=5129+1448=6577，表示收到了 6577之前的所有字节。==理论上，接收方回复的 Ack 号恰好就等于发送方的下一个 Seq 号==，所以我们可以看到 54 号包的 Seq 也等于 5129+1448=6577。
    你也许想问 51 号包为什么没有对应的确认包呢？其实 **53 号包确认 6577 的时候，表示序号小于 6577 的所有字节都收到了**，相当于把 51 号发送的字节也一并确认了，也就是说 **TCP 的确认是可以累积的**。
    ==在一个 TCP 连接中，因为双方都可以是接收方，所以它们各自维护自己的Ack 号==。本例中 10.32.106.62 没有发送任何字节，所以 10.32.106.159 发出的 Ack 号一直不变。

你可能要花些心思来学习这几个参数，不过付出是值得的。**因为一旦理解了
它们，接下来学习 TCP 的特性就会水到渠成**。
- 比如**当包乱序时，接收方只要根据 Seq 号从小到大重新排好就行了**，这样就保证了 TCP 的有序性。
- 再比如有包丢失时，接收方通过前一个 Seq+Len 的值与下一个 Seq 的差，**就能判断缺了哪些包**，这保证了 TCP 的可靠性。

我们举个例子来说明这两种状况，以下 3 个包到达了接收方（见表 1）：
表 1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130930635.png)
很明显，从 Seq 号可见它们的顺序是乱的。重新排序之后应该是下面这个样子（见表 2）：
表 2
```java
Seq:101 Len:100
Seq:301 Len:100
Seq:401 Len:100
```
**排序完之后还是有问题**。第一个包的 Seq+Len=101+100=201，意味着下一个包本应该是 Seq:201，而**不是实际收到的 Seq:301**。由此**接收方可以推断，
“Seq:201”这个包可能已经丢失了**。于是**它回复 Ack:201 给发送方，提醒它重传 Seq:201**。

## 23.3.3 段格式
在更详细地讨论TCP之前，讨论TCP分组本身。在TCP中的分组称为**段** `segment` 。 段的格式，如图23.16所示。
![图23.16 TCP段格式](https://img-blog.csdnimg.cn/89cffa52e49d443db746fb8f696822ae.png)

段包括 $20$ 字节到 $60$ 字节的头部，接着是来自应用程序的数据。==如果没有选项，那么头部是 $20$ 字节。如果有选项，最多是 $60$ 字节==（IPv4的头部结构长度为 $20$ 字节，若含有可变长的选项部分，最多 $60$ 字节）。在本节中，将讨论某些头部字段，以了解这些字段的意义和目的。
- **源端口地址**。这是一个 $16$ 位的字段，它定义了在主机中「发送该段的应用程序的端口号」。这与UDP头部的源端口地址的作用一样。
- **目的端口地址**。这是一个 $16$ 位的字段，它定义了在主机中「接收该段的应用程序的端口号」。这与UDP头部的目的端口地址的作用一样。
- **序列号**。这个 $32$ 位的字段**定义了一个数，它分配给段中数据的第一个字节**。如前所述，TCP是一种**字节流传输协议**。为了确保连通性，对要发送的每一个字节都进行编号。序列号告诉目的端，「在这个序列中的哪一个字节」是「该段的第一个字节」`which byte in this sequence comprises the first byte in the segment` 。在连接建立时，每一方都使用随机数生成器产生一个**初始序列号** `initiaI sequence number, ISN` ，通常每一个方向的 `ISN` 都不同。
- **确认号**。这个 $32$ 位的字段定义了「**段的接收方期望从对方接收的字节号**」。==如果段的接收方成功地接收了对方发来的字节号 $x$ ， 它就将确认号定义为 $x + 1$ 。确认和数据可捎带一起发送== `be piggybacked together` 。
- **头部长度**。这个 $4$ 位的字段 `HLEN` ，指明了TCP头部中共有多少个 $4$ 字节长的字。头部的长度可以在 $20$ 字节到 $60$ 字节之间。因此，这个字段的值在 $5\ (5 \times 4=20)$ 到 $15\ (15 \times 4 = 60)$ 之间。
- **保留** `Reserved` 。这个 $6$ 位的字段保留为将来使用。
- **控制** `Control` 。这个字段定义了 $6$ 种不同的**控制位或标记**，如图23.17所示。在同一时间可设置一位或多位。
![图23.17 控制字段](https://img-blog.csdnimg.cn/ccfbc79c9a3f4a0eaaf299adeaf8a4ab.png)
	==这些位用在TCP的流量控制、连接建立和终止、连接失败和数据传送方式等方面==。表23.3显示了每位的说明。当讨论TCP的详细操作时，对它们做深入的讨论。
![表23.3 控制字段的标志描述](https://img-blog.csdnimg.cn/d2ecd038e5674eef85d278adb332dbd2.png)
- **窗口大小** `Window size` 。这个字段定义「**对方必须维持的窗口的大小**」（以字节为单位）。注意：这个字段的长度是 $16$ 位，这意味着窗口的最大长度是 $65 535$ 字节。这个值通常称为**接收窗口** `receiving window, rwnd` ，**它由接收方确定**。此时，**发送方必须服从接收端的支配**。
- **校验和**。这 $16$ 位的字段包含了校验和。==TCP校验和的计算过程，与前面描述的UDP所采用的计算过程相同==。但是，在UDP数据报中校验和是可选的。然而，**对TCP来说，将校验和包括进去是强制的**，起同样作用的伪头部被加到段上。**对TCP伪头部，协议字段的值是 $6$** 。
- **紧急指示符** `Urgent pointer` 。这个 $16$ 位的字段**只有当紧急标志置位时才有效**。==这个段包含了紧急数据，它定义了必须加到序列号上的一个数，以获取数据段中最后一个紧急字节的编号==，稍后将会讨论它。
- **选项** `Options` 。在TCP头部中可以有多达 $40$ 字节的可选信息。这里不讨论这些选项，更多信息参见参考文献。

## 23.3.4 TCP连接
TCP是一种面向连接的协议。面向连接的传输协议会在源端和目的端之间，建立一条**虚路径**。然后，属于一个报文的所有段都沿着这条虚路径发送。整个报文使用单一的虚路径，有利于确认处理、以及对损坏或丢失帧的重发。

可能想知道TCP如何使用IP服务，一个无连接协议如何能面向连接？这就是TCP的连接是虚连接，而不是物理连接。==TCP在一个较高层次上操作，TCP使用IP服务向接收方传递独立的段 ` individual segments` ，但它控制连接本身==。
- 如果一个段丢失或损坏了，则重新发送它。与TCP不同，IP不知道这个重新发送过程。
- **如果一个段失序到达，则TCP保存它、直到缺少的段到达**。IP是不知道这个重新排序过程的。

在TCP中，面向连接的传输需要三个过程：连接建立、数据传输和连接终止。
除了这几个参数，TCP 头还附带了很多**标志位**，**在 Wireshark 上经常可以看到下面这些**。
- SYN：携带这个标志的包表示正在发起连接请求。==因为连接是双向的，所以建立连接时，双方都要发一个 SYN==。
- FIN：携带这个标志的包表示正在**请求终止连接**。==因为连接是双向的，所以彻底关闭一个连接时，双方都要发一个 FIN==。
- RST：用于**重置一个混乱的连接**，或者**拒绝一个无效的请求**。

如图7所示，我故意尝试连接一台Linux服务器的445端口（一般只有Windows
上才开启这个端口，Wireshark 上把该端口显示为 microsoft-ds），结果就被 RST 了。

当然这个实验属于“没事找抽型”，==实际环境中的 RST 往往意味着大问题。如果
你在 Wireshark 中看到一个 RST 包，务必睁大眼睛好好检查==。
图 7
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130934425.png)

了解了这些参数和标志位，我们就可以学习 **TCP 是如何管理连接的**了。图 8
是一个标准的连接建立过程：
图 8
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130934999.png)
这三个包就是传说中的“三次握手”。事实上，**握手时 Seq 号并不是从 0 开始的**。我们之所以在 Wireshark 上看到 Seq=0，是因为 Wireshark 启用了 Relative Sequence Number。如果你想关闭这个功能，可以在 Edit-->Preferences-->protocols-->TCP 里设置。

握手过程可以用图 9 来表示。
图 9
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130935553.png)
如果用文字来表达，过程就是这样的。
客户端：“我能跟你建立连接吗？我的初始发送序号是 X。如果你答应就
Ack=X+1。”
服务器：“收到啦，Ack=X+1。**我也想跟你建立连接**。我的初始发送序号是 Y，
你如果答应连接就 Ack＝Y+1。”
客户端：“收到啦，Ack＝Y+1。”

为什么要用三个包来建立连接呢，用两个不可以吗？其实也是可以的，**但两
个不够可靠**。我们可以设想一个情况来说明这个问题：某个网络有多条路径，客户端请求建立连接的第一个包跑到一条延迟严重的路径上了，所以迟迟没有到达
服务器。因此，客户端只能当作这个请求丢失了，不得不再请求一次。由于第二
个请求走了正确的路径，所以很快完成工作并关闭了连接。对于客户端来说，事
情似乎已经结束了。没想到它的第一个请求经过跋山涉水，还是到达了服务器。
如图 10 所示，服务器并不知道这是一个旧的无效请求，所以按照惯例回复了。
- 假如 TCP 只要求两次握手，服务器上就这样建立了一个无效的连接。
- 而在三次握手的机制下，客户端收到服务器的回复时，知道这个连接不是它想要的，所以就发一个拒绝包。服务器收到这个包后，也放弃这个连接。
    图 10
    ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130936044.png)

经过三次握手之后，连接就建立了。双方可以利用 Seq、Ack 和 Len 等参数
互传数据。传完之后如何断开连接呢？图 11 就是 TCP 断开连接的“四次挥手”
过程。
图 11
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130948003.png)

客户端：“我希望断开连接（请注意 FIN 标志）。”
服务器：“知道了，断开吧。”
服务器：“我这边的连接也想断开（请注意 FIN 标志）。”
客户端：“知道了，断开吧。”
就这样，双方都关闭了连接。**其实用四次挥手来断开连接也不完全可靠，但
世界上不存在 100%可靠的通信机制**。假如对这个话题感兴趣，可以研究一下著名的“两军问题”，维基百科上有详细介绍，地址为 http://en.wikipedia.org/wiki/
Two_Generals'_ Problem。

==工作中如果碰到断开连接的问题，可以使用 netstat 命令来排查，无论在
Windows 还是 Linux 上，这个命令都能把当前的连接状态显示出来==。不过老话常说，**最推荐的工具还是 Wireshark**。

第 13 章
网络在传输什么——数据流功能
我们经常会在访问某个网站时，却不小心下载了木马的情形。尤其让人感到郁闷的是，
下载木马的过程完全是不可见的。不过即便如此，这个木马文件仍然需要以数据包的形式
进行传输，所以我们完全可以用 Wireshark 来检测到它。
最初设计 Wireshark 的目的是用来检查网络中的问题，不过随着使用者技能的不断娴
熟，他们也发现了 Wireshark 还可以胜任更多的任务，而网络取证就是其中重要的一项。取
证者只需要监控网络中的通信，就可以清楚地发现网络中用户的行为。例如某个用户从外
网下载了什么文件，或者它通过电子邮件向外发送了什么文件等。
既然用户可能是使用各种不同的应用程序传输的文件，为什么 Wireshark 都可以对其
进行解析呢，有人可能会此感到困惑。其实这些应用程序在应用层可能使用不同的协议，
但是它们在传输数据时传输层采用的大多数采用的是 TCP 协议，只不过一个完整的文件会
被分割成多个数据包进行传输。这些有顺序的数据包就被称作流，而 Wireshark 中提供了一
个“流跟踪（TCP Stream）”功能。利用这个功能，Wireshark 就可以将捕获到所有的通信
数据包重组成完整的会话或者文件。
在这一章中，我们将就如下主题展开介绍：
• TCP 中的数据传输；
• Wireshark 中的 TCP 流功能；
• 网络取证实践。
13.1 TCP 的数据传输
我们对 TCP 连接的建立方式已经不陌生了，现在来了解一下 TCP 连接建立之后的数
异步社区云云云(18169257213) 专享 请尊重版权
186 第 13 章 网络在传输什么—— 数据流功能
据传输。当客户端和服务端之间建立好连接之后，就可以通过这个连接来传递数据了。客
户端和服务端可以同时通过这个连接向对方发送消息。TCP 在进行数据的传输时提供了可
靠的数据传输服务，这一点指的是彼此通信的应用进程可以通过 TCP 无错的顺序传递所有
数据，中间不会有字节的丢失或重复。但是 TCP 协议仅仅能保证全部数据传递的准确性，对
传输的速度是不能保证的。
下面我们来具体分析一下 TCP 数据传输的过程，这是一个由服务器向客户端传递数据
的实例。
（1）服务器在发送的数据包中设置 tcp.flags.push = 1，tcp.flags.ack =1。图 1 就给出
了一个设置了 tcp.flags.push 和 tcp.flags.ack 标志位的数据包实例。
图 1 设置 tcp.flags.push = 1，tcp.flags.ack =1 的数据包
（2）服务器会将要传输的数据添加到数据包的 Data 部分（见图 2）。
图 2 数据包的 Data 部分
异步社区云云云(18169257213) 专享 请尊重版权
13.2 Wireshark 中的 TCP 流功能 187
（3）服务器将这个数据包发送出去。
在这个网络数据传输过程中，有用的 Wireshark 显示过滤器包括以下几个。
• data：只显示包含数据的数据包（见图 3）。
图 3 使用 data 作为显示过滤器
• data && ip.addr==10.0.0.221。
• tcp.flags.push == 1。
• tcp.flags.push == 1 && ip.addr==10.0.0.221。
• tcp.flags == 0x0018：显示所有的 PSH，ACK 数据包。
• tcp.flags == 0x0011：显示所有的 FIN 和 ACK 数据包。
• tcp.flags == 0x0010：显示所有的 ACK 数据包。
13.2 Wireshark 中的 TCP 流功能
在上一节中已经了解了 TCP 数据包中是如何传输数据的，当我们在监测一个网络时这
一点是十分有用的。如果我们需要在网络中进行取证，那么查看这些数据的具体内容则是
十分重要的，例如一台主机向外部传输数据时，到底传输的是一张图片，还是一个木马文
件呢？
下面给出在 Wireshark 中还原数据的方式，我们仍然使用 Wireshark 官方提供的样
例包。
首先选中数据包列表中一个任意的会话数据包，在这个数据包中单击鼠标右键，然后
在弹出的菜单中依次选中“追踪流”→“TCP 流”。这种方法在检测 TCP 流的内容时是一
种绝佳的选择，它避免了我们对数据包进行逐个检查的烦琐操作。尤其是在服务器和客户
端之间出现故障的时候，使用这种方法非常有用。
如图 4 所示，Wireshark 中的 File 菜单提供了“Export Objects”功能，这个功能可
以导出 HTTP 和 TCP 数据流中的文件。
异步社区云云云(18169257213) 专享 请尊重版权
188 第 13 章 网络在传输什么—— 数据流功能
图 4 Wireshark 中的“Export Objects”功能
但是这种方法经常会出现错误，造成导出的文件并不完整，因此我们再介绍另外一种
方法。
我们以 http_witp_jpegs.cap 为例，在这次传输过程中由服务端向客户端传送了一个文
件，这里就以还原这个文件为例。如图 5 所示，其中序号为 269 的数据包中内容如下。
图 5 选中序号为 269 的数据包
如图 6 所示，我们在这个数据包上单击鼠标右键，然后再依次选中“追踪流”|
“TCP 流”。
图 6 选中“追踪流”|“TCP 流”
异步社区云云云(18169257213) 专享 请尊重版权
13.2 Wireshark 中的 TCP 流功能 189
当我们对一个数据包进行“追踪流”的操作时，这时就会自动创建并应用一个显示过
滤器。图 7 就展示了一个应用了“追踪流”窗口。注意在这个数据流被选中之后创建显
示过滤器的语法。
图 7 追踪数据流 17
整个数据流会在一个单独的窗口中显示出来，这个窗口中的全部数据以两种颜色显示，
其中红色用来标明从源地址前往目的地址的流量，而蓝色用来区分出相反方向也就是从目
的地址到源地址的流量。通常连接是由客户端主动发起的，因此显示的颜色为红色，如图
8 所示。
图 8 整个数据流的内容
我们需要过滤掉其中的 GET 请求，具体方法是单击左侧的下拉列表框，然后选中
“10.1.1.1-10.1.1.101”（见图 9）。
图 9 选择单向数据流
异步社区云云云(18169257213) 专享 请尊重版权
190 第 13 章 网络在传输什么—— 数据流功能
然后在右侧的“显示和保存数据为”后选择“原始数据”（见图 10）。
图 10 显示和保存为“原始数据”
保存的时候，你可以随意指定一个文件名，但是扩展名需要指定为.bin，例如
Capture_picture.bin。这个文件中除了包含目标图片之外，还包含了一些多余的数据，接下
来就需要使用 WinHex 将其去除掉。
WinHex 是一款极为精巧的文件编辑工具，你可以在互联网上很容易地下载到它，大小
只有几 MB。如图 11 所示，我们使用 WinHex 打开 Capture_picture.bin，可以看到这个
文件中包含了一些跟图片无关的头部信息，现在需要将这些信息去除掉。
图 11 在 WinHex 打开 Capture_picture.bin
异步社区云云云(18169257213) 专享 请尊重版权
13.2 Wireshark 中的 TCP 流功能 191
仔细观察 Wireshark 中解析的数据流，在“Content-Type: image/jpeg”后面就是图片的
实际内容，在中间有两个换行符。换行符对应的是“0D 0A”，我们在 WinHex 找到
“Content-Type: image/jpeg”，其中的图片是由“0D 0A 0D 0A”后面的内容构成。我们先找
到“0D 0A 0D 0A”（见图 12），然后将其前面（包含“0D 0A 0D 0A”）的所有内容全部
删除。
图 12 删除掉无关内容
这个文件比较方便的是没有多余的尾部信息，所以在去除头部信息之后，我们就可以
将这个文件保存为图片了，这里起名为 Capture_picture.jpeg，如图 13 所示。
图 13 将文件保存起来
异步社区云云云(18169257213) 专享 请尊重版权
192 第 13 章 网络在传输什么—— 数据流功能
下面你就可以使用任意的一个图片查看工具来查看这张图片。
13.3 网络取证实践
好了，现在我们已经知道如何从网络通信中导出文件了，这其实也正是网络取证工作
中重要的一个环节。那么现在不妨将学到的内容进行应用，这一方面可以帮助我们巩固前
面的知识，另一方面也可以熟悉一下网络取证工作的思路。
这里我向你推荐一个很有意思的网站，名为 Network Forensics Puzzle Contest，在这个
网站提供了一些很专业的题目帮助我们学习 Wireshark 的使用。国内很多安全类比赛的题目
也都源于这个网站。我们来看一下里面提供的第一个网络取证题目：Ann 使用 AIM 做了什么？
题目信息如下：
Anarchy-R-Us 公司怀疑他们的雇员 Ann Dercover 是一个为竞争对手工作的特工，她有
机会获得公司的重要机密。安全人员担心 Ann Dercover 有可能会泄露这些机密。
这些安全人员一直在监视 Ann Dercover 的活动，但是到目前为止还没有任何可疑的行
为。不过就在今天，一个从未使用过的笔记本电脑连接到了公司的无线网络中，工作人员
推测是有人在停车场中使用它，因为大楼内部没有任何陌生人。而 Ann Dercover 的计算机
（192.168.1.158）则将一些信息通过无线网络发送到这台计算机，而之后不久她就消失了。
“我们捕获到了他们通信时的数据包”安全人员说，“但是我们并不知道发生了什么，
你能帮忙吗？”
好了，现在你就是这个安全取证工作人员，现在你的任务就是弄清楚 Ann 在和谁联系，
她发送了什么，并取得如下的证据。
（1）和 Ann 通信的好友（buddy）叫什么名字？
（2）在这次通信时发出的第一条消息是什么？
（3）Ann 传送了一个文件，这个文件的名字为什么？
（4）这个文件中 Magic number
①是什么（即最前面的 4Bytes）？
（5）这个文件的 MD5 值为多少？
① Magic number，即幻数，它可以用来标记文件或者协议的格式，很多文件都有幻数标志来表明该文件的格式。一般而言，
硬盘数据恢复软件（如 EasyRecovery），就是靠分析磁盘上的原始数据，然后根据文件幻数来试图匹配文件格式，从而尝试识
别出磁盘中那些已经从文件系统登记表中删除的文件（真实的文件内容可能没有被覆盖）。
异步社区云云云(18169257213) 专享 请尊重版权
13.3 网络取证实践 193
（6）这个文件的内容是什么？
我们先来看第一个题目，和 Ann 通信的好友（buddy）叫什么名字？首先使用 Wireshark
打开刚刚捕获到的 evidence01.pcap 文件。现在我们可以肯定的是，Ann 使用了某种通信工
具在和外界进行通信，那么她使用的是什么呢？ICQ、Skype 还是 QQ？（注意，其实这个
问题在题目中已经给出了答案，这里为了拓宽读者的思路，所以假设事先不知道结果。）这
里我们可以在数据包中来一查究竟。经过仔细观察之后，我们除了开始的一些 ARP 和 TCP
数据包之外，第 23 个数据包显示使用了 SSL 协议，这是一个加密的格式，我们猜测这就
是 Ann 在和外界通信时产生的数据包。虽然它的内容采用了加密的格式，但是它的 IP 协议
头部却给带来了我们了一个惊喜，这个数据包的目的地址是 64.12.24.50（见图 14）。
图 14 查看到的目的地址
在前面的章节中，我们已经为 Wireshark 添加了显示地理位置的插件，所以这里可以
直接查看这个数据包的目的地址（见图 15）。
图 15 目的地址的详细信息
这里我们看到了这个数据包发往了“AOL Transit Data Network”，国内的用户对于 AOL
可能有些陌生，不过它在美国可是非常有名的。不过我们可以求助于搜索引擎，在百度里
异步社区云云云(18169257213) 专享 请尊重版权
194 第 13 章 网络在传输什么—— 数据流功能
面搜索“AOL 通信工具”，很快就得到了有用的信息（见图 16）。
图 16 在百度中搜索到的 AOL 信息
原来这就是 Ann 所使用的通信工具——AIM，另外我们还查询到了这个工具使用的是
443 端口。那么接下来就好办了，Wireshark 早就已经提供了对 AIM 信息的解析方法。这里
我们只需要将 SSL 加密的数据包重新解析为 AIM 格式即可。首先在第 23 个数据包上单击
鼠标右键，然后选择“Decode as”选项，就可以打开相应的对话框了（见图 17）。
图 17 Wireshark 的“Decode as”窗口
这个对话框一共分成 5 个部分，第 1 个 Field 表示使用端口的类型，第 2 个 Value 表示使
用的端口值，第 3 个 Type 表示类型，第 4 个为默认的解析协议，第 5 个为用户要指定的解析
协议。对这里面的信息进行修改，我们的目的是凡是使用 443 端口的通信都使用 AIM 进行解
析。那么将 Field 修改为 TCP Port，将 Value 修改为 443，将 Current 修改为 AIM（见图 18）。
图 18 将 SSL 加密的数据包重新解析为 AIM 格式
异步社区云云云(18169257213) 专享 请尊重版权
13.3 网络取证实践 195
好了设置完成之后，我们就可以单击 Save 按钮保存设置，然后在数据包列表面板中
查看所有的信息。这里面原来显示为 SSL 的数据包，现在都已经显示为 AIM 信息了（见
图 19）。
图 19 转换格式之后的数据包
好了，现在我们回到第一个问题上来，和 Ann 通信的好友（buddy）叫什么名字？找到
第一条“AIM Messaging”，也就是第 25 个数据包，展开里面的信息，你会发现它分成了两
层“AOL Instant Messenger”和“AIM Messaging，Outgoing”（见图 20）。我们依次展开
两层，很快就找到了答案。Ann 联系的好友的名称原来就是 Sec558user1。
图 20 显示的 Buddy 字段内容
第 2 个问题是在这次通信时发出的第一条消息是什么？这个问题就简单多了，展开第
一条 AIM Messaging 这个数据包的 TLV 部分，即可得到答案（见图 21）。
图 21 这次通信时发出的第一条消息
异步社区云云云(18169257213) 专享 请尊重版权
196 第 13 章 网络在传输什么—— 数据流功能
第 3 个问题，Ann 传送了一个文件，这个文件的名字为什么？我们在 Wireshark 中使用
“data”作为显示过滤器来查看哪些数据包中包含的数据（见图 22）。
图 22 使用“data”作为显示过滤器
在这里面选择一个数据包，然后单击鼠标右键选择 Follow→TCP Stream，打开的窗口
如图 23 所示。好了，其实我们不用提取这个文件，就已经看到了这个文件的名称是
recipe.docx 了。
图 23 在 TCP 数据流中看到的文件名
第 4 个问题，这个文件中 Magic number 是什么（最前面的 4Bytes）？我们按照第 2 节
中介绍的方法将数据流中的文件提取出来，将这个文件保存为 evidence01.raw，然后使用
winhex 打开，这个文件实际内容是从 recipe.docx 后面开始的，根据题目中给出的提示答案
为最前面的 4 个 bytes，所以是“50 4B 03 04”（见图 24）。这里面涉及一些文件格式方
面的知识，大家如果感兴趣的话可以去参考一些相关的资料。
异步社区云云云(18169257213) 专享 请尊重版权
13.3 网络取证实践 197
图 24 文件最前面的 4Bytes
然后我们将这个 PK 前面的部分删除掉，再保存为 recipe.docx（见图 25）。
图 25 保存的 recipe.docx
第 5 个问题是这个文件的 MD5 值是多少？
计算 MD5 的值其实和 Wireshark 没有什么关系，但是在取证方面却很重要，这相当于
给文件添加了一个身份证，以防止它被篡改。你可以使用任何的 MD5 工具来计算它的 MD5
值，这个题目最后的答案为 8350582774e1d4dbe1d61d64c89e0ea1，如图 26 所示。
图 26 计算文件的 MD5 值
第 6 个问题，这个文件的内容是什么？在解答第 4 个问题的时候，我们已经将网络中
的 TCP 数据流保存成 recipe.docx，现在只需要打开这个 word 文档，就可以看到里面的内
容了，如图 27 所示。
异步社区云云云(18169257213) 专享 请尊重版权
198 第 13 章 网络在传输什么—— 数据流功能
图 27 还原的 word 文档
好了，整个探案过程到此为止了，是不是很有感觉很有意思呢？
13.4 小结
在上一章中，我们介绍了 SYNFlood 攻击技术，这种技术是建立在 TCP 连接的 3 次握
手过程之上的。本章紧随其后地介绍了 TCP 数据的传输，并详细讲解了 Wireshark 中的数
据流功能，利用这个功能可以监控整个网络中传输的文件。在本章的最后，你将学到的知
识进行了实践，这里提供了一个非常优秀的 Wireshark 学习网站。还有很多极为优秀的测试
题目，读者可以借此体会一下职业的安全取证专家是如何工作的。
在下一章，我们将会又开始另一种拒绝服务攻击的讲解，不过这种攻击方式是建立在
UDP 协议基础上的。

### 1. 连接建立
**TCP以全双工方式传输数据**。当两个机器中的两个TCP建立连接后，它们就能够同时向对方发送段。这就表示，在传输数据之前，每一方都必须对通信进行初始化，并得到对方的认可 `each party must initialize communication and get approval from the other party before any data are transferred` 。
#### (1) 三次握手
在TCP中连接建立称为**三次握手** `three-way handshaking` 。在例子中，称为客户的应用程序想要与另一个称为服务器的应用程序，使用TCP作为传输层协议建立连接。

**该过程从服务器开始**。==服务器程序告诉它的TCP ，它已准备好接受一个连接。这就称为请求**被动打开**== `passive open` 。虽然TCP己准备好接受从世界上任何一个机器来的连接，**但它自己并不能完成这个连接**。

==客户程序发出请求**主动打开** `active open` 。想要与服务器进行连接的客户告诉它的TCP ，它需要连接到特定的服务器==。**TCP现在就开始如图23.18所示的三次握手过程**。为了表示该过程，我们使用了两个时间序列，每端一个。

每个段头部的所有字段都有值，或许它的某些选项字也有。但是，我们每次仅表示「少数几个必须要知道的字段」，如果**序列号、确认号、控制标记**（仅是其中被置位的）和**窗口大小**等有值，我们就表示它们。这个阶段的三个步骤如下：
1. 客户发送的第一个段是 `SYN` 段。**这个段仅有 `SYN` 标志被置位，它用于序列号同步**（图画错了吧？）。==它占用一个序列号。当数据传输开始时，序号加 $1$== 。我们说 `SYN` 段不携带实际数据，但我们可以认为它是一个字节。
2. 服务器发送第二个段，**两个标志位 `SYN` 和 `ACK` 置位的段，即 `SYN` 和 `ACK` 段**。这个段有两个目的。==它是**另一方向通信的 `SYN` 段**，并用 `ACK` 标志作为对第一个 `SYN` 段的确认。它占用一个序列号==（来自服务器端的、对称的 `SYN` 段，也要占用序列号）。
3. 客户发送第三个段。**这个段仅仅是一个 `ACK` 段，它使用 `ACK` 标志和确认序号字段来确认收到了第二个段**。注意：==这个段的序列号与 `SYN` 段中的序列号相同，`ACK` 段没有占用任何序列号——**`ACK` 段，如果不携带数据，则它不占用序列号**==。？？？？
![图23.18 使用三次握手建立连接](https://img-blog.csdnimg.cn/4b3e3cf38e9544858ea42c8e292fe9e8.png)
#### (2) 同时打开
当两个进程都发出一个**主动打开**时，可能会出现一种罕见的情况，称为**同时打开** `simultaneous open` 。在这种情况下，两个TCP彼此发送 `SYN + ACK` 段，在它们之间建立一条单独的连接 `one single connection is established between them` 。

#### (3) SYN洪泛攻击
在TCP中的连接建立过程，易遭受到称为**SYN洪泛攻击** `SYN flooding attack` 的严重安全问题：==当一个恶意的攻击者将大量的 `SYN` 段发送到一个服务器，在数据报中通过伪装源IP地址，假装这些段来自不同的客户端时，就发生了这种情况==。

假定客户机发出**主动打开**，服务器分配必要的资源，如生成通信表和设置计时器等。然后服务器送 `SYN + ACK` 段给这些假装客户，但这些段都丢失了。然而，在这段期间，许多资源被占用、但没有被使用。**如果在短时间内，`SYN` 段的数量很大，服务器最终会耗尽它的资源而崩溃**。

这种 `SYN` 洪泛攻击，属于一种称为**拒绝服务攻击** `denial-of-service attack` 的安全攻击类型，此时一个攻击者通过大量的服务请求，独占系统，使得系统崩溃、拒绝对每个请求提供服务 `the system collapses and denies service to every request` 。

TCP的某些实现有减轻 `SYN` 攻击影响的策略。==有些实现在特定时间周期内，对连接请求进行限制；另一些实现过滤掉来自「不需要的源地址」的数据报==。一个新的策略是：**使用 `cookie` 推迟资源分配，直到一个完整的连接建立**。新的传输层协议STCP使用这种策略，在下一节讨论。

### 2. 数据传输
连接建立后，可进行双向**数据传输** `data transfer` ，客户端与服务器双方都可发送数据和确认。稍后将学习确认的规则。目前，知道==在同一段内携带确认时，在同一方向上也可以传输数据就行了，这就是数据捎带确认==。

一个例子如图23.19所示，在连接建立后（图中没有表示出），客户端用两个段发送 $2000$ 个字节的数据。然后，服务器用一个段发送 $2000$ 个字节的数据。客户端发送另一个段。==前面三个段携带数据与确认，但是最后一个段仅携带确认、且不占用序列号，这是因为已没有数据发送了==。注意**序列号与确认号的数值**。

==客户端发送的数据段有 `PSH`（急迫）标志，所以服务器TCP知道，当收到数据后立刻传递给服务器进程==。稍后讨论这个标志的用法。另一方面，来自服务器的段没有设置急迫标志。大多数TCP实现都有选项，可设置或不设置此标志。 
![图23.19 数据传输](https://img-blog.csdnimg.cn/d4c5d06c1b774e209b1770aecc3f2053.png)
#### (1) 急迫数据 `Pushing Data`
我们知道，发送方的TCP使用缓冲区，存储来自发送方应用程序的数据流。发送方的TCP可以选择段的大小。接收方的TCP在数据到达时也将数据进行缓存，并当应用程序准备就绪时、或当接收端TCP认为方便时，将这些数据传递给应用程序。**这种灵活性增加了TCP的效率**。

但是，在有些情况下，应用程序并不需要这种灵活性。例如，应用程序与另一方应用程序进行**交互式通信**。一方的应用程序打算将其击键发送给对方应用程序，并希望接收到立即响应。数据的延迟传输和延迟传递，对这个应用程序来说是不可接受的。

TCP可以处理这种精况。**在发送端的应用程序可请求急迫操作**，这就表示：==发送端的TCP不必等待窗口被填满，**它创建一个段就立即将其发送**；发送端的TCP还必须设置急迫位 `PSH` ，以告诉接收端的TCP——这个段所包括的数据，必须尽快地传递给接收应用程序，而不要等待更多数据的到来==。

虽然急迫操作可由应用程序提出，但是**现在的大多数实现却忽视了这些请求**。TCP可以选择使用或不使用这个操作。
#### (2) 紧迫数据 `Urgent Data`
TCP是**面向字节流的、面向连接的、可靠的**协议。这就是说，从应用程序到TCP的数据被表示成一串字节流，数据的每一个字节在流中占有一位置。但是，**在某些情况下，应用程序需要发送紧急字节** `urgent bytes` ，这表示：发送应用程序希望某一块数据由接收应用程序不按序读出。

作为一个例子，假定发送应用程序正在发送数据，以供接收应用程序处理。当处理结果返回时，发送应用程序出现了某些差错。**它希望中止此过程**，但它已发送了大量的数据。如果它发送出异常中止命令 `Control + C` ，这两个字符将被存放在接收端TCP缓冲区的末尾，当所有的数据被处理完毕时，这两个字符才被传递给接收应用程序。

解决这个问题的方法是，发送将 `URG` 位置 $1$ 的段 `a segment with the URG bit set` ：
- 发送应用程序告诉发送端的TCP**这块数据是紧急的**。==发送端的TCP创建段，并将紧急数据放在段的开始，段的其余部分可以包括来自缓冲区的普通数据，头部中的紧急指针字段定义了**紧急数据的结束**和**普通数据的开始**== `the end of the urgent data and the start of normal data` 。
- 当接收端的TCP接收到 `URG` 位置 $1$ 的段时，它就==利用紧急指针的值，从段中提取出紧急数据，并不按序地将其传递给接收应用程序==。
### 3. 连接终止
交换数据双方的任一方（客户或服务器）都可关闭连接，通常它是由客户端发起。当前大多数对连接终止的实现有两个方法：**三次握手** `three-way handshaking` 和**带有半关闭选项的四次握手** `four-way handshaking with a half-close option` 。
#### (1) 三次握手
当前对连接终止的**多数实现是三次握手**，如图23.20所示。
1. 在正常情况下，从客户进程接收到一个关闭命令后，**客户的TCP发送第一个段：`FIN` 段，即其中的 `FIN` 位置位**。注意：`FIN` 段可包含客户机要发送的最后数据块，或如图23.20所示的只是控制段。==如果 `FIN` 段只是控制段、不携带数据，则该段仅占用一个序列号==。
2. 服务器TCP接收到 `FIN` 段后，通知它的进程，并**发送第二个段：`FIN + ACK` 段，证实它接收到来自客户端的 `FIN` 段，同时宣布另一个方向的连接关闭**。这个段还可以包含来自服务器最后数据块。==如果 `FIN + ACK` 段没有携带数据，则该段仅占用一个序列号==。
3. **客户端的TCP发送最后一段：`ACK` 段，证实它接收到来自服务器的 `FIN` 段**。==这个段包含确认号，它是前面接收到来自服务器 `FIN` 段的序号加 $1$ 。这个段不携带数据、也不占用序列号==。
![图23.20](https://img-blog.csdnimg.cn/bf3394e6fef44e50a504b0957923c336.png)

#### (2) 半关闭
==在TCP中，一端可以停止发送数据后，还可以继续接收数据。这就是所谓的半关闭== `half-close` 。虽然任一端都可发出半关闭，但**通常都是由客户端发起的**。==当服务器需要所有数据才能开始处理时，可能会发生半关闭==。

例如，排序是一个很好的例子。当客户端发送数据给服务器进行排序时，服务器需要在开始排序之前接收到全部数据。这意味着，客户端发送完全部数据之后，它在出外/站方向的连接可以关闭，但在入内/站方向必须保持打开状态，才能接收已排序的数据。服务器在接收到数据后，还需要时间进行排序，它的对外方向必须保持打开。

图23.21表示了半关闭的例子。**客户端发送 `FIN` 段半关闭连接，服务器通过发送 `ACK` 段确认半关闭**。从客户端到服务器的数据传输结束，但是服务器还可以发送数据。**当服务器已经发送完被处理的数据时，它发送一个 `FIN` 段，该 `FIN` 段由客户端的 `ACK` 来确认**。
.
==连接半关闭后，数据可从服务器传送给客户端，而确认可从客户端传送给服务器==。注意所用的序列号，**第二个段 `ACK` 没有占用序列号**，虽然客户端已接收了序列号 $y-1$， 正在期望的是 $y$ ， 但服务器的序列号还是 $y - 1$ 。当连接最后关闭时，最后 `ACK` 段的序列号还是 $x$ ，因为没有序列号在该方向的数据传输过程中被消耗。？？？
![图23.21](https://img-blog.csdnimg.cn/9186bc4a6c704d0d9afc5e623c965921.png)

## 23.3.5 流量控制
**快递员的工作策略—TCP 窗口**
假如你是一位勤劳的快递员，要送 100 个包裹到某公司去，怎样送货才科学？最简单的方式是每次送 1 个，总共跑 100 趟。当然这也是最慢的方式，因为往返次数越多，消耗的时间就越长。除了需要减肥的快递员，一般人不会选择这种方式。最快的方式应该是一口气送 100 个，这样只要跑一趟就够了。可惜现实
没有这么美好，往往存在各种制约因素：公司狭小的前台只容得下 20 个包裹，要等签收完了才能接着送；更令人郁闷的是，电瓶车只能装 10 个包裹。综合这两个因素，不难推出**电瓶车的运力是效率瓶颈，而前台的空间则不构成影响**。

==快递送货的策略非常浅显，几乎人人可以理解，而 TCP 传输大块数据的策略
却很少人懂。事实上这两者的原理是相似的==。**TCP 显然不用电瓶车送包，但它也有“往返”的需要**。因为发包之后并不知道对方能否收到，要一直等到确认包到达，这样就花费了一个往返时间。**假如每发一个包就停下来等确认，一个往返时间里就只能传一个包，这样的传输效率太低了**。最快的方式应该是一口气把所有包发出去，**然后一起确认**。但现实中也存在一些限制：
- 接收方的缓存（接收窗口）可能一下子接受不了这么多数据；
- 网络的带宽也不一定足够大，一口气发太多会导致丢包事故。

所以，发送方要知道接收方的接收窗口和网络这两个限制因素中哪一个更严格，然后**在其限制范围内尽可能多发包**。这个一口气能发送的数据量就是传说中的 TCP 发送窗口。（拥塞窗口可以[[Wireshark案例11 工作中的Wireshark：发送方和接收方的顺序混乱，计算在途字节数和估算拥塞点，以及LSO]]

发送窗口对性能的影响有多大？一图胜千言，图 1 显示了发送窗口为 1 个
MSS（即每个 TCP 包所能携带的最大数据量）和 2 个 MSS 时的差别。在相同的往返时间里，右边比左边多发了两倍的数据量。**而在真实环境中，发送窗口常常可以达到数十个 MSS**。
图 1
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130958464.png)
图 2 就是在真实环境中抓的包，抓包时服务器 10.32.106.73 正往客户端
10.32.106.103 发数据。由于**服务器的发送窗口很大**，所以收到读请求之后，它在没有客户端确认的情况下连续发了 10 个包。
图 2
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130958302.png)
接着我把客户端的接收窗口强制成 2920，相当于两个 TCP 包能携带的数据
量。从图 3 中可以看到客户端通过“win=2920”把自己的接收窗口告诉服务器。因
此服务器把发送窗口限制为 2920，**每发两个包就停下来等待客户端的确认**。同样一个 14215 字节的读操作，图 2 只用 1 个往返时间就完成了，而图 3 则用了 6 个。
图 3
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307130959564.png)
为了更好地说明这个过程，我把 27 号包到 32 号包用对话的形式表示出来，括号内的文字为我添加的注释。
27 号包：客户端：“当前我的接收窗口是 2920。”
28 号包：服务器：“（好，那我的发送窗口就定为 2920。）先给你 1460 字节。”
29 号包：服务器：“再给你 1460 字节。（哎呀！我的发送窗口 2920 用完了，不能再发了。）”
30 号包：客户端：“你发过来的 2920 字节已经处理完毕，所以现在我的接收窗口又恢复到 2920。”
31 号包：服务器：“（好，那我再把发送窗口定为 2920。）给你一个 1460 字节。”
32 号包：服务器：“再给你 1460 字节。（哎呀！我的发送窗口 2920 又用完了，不能再发了。）”

你也许有个疑问，本文的开头不是说有两个限制因素吗？这个例子只提到了
接收窗口对发送窗口的限制，那网络的影响呢？由于**网络的影响方式非常复杂**，所以本文暂时跳过。下一篇文章将作详细介绍。

不知道出于何种原因，TCP 发送窗口的概念被广泛误解，比如，很多人会把接收窗口误认为发送窗口。我经常想在论坛上回答相关提问，却不知道该从何答起，因为有些提问本身就基于错误的概念。下面是一些经常出现的问题。
1．如图 4 的底部所示，**每个包的 TCP 层都含有“window size:”（也就是 win=）的信息**。这个值表示发送窗口的大小吗？
图 4
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131001436.png)
这不是发送窗口，而是**在向对方声明自己的接收窗口**。在此例子中，10.32.106.103 向 10.32.106.73 声明自己的接收窗口是 64093 字节。10.32.106.73 收到之后，就会把自己的发送窗口限制在 64093 字节之内。**很多教科书上提到的滑动窗口机制，说的就是这两个窗口的关系**，本文就不再赘述了。

假如接收方处理数据的速度跟不上接收数据的速度，缓存就会被占满，从而**导致接收窗口为 0**。如图 5 的 Wireshark 截屏所示，**89.0.0.85 持续向 89.0.0.210 声
明自己的接收窗口是 win=0**，所以 **89.0.0.210 的发送窗口就被限制为 0，意味着那段时间发不出数据**。
图 5
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131002115.png)
2．我如何在包里看出发送窗口的大小呢？
很遗憾，没有简单的方法，有时候甚至完全没有办法。因为，当发送窗口是
由接收窗口决定的时候，我们还可以通过“window size:”的值来判断。而当它由
网络因素决定的时候，事情就会变得非常复杂（下篇文章将会详细介绍）。大多数时候，我们甚至不确定哪个因素在起作用，只能大概推理。以图 5 为例，接收方声明它的接收窗口等于 0，那接收窗口肯定起了限制作用（因为不可能再小了），因 此 **可 以 大 胆 地 判 断 发 送 窗 口 就 是 0** 。 再 回 顾 本 文 开 头 10.32.106.73 向10.32.106.103 传数据的两个例子。
- 第一个例子中，我们只能推理出 10.32.106.73的发送窗口不小于那 10 个包（39～48 号）携带的数据总和，但具体能达到多少却不得而知，因为窗口还没用完时读操作就完成了。
- 第二个例子比较容易分析，因为传了两个包就停下来等确认，所以发送窗口是那两个包携带的数据量 2920。

3．发送窗口和 MSS 有什么关系？
==发送窗口决定了一口气能发多少字节，而 MSS 决定了这些字节要分多少个包发完==。举个例子，在发送窗口为 16000 字节的情况下，如果 MSS 是 1000 字节，那就需要发送16000/1000=16 个包；而如果 MSS 等于 8000，那要发送的包数就是 16000/8000=2 了。

4．发送方在一个窗口里发出 n 个包，是不是就能收到 n 个确认包？
不一定，**确认包一般会少一些**。由于 **TCP 可以累积起来确认，所以当收到多
个包的时候，只需要确认最后一个就可以了**。比如本文中 10.32.106.73 向
10.32.106.103 传数据的第一个例子中，客户端用一个包（包号 49）确认了它收到的 10 个包（39～48 号包 ）。

5．经常听说“TCP Window Scale”这个概念，它究竟和接收窗口有何
关系？
**在 TCP 刚被发明的时候，全世界的网络带宽都很小，所以最大接收窗口被定
义成 65535 字节**。随着硬件的革命性进步，65535 字节已经成为性能瓶颈了，怎么样才能扩展呢？**TCP 头中只给接收窗口值留了 16 bit，肯定是无法突破 65535（$2^{16}−1$）的**。
1992 年的 RFC 1323 中提出了一个解决方案，就是**在三次握手时，把自己的
Window Scale 信息告知对方**。由于 **Window Scale 放在 TCP 头之外的 Options 中**，所以不需要修改 TCP 头的设计。Window Scale 的作用是向对方声明一个 Shift count，我们把它作为 2 的指数，再乘以 TCP 头中定义的接收窗口，就得到真正的TCP 接收窗口了。

以图 6 为例，从底部可以看到 10.32.106.159 告诉 10.32.106.103 说它的 Shift
count 是 5。25 等于 32，这就意味着以后 10.32.106.159 声明的接收窗口要乘以 32 才是真正的接收窗口值。
图 6
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131004338.png)
接下来我们再看图 7 中的 3 号包。10.32.106.159 声明它的接收窗口为“Window
size value: 183”，183 乘以 32 得到 5856，所以 Wireshark 就显示出“Win=5856”
了。要注意 ==Wireshark 是根据 Shift count 计算出这个结果的，如果抓包时没有抓到三次握手，Wireshark 就不知道该如何计算==，所以我们有时候会很莫名地看到一些极小的接收窗口值。还有些时候是==防火墙识别不了 Window Scale，因此对方无法获得 Shift count，最终导致严重的性能问题==。
图 7 
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307131013806.png)

如[【计算机网络】第三部分 数据链路层(11) 数据链路控制](https://memcpy0.blog.csdn.net/article/details/123156008)讨论的那样，**TCP使用滑动窗口处理流量控制**。TCP使用滑动窗口协议，但其**使用的滑动窗口协议界介于回退 $N$ 帧与选择重发之间的滑动窗口** `between the Go-Back-N and Selective Repeat sliding window` ——==由于它不使用 `NAK` ，看起来像回退 $N$ 帧协议；由于接收方保存失序的段、直到丢失的段到达，它看起来又像选择重发==。可是，这里的滑动窗口与数据链路所用的滑动窗口有两大点不同。
- 第一点，TCP的滑动窗口是**面向字节的** `byte-oriented` ，而数据链路层讨论的滑动窗口是**面向帧的** `frame-oriented` ；
- 第二点，TCP的滑动窗口是**可变大小** `variable size` 的，而数据链路层讨论的滑动窗口是**固定大小** `fixed size` 的。

图23.22表示了TCP 中的滑动窗口，==该窗口跨越缓冲区的一部分，其中存储着从进程接收到的字节，窗口内的字节都是在传输中的字节== `the bytes that can be in transit` ，**可以发送它们、而不必考虑来自另一端的确认**。这个设想的窗口有两个边沿：左边沿和右边沿。
![图23.22 滑动窗口](https://img-blog.csdnimg.cn/38011417ee4b4cb7aae163461066b014.png)
窗口是**张开的、合拢的或收缩的** `opened, closed, or shrunk` 。正如将看到的，这三种活动是**由接收方控制的**（**也取决于网络中的拥塞**）而不是发送方。在这个问题上，**发送方必须服从接收方的命令**。
- 窗口张开是指**右边沿向右移动**，这允许缓冲区中有更多符合发送条件的新字节。
- 窗口合拢是指**左边沿向右移动**，即**有些字节已被确认**，发送方不必再为这些字节而担忧。
- 窗口收缩是指**右边沿向左移动**。因为这意味着取消某些字节的发送资格，**因此强烈建议在实现中不使用它**。如果发送方已经发送了这些字节，则会出现问题。注意：**左边沿不能向左移动**，因为**这将宣告先前发送的某些确认无效** `this would revoke some of the previously sent acknowledgments` 。

==使用滑动窗口可使传输更加有效，同时也可以控制数据流，使得目的端不致因数据来得过多而瘫痪==。一端的TCP窗口大小取决于两个值中较小的一个：**接收方窗口** `receiver window, rwnd` 值和**拥塞窗口** `congestion window, cwnd` 。==接收方窗口值是在包含确认的段中由另一端宣布的值==（在Wireshark的包中就是win字段），它就是另一端在它的缓冲溢出和数据被丢弃之前、可以接收的字节个数。拥塞窗口值是网络为避免拥塞而确定的值，在后面讨论拥塞。

【例23.4】如果接收方主机 $B$ 有一个 $5000$ 个字节的缓冲区，已接收到但并未处理的 $1000$ 个字节数据。试问主机 $A$ 的接收方窗口 `rwnd` 的值是多少？
解：`rwnd` 的值 $=5000 - 1000=4000$ ，主机 $B$ 在它的缓冲溢出之前仅能接收 $4000$ 个字节。主机 $B$ 在下一段向主机 $A$ 宣布。

【例23.5】如果 `rwnd` 的值是 $3000$ ，而 `cwnd` 值是 $3500$ ，试问主机 $A$ 的窗口大小是多少？
解：窗口大小是 `rwnd` 和 `cwnd` 中较小的一个，它应是 $3000$ 个字节。

【例23.6】图23.23表示了一个不切实际的滑动窗口，发送方已发送了 $202$ 个字节。我们假定 `cwnd` 是 $20$（实际上，这个值是上千字节），接收方已发一个 `rwnd` 为 $9$（实际上，这个值也是上千字节）而确认号为 $200$ 的 `ACK` 段。**发送窗口的大小是 `rwnd` 和 `cwnd` 的最小值，即 $9$ 个字节**。字节号 $200$ 到 $202$ 都已发送、但未被确认 `are sent, but not acknowledged` 。字节号 $203$ 到 $208$ 可以发送、而不必考虑从另一端来的确认 `can be sent without worrying about acknowledgment` 。字节号 $209$ 和它以上各字节不可能发送。
![图23.23](https://img-blog.csdnimg.cn/c0b5153c966247679ddd9433d18c75a5.png)
**TCP滑动窗口的要点**如下：
- **发送窗口大小是 `rwnd` 和 `cwnd` 中的最小值**；
- 发送方不必发送一个全窗口大小的数据；
- 接收方可张开或合拢窗口，但不能收缩窗口；
- **只要不引起窗口收缩，目的方可以随时发送一个确认**；（或者累积确认）
- **接收方可暂时关闭窗口**，然而在窗口关闭后，发送方总是可以发送一个 $1$ 字节的段。

## 23.3.6 差错控制
TCP是一个可靠的传输层协议。这意味着：==向TCP发送数据流的应用程序，依靠TCP将整个数据流传递给另一端的应用程序，并且是按序的、无差错的、没有任何一部分丢失或重复的==。

TCP使用差错控制提供可靠性。差错控制包括一些机制：检测受到损坏的段、丢失的段、失序的段和重复的段。差错控制还包括检测出差错后纠正差错的机制。==TCP中的差错检测和纠正是通过三种简单工具来完成的：**校验和、确认和超时**==。
### 1. 校验和
每个段都包括校验和字段，用来检查受到损坏的段。如果段被损坏，它将被目的端TCP丢弃，并认为是丢失了。

TCP在每段中强制使用一个 $16$ 位的校验和。在[【计算机网络】第五部分 传输层(24) 拥塞控制和服务质量](https://memcpy0.blog.csdn.net/article/details/123029798)中会看到，这 $16$ 位的校验和对于新的传输层协议SCTP是不适合的。因为SCTP将整个头部格式重新配置，而TCP不可能改变它。
### 2. 确认
**TCP使用确认方法来证实收到了数据段**。==不携带数据、但占用序列号的一些控制段也要确认，但 **`ACK` 段**（控制标记中 `ACK` 置位、但不携带数据的段）不占用序列号，**是不要确认的**==。
### 3. 重传
**差错控制机制的核心是段的重传**：当一个段损坏、丢失或延迟时，就重传这个段。在当前实现中，有两种情况要重传段：**重传计时器** `retransmission timer` **到时**或**当发送方收到三个重复的 `ACK` 时**。注意：==不占用序列号的段不宣传，**尤其是 `ACK` 段不重传，对 `ACK` 段也不设置重传计时器**==。
#### (1) RTO后重传
TCP对所有重要的段（已发送、但还未被确认）的最新实现使用了一个**重传超时** `retransmission time-out, RTO` **计时器**。当计时器到时，重发一个最早的重要的段 `the earliest outstanding segment` ，即使没有接收到的 `ACK` 可能是由于段被延迟、`ACK` 被延迟或丢失确认等。注意：==对仅携带确认的段没有设置超时计时器，这说明这样的段不需要重发==。

**在TCP中，`RTO` 的值是动态的**，根据段的往返时间 `round-trip time, RTT` 进行更新—— `RTT` 是一个段到达目的端、并接收到一个确认所需要的时间，它使用了一种类似于[第12章]()讨论的 `back-off` 往返策略。

#### (2) 三个重复 `ACK` 段之后的重发
如果 `RTT` 的值不是很大，先前关于段重传的规则就足够了 。但有时某一段丢失了，而接收端收到了许多失序的段，它们不可能都被存储（有限的存储器大小）。

为了缓解这种情况，当今的大多数实现遵循**三次重复 `ACK` 规则** `three-duplicate-ACKs rule` ，**立即重发缺少的段**。这一特点称为**快速重传** `fast retransmission` ，在稍后的例子和拥塞控制中将会看到。
#### (3) 失序的段
==当一个段被延迟、丢失或丢弃时，后面一些段的到达就失序了==。TCP最初的设计是丢弃所有失序的段，并重传那个缺少的段、以及其后的一些段。

当今大多数的实现**不丢弃失序的那些段，暂时将它们存储，并标记它们为失序的段，直到缺少的那个段到达**。但是注意：这些失序的段不传递给进程，TCP确保数据按序传递给进程。即==数据可以失序到达、并被接收的TCP暂时存储，但TCP确保传递给进程的段是有序的==。
### 4. 某些情况
在本节中，给出TCP操作时某些情况的例子。在这些情况中，用长方形表示段。如果段携带数据，就显示字节序列号的范围和确认字段的值。如果段仅是一个确认，仅用小方框中的确认号表示。
#### (1) 正常操作
第一种情况表示了两个系统之间的双向数据传输，如图23.24所示。客户TCP发送一个段，而服务器TCP发送三个段。图23.24表示了应用于每个确认的规则：有数据要发送，所以该段显示期望接收的下一个字节序号。

==当客户端接收到来自服务器的第一个确认时，它没有更多的数据要发送，它仅发送一个 `ACK` 段==。但是，==该确认段需要延迟 $500\textrm{ms}$ ，以观察是否还有更多的段到达==（？或看看自己有没有数据要捎带？）。
**当计时器到时，客户端触发一个确认**，这样做是因为==客户端不知道是否还有其他的段到来，它不再延迟这个确认==。**当下一个段到达时，启动另一个确认计时器**。但是，在它到时之前，第三个段到达，**第三个段的到达触发另一个确认**。
![图23.24 正常操作](https://img-blog.csdnimg.cn/904bfd87f9f6457a85e493ed7f8af2ab.png) 
#### (2) 丢失的段（超时重传）
在这种情况下，我们说明了当一个段丢失或损坏时，将会发生什么。**接收方对丢失的段和损坏的段用同样的方法处理**：丢失的段是在网络中的某处被丢失的，损坏的段是被接收方本身丢弃的。图23.25表示了一种情况，在这种情况下，一个段可能由于拥塞，被网络中的某个路由器丢弃或丢失。 
![图23.25 丢失的段](https://img-blog.csdnimg.cn/fdf2a44c4d7742bf912018a4d84aea43.png)
我们假定数据传输是单向的：一方发送，另一方接收。在这个特定情况下，发送方发送段 $1$ 和段 2 ，这两个段立即被一个 `ACK` 确认。但是，段 $3$ 被丢失了，接收方接收到段 $4$ ，发生了**失序**。==接收方将数据存储在其缓冲器的段中，但留出一个间隙，以指明数据中存在不连续性==。接收方**立即**给发送方发送一个确认，表示了它期望的下一个字节（$701$）。注意：接收方存储从 $801$ 到 $900$ 的字节，但在这个间隙被填充之前、不将这些字节传递给应用程序。**接收方TCP仅将有序的数据传递给进程**。

我们已表示了最早的重要段的计时器 `the earliest outstanding segment` ，==因为**接收方永远不会给丢失或失序段发送确认**（段 $4$ 得到的确认号仍是 $701$ ），因此这个定时器肯定会超时==。当该计时器到时时，发送方TCP重发段 $3$ ，该段此时到达并被正确确认。注意：按照相应的规则，第二个确认和第三个确认的值是不同的，**第三个确认一次性确认了重发的段 $3$ 和此前到达的段 $4$** 。

如果丢失了多个包，比如701-800,801-901,……，每个包都可能要到超时才能重传，然后触发多个ACK……这就可以用SACK！？？？
#### (3) 快速重传
在这个情况中，我们要表示快速重传的思想。除了 `RTO` 具有较大的值外，该情况与第二种情况相同（见图23.26）。==当接收方接收到第四个、第五个和第六个段时，它触发一个确认。发送方接收到 $4$ 个具有相同值的确认（$3$ 个是重复的）==。**虽然段 $3$ 的计时器还没有到时，但快速传输要求立即重发段 $3$ ，该段是所有这些确认所期望的**。
![图23.26 快速重传](https://img-blog.csdnimg.cn/d0aa7c631b434f80a62a9d077c185f90.png)注意：虽然有 $4$ 个段都没被确认，但**只有一个段被重新传输**。==当发送方接收到这个重发的 `ACK` 时，因为**确认是累计的**，因此它知道这 $4$ 个段是安全的和可靠的==。

## 23.3.7 拥塞控制
在[【计算机网络】第五部分 传输层(24) 拥塞控制和服务质量](https://memcpy0.blog.csdn.net/article/details/123029798)讨论TCP的拥塞控制，本地[[【计算机网络】第五部分 传输层(24) 拥塞控制和服务质量]]。

---
# 23.4 SCTP 
**流控制传输协议** `SCTP` 是一种新的**可靠的、面向报文的**传输层控制协议。然而，SCTP主要是*为最近引入的因特网应用而设计的*。这些新的应用，如 `IUA`（IP上的ISDN）、`M2UA` 和`M3UA`（电话信令）、`H.248`（媒体网关控制）、`H.323`（IP电话）和 `SIP`（IP电话）等，都需要提供比TCP更复杂的服务。

**SCTP提供了更高的性能和可靠性**。我们简要比较UDP 、TCP和 STCP的性能。
- UDP是一个**面向报文** `message-oriented` 的协议，进程将报文传递给UDP，将它封装在一个用户数据报中，通过网络发送。**UDP保留报文边界，每个报文与其他报文无关**。正如在后面将看到的，当我们处理一些应用，如IP电话和实时数据传输时，这个特性是想要的。但是，==UDP是不可靠的，发送方不知道报文的命运，报文可能会丢失、重复或失序；UDP也还缺乏其他特性，如缺少友好的传输层协议所需要的拥塞控制和流量控制==。
- TCP是一个**面向字节** `byte-oriented` 的协议。==它从进程中接收**一个报文或多个报文**，以一个**字节流**的方式存储它们，并以**段**的方式发送它们，**没有保存报文的边界**==。但是，TCP是一个可靠的协议，重复段会被删除、丢失的段会重发，并且字节按序传递到端进程。TCP还有拥塞控制和流量控制机制。
- **SCTP兼有UDP和TCP的特性**。SCTP是一个可靠的面向报文的协议，**它保存报文的边界**，同时它检测丢失的数据、重复的数据和失序的数据。它还有拥塞控制和流量控制机制。稍后会看到，SCTP还有UDP和TCP中没有的一些新特性。

## 23.4.1 SCTP服务
在讨论SCTP操作之前，先说明**SCTP向应用层进程提供的服务**。
### 1. 进程到进程通信（多流服务）
SCTP使用TCP空间中的熟知端口号，表23.4列出了SCTP使用的一些额外的端口。
![表 23.4某些SCTP应用](https://img-blog.csdnimg.cn/1fbb79bb3ead4f008b24767033b4f77e.png)
在前一节讨论过==TCP是一种面向流的协议，TCP客户端与 TCP服务器的每一次连接，都包含了一个单一的流==。这个方法存在的问题是，**在流中任何一点的丢失，会阻塞其余数据的传递**。当传输文本时，这还可以接受；但当传输实时数据（音频或视频）时，这就不能接受了。

SCTP在每一次连接中提供**多流服务** `multistream service` ，用SCTP专门名词称为**关联** `association` ，SCTP的一次关联能包含多个流。如果多流中某一个被阻塞，其余的流仍然可传递它们的数据。这种思想类似于*高速公路上的多车道*，每一个车道可用于不同类型的交通量。例如，一条车道用于正常的交通，另一条车道用于合伙车。如果正常的交通受到阻塞，合伙车辆依旧可达目的地。图23.27表示了**多流传递**的思想。
![图23.27 多流的概念](https://img-blog.csdnimg.cn/6175a3c5bb6a4d138dac8e440a35068d.png)
### 2. 多接口
一个TCP连接包括了一个源IP地址和一个目的IP地址。这就是说，即使发送方或接收方是一个**多接口主机** `multihomed host`（即连接到具有多个IP地址的多个物理地址上），在连接期间，每端的这些IP地址中仅有一个是可用的 `only one of these IP addresses per end can be utilized` 。

另一方面，SCTP关联支持**多接口服务** `multihoming service` ，**发送和接收主机可以在每一端为关联定义多个IP地址**。在这个容错方法 `fault-tolerant approach` 中，当一条通路发生故障时，可以用另一个接口不中断地传递数据。当发送和接收实时有效载荷时，如因特网上的电话，这个特性是很有用的。图23.28表示了多接口的思想。
![图23.28 多接口概念](https://img-blog.csdnimg.cn/00dad512042042749a6c97543988f4b7.png)
在图23.28中，客户端用两个IP地址分别连接两个局域网络，服务器也用两个IP地址分别连接两个网络。**客户端和服务器可用四个不同的IP地址对做出一个关联**。但是应注意，==在目前SCTP的实现中，仅有一对IP地址可用于正常的通信；当选用的主路径有故障时，可使用替换路径==。换言之，目前SCTP不允许不同路径共用。
### 3. 全双工通信
像TCP一样，**SCTP提供全双工服务**。在全双工服务中，数据可同时在两个方向流动。每一个SCTP都有一个发送和接收缓存区，在两个方向都可以发送分组。
### 4. 面向连接服务
像TCP一样，**SCTP是面向连接的协议**。但是，**在SCTP中连接被称为关联**。站点 $A$ 的进程要向站点 $B$ 的另一个进程发送或接收数据时，其步骤如下：
1. 两个SCTP彼此建立关联：
2. 双方向交换数据$
3. 终止关联。

### 5. 可靠的服务
像TCP一样，**SCTP是可靠的传输协议**。它利用确认机制检测数据是否安全和可靠地到达。在差错控制这一节进一步讨论这个特性。
## 23.4.2 SCTP特性
首先讨论SCTP的一般特性，然后将这些特性与TCP特性相比较。
### 1. 传输序列号
==TCP的数据单元是字节，在TCP中用序列号对字节编号，以控制数据传输==。另一方面，**SCTP的数据单元是数据大块** `DATA chunk` 。由于分段原因，**数据大块与来自进程的报文可能有、也可能没有一一对应的关系**（以后讨论）。在SCTP中，用数据大块的编号控制数据传输，SCTP使用**传输序列号** `transmission sequence number, TSN` 对数据大块进行编号。

换言之，==SCTP中的 `TSN` 所起的作用类似于TCP中的序列号==。`TSN` 是 $32$ 位长，初始值可取 $0$ 到 $2^{32} -1$ 之间的随机数。**每个数据大块的头部必须有相应的 `TSN`**。
 
### 2. 流标识符
在TCP中，每一次连接仅有一个流。而在SCTP中，每次关联可以有多个流。因此，**每个流需要用流标识符 `SI` 进行标识**。注意，**每个数据大块的头部必须有 `SI`** ，这样当它到达目的端时，它可正确地放入它的流中。`SI` 是从 $0$ 开始的 $16$ 位数字。

### 3. 流序列号
==当一个数据大块到达目的SCTP时，它被传递到适当的流中，并按原序排列==。这就是说，除了 `SI` 之外，为了区别属于同一个流中的不同数据大块，SCTP还用**流序列号** `stream sequence number, SSN` **对每个流中的每个数据大块进行定义**。
### 4. 分组
在TCP中，段携带数据和控制信息，数据作为一组字节被携带，而**控制信息是用它头部的 $6$ 个控制标记来定义**。而SCTP的设计完全不同：==数据作为数据大块被携带，控制信息作为控制大块被携带，多个控制大块与数据大块可合并成一个分组== `packet` 。**SCTP中一个分组起的作用与TCP中的段相同** `A packet in SCTP plays the same role as a segment in TCP` 。

图23.29比较了TCP的段与 SCTP的分组。扼要列出SCTP的分组和TCP的段不同：
![图23.29 TCP段与SCfP分组的比较](https://img-blog.csdnimg.cn/cb821b069dba448fa726b3f28d7a3a78.png)
1. TCP中的控制信息在头部，而**SCTP中的控制信息是在控制大块中**，有几种类型的控制大块，每个类型用于不同的目的；
2. 一个TCP段中的数据作为一个实体处理，而==一个SCTP分组可以携带多个数据大块，每个可能属于不同的流==。
3. 选项可以是TCP段的一部分，而**SCTP分组不存在选项**，SCTP中的选项是通过定义新的大块类型来处理的 `Options in SCTP are handled by defining new chunk types` 。
4. TCP头部的强制性部分是 $20$ 个字节，而SCTP头部仅是 $12$ 个字节。SCTP头部较短是由于下列因素：
	- **SCTP序列号 `TSN`** 属于每个数据大块，因此它**位于数据大块的头部**；
	- **确认号和窗口大小都是每个控制大块的一部分**；
	- SCTP头部的长度是固定的 $12$ 个字节) ，因此不需要头长度字段（TCP段中用 `HLEN` 表示），不存在用选项生成头部的长度；
	- 在SCTP中没有紧急指针。
5. TCP中的校验和是 $16$ 位，而SCTP中的校验和是 $32$ 位。
6. SCTP中**确认标签** `verification tag` 是关联标识符 `association identifier` ，而在TCP中是没有的。TCP中的IP地址和端口地址一起定义了一个连接，而**在SCTP中**，用不同的IP地址实现多接口，**定义每个关联都需要唯一的确认标签**。
7. TCP段的头部有一个序列号，它定义数据部分中的第一个字节编号，而SCTP分组可包含多个数据大块，用 `TSN, SI, SSN` 定义每个数据大块。
8. TCP中有些段携带控制信息（如 `SYN` 和 `FIN`），它要占用一个序列号，**在SCTP中，控制大块不使用 `TSN, SI, SSN` 。这三个标识符仅属于数据大块，而不是属于整个大块**。

在SCTP中，控制信息和数据信息在分开的大块中携带。==在SCTP中，有**数据大块、流和分组**：一个关联可发送多个分组，一个分组可包含多个大块，而各个大块可属于不同的流==。

为了使这些术语定义得更清晰，让我们假定进程 $A$ 用 $3$ 个流发送 $11$ 个报文给进程 $B$ 。前面的 $4$ 个报文用第一个流，其次的 $3$ 个报文用第二个流，最后的 $4$ 个报文用第三个流。虽然**一个长的报文可能被多个数据大块携带**，但是我们还是==假定每个报文装载在一个数据大块中==。因此，我们在 $3$ 个流中有 $11$ 个数据大块。

应用进程传递 $11$ 个报文给STCP ，这里对每个报文标上适合的流记号 。虽然进程可传递第一个流的一个报文，然后再传递第二个流的另一个报文。但是，我们==假定首先传递属于第一个流的所有报文，然后再传递属于第二个流的所有报文，最后传递属于第三个流的所有报文==。

我们还==假定网络仅允许每个组有三个数据大块==。这就是说，我们需要 $4$ 个分组如图23.30所示。第一个分组和一部分第二个分组携带流 $0$ 中的数据大块，第二个分组和第三个分组携带流 $1$ 中的数据大块，第三个分组和第四个分组携带流 $2$ 中的数据大块。
![图23.30 分组、数据大块和流](https://img-blog.csdnimg.cn/62d75561e9914eb19b32eecb4253719c.png)
注意，**每个数据大块需要三个标识符：`TSN, SI, SSN`** 。`TSN` 是累计数，将会看到它也用于流量控制和差错控制。`SI` 定义这些块所属的流。`SSN` 定义了在特定流中数据大块的次序。在我们的例子中，对每个流，`SSN` 都从 $0$ 开始编号计数。

### 5. 确认号
TCP确认号是面向字节的，它指的是序列号，而**SCTP确认号是面向大块的，它指的是 `TSN`** 。TCP与SCTP确认号的第二个不同是控制信息，在TCP中控制信息是段头部的一部分，为了确认只携带控制信息的段 `segments that carry only control information` ，TCP使用序列号和确认号（例如，`SYN` 段需要用 `ACK` 段确认）。

但在SCTP中，**确认号仅用于对数据大块的确认**。此外，==控制大块携带控制信息，它不使用 `TSN` ，如果需要的话，**这些控制大块用另一个适当类型的控制大块来确认**==（有些不需要确认）。例如，`INIT` 控制大块是由 `INIT ACK` 大块来确认，它不需要序列号或确认号。
### 6. 流量控制
像TCP一样，SCTP实现流量控制、以避免接收方崩溃，在后面讨论SCTP的流量控制。
### 7. 差错控制
像TCP一样，SCTP实现差错控制、以提供可靠性。**`TSN` 号和确认号用于差错控制**，在后面讨论差错控制。
### 8. 拥塞控制
像TCP一样，SCTP实现拥塞控制、以决定多少个数据大块可置于网络中。在[【计算机网络】第五部分 传输层(24) 拥塞控制和服务质量](https://memcpy0.blog.csdn.net/article/details/123029798)讨论拥塞控制。
## 23.4.3 分组格式
在这一节说明分组格式和大块的各种类型。在本节中所列出的大多数信息，在后面变得更加清楚。

SCTP分组有一个**强制性的通用头部**和**一组称为大块的块的集合** ` a set of blocks called chunks` 。大块有两种类型：数据大块 `data chunks` 和控制大块 `control chunks` 。**控制大块控制和维护关联，而数据大块携带用户数据**。在一个分组中，控制大块在数据大块之前。图23.31表示了SCTP分组的一般格式。
![图23.31 SCTP的分组格式](https://img-blog.csdnimg.cn/2b957822dd7047919e376d67c3c91d8e.png)
### 1. 通用头部
**通用头部** `general header` 定义分组所属的每个关联的端点 `the endpoints of each association to which the packet belongs` ，**保证了分组属于一个特定的关联**，并保护分组内容包括本身头部的完整性。通用头部格式如图23.32所示。
![图23.32 通用头部](https://img-blog.csdnimg.cn/9bfaa113514f48838d2a567be38092fc.png)
通用头部有 $4$ 个字段： 
- **源端口地址**。这是一个 $16$ 位字段，它定义进程发送分组的端口号。
- **目的端口地址**。这是一个 $16$ 位字段，它定义进程接收分组的端口号；
- **确认标签**。这是一个数，它将一个分组与一个关联相匹配。它防止将以前关联的一个分组误认为是这个关联中的一个分组。==**它作为关联的一个标识符**，在关联期间，它在每个分组中都是相同的==。在关联中，每个方向有各自的确认标签 `There is a separate verification used for each direction in the association` 。
- **校验和**。这是一个 $32$ 位字段，它包含CRC-32校验和。注意校验和的长度从 $16$ 位（UDP、TCP和IP）增加到 $32$ 位，并允许用CRC-32校验和。

### 2. 大块
**大块携带控制信息或用户数据**，每块的详细格式超出了范围。所有大块的前三个字段是相同的，信息字段取决于大块类型。最重要的是，SCTP要求信息部分是 $4$ 字节的倍数，如果不是，在信息部分的末尾增加填充字节（$8$ 个 $0$) 。一些大块和它们的说明见表23.5：
![表23.5 大块](https://img-blog.csdnimg.cn/8b44873e4e6f40ee8f91b20fbe7ad73f.png)
## 23.4.4 SCTP关联
像TCP一样，SCTP是一个面向连接的协议。但是，为了强调其多接口性，SCTP中的连接被称为**关联**。
### 1. 关联建立
SCTP中的**关联建立** `association establishment` 要求**四次握手** `four-way handshake` 。在这个过程中，一个进程（通常是客户）想要与另一个进程（通常是服务器）建立关联，使用SCTP作为传输层协议。

与TCP相似，**SCTP服务器需要准备接收一个关联（被动打开），而由客户发起建立关联（主动打开）**，SCTP关联建立，如图23.33所示。在正常情形下，步骤如下：
1. 客户端发送第一个分组，它是一个 `INIT` 大块 `INIT chunk` ；
2. 服务器发送第二个分组，它是一个 `INIT ACK` 大块 `INIT ACK chunk` ，**携带 `INIT` 或 `INIT ACK` 大块的分组中不允许有其他大块**；
3. 客户端发送第三个分组，它包含一个 `COOKIE ECHO` 大块
 `COOKIE ECHO chunk` ，这是一个很简单的大块，**它毫无改变地回应由服务器发送的 `cookie`** 。SCTP允许在这个分组中包含数据大块；
4. 服务器发送第四个分组，它包含对接收到的 `COOKIE ECHO` 大块进行确认的 `COOKIE ACK` 大块 `COOKIE ACK chunk` 。SCTP允许在这个分组中包含数据大块。
![图23.33 四次握手](https://img-blog.csdnimg.cn/d4acc19ed00a4661b6bddf9f3d535c48.png)

#### Cookie
在前几节中，讨论过SYN洪泛攻击。利用TCP，一个恶意的攻击者可以向一个TCP服务器，发送大量的、具有不同假IP地址的伪造的 `SYN` 段。每次服务器接收到一个 `SYN` 段时，它设置状态表 `sets up a state table` 并分配其他资源，同时等待下一段到达。然而，一段时间后，服务器可能会因为资源耗尽而崩溃。

SCTP设计者使用一种策略防止这种类型的攻击。当发送方IP地址被确认时，这个策略是**推迟资源分配、直到接收到第三个分组**。第一个分组中接收到的信息必须以某种方式保存到第三个分组到达。但是，如果服务器保存该信息，那就需要资源（存储器）的分配，这是一个困境。

解决办法是==包装该信息，并把它送回到客户==，这称为**生成一个 `cookie`** ，==这个 `cookie` 与第二个分组一起发送给接收第一个分组的地址==。有两种可能的情形：
1. 如果第一个分组的发送方是一个攻击者，那么服务器永远不会接收到第三个分组，`cookie` 丢失了，但没有分配资源。服务器的唯一的工作是 `"baking" cookie` 。
3. 如果第一个分组的发送方是需要建立连接的一位诚实的客户，那么它接收到带有 `cookie` 的第二个分组。**它毫无改变地用该 `cookie` 发送一个分组（在序列中是第三个分组）**。服务器接收到第三个分组，而且知道它来自一位诚实的客户，因为发送方发送的 `cookie` 已经在那里。**现在服务器可以分配资源了**。

如果没有实体可以"吃掉"由服务器"生成"的 `cookie` ，那么上述策略就可以起作用。为了保证这一点，服务器用它自己的密钥产生该信息的一个摘要（见[【计算机网络】第七部分 网络安全(30) 密码学](https://memcpy0.blog.csdn.net/article/details/122954329)）。**信息和摘要一起生成一个 `cookie` ，它在第二个分组中被发送给客户**。当 `cookie` 在第三个分组中返回时，服务器计算信息的摘要。如果该摘要与发送的摘要相匹配，那么该 `cookie` 就没有被其他的实体修改。

### 2. 数据传输
关联的目的是为了在两端之间传输数据。关联建立后，就可以进行双方向的数据传输，客户端与服务器都可发送数据。**像TCP一样，SCTP支持捎带**。

然而，TCP与SCTP在数据传输方面存在着很大的不同，==TCP从进程接收报文，这些报文作为字节流、在其间没有可识别的边界==。为了它的对等方的使用，进程可插入一些边界，但TCP将那些标记作为文本的一部分对待。换言之，TCP把每个报文附加 `append` 到它的缓存中，一个段可能携带两个不同报文的一部分 `A segment can carry parts of two different messages.` 。TCP使用的唯一的排序系统是**字节编号**。

另一方面，==SCTP识别并维护边界，来自进程的每个报文作为一个单元处理，并插入到一个 `DATA` 大块中==，除非这个报文被分段（后面讨论）。在这种情况下，SCTP与UDP一样具有一个很大的优势：数据大块相互关联。

==通过把 `DATA` 大块的头部加到报文上，从进程接收到的一个报文成为一个 `DATA` 大块；如果要分段，则成为几个 `DATA` 大块==。**一个报文或一个报文的分段形成的每个 `DATA` 大块，都有一个 `TSN`** 。我们要记住，**只有 `DATA` 大块使用 `TNS` ，也只有 `DATA` 大块使用 `SACK` 大块进行确认**。

图23.34表示了一个简单数据传输的情形，客户端发送 $4$ 个 `DATA` 大块，从服务器接收两个 `DATA` 大块。稍后，讨论SCTP中的流量和差错控制，此时假定在这种情形下一切都顺利。
![图23.34 简单数据传输](https://img-blog.csdnimg.cn/f006478b8f40403aaa5a349194391179.png)
1. 客户端发送第一个分组，它携带 `TSN` 分别为 $7 105$ 和 $7 106$ 的两个 `DATA` 大块。
2. 客户端发送第二个分组，它携带 `TSN` 分别为 $7107$ 和 $7 108$ 的两个 `DATA` 大块。
3. 第三个分组来自服务器，它包括了对收到来自客户端的 `DATA` 大块进行确认所需要的 `SACK` 大块。与TCP相反，**SCTP只有按顺序收到的最后一个 `TSN` 进行确认，而不是下一个所期望的**。第三个分组还包括了 `TSN` 为 $121$ 的来自服务器的第一个 `DATA` 大块。
4. 不久，服务器发送另一个携带 `TSN` 为 $122$ 的、最后一个`DATA` 大块的分组，但由于接收来自客户端的最后的 `DATA` 大块已被确认，所以在这个分组中不包括 `SACK` 大块。
5. 最后，客户端发送一个分组，该分组包含了一个 `SACK` 大块，该 `SACK` 大块是对接收到的、来自服务器最后两个 `DATA` 大块的确认。

在SCTP中的确认定义了累计 `TSN`  ，最后数据大块的 TSN是按序接收的。
#### (1) 多接口数据传输
我们讨论SCTP多接口的性能，它与UDP和TCP不同的特性。==多接口允许双方为了通信定义多个IP地址，但这些地址中只有一个地址能被定义为**主地址** `primary address` ，其余的地址都是可选地址==。

**在关联建立期间，主地址被定义**。有趣的是，**一端的主地址由另一端决定**。换言之，源端定义目的端的主地址。
#### (2) 多流传递
SCTP的一个重要特性是**数据传输和数据传递** `data transfer and data delivery` 是不同的：SCTP使用 `TSN` 号处理数据传输，在源端与目的端之间移动数据大块。数据大块的传递是用 `SI` 和 `SSN` 来控制。

SCTP支持多流，这就是说发送进程可定义不同的流，一个报文可属于这些流中某一个。**每个流被赋于一个流标识符 `Sl` ，它唯一地定义这个流**。
#### (3) 分段
在数据传输中的另一个问题是**分段** `fragmentation` 。虽然SCTP也用IP中分段 `fragmentation` 这个术语，但IP中的分段与SCTP中的分段属于不同的级别：前者是在网络层，而后者是在传输层。

==如果一个报文（封装在IP数据报中）的长度不超过路径的 `MTU` ，**当这个报文创建一个 `DATA` 大块时，SCTP保存进程到进程的报文的边界**==。携带一个报文的IP数据报的长度，等于报文的长度（以字节为单位）加上 $4$ 个开销：数据大块的头部、必需的 `SACK` 大块、SCTP通用头部和IP头部。**如果总长度超过 `MTU` ，则报文需要分段**。
### 3. 关联终止
像TCP一样，在SCTP中交换数据的双方（客户端与服务器）的任一方都可关闭连接。但与TCP不同的是，**SCTP不允许有半关闭的情形**：==如果某一端关闭了关联，另一端必须停止发送新的数据。如果在终止请求的队列中还有数据，那么将这些数据送，并关闭关联==。

**关联终止** `association termination` **使用三个分组** `SHUTDOWN, SHUTDOWN ACK, SHUTDOWN COMPLETE` ，如图23.35所示。注意：虽然在图中终止是由客户端发起的，但也可由服务器发起。关联终止可以有多种情况，在本章末提到的参考文献中有讨论。
![图23.35 关联终止](https://img-blog.csdnimg.cn/dbac4b491fb64331ada6a3d3c7625e6d.png)
## 23.4.5 流量控制
SCTP的流量控制与TCP的流量控制相类似。在TCP中，我们只需要处理一个数据单元——字节。在SCTP ，我们需要处理两个数据单元的数据：字节和大块 `the byte and the chunk` 。`rwnd` 和 `cwnd` 的值用字节表示，`TSN` 的值和确认用大块表示。

为了说明这个概念，我们做某些不实际的假定，假设网络永远不会拥塞和永远没有差错。换言之，我们假定 `cwnd` 是无穷大，分组不丢失、不延迟、不失序到达。还假定数据传输是单向的。在后面几节改进这些不实际的假定。

关于流量控制，==现在SCTP的实现依旧是使用一个面向字节的窗口==。然而，为了使概念变成更加容易了解，==用大块表示缓冲区==。
### 1. 接收方站点
接收方有一个缓冲区（队列）和三个变量。该队列保存接收到、但还未被进程读出的大块。第一个变量保存**最后收到的 `TSN` 值**，即 `cumTSN` 。第二个变量保存**缓冲区大小**，即 `winSize` 。第三个变量保存**最后的累计确认值**，即 `lastACK` 。图23.36表示接收方站点的队列和变量。
1. 当站点接收到一个数据大块时，将它存储在缓冲区（队列）的末端，并从 `winSize` 减去该数据大块的大小。这一大块的 `TSN` 号存储在 `cumTSN` 变量中；
2. 当进程读出一个大块时，该块从队接收列中移去，并在  `winSize` 中加上移去大块的大小（循环使用）；
![图23.36 接收方站点的流量控制](https://img-blog.csdnimg.cn/3eeea810aa4b41d5a662c4585d540c7a.png)
3. 当接收方决定发送一个 `SACK` 时，它检验 `lastACK` 的值。如果它小于 `cumTSN` ， 接收方就发送一个「累计 `TSN` 号等于 `cumTSN` 」的 `SACK` ，同时该 `SACK` 也包含 `wizeSize` 的值作为该窗口的大小。

### 2. 发送方站点
发送方有一个缓冲区（队列）和三个变量：`curTSN, rwnd, inTransit` 。如图23.37所示。我们假定每个大块的长度为 $1 00$ 个字节。

![图23.37](https://img-blog.csdnimg.cn/0f4ac9153a464e05818bc3ec54ad717f.png)
缓冲区保存由进程产生的大块，这些大块或者已被发送或者准备发送。第一个变量 `curTSN` 指的是**下一个要发送的大块**，==队列中所有小于这个值的大块都已被发送、但还没有被确认，它们是未完成的==。第二个变量 `rwnd` 保存**接收方通告窗口的最新值**（以字节为单位）。第三个变量 `inTrasit` 保存**正在传输中（即字节已发送、但还未被确认）的字节个数**。下面是发送方所用的过程。
1. 如果 `curTSN` 指向的大块的数据大小 `<= rwnd - inTransit` 时，该大块可以发送。发送后，`curTSN` 值增 $1$ 并指向下一个要发送的大块。`inTransit` 的值加上己被发送大块的数据大小。
2. 当接收到一个 `SACK` ，队列中具有 `TSN`  值小于或等于  `SACK` 中的 `TSN` 值的那些大块从队列中移去并丢弃。发送方不再关心它们。`inTrasit` 值减去被丢弃块总的大小。用 `SACK` 中通告窗口的值更新 `rwnd` 的值。
 
### 3. 一个实例
给出如图23.38所示的一个简单实例。开始时，发送方站点的 `rwnd` 和接收方站点的 `winSize` 都是 $2000$（在关联建立期间通告）。发送方队列初始有 $4$ 个报文，它发送一个数据大块，并在 `inTransit` 变量中加上字节数 $1 000$ 。之后，发送方检查`rwnd` 与 `inTrasit` 的差，它是 $1000$ ，所以发送方可发送另一个数据大块。**现在两个变量的差为 $0$ ，不能再发送数据大块**。

过一会儿，确认数据大块 $1$ 和 $2$ 的 `SACK` 到达。这两个大块从队列中移去，此时 `inTransit` 的值是 $0$ 。但是，==`SACK` 通告了接收窗口的值是 $0$ ，这使得发送方将 `rwnd` 值更新为 0。现在发送方被阻塞，它不能发送任何数据大块（有一个例外稍后说明）==。
![图23.38 流控制情况实例](https://img-blog.csdnimg.cn/db9e5f95535f44b4a5ab9f19e50aa706.png)
在接收方，开始时队列是空的。当第一个数据大块接收到后，队列中有一个报文，并且 `cumTSN` 值为 $10$ ，`winSize` 的值减小到 $1000$ ，这是因为第一个报文占用 $1000$ 个字节。接收到第二个报文后，窗口大小的值为 $0$ 而 `cumTSN` 为 $2$ 。此时，我们将看到接收方需要发送累计 `TSN` 为 $2$ 的 `SACK` 。第一个 `SACK` 发送后，进程读出这两个报文，这就是说现在队列有空间，接收方用 `SACK` 通告这种情况，允许发送方发送更多的数据大块。余下的事件在图中没有表示。
## 23.4.6 差错控制
像TCP一样，SCTP是一个可靠的传输层协议。**它使用一个 `SACK` 大块，向发送方报告接收方缓冲区的状态**。在接收方站点与发送方站点，每个实现都使用不同的实体和计时器集合。用一个最简单的设计，介绍这个概念。
### 1. 接收方站点
在我们的设计中，**接收方将所有到达的大块存储在队列中，包括失序大块**。但是，**它给任何丢失的大块保留空间**。**它丢弃那些重复的报文，但追踪它们并向发送方报告**。图23.39表示了一个接收方站点的典型设计、和在一个特定时间接收队列的状态。

发送的最后确认是对数据大块 $20$ ，有效窗口大小是 $1000$ 个字节。大块 $21$ 到 $23$ 已按序收到，第一个失序的块包含大块 $26$ 到 $28$ ，第二个失序块包含大块 $31$ 到 $34$ 。一个变量保存 `cumTSN` 的值。**一组变量保存失序的那些块的首块 `TSN` 和末块 `TSN`**  。一组变量保存接收到的那些重复的大块。注意：==在队列中，不需要对重复的大块进行排序，它们被丢弃==。图23.39中也显示了，将要发送给发送方的、用以报告接收方状态的 `SACK` 大块。那些失序大块的 `TSN` 号是相对于（偏移量 ）累计TSN的。
![图23.39 接收方站点的差错控制](https://img-blog.csdnimg.cn/45dab52c2a8d4dd3a350e25a144f166c.png)

### 2. 发送方站点
在发送方站点，我们的设计要求**两个缓冲区（队列）：一个发送队列和一个重传队列**。也使用前一节描述的三个变量 `rwnd, inTrasit, curTSN` 。图23.40表示了一个典型的设计。
![图23.40 发送方站点差错控制](https://img-blog.csdnimg.cn/727fc1e03fc546bdb6b88675886c1ff0.png)
发送队列保存大块 $23$ 到 $40$ 。其中大块 $23$ 到 $36$ 已发送，但还未被确认，它们是未完成的大块。`curTSN` 指向下一个要发送的大块 $37$ 。假定每个大块是 $100$ 个字节，这就是说数据中的 $1 400$ 个字节（大块 $23$ 到 $36$）是正在传输中的。

这时**发送方有一个重传队列**，==当发送一个分组时，那个分组（那个分组中的所有大块）的重传计时器开始启动==。有些实现对整个关联使用一个计时器，但我们为了简单起见，继续按惯例对每个分组使用一个计时器。==当一个分组的重传计时器到时时，或声称一个分组丢失的 $4$ 个重复的 `SACK`（在[第12章]()中讨论过快速重传）到达时，那个分组中的所有大块都移到重传队列中被重新发送==。**在重传队列中的大块具有优先权**。换言之，下一次发送方发送的大块将来自重传队列的大块 $21$ 。
### 3. 发送数据大块
==每当在发送队列中存在TSN的值 `>= curTSN` 的数据大块时，或者在重传队列中有数据大块时， 一个端就可以发送一个数据分组==。重传队列中的大块具有优先发送权。但是，一个分组所包含的数据大块的大小，或多个数据大块总的大小必须小于或等于 `rwnd - inTransit` ，在前几节已讨论过，帧的总的大小必须小于或等于 `MTU` 。
### 4. 重发
像TCP一样，为了控制丢失的或丢弃的大块，SCTP采用两种策略：**使用重发计时器**和**接收到同一丢失大块的 $4$ 个 `SACK`** 。
### 5. 生成SACK大块
差错控制中的另一个问题是生成 `SACK` 大块。**生成 `SCTP SACK` 大块的规则，与TCP中「使用 `ACK` 标记进行确认 `acknowledgment with the TCP
ACK flag` 」所用的规则相似**。
## 23.4.7 拥塞控制
像TCP一样，SCTP是一个传输层协议，其分组会遭受到网络拥塞。**SCTP设计者也使用相同的策略**，将在[【计算机网络】第五部分 传输层(24) 拥塞控制和服务质量](https://memcpy0.blog.csdn.net/article/details/123029798)中讨论TCP拥塞控制。==SCTP具有慢速启动（指数增加）、拥塞避免（加性增加）和拥塞检测（乘性减少）等阶段。像TCP一样，SCTP也使用快速重传和快速恢复==、以及慢速恢复。
