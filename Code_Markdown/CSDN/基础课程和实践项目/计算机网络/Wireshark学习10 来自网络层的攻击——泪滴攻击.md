我们了解过一种针对网络层ARP协议的攻击技术，下面就网络层中**另一个常用的协议IP**展开分析。几乎每一个对网络有所了解的人都知道IP地址，**IP可以说是整个网络中最为重要的一个协议**。互联网上的每一个设备都需要通过IP地址来标识自己的身份。

和ARP协议一样，**在IP协议中也没有任何的安全机制，所以它也经常被攻击者所利用**。虽然现在随着操作系统的不断完善，很多针对IP协议的攻击手段已经不再能对网络和设备造成任何的威胁了，但它们都设计得十分巧妙，通过对其进行学习和研究，可以帮助更好地掌握网络安全方面的知识。

就如下主题展开学习：
-泪滴攻击（TearDrop）的相关理论；
-Wireshark的着色规则；
-如何发起泪滴攻击；
-根据TTL值判断攻击的来源。

## 11.1泪滴攻击的相关理论
针对IP协议的攻击方法，主要有**伪造IP地址和发送畸形数据包**两种方式。我们中选择的泪滴攻击就属于发送畸形数据包这种方式，它的设计思路巧妙地利用了IP协议里面的**缺陷**，因此成为了网络安全里面的一个经典案例。
这种攻击的实现原理是向目标主机**发送异常的数据包碎片**，使得IP数据包碎片在重组的过程中有重合的部分，从而导致目标系统无法对其进行重组，进一步导致系统崩溃而停止服务的恶性攻击。

考虑到这种攻击是建立在IP协议上，我们先来简单地了解一下IP协议的几个重要内容，包括IP协议数据包的格式、分片方式以及存活时间（TTL）。
### 11.1.1IP协议的格式
我们先来了解IP协议数据包的格式，读者可以访问https://wiki.wireshark.org/
SampleCaptures/，这里面包含有Wireshark官方提供的**各种数据包样本**。这一章我们以其中的teardrop.cap为例。图1中给出了下载这些样本的页面。
图1 Wireshark提供的数据包样本
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182313946.png)
下载这个文件之后，可以使用Wireshark打开，里面的内容显示如图2所示。
图2 在Wireshark中打开teardrop.cap
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182314991.png)
如图3所示，我们选择第8个数据包，在数据包信息面板中查看它的详细信息，这
个数据包各部分的含义如下。
（1）版本——占4位，指IP协议的版本目前的IP协议版本号为4（即IPv4）。
（2）首部长度——占4位，这里的值为20Bytes。
（3）总长度的是56字节。
（4）标识（identification）——占16位，它是一个计数器，用来产生数据包的标识。
（5）片偏移（16位）——**较长的分组在分片后，某片在原分组中的相对位置**，片偏移以8个字节为偏移单位。
（6）生存时间（8位）——记为TTL（TimeToLive），表示**数据包在网络中可通过的路由器数的最大值**。
（7）协议（8位）字段——指出此数据包携带的数据使用何种协议，以便目的主机的IP层将数据部分上交给哪个处理进程。
（8）源IP地址，表示数据包从哪里发出。
（9）目的IP地址，表示数据包将要发向哪里。
图3 数据包信息面板中查看IP层的内容
![Uploading file...4born]()
数据包中的每个部分都有它的作用，**我们最为关心的几个部分则是片偏移、生存时间、源IP地址和目的IP地址**。其中的源IP地址和目的IP地址就好像是平时邮寄信件时的发信人地址和收信人地址一样。不过刚接触网络的人可能会有一个疑问，单凭一个目的IP地址，数据包就可以穿越半个世界到达目的地吗？

当然是不可以，操作系统在数据包上添加目的IP地址时，就好像我们写信时在里面写了收信人地址一样，信是不会自己走的，真正把信送到目的地的是邮政公司。但邮政公司是怎么运作的，我们是看不到的。同样**数据包到达目的地是需要路由器和路由协议共同完成的**，这和我们现在研究的IP协议是两个不同的部分。
### 11.1.2 IP分片
刚刚在讲到IP协议格式的时候，提到的片偏移就是用来实现对数据包进行分片的。可是为什么数据包要分片呢，把所有信息放在一个数据包中不是更方便？这其实是和一个名为MTU（最大传输单元）的值有关。我们知道**数据包的最外面要添加一个以太网的帧头**，并包装成一个数据帧之后才能传输。由于以太网传输电气方面的限制，**以太网帧的大小都有限制**。每个以太网帧最小也要64Bytes，最大不能超过1518bytes。刨去以太网帧的帧头（DMAC目的地址MAC48bit=6Bytes+SMAC，源MAC地址48bit=6Bytes+Type域2bytes）
14Bytes和帧尾CRC校验部分4Bytes（这个部分有时候也被称作FCS），那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes，这个值我们就把它称之为MTU。这也就是**我们几乎所有设备的MTU值都为1500的原因**。

那么既然最大的数据包只能为1500的话，如果现在要发送一个信息量更大的数据时，又该如何处理呢？实际上，当发送的数据的大小超过1500时，IP层就需要对数据进行分片。**就好像我们要搬家的时候，如果一辆车装不满的时候，就需要分装到几辆车里**。图4就给出了Wireshark中是如何观察到数据包的。
图4 数据包信息面板中查看IP分片
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182316176.png)
在图3中的④和⑤是用于分片的。**④是IP数据包的标识，同一个数据包的各个分片的标识是一样的**，目的端会根据这个标识来判断IP分片是否属于同一个IP数据报。⑤分成两个部分，**前面3位是第一部分为标志位，其中有1位用来表示是否有更多的分片**，如果是最后一个分片，该标志位为0，否则为1。**后面13位为第二部分表示分片在原始数据的偏移**。我们再把这个内容更直观的展示一下，如图5所示。
图5 数据包分片演示
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182317955.png)
好了现在，我们先来看一个正常的分片过程，这个实验很简单，所以我们不再使用ENSP环境，在任何的操作系统中都可以完成这个实验。先启动Wireshark开始捕获数据包，然后打开命令行窗口，在里面发送一个大小为4200Bytes的ICMP请求，如图6所示。
图6 发送一个大小为4200Bytes的ICMP请求
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182317314.png)
使用Wireshark捕获到这个请求，可以看到它被分成了3个数据包，如图7所示。
图7 被分成了3个分片的ICMP请求
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182317466.png)
可以看到这里面的**前两个数据包的长度都是1514Bytes**，最后一个数据包的长度为1282Bytes。我们点击第1个数据包（63号数据包），然后在数据包信息面板里面查看。如图8所示，这个数据包的标识号为8805，标志位为1，偏移量为0。其中包含的数据为1514−14−20=1480Bytes。这里面包含了14Bytes以太网帧头和20BytesIP头。
图8 在数据包信息面板查看第1个数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182318237.png)
接下来，我们来看第2个数据包（64号数据包）。如图9所示，这个数据包的标识
号为8805，标志位为1，偏移量为185Bytes( `185*8=1480bit` )。其中包含的数据也为1514−14−20=1480Bytes。
图9 在数据包信息面板查看第2个数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182319958.png)
第3个数据包（65号数据包）的内容如图10所示。这个数据包的标识号为8805，
标志位为0，表示这是数据包的最后一个分片，偏移量为370Bytes(`370*8=2960bit`)。其中包含的数据为1248Bytes。而且在这个数据包中包含了分片的全部信息，如图11所示。
图10 在数据包信息面板查看第3个数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182319425.png)
图11 分片的全部信息
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182320156.png)
而当目标服务器收到了这几个数据包分片之后，就会按照这个信息组合起来，组合好的数据包如图12所示。
图12 分片的组合方式
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182320511.png)
### 11.1.3 泪滴攻击
**泪滴（teardrop）攻击是基于数据分片传送进行的攻击手段**。在IP报头中有一个偏移字段和一个分片标志（MF），**如果MF标志设置为1，则表明这个IP包是一个大IP包的片断**，其中偏移字段指出了这个片断在整个IP包中的位置。例如，对一个4200Bytes的IP包进行分片（MTU为1480），则3个片断中偏移字段的值依次为：0、1480、2960。这样**接收端就可以根据这些信息成功的组装该IP包**。而如果一个攻击者打破这种正常情况，把**偏移字段设置成不正确的值，即可能出现重合或断开的情况**，就可能导致目标操作系统崩溃。比如，把上述偏移设置为0、1000、2000。

图13中阴影部分的就是两个数据包有重合的地方，**目标设备在接收到这种分片
后就无法重新组合成一个数据包，这就是所谓的泪滴攻击**。这种攻击方式在以前曾经给计算机用户带来了很大的困扰，但是对如今的操作系统基本无效，只是有时攻击者会将其与泛洪相结合来作为一种攻击手段。
图13 泪滴（teardrop）攻击分片的组合
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182321046.png)
到此为止，我们对泪滴攻击的介绍已经结束了，不过在这个学习过程中，你有没有发现这里面的3个分片的颜色呢？其中前两个分片的颜色都是白色的，而最后一个分片却是紫色的。如图14所示，为什么同一个数据包的3个分片却显示了不同颜色呢？
图14Wireshark中数据包显示的不同颜色
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182322193.png)
在Wireshark中不同类型的数据包往往有不同的颜色，那么这些颜色都代表着什么含义呢？
## 11.2 Wireshark的着色规则
在我们使用Wireshark进行工作的时候，可以在数据包列表面板处看到各种类型的数据包都以不同的颜色显示出来。如图15所示，我们可以通过调整“视图”子菜单中的选项来调整颜色的设置。
图15 Wireshark中的着色功能
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182322709.png)
这里面“着色分组列表”选项可以打开或者关闭对数据包的着色，默认情况下是打开的，如果单击这个选项的话，可以切换到关闭状态。这样看到的所有数据包就都是没有颜色的。

可是这些颜色又代表了什么含义呢？如果想要了解到这一点的话，可以点击“着色规则”选项（见图16），这时就会弹出一个“Wireshark着色规则”的对话框。
图16 Wireshark中的着色规则
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182323302.png)
这个对话框中以很直观的形式显示了数据包着色的规则，每一行的格式由前景色和背景色组成，其中前景色就是文字的颜色。这里面内容分成了“名称”和“过滤器”两列，**其中“名称”列给出了当前数据包的类型，“过滤器”使用了前面介绍过的显示过滤器的语法**，这样就可以更明确地指明到底哪些数据包使用当前的格式。

例如图16的第一行的名称就是“BadTCP”，表示不正常的TCP数据包（包括乱序、
重传等），如图17所示这部分流量是使用过滤 `tcp.analysis.flags && !tcp.analysis.window_update` 过滤得到的，符合这个特点的数据包在数据包列表面板中就会以黑底红字的形式显示出来。
图17 “BadTCP”的着色规则
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182324569.png)
这些着色规则以文件的形式保存在“colorfilters”中，**我们也可以在Wireshark的外部使用文本编辑器对其进行处理**。每当Wireshark启动之后，就会**自动加载这个文件**，将里面的规则应用到所有捕获到的数据包上。如果我们需要在Wireshark中创建一个颜色规则，可以按照如下步骤进行。
（1）首先依次单击菜单栏“视图”→“着色规则”。
（2）在弹出的“Wireshark着色规则”，单击左下角的“+”按钮，这样就会在最上方添加新的一行。默认的名称为“Newcoloringrule”，过滤器处为空（见图18）。
图18 添加一条新的着色规则
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182324779.png)
（3）在名称处添加一个名称。
（4）在过滤器中按照显示过滤器的语法添加一个字符串。
（5）如图19所示，单击“前景”按钮，在弹出的Windows调色板中选择指定的颜色。
图19 设定前景色
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182324861.png)
（6）单击“背景”按钮，在弹出的Windows调色板中选择指定的颜色。
（7）这里我们以添加一个Windows操作系统ping命令发出的数据包作为例子，这里名称填写为“WindowsPing”，过滤器为 `(icmp.type==8&&icmp.code==0)and(data.len==32)` ，前景色设置为黑，背景色设置为绿。添加完“着色规则”如图20所示。
图20 添加ping命令发出的数据包的着色规则
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182325985.png)
（8）单击“OK”按钮就可以将这个着色规则应用到Wireshark中了，**从图21中可
以看到这个规则已经起作用了**。
图21 在Wireshark中显示的ICMP数据包
 ![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182325185.png)
如果还需要进一步对数据包应用着色规则进行判定的话，可以在数据包列表面板中单击一个数据包，然后**在数据包详细信息列表处点击Frame层展开**。从图22中可以看到这个数据包符合了名称为“WindowsPing”的着色规则。
图22 在数据包详细信息列表处查看着色规则
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182325565.png)
当不需要其中某一条着色规则时，可以在“Wireshark着色规则”的对话框选中这条规则，然后单击左下方的“-”按钮。

如果你希望能在其他计算机上使用这些自定义着色规则，可以使用“Export”功能将
这些设置以文件的形式导出（见图23），并在别的计算机上可以使用“Import”功能导入这个文件。
图23 将着色规则导出
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182327914.png)

Wireshark中默认也有一个专门用来保存着色规则的文件“colorfilers”。这个文件保存在Windows系统的个人配置文件或者Wireshark安装目录的profiles文件夹中，可以使用文本编辑器进行编辑，这个文件中一般会使用如下的3种符号。
- `#` ：表示一个单行的注释。
- `@` ：表示用于分割着色规则各个字段的分隔符。
- `!` ：表示要停止这个着色规则的使用。

有些时候，会出现一个数据包匹配了两个以上着色规则的情形，例如上例中“Windows ICMP Echo Request”就与系统预设的“ICMP”规则，在这种情况下，显然一个数据包不能同时显示两个不同的颜色，那么它将会遵循哪个规则呢？

==这里面的着色规则按照从上到下的顺序来确定优先性，一个数据包会按照从上到下的顺序来逐个匹配这些规则==，所以我们通常会将一个指定范围小的规则放置在通用规则的前面。
## 11.3 根据TTL值判断攻击的来源
我们在对攻击数据包的IP层进行分析时，还有一个很重要的字段：TTL。TTL的作用是**限制IP数据包在计算机网络中存在的时间**。TTL的最大值是255，不同的操作系统发出数据包的TTL字段值都不相同。==TTL字段由IP数据包的发送者设置，在IP数据包从源主机到目的主机的整个转发路径上，每经过一个路由器，路由器都会修改这个TTL字段值==，具体的做法是把该TTL的值减1，然后再将IP包转发出去。

不同的操作系统的默认TTL值是不同的，所以我们可以通过TTL值来判断主机的操
作系统，但当用户修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也不一定准确。下面是默认操作系统的TTL。
- WINDOWSNT/2000TTL：128
- WINDOWS95/98TTL：32
- UNIXTTL：255
- LINUXTTL：64
- WIN7TTL：64

从TTL值可以大致判断一个数据包要经过多少个路由器才能到达目的主机，例如从TTL的值60可以看出数据包经过64−60=4个路由器到达目的主机。==很多攻击者伪造了源地址对我们的网络进行入侵时，经常会忽略对TTL值的修改==，而我们就可以以此来获得重要的信息。例如我们在前面第10章时，收到了大量不同地址的数据包的那个例子（见图24）。
图24 接收到的大量数据包
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182329606.png)
从表面来看，这些数据包来自不同地方，也去往不同目标。但我们查看这里面数据包的IP协议头时，却发现所有的TTL值都为64（见图25）。
图25 查看到的数据包的TTL值
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202307182330726.png)
==如果这些数据包来自于网络外部，即使是来源于同一台设备，也会因为路径不同而产生不同的TTL值==。而且这些数据包的值全都为64，基本上可以肯定这时攻击者所使用的设备就在网络内部。
## 11.4 小结
在这一章中主要讲解了针对IP协议的一种典型攻击手段：泪滴攻击。首先讲解了IP协议的格式，然后介绍了IP协议的一个重要概念：分片。分片技术为网络带来了很大的便利，但是也被别有用心的人加以利用，而这种攻击的设计思路十分巧妙，了解它有助于拓宽我们思考问题的思路。同时我们在这一章中也介绍了Wireshark的着色规则，只需查看数据包的颜色，就可以判断出它的类型。最后，我们还介绍了IP协议头中一个很有用的字段TTL。