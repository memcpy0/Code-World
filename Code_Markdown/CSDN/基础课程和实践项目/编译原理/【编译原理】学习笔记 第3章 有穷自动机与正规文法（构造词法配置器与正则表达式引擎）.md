@[toc]



---
# 3.0 本章概述
① **自动机**是一种能进行运算并能实现自我控制的装置（一台存储有程序、电源合适的传统计算机，具有进行运算和自我控制的能力，因此也是一部自动机），是描述**符号串处理**的强有力的工具，是**研究词法分析**、**构造词法分析器与正则表达式引擎**的理论基础。本章只限于有穷自动机FA（包括确定性有穷自动机 `DFA` 和非确定性有穷自动机 `NDFA` ）。

② 对NDFA可以使用**子集法**和**造表法**进行确定化，转换为等价的DFA。对DFA则可以进行最小化（化简），其基本思想是**将状态集分解成若干个不相干的子集，使得每个子集中的状态都等价，而不同子集间的状态可区分**。

③ 正规文法与FA关系特殊，**从正规文法可直接构造其自动机**，反之**由自动机也可直接构造其正规文法**。

④ 正规表达式也同FA有着特殊的关系，对于字母表 $\Sigma$ 上的任意一个正规表达式 $e$ ，一定可以构造一个NDFA  $M$ 使得 $L(M) = L(e)$ ；反之对于一个具有输入字母表 $\Sigma$ 的NDFA $M$ ，在 $\Sigma$ 上也可以构造一个正规表达式 $e$ 使得 $L(e) = L(M)$ 。

⑤ 正规语言可用**正规文法**描述，也可用**正规表达式**描述。

⑥ DFA在计算机中有两种表示，一种是**矩阵表示**，另一种是**表结构**。
> 文法 `Grammar` ：生成方法。给出一组构成规则，可以将一个语言的多种语法成分生成出来；
> 自动机 `Automaton` ：识别方法。对于任何给定的语言，判断是否属于自动机描述的语言。









---


# 3.1 有穷自动机的形式定义和表示

> **定义1** 一个**确定性有穷自动机**DFA是一个五元组 $$\text{DFA} = (Q, \Sigma, t, q_0, F)$$ 其中，$Q$ 是非空有穷状态集，$\Sigma$ 是有穷输入字母表，$t$ 是一个映射 $Q\times \Sigma \to Q$
> ，$q_0\in Q$ 是开始状态，$F\subseteq Q$ 是非空终止状态集。

## 3.1.1 状态转换表
有穷自动机中的映射 $t:\ Q\times \Sigma \to Q$ 可以用以下形式描述：$$t(q, a) = q'\quad q, q' \in Q, a \in \Sigma$$ 对于这些映射，可由一个状态转换表给出。

【例】有穷自动机 $A = (Q, \Sigma, t, q_0, F)$ ，其中 $Q = \{q_0, q_1, q_2, q_3\}$ ，$\Sigma=\{a, b\}$ ，$q_0$ 是开始状态，终止状态集 $F = \{q_0\}$ ，其映射 $t:\ Q\times \Sigma \to Q$ 包括 $$\begin{aligned} t(q_0, a) = q_1\quad t(q_0, b) = q_3\\ t(q_1, a) = q_0\quad t(q_1, b) = q_2\\ t(q_2, a) = q_3\quad t(q_2, b) = q_1\\ t(q_3, a) = q_2\quad t(q_3, b)= q_0\end{aligned}$$
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201015193558582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)
由上图可知，对于输入符号 $a, b$ ，若当前状态为 $q_0$ ，则分别转入状态 $q_1, q_3$ ；若当前状态为 $q_1$ ，则分别转入状态 $q_0, q_2$ ；若当前状态为 $q_2$ ，则分别转入状态 $q_3, q_1$ ；若当前状态为 $q_3$ ，则分别转入状态 $q_2, q_0$ 。

## 3.1.2 状态转换图
有穷自动机中的映射 $t:\ Q\times \Sigma \to Q$ 也可以使用状态转换图来描述。上一例子中的有穷自动机 $A$ 的状态转换图如下，状态 $q_0$ **用双圆圈标记**，表明是终止状态；同时**用一个箭头标记**，表明是开始状态——状态 $q_0$ 既是开始也是终止状态，经过输入字母 $a$ 可转换成状态 $q_1$ ：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201015192526640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)
一个状态转换图等价于一个有穷自动机，因为状态转换图中完全包括了**有穷自动机的五个部分**。


## 3.1.3 自动机的等价性
为了讨论自动机的等价性，先要扩充DFA的映射定义。
> **定义2** $\text{DFA} = (Q, \Sigma, t, q_0, F)$ ，扩充的映射 $t:\ Q\times \Sigma^* \to Q$ 定义为 $$\begin{aligned} &t(q, \varepsilon)= q\\ &t(q, a\alpha) =
> t(t(q, a), \alpha)\end{aligned}$$ $q \in Q, a\in \Sigma, \alpha \in
> \Sigma^*$ ，其中 $\alpha$ 是一个符号串。
> <b></b>
> **定义3** $\text{DFA} = (Q, \Sigma, t, q_0, F)$ ，如果 $t(q_0, \alpha) = q \in F$ ，则称符号串 $\alpha$ 可被有穷自动机DFA所接受。由有穷自动机 $A$ 接受的符号串集，记为 $L(A)$ 。

【例】![在这里插入图片描述](https://img-blog.csdnimg.cn/20201015194634698.png#pic_center)
实际上，所有包含偶数个 $a$ 和偶数个 $b$ 的符号串，都能被有穷自动机 $A$ 接受。

> **定义4** 两个有穷自动机 $A_1, A_2$ ，如果 $L(A_1) = L(A_2)$ ，则称自动机 $A_1$ 与 $A_2$ 等价。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201015195347413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)

## 3.1.4 非确定性有穷自动机

> **定义5** 一个非确定性有穷自动机NDFA是一个五元组，$$\text{NDFA}=(Q, \Sigma, t, q_0, F)$$ 其中，$Q$ 是一个非空有穷状态集，$\Sigma$ 是一个非空有穷输入字母集，映射 $t$ 为 $Q\times \Sigma \to Q$的子集 （即
> $t$ 是一个多值映射），$Q_0 \subseteq Q$ 是开始状态集，$F\subseteq Q$ 是终止状态集。

NDFA和DFA的主要区别有二：
- NDFA有一个开始状态集，DFA只有一个开始状态；
- NDFA的映射是 $Q\times \Sigma \to Q$的子集 ，是一个多值映射，DFA的映射是 $Q \times \Sigma \to Q$ ，是一个单值映射。


![在这里插入图片描述](https://img-blog.csdnimg.cn/20201015195941598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)
对NDFA的映射定义同样进行扩充。

> **定义3.6** $\text{NDFA} = (Q, \Sigma , t, Q_0, F)$ ，扩充的映射 $t:\ Q\times \Sigma^*\to Q$的子集定义为：$$\begin{aligned} &t(q, \varepsilon) = \{q\}\\
> &t(q, a\alpha) = t(q_1, \alpha) \cup t(q_2, \alpha)\cup \dots \cup
> t(q_n, \alpha) \end{aligned}$$ 其中，$a\in \Sigma, \alpha \in \Sigma^+ \textcolor{red}\Sigma^*,
> t(q, a) = \{q_1, q_2, \dots, q_n\}$ 。
> <b></b>
> **定义3.7** $\text{NDFA} = (Q, \Sigma, t, Q_0, F)$ ，对于一个符号串 $\alpha \in \Sigma^*$ ，如果 $q \in t(q_0, \alpha)$ ，而 $q_0\in Q_0, q \in F$ ，则称符号串 $\alpha$ 能被该非确定有穷自动机NDFA所接受。能被非确定有穷自动机 $A$ 接受的符号串集，记为 $L(A)$ 。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201015201414474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)

---
# 3.2 NDFA到DFA的转换
## 3.2.1 空移环路的寻找和消除
如果自动机的弧上允许标记 $\varepsilon$ ，则称此自动机为 $\varepsilon$ 自动机，记为 $\varepsilon\text{NDFA}$ 或 $\varepsilon\text{DFA}$ 。对于 $\varepsilon\text{NDFA}$ 总可以构造等价的 $\text{NDFA}$，使得 $L(\varepsilon \text{NDFA}) = L(\text{NDFA})$ ；同理可构造等价的 $\text{DFA}$ ，使得 $L(\varepsilon\text{DFA})= L(\text{DFA})$ 。即可以消除 $\varepsilon$ 自动机中的空移环路。

寻找空移环路的步骤如下：先找到一个有 **$\varepsilon$ 射出的状态结点** $q_1$ ，假设一条 $\varepsilon$ 弧自 $q_1$ 射出，到达结点 $q_2$ 。同时假设结点 $q_2$ 也有一条 $\varepsilon$ 弧射出，到达结点 $q_3$ 。如果 $\varepsilon$ 弧所到达的结点总有 $\varepsilon$ 射出，则此 $\varepsilon$ 自动机必有空移环路。如下图是一个空移环路：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201018102924103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)
找到空移环路之后，要消除它只需要把空移环路上的所有结点 $q_1,q_2,\dots, q_n$ 合并为一个结点，并消除它们所有的 $\varepsilon$ 弧。如果其中某一个结点 $q_i\ (i = 1, 2, \dots, n)$ 是**开始状态或终止状态**，则将此合并之后的新结点相应设置为开始状态或终止状态。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020101810352445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201018103501245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)


---
不要B了，去掉冗余状态？



---
# 3.3 正规文法与有穷自动机
正规文法和FA关系紧密。
## 3.3.1 从正规文法到FA
设正规文法 $G$ 有形如 $U \to aV(a\in V_T, V \in V_N \vee V = \varepsilon)$ 的产生式（即3型文法 $A \to a \vee A \to aB\ \  A,B\in V_N,\ a \in V_T$ 的另一种表达）。**由正规文法 $G$ 可以直接构造一个有穷自动机 $A$** ，使得 $L(A) = L(G)$ ，步骤如下：
1. 令正规文法 $G$ 的**终结符号集**作为有穷自动机 $A$ 的**输入字母表**；
2. 文法 $G$ 的每个**非终结符**都作为自动机 $A$ 的一个**状态**，特别是文法 $G$ 的**开始符**作为自动机 $A$ 的**开始状态**；
3. 在自动机 $A$ 中增加一个**新状态** $z$ 作为自动机的**终止状态**；
4. 对于文法 $G$ 的形如 $U\to aV(a\in V_T\ or\ a=\varepsilon, V\in V_N)$ 的产生式，在自动机 $A$ 中构造形如 $t(U, a) = V$ 的映射；
5. 对于文法 $G$ 的形如 $U\to a(a\in V_T)$ 的产生式，在自动机 $A$ 中构造形如 $t(U, a) = z$ 的映射。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201015203347158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)

## 3.3.2 从FA到正规文法
**由一个有穷自动机 $A$ 也可以直接构造一个正规文法 $G$**，步骤如下：
1. 自动机的每个**状态标记**，均为正规文法的**非终结符**，其中自动机**开始状态**的标记，将作为正规文法的**开始符号**。自动机的**输入字母表**中的所有符号，均作为正规文法的**终结符**；
2. 对于自动机的映射 $t(U, a) = V$（其中 $U, V$ 为自动机的**状态标记**，$a$ 为**输入符号**），构造文法的一条产生式 $U\to aV$（其中 $U, V$ 为文法的**非终结符**，$a$ 为**终结符**）
3. 对于自动机的终止状态 $Z$ ，在正规文法中增加一条产生式 $Z \to \varepsilon$ 。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201015205800168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)

---
# 3.4 正规表达式与FA
## 3.4.1 正规表达式的定义
**定义12** 字母表 $\Sigma$ 上的正规表达式和正规集，递归定义如下：
① $a\in \Sigma$ ，$a$ 是 $\Sigma$ 上的一个正规表达式，它所表达的正规集为 $\{a\}$ ；
② 空串 $\varepsilon$ 是 $\Sigma$ 上的一个正规表达式，它所表达的正规集为 $\{\varepsilon\}$ ；
③ 空集 $\empty$ 是 $\Sigma$ 上的一个正规表达式，它所表示的正规集为 $\empty$ ；


## 3.4.2 正规表达式与FA的对应性
正规表达式和FA是定义语言（符号串集）的两种不同形式。同一个语言即可用FA描述，也可用正规表达式描述，可以证明：
- 对于一个在输入字母表 $\Sigma$ 上的NDFA $M$ ，一定可以在字母表 $\Sigma$ 上构造一个正规表达式 $e$ ，使得 $L(e) = L(M)$ ，其中 $L(e)$ 是正规表达式 $e$ 的正规集，$L(M)$ 是NDFA $M)$ 所能识别的符号串集合；
- 对于一个在输入字母表 $\Sigma$ 上定义的正规表达式 $e$ ，也一定可以用 $\Sigma$ 作为输入字母表，构造一个NDFA $M$ ，使得 $L(M)= L(e)$ 。

---
## 3.4.3 正规表达式到NDFA的转换


---
# 3.5 DFA在计算机中的表示
对于一个$DFA=(Q, \Sigma, t, q_0, F)$ ，如果给出其映射 $t:\ Q\times \Sigma \to Q$ ，那么这个DFA实际上就确定了。因此，**要在计算机中表示一个DFA，只需在计算机中表示它的映射**。

## 3.5.1 矩阵表示法
DFA的映射 $t:\ Q\times \Sigma \to Q$ 写成 $t(q, a) = q',\ q \in Q, q'\in Q, a\in \Sigma$ ，在计算机中可自然用矩阵表示。**其中状态 $q$ 作为矩阵的行，输入字母 $a$ 作为矩阵的列，映象 $q'$ 作为矩阵元素 $t(q, a)$ 的值**。将状态集合中的所有状态排一个序：$q_0, q_1, q_2, \dots, q_n$ ，输入字母表 $\Sigma$ 中的所有字母也排一个序：$a_0, a_1, a_2,\dots, a_m$ ，设 $M$ 是一个二维数组，若 $t(q_i, a_j) = q_k$ ，则令 $M[i][j] = k$ ，其中 $i,k = 0, 1,2,\dots, n;\ j = 0,1,2,\dots, m$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201015165715647.png#pic_center)
## 3.5.2 表结构
DFA的映射 $t:\ Q\times \Sigma \to Q$ 在计算机中也可表示成一种表结构，在这个表结构中**每个状态对应一个表**，表中包括该状态的状态名、从该状态发出的弧数、每条弧上的标记（输入字母）以及弧到达的状态所在表的首地址。其实就是一个邻接表：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201015170017555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)


---
## 1. 词法分析-词法记号
<img src="https://img-blog.csdnimg.cn/20200511133548116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">词法分析在整个编译过程中的地位和作用：
承接源程序和语法分析，读入源代码，输出记号流

<img src="https://img-blog.csdnimg.cn/20200511133647701.png" width="50%">
语法分析器是主导！
<img src="https://img-blog.csdnimg.cn/20200511133707430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">


## 词法单元和词法记号
## 词法记号的描述和识别

词法分析：编译第一步 分词
看一个中文的句子：黄蓉是古代的才女

<img src="https://img-blog.csdnimg.cn/20200511133829169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
PASCAL语言的例子；

L1 : x = y2 + 12;
ID 
<img src="https://img-blog.csdnimg.cn/20200511133957168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
变量：ID
满足某种规则的词法单元，采用同一种记法。

词法单元与词法记号
满足一个给定规则的词法单元，被记为一个词法记号！
词法单元 通过一个模式 映射为一个词法记号

<img src="https://img-blog.csdnimg.cn/20200511134121594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
词法模式：
C语言的标识符：哪些是合法的C标识符？


<img src="https://img-blog.csdnimg.cn/2020051113420164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">常见的词法模式：
词法记号 STRUCT 词法单元例子  模式的非形式描述
FOR
RELOP（关系运算符）
ID
NUM
LITERAL（字符串）
<img src="https://img-blog.csdnimg.cn/20200511134447406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

 下面的四个是稍微复杂的例子

---


词法记号及属性：词法记号、模式、词法单元
名词         大连 软件 大黑山         表示名称的词
连词                和 与 或                和 与 或
词法记号       词法单元例举         模式的非形式化描述

比较规范的形式。下面的形式是远远不够的！

<img src="https://img-blog.csdnimg.cn/20200511134625853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
词法记号及属性
如果简单地把词法记号流传给词法分析器，会产生什么结果？

丢失一些信息。

把里面<img src="https://img-blog.csdnimg.cn/20200511134805742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
通过符号表记录下来！每个词法记号具有一定的含义（属性）
第一个ID
第二个ID
第三个ID

符号表是一个记录员，把当前的词究竟是什么样的含义保持下来，以便后面使用

position := initial + rate * 60    的记号和属性值：
<id , 指向符号表中position条目的指针>
<assign _op>    //赋值运算符

<img src="https://img-blog.csdnimg.cn/20200511135028257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
词法记号的描述与识别

<img src="https://img-blog.csdnimg.cn/20200511135057855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
词法模式的表示方法，是词法记号描述的核心


词法

出现错误！

编译器遇到错误如何处理？
<img src="https://img-blog.csdnimg.cn/20200511144018478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
这种表示方法和程序上的表示方法有距离！更接近程序的表示方式！


---
 ## 2.2. 词法分析-正规式
 一种更规范的模式表示方法——正规式——
<img src="https://img-blog.csdnimg.cn/20200511144229872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">


<img src="https://img-blog.csdnimg.cn/20200511144337767.png" width="50%">


<img src="https://img-blog.csdnimg.cn/20200511144425231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

正规式的表示：
<img src="https://img-blog.csdnimg.cn/20200511144701564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
例子：
 <img src="https://img-blog.csdnimg.cn/20200511145006222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

正规定义：
对正规式命名，让复杂规则表示起来简洁！
- $d_1 \to r_1$ 即把 $r_1$ 命名为 $d_1$
- $d_2 \to r_2$ 从简单到复杂！
- ...
- 
每个正规式名字不同，在 rn正规式里面可以使用d1到d{i-1}的名字，但不能用后面的！


<img src="https://img-blog.csdnimg.cn/20200511145344490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">Pascal语言的标识符模式：
正规式表示：
- 字母为 `letter` 记号：$A-Za-z$
- 数字为 `digit` 记号：$0-9$
- 标识符为 `id` ：`letter (letter | digit)*` 字母开始，后面跟的是字母或数字的闭包！
<img src="https://img-blog.csdnimg.cn/20200511145355114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">C语言的标识符模式，用语言描述的规则，但不是真正的程序！

<img src="https://img-blog.csdnimg.cn/20200511145611642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200511145651380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
无符号数的定义：


先有数字：
- $digit \to 0\ |\ 1\ |\ .. |\ 9$
- $digits \to digit\ digit^*$ 实际就是正闭包！
- `optional_fraction` $\to .digits\ |\ \varepsilon$
- `optional_exponent` $\to (E\ (\ +\ |\ - $
 <img src="https://img-blog.csdnimg.cn/20200511150019488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/2020051115012495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">用简化规则简化为上述的式子！
 <img src="https://img-blog.csdnimg.cn/20200511150405267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
识别空白：blank空格 \tab键 回车
空白行：若干个上述的结合！

描述用正规式，实现识别程序用状态机！
<img src="https://img-blog.csdnimg.cn/20200511150432195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">正规式和状态转换图是如何对应的！
<img src="https://img-blog.csdnimg.cn/20200511150511692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">从起始状态0 到下一个状态1，上面的a是指两个状态间跳转的必要元素。通过识别一个字母a，就从起始状态到结束状态1
同理，识别ab连接
如果源程序正确的话，必须先出现a，然后出现b；

a|b的选择 a的闭包！
<img src="https://img-blog.csdnimg.cn/20200511150737656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200511150829749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">关系运算符的正规式描述对应的状态转换图！
<img src="https://img-blog.csdnimg.cn/20200511150946527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200511151107824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200511151436859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200511151601396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">以上就是这节课的内容！

## 词法分析——有限自动机
词法分析器工作原理：通过扫描源代码
最为重要的是模式的描述，也就是规则的描述——非形式化描述；形式化描述——正规式，它的名字就是我们想要得到的词法记号！
<img src="https://img-blog.csdnimg.cn/20200511162135417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
为了把正规式更加贴近计算机的实现，我们学习有限状态自动机的内容。

从正规式向状态图的转换，我们已经看过了一些例子。但是对于复杂的正规式，我们怎么得到这样的状态转换图？这样就有一定的困难。

我们怎样得到正规式的编译程序呢？两种状态机。
<img src="https://img-blog.csdnimg.cn/2020051116450460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
正规式和NFA对应关系比较明确，因此可以将正规式转换为不确定有限状态自动机，然后转换为确定有限自动机。

DFA是这样一个数学模型。它包括状态集合S、输入字母表$\sum$ 箭头上的字母和符号，转换函数(怎么转换)：move: $S \times \sum \to S$ 状态S通过识别$\sum$中的某一个字母就可以达到另一个状态。

唯一的初态，$s \in S$；终胎不唯一：终态集合$F\subseteq S$，结束状态不唯一！很多状态都可以表示这个串正确。
<img src="https://img-blog.csdnimg.cn/20200511165018159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
NFA是这样一个数学模型，包括：
- 状态集合S；
- 输入字母表$\sum$；转换函数：$S \times (\sum\ \cup\ \{\varepsilon\}) \to P(S)$ 即状态通过识别（输入字符）字母表中的字母或者 空串(可以不经过输入就跳转！)；可以跳转到多个次态中（一个状态对于某个字符，可能有多个输出边）；是不确定性的一个体现！
- 唯一的初态 $s\in S$；
- 终态集合$F\subseteq S$

<img src="https://img-blog.csdnimg.cn/20200511165644848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
以同一个正规式，看看DFA和NFA的区别。
(a | b)* ab 的NFA：识别一个a可以跳转到状态1或者保持为状态0；和正规式的结合更直观、紧密
<img src="https://img-blog.csdnimg.cn/20200511165902251.png" width="50%">确定性更好！
<img src="https://img-blog.csdnimg.cn/20200511165943661.png" width="50%">区别：NFA中允许$\varepsilon$转换边，而DFA中不允许；
NFA中move(s, a)可以是一个多元集合，而DFA中move(s, a)最多只有一个元素。
<img src="https://img-blog.csdnimg.cn/20200511170330695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">DFA或者是NFA？在机器上实现字符串识别过程，基于DFA？还是基于DFA？


<img src="https://img-blog.csdnimg.cn/20200511170432489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
采取一种迂回的策略？
正规式 $\to$ NFA $\to$ DFA
<img src="https://img-blog.csdnimg.cn/2020051117052794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
对于NFA的构建：
从正规式(a | b) * ab的自动机构造：
<img src="https://img-blog.csdnimg.cn/20200511170607834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200511170626738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200511170813490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/2020051117085937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">画一个闭包：一个开始状态，一个结束状态，可以直接一条$\varepsilon$边。类似一个平底锅把？
<img src="https://img-blog.csdnimg.cn/20200511170914903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
NFA构建示例：(a | b)* ab $\to$ NFA，下面看看它的分解动作：

先画a和b，然后选择；然后闭包；然后连接一个a，然后连接一个b
<img src="https://img-blog.csdnimg.cn/20200511171518637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
## 词法分析——DFA构建
想把正规式转换为一个DFA的话必须先迂回，然后再化简！现在化简得到DFA，这样的DFA是最简的吗？

### 1. 子集构造法
策略：先构造NFA，再去掉其中的不确定性，转换为DFA；
三大步骤：
- NFA构建
- NFA->DFA的转换（子集构造法）
- DFA化简

简单来说，在NFA中 $\varepsilon$ 边不确定的，去掉；如果可以从NFA的一个状态跳转到多个状态，就把这些状态合并到一个集合中，变成一个状态！这就是子集构造法，NFA的多个状态就是这里的状态的子集。


<img src="https://img-blog.csdnimg.cn/20200511172307551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
子集构造法：整个过程的原理：DFA的一个状态时NFA的一个状态集合。有 $\varepsilon$ 边的话也可以合并！
<img src="https://img-blog.csdnimg.cn/20200511172417591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">- 通过一个状态，有 $\varepsilon$ 边随意到达的多个次态（可以有多个 $\varepsilon$ 边形成的路径），可以合并到一起。比如下面的状态0，可以通过 $\varepsilon$ 边到达的有 $1,2,4, 7$。DFA中这几个状态合并为新状态，这里称为 $A$，由 $A$ 跳转可到的状态。遇到a，从2和7状态出发分别到达3和8状态；然后对3和8状态求 $\varepsilon$ 闭包，得到(6,7,1,2,4) ），这就是 B = {1, 2, 3, 4, 6, 7, 8}；状态A遇到字母b，只有4状态调到5，5求$\epsilon$闭包得到 (6,7,1,2,4)状态，合起来是一个新的状态集合，为C。
<img src="https://img-blog.csdnimg.cn/20200511180226310.png" width="50%">状态B遇到a回到B本身，遇到b产生新状态集合D={1,2,4,5,6,7,9}。

在这些状态中，开始状态是包含原有开始状态0的状态A，结束状态是所有包含原有结束9的状态集合，这里只有D。转换后的DFA状态图中，就是D为结束状态。


<img src="https://img-blog.csdnimg.cn/20200511181227566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/2020051118312944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">一开始的NFA只有3个状态，我们转换得到的DFA有4个状态集合，而实际上我们希望得到的是左侧的DFA，最简的DFA，3个状态，便于提高编译器的效率：
<img src="https://img-blog.csdnimg.cn/20200511183407342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
### 2. DFA化简
<img src="https://img-blog.csdnimg.cn/20200511183504503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200511183550598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
多个状态遇到同样的串，得到同样的次态，就可以合并到一起，功能不可区分；

<img src="https://img-blog.csdnimg.cn/20200511183808554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">DFA化简的途径：
<img src="https://img-blog.csdnimg.cn/20200511183855615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
化简时DFA的状态转换函数必须是一个完全转换的函数，意思是对于图中的每个状态，是否有所有的转换(a和b)和输出(a和b)；不是的话，就会补入一个死状态，将其他状态缺少的转换和输出都指向它，右图是E，只有输入没有输出。死状态是因为E不会再跳转到其他地方，不会影响原有的输出，不改变原有有限状态自动机的结果。
<img src="https://img-blog.csdnimg.cn/20200511183904574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200511185652692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
化简的过程：
1. 分成两个集合：可接受状态{D}和不可接受状态{A,B,C}。
2. 对于move({A,B,C},a) - {B}，move({A,B,C}, b) = {C, D}，将B分开来；
3. 得到{A,C}和{B}，{D}；move({A,C}, a) = {B}, move({A,C}, b) = {C}。因此{A,C}功能相同，合并得到下图：
<img src="https://img-blog.csdnimg.cn/20200511185639760.png" width="50%">


<img src="https://img-blog.csdnimg.cn/20200511185828662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">由于正规式的表达能力有限，我们使用上下文无关文法，从数学上来说，是一个四元组的表达形式，可以用来推导从而产生图形化的表示方式。

<img src="https://img-blog.csdnimg.cn/20200512181033849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">给定一个句子，`id + id * id`：


---


## 2. first follow
重点学习first集，FOLLOW集合，定义LL(1)文法。

First & Follow：$FIRST(\alpha) = \{\ a\ |\ \alpha \to *a..., a \in V_T\}$ 都是终结符的集合。
<img src="https://img-blog.csdnimg.cn/20200512182805190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">First集合和Follow集合的计算方法：
- First集合计算方法：
<img src="https://img-blog.csdnimg.cn/20200512182939930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
$S \to BA\ ;\quad A \to BS\ |\ d\ ; \quad B\to aA\ |\ bS\ |\ c$
步骤1：`FIRST(S) = FIRST(B)`
$FIRST(A) = FIRST(B) \cup {d}$
$FIRST(B) = \{a, b, c\}$
$FIRST(S) = \{a, b, c, d\}$

$E\to TE'$

<img src="https://img-blog.csdnimg.cn/20200512183528546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
FIRST集合FOLLOW集：
![FIRST](https://img-blog.csdnimg.cn/20200512183625305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
FOLLOW集合计算方法：
- 对文法开始符号 `S`， 置 `$` 于 $FOLLOW(S)$ 中。
- 若有 $A\to \alpha B\beta$ ，则将$FIRST(\beta)\ \backslash\ \{\varepsilon\}$ 加入 $FOLLOW(B)$ 中，此处 $\alpha$ 可为空；
- 若 $A\to \alpha B$ 或者 $A\to \alpha B\beta$ ，且 $\beta \to *\varepsilon$ （即 $\varepsilon$ 属于 $FIRST(\beta)$ ），则将 $FOLLOW(A)$ 加入 `FOLLOW(B)` 中，此处 $\alpha$ 可为空。

计算FIRST集合之后才计算FOLLOW集合！
<img src="https://img-blog.csdnimg.cn/2020051218441491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200512184757177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200512184843396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200512184917692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200512203925832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200512203948220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

---
## 3. LL1
在FIRST集合和FOLLOW集定义的基础上加了两个条件，就产生了LL1文法。

<img src="https://img-blog.csdnimg.cn/20200512204627410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200512204800317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200512204948810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">上面的是LL1文法。
<img src="https://img-blog.csdnimg.cn/2020051220505394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200512205159574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"> 


----
## 4. 预测分析器
<img src="https://img-blog.csdnimg.cn/20200512205319820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">递归下降分析方法：将对应的文法改写成一个程序；

递归的分析程序：$S\to BA$ ；$A\to BS\ |\ d$ ；$B\to aA\ |\ bS\ |\ c$

<img src="https://img-blog.csdnimg.cn/20200512205542252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
每一次写递归下降分析程序的时候，我们观察到，只需要观察文法的内容，然后写成程序。

写一个分析过程；
递归下降的预测方法：
<img src="https://img-blog.csdnimg.cn/20200512205725934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
一个辅助过程：
```c
void match(terminal t) {
	if (lookahead == t) lookahead = nextToken();
	else error();
}
```
对type，根据文法写出来如下：
<img src="https://img-blog.csdnimg.cn/20200512205931694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">对于simple：
<img src="https://img-blog.csdnimg.cn/20200512210022848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

非递归下降的分析程序如下：
如果栈底的 `$` 和程序输入中我们自行添加的 `$` 匹配，就说明成功匹配结束。分析表是整个程序的中心和基础，预测分析表用于驱动分析 的全过程。我们的程序每次根据栈顶的符号和一个输入的符号，来查预测分析表，决定下一步的动作。
<img src="https://img-blog.csdnimg.cn/20200512210456932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">看一个预测分析表的例子：竖向的都是非终结符，横向的是输入符号，中间是产生式。每次根据非终结符和输入符号查表，根据产生式运行；如果查表是空白，说明程序错误。



<img src="https://img-blog.csdnimg.cn/20200512232321970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
预测分析器接受输入 `id * id + id` 的动作；
| 栈  | 输入   | 输出  |  |
|:-:|:-:|:-:|:-:|
|  $E  | id * id + id$  | 
|  |   |  $E \to TE'$


一个符号消耗掉了
<img src="https://img-blog.csdnimg.cn/20200512233230916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
后面的跟之前一样的过程；


<img src="https://img-blog.csdnimg.cn/20200512233359345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200512233451129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
其他没有填的都是空串！

文法 $S\to ACD\ ; \ A \to  a\ |\ \varepsilon\ ; \ C\to c \ ; \ D\to d$
FIRST(S) = {a, c}
FIRST(A) = {a, $\varepsilon$ }
FIRST(C) = {c}
FIRST(D) = {d}
FOLLOW(S) = {\$}
FOLLOW(A) = {c}
FOLLOW(C) = {d}
FOLLOW(D) = {\$}

<img src="https://img-blog.csdnimg.cn/20200512234006285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200512234037764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200512234209714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200512234303396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">LL(1)文法的证明：构造出的分析表没有多重定义的条目




---
## 5. 语言和文法
学习语言和文法的内容
一个上下文无关的文法G，包括4个组成部分：一组非终结符号，一组终结符号，一个开始符号，一组产生式。

非上下文无关的语言结构：

$L_1 = \{wcw\ |\ w 属于(a|b)*\}$ ：标识符的声明应该先于其引用的抽象
$L_2 = \{a^nb^mc^nd^m\ |\ n\ge 0,\ m \ge 0\}$ ：形参个数和实参个数应该相同的抽象
$L_3 = \{a^nb^nc^n\ |\ n \ge 0 \}$ ：早先排版描述的一个现象的抽象

$w^R$ 是 $w$ 的逆：
<img src="https://img-blog.csdnimg.cn/20200512235041339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
 <img src="https://img-blog.csdnimg.cn/20200513011720375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
 形式语言鸟瞰：
文法 $G = \{V_T, V_{N}, S, P\}$    短语文法 
0型文法：$\alpha \to \beta,\ \alpha , \beta \in (V_n\cup V_T)^*, |\alpha| \ge 1$
1型文法：$|\alpha| \le |\beta|$ ，但是 $S\to \varepsilon$ 可以例外，上下文有关文法
2型文法：

语法分析之所以采用上下文无关文法是因为它的描述能力最强
<img src="https://img-blog.csdnimg.cn/20200513012253350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200513012413811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

---
## 6. 归约句柄
之前学了自上而下的分析，一直使用的是最左推导，现在是自下而上的分析，最右推导。
<img src="https://img-blog.csdnimg.cn/20200513133148490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
看一个例子，在自上而下的分析中，我们将
 <img src="https://img-blog.csdnimg.cn/20200513133340967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
 <img src="https://img-blog.csdnimg.cn/20200513133511440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">归约为产生式的开始符号！
 <img src="https://img-blog.csdnimg.cn/20200513133631443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
 归约，是自下而上分析中的重要动作；对应最右推导的逆过程：
 <img src="https://img-blog.csdnimg.cn/20200513133820713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
 <img src="https://img-blog.csdnimg.cn/20200513151741227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
 归约的过程中，(从左往右匹配)一个和产生式右部匹配的子串，我们给它一个名字——句柄，
 
<img src="https://img-blog.csdnimg.cn/20200513152130143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
如果文法是二义的，句柄不唯一！
<img src="https://img-blog.csdnimg.cn/20200513152351767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/2020051315242149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200513153015538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200513153442443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200513153707182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">


---
## 7. 移进归约分析过程
语法分析中自下而上分析，使用移进-归约分析器。输入在最上部；防止 $ 符号标志输入的结束。
从左到右读取符号！

分析器的4种动作：
- 移进动作：将下一个输入符号压入栈中；

<img src="https://img-blog.csdnimg.cn/20200513153956765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200513154145571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200513154204869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200513154402331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
归约后：

<img src="https://img-blog.csdnimg.cn/20200513154454799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200513154550990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200513154612131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">发现二义性了，假设选择移进：

<img src="https://img-blog.csdnimg.cn/20200513154950553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
最后一个符号移进到栈中：
<img src="https://img-blog.csdnimg.cn/20200513155044853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
仍然根据输入符号和栈顶元素决定下一步的动作，继续去判断一下是否有句柄出现？
<img src="https://img-blog.csdnimg.cn/20200513155140909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">将id3移除，将E移入栈中：
<img src="https://img-blog.csdnimg.cn/20200513155207669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
继续将E移入栈中！
<img src="https://img-blog.csdnimg.cn/20200513155245637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200513155259823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">问题：
<img src="https://img-blog.csdnimg.cn/20200513155314987.png" width="50%"><img src="https://img-blog.csdnimg.cn/20200513155709327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">冲突-移进归约冲突！

出现下图中的问题的原因在于文法本身包含一个归约-归约冲突！
<img src="https://img-blog.csdnimg.cn/20200513155909246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">


---
## 8. LR分析器
这一节我们学习语法分析 中 自下而上分析中一类重要的文法——LR分析文法及LR分析器。LR(1)简称为LR文法。
<img src="https://img-blog.csdnimg.cn/2020051316042085.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200513160706763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
<img src="https://img-blog.csdnimg.cn/20200513211614628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

先来学习一下整个LR分析器的特点，以及移进归约的动作：

比之前的分析器多了状态，表示更多的含义。
<img src="https://img-blog.csdnimg.cn/20200513211703820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
初始格局：只有初始状态在栈顶；输入符号指向a1；先查动作表，根据动作进行移进或归约；
<img src="https://img-blog.csdnimg.cn/20200513211814497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200513211900259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">根据sm状态和输入ai，查动作表，于是移进。
<img src="https://img-blog.csdnimg.cn/20200513211947271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
归约之前：按照A \to \beta 归约；弹出栈！两倍长度
<img src="https://img-blog.csdnimg.cn/20200513212011770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">\beta 长度两倍的符号 

<img src="https://img-blog.csdnimg.cn/20200513212059491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
之后再进栈：添加归约之后的状态，查动作表；如果状态是s，压入栈中！
<img src="https://img-blog.csdnimg.cn/20200513212208528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
接受的格局：根据栈顶的状态s和输入符号 $ 
发现动作表写的是接受的状态，而且输入处理到了最后的符号，整个栈里面也只有X1，文法的开始符号；此时我们认为已经结束，

报错的状态：查表的时候发现为没有定义，空白，即当前的输入不满足当前的文法
<img src="https://img-blog.csdnimg.cn/20200513212535480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

---
## 9. 活前缀
语法分析中的活前缀。

右句型，进行最右推导时形成的句型。
假设 $\omega$ 全都是终结符的串；不超过 $\beta$ 的右边，都是活前缀！$\beta$ 是句柄！
<img src="https://img-blog.csdnimg.cn/20200513213245623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200513214653305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/2020051321482645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"> <img src="https://img-blog.csdnimg.cn/2020051321495434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
下面的A由归约得到！
<img src="https://img-blog.csdnimg.cn/20200513215041424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">




---
## 10. SLR
自下而上的SLR分析 需要 识别活前缀的DFA，还需要先计算LR(0)项目集，然后才能构建识别活前缀的DFA，构造SLR分析表
<img src="https://img-blog.csdnimg.cn/20200513215243635.png" width="50%">LR分析的核心工作：构建识别活前缀的DFA；基于DFA构建分析表
<img src="https://img-blog.csdnimg.cn/20200513215340822.png" width="50%">
直接画出是很难的！
<img src="https://img-blog.csdnimg.cn/20200513222351622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
特例：$A \to \varepsilon$
<img src="https://img-blog.csdnimg.cn/20200513222626643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">使用E'代替E
 <img src="https://img-blog.csdnimg.cn/20200513232720911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">从文法构造识别活前缀的DFA
 

---
## 11. LR


---
## 12. LALR




---
## 13. LR分析方法特点




----
## 14. 非二义且非LR的上下文无关语法





----

# 四、语法制导的翻译

# 五、运行时存储


---
# 六、中间代码生成
## 1. 中间代码生成概述
从图中可以看出来，中间代码生成处于前端的最后一个阶段；即我们完成词法分析、语法分析、语义分析后，将我们的结果翻译成中间代码，供编译器的后端使用。
<img src="https://img-blog.csdnimg.cn/2020051400262654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/202005140027175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/2020051400275615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200514003124747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200514003420503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200514003551872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

<img src="https://img-blog.csdnimg.cn/20200514003924800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200514004444637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200514004626284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200514004715647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200514005015810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">每个变量只有一次赋值，静态单赋值！
 <img src="https://img-blog.csdnimg.cn/20200514005154161.png" width="50%">
 
## 声明语句-作用域信息
<img src="https://img-blog.csdnimg.cn/20200514005406447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200514005506130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">


---
# 七、代码生成

