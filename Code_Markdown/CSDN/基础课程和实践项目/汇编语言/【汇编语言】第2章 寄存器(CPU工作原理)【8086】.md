 
@[toc]
> CPU概述
一个典型的**CPU**由**运算器、控制器、寄存器**等器件组成，这些器件靠**内部总线**相连。
内部总线实现**CPU内部各个器件**之间的联系。外部总线实现**CPU和主板上其它器件**的联系。
>
> 寄存器概述：
> 8086CPU有14个寄存器，它们的名称为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。以后会陆续介绍。

# 2.1 通用寄存器
$8086CPU$ **所有的寄存器都是 $16$ 位的**，可以存放两个字节。
- $AX,BX,CX,DX$：通常用来存放**一般性数据**，被称为通用寄存器。

下面以AX为例，我们看一下**寄存器的逻辑结构**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324005847661.png)
一个 $16$ 位寄存器可以存储一个 $16$ 位的数据，所能存储的数据的最大值为多少？答案：$2^{16}-1$。

$e.g.$ 数据：$18$，二进制表示：$10010_2$ 在寄存器AX中的存储：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324012052996.png)
$e.g.$ 数据：$20000$，二进制表示：$0100111000100000_2$ 在寄存器AX中的存储：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324012205170.png)
$8086$ 上一代CPU中的寄存器都是 $8$ 位的；**为保证兼容性**（与上一代兼容），这四个寄存器都可以**分为两个独立的8位寄存器**使用，也就是高八位和第八位：
- AX可以分为AH和AL；
- BX可以分为BH和BL；
- CX可以分为CH和CL；
- DX可以分为DH和DL。

那么怎么兼容呢？把以前的用到的八位寄存器，全部对应到低八位，而高八位则全部填 $0$，当做不存在。

以AX为例，$8086$ CPU的 $16$ 位寄存器分为两个 $8$ 位寄存器的情况：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324012357959.png)

AX的低 $8$ 位构成了AL寄存器，高 $8$ 位构成了AH寄存器。AH和AL寄存器是**可以独立使用的 $8$ 位寄存器**。

一个 $8$ 位寄存器所能存储的数据的最大值是多少？答案：$2^8-1$。


![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324012803232.png?x-oss-process=imag/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)


# 2.2 字在寄存器中的存储
一个**字**可以存在一个 $16$ 位寄存器中，这个**字的高位字节**和**低位字节**自然就存在这个寄存器的**高8位寄存器**和**低8位寄存器**中。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020032401290356.png)
由于一个内存单元可以存放 8位数据，CPU中的寄存器又可存放 n 个 8位数据。也就是说，计算机中的数据大多
   是由1~N个8位数据构成的。
用十六进制来表示数据可以直观的看
   出这个数据是由哪些8位数据构成的。
示例



2.3 几条汇编指令
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324101456119.png)
CPU执行下表中的程序段的每条指令后，对寄存器中的数据进行的改变。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324101514385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324101531141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
这里的丢失，指的是进位制不能在 8 位寄存器中保存，但是 CPU 不是并真的不丢弃 这个进位值，这个问题会在后面的课程中讨论。


检测点2.1（Page 18）

没有通过检测点请不要向下学习！
2.4 物理地址
CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。
　每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为物理地址。


2.5 16位结构的CPU
概括的讲，16位结构描述了一个CPU具有以下几个方面特征：
1、运算器一次最多可以处理16位的数据。

2、寄存器的最大宽度为16位。

3、寄存器和运算器之间的通路是16位的。

2.6 8086CPU给出物理地址的方法
8086有20位地址总线，可传送20位地址，寻址能力为1M。
8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K。

8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。

8086CPU相关部件的逻辑结构

在8086CPU内部用两个16位地址合成的方法来形成一个20位的物理地址

地址加法器合成物理地址的方法：
         物理地址=段地址×16+偏移地址

例如：
  8086CPU访问地址为123C8H的内存单元

  由段地址×16引发的讨论

2.7 “段地址×16+偏移地址
  =物理地址”的本质含义
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324101707574.png)
观察移位次数和各种形式数据的关系：
（1）一个数据的二进制形式左移1位，相当于该数据乘以2；
（2）一个数据的二进制形式左移N位，相当于该数据乘以2的N次方；
（3）地址加法器如何完成段地址×16的运算？
         以二进制形式存放的段地址左移4位。

2.8 段的概念
两个比喻说明：
说明“基础地址+偏移地址 = 物理地址” 的思想：第一个比喻

说明“段地址×16+偏移地址=物理地址”的思想：第二个比喻
   8086CPU就是这样一个只能提供两张3位数据纸条的CPU。
   “基础地址+偏移地址 = 物理地址”

比如说，学校、体育馆同在一条笔直的单行路上（学校位于路的起点0米处）。
读者在学校，要去图书馆，问我那里的地址，我可以用几种方式描述这个地址？
（1）从学校走2826m到图书馆。这2826可以认为是图书馆的物理地址。
（2）从学校走2000m到体育馆，从体育馆再走826m到图书馆。
第一个距离2000m是相对于起点的基础地址；
第二个距离826m是将对于基础地址的偏移地址。
比如我们只能通过纸条来通信，读者问我图书馆的地址，我只能将它写在纸上告诉读者。
显然我必须有一张可以容纳 4 位数据的纸条才能写下2826这个数据：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324101740822.png)不巧的是，没有能容纳4位数据的纸条，仅有两张可以容纳3位数据的纸条。
这样我只能以这种方式告诉读者2826这个数据：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324101759713.png)错误认识：
内存被划分成了一个一个的段，每一个段有一个段地址。
其实：
内存并没有分段，段的划分来自于CPU，由于8086CPU用“（段地址×16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324101825108.png)我们可以认为：地址10000H~100FFH的内存单元组成一个段，该段的起始地址（ 基础地址）为10000H，段地址为1000H，大小为100H。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020032410184220.png)
我们也可以认为地址10000H~1007FH、10080H~100FFH 的内存单元组成两个段，它们的起始地址（ 基础地址 ）为10000H和10080H，段地址为：1000H  和1008H，大小都为80H。

以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。
两点需要注意
内存单元地址小结
特别提示
（1）段地址×16 必然是 16的倍数，所以一个段的起始地址也一定是16的倍数；
（2）偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K。

CPU访问内存单元时，必须向内存提供内存单元的物理地址。
8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。

思考两个问题
（1）观察下面的地址，读者有什么发现？


![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324101936352.png)

结论：CPU可以用不同的段地址和偏移地址形成同一个物理地址。
（2）如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可以定位多少内存单元？
结论：偏移地址16位，变化范围为0~FFFFH，仅用偏移地址来寻址最多可寻64K个内存单元。
比如：给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H~1FFFFH。
在8086PC机中，存储单元的地址用两个元素来描述。即段地址和偏移地址。
“数据在21F60H内存单元中。”对于8086PC机的两种描述：
（a）数据存在内存2000:1F60单元中；
（b）数据存在内存的2000段中的1F60H单元中。
可根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。

检测点2.2（Page 23）

没有通过检测点请不要向下学习！


2.9 段寄存器

段寄存器就是提供段地址的。
   8086CPU有4个段寄存器：
		CS、DS、SS、ES

当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。


2.10 CS和IP
CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。

    CS为代码段寄存器；
    IP为指令指针寄存器。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324102108886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)（1）从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；
（2）IP = IP + 所读取指令的长度，从而指向下一条指令；
（3）执行指令。 转到步骤 （1），重复这个过程。
在 8086CPU 加电启动或复位后（ 即 CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。
内存中指令和数据没有任何区别，都是二进制信息，CPU在工作的时候把有的信息看作指令，有的信息看作数据。
CPU根据什么将内存中的信息看作指令？
   CPU将CS:IP指向的内存单元中的内容看作指令。
在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。
如果说，内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过。
在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。
CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令。
我们如何改变CS、IP的值呢？
8086CPU必须提供相应的指令
先回想我们如何修改AX中的值？
mov指令不能用于设置CS、IP的值，
   8086CPU没有提供这样的功能。
8086CPU为CS、IP提供了另外的指令来改变它们的值：转移指令
mov 指令
如：mov ax,123
mov指令可以改变8086CPU大部分寄存器的值，被称为传送指令。
能够通过mov 指令改变CS、IP的值吗？
同时修改CS、IP的内容：
	jmp 段地址：偏移地址
		jmp 2AE3:3
		jmp 3:0B16
	功能：用指令中给出的段地址修改CS，偏移地址修改IP。
仅修改IP的内容：
	jmp 某一合法寄存器
		jmp ax   （类似于 mov IP,ax）
		jmp bx
	功能：用寄存器中的值修改IP。
内存中存放的机器码和对应汇编指令情况： （初始：CS=2000H，IP=0000H）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324102308617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)







请写出指令执行序列：

（1）mov ax,6622
（2）jmp 1000:3
（3）mov ax,0000
（4）mov bx,ax
（5）jmp bx
（6）mov ax,0123H
（7）转到第（3）步执行

2.12 代码段
对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。
可以将长度为 N（ N≤64KB ）的一组代码，存在一组地址连续、起始地址为 16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。

例如

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200324102231631.png)
这段长度为 10 字节的字节的指令，存在从123B0H~123B9H的一组内存单元中，我们就可以认为，123B0H~123B9H这段内存单元是用来存放代码的 ，是一个代码段 ，它的段地址为123BH，长度为10字节。

如何使得代码段中的指令被执行呢？
将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义得代码段中的指令当作指令来执行。
CPU 只认被 CS:IP 指向的内存单元中的内容为指令。
所以要将CS:IP指向所定义的代码段中的第一条指令的首地址。
CS = 123BH，IP = 0000H。

1、段地址在8086CPU的寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址。
2、CS存放指令的段地址，IP存放指令的偏移地址。
   8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。

3、8086CPU的工作过程：
（1）从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；
（2）IP指向下一条指令；
（3）执行指令。（转到步骤（1），重复这个过程。）
4、8086CPU提供转移指令修改CS、IP的内容。


检测点2.3（Page 33）

没有通过检测点请不要向下学习！


