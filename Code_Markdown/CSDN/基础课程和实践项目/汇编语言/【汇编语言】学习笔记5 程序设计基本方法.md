@[toc]

 


---
# 实方式指令寻址与指令系统

## 指令的基本寻址方式
8086 CPU的指令系统的基本指令包括: 
数据传送类指令、算术运算类指令、位操作类指令、串操作类指令、控制转移类指令、处理机控制类指令等。后几节将分别介绍这些指令的语句格式和功能。

8086 CPU的指令系统的基本指令包括: 
数据传送类指令、算术运算类指令、位操作类指令、串操作类指令、控制转移类指令、处理机控制类指令等。后几节将分别介绍这些指令的语句格式和功能。

<img src="https://img-blog.csdnimg.cn/20200516100033402.png" width="40%">

PC微机的多数指令有一个或两个操作数，当然也可以没有操作数，常见的表示形式如下:
            OP   操作数
            OP  目的操作数   源操作数 
            OP                          
示例:
单操作数指令只需指定一个操作数。例如将寄存器AX的内容加1后，其和回送到AX，指令的符号表示形式为:
INC     AX     ;  AX+1→AX
双操作数指令需要指定两个操作数.当源操作数和目的操作数进行运算后，多数指令将其结果回送到目的操作数的位置。例如寄存器BX与CX的内容相减后，其差送入BX的指令为:
SUB    BX，CX  ;  BX-CX→BX
无操作数指令，即隐含操作数指令，是指在OD位置虽然未明确给出操作数，但在指令OP中隐含有事先安排的操作数。例如:
 CLC         ;     0→CF
  表示将标志寄存器中的CF位清0。

### 寻址方式
### 立即寻址(Immediate Addressing)
立即寻址方式中，指令操作码和操作数都在存储器代码段中。
汇编格式：n（n为立即操作数，是用8位或16位二进制补码表示的有符号数）
功能：操作数存放在存储器，指令下一单元的内容为立即操作数n。
图形表示： 
<img src="https://img-blog.csdnimg.cn/20200516100205826.png" width="40%">
示例
MOV  AX， 10
执行后（AX）=？
该例中源操作数为立即寻址方式，立即数为10，存放在指令的下一单元。
执行：10→AX
执行后：（AX）=000AH 
图形表示：<img src="https://img-blog.csdnimg.cn/2020051610021995.png" width="40%">



### 寄存器寻址(Register Addressing)
寄存器寻址方式的操作数在指令指明的寄存器中。
    功能：操作数直接存放在寄存器中。
图形表示：
         <img src="https://img-blog.csdnimg.cn/20200516100159334.png" width="40%">下列程序执行后，（AX）=？，（BX）=？
     MOV  AX，1234H
     MOV  BX，5678H
     ADD  AX，BX
该程序中MOV指令为数据传送指令操作符，ADD指令为加法指令操作符，三条指令皆为双操作数指令。第一、二条指令AX、BX皆为目的操作数地址，为寄存器寻址方式。第三条指令中，AX为目的操作数地址，BX为源操作数地址。源地址和目的地址皆为寄存器寻址方式。
执行：
         1234H→AX
         5678H→BX
      （AX）+（BX）→AX
执行后：（AX）=68ACH，（BX）=5678H
图形表示：
<img src="https://img-blog.csdnimg.cn/20200516100304976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">


### 直接寻址(Direct Addressing)
指令操作码OP后直接给出操作数的16位偏移地址EA。OP与直接地址在代码段，操作数据一般在数据段。
功能：指令下一字单元的内容是操作数的偏移地址EA。
图形表示：
<img src="https://img-blog.csdnimg.cn/20200516110027992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">寄存器和存储器内容为：（AX）=1212H，BUF为数据段定义的变量，其偏移地址是2000H，（DS）=3000H，
【例】（32000H）=4545H。
执行指令：MOV  AX ，BUF
执行后：（AX）=?
执行：（32000H）→AX
执行后：（AX）=4545H
图形表示：
<img src="https://img-blog.csdnimg.cn/2020051611010055.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">


### 寄存器间接寻址(Register Indirect Addressing)
寄存器间接寻址方式中，寄存器R的内容为操作数的偏移地址EA，操作数在存储器中，即:
           EA=BX∨BP∨DI∨SI
功能：操作数存放在存储器，寄存器R存放操作数的偏移地址EA。
偏移地址EA计算方法如下：
<img src="https://img-blog.csdnimg.cn/20200516110150234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">

【例】寄存器和存储器内容分别为：（AX）=0，（BP）=0030H，（SS）=2000H，（20030H）=1234H
执行指令：MOV  AX ，[BP]  
执行后：（AX）=?，（BP）=?，（SS）=?，（20030H）=?
图形表示：
<img src="https://img-blog.csdnimg.cn/20200516110242941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">                               


### 寄存器相对寻址(Register Relative Addressing)

寄存器相对寻址方式操作数的偏移地址EA为寄存器的内容加位移量，操作数在存储器中。
汇编格式：X[R]（X表示位移量，是8位或16位二进制补码表示的有符号数）
功能：操作数存放在存储器，寄存器R的内容加位移量X为操作数的偏移地址EA。
图形表示：
<img src="https://img-blog.csdnimg.cn/20200516110305315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">偏移地址EA计算方法如下：
<img src="https://img-blog.csdnimg.cn/20200516110315164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">【例】设执行前： （AX）=0040H，（BX）=0030H，（DS）=2000H，（20036H）=0050H 
执行指令：ADD   6[BX]，AX
执行后：（AX）=?，（BX）=?，（DS）=?，（20036H）=?
图形表示如下： 
<img src="https://img-blog.csdnimg.cn/20200516110333351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">执行：（20036H）+（AX） →20036H
执行后：（AX）=0040H，（BX）=0030H，（DS）=2000H，（20036H）=0090H。


### 基址变址寻址(Based Indexed Addressing)
基址变址寻址方式中，操作数的偏移地址EA是指令中基址寄存器内容加上变址寄存器内容之和，操作数在存储器中。
汇编格式： [BR] + [IR]
功能：操作数存放在存储器，BR的内容加IR的内容是操作数的偏移地址EA。
图示如下:

<img src="https://img-blog.csdnimg.cn/20200516110402251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
偏移地址EA计算方法如下：
<img src="https://img-blog.csdnimg.cn/20200516110416374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">

### 相对基址变址寻址(Relative Based Indexed Addressing)
相对基址变址寻址方式中，操作数的偏移地址EA是指令中基址寄存器内容、变址寄存器内容、位移量Ｘ三项之和，操作数在存储器中。
汇编格式：X[BR+IR]
功能：操作数存放在存储器，BR的内容加IR的内容加位移量X是操作数的偏移地址EA。
图形表示：

<img src="https://img-blog.csdnimg.cn/20200516110433170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
偏移地址EA计算方法如下：
<img src="https://img-blog.csdnimg.cn/20200516110442993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
## 数据寻址与数据结构的关系
多种寻址方式能方便、灵活的存取操作数, 支持高级语言的某些数据结构。
1.简单变量寻址
2.数组或表格数据的寻址
3.记录型数组的寻址
    
### 1.简单变量寻址
   存取简单变量有时使用直接寻址方式，如果变量有基本地址就将基本地址→BX∨SI∨DI, 则存取某个变量  EA = BX∨SI∨DI

### 2.数组或表格数据的寻址
表格数据的存取也可当作是数组的存取,均可用寄存器、寄存器相对、基址变址和相对基址变址等寻址方式。
(1)存取基本数组:数组的基本地址→BX,某个元素到数组基本地址的距离→SI∨DI, 则:
              EA = BX + { SI∨DI}
    或者位移量DISP=数组开始地址, BX∨SI∨DI =数组元素到数组开始地址的距离,则:
             EA = {BX∨SI∨DI } + DISP
(2)对于赋值语句A(i) = B (j)应指出两个变址寄存器。如对应元素ai可使用DI; 对应元素bj用SI, 则两组元素的地址分别为:
                 EA = SI + DISP
                 EA = DI + DISP   
(3)存取二维数组A(i, j): 数组起始地址→BX, BX兼行元素相对数组起始地址变址,而列元素又相对行元素的变址量→SI \/ DI, 则存取某个元素应有:
                 EA = {BX + SI}∨{BX + DI}
若DISP = 数组元素的起始地址, BX = 行元素变址量, SI 或 DI = 列元素相对行元素的变址,则存取某个元素应有:
                 EA = BX + {SI∨DI} + DISP

### 3.记录型数组的寻址
数组和记录结合使用。 设雇员的记录有四个数据项(雇员、保险号、雇龄和工资),由多个雇员的记录组成一个数组,则任一雇员记录项地址的形式描述为  F=f(M, I, J) 
   其中,F为数组记录项的地址,M为数组的基本地址, I为数组的元素(记录), J为元素的数据项, f则表示记录型数组。 对此,存取任一记录中的数据项(如雇龄项)的操作数寻址对应描述为：
                偏移地址 = f(基址,变址,位移)

假定基址指针在BX,与数组元素相一致的变址值在SI,记录中项的位置用DISP表示,则
          EA = BX + SI + DISP
4.堆栈数据结构寻址
堆栈采用以BP为基址指针的寻址,方便数据结构相同而参数不同的数据存取。当存取堆栈中的简单变量时
          EA = BP + DISP
    若存取堆栈中的数据和记录,则
          EA = BP +{SI∨DI} + DISP

## 程序转移寻址
寻址方式对多数指令而言,是要计算出操作数的地址,但是也由少数指令是为了形成程序转移的地址(如无条件转移指令JMP、调用指令CALL等)。
程序正常顺序执行时,每取出一条指令执行IP+n→IP,其中n为取出指令的字节数;然后形成下一条指令的地址:      PA = CS * 24 + IP
但是如果程序发生转移时,需要计算出转移偏移地址EA并修改IP,有时还需要修改CS的值。这种情况操作的对象是一个地址,地址的内容是要取出的指令,而不是上述讲到的操作数,因此称之为程序转移寻址。
### 程序转移方式：
段内转移是指程序在同一段代码内,仅改变IP的值而不改变CS的值所发生的转移。
而段间转移是程序要从一个代码段转移到另一个代码段,则不仅改变IP的值,同时也要改变CS的值。
无论是段内还是段间发生的转移都有直接和间接的形式,因此程序转移有四种寻址。
段内转移图示
段内直接转移和间接转移寻址如下图:

<img src="https://img-blog.csdnimg.cn/20200516110634372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">段内转移过程
1.段内直接寻址(Intrasegment Direct Addressing)
   转移偏移地址EA是指令中8位或16位位移量(DISP8,16)与指令指针IP当前内容之和。即:
                  $$EA = IP + DISP_{8,16} → IP$$
2.段内间接寻址(Intrasegment  Indirect Addressing)
   转移偏移地址 EA如果指定的是16位的寄存器,则将寄存器的内容→IP；如果指定的是存储器中的一个字,则将该存储单元的内容→IP。
段间转移图示
程序段间直接或间接转移如下图:
<img src="https://img-blog.csdnimg.cn/20200516110714986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">段间转移过程

1.段间间接寻址(Intersegment Direct Addressing)
    用指令中直接提供的转移偏移地址EA→IP,指令同时直接提供的转移段地址→CS, 实现从一个代码段转移到另一个代码段。

2.段间间接寻址(Intersegment Indirect Addressing)
    根据存储器的数据寻址方式获得EA,再将EA双字单元第一个字的内容作为转移偏移地址→IP,EA双字单元第二个字的内容作为转移段地址→CS,然后CS+IP形成指令的实际转移地址。

---
## 实方式32位指令寻址 
实地址方式32位指令寻址，指在32位的PC机上使用16位的存储机制，执行32位的非保护方式及非虚拟方式的指令，达到直接存取32位寄存器和32位存储器操作数的目的。

### 数据与地址类型		
几个概念
位域：一个相邻的位系列，在该序列中每一个作为一个独立的单位处理，一个位域可以从任何字节的任何位置开始。
位串：相邻位的序列，可以从任何字节的任何位置开始。
串：字节、字、双字的序列。
实方式的近程指针：16位的段内偏移值。

### 32位的指令寻址方式
偏移地址EA
     EA={基址}＋{变址} ×{比例因子}＋{位移量}
基址寄存器可以是任意一个32位通用寄存器。
变址寄存器是指除了堆栈指针ESP以外的7个通用寄存器。
比例因子是1、2、4、8可以分别用于字节、字、双字、四字的变址。
常数位移量可以指8位或32位。

32位的寻址方式图示
<img src="https://img-blog.csdnimg.cn/20200516110832342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">如果使用ESP、EBP为基址寄存器，则SS是默认的段寄存器，也可用CS、DS、ES、FS、GS来替换SS；

使用EAX、EBX、ECX、EDX、ESI、EDI为基址寄存器，则DS是默认的段寄存器，同样也能用CS、SS、ES、FS、GS来越段替换DS

32位的指令寻址方式示例：		

MOV AX ,DS:[BP]    
MOV FS:[EBP],ECX；DS、FS分别替换了缺省段SS

为了取得指令代码，只能用CS；PUSH、POP等指令与堆栈有关，也只能用SS。此外，在指令代码32位的程序堆栈操作时，要确保ESP/SP的内容（地址）总是为4的倍数。
例如：
PUSH 12345678H 
;ESP/SP-4→ESP/SP,12345678→[ESP/SP]
    POP EAX
    ; ([ESP/SP])→EAX, ESP/SP+4→ ESP/SP

32位的指令寻址包括数据寻址和程序转移寻址。一般寻址的基本概念与16位汇编寻址概念相似，特殊的寻址方式如上叙述。现介绍如下：

### 1、非存储器的数据寻址方式示例
（1）立即寻址
  MOV EAX,19461201H; 19461201H→EAX
                               与16位寻址相似。

   （2） 寄存器寻址
MOV EAX,ECX      ;ECX→EAX
                              与16位寻址相似
### 2、存储器的数据寻址方式示例
（1）直接寻址
MOV EAX,[4612H];   EA=4612,(EA)→EAX
                                与16位寻址相似。

（2）寄存器间接寻址
MOV [ECX],EDX   ;[ECX]间接指示存放操作数EA在ECX中，EA=ECX,EDX→EA，与16位寻址相似。
（3）寄存器相对寻址
MOV ECX,[EAX+24]   ;  EA=EAX,(EA)→ECX

（4）基址变址寻址
MOV EAX ,[EBX] [ESI] ; EA=EBX+ESI,(EA)→EAX

（5）相对基址变址寻址
SUB EAX,[EBX+ESI+0FF0H]
;EA=EBX+ESI+0FF0H,EAX-(EA)→EAX
   
（6）带比例因子的变址
MOV ECX,[ESI*4];     EA=ESI×4,(EA)→ECX
（7）基址与带比例因子的变址寻址
MOV ECX,[EAX][EDX*8]
   ;EA=EAX+EDX×8,(EA)→ECX
（8）基址与带位移量及比例因子的变址寻址
MOV EAX,LTAB[EDI*4][EBP+80]
   ;EA=LTAB+EDI×4+EBP+80,(EA)→EAX

### 3.程序转移寻址方式	
有相对EIP的段内直接寻址，段内间接寻址、段间直接寻址和段间间接寻址。

### 4.前缀代码67H或66H
32位机汇编指令或有32位操作数的情形识别涉及指令机器码格式的有关前缀表示。这些在相应的汇编列表文件（*.LST）或DEBUG过程中可以看到，如前缀代码67H或66H。
机器指令操作数长度属性前缀码66H
66|83 E0 0F   AND EAX,0FH     ;EAX^0FH→EAX
66|8B CB       MOV ECX,EAX
机器指令寻址长度续性前缀
67|8B 1475 00000026
    MOV DX,26H[ESI*2]
67|66|8B 04B0
    MOV EAX,[EAX+ESI*4]

## 实方式指令系统
指令系统是一台机器所有指令的集合。 Pentium系列机指令系统庞大、类型多样,约有300多条指令,其中包括基本指令100多条。 具有支持多进程、多任务、虚拟存储器和多媒体等功能的32位指令。
常用指令类型集
1.数据传送类指令
2.算术运算类指令
3.逻辑和移位操作类指令
4.串操作与重复前缀类指令
5.控制转移类指令
6.处理机控制类指令
7.其它指令
本讲义约定:

OPD表示目的操作数; (OPD)表示OPD的内容; 
OPS表示源操作数; (OPS)表示OPS的内容; 
→表示传送; 
R表示通用寄存器; 
Sr表示段寄存器;
 M表示主存储器; 
XXXX:XXXX 表示组合号;
“:”表示其前后组成一个数;
L表示操作数的长度; 
d表示立即数; 
B/W/D表示字节或字或双字。

### 数据传送类指令
#### 通用数据传送指令
##### 1.传送指令MOV
语句格式：MOV  OPD，OPS
功能：将源操作数传送入目的地址，源地址内容不变。即（OPS）→OPD。
下图描述了MOV指令在传送数据时允许传送的路径及类型。

MOV指令在传送数据时允许传送的路径及类型
<img src="https://img-blog.csdnimg.cn/20200516111058847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">(1)OPD,OPS必须同时是8/16/32位,否则会产生操作数类型不匹配的错误。

(2)OPS可以是R/M/Sr/d, OPD只能是R/M/Sr(除CS外)。

(3)例外:OPD和OPS不能同时为M,也不能同时为Sr;不能将d→Sr。

(4)指令执行后不影响FLAGS的标志位的状态。


##### 2.数据交换指令XCHG
 

示例:存储器与寄存器间数据传送。
MOV  AX，BUF；
BUF是变量，源操作数为直接寻址
MOV  BH，[DI]；
源操作数为寄存器间接寻址
MOV  DI，ES：3[SI]；
源操作数为变址寻址，使用跨段前缀
MOV  BP，3[BX+SI]；
源操作数为基址加变址寻址
MOV  BUFA，DL；
BUFA是一字节变量
MOV  [BP]，AX；
使用SS段寄存器
MOV  DS：[BP]，DL；
使用跨段前缀
MOV  BUF，DS；
MOV  ES ，BUF
BUF是个字变量


##### 数据交换指令XCHG
语句格式：XCHG  OPD，OPS
功能：将源地址与目的地址中的内容互换。即（OPD）→OPS，（OPS）→OPD。
寄存器与存储器之间数据交换。
MOV    AX，5678H；(AX)=5678H
MOV    BX，0FFFFH；(BX)=0FFFFH
XCHG  AX，BX	；(AX)=0FFFH, (BX)=5678H

##### MOVSX和MOVZX指令
格式：`MOVSX   OPD, OPS`  和 `MOVZX   OPD, OPS`
功能：它们将 `OPS` 的内容 `→ OPD`，但是对于 `OPD` 左边空缺的位,MOVSX全部用OPS的符号填充(作符号延伸)，可以对有符号的数进行符号扩展;而MOVZX是全部以零(0)填充，可对无符号数进行0扩展。

示例:
MOV      CL, 88H
   MOVZX  AX, CL         ;AX = 0088H
   MOVSX  BX, CL         ;BX = FF88H

另外也可如下书写指令:
MOVSX  CX, BL       MOVSX  EAX, BUF
MOVZX  AX,  CL      MOVSX  EBX, AL
MOVZX  ESI, BUF    MOVZX  EDX,DI

##### 查表转换指令 XLA
语句格式：XLAT  OPS或XLAT
功能：将（BX）为首址（AL）为位移量的字节存储单元中的数据送AL寄存器。即（[BX+AL]）→AL。

例：
……
MOV  BX,100H
MOV  AL, 03H
XLAT
……


#### 堆栈操作指令
##### 1. 进栈指令PUSH
语句格式：
 PUSH  OPS  ; W/D, R/Sr/M/d
功能：将寄存器、段寄存器、立即数或存储器中的一个字数据压入堆栈顶部，指令视操作数长度为字(2字节)或双字(4字节)和地址为16位/32位,先将SP/ESP - 2/4→SP/ESP,后将OPS→[SP]/[ESP]。

##### 2. 出栈指令POP
语句格式： POP OPD  ; W/D, R/Sr/M/d
功能： 视OPD长度为字或双字,先将当前SP/ESP指向的内容→OPD,后将SP/ESP+2/4→SP/ESP 。
从POP指令功能可看出，该指令为PUSH指令的逆过程,一般成对使用。

##### 3. PUSHA/PUSHAD指令
格式: 
-   PUSHA  ; 压入8个字通用寄存器。

 -  PUSHAD ; 压入8个双字通用寄存器.。

##### 4.POPA/POPAD指令
格式:
   POPA  ;弹出到8个16位通用寄存器

   POPAD ; 弹出到8个32位通用寄存器

#### 标志寄存器传送指令
1.标志送AH指令LAHF
语句格式：LAHF
功能：将标志寄存器的低8位送入AH寄存器。
即（FLAGS）7-0→AH。该指令的执行对标志位无影响。
【例】标志寄存器传送。
执行前：（FLAGS）=0485H，（AX）=0FFFFH
执行指令：LAHF
执行后 :  AH =85H



2.AH送标志指令SAHF
语句格式：SAHF
功能：将AH的内容送入标志寄存器的低8位，高8位不变。即（AH）→（FLAGS）7-0 。
从该指令功能可看出，SAHF为LAHF的逆过程。 

3.标志寄存器进栈指令PUSHF

4.标志寄存器出栈指令POPF
语句格式：
PUSHF
    功能：将标志寄存器的内容压入堆栈。即(FLAGS)→ 堆栈。    
POPF
功能：将堆栈顶端的内容送到标志寄存器。即堆栈→ (FLAGS )。


#### 地址传送指令
##### 1．传送偏移地址指令 LEA
语句格式： 
    LEA  OPD，OPS ;OPS的EA→OPD
                  ;OPD是16/32位的R,OPS是M
功能：主存按源地址的寻址方式计算偏移地址，将偏移地址送入指定寄存器。
【例】主存偏移地址的获取。
  MOV  BX，0100H	     ；(BX)=0100H
  MOV  SI，0210H	     ；(SI)=0210H
  LEA  BX，1234[BX+SI]	；(BX)=1544H



##### 2．传送偏移地址及数据段首址指令LDS
##### 3．传送偏移地址及附加数据段指令LES
语句格式：
   LDS/LES/LFS/LGS/LSS OPD，OPS ;EA = OPS
功能: 地址传送LDS等指令中,OPD为R(16位),OPS为M(32位).操作对FLAGS无影响,执行后结果为:
  (EA)→R   ;全程指针的偏移地址
  (EA+2)→LDS/LES/LFS/LGS/LSS ;全程指针的段地址



#### 输入输出指令
##### 1．输入指令IN
输入指令用来从指定的外设寄存器取信息送入累加器。它有四种形式：
（1）语句格式：IN	AL，PORT        
   　 功能：（PORT）→AL
（2）语句格式：IN	AX，PORT
 　　 功能：（PORT）→AX
（3）语句格式：IN	AL，DX
 　　 功能：（[DX]）→AL
（4）语句格式：IN	AX，DX
 　　 功能：（[DX]）→AL


##### 2．输出指令OUT
输出指令用来把累加器的内容送往指定的外设存储器，它有四种形式：
（1）语句格式：OUT	PORT，AL       
 　　 功能：（AL）→PORT
（2）语句格式：OUT	PORT，AX   
 　　 功能：（AX）→PORT
（3）语句格式：OUT	DX，AL       
 　　 功能：（AL）→[DX]
（4）语句格式：OUT	DX，AX     
 　　 功能：（AX）→[DX]

### 算术运算类指令

加法指令
1．加1指令  INC
语句格式：INC  OPD
功能：将目的操作数加1，结果送目的地址。即（OPD）+1→OPD。
INC指令是一个单操作数指令，操作数可以是寄存器或存储器操作数。
如：INC  BX，即（BX）+1→BX。
加1指令可用于对计数器和地址指针进行调整。 

2．加指令ADD
语句格式：ADD  OPD， OPS
功能：将目的操作数与源操作数相加，结果存入目的地址中，源地址的内容不改变。
即（OPD）+（OPS）→OPD。


3．带进位加指令ADC
语句格式：ADC  OPD，OPS
功能：将目的操作数加源操作数再加低位进位，结果送目的地址。
即（OPD）+（OPS）+CF → OPD。
【例】无符号双字加法运算。
MOV	AX，4652H	；（AX）=4652H
ADD	AX，0F0F0H	；（AX）=3742H，CF=1
MOV	DX，0234H	；（DX）=0234H
ADC	DX，0F0F0H	；（DX）=0F325H，CF=0



减运算指令
1．减1指令DEC
语句格式：DEC  OPD 
功能：将目的操作数减1，结果送目的地址。即（OPD）－1→OPD。
DEC指令是一个单操作数指令，操作数可以是寄存器或存储器操作数。
如：DEC  CX; 即（CX）－1→CX。
减1指令DEC也一般用于对计数器和地址指针的调整。


2．减指令SUB
语句格式：SUB  OPD，OPS
功能：目的操作数减源操作数，结果存于目的地址，源地址内容不变。
即（OPD）－（OPS）→OPD
【例】减法运算。
     MOV	AX ，5678H	；（AX）=5678H
      SUB	AX ，1234H	；（AX）=4444H
     MOV	BX ，3354H	；（BX）=3354H
      SUB	BX ，3340H	；（BX）=0014H

3．求补指令NEG
语句格式：NEG  OPD
功能：将目的操作数的每一位求反（包括符号位）后加1，结果送目的地址。
即（OPD）+1→OPD。
【例】求补运算。
   MOV  AX，0FF64H
   NEG  AL	      ；（AX）=0FF9CH
   SUB  AL，9DH	；（AX）=0FFFFH
   NEG  AX	      ；（AX）=0001H
   DEC  AL	      ；（AX）=0000H
   NEG  AX	      ；（AX）=0000H

4．带借位减指令 SBB
语句格式：SBB  OPD ，OPS
功能：目的操作数减源操作数再减低位借位CF，结果送目的地址。
即(OPD)―(OPS)―CF  → OPD


5．比较指令 CMP
语句格式：CMP  OPD，OPS
功能：目的操作数减源操作数，结果只影响标志位，不送入目的地址。
即（OPD）－（OPS）。

【例】比较AL的内容数值大小。
       CMP AL，50	；(AL)－50
       JB	  BELOW	；(AL)<50,转到BELOW处执行
       SUB  AL，50	；(AL)>=50,(AL)－50→AL
       INC  AH	     ；(AH)+1→AH
BELOW：	…


乘运算指令
1．无符号数乘法指令MUL
语句格式：  MUL  OPS
功能： 若是字节数据相乘，（AL）与OPS相乘得到字数据存入AX中；若是字数据相乘，则（AX）与OPS相乘得到双字数据，高字存入DX、低字存入AX中。
字节乘法：(AL)*(OPS)→AX，
字乘法：  (AX)*(OPS)→DX，AX 

【例】无符号数0A3H与11H相乘。
  MOV  AL，0A3H；（AL）=0A3H
  MOV  BL，11H	 ；（BL）=11H
  MUL  BL	      ；（AX）=0AD3H


2．有符号乘指令IMUL
语句格式：IMUL  OPS
功能：字节乘法：(AL)*(OPS)→AX，
      字乘法：  (AX)*(OPS)→DX、AX。
IMUL指令除计算对象是带符号二进制数外，其他都与MUL一样，但计算结果不同。 

【例】有符号数0B4H与11H相乘。
    MOV	AL，0B4H	；（AL）=B4H
    MOV	BL，11H	；（BL）=11H
    IMUL	BL	     ；（AX）=0FAF4H



除运算指令
1．无符号除指令DIV
语句格式：DIV  OPS
功能：字节除法：(AX)/(OPS)→ AL(商)、AH(余数)
       字除法：(DX、AX)/(OPS)→AX(商)、DX(余数)

【例】写出实现无符号数0400H/0B4H运算的程序段。
     MOV	AX，0400H	；(AX)=0400H
     MOV	BL，0B4H	；(BL)=0B4H
     DIV	BL	     ；商(AL)=05H，余数(AH)=7CH 

2．有符号除指令IDIV
语句格式：IDIV  OPS
功能：字节除法：(AX)/(OPS)→AL(商)、AH(余数)
       字除法：(DX，AX)/(OPS)→AX(商)、DX(余数)
除法指令DIV和IDIV虽然对标志的影响未定义，但可产生溢出。

【例】写出实现有符号数0400H/0B4H运算的程序段。
      MOV	AX，0400H	；(AX)=0400H
      MOV	BX，0B4H	；(BX)=0B4H
      IDIV	BX	      ；(AL)=0F3H，(AH)=24H

符号扩展指令 

1．字节转换成字指令CBW
语句格式：CBW
功能：将AL中的符号位数据扩展至AH。

【例】将字节数据扩展成字数据。
      MOV	AL，0A5H	；（AL）=0A5H
      CBW	          ；（AX）=0FFA5H
      ADD	AL，70H	；（AL）=25H
      CBW		     ；（AX）=0025H


2．将字转换成双字指令CWD
语句格式：CWD
功能：将AX中的符号位数据扩展至DX 。

【例】将字数据扩展成双字数据。
      MOV	DX，0	     ；(DX)=0
      MOV	AX，0FFABH	；(AX)=0FFABH
      CWD	          ；(DX)=0FFFFH;(AX)=0FFABH


十进制调整指令
1．压缩BCD码调整指令

加法的十进制调整指令DAA 

语句格式：DAA
功能：如果AL寄存器中低4位大于9或辅助进位（AF）=1，则（AL）=（AL）+6且（AF）=1；如果（AL）>=0A0H或（CF）=1，则（AL）=（AL）+60H且（CF）=1。同时，SF、ZF、PF均有影响。

【例】压缩BCD码的加法运算。
      MOV AL，68H	；(AL)=68H，表示压缩BCD码68
      MOV BL，28H	；(BL)=28H，表示压缩BCD码28
      ADD AL，BL	；二进制加法:(AL)=68H+28H=90H
      DAA	      ；十进制调整:(AL)=96H
                  ；实现压缩BCD码加法:68+28=96
减法的十进制调整指令DAS
语句格式：DAS
功能：如果（AF）=1或AL寄存器中低4位大于9，则（AL）=（AL）－6且（AF）=1；如果（AL）>=0A0H或（CF）=1，则（AL）=（AL）－60H且（CF）=1。同时SF、ZF、PF均受影响。

【例】压缩BCD码的减法运算。
      MOV	AL，68H ；(AL)=68H，表示压缩BCD码68
       MOV	BL，28H ；(BL)=28H，表示压缩BCD码28
       SUB	AL，BL  ；二进制减法:(AL)=68H－28H=40H
       DAS	        ；十进制调整:(AL)=40H
	              ；实现压缩BCD码减法:68－28=40



2．非压缩BCD码调整指令
（1）加法的非压缩BCD码调整指令AAA
语句格式：AAA  
功能：如果AL的低4位大于9或（AF）=1，则：
（AL）=（AL）+6
（AH）=（AH）+1
（AF）=（CF）=1
且AL高4位清零。
否则：（CF）=（AF）=0
AL高4位清零。


（2）减法的非压缩BCD码调整指令AAS
语句格式：AAS                   
功能：如果AL的低4位大于9或（AF）=1，则：
（AL）=（AL）－6
（AH）=（AH）－1
（AF）=（CF）=1
AL高4位清零。
否则：（CF）=（AF）=0
　　  AL高4位清零。
其他标志位OF、PF、SF、ZF不确定。

（3）乘法的非压缩BCD码调整指令AAM
语句格式：AAM                    
功能：被调整的乘积在AX中，对AL按10取模，则：
（AL）／0AH→AH（商）：AL（余数）
其中AH为商，AL为余数，标志位AF、CF、OF、PF、SF、ZF受影响。 

（4）除法的非压缩BCD码调整指令AAD
语句格式：AAD          
功能：除法运算前，先调整被除数AX内容，使：
     （AL）=（AL）+（AH）*0AH
     （AH）=0
即把非压缩型十进制数变成二进制数。


### 逻辑运算和位操作类指令

1．求反指令NOT
语句格式：NOT  OPD
功能：将目的地址中的内容逐位取反后送入目的地址。
即（OPD）求反→OPD 
 
【例】逻辑非运算。
     MOV	AX，878AH ；（AX）=878AH
     NOT	AX	     ；（AX）=7875H


2．逻辑乘指令AND
语句格式：AND  OPD，OPS	
功能：将目的操作数和源操作数进行逻辑乘运算，结果存目的地址。
即（OPD）∧（OPS）→OPD。
该指令用于清除目的操作数中与源操作数置0的对应位。说明：逻辑乘的运算法则为：1∧1=1，1∧0=0，0∧1=0，0∧0=0

【例】将AL中第3位和第7位清零。
     MOV	AL，0FFH                        
     AND	AL，77H 

3．测试指令TEST
语句格式：TEST  OPD，OPS
功能：源地址和目的地址的内容执行按位的逻辑乘运算，结果不送入目的地址。
即（OPD）∧（OPS）。

【例】测试AX中的第12位是否为0，不为0则转L。
     TEST	  AX，1000H
     JNE	  L        


4．逻辑加指令OR
语句格式：OR  OPD，OPS
功能：将目的操作数和源操作数进行逻辑加运算，结果存目的地址。
即（OPD）∨（OPS）→OPD。
说明：逻辑加的运算法则为：1∨1=1，1∨0=1，0∨1=1，0∨0=0。

【例】将AL寄存器中第3位和第7位置1。
MOV	AL，0          
OR 	AL，88H 

5．按位加指令XOR
语句格式：  XOR  OPD，OPS
功能：目的操作数与源操作数做按位加运算，结果送入目的地址。
即（OPD）⊕(OPS) →OPD。
说明：按位加的运算法则为；1⊕1=0，1⊕0=1，0⊕1=1，0⊕0=0。

【例】按位加运算。
     MOV	AL，45H；（AL）=45H
     XOR	AL，31H；（AL）=74H

移位指令 
移位指令包括算术移位指令、逻辑移位指令和循环移位指令，分别进行左移和右移操作。这些指令均有统一的语句格式：
       SAL/SHL OPD, OPS   ;左移
       SAR     OPD, OPS   ;算术右移 
       SHR     OPD, OPS   ;逻辑右移
其中,OPD是8/16/32位的R/M;OPS是计数值(即移位次数),有三种情形:OPS即可是8位的立即数或CL的内容(移位前次数→CL)。
其功能为将目的操作数的所有位按操作符规定的方式移动1位或按寄存器CL规定的次数（0~255）移动，结果送入目的地址。目的操作数是8位（或16位）的寄存器数据或存储器数据。

算术左移和逻辑左移指令SAL（SHL）
语句格式：SAL  OPD，1  
          SHL  OPD，1
          SAL  OPD，CL
          SHL  OPD，CL
功能：将（OPD）向左移动CL指定的次数，最低位补入相应的０，ＣＦ的内容为最后移入位的值。

<img src="https://img-blog.csdnimg.cn/20200516111958168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">算术右移指令SAR
语句格式：SAR  OPD，1
          SAR  OPD，CL
CF功能：将（OPD）向右移动CL指定的次数且最高位保持不变；CF的内容为最后移入位的值。
<img src="https://img-blog.csdnimg.cn/202005161120189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
【例】算术右移运算
MOV	BH，0F4H	；（BH）=0F4H
MOV	CL，  2	；（CL）=2
SAR	BH，  CL	；（BH）=0FDH，（CF）=0

该例语句“SAR　BH，CL”实际上完成了（BH）／４→BH的运算，所以，用SAR指令可以实现对有符号数除2n的运算（n为移位次数）。

逻辑右移指令SHR
逻辑右移指令SHR
<img src="https://img-blog.csdnimg.cn/20200516112041944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
循环左移指令ROL
语句格式：ROL  OPD，1
          ROL  LPD，CL
功能：将目的操作数的最高位与最低位连成一个环，将环中的所有位一起向左移动CL规定的次数。CF的内容为最后移入位的值。
<img src="https://img-blog.csdnimg.cn/20200516112056210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
循环右移指令ROR
语句格式： ROR  OPD，1
           ROR  OPD，CL
功能：将目的操作数的最高位与最低位连成一个环，将环中的所有位一起向右移动CL规定的次数，CF的内容为最后移入位的值。
<img src="https://img-blog.csdnimg.cn/20200516112110308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">带进位的循环左移指令RCL
语句格式： RCL  OPD， 1
           RCL  OPD，CL
功能：将目的操作数连同CF标志一起向左循环移动CL规定的次数。 
<img src="https://img-blog.csdnimg.cn/2020051611212518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">带进位的循环右移指令RCR
语句格式：RCR  OPD，1
          RCR  OD，CL
功能：将目的操作数连同CF标志一起向右循环移动所规定的次数。 
<img src="https://img-blog.csdnimg.cn/20200516112149311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
### 串操作类指令
串操作指令 ：
     数据传送类指令每次只能传送一个数据，若要传送大批数据就需要重复编程，这样就浪费了大量的时间和空间。为此8086提供了一组处理主存中连续存放数据串的指令，这就是串操作指令。 
     串操作流程图

<img src="https://img-blog.csdnimg.cn/20200516112213524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
传送指令MOVS
语句格式：
① MOVSB——字节串传送
② MOVSW——字串传送
功能：将以SI为指针的源串中的一个字节（或字）存储单元中的数据传送至以DI为指针的目的地址中去，并自动修改指针，使之指向下一个字节（或字）存储单元。
即：①（DS：[SI]）→ES：[DI]。
    ② 当DF=0时，（SI）和（DI）增量。
              当DF=1时，（SI）和（DI）减量。
串比较指令CMPS  
语句格式：
① CMPSB——字节串比较
② CMPSW——字串比较
功能：将SI所指的源串中的一个字节（或字）存储单元中的数据与DI所指的目的串中的一个字节（或字）存储单元中的数据相减，并根据相减的结果设置标志，但结果并不保存。即：
①（[SI]）－（[DI]）。
② 修改串指针，使之指向串中的下一个元素。
   当DF=0时，（SI）和（DI）增量。
   当DF=1时，（SI）和（DI）减量。


串搜索指令SCAS
语句格式：
① SCASB——字节串搜索
② SCASW——字串搜索
功能：AL（字节）或AX（字）中的内容与DI所指的目的串中的一个字节（或字）存储单元中的数据相减，根据相减结果设置标志位，结果不保存，即：
① 字节操作:(AL)－([DI])，字操作:(AX)－([DI])。
② 修改指针使之指向串中的下一个元素。
   当DF=0时，（DI）增量。
   当DF=1时，（DI）减量。
从源串中取数指令LODS
语句格式：
① LODSB——从字节串中取数
② LODSW——从字串中取数
功能：将SI所指的源串中的一个字节（或字）存储单元中的数据取出来送入AL（或AX）中。即：
① 字节操作：（[SI]）→AL，字操作：（[SI]）→AX。
② 修改指针SI，使它指向串中的下一个元素。
   当DF=0时，（SI）增量。
   当DF=1时，（SI）减量。 

往目的串中存数指令STOS
语句格式：
① STOSB——往字节串中存数
② STOSW——往字串中存数
功能：将AL或AX中的数据送入DI所指的目的串中的字节（或字）存储单元中。即：
① 字节操作：（AL）→[DI]，字操作：（AX）→[DI]。
② 修改指针DI，使之指向串中的下一个元素。
   当DF=0时，（DI）增量。
   当DF=1时，（DI）减量。

重复前缀指令REP  REPZ  REPNZ
（1）REP    
REP前缀用在MOVS、STOS 、LODS指令前。
功能：每执行一次串指令（CX）－1，直到（CX）=0，重复执行结束。
（2）REPZ  
该指令一般用在CMP、SCAS指令前。
功能：每执行一次串指令（CX）－1，并判断ZF标志是否为0，只要（CX）=0或ZF=0，则重复执行结束。
（3）REPNZ  
该指令一般用在CMPS、SCAS 指令前。
功能：每执行一次串指令（CX）－1，并判断ZF标志是否为0，只要（CX）=0或ZF=1，则重复执行结束。

### 控制转移类指令
语句格式：
         操作符  短标号
功能：如果条件满足，则（IP）＋位移量→IP。
条件转移指令

 
1．简单条件转移指令
<img src="https://img-blog.csdnimg.cn/20200516124408696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
2．无符号数条件转移指令
<img src="https://img-blog.csdnimg.cn/20200516124424692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">无符号数条件转移指令示例
【例】比较无符号数大小，将较大的数存放AX寄存器
     CMP  AX，BX ；（AX）－（BX）
      JNB  NEXT ；若AX>=BX，转移到NEXT
      XCHG AX，BX ；若AX<BX，交换
NEXT：…


3. 有符号数条件转移指令 

<img src="https://img-blog.csdnimg.cn/20200516124440315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
【例】比较有符号数大小，将较大的数存放在AX寄存器
     CMP	  AX，BX	；(AX)－(BX)
      JNL	  NEXT   ；若AX>=BX，转移到NEXT
      XCHG  AX，BX	；若AX<BX，交换
NEXT：…


无条件转移指令
无条件转移指令的语句格式及功能

<img src="https://img-blog.csdnimg.cn/20200516124514614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
### 循环指令 
1．循环指令LOOP
语句格式： LOOP  短标号
功能:(CX)－1 ≠0，则程序转移（循环）；否则，顺序执行。
说明：使用LOOP指令可代替两条指令：
       DEC  CX
       JNE  短标号


2．相等/为零循环指令LOOPE
语句格式：
① LOOPE  短标号
② LOOPZ  短标号
功能：（CX）－1 ≠0且ZF=1，则程序转移（循环）；否则，顺序执行。


3．不相等/不为零循环指令LOOPNE 
语句格式：
① LOOPNE  短标号
② LOOPNZ  短标号
功能：（CX）－1≠0，则程序转移（循环）；否则，顺序执行。


4．CX为零转移指令JCXZ
语句格式： JCXZ  短标号
功能：（CX）－1≠0，则程序转移（循环）；否则，顺序执行。



子程序调用指令
1．子程序调用指令CALL
（1）段内直接调用
（2）段间直接调用
（3）段内间接调用
（4）段间间接调用
2．返回指令RET
（1）语句格式：RET
（2）语句格式：RET  n（n为偶数） 

中断指令
1．中断调用指令INT
语句格式：INT  n
功能：
①（FLAGS）→↓（SP），0→ IF、TF。
②（CS） →↓（SP），（4*n+2） → CS。
③（IP） →↓（SP），（4*n） → IP。
2．中断返回指令IRET
语句格式：IRET
功能：①↑（SP）→IP  
            ②↑（SP） →CS
            ③↑（SP） → FLAGS 

### 处理机控制类指令
标志位设置指令
CLC设置标志CF=0,
STC设置标志CF=1,
CLD设置标志DF=0, 
STD设置标志DF=1, 
CLI设置标志IF=0, 
STI设置标志IF=1.


CPU状态控制指令
1．空操作指令NOP
2．总线封锁前缀指令LOCK
3．暂停指令HLT
4．交权指令ESC
5．等待指令WAIT





## 字符设备I/O功能调用
      本节主要介绍DOS子程序调用方式、键盘输入、屏幕显示和打印机输出的DOS系统功能调用。
DOS子程序调用方式
调用之前：设置子程序的入口参数。
调用请求：执行“INT 21H”软中断指令调用。
调用之后：可能有出口参数，也可能无出口参数。如果有出口参数，可根据程序需要，判断本次调用是否成功或者分析执行情况。

从键盘输入一个字符AH=01H
  从键盘读入一个字符，送到显示器输出，并将该字符的ASCII码值→AL（出口参数）；如果检测到读入的字符是Ctrl＋Break，则中止程序执行。
例：
   MOV AH,01H ;键盘输入子程序，功能1→AH
   INT   21H       ； DOS子程序调用，等待键入一个字符调用后，输入字符的ASCII码值→AL

显示输出一个字符AH=02H
将DL寄存器中的字符（ASCII码值）送到标准输出设备上输出。若检测到Ctrl＋Break间，则执行中断“INT 23H”中止程序的执行。

例：
   MOV  DL,AL  ;AL内容是字符的ASCII码→DL
      MOV  AH,2     ;功能号2→AH
      INT    21H       ;调用显示一个字符

打印机输出一个字符AH=05H
将要打印的字符→DL,然后调用就可以打印输出。如果有标准打印设备不输出，可在执行时用DOS命令键Ctrl＋Break进行帮助。

例：
      MOV  DL,AL  ;AL的字符ASCII码→DL
         MOV  AH,5    ;功能号5→AH
         INT    21H      ;调用打印一个字符

直接控制台输入AH=07H
输入时不回显，例如，从键盘输入一个字符，在屏幕上不显示，出口参数AL＝键入的字符。可用来设置保密口令。
例：
          PASSWORD DB 10DUP(0)
                     ...
                           MOV    CX,6
                           MOV    SI,0             
          AGAIN:    MOV    AH,7
                           INT      21H
                           MOV    PASSWORD[SI],AL
                           INC      SI
                           LOOP  AGAIN
多字符输入显示输出
1、显示输出字符串AH=09H
例：执行下语句后屏幕显示输出WELCOME!”
STRING  DB ‘WELCOME!’,13,10,’$’
          …
            MOV   AX, SEG STRING
            MOV   DS, AX
            LEA    DX, STRING
            MOV   AH, 9
            INT     21H
缓冲区键盘输入AH=0AH
如果需要键入最大的字符数位N，则由“DS：DX”指向的缓冲区可分为3个字段。
第一个字段：定义缓冲区可存放的字符数N+1，使机器自动控制检查，若键入实际的字符数个数超过N，则响铃报警。
第二个字段：定义缓冲区，当键盘输入调用退出后，系统自动计数并存放实际输入的字符。
第三个字段：定义可存放字符的缓冲区，调用退出后，存放实际输入的字符，最后一个字节总是回车符。
<img src="https://img-blog.csdnimg.cn/20200516124735272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
0AH调用示例
例：编写在实地址方式（.586与USE16）下，定义一个能最多可输入20个字符到BUF缓冲区的程序。
.586
STACK     SEGMENT  USE16                ；定义16位段
                  DB        256         DUP(0)
STACK      ENDS
DATAS     SEGMENT  USE16
                  N        EQU  20
                  BUF   DB     N+1   ；定义第一个字段，BUF位21
                  COUNT    DB   0  ；定义第二个字段
                  CHAR       DB   N+1 DUP(0)  ；定义第三个字段
                  PROMPT   DB       ‘Please input:’,13,10, ‘$’
DATAS      ENDS

COUNTS   SEGMENT  USE16
                  ASSUME  CS:CODES,DS:DATAS
START:     MOV    AX,DATAS
                  MOV    DS,AX
                  LEA     DX, prompt    ;取prompt的偏移地址→dx
                  MOV    AH,9                       
                  INT      21H
                  LEA     DX,BUF            ;取BUF的偏移地址→dx
                  MOV    AH,0AH
                  INT       21H
                  MOV    AH,4CH
                  INT       21H
CODES     ENDS 
               END  START




---
# 程序设计的基本方法 
程序设计的基本步骤 
汇编语言程序设计的一般步骤如下：
分析问题，确定算法
根据具体问题，确定存储空间，工作单元和寄存器。
根据算法，编制程序流程图
根据流程图编写程序
上机调试程序


## 顺序程序设计
顺序程序设计是程序设计中最简单的一种程序设计方法。从程序的流程图看，顺序程序是以一个开始框开始，以一个结束框终止，中间有一个或多个顺序的执行框组成的程序结构形式。只要遵照算法步骤依次写出相应的指令即可。这种程序设计方法称为直流方法。
例5.1  设X、Y、Z为有符号字变量，编写程序计算R=（（X ＊Y+5）+4 ＊X）/Z 表达式。 
数据段定义如下：DATA	SEGMENT
                      X		DW	？
                      Y		DW	？
                      Z		DW	？
                      R		DW	2   DUP（0）
                DATA	ENDS
例5.1
CODE	 SEGMENT
	 ASSUME  CS：CODE，DS：DATA
START：	MOV	AX，DATA
	 	MOV	DS，AX
     	MOV	AX，X
	 	IMUL	Y	      ；计算X＊Y
	 	ADD	AX，5   	；计算X＊Y+5
     	ADC	DX，0
     	MOV 	CX，DX
	 	MOV	BX，AX
	 	MOV	AX，X	     	；计算4＊X	 		 
      	MOV	SI，4
	  	IMUL	SI
      	ADD	AX，BX 	；算（X＊Y+5）+4＊X
	  	ADC	DX，CX 
      	IDIV	Z     ；计算（（X＊Y+5）+4＊X）/Z
	   	MOV	R，AX
	   	MOV	R+2，DX
	   	MOV	AH，4CH
	   	INT	21H
CODE	ENDS
	  END	START 	
例5.2
编写程序将A字变量中的48位二进制数与B字变量中的16位二进制数做无符号数相乘，其结果放在C字变量中。
在本例中，如果用一个字母表示一个16位二进制数，48位二进制被乘数用LMN表示，16位二进制乘数用P表示，则N×P=RZ，M×P=TS，L×P=UV，两个数相乘可表示为： 
<img src="https://img-blog.csdnimg.cn/20200516140339210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">DATA	SEGMENT
                      A           DW	 3745H，2948H，7068H
                      B	DW	1231H
                      C	DW	4  DUP（0）
DATA	ENDS 
CODE	SEGMENT
	ASSUME     CS：CODE，DS：DATA
START：	MOV	AX，DATA
		MOV	DS，AX
		MOV	AX，A+4	
                      MUL	B
		MOV	C+6，AX
		MOV	C+4，DX		
              MOV       AX，A+2	
	     MUL        B
	     ADD	         C+4，AX
             ADC	         DX，0
	     MOV        C+2，DX
	     MOV        AX，A		
	     MUL         B
              ADD         C+2，AX
	     ADC          DX，0
	     MOV         C，DX
              MOV         AH，4CH
	      INT           21H
CODE	ENDS   	        
              END   START			

例5.3
将BUF中的一字节压缩BCD码转换为ASCII码显示输出。
程序清单如下：
DATA	SEGMENT
     BUF	DB	34H
DATA	ENDS
CODE	SEGMENT
	ASSUME     CS：CODE，DS：DATA
START：	MOV	AX，DATA
		 	MOV	DS，AX
       	MOV	DL，BUF	； 
		 	MOV	CL，4	
	     	SHR	DL，CL
      	ADD	DL，30H	
			MOV	AH，2
			INT	21H
			MOV	DL，BUF	
			AND	DL，0FH
			ADD	DL，30H		
	    	MOV	AH，2
			INT	21H
       		MOV	AH，4CH
			INT	21H
     CODE	ENDS
		END	START
例5.4
设A、B变量中存放的是64位的二进制数，请用386及其后继机型的相应指令编写A＋B→C的程序。
．586
STACK	SEGMENT	STACK
        DW	200 DUP（0）
STACK	ENDS
DATA	SEGMENT     USER16
        A	DQ	372869AF63DE3710H
        B	DQ	1239876ABCFDE020H
        C	DQ	0
DATA	ENDS 
CODE	SEGMENT   USER16
		ASSUME   CS：CODE，DS：DATA，SS：STACK
 START：      MOV	AX，DATA
		       MOV	DS，AX
		       MOV	AX，STACK
		       MOV	SS，AX      
              MOV	EAX，DWORD  PTR  A+4		
	           ADD	EAX，DWORD   PTR  B+4
		       MOV	DWORD   PTR  C+4，EAX
		       MOV	EAX，DWORD  PTR  A
              ADC	EAX，DWORD   PTR  B
		       MOV	DWORD   PTR  C，EAX
		       MOV	AX，4C00H			；返回DOS
		       INT	21H
	CODE	     ENDS 
     END	START   



## 分支程序设计
根据不同情况做出判断，有选择地执行相应的处理程序。通常称这类程序为分支程序。实现这类程序的设计过程称为分支程序设计。
在分支程序中，不同的条件往往是通过标志寄存器中条件标志的不同状态反映的。因而，分支程序设计中一个至关重要的问题是根据各标志的不同状态选用合适的转移指令。
相关指令类型
简单的条件转移指令
无符号数比较条件转移指令
有符号数比较条件转移指令
测试CX或ECX为0则转移指令
循环指令
### 分支程序的结构形式
第一种形式称为双分支程序结构;
<img src="https://img-blog.csdnimg.cn/20200516140509134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">第二种形式称为多分支程序结构;
<img src="https://img-blog.csdnimg.cn/20200516140518338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">1. 双分支程序设计
例5.5 设有三个单字节无符号数存放在BUF开始的缓冲区中，编写一个能将它们按大到小重新排列的程序。
  由于BUF缓冲区中只有三个数据，有多种方法可实现三个数据的排序。我们采用交换法，找到三个数中的最大数，然后再找到剩下两个数的大数，最后将三个数按大小依次存放。为了方便，先把要排序的三个数取到三个寄存器中，然后再对三个数据进行比较排序。
 
DATA   	SEGMENT
           BUF	DB   87，234，123  
 DATA	ENDS

例5.5
CODE	SEGMENT
           ASSUME    CS：CODE，DS：DATA
 START：	MOV  	   AX，DATAS
                    	MOV 	   DS，AX
                        MOV 	   SI，OFFSET BUF   
                        MOV	   AL，［SI］
                        MOV	   BL，［SI＋1］  
                 MOV     CL，［SI＋2］
                 CMP      AL，BL	
                 JAE       NEXT1
                 XCHG    AL，BL
NEXT1： CMP        AL，CL
                  JAE	         NEXT2
                  XCHG     AL，CL
NEXT2： CMP        BL，CL	 
        	     JAE          NEXT3
                  XCHG      BL，CL
NEXT3： MOV        [SI]，AL	
                  MOV        [SI＋l］，BL
                  MOV        [SI＋2]，CL
                  MOV         AH，4CH
                  INT 	           21H
 CODES	ENDS
                      	END	 START

例5.6
编写计算下面函数值的程序(x、y的值均在—128～＋127之间) 
 	            1           x≥0，y≥0
       Z =    -1   	     x＜0，y＜0
	            0	     x、y异号
        输入数据为x、y，结果数据为Z。

 存储单元分配如下：变量X中存放x的值，变量Y中存放y的值，变量Z用来存放函数值。以上各变量均为字节类型。程序流程图如下。
<img src="https://img-blog.csdnimg.cn/2020051614061473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">程序清单如下：
DATA 	SEGMENT
        X		DB	23
        Y           	DB	－10
        Z		DB	0
DATA 	ENDS
CODE 	SEGMENT
           ASSUME    CS：CODE，DS：DATA
START：MOV   AX，DATA
          	    MOV   DS，AX
                 CMP    X，0		
           	    JS	    L1	    
                        CMP	Y，0
           	              JL	              L2	；y＜0转L2
          	              MOV         Z，1	
          	              JMP           EXIT 
          L1：         CMP 	Y，0		；y≥0转L2
    	                       JGE	L2
                            MOV	  Z，－1		
                            JMP	EXIT
          L2：         MOV	Z，0		；x、y异号时则0→Z
          EXIT：    MOV	AH，4CH
                            INT	21H
CODE        ENDS
		END	START

例5.7
从键盘输入0～9中任一自然数X，若输入的字符是0～9中的某一数，则将X的立方值送Y；若输入的字符不是0～9中的某一数，则显示“INPUT    ERROR！”，表明输入错。
程序清单如下： 
STACK	 SEGMENT	STACK
		 DB	100  DUP（0）
STACK	 ENDS
DATA	SEGMENT
          INPUT 	DB     ‘PLEASE  INPUTX（0 ～9）：＄’
          TAB	DW       0，l，8，27，64，125，216，343，512，729
          X		DB        ？
          Y		DW       0
         ERR      	DB        0DH，0AH，“INPUT ERROR！＄”
DATA   	ENDS
CODE 	SEGMENT
          	ASSUME    CS：CODE，DS：DATA，SS：STACK
START：MOV       AX，DATA                                                        	    MOV        DS，AX
                  LEA         DX，INPUT	
                  MOV        AH，9    
      	     INT	          21H
                  MOV        AH，1		
 		     INT	          21 
                  CMP         AL，‘0’ 
                   JB 	          CHR
                   CMP         AL，‘9’ 
	               JA	           CHR
 	        AND        AL，0FH	
	        MOV       X，AL                                                                     	
              SHL        AL，1
              MOV      BL，AL  
              MOV      BH，0
              MOV      AX，TAB[BX]
	        MOV      Y，AX
EXIT：MOV      AH，4CH	
               INT       21H    
CHR：  LEA      DX，ERR	；显示“INPUT ERROR！”
	          MOV	AH，9
                INT      21H
 	          JMP	EXIT 
CODE 	ENDS                        
            END 	START	

多分支程序设计
	
设计多分支程序的关键是如何按条件对多分支进行判断，从而根据不同的条件转移到不同的入口去执行各自的程序段。
下面结合具体示例介绍多分支结构程序设计的三种基本方法：逻辑分解法、地址表法和转移表法。 
逻辑分解法多分支程序设计

<img src="https://img-blog.csdnimg.cn/20200516140704797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">例5.8
如果X字节变量中是处理程序的序号（0～9），P0、P1、P2、…  、P9是序号（0～9）的对应的处理程序。试编写一程序，根据X中值的不同，分别转移到相应的处理程序。 
DATA	SEGMENT
            X	DB	？
DATA	ENDS
CODE	SEGMENT
	       ASSUME    CS：CODE，DS：DATA
START：MOV	   AX，DATA
		    MOV	   DS，AX
		    MOV	   AL，X 	
		    CMP	   AL，0		；如果（X）=0则转P0
		    JNZ	   L1
                  JMP	   P0
L1：  	     CMP      AL，1		；如果（X）=1则转P1
	             JNZ	       L2
                  JMP       P1
L2：	     CMP      AL，2		；如果（X）=2则转P2
	             JNZ        L3
                  JMP       P2
		┇
L9：	     CMP      AL，9		；如果（X）=9则转P9
	             JNZ	       L10
                  JMP       P9
L10：	     JMP       EXIT
P0：	…
		┇
P1：	…
		┇
P9：	…
		┇
EXIT：MOV	  AH，4CH	；返回DOS
		  INT	  21H             
  CODE	ENDS 		
                  END	START
转移表法多分支程序设计
逻辑分解法需用多条比较判断转移指令才能实现多分支的程序设计。这样使得编写的程序太长。
如果将转移各分支程序段的转移指令依次存放在一张表中，这张表称为转移表。
各分支转移指令在表中的位置，即离表首地址的位移量为条件，当进行多分支条件判断时，把当前条件的位移量加上表首地址作为转移地址，转移到表的相应位置，继续执行无条件转移指令，达到多分支目的。
这种程序设计的方法称为转移表法多分支程序设计。
例5.9
编写程序，根据键盘输入的值，若输入数字0则显示“INPUT DIGIT 0！”，若输入数字1则显示“INPUT DIGIT 1！”，…，若输入数字9则显示“INPUT DIGIT 9！”；否则显示“INPUT CHARACTER！”。
DATA	SEGMENT
    DIS0	DB	‘INPUT DIGIT 0！$’
    DIS1	DB	‘INPUT DIGIT 1！$’
	                  ┇
    DIS9	DB	‘INPUT DIGIT 9！$’
    DIS10	DB	‘INPUT CHARACTER！$’
DATA	ENDS
CODE	SEGMENT
		ASSUME    CS：CODE，DS：DATA
START：	MOV	AX，DATA
		MOV	DS，AX
		MOV	AH，1		；调用键盘输入DOS中断
       INT	21H
		CMP	AL，30H	       ；如果输入的是非数字则转M
		JB	M
		CMP	AL，39H
		JA	M
		AND	AL，0FH
       JMP	N ；
        M：	MOV	AL，10		
 N：   LEA	BX，TAB	； 
               MOV	AH，0
		SHL	AL，1		                  
       ADD	BX，AX
		JMP	BX		
EXIT：	MOV	AH，4CH
		INT	21H 
TAB：	JMP	SHORT   P0	；跳转指令表
		JMP	SHORT   P1
		JMP	SHORT   P2
		┇
		JMP	SHORT   P9
		JMP	SHORT   P10
P0：	LEA	DX，DIS0  ；显示输出字符串“INPUT DIGIT 0！”
		MOV	AH，9
		INT	21H
		JMP	EXIT
 P1：	LEA	DX，DIS1  ；显示输出字符串“INPUT DIGIT 1！”
		MOV	AH，9
		INT	21H
		JMP	EXIT
		┇
P10：	LEA	DX，DIS10  ；显示输出字符串“INPUT CHARACTER！”
		MOV	AH，9
		INT	21H
		JMP	EXIT    
CODE     ENDS     
      END START
地址表法多分支程序设计
如果将每个分支处理程序的入口地址存放一个地址表中，然后根据不同的条件，分别从地址表中取出对应分支处理程序的入口地址，转移到相应的分支执行程序。按例9的要求，可编写程序如下：
DATA	SEGMENT
      DIS0	DB   ‘INPUT DIGIT 0！$’
      DIS1	DB   ‘INPUT DIGIT 1！$’
      DIS2	DB   ‘INPUT DIGIT 2！$’
	                 ┇
      DIS9	DB   ‘INPUT DIGIT 9！$’
      DIS10	DB   ‘INPUT CHARACTER！$’
      TAB	DW   P0，P1，P2，P3，P4，P5，P6，P7，P8，P9，P10
DATA	ENDS
CODE	SEGMENT
		ASSUME    CS：CODE，DS：DATA
START：  MOV	 AX，DATA
        MOV	 DS，AX
        MOV	 AH，1		
        INT	 21H
		  CMP	 AL，30H	
		  JB	 M
		  CMP	 AL，39H
		  JA	 M
		  AND	 AL，0FH
		  JMP	 N；
  M：   MOV	AL，10		
 N：	LEA	BX，TAB	
		MOV	AH，0
		SHL	AL，1
		ADD	BX，AX
		JMP	[BX]		
EXIT：MOV	AH，4CH
		INT	21H
             P0：	LEA	DX，DIS0	
		        MOV	AH，9
		        INT	21H
		        JMP	EXIT
         P1：	LEA	DX，DIS1	
		        MOV	AH，9
		        INT	21H
		        JMP	EXIT
	                   ┇
        P10：      LEA	DX，DIS10	
		        MOV	AH，9
		        INT	21H
		        JMP	EXIT    
CODE ENDS	  
      END	START

## 循环程序设计
如果对多次重复执行的语句由程序控制执行，这类程序设计称为循环程序设计。
循环程序一般由四部分组成：置初值部分、工作部分、修改部分和控制部分。
置初值部分：为了保证循环程序能正常进行循环操作而必须做的准备工作。循环初值分两类，一类是为循环体的循环次数设置的计数初值，另一类是为工作部分、修改部分正常工作设置的初值。
工作部分：即需要重复执行的程序段，这是循环程序的核心，称之为循环体。
修改部分：按一定规律修改操作数地址及控制变量，以使每次执行循环体时得到新的数据。
控制部分：用来保证循环程序按一定的次数或特定条件正常循环。
<img src="https://img-blog.csdnimg.cn/20200516140845819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">1． 计数控制法（循环次数已知的循环控制方法）
假设循环次数为N，常常用以下三种计数控制方法实现循环次数的控制：
1）      MOV	   CX，N	；置初值部分
       ┇
  L：   …  			；工作部分
       ┇			     ；修改部分
             DEC	   CX		；控制部分
             JNZ	   L
2）MOV	CX，－N	；置初值部分
           ┇
L：  …			       ；工作部分
           ┇			；修改部分
       INC 	CX		；控制部分
       JNZ	L

3）MOV	CX，0   	；置初值部分
           ┇
L：  …			       ；工作部分
           ┇			；修改部分
        INC	CX		；控制部分
       CMP	CX，N
       JNZ	L

条件控制法
有些情况下，循环次数无法事先确定，但它与问题中的某些条件有关。这些条件可以通过指令来测试。若测试比较的结果表明满足循环条件，则继续循环，否则结束循环。
例如：统计AX寄存器中为1的位数，并将统计的结果存放在CL寄存器中。
  如果要解决这一问题，可以采用计数控制法控制循环，其程序段如下：
                MOV 	CL，0		；置循环的初值
            	MOV	BX，16
L：	SAL	AX，1	
		JNC	N		
		INC	CL		
N：	DEC	BX		
	 	JNZ	L
EXIT：…

无论AX中内容为何值，程序都要循环16次。显然，解决这一问题时，此种方法并非是一种好方法。如果采用条件控制法编写程序，其程序段如下：
                  	MOV 	CL，0
           L： 	AND    AX，AX
                        JZ        EXIT         ；AX=0时，结束循环转EXIT
    	    	            SAL	AX，1	     ；将AX中的最高位移入CF中
                  	JNC	 L	     ；如果 CF=0则转L
                        INC     CL	     ；如果 CF=1则CL+1→CL
                	JMP     L	     ；转L处继续循环
     EXIT：…

单重循环程序设计
所谓单重循环，即其循环体内不再包含循环结构。
1． 循环次数已知的循环程序设计
  对于循环次数已知的情况，通常采用计数控制方法实现循环。
例5.10   已知以BUF为首地址的字存储区中存放着N个有符号二进制数，试编写程序将其中大于等于0的数依次送BUF1为首地址的字存储区中，小于0的数依次送以BUF2为首地址的字存储区中。同时将大于等于0的数的个数送A字变量，将小于0的个数送B字变量。

例5.10
<img src="https://img-blog.csdnimg.cn/20200516140936274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">DATA	SEGMENT
          BUF	DW	23，123，–12，–210，45，0，90，–453
          N		=         （$–BUF）/2
          BUF1	DW	N  DUP（0）
          BUF2	DW	N  DUP（0）
          A		DW	0
          B		DW	0
DATA	ENDS
CODE	SEGMENT
		ASSUME    CS：CODE，DS：DATA
START：MOV	AX，DATA
		     MOV	DS，AX 
               LEA	BX，BUF	；置循环初值
		LEA	SI，BUF1
		LEA	DI，BUF2
		MOV	A，0
		MOV	B，0
		MOV	CX，N
    L0：	MOV	AX，[BX]		
 	           CMP	AX，0
		JGE	L1
		MOV	[DI]，AX		
	           ADD	DI，2
		INC	B
		JMP	NEXT
      L1： MOV     [SI]，AX	
		    ADD      SI，2
		    INC	       A
NEXT：ADD	       BX，2	  ；BUF的地址修改
		    LOOP    L0		  ；循环次数修改，未完则转L0
		    MOV     AH，4CH
		     INT       21H
CODE	   ENDS
             END	START	

例5.11
试编制一个程序，把字变量X中的16位二进制数用十六进制数的形式在屏幕上显示出来。
这里采用了循环移位的方法把所要显示的4位二进制数移到最右边（最低4位），以便作数字到字符的转换工作。
另外，由于数字0～9的 ASCII为30H～39H，如果要将数字转换为ASCII码只需加30H；而字母 A～F的ASCII码为 41H～46H，如果要将字母转换为对应的ASCII码则需加37H。所以在把4位二进制数转换为ASCII码的时候，需要判断4位二进制所表示的是0～9还是A～F。
在转换的过程中，首先将4位二进制数加30H，然后再作一次判断，如果为数字，则此时的值就是0～9的ASCII码；如果为字符A～F，则还应加上7才是A～F的ASCII码。
只有将4位二进制数转换为ASCII码后才能显示出正确的十六进制数。

<img src="https://img-blog.csdnimg.cn/20200516141008223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">DATA	SEGMENT
            X    DW	4F59H
DATA	ENDS
CODE	SEGMENT
		ASSUME    CS：CODE，DS：DATA
START： MOV	   AX，DATA
		    MOV	   DS，AX
		    MOV	   CH，4	；置循环初值
		    MOV	    BX，X
L：            MOV	    CL，4	；BX中的内容左环移4位
		     ROL	     BX，CL
		     MOV     DL，BL	；低4位送DL
		     AND	     DL，0FH	；DL的低4位转换为ASCII码
		 CMP	DL，10
		 JB	NEXT
		 ADD	DL，7
NEXT：ADD	DL，30H
	          MOV	AH，2		；输出显示
	          INT	21H
	          DEC	CH
		 JNZ	L		；循环次数修改，未完则转L
		 MOV	AH，4CH
		 INT	21H
CODE	ENDS
		END	START 

例5.12
设A变量中存放着10个双字长的二进制数，试用386及其后继机型的相应指令编写将A送B的程序。
在进行32位数据传送的程序设计过程中，首先应该使用32位的数据传送指令。当数据传送后，为了使地址指针指向下一数据，需对地址进行修改。由于一个32位的数据占用4字节，在做地址修改时，需将地址加4。
  .586
DATA	SEGMENT   USE16
           A	DD	10  DUP （？）
           B	DD	10  DUP （？）
DATA	ENDS
CODE	SEGMENT   USE16
		ASSUME   CS：CODE，DS：DATA
START：    MOV	AX，DATA
		       MOV	DS，AX
                     MOV	CX，10		；置循环初值
		       LEA	ESI，A
		       LEA	EDI，B
	     L：    MOV 	EAX，[ESI]	；传送一个双字长的二进制数
		       MOV	[EDI]，EAX
		       ADD	ESI，4		；地址修改
		       ADD	EDI，4
		       LOOP	L		；循环控制
		       MOV	AX，4C00H
		       INT	21H
   CODE	ENDS  		
                  END	START

例5.13
例5.13    设A、B变量中分别存放着10个双字长的多精度二进制数，其中低地址存放的是低位数，高地址存放的是高位数。试用386及其后继机型的相应指令编写将A＋B送C的程序。
 .586
DATA	SEGMENT   USE16
             A	DD	10  DUP （？）
             B	DD	10  DUP （？）
             C	DD	11   DUP（0）
DATA	ENDS
CODE	SEGMENT   USE16
		ASSUME CS：CODE，DS：DATA
START： MOV	AX，DATA
	             MOV	DS，AX	
                CLC			         ；置循环初值
		     MOV	CX，10                
                  LEA	ESI，A
		     LEA	EDI，B
		     LEA	EBX，C
	     L： MOV            EAX，[ESI] ；两个双字长的二进制数相加
		     ADC	EAX，[EDI]
		     MOV	[EBX]，EAX	；结果送目的单元
		     ADD	ESI，4		；地址修改
		     ADD	EDI，4
		     ADD	EBX，4
		     LOOP	L		；循环控制
            MOV	EAX，0	；最高进位的处理
		ADC	EAX，0
		MOV	[EBX]，EAX
		MOV	AX，4C00H
		INT	21H
CODE	     ENDS 		             
         END	START		
循环次数未知的循环程序设计
 例5.14   设STR字符串是以0结尾。试编写一个把字符串中的所有大写字母改为小写字母的程序，并将转换后的字符串显示输出。
由于字符串是以0结尾的，所以字符串的长度是一个未知数，它的循环次数是不确定，需根据字符串尾这个条件来控制程序的循环。
如果是大写字母，需将对应字母的ASCII码加20H；如果是其他字符，则其字符保持不变。编写的程序清单如下：
DATA	 SEGMENT
  STR	DB     ‘HOW   arE   YoU！’，0；假设的字符串
DATA	ENDS
CODE	SEGMENT
           ASSUME    CS：CODE，DS：DATA
 START：MOV      AX，DATA
            	    MOV	      DS，AX
          	    MOV	      SI，OFFSET STR	
AGAIN： MOV       DL，[SI]		；取一字符
                   OR 	       DL，DL 		；是否到字符串尾？
          	     JZ 	       OK  		；到字符串尾，转OK
                   CMP        DL，‘A’	              ；否则，判是否为大写字母
        	     JB	        NEXT		；否，转继续
        	     CMP         DL，‘Z’
        	     JA 	         NEXT		；否，转继续
        	     ADD          DL，20H	              ；是大写字母，改为小写字母
        	     MOV         [SI]，DL		；送回到字符串中
       
NEXT：   MOV	AH，2
                  INT	21H
                  INC 	SI			；调整指针
                  JMP 	AGAIN		；继续
    OK：   MOV         AH，4CH
                  INT 	21H
CODE	     ENDS
                 END 	START 
例5.15
设有一字数组A，第一个字单元存放的是数组元素的个数，从第二个字单元开始依次存放的是数组元素。现要求编写一程序，查找字数组A中与X字变量中相等的第一个元素，若找到该元素，则从数组中删除该元素；否则，数组中的元素不变。
在查找字数组时，若查找到该元素，就应将该元素之后的元素向前移动。移动元素的个数是查找数组元素之后剩余未查找元素的个数；若查找到最后一个元素与该元素相等，因为其后没有元素，所以不需将该元素之后的元素向前移动；若未查找到该元素，表示查找结束。其程序清单如下： 
DATA	     SEGMENT
             A	DW	12，432，—234，56，4，8，2，0，—1，44，20，10，22
             X	DW	？
DATA      ENDS
CODE	      SEGMENT
                       ASSUME    CS：CODE，DS：DATA
START：MOV 	AX，DATA
                  MOV	DS，AX
            MOV	AX，X
	     	MOV	CX，A		；送数组的个数到CX
		LEA	DI，A+2	；送数组元素的首地址到DI
L：	CMP	AX，[DI]	
		JZ	YES		
               ADD	DI，2		；不相同则地址加2继续循环
		LOOP	L
		JMP	RE
YES：	DEC	A	              ；相同时首先将元素的个数减1
	     	CMP	CX，0		；判断是否为最后一个元素
		JZ	RE		；是则转RE退出
               MOV	SI，DI	               ；将未查找的首地址送SI
            MOV	DX，CX	       ；将未查找的个数送DX
		DEC	DX
L1：	MOV	BX，[SI＋2]	
		MOV	[SI]，BX
		ADD	SI，2
		DEC	DX
		JNZ	L1
RE：  MOV   AH，4CH
            INT 	21H
 CODE	ENDS
            	END 	START
例5.16
例5.16    设ARY中存放着以0作为结束的双字数组。请用386及其后继机型的相应指令编写出统计数组中大于0和小于0元素的个数，并将统计的个数分别存放在P和N变量中的程序。
.586
STACK    	SEGMENT    USE16	STACK
              DW	200 DUP （0）
STACK	ENDS
DATA	SEGMENT   USE16
              ARY	DD	100  DUP （？）
              P	DW	0
              N	DW	0
DATA	ENDS
CODE	SEGMENT   USE16
		ASSUME  CS：CODE，DS：DATA, SS：STACK
START：  MOV	AX，DATA
	             MOV	DS，AX
                    MOV	CX，100		；置循环初值
		  LEA	ESI，ARY
	     L：  MOV 	EAX，[ESI]	
             	  CMP	EAX，0
		  JZ           EXIT		；为0则转EXIT
		  JNS         PLUS		；为正数则转PLUS
		  INC         N		；为负数则N+1
		  JMP        CONT
     PLUS： INC	P		；为正数则P+1
    CONT：ADD	ESI，4	                  ；地址加4使ESI指向下一个数
		  LOOP	L		；未完则继续循环
     EXIT： MOV	AX，4C00H
		  INT	21H		
CODE         ENDS
              END	START

多重循环程序设计
当内层循环设计完之后，用其替换外层循环体中被视为一个处理粗框的对应部分，再对外层循环进行置初值、工作、修改和控制部分的设计，这样一层一层地进行设计，就构成了一个多重循环结构。
例5.17   已知M×N矩阵A的元素Aij按行序存放在以A为首地址的字节存储区中，试编写程序，求每行元素之和Si。
        每行元素之和Si的计算公式为：
		         ｎ
	 	Sｉ= Σ Aij		（ｉ=1，2，…，ｍ）
		    ｉ=1
<img src="https://img-blog.csdnimg.cn/20200516141159836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">DATA	SEGMENT
    A      DB	11，12，13，14，15，16
		DB	17，18，19，20，21，22
		DB	23，24，25，26，27，28
		DB	29，30，31，32，33，34
		DB	35，36，37，38，39，40
    M	=	5
    N	=	6
    S	DW	M   DUP（0）
DATA	ENDS
CODE	SEGMENT
            		ASSUME    CS：CODE，DS：DATA
START：MOV 	  AX，DATA
            	   MOV	  DS，AX
                  LEA	  SI，A	      ；S的首地址送SI
                  LEA	  DI，S	      ；和数的地址送DI
                  MOV	  BX，M     ；将行数送BX作为循环的次数
	  L1：  MOV	  DX，0	      ；将行的和数初值送0
		    MOV	  CX，N     ；将行元素个数（列数）送CX作为循环的次数
        L2：  MOV	  AL，[SI]   ；求行元数的和
                   CBW
                   ADD	   DX，AX
                   INC	   SI
                   LOOP  L2	        ；一行的元素未完则转L2 继续
         MOV	[DI]，DX	；和数送结果单元
         ADD	DI，2		；地址加2指向下一个数
         DEC	BX
         JNZ	L1  		；行数未完则转L1继续
         MOV     AH，4CH
         INT 	21H
CODE	      ENDS             
         END 	START
算术运算与代码变换程序设计
算术运算程序
例 5.18  设A、B两个变量都是6字节的无符号数据。
编写程序计算A+B→C。
DATA	SEGMENT
          A	     DB	91，12，13，14，15，16
          B	     DB	37，18，19，20，21，22
          C	     DB	7   DUP（0）
DATA	ENDS
CODE	SEGMENT
            ASSUME    CS：CODE，DS：DATA
START：	MOV 	AX，DATA
            		MOV	DS，AX
             LEA	SI，A		；置初始参数地址值
             LEA	DI，B
             LEA	BX，C
             MOV	CX，6		；置初始参数个数
             CLC			；清进位位
L： 	MOV	AL，[SI]	；两数相加送结果单元
             ADC	AL，[DI]
             MOV	[BX]，AL
             INC	SI		；地址修改
             INC	DI
             INC	BX
             LOOP	 L		；循环控制
         MOV	AL，0		；最高进位位的处理
         ADC	AL，0
         MOV	[BX]，AL
         MOV    	AH，4CH
         INT 	21H
CODE	     ENDS
            END 	START 

例 5.19
例5.19   设变量BCD1、BCD2为非压缩BCD码，试编写一程序计算表达式：   F=（BCD1+BCD2）×5/10。同时将计算结果显示输出。
DATA	SEGMENT
          BCD1 	DB	5，9
          BCD2	DB	3，8
          F	             DB	6   DUP（‘ ’），0DH，0AH，‘＄’
          FIVE	DB	5
          TEN	DB	10
DATA	ENDS
CODE	SEGMENT
            		ASSUME    CS：CODE，DS：DATA
START：MOV     AX，DATA
            	   MOV	   DS，AX
                 MOV	   AL，BCD1		；个位数相加
                 ADD	   AL，BCD2
                 AAA
                 MOV	   DL，AL
                 MOV	   AL，BCD1+1		；十位数相加
                 ADC	   AL，BCD2+1
                 AAA
                 MOV	   CL，0		；将十位数相加的进位送CL
                 ADC	   CL，0
                 MOV	   DH，AL
                 MOV	   AX，DX		；将十进制数转换为二进制数
             AAD
             CMP	   CL，0
             JZ	   P
             ADD	   AX，100
P：	MUL	   FIVE			；（BCD1+BCD2）×5
             DIV	   TEN			；（BCD1+BCD2）×5/10
             ADD	   AH，30H		；余数送F+5
             MOV	   F+5，AH
             AAM
             ADD	   AX，3030H		；商数送F
             XCHG	   AH，AL
             MOV	   WORD   PTR   F，AX
                                  LEA	DX，F                   
                                  MOV	AH，9
                                   INT	21H
                                   MOV   	AH，4CH
            		INT 	21H
                  CODE	ENDS
            		END 	START

例 5.20
例5.20     设变量BCD1、BCD2为压缩型BCD码，编写计算表达式 S=BCD1＋BCD2的程序，同时将计算结果显示输出。
DATA	SEGMENT
          BCD1 	DB	56H，92H
          BCD2	DB	73H，81H
          S		DB	3   DUP (0)
          F		DB	5   DUP（‘ ’），0DH，0AH，‘＄’
DATA	ENDS
CODE	SEGMENT
            		ASSUME    CS：CODE，DS：DATA
START：	MOV 	AX，DATA
            		MOV	DS，AX
MOV	AL，BCD1		；低位数相加
ADD	AL，BCD2
DAA				；BCD调整
MOV	S，AL			；送结果单元
MOV	BL，AL
MOV	AL，BCD1+1		；高位数相加
ADC	AL，BCD2+1
DAA				；BCD调整
MOV	S+1，AL		；送结果单元
MOV	CL，0			；高位进位送结果的最高位
ADC	CL，0
MOV	S+2，CL
ADD	CL，30H		；将结果转换为ASCII码送F
MOV	F，CL
MOV	AH，AL
MOV	BH，BL
MOV	CL，4
SHR	AH，CL
AND	AL，0FH
SHR	BH，CL
AND	BL，0FH
OR	AX，3030H
OR	BX，3030H
XCHG	AH，AL
XCHG	BH，BL
MOV	WORD	PTR   F+1，AX
MOV	WORD	PTR   F+3，BX
LEA	DX，F	；将F的内容显示输出
MOV	AH，9
INT	21H
MOV    AH，4CH
INT 	21H
CODE	ENDS
            		END 	START

## 代码转换程序设计
例5.21     编写程序，将BIN字变量中的16位有符号二进制数转换成十进制数，然后将十进制数的ASCII码存人存储器的BUF字节缓冲区中，并显示输出转换的结果。
其解题分为四步：
一是处理16位有符号二进制数的符号位；
二是完成二进制转换成十进制的操作；
三是ASCII码的转换；四是显示输出转换的结果。
四步中最主要的是完成二进制转换成十进制的操作。
其转换的方法有多种，下面介绍一种除十取余的方法。此转换方法是将二进制数每次除以10。
第一次将二进制数除以10得到的余数是个位数；
第二次将所得的商除以10得到的余数是十位数；
第三次再将所得的商除以10得到的余数是百位数；
第四次再将所得的商除以10得到的余数是千位数；
第五次再将所得的商除以10得到的余数是万位数。

例5.21
每次将所得的余数依次保存在堆栈中。ASCII码的转换操作是将堆栈中的内容依次弹出，将每个数加30H后送BUF字节缓冲区。最后用DOS功能调用将BUF字节缓冲区的内容显示输出。编写的程序清单如下：
STACK	SEGMENT    STACK
	DW	100 DUP（0）
STACK	ENDS
DATA	SEGMENT
  BIN	DW	7462
  BUF	DB	6   DUP（0），0DH，0AH，‘＄’
  TEN	DW	10
DATA	ENDS
CODE	SEGMENT         
ASSUME    CS：CODE，DS：DATA，SS：STACK
START：	  MOV 	AX，DATA
          MOV	DS，AX
          MOV	AX，BIN		；符号位处理
          OR	AX，AX
          JNS	PLUS
          NEG	AX
          MOV	BUF，‘－’
          JMP	NEXT
PLUS：	  MOV	BUF，‘+’
NEXT：	  MOV	CX，5		
L1：  	  MOV	DX，0
          DIV	TEN
          PUSH	DX
          LOOP	L1
          MOV	CX，5		；ASCII码的转换
      LEA	BX，BUF+1
L2： 	POP	AX
       ADD	AL，30H
       MOV	[BX]，AL
       INC	BX
       LOOP	L2
       LEA	DX，BUF		；显示字符串
       MOV	AH，9
       INT	21H
       MOV   AH，4CH
       INT 	21H
CODE	ENDS
     END 	START

例5.22
例5.22   编写将STR字符串中存放的十进制ASCII码数字（－32768～32767）转换为二进制数字，并把转换的结果送BUF缓冲区的程序。
该程序的功能是要将有符号的十进制数（连同符号位）转换成二进制数。有符号十进制数的书写形式有如下三种：
d1 d2 …dn, +d1  d2  …dn, －d1  d2  …dn;其中di (i =1,2, …,n)为0～9中的一位十进制数字。
将有符号十进制数转换二进制数须分三步完成。第一步是对符号的处理；第二步是对数字的转换；第三步是对错误信息的处理。对数字的转换可以把十进制数字d1 d2 …dn写成如下形式：
d1 d2 …dn=（…（0）×10+ d1）×10+ d2+…）×10+ dn
由于di和10在计算机中都是以二进制形式表示和运算的，所以上式在计算机中计算所得的值为二进制。如果d1 d2 …dn为正数，则计算所得的值就是要转换的二进制；如果d1 d2 …dn为负数，则计算所得的值须求补后才是转换的二进制。编写的程序清单如下：
STACK	SEGMENT    STACK
	DW	100 DUP（0）
STACK	ENDS
DATA	SEGMENT
   STR	DB      ‘－2510’
   C		=	＄－STR
   BUF	DW	2  DUP  （0）
   FLAG	DB	0
   TEN	DW	10
   ERR1	DB      ‘十进制数的ASCII码串有非数字字符的错误！＄’
   ERR2	DB      ‘十进制数字超出数字范围错误！＄’
DATA	ENDS
CODE	SEGMENT
    ASSUME    CS：CODE，DS：DATA，SS：STACK
START：	MOV 	AX，DATA
        MOV	DS，AX
       MOV	FLAG，0	   ；置初值
       MOV	AX，0
       LEA	SI，STR
       MOV	CX，N
       MOV	BL，[SI]
       CMP	BL，‘－’；第一个字符为非“－ ”则转A
       JNZ	A
       MOV	FLAG，1	   ；第一个字符为“－ ”则FLAG置1
       JMP	B
A：   	CMP	BL，‘＋’；第一个字符无“－”、“＋”则转N2
       JNZ	N2
B：   	DEC	CX	   ；跳过第一个符号位字符
N1： 	INC	SI
       MOV	BL，[SI]  ；取出一个ASCII码数
N2：	CMP	BL，30H	        ；为非数字则转ER1进行出错处理
	     JB	ER1
        CMP	BL，39H
        JA	ER1
        SUB	BL，30H	        ；将ASCII码转换为数字
        MOV	BH，0
        MUL	TEN		；将上次的数乘以10
        JO	ER2		；超出范围则转ER2进行出错处理
        ADD	AX，BX	        ；将本次的数加到结果中
        JC	ER2		；超出范围则转ER2进行出错处理
        LOOP	N1
        CMP	FLAG，1	        ；为负数则将转换的结果求补
        JNZ	RE
        NEG	AX
RE：	MOV	BUF，AX	        ；保存结果
      JMP	EXIT
ER1： 	LEA	DX，ERR1	；显示非数字的出错信息
		MOV	AH，9
		INT	21H
		JMP	EXIT
ER2：	LEA	DX，ERR2	；显示超出范围的出错信息
		MOV	AH，9
		INT	21H
		JMP	EXIT	
EXIT：	MOV     AH，4CH
    	INT 	21H
CODE	ENDS
      END 	START

例5.23     编写程序，将BUF缓冲区中5个字节的压缩型的BCD码转换成非压缩型的BCD码（ASCII）送STR缓冲区，并将转换结果显示输出。
STACK	SEGMENT    STACK
	DW	100 DUP（0）
STACK	ENDS
DATA	SEGMENT
   BUF	DB       	23H，65H，28H，91H，66H
   STR	DB	10  DUP  （0）
   DISBUF	DB	10  DUP （0），0DH，0AH，‘＄’
DATA	ENDS
CODE	SEGMENT
   ASSUME    CS：CODE，DS：DATA，SS：STACK
START：	MOV 	AX，DATA
        MOV	DS，AX
        LEA	SI，BUF		；送循环的初值
        LEA	DI，STR
        LEA	BX，DISBUF+9
        MOV	DX，5
L：	MOV	AL，[SI]	；将压缩的BCD码的低位转换为ASCII
        AND	AL，0FH
        ADD	AL，30H
        MOV	[DI]，AL
        INC	DI
        MOV	[BX]，AL
        DEC	BX
        MOV	AL，[SI]	；将压缩的BCD码的高位转换为ASCII
        MOV	CL，4
        SHR	AL，CL
        ADD	AL，30H
        MOV	[DI]，AL
        INC	DI
         MOV	[BX]，AL
         DEC	BX
         DEC	DX
         JNZ	L			
         LEA	DX，DISBUF		
         MOV	AH， 9
         INT	21H
EXIT：   MOV	AH，4CH
         INT 	21H
CODE	ENDS
     END 	START

## 子程序设计（自学）
子程序又称为过程，它相当于高级语言中的过程和函数。将重复的或经常要使用的程序段设计成可供反复调用的独立程序段，在需要时用相应的指令调用它，执行完之后再返回到调用它的程序中继续执行，这样的独立程序段称为子程序。

<img src="https://img-blog.csdnimg.cn/20200516141528201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
### 设计子程序考虑的主要问题
如何定义子程序？
主程序是怎样调用子程序的？
子程序执行完之后，怎样才能返回到主程序处继续往下执行？
主程序每次调用子程序时提供给子程序加工的数据往往是不同的。主程序怎样把这些数据传送给子程序、而子程序又如何把加工结果交给主程序？即主程序与子程序之间用什么方式传递参数？
如何编写子程序？ 
### 子程序的调用和返回指令
1． 子程序调用指令CALL
  1）段内直接调用指令
格式：  CALL      OPD
当操作数长度为 16位时：
SP－2→SP，IP →[SP]
IP＋D16→ IP  
或 EIP＋D16   AND 0000FFFFH→EIP
当操作数长度为32位时： ESP－4→ESP，
                                              EIP → [ESP]
                       EIP＋D32→ EIP

2）段内间接调用指令
格式： CALL     WORD  PTR  OPD
执行的操作：
当操作数长度为16位时：
SP－2→SP，IP→[SP] （EA）→ IP
或（EA）AND 0000FFFFH→ EIP
当操作数长度为32位时：ESP－4→ESP，
                                            EIP→[ESP] 
                     （EA）→ EIP
如操作数长度的为16位时，则有效地址EA应为16位；操作数长度为32位时，EA应为32位。 

3）段间直接调用指令
格式： CALL     FAR PTR  OPD
执行的操作：当操作数长度为16位时：
       		SP－2→ SP，CS→[SP]
    	SP－2→ SP，IP →[SP]                                                                   		OPD指定的偏移地址→ IP                                                                              		OPD指定的段地址→ CS
当操作数长度为32位时： 
        	ESP－4→ ESP，CS作低16位→[ESP] 
        	ESP－4→ ESP，EIP→[ESP]
        	OPD指定的偏移地址→ EIP                                                                          
        	OPD指定的段地址→CS
4）段间间接调用指令
格式： CALL     DWORD  PTR  OPD
执行的操作：当操作数长度为16位时：
		SP－2→SP，CS→[SP] 
		SP－2→SP，IP →[SP]                                                                             		（EA）→IP                                                                             		（EA+2）→CS
当操作数长度为32位时： 
		ESP－4→ESP，CS作低16位→[ESP]
          ESP－4→ESP，EIP→[ESP]                                                                             		（EA）→EIP                                                                             		（EA+4）的低16位→CS

2．子程序返回指令RET

1）段内近程返回指令
格式：RET
当操作数长度为16位时：（[SP]）→IP，SP＋2→SP
当操作数长度为32位时：（[ESP]）→EIP，ESP＋4→ESP

2）段内带立即数近程返回指令
格式：RET    n
当操作数长度为16位时：（[SP]）→IP，SP＋2→SP 
                       SP+D16→SP
当操作数长度为32位时：（[ESP]）→EIP，ESP＋4→ESP
                       ESP+D16→ESP
2．子程序返回指令RET
3）段间远程返回指令      
格式：RET
当操作数长度为16位时：（[SP]）→IP，SP＋2→SP
                      （[SP]）→CS，SP＋2→SP
当操作数长度为32位时：（[ESP]）→EIP，ESP＋4→ESP
                      （[ESP]）→CS，ESP＋4→ESP
4）段间带立即数远程返回指令    
格式：RET    n
当操作数长度为16位时：（[SP]）→IP，SP＋2→SP
			    （[SP]）→CS，SP＋2→SP
			     SP+D16→SP
当操作数长度为32位时：（[ESP]）→EIP，ESP＋4→ESP
		  	    （[ESP]）→CS，ESP＋4→ESP				     ESP+D16→ESP

### 子程序的定义
过程名     PROC     ［NEAR / FAR］
		 （过程体）
过程名    ENDP

如果调用的程序和子程序在同一个代码段中，则使用NEAR属性。
如果调用的程序和子程序不在同一个代码段中，则使用FAR属性。
过程体是完成某一功能的程序段。 
例如：编写一子程序，将AL中的一位十六进制转换成ASCII码显示输出。
HEXDIS 	PROC	NEAR
		AND	AL，0FH
		ADD	AL，30H
		CMP	AL，39H
		JBE	NEXT
		ADD	AL，7
NEXT：	MOV	DL，AL
		MOV	AH，2
		INT	21H
          RET
HEXDIS	ENDP
如果调用程序和子程序在同一代码段中，其结构形式为：
CODE	SEGMENT
		 ┇
		CALL	DISPLAY
		 ┇
DISPLAY 	PROC	NEAR
		 ┇
		RET
DISPLAY	ENDP
CODE	ENDS
由于“ CALL  DISPLAY ”指令和子程序DISPLAY在同一代码段中，DISPLAY应定义为NEAR属性。
如果调用程序和子程序不在同一代码段中，其结构形式为：
CODE1	SEGMENT
		 ┇
		CALL	FAR  PTR  DISPLAY
		 ┇
CODE1	ENDS
CODE2	PROC	
		 ┇
		CALL	DISPLAY
		 ┇
DISPLAY 	PROC	FAR
		 ┇
		RET
DISPLAY	ENDP
		 ┇
CODE2	ENDS
现场的保护和恢复
例如：
                SUB1	PROC
                         	PUSH	AX
                       	PUSH	BX
                       	PUSH 	CX
                          PUSH 	DX
                         	 ┇
                          POP	DX
                          POP 	CX
                          POP	BX
                         	POP	AX
		              RET
                 SUB1	ENDP
应该注意的是，堆栈的操作原则是后进先出。

子程序的参数传递方法
在编写子程序时，为了便于其他用户调用该子程序和程序的阅读，通常要写出该子程序的说明信息。说明信息一般由如下几个部分组成：
（1）子程序名
（2）功能描述
（3）入口参数
（4）出口参数
（5）使用的寄存器
（6）使用的算法和重要的性能指标
（7）其他说明

主程序与子程序之间传递参数的方法有寄存器法、约定单元法、地址表法和堆栈法。 

寄存器法
寄存器法就是子程序的入口参数和出口参数存放在约定的寄存器中。
优点：数据传递速度快、编程较方便、节省内存单元。
缺点：当传递的参数较多时，由于寄存器的个数是有限的，而且在处理过程中要经常使用寄存器，将导致无空闲寄存器供编写程序使用。
寄存器法只适用于传递参数较少的情况。

例 6.1
编写程序，将键盘输入的以非数字结束的十进制数转换成二进制数依次送BUF字缓冲区，最后以输入回车结束数据的输入。
程序清单如下：
STACK	   SEGMENT	STACK
	   DB	128  DUP（0）
STACK	   ENDS
DATA	          SEGMENT
       BUF	DW	30  DUP（0）
DATA           ENDS
CODE   	   SEGMENT
	ASSUME     CS：CODE，DS：DATA，SS：STACK
START：	MOV	AX，DATA
	       MOV	DS，AX
           	MOV	AX，STACK
       	MOV	SS，AX
  		LEA	SI，BUF	；
L：	   	MOV	DI，0		 
         	CALL	DCB		
         	CMP	DI，0		
                   	JNZ	EXIT		
         	MOV 	[SI]，BX	
         	ADD  	SI，2
         	JMP	L
EXIT：   	MOV	[SI]，BX
         	MOV	AH，4CH
	   	INT	21H
DCB	 PROC
      	PUSH	 AX		
      	PUSH   CX
		MOV	 BX，0		
NEW ：	MOV	 AH，1		
		INT	 21H
		CMP	 AL，0DH	
      	JNZ	 NHC		
      	MOV	 DI，1		
NDIG：	POP	 CX		
		POP	 AX
      	RET
NHC： CMP	AL，30H	
     JL 	NDIG
     CMP 	AL，39H
     JG	NDIG
     AND	AL，0FH
     CBW			
     XCHG	AX，BX
     MOV  	CX，10
     MUL  	CX
     XCHG     AX，BX
     ADD      BX，AX
     JMP 	NEW
DCB	ENDP
CODE	ENDS
		END	START

例 6.2
编写一主程序调用二进制数转换成十进制数显示输出的子程序，将BUF字缓冲区的数显示输出。
STACK	SEGMENT	STACK
		DB	128  DUP（0）
STACK	ENDS

DATA 	SEGMENT
 	BUF	DW	30  DUP（？）
 	N	=     （＄－BUF）/2
 	STR	DB	9  DUP（‘ ’）
 	CHE	DW	10000，1000，100，10，1
DATA	       ENDS
CODE	      SEGMENT
		ASSUME     CS：CODE，DS：DATA，SS：STACK
START：	MOV	AX，DATA
		MOV	DS，AX
       	MOV	AX，STACK
       	MOV	SS，AX
       	LEA	SI，BUF	
		MOV	CX，N
L：    	MOV	AX，[SI]	
		LEA	DI，STR	
       	CALL	CBD		
       	ADD	SI，2		
       	LOOP	L		
       	MOV	AH，4CH
		INT	21H
CBD	PROC
	PUSH	AX			；保护现场
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	PUSH	DI
	PUSH	DI
	LEA	SI，CHE
	OR	AX，AX		
	JNS	PLUS
	MOV	BYTE   PTR  [DI]，’_’ 		
    INC	DI
	NEG	AX			；将负数转为正数
PLUS：	MOV	CX，5			
L1：		MOV	BX，[SI]
		MOV	DX，0
		DIV	BX
		ADD	AL，30H
		MOV	[DI]，AL
		INC	DI
		ADD	BX，2
		MOV	AX，DX
		OR	AX，AX
		JZ	L2
		LOOP	L1
L2：		MOV	BYTE   PTR[DI]，0DH		
 		INC	DI
       	MOV	BYTE   PTR[DI]，0AH
		INC	DI
 		MOV	BYTE  PTR[DI]，‘＄’
		POP	DX			
		MOV	AH，9
		INT	21H
		POP	DI			；恢复现场
		POP	SI
		POP	DX
		POP	CX
		POP	BX
		POP	AX
		RET
  CBD	ENDP
  CODE	ENDS
		END	START 
约定单元法
约定单元法是子程序的入口参数和出口参数存放在约定的存储单元中。

优点：子程序要处理的数据或计算的结果分别存放在各自的存储单元中。它不需要占用寄存器。

缺点：需要占用一定数量的存储单元。 
例 6.3
编写程序，其主程序和被调用的子程序在同一个代码段中。要求子程序的功能是将BUF中的16位无符号二进制数转换为P 进制数显示输出。其中的P为3～16中任一整数。
二进制数转换为P进制数可采用“除P取余” 法
   STACK	SEGMENT	STACK
		DW	128  DUP（0）
   STACK	ENDS
   DATA		SEGMENT
    		A	DW	1234H，4352H，3A62H，6390H
    		N	=         （＄－A）/2
    		BUF	DW	？
    		STR	DB	15  DUP （？）
    		P	DW	？
    		J	DB	？
   DATA		ENDS 
CODE	     SEGMENT
	ASSUME    CS：CODE，DS：DATA，SS：STACK
START：	MOV	AX，DATA
	 	MOV	DS，AX
	 	MOV	AX，STACK
	 	MOV	SS，AX
	 	MOV	CX，N
	 	LEA	DI，A
   L：	MOV	AX，[DI]		
		MOV	BUF，AX
       	MOV	P，8			
       	MOV	J，‘Q’		
       	CALL	BCP
       	MOV	P，16			
       	MOV	J，‘H’		
 		CALL	BCP
       	ADD	DI，2
       	LOOP	L
		MOV	AH，4CH
		INT	21H
 BCP	  PROC
		PUSH	AX		
		PUSH	BX
		PUSH	CX
		PUSH	DX
		PUSH	SI
       	MOV	AX，BUF	
       	LEA	SI，STR	；
       	MOV	BX，P		
       	MOV	CX，0		
 	L1：	MOV	DX，0		
           	DIV	BX
           	PUSH	DX
           	INC	CX
            	OR	AX，AX
           	JNZ	L1
     L2：	POP	AX		
            	CMP	AL，10 
          	JB	L3
          	ADD	AL，7
     L3：	ADD	AL，30H
		MOV	[SI]，AL
          	INC	SI
          	LOOP	L2
          	MOV	AL，J
          	MOV	[SI]，AL
 	 	MOV	[SI+1]，BYTE  PTR  0DH
       	MOV	[SI+2]，BYTE  PTR  0AH
       	MOV	[SI+3]，BYTE  PTR ‘＄’
       	LEA	DX，STR	；
              	MOV	AH，9
       	INT	21H
       	POP	SI		
		POP	DX
		POP	CX
		POP	BX
		POP	AX
		RET
BCP	ENDP
CODE	    ENDS
		END	START

例 6.4 
编写一程序，其主程序和子程序在同一个代码段中。要求子程序将DATA1和DATA2字节缓冲区中的N个字节的内容相加，其结果存放在SUM字节缓冲区中。
编写的程序清单如下：例 6.4（续）-子程序：MADD 


STACK	SEGMENT	  STACK
	DW	128  DUP（0）
STACK	ENDS

DATA	       SEGMENT
	DATA1	DB	10  DUP （？）
	DATA2	DB	10  DUP （？）
	SUM	DB	11  DUP （0）
	N	DW	10
DATA	       ENDS
CODE	SEGMENT
	ASSUME    CS：CODE，DS：DATA，SS：STACK
START:        MOV	AX，DATA
		MOV	DS，AX
		MOV	AX，STACK
		MOV	SS，AX
		CALL	MADD
		MOV	AH，4CH
		INT	21H
MADD   PROC
       	PUSH 	AX
       	PUSH 	CX
       	PUSH	SI
       	MOV	CX，N			
       	XOR	SI，SI
  M1： 	MOV  	AL，DATA1［SI］	
       	ADC	AL，DATA2［SI］
       	MOV  	SUM［SI］，AL
       	INC	SI
		LOOP	M1
		MOV	AL，0			
		ADC	AL，0
		MOV	SUM[ SI ]，AL
 		POP	SI			
		POP	CX
		POP	AX
		RET
MADD	   ENDP
CODE	   ENDS
		END	START


地址表法
地址表法是把参数组成一张参数表存放在某个存储区中，然后只要主程序与子程序约定好这个存储区的首地址和存放的内容，在主程序中将参数传送给地址表，在子程序中根据地址表给定的参数就可以完成其操作。
例6.5
编写一程序，其主程序和子程序在同一个代码段中。要求子程序将字节缓冲区中的多个字节的二进制内容相加，其结果存放在结果单元中。
程序清单如下：
DATA	     SEGMENT
	TAB	DW	3   DUP  （0）
	BUF1	DB	10  DUP （？）
	N1	DW	6
	SUM1	DW	0
	BUF2	DB	20  DUP （？）
	N2	DW	12
	SUM2	DW	0
DATA	     ENDS 
CODE	     SEGMENT
		ASSUME    CS：CODE，DS：DATA，SS：STACK
START：	MOV	AX，DATA
		MOV	DS，AX
		MOV	AX，STACK
		MOV	SS，AX
		LEA	AX，BUF1		；将入口参数送TAB
		MOV	TAB，AX
		LEA	AX，N1
		MOV	TAB+2，AX
		LEA	AX，SUM1
		MOV	TAB+4，AX
 		CALL	MBA			；子程序调用
		LEA	AX，BUF2		；将入口参数送TAB
		MOV	TAB，AX
		LEA	AX，N2
		MOV	TAB+2，AX
		LEA	AX，SUM2
		MOV	TAB+4，AX
		CALL	MBA			；子程序调用
		MOV	AH，4CH
		INT	21H 
子程序：MBA

 MBA 	PROC
      	PUSH 	AX	
        	PUSH 	CX
 		PUSH	SI
         	MOV	SI，TAB+2		
		MOV	CX，[SI]
		MOV	SI，TAB
         	XOR	AX，AX
	M1：	ADC	AL，［SI］		
         	ADC	AH，0
         	INC	SI
		LOOP	M1
  		MOV	SI，TAB+4		
		MOV	[SI]，AX
		POP	SI			
		POP	CX
		POP	AX
		RET
MBA	  ENDP
CODE	ENDS
		END	START

堆栈法
用堆栈传递参数的方法是在调用子程序之前，用PUSH指令将输人参数压入堆栈，在子程序中通过出栈方式依次获得这些参数。经过子程序操作处理后再将输出参数压入堆栈，返回主程序后再通过出栈获得结果。
使用这种方式传递参数时，特别要注意堆栈中断点的保存与恢复。 
例6.6
利用堆栈传递参数的方法编制一子程序，实现主程序调用不同代码段的子程序对指定的数组求和。
STACK 	SEGMENT  PARA   STACK  ‘STACK’
       DB           128   DUP（？）
STACK 	ENDS
DATA	      SEGMENT
	ARYA 	DB	 al，a2，a3，…，an	
	NA	=	＄－ARYA		
	SUMA 	DW	？			
	ARYB 	DB	bl，b2，b3，…，bn	
	NB	=	＄－ARYB		
	SUMB  	DW	？			
DATA 	ENDS 
CODE 	SEGMENT
      ASSUME    CS： CODE， DS： DATA， SS： STACK
START：	MOV	AX，DATA
          	MOV	DS，AX
          	MOV    AX，STACK
          	MOV 	SS，AX
          	MOV 	AX，NA	
          	PUSH 	AX
          	LEA	AX，ARYA	
          	PUSH 	AX
		LEA	AX，SUMA	
		PUSH	AX           
     	CALL   FAR PTR SUM	
		MOV 	 AX，NB	
         	PUSH 	 AX
          LEA	 AX，ARYB	
        	PUSH   AX
		LEA	 AX，SUMB	
		PUSH	 AX
          CALL   FAR  PTR SUM
          MOV    AH， 4CH
          INT 	 21H
CODE 	ENDS
     	CALL   FAR PTR SUM	
		MOV 	 AX，NB	
         	PUSH 	 AX
          LEA	 AX，ARYB	
        	PUSH   AX
		LEA	 AX，SUMB	
		PUSH	 AX
          CALL   FAR  PTR SUM
          MOV    AH， 4CH
          INT 	 21H
CODE 	ENDS
<img src="https://img-blog.csdnimg.cn/2020051614204717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">子程序：SUM

PROCE 	SEGMENT
       ASSUME   CS： PROCE， DS： DATA， SS： STACK
SUM 	PROC 	FAR
              	PUSH 	AX		
               	PUSH	BX
              	PUSH 	CX
			PUSH	BP
             	PUSHF
              	MOV 	BP，SP		
            	MOV	CX，[BP+18]	
            	MOV    BX，[BP+16]	
              	MOV 	AX，0	
 	LOPI：		ADD 	AL，[BX]	
 		ADC 	AH，0	
		INC 	BX		
		LOOP	LOPI
		MOV	BX，[BP+14]	
		MOV	[BX]，AX	
		POPF			
		POP	BP
		POP	CX
		POP	BX
		POP	AX
		RET	6
SUM	ENDP
PROCE	ENDS   		
		END	START 	

例6.7
设ARY1和ARY2是两个长度都为10的双字数组。请用比例变量寻址方式编写一子程序，对两个数组中的对应元素分别相乘，其结果存放在ARY3的数组中。

 .586
STACK     	SEGMENT	   USE16  SATCK
      DW	128   DUP（0）
STACK	ENDS
DATA	       SEGMENT    USE16  
	ARY1	DD	10  DUP （？）
	ARY2	DD	10   DUP（？）
	ARY3	DQ	10  DUP （？）
	TAB	DD	3   DUP （0）
DATA	       ENDS
CODE	     SEGMENT       USE16  
	ASSUME  CS：CODE，DS：DATA, SS：STACK
START：	MOV	AX，DATA
		MOV	DS，AX
		MOV	AX，STACK
		MOV	SS，AX
		LEA	EAX，ARY1		
     	MOV	TAB，EAX
		LEA	EAX，ARY2
		MOV	TAB+4，EAX
		LEA	EAX，ARY3
		MOV	TAB+8，EAX
		CALL	AMUL	
             MOV	AX，4C00H
		INT	21H
AMUL	PROC
		MOV	ESI，TAB	
      	MOV	EDI，TAB+4				
	        MOV	EBP，TAB+8			
		MOV	EBX，0
		MOV	CX，10
     L：	MOV 	EAX，[ESI][EBX*4]			
	        MUL	[EDI][EBX*4]			
		MOV	[EBP][EBX*8]，EAX		
	        MOV	[EBP+4][EBX*8]，EDX
		INC	EBX				
		LOOP	L
		RET
AMUL	ENDP
		END	START 


