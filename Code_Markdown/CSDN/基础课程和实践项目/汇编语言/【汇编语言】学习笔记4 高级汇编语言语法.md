@[toc]

# 一、汇编语句表达式
## 1. 汇编语言语句格式
1.指令语句的一般格式如下:

```clike
[标号:][指令前缀] 助记符 [操作数] [;注释]
```
- 标号：标号是机器指令语句**存放地址的符号表示**，代表该指令目标代码的**第一个字节地址**，后面必须紧跟冒号“:” 。
- 指令助记符：**指令助记符为语句的核心成分**，表示了该语句的操作类型。 
- 操作数：操作数表示**指令助记符的操作对象**。 
- 注释：**注释均以分号开始**，它可占一行或多行，一般放在一条语句的后面。 

## 2. 数值表达式
### (1) 常量
#### 1) 整常量
各种形式数字常量格式对照表：
<img src="https://img-blog.csdnimg.cn/20200516135436923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="43%">
#### 2) 字符串常量
   字符串常量是用**单引号或双引号引起来**的一个或多个字符。字符串常量是以 `各字符的ASCII码` 表示的。如‘A’用41H表示，字符串‘A1B2’用 `41H, 31H, 42H, 32H` 表示。回车换行用 `0DH, 0AH` 表示。

#### 3) 符号常量
用等价语句 `EQU` 或者 `=` 语句**定义的名字来表示常量**，可以直接写在汇编语句中，**能提高程序的可读性**，使用修改也很方便。

```clike
COUNT = 60 * 60   	;COUNT = 3600
MOV   ECX, COUNT
```

### (2) 算术运算符
算术运算符包括：`+`（加）、`-`（减）、`*`（乘）、`/`（除）、`MOD`（求模）、`SHL`（左移）、`SHR`（右移）几种，它**既可以用于数值表达式又可用于地址表达式**。

例 用算术运算符进行数值表达式运算。
	 
```clike
NUM1	EQU	25*4 – 50	    ;NUM1=50
NUM2	EQU	NUM1 / 7	    ;NUM2=7
NUM4	DB	NUM1  MOD  7    ;NUM4=1
VAR1	DB	1, 2, 4, 4, 5
VAR2	DB	'12445'
NUM4	EQU	VAR2 - VAR1	    ;NUM4=5, VAR1为1的地址, VAR2为'1'的地址
NUM5	EQU	0FH
		...
MOV   AL, NUM5  SHL  4     ;(AL)=11110000B
MOV   BL, NUM5  SHR  4     ;(BL)=00000000B
```

### (3) 逻辑运算符
逻辑运算符包括：逻辑乘（`AND`）、逻辑加（`OR`）、按位加（`XOR`）、逻辑非（`NOT`）四种运算。由于逻辑运算是**按位操作**，且在汇编过程中完成，因而**运算的结果仍为整数常量**。

例 用逻辑运算符进行运算。
```clike
MOV	AL, 44H  AND  0FH    ;04H→AL
MOV	BL, 05H  OR   40H	 ;45H→BL
MOV	CX, NOT  00FFH       ;0FF00H→CX
MOV	DX, 789AH XOR 000FH	 ;7895H→DX
```

### (3) 关系运算符
关系运算符包括：相等（`EQ`），不等（`NE`），小于（`LT`），大于（`GT`），小于等于（`LE`）及大于等于（`GE`）。 

例 用关系运算符进行数值表达式运算。
```clike
 NUM1	DB  10  LT  5	        ;NUM1=0
 NUM2	DB  0AAAAH  GT  7FFFH	;NUM2=0FFH, 成立则一个字节全1，否则一个字节全0
       ...
 MOV	AX, 'A' EQ  41H	        ;0FFFFH->AX, 是AX所以成立则一个字全1 
 MOV	BX, NUM2  LT  NUM1	    ;0→BX
```



## 3. 标号、变量与地址表达式
### (1) 标号
标号是一条**指令语句的符号地址**。在汇编源程序中，只**有在需要转向一条指令语句时，才为该指令语句设置标号**，以便在转移类指令（含子程序调用指令）中直接引用这个标号。因此，**标号可作为转移类指令的操作数**，即转移地址。
- `NEAR` (近程）类型标号表示**段内标号**。需要用2字节（16位方式）或者4字节（32位方式）给出标号所在的段内 `EA` 。
- `FAR` (远程）类型标号表示段间标号。需要用2字节（16位方式）或者4字节（32位方式）给出标号所在的段地址以及 `EA` 。
### (2) 变量
 变量是**内存中一个数据区**的名字，作为**指令的存储器操作数**来使用。具有三种属性：`段地址, EA和类型` 。`EA` 是汇编时汇编地址计数器 `LC` 的值。变量的类型有：`DB,DW,DD,DQ` 和 `DT` 。例如：

```clike
COUNT DB 5        ;定义变量COUNT类型是字节。
VAR  DB 'A' , 'B' ;定义字符AB的ASCII码
MOV AL, VAR       ;语句正确，AL和VAR类型相符
MOV EAX, VAR      ;VAR和EAX类型不符
```

### (3) 地址表达式
汇编语句的地址表达式**形成的结果是存储器的地址**，用来表示指令中的**标号或者变量操作数**，有三个属性：`段地址，EA和类型` 。

变量**仅对应于**数据区的**第一个数据项**，如果对其他数据项操作，必须要用地址表达式指出**哪那一个数据项是指令的操作数**。
  
例如：`ARRAY DD 2,0,0,2,6,1,8,9,40,4` 定义10个双字(4个字节)类型的数据。
```clike
MOV  EAX, ARRAY + 36 ;取第10 个元素
MOV  ESI, 36         ;第10个元素的地址偏移量送ESI
SUB  ESI, 4          ;ESI – 4 ->ESI
ADD  EAX, ARRAY[ESI] ;EA=ARRAY+ESI, EAX与第9个元素相加 
```
---
## 4. 特殊运算符
### (1) 属性替换运算符
#### 1) 强制类型转换PTR运算符
格式：`类型   PTR   地址表达式`

`PTR` 与 `EQU` 连用，可定义与 `PTR` 右边**地址表达式类型不同**的**新变量名或新标号**，但不另分配存储单元。
例如:

```clike
NBYTE  DB 0,2,4,6,8           ;定义NBYTE为字节型变量
MOV    AX, WORD PTR NBYTE     ;字节变量临时作字使用
MOV    AL, NBYTE 	          ;显式类型为字节由DB定义
MOV    CH, NBYTE + 4          ;隐式类型，NBYTE + 4 伪字节
MOV    WORD PTR [BX], 5       ;PTR强制说明模糊型为字类型
MOV    AX, [SI + 8]           ;两个操作数中以确定的类型为准
```

#### 2) 段地址取代运算符“:” 
又称为**段地址运算**或者**跨段前缀**。用于临时给定变量，标号或者地址表达式**指定一个段属性**，地址表达式EA和类型保持不变。**在指令中替代默认的段以形成物理地址**。
例如:

```clike
MOV  DX, ES:[BX + DI]	;EA = BX +DI, 临时替换默认的DS 
```

#### 3) 短取代运算符SHORT 
  告诉汇编程序，**目标标号**在本条指令的 `-128~+127` 个字节的范围内，生成节省一个字节的机器指令。**一般情况下可以不用**。例如:
```clike
JMP SHORT NEXTBRACH
     ...
NEXTBRACH: MOV EAX,ECX
```

#### 4) 定义类型运算符THIS 
与 `PTR` 类似，用于建立**同一地址而类型不同**的变量或者标号，方便**按照不同类型存取变量**或程序发生转移。不分配存储单元，**标号或变量的段属性为语句所在段的段地址**，EA是该语句所在的**下一个可用的存储单元地址**。
例如:

```clike
BYTE_VAR EQU THIS BYTE ;定义BYTE_VAR为字节
WORD_VAR DW  8800H
MOV AL, BYTE_VAR       ;BYTE_VAR地址同WORD_VAR, AL=00H
MOV AX, WORD_VAR       ;AX=8800H
```

### (2) 属性分离运算符
`SEG` 分离出其后变量或标号**所在段的段首址**；`OFFSET` 分离出**其后变量或标号的偏移地址**。例如:
```clike
ARRAYW   DW   20 DUP(0)
...
START: 
	MOV  AX, SEG ARRAYW    ;ARRAYW段址→AX
    MOV  DS, AX
    MOV  BX, OFFSET ARRAYW ;ARRAYW的EA→BX
```

`TYPE` 运算符：
- 格式：`TYPE  变量或标号`
-  功能：分离出其后**变量或标号的类型**。如果是变量，将返回**该变量的类型对应字节数**；如果是标号，则返回**代表标号类型的数值**。
### (3) 返回值运算符
#### 1) LENGTH运算符
格式：`LENGTH  变量`
功能：取出变量所含的**数据存储单元个数**。 

例 取出变量占存储单元个数。

```clike
DATA SEGMENT
     A DB 'ABCDEF'
     B DW 10 DUP(1, 2DUP(2))
     C DB 4, 20 DUP（0）
DATA ENDS
...
MOV	AX, LENGTH  A	;1→AX ;A代表'A'的地址
MOV	BX, LENGTH	B	;10→BX
MOV	CX, LENGTH	C	;1→CX	
```
#### 2) SIZE运算符
格式：`SIZE   变量`
功能：取出**变量**所含的**数据存储区大小**。其返回值为: `LENGTH  变量 * TYPE  变量` 。
例如：上例中 `A、B、C` 三变量:
```clike
SIZE A = LENGTH A*TYPE A = 1
SIZE B = LENGTH B*TYPE B = 20
SIZE C = LENGTH C*TYPE C = 1
```

#### 3) 动态求数据项的个数
对**字符串变量**求数据项的个数，或者表达式有**多个DUP项嵌套**，或者**表达式没有DUP项**时，使用 `SIZE` 达不到取数据项的个数的目的。在程序中使用 `$` 符号来代表汇编程序**下一个可用偏移值**，来达到**动态求数据项的个数**的目的。
例如：

```clike
STRING  DB 'Advance assembly'
COUNT   EQU $ - STRING    ;COUNT = 16
```

#### 4) 字节分离运算符
字节分离运算符包括：`HIGH` 和 `LOW` 。
格式：`HIGH  常量或地址表达式` 或者 `LOW  常量或地址表达式`
功能：`HIGH` 用来分离出其后**16位常量或地址表达式**的**偏移量的高字节**；`LOW` 用来分离出其后16位常量或地址表达式偏移量的**低字节**。 
  
 例如:
```clike
WVAL EQU  0CA19H
MOV  AH, HIGH 8162H  ;取高位字节81H→AH
MOV  AL, LOW  WVAL   ;取低位字节19H→AL
```

## 4. 运算符的优先级
<img src="https://img-blog.csdnimg.cn/20200516135726413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">

---
# 二、汇编伪指令语句
伪指令语句格式如下：`[名字]   伪指令符   [参数，…参数]  [;注释]`
- 名字：符号名是伪指令语句的一个**可选项**。
- 伪指令符：伪指令符指定汇编程序要完成的**具体操作**，如数据定义伪指令`DB、DW、DD`，段定义伪指令 `SEGMENT` ，假定伪指令 `ASSUME` 等。
- 参数表：伪指令后面的**操作数**可以是**常数、字符串、变量、表达式**等，其个数由具体的伪指令决定，各个操作数之间必须以“逗号”分隔。
- 注释：伪指令的注释必须以“;”开始，其作用**同指令语句中的注释部分**。 

## 1. 方式伪指令
32位pc系列微机有386、486、Pentium等多种CPU，也就有多种指令系统。这些指令虽然**向上兼容**，却是**不断进行扩充的**，增加了许多**功能丰富的新指令**。为了告诉汇编程序怎样进行汇编，识别哪种类型的CPU指令系统，以保证扩充功能的指令能够正确汇编，于是**采用方式伪指令**来指定具体的指令系统。

如果没有指定，则 `masm` 默认的是：`8086/8088 cpu` 和 `8087` 协处理器的指令系统以及浮点变量的 `IEEE` 格式。
    
方式伪指令主要有:
- `.8086   .386   .386P  .486   .486P`
- `.586    .686   .MMX`  等。
 
例如：

```clike
.386
CODES  SEGMENT 'CODE'    ;设置Pentium兼容的32位386方式
       ...
CODES   ENDS
```

## 2. 数据与符号定义伪指令
### (1) 定义符号伪指令
格式：`符号名 EQU 表达式`
功能：为**常量、表达式及其他各种符号**定义一个**等价的符号名**，但它不申请存储单元。
- 用符号表示常量、数值表达式，即定义符号常量。使用符号常量可使程序简单明了，增强程序的可读性和通用性。
- `EQU` 与属性运算符 `PTR` 或 `THIS` 联合使用，可以给**变量或标号**定义**新的类型属性**并重新命名，但保持其段偏移地址属性不变。
- 利用 `EQU` 可以用**一个符号名**替代**一个复杂的地址表达式**和其他一些符号，如指令助记符、变量名、标号、**段名、寄存器名**、宏定义名等。 

格式：`符号名 = 表达式`
功能：为常量、表达式及其他各种符号定义一个等价的符号名，**并能对所定义的符号多次重复定义，且以最后一次定义的值为准**。
【例】定义等价符号名。

```clike
    ...
COST = 20
M = ABC
COST = COST+10	;30→COST
M= EFG	        ;M=EFG
    ...
```

格式：`变量名或标号 LABEL 类型`
功能：定义**与原有变量类型不同的新变量**，或为指令语句**定义有指定类型的标号**。通常与数据定义伪指令连用，其功能类似语句 `变量名或标号 EQU THIS 类型` 。
例 定义新类型的变量。

```clike
     ...
DDBUF LABEL DWORD
BUF	DB 200 DUP（0）
     ...　
A  LABEL FAR
B: LEA	 DX, BUF
     ...
```

### (2) 程序模块名与结束语句
为了提供模块程序的设计功能，汇编语言提供了**划分模块并命名**的能力。
#### 1) 模块命名语句NAME
格式：`NAME [模块名]`
**源程序模块开始**的一个语句，有模块名则为模块的名字，**名字不要使用程序的变量、标号和保留字**。`NAME` 语句在原程序中也可以不必写出。

#### 2) 源程序模块结束语句 END
格式：`END  [表达式]`
**源程序模块的最后**一个语句。如果有表达式的值，则为程序开始执行目标代码的地址。汇编结束后，指令指针 `IP` 或 `EIP` 指向这个入口地址。 例如:
```clike
NAME Pentium_MASM61X
CODES SEGMENT
START: ...
       ...
CODE ENDS
END START
```

### (3) 数据定义以及存储分配伪指令
常用的数据定义伪指令有 `DB` (8位），`DW`（16位），`DD`（32位），`DQ`（64位），`DT`（80位）。
格式：`[变量名]   数据定义伪指令 表达式[, 表达式]`
功能：**定义数据存储区**，类型由数据定义伪指令确定，初值由表达式给定。表达式可以有以下几种类型:
- 数值表达式
- `?` 定义的数据项**没有确定的初值**，**只分配存储单元**
- ASCII字符串：**多于2个以上字符的字符串**可以用 `DB` 来定义
- `n  DUP(?)` ：重复定义 `n` 个数据项，**内容不确定**
- `n DUP(表达式[, 表达式, ... ])` ：定义 `n` 个数据项，内容**由表达式确定**
- `n DUP(m DUP(表达式1), 表达式2)` ：多层嵌套DUP项（共有 `n*(m + 1)` 项)，初始值**由表达式决定**。

例如：
```clike
VARN DB 88                         ;定义一个字节88H 
VARM DW 60 * 60                    ;定义一个双字3600
STR DW 'AB'                        ;定义一个双字‘AB’
ERROR DB 'syntax  error !', 13, 10 ;定义一个字符串和数字
TABB DB 2 DUP(3 DUP(8), 'A')       ;定义2个字符串，每个字符串3个8和一个‘A’
```

## 3. 段定义与段管理伪指令SEGMENT/ENDS
### (1) 定义段语句SEGMENT和ENDS
格式：`段名  SEGMENT  [使用类型] [边界类型][连接类型]['类别']`
段名是**为该段起的名字**，用来指出汇编程序**为该段分配的存储区起始位置**。

① 使用类型：  只有使用了 `.386` 等方式伪指令，**使用类型**才有用。有两种类型:
   - `USE16`——该段**按照 `16` 位寻址**，与**8088寻址方式**相同 ;
- `USE32`——该段**按照 `32` 位寻址**，`地址指针48位 : 段地址16位`，EA32位 

若在段定义时**没有给出使用类型**，使用了 `.386` 后默认的是 `USE32`。

② 边界类型
- `PARA` ：表示本段必须从**能被16整除的地址处**开始存放，即**段起始地址最低四位必须是0**，称为节地址。
- `BYTE` ：表示本段起始地址**可以从任一地址处开始存放**。
- `WORD` ：表示本段要**从一个偶数地址处**开始存放，即段起始地址的**最低一位必须是0**，称为字地址。
- `DWORD` ：表示本段要**从一个4的倍数地址处**开始存放，即段起始地址的**最低两位必须是0**，双字地址，常用于 `32` 位寻址。
- `PAGE` ：表示本段要从**能被256整除的地址处**开始存放，即起始地址的**最低八位必须是0**，称为页地址。

③ 连接类型：组合方式有六种类型可供选择。 
- 无：省略连接类型。本段**有自己的段地址**，**与其他同名段独立**。
- `PUBLIC` ：**同名同类**段连接。程序连接时将**本段与其他同名同类型**（可以包括不同的模块）**的段连接在一起**，组成同一个物理段，**具有同一个段地址**。
- `STACK` ：指定堆栈段。Link程序**连接后的段为堆栈段**，与PUBLIC处理相同。
- `COMMON` ：指明覆盖段。连接时产生一个覆盖段，**类别相同的同名段**有**相同的起始段地址**，段的长度选取含 `COMMON` 段的**最大长度**。
- `MEMORY` ：指定存储方式段。
- `AT表达式` ：指定**段地址值表达式**。将给定表达式的值**作为16位寻址**的**非代码段的段地址值**，可作为变量赋予绝对地址。

④  `'类别'` 说明：定义逻辑段时**若类别选择项缺省**，则表明该类别为空。如果有 `'类别'` 说明，则**必须用单引号将类别括起来**，类别是任何合法的名字。连接时，LINK程序将**类别名相同的段依次连续存放在内存**中。

### (2) 置汇编计数器语句ORG
格式：`ORG  数值表达式`
功能：将**数值表达式的值**赋给**汇编地址计数器**。数值表达式的值须为 `0~65545` 之间的**非负整数**。
例 给汇编地址计数器赋值。

```clike
DATA SEGMENT              ;ORG可以修改当前地址
     ORG  10	          ;置$值为10, 最前面的10个字节都是空的
     VAR1 DW  100H, 200H  ;VAR1偏移地址为10,10+2+2=14
     ORG  $+5	          ;置$的值为14+5，即为19
     VAR2 DB 1, 2, $+1, $+2 ;1的偏移地址为19, $+2偏移地址为22
     N    EQU $-VAR2	  ;($)=23, N=23-19=4
DATA ENDS
```

### (3) 指示段寄存器语句（假定语句）ASSUME
格式：`ASSUME  段寄存器:段名 [, 段寄存器:段名]`
功能：建立**段寄存器与段之间的对应关系**。该伪指令**一般出现在代码段中**。

例如：用 `ASSUME` 伪指令建立代码段、堆栈段与CS和SS的对应关系。
```clike
DATA	SEGMENT
        A	DB  1, 2, 4
DATA	ENDS

STACK   SEGMENT  STACK
        DB	200 DUP（0）
STACK	ENDS

CODE SEGMENT 
	ASSUME  SS:STACK, DS:DATA
	...
CODE ENDS
```

### (4) 段组语句GROUP
格式：`GROUP  段名 [, …]`
功能：`GROUP` 伪指令可以**把模块中若干不同的段集合成一个组**，并赋予一个组名，**使它们都装在同一个物理段**(64KB)**中**。

```clike
DATA1  SEGMENT  WORD PUBLIC  ‘DATA’
     VAR1   DW       10 DUP(?)
...
CGROUP  GROUP DATA1, DATA2
     ASSUME   DS:CGROUP, CS:CODES
...
START: MOV  AX, CGROUP
       MOV  DS, AX
...
```

 


