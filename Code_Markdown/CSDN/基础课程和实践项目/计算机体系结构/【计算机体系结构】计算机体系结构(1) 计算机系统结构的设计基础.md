@[toc]

世界上第一台通用**电子数字计算机** `Electronic Numerical Integrator
And Computer，ENIAC`，于1946年在美国宾夕法尼亚大学建成。由于 `ENIAC` 输入和更换程序特别繁杂，`ENIAC` 课题组的顾问、著名数学家冯·诺依曼提出「**将程序的指令与指令所操作的数据一起存于存储器**」的概念。这个著名的存储式程序 `stored-program` 概念，成为计算机工作的基本机理。这一概念也被图灵大约同时期提出。

世界上第一台**存储式程序计算机**是1949年在英国剑桥大学建成的 `Electronic Delay Storage Automatic Calculator, EDSAC` 计算机，它使用 $3 000$ 只电子管，每秒钟能完成 $700$ 次加法运算。1953年IBM公司制造出第一台**电子存储式程序的商用计算机**。

50 多年来，计算机系统性能得到了大幅度地提高，价格却大幅度地下降。计算机的发展已经历了四次更新换代，现在正处于第五代。依据半导体技术发展水平，这五代划分应该是：
- 第一代：1945～1954 年，电子管和继电器；
- 第二代：1955～1964 年，晶体管和磁芯存储器；
- 第三代：1965～1974 年，中、小规模集成电路 `MSI-SSl` ；
- 第四代：1975～1990 年，`LSI/VLSI` 和半导体存储器；
- 第五代：1990 年至今，`ULSI/GSI (Giga-Scale Integration)` 巨大规模集成电路。

计算机系统更新换代的标志主要是两个方面，一是**由于器件不断发展，计算机系统的工作速度、功能、集成度和可靠性等指标不断提高，价格不断降低**；二是**计算机系统结构的改进**。有人统计在1965年到1975年期间，计算机系统性能提高近 $100$ 倍，其中由于器件性能提高使其性能增加 $10$ 倍，而另外的 $10$ 倍主要归功于系统结构改进——==在50多年的发展进程中，器件在技术上的改进是比较稳定的，而系统结构的改进则有较大起伏==。特别是近20年来，由于计算机系统的设计对集成电路技术的依赖性大为增加，从而使得在这一期间内，各类不同的计算机系统的性能增长率有了差异。
- 巨型机的性能增长得益于器件技术和系统结构两方面的改进；
- 大型机的性能增长则主要靠器件工艺上的改进，因为系统结构方面的改进没有新的突破；
- 小型机的发展，一方面是由于计算机实现方法有了较大的改进，另一方面是因为采用了许多大型机中行之有效的先进技术。
然而这三类计算机，在1970年到1990年期间，每年计算机的性能平均增长率均只在 $18\%$ 左右。
与之形成明显对照的是，微型计算机的性能增长非常快，每年的平均增长率约为 $35\%$ ，这是因为微型计算机能从「集成电路技术的进展中」得到最为直接的好处。==自20世纪80年代起，**微处理机技术**实际上已成为新系统结构和老系统结构更新时，所选用的主要技术==。

自1985年开始，一种具有新颖设计风格的系统结构，即 **`RISC` 技术的系统结构**，为计算机工业界所青睐。==它将「集成电路技术进展」、「编译技术改进」和「新的系统结构设计思想」这三者有机地结合起来，从而使这种风格设计的计算机系统的性能，以每年增长一倍的高速率加以改进==。应该指出的是，这种改进的基础是通过「对以往计算机如何被使用的模拟实验数据」，进行定量分析后获得的。有的学者将这种设计风格称为**定量分析的计算机系统结构设计风格**，显然这比传统的定性设计风格要精确得多，开发 `RISC` 技术的两位先驱者，美国加州大学伯克莱分校的 `D. Patterson` 教授和斯坦福大学的 `J .Hennessy` 教授，是这种定量分析设计方法的主要倡导者。

# 1.1 计算机系统结构的基本概念
## 1.1.1 计算机系统的层次结构
==现代通用计算机系统是由硬件和软件组成的一个复杂系统，按其功能可划分为**多级层次结构**==，如图1.1所示。层次结构由上往下依次为应用语言机器级、高级语言机器级、汇编语言机器级、操作系统机器级、传统机器级和微程序机器级。对于一个具体的计算机系统，层次的多少会有所不同。

**各机器级的实现主要靠翻译或解释，或者是这两者的结合**：
- **翻译** `Translation` 是先用转换程序将上一级机器级上的程序，整个地变换成下一级机器级上可运行的等效程序，然后再在下一级机器级上去实现的技术。
- **解释** `Interpretation` 则是在下一级机器级上用它的一串语句或指令，仿真上一级机器级上的一条语句或指令的功能，通过对上一级机器语言程序中的每条语句或指令逐条解释来实现的技术。

简要介绍各个层次如下：
- **应用语言机器级**是为了满足信息管理、人工智能、图像处理、辅助设计等专门的应用来设计的。使用**面向某种应用环境的应用语言** `L5` 编写的程序，一般是经**应用程序包**翻译成**高级语言** `L4` 程序后，再逐级向下实现的。
- **高级语言机器级**上的程序，可以先用**编译程序**整个地翻译成**汇编语言** `L3` 程序或**机器语言** `L1` 程序，再逐级或越级向下实现，也可以用汇编语言 `L3` 程序、机器语言 `L1` 程序，甚至**微指令语言** `L0` 程序解释实现。
- **汇编语言级**上的汇编语言 `L3` 源程序，则先用**汇编程序**，将其整个变换成等效的二进制机器语言 `L1` 目标程序，再在传统机器级上实现。
- **操作系统程序**虽然已发展成用高级语言（如面向编写操作系统软件的C语言）编写，但最终还是要用**机器语言程序**或**微指令程序**来**解释**的。==它提供了传统机器级所没有，但为汇编语言和高级语言使用和实现所用的基本操作、命令和数据结构，例如，处理机管理、进程管理、文件管理、存储管理、设备管理、多道程序共行、多重处理、作业控制等所用到的操作命令、语句和数据结构等==。因此，操作系统机器级放在传统机器级和汇编语言机器级之间是适宜的。
- **传统机器级**采用**组合逻辑电路**控制，其指令可直接用**硬件**来实现，也可以采用**微程序**控制，用微指令 `L0` 程序来解释实现。
- **微指令直接控制硬件电路的动作**。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dl46Fo59-1644076074317)(https：//img-blog.csdnimg.cn/abd60653e3fc441fa9057badf8b1d794.png)]

就目前的状况来看，第 $0$ 级用硬件实现，第 1 级用微程序（固件）实现，第 $2$ 级到第 $5$ 级大多用软件实现。我们称**以软件为主实现的机器为虚拟机器**，以区别于由**硬件或固件实现的实际机器**。虚拟机器不一定全都由软件实现，有些操作可以用固件或硬件实现。如操作系统中的某些命令可由比它低两级的微程序解释，或全部用硬件来实现；高级语言机器则直接用微程序解释或用硬件实现，没有编译软件。

计算机系统结构作为一门学科，主要研究**软件、硬件功能分配**和**对软件、硬件界面的确定**，即==哪些功能由软件完成，哪些功能由硬件完成==。采用何种实现方式，要从整个计算机系统的效率、速度、价格、资源状况等方面考虑，**对软件、硬件、固件取舍进行综合平衡**——**软件和硬件在逻辑功能上是等效的**。原理上，软件实现的功能完全可以用硬件或固件完成，硬件实现的功能也可以由软件的模拟来完成，只是其性能、价格、实现的难易程度等有所不同。具有相同功能的计算机系统，其软、硬件功能分配比例可以在很宽的范围内变化。

## 1.1.2 计算机系统结构
“计算机系统结构”这个名词来源于英文 `Computer Architecture` ，也有译成“计算机体系结构”的。`architecture` 这个词原来用于建筑领域，其意义是“建筑学”、“建筑物的设计或式样”，它是指一个系统的外貌。20世纪60年代这个名词被引入计算机领域，“计算机系统结构”一词已经得到普遍应用，**它研究的内容不但涉及计算机硬件，也涉及计算机软件**，已成为一门学科。但对“计算机系统结构”一词的含义仍有多种说法，并无统一的定义。

**计算机系统结构**这个词是 `Amdahl` 等人在1964年提出的。他们把系统结构定义为==由程序设计者所看到的一个计算机系统的属性，即**概念性结构**和**功能特性**==。这实际上是**计算机系统的外特性**。按照计算机层次结构，**不同程序设计者所看到的计算机有不同的属性**。例 如：
- 对于使用FORTRAN高级语言程序员来讲，一台IBM3090大型机、一台VAX11/780小型机或一台PC微型机，看起来都是一样的，因为在这三台计算机上运行他所编制的程序，所得到的结果是一样的。
- 但对于使用汇编语言程序的程序员来讲，由于这三台机器的汇编语言指令完全不一样，他所面对的计算机的属性就也会不一样。
- 另外，==即使对同一台机器来讲，处在不同级别的程序员，例如应用程序员、高级语言程序员、系统程序员和汇编程序员，他们所看到的计算机外特性也是完全不一样的==。

那么通常所讲的「**计算机系统结构的外特性**」，应该是处在哪一级的程序员所看到的外特性呢？比较一致的看法，是**机器语言程序员或编译程序编写者所看到的外特性**，这种外特性是指由他们所看到的计算机基本属性，即==计算机的概念性结构和功能特性，这是机器语言程序员或编译程序编写者，为使其所编写、设计或生成的程序，能在机器上正确运行所必须遵循的==。由机器语言程序员或编译程序编写者，所看到的计算机的基本属性，是指**传统机器级的系统结构**；在传统机器级之上的功能被视为属于**软件功能**，而在其之下的则属于**硬件和固件功能**。因此，==计算机系统的概念性结构和功能属性，实际上是**计算机系统中软、硬件之间的界面**==。

==在计算机技术中，一种本来是存在的事物或属性，但从某种角度看似乎不存在，称为**透明性现象**==。通常，在一个计算机系统中，**低层机器级的概念性结构和功能特性，对高级语言程序员来说是透明的**。由此看出，在层次结构的各个级上都有它的系统结构。

就目前的通用机来说，**计算机系统结构的属性**应包括以下几个方面：
- 「硬件能直接识别和处理的数据类型和格式」等的**数据表示**；
- 最小可寻址单位、寻址种类、地址计算等的**寻址**方式；
- 通用/专用寄存器的设置、数量、字长、使用约定等的**寄存器组织**；
- 二进制或汇编级指令的操作类型、格式、排序方式、控制机构等的**指令系统**；
- 内存的最小编址单位、编址方式、容量、最大可编址空间等的**存储系统组织**；
- 中断的分类与分级、中断处理程序功能及入口地址等的**中断机构**；
- 系统机器级的**管态和用户态的定义和切换**；
- 输入/出设备的连接、使用方式、流量、操作结束、出错指示等的**机器级 I/O 结构**；
- 各部分的**信息保护方式和保护机构**等。


## 1.1.3 计算机组成与实现
**计算机组成** `Computer Organization` 指的是**计算机系统结构的逻辑实现**，也常称为**计算机组织**。它==包括机器级内的数据流、控制流的组成以及逻辑设计等，着眼于机器级内各事件的排序方式与控制机构、各部件的功能及各部件间的联系==。计算机组成设计要解决的问题是==在所希望达到的性能和价格下，怎样**最佳、最合理地**把各种设备和部件组织成计算机，以实现所确定的系统结构==。计算机组成设计主要是围绕提高速度，着重从**提高操作的并行度、重叠度**以及**分散功能**和**设置专用功能部件**来进行的。

计算机组成设计要确定的方面一般应包括：
- **数据通路宽度**（在数据总线上一次并行传送的信息位数多少）；
- **专用部件的设置**（设置哪些专用部件，如乘除法专用部件、浮点运算部件、字符处理部件、地址运算部件等，每种专用部件设置的数量等，这些都与机器所需达到的速度、专用部件的使用频度高低及允许的价格等有关）；
- **各种操作对部件的共享程度**（共享程度高，即使操作在逻辑上不相关也只能分时使用，限制了速度，但价格便宜；可以设置多个部件降低共享程度，提高操作并行度来提高速度，但价格也将提高）；
- **功能部件的并行度**（功能部件的控制和处理方式是采用顺序串行，还是采用重叠、流水或分布处理）；
- **控制机构的组成方式**（事件、操作的排序机构是采用硬联控制还是用微程序控制，是采用单机处理还是用多机处理或功能分布处理）；
- **缓冲和排队技术**（在不同部件之间怎样设置及设置多大容量的缓冲器来弥补它们的速度差异；是采用随机方式，还是先进先出、先进后出、优先级或循环方式来安排等待处理事件的先后顺序）；
- **预估、预判技术**（为优化性能和优化处理，采用什么原则来预测未来的行为）；
- **可靠性技术**（采用什么样的冗余技术和容错技术来提高可靠性）

**计算机实现** `Computer Implementation` 指的是**计算机组成的物理实现**。它包括处理机、主存等部件的物理结构，器件的集成度、速度和信号，器件、模块、插件、底板的划分与连接，专用器件的设计，电源、冷却、装配等技术。

**计算机系统结构、计算机组成和计算机实现是三个不同的概念**。==计算机系统结构是指令系统及其执行模型；计算机组成是计算机系统结构的逻辑实现； 计算机实现是计算机组成的物理实现==。它们各自包含不同的内容和采用不同的技术，但又有紧密的联系。在学习和理解时有两点需要注意：
- 一是计算机系统结构、组成和实现之间的界限变得越来越模糊了。尤其是**严格区分计算机系统结构和组成已不太可能，也没有太大的实际意义**。
随着 `VLSI` 技术的进步，新器件的不断涌现，当今计算机系统结构的设计所面临的问题与 `Amdahl` 所处的时期大不相同，就是与10年前也大不相同。例如，10年前系统配置几十至几百KB的内存就很不错了，某些指令系统的设计中，甚至有对存储器操作数直接进行加减的指令，不惜牺牲执行速度来珍惜宝贵、有限的内存资源。
现在，存储器芯片的集成度大幅度提高、价格急剧下降，内存容量已不是计算机系统结构设计的主要问题了。如何组织存储器以提高存取速度，如何保证CPU—内存之间的通道不致成为系统性能的瓶颈，是当代计算机系统结构设计必须考虑的问题。现在，**一般已将功能模块设计移入计算机系统结构考察的范畴之内**。
- 二是我们介绍了计算机系统结构、组成和实现三者之间的关系，但**不要认为计算机系统结构设计就是硬件设计，两者不能混淆**。操作系统、编译程序以及高级语言的发展，都对计算机系统结构的设计有重要影响。==计算机系统结构设计是在功能这一层次上考虑问题，当然要涉及到硬件，但它不是只包括硬件设计==。例如，存储器管理功能可以由硬件和软件共同实现，它们之间的分工取决于当前硬件和软件的可用性、性能和价格——在 `VLSI` 发展的初期，存储器管理功能一般由软件实现； 现在的存储器控制芯片，已能实现这些存储器管理算法，并维护存储器与高速缓存的一致性。因此，==**计算机系统结构设计的一个主要任务**是研究软件、硬件功能分配和对软件、硬件界面的确定==。

## 1.1.4 计算机系统结构的分类
研究计算机系统的分类方法，有助于认识计算机系统结构的组成和特点，理解计算机系统的工作原理和性能。常用的计算机系统结构分类方法有三种：
### 1. `Flynn` 分类法
1966年 `M. J. Flynn` 提出了按照**指令流和数据流的多倍性概念**进行分类的方法，其定义如下：
- **指令流** `instruction stream` ———机器执行的指令序列。
- **数据流** `data stream` ———由指令流调用的数据序列，包括输入数据和中间结果。
- **多倍性** `multiplicity` ———==在系统最受限制的部件（瓶颈）上，同时处于同一执行阶段的、**可并行执行的指令或数据的最大可能个数**==。

按照指令流和数据流的不同组织方式，把计算机系统的结构分为以下四类：
- 单指令流单数据流 `Single Instruction stream Single Data stream, SISD`；
- 单指令流多数据流 `Single Instruction stream Multiple Data stream, SIMD` ；
- 多指令流单数据流 `Muhiple Instruction stream Single Data stream, MISD` ；
- 多指令流多数据流 `Muhiple Instruction stream Multiple Data stream, MIMD` 。

对应于这四类计算机的基本结构框图，如图1.2所示。`SISD` 是传统的**顺序处理计算机**。`SIMD` 以**阵列处理机或并行处理机**为代表。`MISD` 在实际上代表何种计算机，也存在着不同的看法，有的文献把**流水线结构机器**看做是 `MISD` 结构，**多处理机**属于 `MIMD` 结构。
![在这里插入图片描述](https://img-blog.csdnimg.cn/032eca4c29ea4baab77b201e9a72400a.png)

### 2. 冯氏分类法
1972年美籍华人冯泽云 `Tse-yun Feng` 教授，提出了用最大并行度 `Pm` 来定量描述各种计算机系统特性的**冯氏分类法**。**最大并行度** `Pm` 的定义为：**计算机系统在单位时间内能够处理的最大的二进制位数**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/7ab1289c142e44919fd60bceb7b2e843.png)

图1.3描述了用最大并行度对计算机系统分类的方法。用平面直角坐标系中的一个点代表一个计算机系统，横坐标代表字宽 $n$ 位，即在**一个字**中同时处理的二进制位数；纵坐标代表位片宽度 $m$ 位，即在**一个位片**中能同时处理的字数。

 
由图1.3可得出四类不同处理方法的计算机系统结构：
- **字串位串** `Word Serial and Bit Serial, WSBS` ，其中 $n = 1, m = 1$ 。这是**第一代计算机发展初期的纯串行计算机**。
- **字并位串** `Word Parallel and Bit Serial, WPBS` ，其中 $n > 1, m = 1$ 。这是**传统并行单处理机**。
- **字串位并** `Word Serial and Bit Parallel, WSBP` ，其中 $n = 1, m > 1$ 。`STARAN, MPP, DAP` 属于这种结构。
- **字并位并** `Word Parallel and Bit Parallel, WPBP` ，其中 $n > 1, m > 1$ 。`PEPE, ILLIAC Ⅳ, Cmmp` 属于这种结构。

### 3. `Handler` 分类法
1977年 `Wolfgan Handler` 根据**并行度和流水线**提出了另一种分类法。这种分类方法把计算机的硬件结构分成三个层次，并分别考虑它们的**可并行-流水处理程度**。这三个层次是：
① 程序控制部件 `PCU` 的个数 $k$ ；
② 算术逻辑部件 `ALU` 或处理部件 `PE` 的个数 $d$ ；
③ 每个算术逻辑部件包含基本逻辑线路 `ELC` 的套数 $w$ 。

这样我们可以把一个计算机系统的结构用如下公式表示：`t(系统型号) = (k, d, w)` 。为了进一步揭示流水线的特殊性，一个计算机系统的结构可用如下公式表示：`t(系统型号) = (k×k′, d×d′, w×w′)` ，其中 `k′` 表示宏流水线中程序控制部件的个数，`d′` 表示指令流水线中算术逻辑部件的个数，`w′` 表示操作流水线中基本逻辑线路的套数。

例如，`Crayl` 有 $1$ 个CPU，$12$ 个相当于 `ALU` 或 `PE` 的处理部件，可以最多实现 $8$ 级流水线。字长为 $64$ 位，可以实现 $1～14$ 位流水线处理。所以 `Crayl` 的系统结构可表示为：
$$t(Crayl) = (1,\ 12×8,\ 64( 1～14) )$$

下面是用这种分类法的例子：
$$\begin{aligned}
&t( PDP11 ) = ( 1,\ 1,\ 16 ) \\
&t( ILLIAC Ⅳ) = (1,\ 64,\ 64 ) \\
&t( STA RAN) = (1,\ 8192,\ 1) \\
&t(Cmmp) = (16,\ 1,\ 16 )\\
&t( PEPE) = ( 1×3,\ 288,\ 32) \\
&t( TIASC) = ( 1,\ 4,\ 64×8) \end{aligned}$$

---
# 1.2 计算机系统设计技术
## 1.2.1 计算机系统设计原理
下面介绍计算机系统设计中**经常用到的几个定量原理**。

### 1. 加快经常性事件的速度 `Make the Common Case Fast`
这是计算机设计中**最重要也最广泛采用的设计准则**。使经常性事件的处理速度加快，能明显提高整个系统的性能。一般说来，经常性事件的处理比较简单，因此比不经常出现的事件处理要快。例如，在CPU中两个数进行相加运算时，相加结果可能出现溢出现象，也可能无溢出发生，显然经常出现的事件是不发生溢出的情况，而溢出是偶然发生的事件。因此，==在设计时应优化不发生溢出的情况，使这个经常性事件的处理速度尽可能快，而对溢出处理则不必过多考虑优化==。因为发生溢出的概率很小，即使发生了，处理得慢一些也不会对系统性能产生很大的影响。

在计算机设计中经常会遇到上述情况，那么，==**如何确定经常性事件**以及**如何加快处理它**，这就是下面介绍的 `Amdahl` 定律要解决的问题==。

### 2. `Amdahl` 定律
`Amdahl` 定律：==系统中对某一部件采用某种更快的执行方式后，整个系统性能的改进程度，取决于「这种执行方式被使用的频率」或「所占总执行时间的比例」==。
$$系统加速比 \\ {} \\ =\displaystyle \dfrac{系统改进后的性能}{系统改进前的性能} \\ {} \\=\dfrac{ 系统改进前执行某一任务的总时间} {系统改进后执行同一任务的总时间}$$

`Amdahl` 定律定义了**改进（加速）某部分功能后，可获得的性能改进或执行时间的加速比**。系统加速比取决于两个因素：
1. **可改进部分在原系统计算时间中所占的比例**。例如，一个需运行 $60s$ 的程序中，有 $20s$ 的运算可以加速，那么该比例就是 $\dfrac{20}{60}$。这个值用“**可改进比例**”表示，它总是小于或等于 $1$ 的。
2. **可改进部分改进以后的性能提高**。例如，系统改进后执行程序，其中可改进部分花费的时间为 $2s$ ，而改进前该部分需花费的时间为 $5s$ ，则性能提高为 $\dfrac{5}{2}$ 。用“**部件加速比**”表示性能提高比，一般情况下它是大于 1 的。

若以 $T_o$ 和 $T_e$ 分别表示采取某种改进措施前后，完成同一任务所需的总时间，用 $f_e$ 表示可改进部分的比例（$0≤ f_e≤1$），用 $r_e$ 表示采用改进措施比不采用改进措施可加快执行的倍数，则上述各参数与**系统加速比** $S_p$ 之间的关系可用如下表达式表
示：
$$T_o = T_e× (1 - f_e ) + \dfrac{f_e× T_e}{ r_e}
= [ ( 1 - f_e ) + \dfrac{f_e}{r_e} ]× T_e$$ 即部件改进后，**系统的总执行时间**等于**不可改进部分的执行时间**加上**可改进部分改进后的执行时间**。
$$S_p = \dfrac{T_e}{T_o} =\dfrac{1} {(1 - f_e ) +\dfrac{ f_e } {r_e}}$$

【例1.1】若考虑将系统中的某一功能的处理速度加快到 $10$ 倍，该功能部件的原处理时间为整个系统运行时间的 $40\%$ ，则采用改进措施后，使整个系统的性能提高了多少？
解：由题意可知：$f_e = 0 .4,\ r_e = 10$ ，由加速比公式可得
$$S_p = \dfrac{1} { (1 - 0.4) + \dfrac{0.4} {10}} = 1.56$$

### 3. 程序访问的局部性规律
所谓**程序访问的局部性**是指==程序执行中，呈现出频繁重新使用那些「最近已被使用过的数据和指令」的规律==。统计表明一个程序执行时间中的 $90\%$ 是花费在 $10\%$ 程序代码上。例如对GCC（GNU C编译）、Spice（CAD电路分析软件）以及 Tex（文本处理软件）三个典型测试程序的测试表明，相应的比例数分别为 $13\%,\ 9. 5\%, 9. 3\%$ ，遵从上述的 $90\%/10\%$ 定量规律。

程序访问局部性主要反映在**时间和空间局部性**两个方面，**时间局部性**是指==程序中近期被访的信息项很可能马上将被再次访问==； **空间局部性**是指==那些在访问地址上相邻近的信息项很可能会被一起访问==。

==程序访问局部性规律是**按层次构成存储体系**的主要依据==——程序中的大部分可放在容量较大、工作速度较慢及成本较低的慢速存储部件，而只需将其中的一小部分（如 $10\%～20\%$）存放在高速的存储部件中，这便是虚存、`Cache` 高速缓存得以实现的具体根据。

## 1.2.2 计算机系统设计的方法
### 1. 软硬件舍取的基本原则
计算机系统结构设计的一个主要任务是**进行软、硬件功能分配**。一般来说，提高硬件功能的比例可**提高解题速度，减少程序所需存储空间**，但会**提高硬件成本，降低硬件利用率和计算机系统的灵活性、适应性**； 而提高软件功能比例可降低硬件成本，提高系统的灵活性、适应性，但解题速度下降，软件设计费用和所需存储空间增加。

下面介绍**软、硬件舍取的三个基本原则**。
- 在现有硬件和器件（主要是逻辑器件和存储器件）条件下，**系统要有高的性价比**。主要从实现费用、速度和其他性能要求来综合平衡；
- 系统结构和组成的设计，尽可能地**不要过多或不合理地限制各种组成、实现技术的采用**；
- 不仅从“硬”的角度考虑，如何应用组成技术的成果、便于发挥器件技术的进展，还应从“软”的角度，把如何为编译和操作系统的实现、以及为高级语言程序的设计，提供更多更好的硬件支持。
### 2. 计算机系统设计者的主要任务
==计算机系统的设计，不仅应该关心系统结构所包含的指令系统设计，还应考虑功能的组成、逻辑设计以及具体的物理实现==，它包括了集成电路的设计、封装、电源以及冷却等。

计算机系统设计者的主要任务是：
1. **要满足用户对功能上的要求，以及相应的对价格和性能的要求**。这里功能上的要求包括：**应用领域**，如专用还是通用、科学计算或是商业上使用；**软件兼容级别**，在程序设计语言级或是目标代码 ( 二进制) 级兼容；**操作系统需求**，如地址空间的大小、存储器管理、保护及环境转换；**中断和自陷、以及对标准的要求**，如浮点标准、I/O总线标准、操作系统标准、网络标准及程序设计语言标准等。
2. **在满足功能要求基础上进行设计的优化**。优化主要是以**性能价格比**为衡量指标，**仔细考虑某一所需的功能应该用软件还是用硬件来实现**。因此，在系统设计中如何很好地平衡软、硬件两者就是特别关键的了。此外，在选择硬件或软件的方法时，还应考虑**设计复杂性**和**具体实现的难易程度**。
3. **设计应能适应日后发展趋势**。这是指，==好的系统结构设计应能经受硬件技术、软件技术以及应用需求特征的变化==。因此，设计者应对计算机使用趋势和计算机技术的发展趋势有足够的认识。
硬件技术进展表现在IC（集成电路）逻辑技术、DRAM技术及Disk（硬盘）技术。统计资料表明：一个芯片上的晶体管数大约每年增加 $25 \%$ ，因此每三年可增加 $1$ 倍；器件的开关速度增长基本类似；DRAM的密度，每年增长约 $60\%$ ，因此每三年将增长 $3$ 倍；访问存储器周期改进相应较慢，每十年约减少 $\dfrac{1}{3}$ ；硬盘密度每年增加 $25\%$ ，每三年增加 $1$ 倍，访问时间则每十年减少 $\dfrac{1}{3}$ 。
软件技术的发展趋向：**一是程序所要求的存储器空间增长**，大约每年增长 $1. 5～2$ 倍；因此相应地要求，地址位每年能增长 $0. 5$ 位到 $1$ 位；这对设计非常重要，即必须留有足够的地址空间以待扩展。**二是汇编语言将逐步为高级语言所替代，编译技术将起更大作用**，因此系统结构应能更好地支持编译要求。编译程序将逐步成为用户和计算机间的主要界面。
### 3. 计算机系统设计的基本方法
从计算机系统的多级层次结构出发，可以有“由上往下”、“由下往上”和“由中间开始”三种不同的设计思路。
- ==“由上往下”设计是先考虑如何满足应用要求，确定好面对使用者那级机器应有什么基本功能和特性==，如基本命令、指令或语言结构、数据类型以及格式等，==然后再逐级往下设计，每级都考虑怎样优化上一级实现==。这样设计的计算机系统，对于设计时所面向的应用必然是很好的。因此，**它适合于专用机设计，但不宜用于通用机的设计**。因为当应用对范围改变时，软、硬件分配会很不适应，而使系统效率急剧下降。
-  ==“由下往上”设计是不管应用要求，只根据能拿到的器件，参照或吸收已有各种机器的特点，先设计出微程序机器级（如果采用微程序控制）及传统机器级，然后再为不同应用配多种操作系统和编译系统软件，使应用人员可根据所提供的语言种类、数据形式，采用合适的算法来满足相应的应用==。这是 $20$ 世纪 $60～70$ 年代前常用的通用机设计思路。
由于是在硬件不能改变的情况下去被动设计软件，尽管某些硬件的设计不利于软件的实现，而且有时只需稍许改变或增加某些功能，就可大大简化软件的设计，也无法加以改变。因此，**在硬件技术飞速发展而软件发展相对缓慢的今天，由下往上设计难以适应系统设计要求，所以已很少使用**。
- “从中间开始设计”的“中间”指的是**层次结构中的软硬交界面**，目前多数是**在传统机器级与操作系统机器级之间**。
==进行合理的软、硬件功能分配时，既要考虑能拿到的硬、器件，又要考虑可能的应用所需的算法和数据结构，先定义好这个交界面==。确定哪些功能由硬件实现，哪些功能由软件实现，同时还要考虑好硬件对操作系统、编译系统的实现提供些什么支持。
==然后由这个中间点分别往上、往下进行软件和硬件的设计==。软件人员依次设计操作系统级、汇编语言级、高级语言级和应用语言级；硬件人员依次设计传统机器级、微程序机器级、数字逻辑级。
**软件和硬件并行设计，可缩短系统设计周期，设计过程中可交流协调，是一种交互式的、较好的设计方法**。当然，这要求设计者应同时具备丰富的软、硬、器件和应用等方面的知识。又由于软件设计周期一般比较长，为了能在硬件研制出来之前，开展软件的设计测试，还应有有效的软件设计环境和开发工具。如在某个宿主机上建立目标机的指令模拟器、系统结构分析模拟器，以及良好的调试程序、性能评价的测试程序等。

---
# 1.3 计算机系统的性能评价
==衡量计算机系统性能可有各种指标，但最为关键的是**时间**==。时间可根据计算方法予以不同的定义，如响应时间、CPU时间等。
- **响应时间**是指**在用户向计算机系统送入一个任务后，直到获得他所需要的结果所需的等待时间**，其中包括了访问磁盘和访问主存储器时间、CPU运算时间I/O动作时间，以及操作系统工作的时间开销等。
虽然**这种定义比较直观**，但对于多道程序，由于CPU可在某一程序等待 I/O操作时转去执行其他程序，**响应时间并不能区别这种情况**。
- 另一种情况是只考虑**CPU时间**，此时便可加以区别，它将**不包括等待 I/O 操作的时间，以及CPU转去运行其他程序所用的时间**。当然，CPU时间本身还可分为**用户CPU时间**和**系统CPU时间**。系统CPU时间的统计很难做到精确，因为这实际上是要求操作系统进行自测量。此外，当比较具有不同系统代码的机器时，由于系统CPU时间是不一样的，因而误差较大，**采用用户CPU时间，作为性能衡量的时间标准较为妥当**。当然，在衡量未加载系统的性能时，采用前述的响应时间较为合适，而**衡量CPU性能，则宜采用用户CPU时间**。

下面主要讨论，以用户CPU时间来衡量的CPU性能。
## 1.3.1 CPU性能
绝大多数计算机都使用**以固定速率运行的时钟**，它的运行周期称为**时钟周期** `Clock cycles` ，它常以**时间长短**（以 $ns$ 计算）或**运行速率**（以 $MHz$ 计算）来表示。一个程序在CPU上运行所需的时间 $T_{CPU}$ ，可用以下的公式表示：
$$T_{CPU} = I_N × CPI × T_C$$
式中，$I_N$ 表示**要执行程序中的指令总数**，$CPI$ 表示执行每条指令所需的平均时钟周期数，而 $T_C$ 表示时钟周期的时间。

由此公式可见，用户CPU时间取决于三个特征：时钟周期（或速率），每条指令所需时钟周期数以及程序中总的指令数。其中，$I_N$ 主要取决于**机器指令系统和编译技术**，$CPI$ 主要与**计算机组成和指令系统**有关，而 $T_C$ 则主要由**硬件工艺和计算机组成**决定。

每条指令平均所需时钟周期数 $CPI$ ，可由下式表示：
$$CPI = ∑^n_{i = 1} \Bigg(CPI_i × \dfrac{I_i} {I_N } \Bigg)$$
其中，$I_i$ 表示**第 $i$ 类指令**在程序中执行次数，$CPI_i$ 表示执行一条第 $i$ 类指令所需的平均时钟周期数，$n$ 为程序中**所有的指令种类**数，$\dfrac{I_i} {I_N}$ 表示**第 $i$ 种指令**在程序中所占比例。

下面通过两个例子来说明上述概念和公式的应用。

【例1.2】假定在设计机器的指令系统时，对条件转移指令的设计有以下两种不同的选择：
- $CPU_A$ 采用一条比较指令来设置相应的条件码，由紧随其后的转移指令对此条件码进行测试，以确定是否要进行转移。显然，为实现一次条件转移就必须使用比较和测试两条指令。
- $CPU_B$ 使转移指令不仅具有「判别是否实现转移」功能，还包含有上述方案中的「比较指令」的功能，这样实现一次条件转移，就只需要一条指令便可完成。

假设在两个机器的指令系统中，执行条件转移指令需 $2$ 个时钟周期，而其他的指令只需 $1$ 个时钟周期。又假设在 $CPU_A$ 上，要执行的指令中有 $20\%$ 是条件转移指令，由于每条转移指令都需要一条比较指令，因此，比较指令也将占据 $20\%$ 。由于 $CPU_B$ 在转移指令中包含了比较功能，因此**它的时钟周期就比 $CPU_A$ 的要慢 $25\%$** 。现在要问，采用不同转移指令方案的 $CPU_A$ 和 $CPU_B$ ，哪一个工作速度会更快些？

解：根据上述假设，可计算得 $CPI_A = 0.2 × 2 + 0.8×1 = 1.2$ ，因为转移指令需 $2$ 个时钟周期，而其余的指令包括比较指令，只需 $1$ 个时钟周期。所以
$$T_{CPU_A} = I_{NA} × 1.2 × T_{CA} = 1.2 I_{N A} × T_{CA}$$

**对于 $CPU_B$ ，由于没有比较指令，从而使转移指令由原来的占 $20\%$ 上升为 $20 \%÷80 \% = 25 \%$**（？），它也需 $2$ 个时钟周期，而其余的 $75\%$ 指令只需 $1$ 个时钟周期，因而有 $CPI_B = 0.25×2 + 0 .75× 1 =1 .25$ 。**由于 $CPU_B$ 中没有比较指令，因此 $I_{NB} = 0.8 × I_{N A}$** 。此外，$T_{CB} = 1.25 T_{CA}$ ，所以
$$T_{CPU_B} = I_{N B} ×CPI_B × T_{CB} = 0.8 I_{N A} ×1.25 ×1.25 T_{CA} = 1.25 I_{NA} × T_{CA}$$ 与 $T_{CPU_A}$ 相比较，可见由于 $CPU_A$ 所需时间较小，所以 $CPU_A$ 比 $CPU_B$ 运行得更快些。

【例1.3】在上例中，如果 $CPU_B$ 的时钟周期只比 $CPU_A$ 的慢 $10\%$ ，那么此时，哪一个 $CPU$ 会工作得更快些 ?
解：$T_{CPU_A} = 1.2I_{N A} × T_{CA}$ ，而此时因 $T_{CB} = 1.10 T_{CA}$ ，故 $T_{CPU_B} = 0.8 I_{N A} ×1.25×1.10 T_{CA} = 1 .10 I_{NA} × T_{CA}$ 。由于 $T_{CPU_B}$ 所需时间较少，故 $CPU_B$ 比 $CPU_A$ 运行得更快些。

## 1.3.2 `MIPS` 和 `MFLOPS`
除了时间评估标准之外，`MIPS` 和 `MFLOPS` 也是比较常用的性能评估标准。
### 1. `MIPS`
**每秒百万次指令** `Million Instructions Per Second, MIPS` 是一个用来描述计算机性能的尺度。对于给定的一个程序，`MIPS` 可表示成：
$$MIPS = \dfrac{I_N} { T_E \times 10^6} = \dfrac{I_N} { I_N \times CPI \times T_C \times 10^6} = \dfrac{R_C} {CPI \times 10^6}$$
其中，$T_E$ 表示执行该程序所需时间；$R_C$ 表示时钟速率，它是时钟周期时间 $T_C$ 的倒数。

在使用 `MIPS` 时应注意它的应用范围，**它只适宜于评估标量机**，因为在标量机中执行一条指令，一般可得到一个运算结果；而向量机中，执行一条向量指令通常可得到多个运算结果，因此，**用 `MIPS` 来衡量向量机是不合适的**。在 `MIPS` 中，不仅是运算指令，所有的服务性指令如取数、存数、转移等都计算在内，而在浮点运算中（的）服务性指令均不予计入。

有时还用**相对 $MIPS_{T}$** 这一标准（？），这需要事先选择一个给定的参照计算机的性能，然后与其比较。因此有：$$MIPS_{T} =\dfrac {T_{ref}} {T_V} × MIPS_{ref}$$
式中，$T_{ref}$ 表示在参照机上程序的执行时间；$T_V$ 表示相同程序在要评估机器上执行时间； $MIPS_{ref}$ 表示所约定的参照机的 `MIPS` 速率。在20世纪80年代，常以DEC公司的 `VAX-11/780` 计算机作为参照机，称其为 `1 MIPS` 机器。

### 2. `MFLOPS`
每秒百万次浮点运算 `Million FLoating point Operations Per Second, MFLOPS` 可用如下式子表示：$$MFLOPS = \dfrac{I_{FN}} { T_E \times 10^6}$$  式中，$I_{FN}$ 表示程序中的浮点运算次数。

$MFLOPS$ 测量单位比较**适用于衡量向量机的性能**，因为一般而言，同一程序运行在不同计算机上时，往往会执行不同数量的指令数，但所执行的浮点数个数（？）常常是相同的。采用 $MFLOPS$ 作为衡量单位时，应注意它的值不但会随**整数、浮点数操作混合比例的不同**发生变化，而且也会随**快速和慢速浮点操作混合比例的变化**而变化。

例如，运行由 $100\%$ 浮点加法组成的程序，所得到的 $MFLOPS$ 值将比由 $100\%$ 浮点除法组成的程序要高。因此，**通常对源程序中的每种实际的浮点操作乘以一个正则化值，然后再进行 $MFLOPS$ 的求值**。例如，在 `Livermore` 循环测试程序中，浮点加、减、乘及比较操作的正则化值为 $1$ ；浮点除法、开方操作的正则化值为 $4$ ；而浮点指数、三角函数等操作的正则化值为 $8$ 。

$MFLOPS$ 和 $MIPS$ 两个衡量值之间的量值关系没有统一的标准，一般认为，在标量计算机中执行一次浮点运算需 $2～5$ 条指令，平均约需 $3$ 条指令，故有 $1MFLOPS≈3MIPS$ 。

## 1.3.3 基准测试程序
在进行计算机系统的评价时，除了与**被评价的机器的结构、功能等特性参数**有关以外，还与输入（即**该计算机系统的工作负荷** `Workload` ）有密切关系。被评价的一个计算机系统，往往对某一种工作负荷表现出较高性能，而对另一种工作负荷则可能呈现较低性能。==为了对计算机系统的性能进行客观的评价，就需要选取具有真实代表性的工作负荷==。通常采用**不同层次的基准 `Benchmark` 测试程序**来评价系统性能。
1. **采用实际应用程序**。例如，C语言的各种编译程序；$\TeX$ 正文处理软件以及Spice那样的CAD工具软件。
2. **采用核心程序**。这是从实际程序中抽取少量关键循环程序段，并以此来评估性能，例如 `Livermore 24 Loops` $24$ 个循环段和 `Linpack` 解线性方程组便是典型代表，但这些核心程序只具有评价性能价值。
3. **合成测试程序**。它类似于核心程序方法，但这种合成测试程序是人为编制的，较流行的合成测试程序有 `Whetstone` 和 `Dhrystone` 两种。
    - `Whetstone` 是有关整、浮点运算的合成混合，还包括了超越函数、条件转移、函数调用。早先用Algol 60书写，后改用FORTRAN书写。
	- `Dhrystone` 主要是有关整数计算，包括字符串及数组处理。应该指出的是由于这类典型测试程序是人为编制的，因此**它比核心程序离实际程序更远**。

1988年以来，美国HP、DEC、MIPS以及SUN公司等发起成立了 `SPEC` 组织（系统性能评价合作团体），一致同意用一组实用程序和相应输入来评价计算机系统性能。`SPEC` 典型测试程序由以下 $10$ 个程序组成—— `GCC, Espresso, Splce2g6, DODUC, NASA7, Li, Eqntott, Matrix300, FPPPP, TOMCAT V` ，其中 $4$ 个用C语言编写 `GCC, Espresso, Li, Eqntott` 进行整数运算，余下 $6$ 个用FORTRAN语言编写、进行浮点运算，计算所得 `SPECmark` 的分值越大越好，它是相对于 `VAX-11/780` 的性能，`1SPEC` 分值约相当于 `0.2～0.3MFLOPS` 。 `SPEC` 还可进一步分为 `SPECint`（整数 `SPEC` ）和  `SPECfp`（浮点 `SPEC`），以及与它相对应的1989、1992和1995三个版本。

类似于 `SPEC` 的组织尚有 `Perfect` 俱乐部，它主要由大学和公司中对并行计算感兴趣的爱好者组成，选定了称为 `Perfect Club` 的典型测试程序。

## 1.3.4 性能评价结果的统计和比较
关于计算机性能的评价，通常用**峰值性能** `Peak Performance` 及**持续性能**`Sustained Performance` 两个指标。峰值性能是指==在理想情况下计算机系统可获得的最高理论性能值，它不能真实反映系统的实际性能==。实际性能又称为持续性能，它的值往往只有峰值性能的 $5\%$ 到 $35\%$（因算法而异）。**持续性能的表示常用算术平均 `Arithmetic Mean` 、几何平均 `Geometric Mean` 和调和平均 `Harmonic Mean` 三种平均值方法**，这三种性能值（运算速率）的计算公式如下。
### 1. 算术性能平均值 $A_m$
$$A_m = \dfrac{1}{n} \sum^n_{i = 1} R_i =\dfrac{1}{n} \sum^n_{i = 1} \dfrac{1}{T_i} = \dfrac{1}{n} \Bigg( \dfrac{1}{T_1} + \dfrac{1}{T_2} + \dots + \dfrac{1}{T_n}\Bigg)$$ 若以执行时间表示性能，则有 $A_m = \displaystyle \dfrac{1}{n} \sum^n_{i = 1} T_i$ 。
### 2. 几何性能平均值 $G_m$
 $$G_m = \sqrt[n]{\prod^n_{i = 1} R_i} = \sqrt[n]{\prod^n_{i = 1} \dfrac{1}{T_i}}$$
### 3. 调和性能平均值 $H_m$
$$H_m = \dfrac{n} { \sum^n_{i = 1} \dfrac{1}{R_i}} = \dfrac{n}{ \sum^n_{i = 1} T_i} = \dfrac{n}{T_1 + T_2 + \dots + T_n}$$

以上三个公式中，$R_i$ 表示由 $n$ 个程序组成的工作负荷中、执行第 $i$ 个程序的速率，$T_i$ 表示执行第 $i$ 个程序所需的时间，这里 $R_i = \dfrac{1}{T_i}$ 。

如果考虑**工作负荷中各程序不会以相等比例出现**这一情况，就需要对各程序的执行速率或执行时间加上相应权值，此时有：
 $$A_m =  \sum^n_{i = 1} W_iR_i =  \sum^n_{i = 1}W_i \dfrac{1}{T_i}  \\ {} \\ 
G_m = \prod^n_{i = 1} (R_i)^{W_i} = (R_1)^{W_1} \times (R_2)^{W_2} \times \dots \times (R_n)^{W_n}  \\ {} \\
H_m = \dfrac{1} { \sum^n_{i = 1} \dfrac{W_i}{R_i}} = \dfrac{1}{ \sum^n_{i = 1}W_i T_i}$$

从上述的三种表示方式中可以看到，==只有 $H_m$ 值是真正与「运行所有典型测试程序所需的时间总和」成反比关系的==，若以前面提及的衡量性能指标的惟一标准是时间这一点来看，用 $H_m$ 值来衡量计算机系统性能是较为精确的。但 $G_m$ 表示法有一个很好的特性：
 $$\dfrac{G_m(X_i) } {G_m(Y_i) } = G_m \bigg[ \dfrac{X_i}{Y_i} \bigg]$$
即 ==「几何平均比」与「比的几何平均」是相等的== 。因此，在对各种机器性能比较进行性能规格化（即以某台机器性能作参考标准，其他机器性能除以该参考标准所得到的比值）的过程中，**不论取哪一台作参考机，$G_m$ 均能保持比较结果的一致性**，$A_m$ 和 $H_m$ 由于没有这样的特性，因而在作比较时，就不如 $G_m$ 那样方便。下面通过一个例子来说明这一点。

表1.1中示出了用两个基准测试程序，对三台计算机进行测试所获得的运行时间。由表中可见，对基准测试程序比 $B_1$ ，$Y$ 机的速度为 $X$ 机的 $2$ 倍； 但对基准测试程序 $B_2$ ，$Y$ 机速度仅为 $X$ 机的一半。类似地有，对 $B_1$ ，$Z$ 机速度仅为 $X$ 机的一半； 对 $B_2$ ，$Z$ 机的速度则为 $X$ 机的 $2$ 倍。直观地看，这 $3$ 台机器应有相同的性能。然而，如果将这些测试值以 $X$ 机为基准进行规格化 (表中括号中的值 )，并求出相应的 $A_m$ 值，就会发现：$Y$ 机和 $Z$ 机速度均比 $X$ 机要慢 $25\%$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/729bb41c7ea040d6a7fc1165c58b3ea7.png)
更糟糕的是，如果我们以 $Y$ 机作为标准来规格化测试，将得到表1.2所示的 $A_m$ 值。由该结果值可知，现在 $Y$ 机的速度比 $X$ 机快 25 %，而比 $Z$ 机要快 $2$ 倍多，尽管 $Y$ 机的总的基准测试程序的运行时间，要比 $X$ 机和 $Z$ 机都要长。显然，选用这种标准机来规格化 $A_m$ ，将会得到不同的结论，因此这种评价方法是不可取的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/0d2a7136330e4364a0494d8919de2c66.png)
对于几何平均值 $G_m$ ，由于有前面所提到的良好特性，则不会发生如同 $A_m$ 那样的错误情况。如表1.3和表1.4所示，分别同样以 $X$ 和 $Y$ 机作为标准机，对测试值进行规格化。可以看出两者得到的结果是一致的，表明这三台处理机具有相同性能这一正确结论。
![在这里插入图片描述](https://img-blog.csdnimg.cn/0d3ef0c8153943e091eee10c52e6af41.png)

## 1.3.5 Intel微处理器性能评价
微处理器发展非常迅速，种类日趋繁多，应用也日益广泛，仅仅靠CPU型号和主频的标识，不能充分说明处理器的性能。为此，Intel公司制定并发展了 **`iCOMP` 指数体系**，通过它希望能给处理器性能一个较为科学、公正的评价。下面介绍 `iCOMP` Intel体系的基本架构。

### 1. `iCOMP 1.0` 和 `iCOMP 2.0`
为向一般用户提供一个理解和比较「Intel微处理器性能相对差异」的易用工具，Intel公司于1992年推出了 `intel COmparative Microprocessor Performance, iCOMP` **微处理器性能比较指数体系**，后来被称为 `iCOMP 1.0` 版。

`iCOMP 1.0` 考虑了那个时期桌面计算机系统的应用，综合了 $9$ 项评估项目：
- 适用于DOS应用的 $16$ 位整数运算
- 适用于CAD/CAM的 $16$ 位浮点运算
- 适用于UNIX应用的 $32$ 位整数运算和 $32$ 位浮点运算、
- 适用于多媒体应用的 $16$ 位和 $32$ 位视频运算
- $16$ 位和 $32$ 位图形处理。

每项指定了测试基准 `BenehMark, BM` ，并分别予以不同的权值 $P$ ，如表1.5 所示。注意，它的视频运算和图形处理的权值为 $0$ ，Intel当时的打算是，随着多媒体和3D动画应用的普及，将来再逐渐改变权值分配。
![在这里插入图片描述](https://img-blog.csdnimg.cn/22624e2c960d479dbbf95d1cb19777b1.png)
`iCOMP 1.0` 以不含FPU的、主频为 `25MHz` 的 `80486(486SX-25)` 作为性能测试的基值 `Base` ，即它的 `iCOMP` 值为 $100$ 。以如下公式计算某类型处理器的 `iCOMP` 值：
 $$\textrm{iCOMP} = 100 \times \Bigg[ \bigg(\dfrac{BM_1}{Base\_BM_1} \bigg) P_1 + \bigg(\dfrac{BM_2}{Base\_BM_2} \bigg) P_2 + \dots + \bigg(\dfrac{BM_9}{Base\_BM_9} \bigg) P_9  \Bigg]$$

其中，$Base\_BM_i$ 代表 `486SX-25` 在第 $i$ 项下的测试值，$BM_i$ 代表被测处理器在第 $i$ 项下的实测值，$P_i$ 为第 $i$ 项的权值。

早期某些主频下 `Pentium` 处理器的测试，按上式加权平均计算出的 `iCOMP 1.0` 值，如表1.6所示。
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/d1ff2a1af12647b1bd41e86c9c924fc1.png)

自 `iCOMP 1.0` 公布之后，短短几年微处理器性能和市场应用发生迅速改变。首先是向 $32$ 位桌面操作系统和应用的快速转变，据调查到1997年底与新PC一块装机的软件，$90\%$ 是 $32$ 位的，仅 $10\%$ 是 $16$ 位的，并推测到1998年底装机软件几乎全部都是 $32$ 位的。其次是多媒体、网络通信以及3D图形处理的应用已形成规模。另外，测试基准程序已经修改，或者已开发出反映「新兴软件中特有指令综合功能」的新基准程序。这一切使得Intel公司将它的 `iCOMP` 评估体系推进到 `iCOMP 2.0` 版。

1996年公布的 `iCOMP 2.0` ，由 $4$ 个工业标准的 $32$ 位测试基准和一个Intel公司自行开发的多媒体测试基准 `Intel Media Benchmark` 组成。它们的应用类别和权值，如表1.7 所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/9818d7a9e5b44237ae220a8fdc33ff0d.png)`iCOMP 2.0` 的 `iCOMP` 值计算公式仍同上述相同（只是 $5$ 项加权平均)，以 `Pentium 120`（主频 `120MHz` ，外频 `60MHz` ）为性能测试的基值，即它的 `iCOMP` 值为 $100$ 。表1.8列出 `Pentium` 系列微处理器在2.0版下的 `iCOMP` 值。
![在这里插入图片描述](https://img-blog.csdnimg.cn/1987c45862654367bb34ea54fdb2409f.png)
### 2. `iCOMP 3.0`
为能反映处理器在当今迅猛增长的多媒体、3D和Internet应用需求的性能指标，1999年初Intel公司公布了 `iCOMP 3.0` 性能评估体系。这次，Intel将PC应用明确划分成 $4$ 大领域：多媒体、3D、Internet和 `Productivity`（生产率 ）。其中，`Productivity` 是指除去多媒体、3D、Internet之外的所有 PC 应用，典型的是各种电子表格、数据库和字处理软件。`iCOMP 3.0` 由 $6$ 项工业标准的测试基准组成，它们是：
- `CPU mark * 99 (BM1)` ：Zitt-Davis开发的 `CPU mark * 99` 是一个Windows测试基准，它测试处理器、内部Cache、外部Cache以及系统RAM的性能。
- `Wintune * 98 Advanced CPU Integer Test (BM2)` ：`Wintune * 98` 是一个用于Windows 95、Windows 98和Windows NT系统的诊断测试和基准程序，它完成 $7$ 项测试，其中包括CPU、存储器、视频和磁盘速度。对于测试结果，可通过Internet访问Windows期刊社维护的一个中央数据库，来与其他类似的机器进行性能比较。
- `Multimedia Mark * 99 (BM3)` ：它是由 `Futuremark Corporation` 开发的一个测试套件，主要用于测试当代PC在“现实世界”环境中的多媒体性能，这包括 `MPEG-1` 视频编码、`MPEG-1` 视频播放、图像处理和音频效果。
- `3D WinBench * 99-3D Lighting and Transformation Test (BM4)` ：`3D WinBench * 99` 是一个系统级的3D性能测试套件，测试包括CPU和图形子系统的性能。为了解CPU的3D性能，要使用此套件中的 `3D Lighting and Transformation Test` ，它测试3D图形流水线中CPU涵盖部分的性能。
- `WinBench * 99-FPU WinMark(BM5)` ：这是由Zitt-Davis开发的、主要用于测试处理器浮点子系统的综合测试套件。为测量FPU在科学计算和3D图形透视计算的能力，此测试由 $5$ 个算法组成：3D图形操作，快速傅立叶变换，行星轨道计算，多边形面积计算和线性方程系数矩阵的高斯—约旦消元法。Zitt-Davis为每种算法指定一个权值，然后加权平均得到单一的记分。
- `JMark * 2.0 Processor Test(BM6)` ：它是Zitt-Davis开发的测试处理器Java性能的基准程序，着重测试Java虚拟机JVM的非图形工作负载方面的性能。

这 $6$ 项测试基准的应用类别和权值，如表1.9所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/ab5ac42d6f37462581c7107c43e64e3c.png)
`iCOMP 3.0` 值的计算公式仍类似于前面介绍的计算方法（只是 $6$ 项加权平均）。只是它以 `Pentium II-350` 为性能测试的底值，并且其 `iCOMP` 值为 $1000$ 。故 `iCOMP` 值计算公式为：
$$\textrm{iCOMP} = 1000×\Bigg[ \bigg( \dfrac{ BM_1 } {Base\_BM_1} \bigg) P_1 + \bigg( \dfrac {BM_2}{Base\_BM_2}\bigg) P_2 +\dots + \bigg(\dfrac{BM_6} {Base\_BM_6}\bigg) P_6 \Bigg]$$

`Pentium II-350` 以 $6$ 个测试基准程序测得的 $Base\_BM_1,\ Base\_BM_2,\ \dots ,\ Base\_BM_6$ 的值分别是：$27.8,\ 87.21,\ 883,\ 26.5,\ 1790,\ 609$ 。将这些值代入上式，即可得到 `iCOMP 3.0` 下的 `iCOMP` 值实际计算公式：
$$\textrm{iCOMP} = 1000×\Bigg[  \dfrac{ BM_1 } { 27.8} ×20 \%  + \dfrac {BM_2}{87.21}×20\% + \dfrac{BM_3}{ 833} ×25\% +\dfrac{ BM_4} {26.5} ×20 \% + \dfrac{BM_5} {1790}×5\% + \dfrac{BM_6} {609} ×10\%\Bigg]$$

只要以 $6$ 个测试基准程序测出某处理器的记分，代入上式即可算出该处理器的 `iCOMP 3.0` 值。例如，以 $6$ 个测试基准程序测试 `Pentium II-400` ，得到 $BM_1 ～BM_6$ 的记分为 $31.6,\ 99.25,\ 999,\ 30.1,\ 2050,\ 974$ ，不难算出它的 `iCOMP` 值为 $1130$ 。表1.10列出 `Pentium II` 和 `Pentium III` 一些处理器的 `iCOMP` 值。
![在这里插入图片描述](https://img-blog.csdnimg.cn/a527f95d0a454994833781e2a22a5302.png)
Intel用于 `iCOMP 3.0` 性能评估时的系统配置为：`Intel SE440BX-2` 的主板，128MB SDRAM的内存，512KB的 $2$ 级Cache，Adapte AHA 2940 UW2W SCSI/PCI的硬盘控制器/总线，Seagate Cheetah ST 39102LW的硬盘驱动器，$1024×768$ 分辨率、$16$ 位颜色的图形显示器，Diamond Multimedi Viper AGP（显示存储器为16MB SDRAM）的Video，Diamond Monster Sound M80 PCI的Audio。使用的操作系统是带有Microsoft Direct x6.1的Windows 98。

---
# 1.4 计算机系统结构的发展
## 1.4.1 计算机系统结构的演变
==传统的计算机主要**以运算器为中心**，此外还有控制器、存储器以及输入/输出设备。所有的输入、输出活动都必须经过运算器，**存储器中存放有指令及数据**==。由于这一设想是美国科学家冯·诺依曼 `Von Neumann` 首先提出来的，故又称为冯·诺依曼计算机，如图1.4所示。

冯·诺依曼型计算机的主要特点是：
- **存储程序方式**。==指令和数据都以字的方式存放在同一存储器中，没有区别==，由机器状态（如取指令或取操作数周期）来确定从存储器读出的字是指令还是数据。**指令送往控制器译码，数据送往运算器进行运算**。
- **指令串行执行**，并由控制器加以集中控制。
- **单元定长的一维线性空间的存储器**。
- 使用低级机器语言，**数据以二进制形式表示**。
- **单处理机结构，以运算器作为中心**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/d49913abd15f4f5a9759ae2d7351d78a.png)

这是一种最为简单且容易实现的计算机结构，在当时元器件可靠性较低的情况下，也是一种很合适的结构。以后，在计算机技术发展的很长一段时期内，基本上没有离开这一结构模式。这种结构存在的主要缺点有：
- **存在有两个主要的瓶颈**。一个是**物理瓶颈**，即在CPU和存储器之间存在频繁的信息交换，而且指令中数据的访问地址通常并不是有效地址，必须经过各种变换和运算后才能得到真正的有效地址； 二是**智能瓶颈**，即每次只能顺序地执行一条指令。
- **低级的机器语言和高级的程序设计语言之间，存在着巨大的语义差距**，此差距往往要靠大量复杂的软件程序来填补。
- **复杂的数据结构对象无法直接存放到一维线性地址空间的存储器中**，必须经过地址映像。

近半个世纪以来，对冯·诺依曼型计算机结构已做了许多改进。归纳起来采用了两种方法。**一种是“改良”方法**，即基本上仍保留原来的工作方式，但做了许多重大改进以提高计算机系统性能，并称为改进的冯·诺依曼型计算机结构。**另一种是“革命”方法**，即采用一种与冯·诺依曼型计算机完全不同的方式工作。

在改进的冯·诺依曼型机中，具有以下一些重要特征，其目的是**提高运算速度，更好地支持高级语言和结构化数据对象**，它们包括：
- **增加了新的数据表示**，如浮点数、字符串和十进制数的表示。
- **采用虚拟存储器**，方便了高级语言编程。
- **堆栈的引入**，以支持高级语言中的过程调用、递归机制以及表达式求值等。
- **采用变址寄存器并增加了间接寻址方式**，以方便对复杂数据结构对象的访问。这一项主要是为了支持对复杂数据结构对象的访问。
- **增加CPU内的通用寄存器数量**，**增设Cache高速缓冲存储器**，以减少 CPU与主存储器间的过分频繁的信息交换。 
- **采用存储器交叉访问技术以及无冲突并行存储器**，以加宽存储器带宽。
- **采用流水技术**，包括指令级流水和运算级流水，以加快指令及操作的执行速度。
- **采用多功能部件**，这样一条指令就可以对多个数据元素在不同功能部件上进行并发操作（？）。
- **采用支持处理机**，如协处理机 `Coprocessors` 及输入/输出处理机 `I/O processors` ，以使CPU能集中精力从事数值运算。
- 采用自定义的数据表示，由数据中的标志符显式说明，是指令还是某一种类型的数据。虽然对这一措施的优越性有争论，但至少在LISP那样的延迟绑定 `Late binding` 语言中是非常重要的。
- 使程序和数据空间分开，从而增加了存储器带宽。

前三项主要是为了更好地支持高级语言，前七项主要是为了提高处理速度。第八、九两项还超出原来冯·诺依曼型机基本结构的范围。==上述各种改进措施的实现，使计算机系统结构从原来**以运算器为中心**逐步演变为**以存储器为中心**==。

系统结构的革命性发展，导致了20世纪70年代数据流计算机的出现，以及需求驱动计算机乃至初等智能计算机的出现，预计到21世纪将会在这方面有较大的发展和新的突破。

总的发展趋势是对计算机性能的要求越来越高，主存容量越来越大和 I/O 吞吐能力越来越强。在20世纪的追求目标是万亿次 `Teraflops` 运算速度、万亿字节存储容量 `Terabyte` 和每秒万亿字节的 I/O 吞吐率 `Terabyte/second` ，简称“3T”目标。
## 1.4.2 软件、应用和器件对系统结构发展的影响
### 1. 软件对系统结构发展的影响
早期的计算机系统，由于**硬件比较昂贵**，因此通常将许多功能用软件实现。再加上应用软件的开发，导致软件越来越多，功能越来越复杂，由于软件书写基本上依靠人力，造成软件编写及排错困难，生产效率低下，导致“软件危机”的出现。

随着**器件更新换代的飞速发展以及硬件价格逐渐下降**，造成软件价格相对地不断上升。因此，用户就希望在新型号机出台后，原先已开发的软件仍能继续在升档换代的新型号机器上使用，即软件要求具有**兼容性**（或称为**软件的可移植性**）——==一个软件可不经修改或只需少量修改，便可由一台机器移植到另一台机器上运行，即同一软件可应用于不同环境==。为了实现软件的可移植性，一般可采用如下方法：
- **采用统一的高级语言**：==软件移植包括应用软件和系统软件两个方面的移植==。软件又可用高级语言、汇编语言或机器语言来编写。由于高级语言是面向题目和算法的，与机器的具体结构关系不大，如果能统一出一种满足各种应用需要的通用高级语言，那就很容易实现所有应用软件和部分系统软件之间的移植。
统一高级语言的方法，目前存在着三个问题。第一，目前已经存在的各种高级语言，是根据不同的应用而产生的，这些高级语言又具有不同的语法结构和语义结构。**如果用一种高级语言包含所有的应用，是非常困难的**。第二，**计算机工作者目前对高级语言的基本结构，在看法上存在不一致**，如常用的 `GOTO` 语句。第三，**习惯势力的影响**，人们不愿轻易抛弃已经习惯了的高级语言和软件上的成果及经验积累。
虽然统一高级语言的方法目前实现非常困难，但仍是努力的重要方向。如果能够统一成一种或几种，对于加速软件人才的培养和软件开发意 义是非常重大的。ADA语言的出现是朝着这个方向的重大进展。
- **采用系列机**：所谓**系列机**是指==在同一厂家内生产的、具有相同系统结构、但具有不同组成和实现的一系列的机器==。它要求预先确定好一种系统结构（软硬件界面）。然后，软件设计者依此进行系统软件设计，硬件设计者则根据不同性能、价格要求，采用各种不同的组成和物理实现技术，以向用户提供不同档次的机器。采用这样的方法后，由于机器语言程序员或是编译程序设计者，他们看到的、这些机器的概念性结构和功能属性都是一样的，即机器语言都是一样的。因此，为某一档次机器编制的软件，在其他档次的机器上都可运行。
==系列机方法较好地解决了硬件技术更新发展快、而软件编写开发周期比较长之间的矛盾。由于系列机中的系统结构在相当长的时期内不会改变，改变的只是组成和实现技术，从而使得软件开发有一个较长的相对稳定的周期==。IBM公司首先提出了这种思想，在1964年推出了IBM 360系列机。以后又陆续推出了IBM 370系列机、IBM 303X、43XX、308X、309X等系列机。DEC公司则推出了PDP ll系列机、VAXll、8000、6200、6300、6400等系列机。==这种系列机设计思想，对以后问世的微型计算机以及巨型计算机都产生了影响==。如Intel公司推出了80X86微机系列，Motorola公司推出了680X0微机系列，CRAY公司推出了巨型机CRAY系列等等，便是例证。
	在各档机器的中央处理机中，**指令系统**都相同，但**指令的分析执行**则可有顺序、重叠或流水等不同处理方式。在**数据表示**方面，从程序设计者所看到的各档机器的字长均为 $32$ 位（定点数都为 $16$ 位的半字或 $32$ 位全字，浮点数为单、双、$4$ 倍字长），但低、中、高档的不同型号机器，它们所采用的**数据通路宽度**可能分别为 $8$ 位、$16$ 位、$32$ 位或 $64$ 位。显然这种数据通信宽度对程序员来讲是透明的。此外在进行**输入输出**时，各档机器都有采用通道方式，但随机器档次的不同，可采用结合型方式（通道借用中央处理机中某些部件完成）或是独立型的。
在系列机中，由于机器语言、汇编语言以及编译程序在各档机器间都可通用，因此它们是**软件兼容**的。==这种方法使得软件开发有一个较长时间的稳定的环境，有利于计算机系统随着硬件器件技术的不断发展而升级换代，对计算机的发展起到了很大的推动作用==。但是，这种可移植性仅限于某一厂商所生产的某一系列机内部，用户不能在不同厂商的产品中进行选择。==系列机的思想，后来在不同厂家间生产的机器上也得到了体现，出现了兼容机==。

	所谓**兼容机** `Compatible machine` 是指==不同厂家能生产的、具有相同系统结构、但具有不同组成和实现的一系列计算机==。这样就使得一些没有软件开发能力的厂家，能借用有软件开发能力的计算机厂家的、已有的软件成果，在采用新的组成和实现技术后，有更好的性能价格比；另一方面，还可以对原有系统结构加以某种形式扩充，以使之能有更强的功能和竞争力。如Amdahl公司生产的与IBM 370兼容的Amdahl470、480 等，以及长城公司生产的0520IBM-PC兼容机，后者由于扩充了汉字处理功能，因而形成了更强的市场竞争力。
	
	==系列机方法较好地解决了软件移植的问题，但由于这种方法要求系统结构不能改变，这也就**在较大程度上限制了计算机系统结构发展**==，而且所有的软件兼容也是有一定条件约束的。

	> 软件兼容按**性能上的高低**和**时间上推出的先后**还可分为向上、向下和向前、向后四种兼容。
	> - 所谓**向上（下）兼容**，是指==按某档机器编制的软件，不加修改就能运行于比它高（低）档的机器上==。同一系列内的软件一般应做到向上兼容，向下兼容就不一定，特别是「与机器速度有关的实时性软件」，向下兼容就难以做到。
	> - 所谓**向前（后）兼容**，是指==在按某个时期投入市场的、该型号机器上编制的软件，不用修改就能运行于在它之前（后）投入市场的机器上==。同一系列机内的软件必须保证做到向后兼容，不一定非要向前兼容了。

- **采用模拟和仿真方法**：系列机的方法只能在**系统结构相同的机器之间**实现软件移植。==为了实现**系统结构不相同的机器之间**也能实现软件移植，必须采用模拟与仿真的方法==。
	- **模拟方法**是指，==用**软件方法**在一台现有的计算机上实现**另一台计算机的指令系统**==。如在 $A$ 机上要实现 $B$ 机的指令系统，通常要用**解释方法**来完成，即==对应 $B$ 机中的每一条指令，用相应的一段 $A$ 机（如 $n$ 条）指令进行解释执行==。这种==用「实际存在的机器语言」解释实现软件移植的方法称为**模拟**==。$A$ 机常称为**宿主机**，$B$ 机则称为**虚拟机**，因为 $B$ 机实际上并不存在，如图1.5(a)所示。
	==为了模拟 $B$ 机系统，除了指令系统以外，通常还需模拟它的系统结构环境==，包括 $B$ 机的存储系统、I/O 子系统以及 $B$ 机的操作系统等。对应用软件的模拟，也可采用类似方法。**由于模拟是采用纯软件解释执行方法，因此运行速度较慢**。
	- **仿真方法**是指，==当宿主机本身采用微程序控制时，则对 $B$ 机指令系统每条指令的解释执行，可直接由 **$A$ 机中对应的一段微程序**来完成==，此时 $A$ 机仍称**宿主机**，但 $B$ 机称为**目标机**。此外，由于仿真方法中，微程序是存放在控存中（模拟方法中模拟程序存放在主存中），因而实际上是**有部分硬件（或固件）参与解释过程**。因此，**仿真的工作速度要比纯软件的模拟方法快**，如图1.5(b)所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/9369239fb5e84720adb5cc20f707ffac.png)
		用微程序仿真方法实现解释执行时，==由于微程序机器级结构更依赖计算机的系统结构，再加上编写仿真微程序较为费时和复杂，因此对于系统结构差别较大的机器，难以完全用仿真方法来实现软件移植==，所以**通常将这两种方法混合使用**——==对于使用频率较高的指令，尽可能用仿真方法以提高运算速度，而对使用频率低且难以用仿真实现的指令（包括 I/O 指令等），则用模拟方法加以实现==。
		
- **开放式系统方法**：值得注意的是，在1978年国际标准化组织（ISO）首先提出了关于**开放式系统** `Open system` 的新概念——==一种独立于厂商、且遵循有关国际标准==（主要是指由IEEE的开放系统技术委员会主管制定的系统或网络中，应用软件、系统软件和硬件相互间的界面接口标准）==而建立的、具有系统可移植性==、==交互操作性==，==从而能允许用户自主选择具体实现技术和多厂商产品渠道的系统集成技术的系统==。它是相对于原来的**封闭系统或专有系统**而言的。开放系统还为系统的档次皆宜性或规模可伸缩性 `Scalability` 创造了良好条件，同一应用软件在某一开放系统的系列产品上都具有运行的能力，如从个人计算机、作站到小型机、大型机乃至巨型机。
要达到上述目标，必须在优选的硬件和软件的平台上，对编程接口、人机接口、通信接口等加以统一，建立统一的规范和协议。
 	> **系统可移植性**主要是指==应用系统可移植性==和==用户（使用者）可移植性==。前者指==应用软件在多厂商、多硬件平台的计算机环境中，从一个平台移到另一个平台的可行度==；而后者是指==使用规范的一致性，这样用户就可不用改变原来的使用习惯（或只做少许改变），便可从一个平台转移到另一个平台上工作==。
	> <b></b>
	> **系统的交互操作性**主要是指==在多厂商、多硬件平台的计算机环境中，一个应用软件能与另一个应用软件进行协调工作，以及实现数据与资源共享的可行度==，它包括了：==应用软件能透明地在一个系统中，通过网络调用另一个系统中的数据资源及计算能力==，以及==在一个系统上运行的任务，可通过网络有效地分解成一些子任务，并分配到其他系统上，以实现这些子任务的并发操作==。

### 2. 应用对系统结构发展的影响
计算机应用是促使计算机系统结构发展的**最根本动力**。

计算机的性能是包括硬件（如主频、CPU运算速度、字长、数据类型、主存容量、寻址空间大小、存储系统、I/O 处理能力、I/O 设备量、指令系统等）、软件（高级语言状况、操作系统功能、用户程序包等）、可靠性、可用性等多种指标的综合。

20世纪60年代中期的多功能通用机的概念起始于大、中型机，后来小型机和微型机也逐步实现多功能通用化了。回顾这几十年的发展，巨、大、中、小、微、亚微、微微型机的性能、价格随时间变化的趋势，如图1.6 所示，其中虚线为等性能线。
![在这里插入图片描述](https://img-blog.csdnimg.cn/5ca31d5a46b74857a6d064dd10c0dce4.png)
可以看出，各型机器所具备的性能是随时在动态下移的，但价格却在相当长一段时期内基本不变。因此，有些人就主张用价格来划分巨型机到微型机的不同类型。

20世纪60年代末（相当于图中的 `t-1` ）问世的小型机（如 `PDP-8` ）性能几乎与70年代末（对应图中的 `t` ）的微型机相近，但后者的价格却下降很多。50年代末期购置的机器，所需费用在目前差不多可以购置一台大型机，其性能却仅接近目前的亚微型机（膝上型和笔记本型）。微型机的发展有两个趋势：一是尽量利用 `VLSI` 的进展，维持价格基本不变来提高性能，往小型机靠拢； 二是维持性能基本不变，降低价格，研制出更低档的亚微型机及微微型（掌上型）计算机，以进一步扩大计算机的用途。

在性能上，微型机的高档机可以替代小型机以至超级小型机的低档，超级小型机的高档顶替大、中型机的低档机的情况将长期存在，这是推动大、中、小、微型机不断提高其性能的重要因素。==高端计算机应用对系统结构不断提出的基本要求是高的运算速度，大的存储容量和大的 I/O 吞吐率==。

从最初的科学计算发展，到应用于商业和事务处理等方面的数据处理、工业过程控制乃至日常社会生活，计算机应用逐渐深入到国民经济及社会的各个领域。随着应用范围的扩大，对计算机系统的要求也就越来越高。

为适应不同的应用需要，满足各种应用的多功能通用机，满足某种特殊要求的专用机，适应不同应用场合需要的大、中、小型机，需要高速运算的巨型机，以及方便灵活的微型机等的涌现，都是应用需要的结果。计算机应用从最初的纯科学计算正逐步向更高级、更复杂的应用发展，经历了从**数据处理、信息处理、知识处理、智能处理**这四级逐步上升的阶段：
- 长期以来进行数据处理一直是计算机的重要任务，它所加工的数据对象相互之间是没有什么关系的。
- 随着对数据结构研究的深入，数据处理逐步向信息处理方向发展，此时被加工的数据对象之间，存在着某种语法结构，构成了信息项，从而导致能有效地对信息项进行管理、增删、检索、变更、维护、查询、修改等工作的数据库的出现。
- 当信息加入某些语义后便构成了知识，导致了对知识处理的应用，各类专家系统的出现便是这种应用日益广泛发展的结果。在20世纪90年代，这种应用有更大发展。
- 在知识处理基础上，使计算机能以自然形式实现人机间对话，如用语言、文字、图画、图像、文件等形式，并在引入推理功能后，就可使计算机系统具有从事定理证明、逻辑推理以及具有学习功能的能力，这就是智能处理的应用。
当然，在这种应用中，对处理复杂性和所需技巧也就要求较高，而可开发的并行程度显然也是较高的。在21世纪这种应用将逐步成为主流。

与数据处理及信息处理主要面向数据世界不同，知识处理与智能处理主要是面向现实世界。在21世纪的高度信息化社会中，如何能够像人类大脑那样，以灵活（柔性）方式处理这种实况计算 `Real world computing` 的问题，将是智能处理和柔性信息处理所要研究的主要问题。
### 3. 器件对系统结构发展的影响
计算机所用的基本器件已经从电子管、晶体管、小规模集成电路、大规模集成电路迅速发展到超大规模集成电路，并使用或开始使用砷化镓器件、高密度组装技术和光电子集成技术。==**器件的发展**是计算机换代的两个标志之一，也是推动系统结构和组成前进的**关键因素和主要动力**==。可从以下三个方面看：
- 从器件的功能和使用方法来看：器件的功能和使用方法发生了很大的变化，由早先使用的非用户片，发展到使用现场片和用户片。这种变化影响着系统结构和组成技术的发展。
	> **非用户片**也称**通用片**，其功能是在器件厂生产时确定下来的，计算机设计者只能使用、不能改变器件内部的功能。例如门、触发器、多路开关、加法器、译码器、寄存器、计数器等通用逻辑类器件。==这类器件的优点是通用性好，灵活方便，但集成度难以提高，因而可靠性低==。
	> <b></b>
	> **现场片**是指，用户可根据需要改变器件内部的功能或内容，以适应结构和组成变化的需要。例如，可编程只读存储器 `PROM` 、现场可编程逻辑阵列 `FPLA` 等。它不仅==使用灵活，功能强==，可取代硬联组合网络，还可构成时序网络，加上又是存储型芯片，也可以实现乘法运算和码制转换、函数计算等功能。==其规整性和通用性强，适合于大规模集成==。
	> <b></b>
	> **用户片**则是专门按用户要求生产的高集成度的 `VLSI` 器件。完全按用户要求设计的用户片称**全用户片**。为解决器件厂和整机厂的矛盾，发展的门阵列、门-触发器阵列等为**半用户片**。
	
	通常，**同一系列各档机器可分别用通用片、现场片或用户片实现**——就是同一型号的机器一般也是先用通用片或现场片实现，等到机器比较成熟并取得用户信任后，再改为半用户片或全用户片实现。至于高速机器，一般一开始就用门阵列片甚至用用户片，只有这样才能发挥出单元电路的高速性。
- 从器件在计算机系统中的地位来看：
① **器件的发展使计算机主频速度迅速提高**。早先的计算时间是以 `ms` 为单位，1960年左右是以 `us` 为单位，现在以 `ns` 为单位。几十年来，无论是器件的速度（门、触发器的级延迟，存储器的存储周期等） 、集成度、体积、可靠性、价格等随时间都呈指数型地改进，这就使计算机的性能价格比有了显著的提高。如果没有器件集成度和速度的迅速提高，机器的主频和速度就不能发生数量级上的提高。
② **器件的发展推动了系统结构、组成的发展**。如果器件的可靠性未发生数量级上的提高，是无法使用后面要讲述的流水技术的实现的；如果没有高速、廉价的半导体存储器，则能使解题速度得以迅速提高的高速缓冲存储器 `Cache` 、及早在20世纪60年代初期就已提出的虚拟存储器就无法真正实现；没有可编程只读存储器 `PROM` 器件的出现，早在20世纪50年代初期就已提出的微程序技术，也无法真正得到广泛应用；只有有了高速相联存储器器件，才有相联处理机这种结构的发展，才能推动向量机、数组机、数据库机器的发展。
③ **器件的发展也使系统结构的“下移”速度加快**。大型机的各种数据表示、指令系统、操作系统很快出现在小型机、微型机上。器件的发展为实现多个CPU的分布处理提供了基础。智能终端、智能机的出现也都表明了这点。
④ **器件的发展还促进了算法、语言和软件的发展**。在硬件结构上，由数百个甚至上万个微处理器组成的 `MPP` 系统，有着很高的性能价格比和良好的可扩展性，促使人们为它不断探索研究新的并行算法、并行语言，开发并行处理应用软件和控制并行操作的操作系统软件，使系统的规模和处理速度能随节点处理器数的增加而显著提高。
由 $1024$ 个有着 $100 \textrm{MFLOPS}$ 性能的 `RISC` 微处理器构成的 `MPP` 系统，其最高性能可达 $100 \textrm{GFLOPS}$ ，大大超过巨型向量机的性能，而其造价只有巨型向量机的 $1/5$ 。nCUBE公司1992年6月推出的 `nCUBE2` 由 $8192$ 个微处理器组成，性能达 $\textrm{34GFLOPS}$ 和 $\textrm{0.123TIPS}$ 。到了1995年，推出的 `nCUBE3` ，其性能已达 $\textrm{6.5TFLOPS}$ ，而其价格反而有了显著降低。日本制定的 RWC（真实世界计算）计划准备用 $\textrm{1M(1024×1024)}$ 个微处理器组成 `MPP` 系统，实现高达 $\textrm{125TIPS}$（即 $125$ 万亿条指令每秒）的性能。
- 从计算机系统的设计方法来看：**器件的发展改变了逻辑设计的传统方法**。传统的逻辑设计方法是逻辑化简，力图节省所用门的个数、门的输入端数及门的级数等，以节省功耗、降低成本、提高速度。而==对于现今采用 `VLSI` 器件来说，斤斤计较省几个门只能带来设计周期的延长，组成实现的不规整、故障诊断的困难、机器产量的低下，这些都使成本反而提高==。因此，应当考虑：采用什么样的组成方式，才能发挥 `VLSI` 器件技术发展所带来的好处，以及选用什么样的 `VLSI` 器件，能使机器的性能价格比更高，应当着眼于在满足系统结构所提出的功能和速度的情况下，如何缩短设计周期、提高系统效能，以及能用上大批量生产的通用 `VLSI` 芯片。
当今流行的设计方法，有计算机辅助设计 `CAD` 和设计自动化系统 `DAS` ，支持各种应用的库软件、工具软件相当丰富。
总之，系统结构设计者要密切了解器件的现状和发展趋势，经常关注和分析，新器件的出现和集成度的提高会给系统结构发展带来什么样的新途径和新方向。

软件、应用、器件对系统结构的发展是有着很大影响的，反过来，系统结构的发展又会对软件、应用、器件的发展提出新的要求，促使其有更大的发展。**计算机系统结构设计者不仅要了解结构、组成、实现的关系，还要充分了解掌握软件、应用、器件发展的现状、趋势和发展要求**。只有这样，才能对系统的结构进行有成效的设计、研究和探索。

