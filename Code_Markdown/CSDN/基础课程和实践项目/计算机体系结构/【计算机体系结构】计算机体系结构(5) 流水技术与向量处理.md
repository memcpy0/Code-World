@[toc]

==计算机系统设计者的基本任务是**提高处理机指令的执行速度**，而采取的主要措施是**指令级的并行性**，即**让多条指令同时参与解释的过程**==。常用的有三种方法：
1. 采用流水线技术，称为流水线处理机或超流水线处理机( Super Pipelining)。
2. 在一个处理机中设置多个独立的功能部件，例如，在一个处理机中设置独立的定点算术逻辑部件、浮点加法部件、乘除法部件、访问存储器部件以及分支操作部件等，称为多操作部件处理机或超标量处理机 (Superscalar) 。也可以把超流水线技术与超标量技术结合起来，称为超标量超流水线处理机。
③ 超长指令字( Very Long Instruction Word，VLlW) 技术，在一条指令中设置有多个独立的操作字段，每个字段可以分别独立地控制各个功能部件并行工作。

目前，前两种技术已经相当成熟，已经研制出了多种高性能的超标量和超流水线处理机，而超长指令字技术还在进一步研究中。

本章以介绍流水线技术为主，包括先行控制技术、流水线原理、流水线性能分析，非线性流水线的调度方法、局部数据相关和全局数据相关的处理方法，超标量处理机和超流水线处理机等，最后介绍向量流水和向量处理机。

---
# 5.1 标量流水工作原理
## 5.1.1 指令的重叠解释方式
一条指令的执行过程可以分为多个阶段，具体的分法要根据各种处理机的具体情况和分析过程而确定。一般把一条指令的解释过程分为 3 个 ( 取指、分析和执行)或 5 个 (取指、译码、执行、访存和写回 )阶段。依据 DLX 指令流水方式的五个子过程及功能定义如表 5.1所示。
表 5.1
 
 如果将一条指令的执行过程分为 3 个子过程，当有多条指令要在处理机中执行时，可以有多种执行方式：
### 1. 顺序执行方式
指令的执行过程如图5.1所示。采用顺序执行方式执行 n 条指令所用的时间
为：
T = ∑
n
i = 1 ( t取 指 i + t分 析 i + t执行 i )
如果取指令、分析指令和执行指令的时间都相等，每段的时间都为 t，则执行 n条指令所用的时间为： T = 3 nt。
按照寻址方式和地址字段中的内容形成操作数的地址，并用这个地址读取操作数( MEM)。
采用顺序执行方式的优点是控制简单，容易实现。主要缺点： 一是处理机执行指令的速度慢。只有当上一条指令全部执行完之后，下一条指令才能够开始执行，即在任何时刻，处理机中只有一条指令在执行； 二是功能部件的利用率很低。例如，在取指令和分析指令时，主存储器是忙碌的，但指令执行部件是空闲的，同样，在执行指令时，指令执行部件是忙碌的，但主存储器和指令分析部件等经常是空闲的。
### 2. 一次重叠执行方式
这是一种最简单的重叠方式，即把执行第 k 条指令与取第 k + 1 条指令同时( 时间上重叠)进行。图 5.1 中所示 3 条指令一次重叠执行过程。
如果取指令、分析指令和执行指令的时间都相等，每段的时间都为 t，则执行 n 条指令所用的时间为：
T = (1 + 2n) t

采用一次重叠执行方式的优点主要有两个，一是指令的执行时间与顺序执行相比缩短；二是功能部件的利用率明显提高。缺点是需要增加一些硬件，控制过程也要复杂一些。例如，为了能够在执行第 k 条指令的同时，分析第 k + 1 条指令，必须再增加一个指令寄存器。用原来的指令寄存器存放当前正在执行的第 k 条指令，而新增加的一个指令寄存器存放新取出来的第 k + 1 条指令。
图 5.1 三条指令解释过程比较
### 3. 二次重叠执行方式
为了进一步提高指令的执行速度，可以把取第 k + 1 条指令提前到分析第 k 条指令同时进行，而把分析第 k + 1 条指令与执行第 k 条指令同时进行，把取第 k + 2 条指令与分析第 k + 1 条和执行第 k 条指令同时进行。图 5.1 中所示 3 条指令的二次重叠执行过程。
如果执行一条指令的 3 个过程的时间相等，则执行 n 条指令所用的时间为：T = (2 + n) t
采用二次重叠执行方式能够使指令的执行时间更进一步缩短，这是一种理想的指令执行方式。
上面分析过程只是在非常理想情况下进行的，实际存在许多因素： 资源冲突 ( 如指令的 3 个子过程有可能同时访问主存储器而引起的与主存资源相关 )、数据相关、三个功能部件的执行时间不相等(相互之间需要等待时间 )以及控制流的改变 (如转移指令)等，会使得重叠解释的速度降低，有关这类问题将在后面进行详细分析。

## 5.1.2 先行控制技术
### 1. 先行控制技术原理
先行控制( Look-Ahead ) 技术最早在 IBM 公司研制的 STRE TCH 计算机中采用。目前，许多处理机中都已经采用了这种技术，包括超流水线处理机和超标量处理机等。
先行控制技术的关键是缓冲技术和预处理技术，以及这两者的结合。通过对指令流和数据流的预处理和缓冲，能够尽量使指令分析器和指令执行部件独立地工作，并始终处于忙碌状态，以提高处理器中部件的利用率。同时，先行控制技术也是解决指令重叠解释过程中，取指令、分析指令和执行指令三个部件访问主存冲突的根本办法。
缓冲技术是指在工作速度不固定的两个功能部件之间设置缓冲栈，用以平滑它们的工作速度。缓冲栈包括指令缓冲和数据缓冲，在采用先行控制的处理机中，一般要设立四个缓冲栈，它们分别是先行指令缓冲栈、先行操作栈、先行读数栈和后行写数栈。
预处理技术是把进入运算器的指令都预处理成寄存器—寄存器型指令，它与缓冲技术相结合，为进入运算器的指令准备好所需的全部操作数。
### 2. 先行控制技术的实现
先行控制技术的处理机结构如图5.2所示。
“先行指令栈”实为先行指令缓冲栈( 或称指令缓冲栈 )，由一个指令缓冲寄存器堆和独立的控制逻辑构成。它可以把后续的指令“先行”取出，存放在缓冲栈中，从而为指令分析器分析新的指令做好准备。在处理机内部设置一定容量的指令缓冲栈，把指令分析器所需要的指令事先取到指令缓冲栈中，而不必访问主存储器。这样，就能够使取指令、分析指令和执行指令重叠起来执行。
图 5.2 先行控制结构示意图
只要指令缓冲栈还没有全部充满，它就自动向存储控制器发出取指令的请求。
同样，指令分析器每分析完一条指令也自动向指令缓冲栈发出取下一条指令的请求，指令取出以后就把先行指令缓冲栈中的指令作废。由于指令分析器取走指令的速度和从主存储器中取来指令的速度都是随机的，因此，指令缓冲栈中的指令数目是动态变化的。另外，在有先行指令缓冲栈的处理机中，要设置两个程序计数器，一个是先行程序计数器 PC1，用来指示到主存储器中取指令，另一个是现行程序计数器，它也就是原来意义上的程序计数器 PC，用来记录指令分析器当前正在分析的指令地址。
先行操作栈是对指令分析器提供的指令进行预处理，即将所有指令转换为寄存器—寄存器型指令，以提高执行部件的处理速度。
先行读数栈和后行写数栈是两个数据缓冲栈，由若干个寄存器组成。其作用表现为两个方面：一是与先行操作栈配合，完成指令预处理过程中的操作数的读取； 二是解决指令重叠解释过程中各功能部件同时访问主存而发生的冲突。
从图 5.2 中可知，主存储器的访问源有三个，即先行指令栈、先行读数栈和后行写数栈。在一般处理机中，存储控制器把这三个访问源的优先次序由高到低安排为：后行写数栈、先行读数栈、先行指令栈。因此，先行指令缓冲栈是利用主存储器的空闲时间来取指令的。只要主存储器的频带宽度足够，就能够保证先行指令缓冲栈从主存储器中取到指令。如果指令分析器每次取指令都能够在先行指令缓冲栈中得到，则取指令只需要很短的时间就能够完成，因此，可以把取指令与分析指令合并到一起，从而构成指令的一次重叠执行方式。
先行控制技术实际上是缓冲技术和预处理技术的结合，通过对指令流和数据流的先行控制，使指令分析器和指令执行部件能尽量连续地工作。这里的缓冲部件一般都是采用先进先出的工作方式，如何合理地确定缓冲部件中的寄存器个数，即缓冲深度的设计是一个关键问题。如果缓冲寄存器的个数太少，往往起不到缓冲作用，指令分析器和指令执行部件不能连续地工作。相反，如果缓冲寄存器的个数设置太多，不仅浪费设备，而且控制逻辑也复杂。
由于在缓冲器的输入和输出端，数据( 或指令)流动的速度是动态变化的，要建立一个准确的数学模型来求出各个缓冲器的深度是非常困难的。只能通过一种动态分析方法，得出各个缓冲深度( D) 之间的一般关系如下：
D指缓 ≥D操 作栈 ≥D读数 ≥D写 数
例如，在 IBM 370/165 计算机中，D指 缓 = 4，D操 作 栈 = 3，D读 数 = 2，D写 数 = 1。我国研制的两台大型计算机中，其中一台 D指 缓 = 8，D操 作栈 = D读 数 = 4，D写 数 = 2，另外一台D指 缓 = 12，D操作 栈 = D读数 = 6，D写 数 = 2。
## 5.1.3 标量流水工作原理
只有标量数据表示和标量指令系统的处理机称为标量处理机。标量处理机是一种最通用，也是使用最普遍的一种处理机。

### 1. 从重叠到流水
前述的重叠工作方式实际上是标量流水方式的原型。标量流水实际上是重叠工作方式的进一步发展(或重叠的进一步引伸) 。如果把一条指令的解释过程进一步细分，例如，把取指、分析、执行 3 个过程进一步分成取指( `IF`)、译码( `ID`) 、执行( `EX`)、访存( MEM)和写回( `WB`)5 个子过程，并用 5 个子部件分别处理这 5 个子过程。这样只需在上一指令的第一子过程处理完毕进入第二子过程处理时，在第一子部件中就开始对第二条指令的第一子过程进行处理，随着时间推移，这种重叠操作最后可达到5 个子部件同时对 5 条指令的子过程进行操作。
由于这种工作方式与工厂中的装配流水线相类似，所以称这种工作方式为流水方式。由 5 个部件组成的流水线组成示意图如图5.3所示。
图 5.3 流水线组成示意图
流水工作时，指令或数据从上一级向下一级流动，由流水线中的公共时钟控制，实现同步传送。在物理实现流水线时，各相邻级及输入、输出级都需有锁定 ( Latch)电路，以暂存欲传送的中间结果。另外，要求各个子过程 ( 或功能段) 的处理时间相等，如果各个子过程的处理时间不相等，则流水工作将引起“堵塞”或“断流”，各功能部件的作用不能充分发挥，流水线性能下降。在流水线中执行时间最长的功能段称
为“瓶颈”，当遇到“瓶颈”时，必须采取办法消除，以保证流水线的畅通。
### 2. 流水线的时空图
在分析流水线工作过程和性能计算时经常使用时空图方法。在时空图中，常以横轴为时间轴，表示流水线完成若干个任务所经过的时间； 纵轴为空间 ( 功能段/部件)轴，表示构成流水线的功能段数。根据图 5.3所示 5 个功能段构成的流水线，共完成 n 个任务的流水线时空图如图5.4所示。
由图 5.4 可知，如果一个流水线中每个功能段的延迟时间都相等(Δt)，完成 n 个任务的总时间为：
T = mΔt + ( n - 1 )Δt
该时间分为两部分，一是第一个任务经过流水线的时间，二是剩余( n - 1 )个任务的完成时间。
另外，从流水线的工作状态来看，有三个时间阶段：建立时间、正常工作时间和排空时间。在建立时间和排空时间阶段，流水线中的某些功能部件是处于空闲状态的，只有在正常工作时间阶段，流水线才处于满负荷状态。

图 5.4 流水线时空图

### 3. 流水线的特点
由上介绍可知，在流水技术中，一般具有如下特点：
① 一个流水线通常由若干个功能段组成。
② 每个流水段有专门的功能部件对指令进行某种加工。
③ 各流水段所需时间是一样的，因为各功能段之间及输入、输出级都需有锁定电路，以暂存欲传送的中间结果。
④ 流水线工作阶段可分为建立、正常工作( 满载)和排空三个阶段。
⑤ 在理想情况下，当流水线正常工作后，每隔Δt 时间将会有一个结果流出流水线。
## 5.1.4 标量流水线的分类
从不同的角度，按照不同的观点可以将流水线分成多种不同的种类。
### 1. 按照处理级别分类
按处理级别可将流水线分为指令级、操作部件级和处理机级。
指令级流水则是把一条指令解释过程分成多个子过程，如前面所提到的： 取指、译码、执行、访存及写回 5 个子过程 ( 见图 5.3 )。在采用先行控制器的处理机中，组成先行控制器的各个部件实际上也构成了一条流指令流水线，如图5.5所示，在先行控制器中，一条指令的执行过程被分解为 5 个子过程，每个子过程在一个专用的功能部件中执行。由于各种指令在同一个功能部件中执行的时间往往相差很大，因此，在每一个功能段之间要设置多个缓冲寄存器，以平滑流水线中各个功能部件的操作。
图 5.5 先行控制方式中的指令流水线
操作部件级流水是将复杂的算术逻辑运算组成流水工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化 4 个子过程。
处理机级流水是一种宏流水，其中每个处理机完成某一专门任务。各个处理机处理所得到的结果需存放在与下一个处理机所共享的存储器中，如图5.6所示。
图 5.6 处理机级流水线 (P 为处理机，M 为存储器 )
### 2. 按功能分类
流水线按功能可分成单功能流水线和多功能流水线。
单功能流水线只完成一种功能。如浮点加法或乘法流水线。
多功能流水线则可完成多种功能，它允许在不同时间，甚至同一时间内在流水线内连接不同功能段来实现不同的功能。如 TI-ASC 计算机中的一个多功能运算流水线，共有 8 个功能段，按需要它可将不同的功能段连接起来完成某一功能，如图5.7所示。它可实现定点加、浮点加和定点乘等功能。这种方式虽然能充分利用功能部件，但控制也比较复杂。因此大多数流水计算机主要采用单功能流水线。
### 3. 按工作方式分类
流水线按这种分类方式可分为静态流水线和动态流水线。
在静态流水线中，同一时间内它只能以一种功能方式工作。它可以是单功能的，也可以是多功能的。当是多功能流水线时，即从一种功能方式变为另一种功能方式时，必须先排空流水线，然后为另一种功能设置初始条件后方可使用。显然，不希望这种功能的转换频繁地发生，否则将严重影响流水线的处理效率。

图 5.7 TI-ASC 计算机的多功能流水线
动态流水线则允许在同一时间内将不同的功能段连接成不同的功能子集 (前提条件是功能部件的使用不发生冲突)，以完成不同的运算功能。显然，动态流水线必须是多功能流水线，而单功能流水线则必须是静态的。
### 4. 按连接方式分类
流水线按连接方式可以分为线性流水线与非线性流水线。
在线性流水线中，从输入到输出，对于一个任务每个功能段只允许经过一次，不存在反馈(或前馈) 回路。一般的流水线均属这一类。
非线性流水方式中则存在反馈(或前馈) 回路，因此从输入到输出过程中，一个任务将数次通过流水线中的某些功能段。这种流水线适合于进行线性递归的运算。图5.8 中显示出了这样的一个非线性流水线。S3 的输出可反馈到 S2，而 S4 的输出可反馈到 S1 。这种非线性流水线对输入流水线加工的指令要加以较复杂控制以保证两条或多条指令不会发生对某一功能段的争用。有关调度方法将在后面讨论。
图 5.8 一种非线性流水线
## 5.1.5 标量流水线性能分析
衡量流水线性能的主要技术指标是：吞吐率、效率和加速比。流水线性能指标的计算可用画时空图或直接用公式求解。
### 1. 吞吐率
流水线的吞吐率( Thoughput Rate，TP) 是指单位时间内从流水线中流出的任务(结果) 数。如前所述，由于流水线并不是在任何时刻都满负荷地工作，因此，它又分为最大吞吐率和实际吞吐率。
#### (1) 最大吞吐率
它是指流水线达到稳定状态(正常工作时间内) 可获得的吞吐率。如果流水线中每个功能段的延迟时间都相等 (均为 Δt)，那么，流水线的最大吞吐率为：
TPmax = 1/Δt
也可以理解为，当流水线满负荷工作时，从它的输出端每隔一个单位时间 Δt 就可有一个任务或结果流出。
如果每个功能段的延迟时间不相等，则最大吞吐率的表达式为：
TPmax =1 max n i = 1 {Δti }
流水线中延迟时间最大的功能段称为流水线中的瓶颈。消除瓶颈的基本方法有两种：
一是将瓶颈子过程进一步细分成若干个子过程，使每一个子过程与其他子过程时间相等。如图5.9( a)所示为一带有瓶颈部件的流水线，其中功能部件 3 为瓶颈。
将瓶颈子过程再细分后的流水线如图5.9( b )所示。
二是在瓶颈段，并联设置多套功能段部件，使它们轮流工作。当瓶颈子过程无法再细分时，可采取此方法消除流水线中的瓶颈，如图5.9( c)所示。
#### (2) 实际吞吐率
以上所述是流水线在连续流动时可达到的最大吞吐率。实际上，由于流水线在开始时有一段建立时间，结束时有一段排空时间，以及由于各种相关因素使流水线无法连续流动，所以，实际吞吐率总是小于最大吞吐率。


图 5.9 消除瓶颈的两种方法

设流水线由 m 个功能段组成，每段的延迟时间为 Δti 。连续处理的任务数为 n,则流水线实际吞吐率的表达式为：
TP =完成的任务数 n 完成 n 个任务的时间 = 完成的任务数 n
第一个任务的流出时间 + ( n - 1 )个任务的完成时间

以下分两种情况讨论流水线的实际吞吐率：
第一种情况是各功能段的延时时间相等，即 Δti =Δtj ( i，j = 1，2，⋯，m)。完成 n个任务的时间为：
T = mΔt + ( n - 1)Δt
实际吞吐率为：
TP =nmΔt + ( n - 1)Δt = 1 Δt(1 + m - 1n) = TPmax 1 + m - 1 n
由此可见，实际吞吐率不仅总是小于最大吞吐率，且只有当 nm m，即当输入的任务(或指令) 数足够多时，实际吞吐率才能接近最大吞吐率。
第二种情况是各功能段的延迟时间不相等，即 Δti≠Δtj ( i，j = 1，2，⋯，m)。并设瓶颈功能段的延迟时间为Δtj 。则完成 n 个任务的时间为：
T = ∑ m i = 1 Δti + ( n - 1 )Δtj
实际吞吐率为：
TP =n ∑  m i = 1 Δti + ( n - 1)Δtj
### 2. 效率
流水线的效率( Efficiency)是指流水线中的各功能段 (或设备 ) 的利用率。由于流水线存在建立时间和排空时间，因此各功能段的设备不可能一直处于工作状态，总有一段空闲时间。效率的表达式一般用流水线各功能段处于工作时间的时空区与流水线中各段总的时空区之比。即为：
E = n 个任务占用的时空区 m 个功能段总的时空区
同样，对于流水线的效率也有两种情况：
当各功能段的延时时间相等时，流水线的效率为：
E = mnΔt m T = nΔt T  = TPΔt
式中，分母 mT 是时空图中 m 个功能段和流水总时间 T 所围成的面积，分子 mnΔt 是时空图中 n 个任务实际使用的面积。因此，从时空图上看 (参见图 5.4 )，只有当 n m m 时，E 才趋于 1。
对于线性流水且每段经过时间相等时，流水线的效率是正比于吞吐率的，当然，对于非线性流水或线性流水各段经过的时间不等时，这种成正比的关系就不存在了，此时应通过画实际工作的时空图才能求出吞吐率和效率。
当各功能段的延时时间不相等时，流水线的效率为：
E = n∑ m i = 1 Δti m ∑ m i = 1 Δti + ( n - 1)Δtj
### 3. 加速比
加速比(Speedup Ratio)是指采用流水方式后的工作速度与等效的顺序串行方式的工作速度之比。对 n 个求解任务而言，若用串行方式工作需要时间为 T1，而用 m 段流水线来完成同一任务所需要时间为 T 2，则加速比为：
Sp = T1 T2
当各功能段的延时时间相等时，流水线的加速比为：
Sp = nmΔt mΔt + ( n - 1 )Δt = m 1 + m - 1 n
当 nm m 时，有 Sp = m，显然要获得高的加速比，流水线段数 m 应尽可能取大，即应加大流水深度。
如果各功能段的延时时间不相等，流水线的加速比为：
Sp =n∑mi = 1 Δti ∑ m i = 1 Δti + ( n - 1)Δtj
### 4. 流水线性能分析举例
例 5.1 带有瓶颈部件的 4 功能段流水线如图5.10所示。在该流水线上分别
连续输入 3 条指令和 30 条指令时，求吞吐率、效率和加速比。
图 5.10 4 功能段流水线
求此题有两点值得注意：一是流水线中各个功能部件的执行时间不相等，即流水线中有“瓶颈”存在；二是连续输入 30 个任务时，由于任务数较多不能用画时空图的办法。下面用两种方法分别求解，即对于连续输入 3 个任务，用画时空图的方法求解，而连续输入 30 个任务时直接按照定义(即用公式法) 求解。
对于连续输入 3 个任务，画出的流水线工作示意图如 5.11所示。由图中可求出流水线实际吞吐率、效率和加速比分别如下：
TP =完成 3 个任务 完成 3 个任务共需用 14Δt = 3 14Δt E =
n 个任务占用的时空区
m 个功能段流水总时空区 = 3 个任务×每个任务需 8Δt
4 个功能段×总时间 14Δt = 3×8Δt 4×14Δt≈42.86%
Sp = 串行方式工作时间
流水线方式完成同一任务时间 = 3 个任务×每个任务需 8Δt
14Δt= 3×8Δt 14Δt ≈1.71
当连续输入 30 个任务时，先计算出流水线完成 30 个任务的总时间为：
T = 第一个任务经过时间 + ( n - 1) 个任务的流出(完成) 时间
= 各功能部件延迟时间和 + ( n - 1) ×瓶颈部件的延迟时间
= 8Δt + ( 30 - 1) ×3Δt
= 95Δt
图 5.11 连续输入 3 个任务时工作示意图

实际吞吐率、效率和加速比如下： TP =
完成 30 个任务 完成 30 个任务共需总时间 = 30
8Δt + 29×3Δt =30 95Δt
E = 完成 30 个任务×每个任务需 8Δt
4 个功能段×完成任务的总时间 95Δt = 30×8Δt
4×95Δt≈63.16 % 
Sp =串行方式工作时间
流水线方式完成同一任务时间 = 30 个任务×每个任务需 8Δt
95Δt  = 30×8Δt
95Δt ≈2.53

【例5.2】有一双功能的静态流水线如图5.12所示。功能段 1→5→6 组成加法流水线，1→2→3→4→6 组成乘法流水线。每功能段延时时间为 Δt。求在流水线上 执行 Π 4 i = 1 ( ai + bi ) 的吞吐率和效率。(设数据巳从主存中取出，输出数据可直接返回输入)
图 5.12 具有双功能的静态流水线
解题时应注意以下几个问题：
① 由于此题涉及多个问题，如流水线的功能切换，输入的任务数不是很明确，如何组织任务的输入才能使流水线的工作效率最高，等等。因此，这类题型只能用画时空图的方法求吞吐率和效率，而不能直接用公式法。
② 根据题意，必须先按 1，5，6 组成加法流水线做完全部加法，然后再将流水线功能切换到 1，2，3，4，6 做乘法(解题时功能切换时间一般忽略不计) 。
③ 做加法时可连续输入 4 个任务，直至完成所有加法。而在做乘法时应注意最后一个乘法任务必须等待前两个任务结果流出 (两操作数均输出) 以后，才能返回输入端而进入流水线(中间结果返回输入端时，一般不计返回时间)。
解：流水线工作时空图如下( 如图5.13所示) ：
图 5.13 双功能静态流水线工作时序图
由时空图可见，共在 17Δt 时间内输出 7 个任务 ( 结果 )，因此该流水线的实际吞吐率为：
TP = 7 个任务数
完成 7 个任务的总时间 =
7 17Δt
E = 完成 7 个任务实际占用的时空区 6 功能段的总时空区
= 4×3Δt + 3×5Δt   6×17Δt
≈26.5 %

---
# 5.2 标量流水中的障碍及控制
要使流水线具有较大的吞吐率、效率和加速比，必须设法使流水线能畅通流动，而不能发生断流。但在通常情况下，由于在流水过程中会出现以下的三种相关 ( 冲突)，使得流水线要实现不断流非常困难，这三种相关是资源或结构相关、数据相关和控制相关。
假定流水线由 5 个功能段组成，它们分别为取指令 ( IP)、指令译码 ( `ID`)、访存有效地址计算或指令执行( `EX`)、访存取数( MEM )以及将结果写回寄存器堆( `WB`)。

在执行各种不同指令时，各段所完成的操作如下：当指令为 ALU 指令时，段 1 取出指令后，段 2 就可进行译码并由寄存器堆中读出操作数，段 3 进行执行，段 4 不做任何操作，段 5 将运算结果写回寄存器堆。
当指令为 LOAD 或 STORE 指令时，段 1 取指令，段 2 进行译码及读寄存器堆，段 3 进行访存有效地址计算，段 4 进行访存，若为 LOAD 指令，则将自存储单元读出的操作数存入数据寄存器，若为 STORE 指令，则将数据寄存器内容写入相应的存储单元，段 5 将数据寄存器内容写入寄存器堆。
当指令为 BRANCH 时，段 1 取指令，段 2 进行译码及读寄存器堆，段 3 将生成转移目标地址，并形成比较条件码，段 4 判条件是否成立，若条件成立便将转移目标地址送往 PC，段 5 不进行操作。(参见表 5.1 )
所谓相关，是指在一个程序中的指令间存在某种关联，这种关联会影响到指令的重叠或流水方式的正常执行。按照相关影响范围的大小，可分为局部性相关和全局性相关两类。下面具体讨论这些相关对流水线工作的影响及处理方法。
## 5.2.1 局部性相关及处理
局部性相关是指相关只发生在相邻或相近的几条指令之间，影响的范围是“局部性”的，它包括主存资源相关和寄存器数据相关。
### 1. 主存资源相关
主存资源相关是指，当有多条指令进入流水线后在同一机器周期内争用同一功能部件所发生的相关( 冲突 )。从图 5.14 中可以看出，在时钟 4 时，第 i 条的 MEM段和第 i + 3 条的 `IF` 段都要访问主存储器。通常，由于数据和指令存放在同一存储器中，且只有一个访问端口，这样便会发生这两条指令争用主存储器资源的相关冲突。
 
图 5.14 两条指令同时访问主存而引起的资源冲突相关
解决主存资源冲突的方法有：
① 将后续指令(i + 3)推迟一拍进入流水线，这样必然导致流水线的性能下降。
② 重复设置一个存储器，使指令和数据分别存放在不同的存储器中。如果不能做到重复设置主存储器，则可以设置双 `Cache` 结构，即一个指 令 `Cache`，一 个数据`Cache`。
③ 采用先行控制技术，或在处理器内部设置指令缓冲队列 (指令缓冲栈，简称缓指)。
应该指出的是，图 5.14 中两条指令同时访存造成资源相关冲突是由于第 i 条为LOAD 指令的缘故，若不是 LOAD 指令，则由于在 MEM 段不访存，就不会发生对存储器的争用。
### 2. 寄存器数据相关
这是由于流水线中的各条指令的重叠操作使得原来对操作数的访问顺序发生了变化，从而导致了数据相关的冲突。这往往发生在后继指令所需的操作数刚好是前一指令运算结果的情况下。例如，如果流水线要执行以下的两条指令：
ADD R1，R2，R3 ； ( R2 ) + (R3 )→R1
SUB R4，R1，R5 ； (R1 ) - ( R5 ) →R4
两条指令在流水线中的执行情况见图 5.15。
从图 5.15 中可以看出，在时钟 5 时加法指令 ADD 方可将运算结果写回寄存器堆中的 R1，但后继的减法指令 SUB 在时钟 3 时就要从 R1 中读出数据。正常的读写顺序是，先由 ADD 指令写入 R1，再由 SUB 指令来读 R1 。在非流水线的顺序执行时，这种写读的先后关系即先写后读，是自然维持的。在流水线中时，由于重叠操作缘故，使读写的先后关系发生了变化。如果不采取相应措施保持原来这种写读的先后关系，就会使操作的结果出错。
 
图 5.15 两条指令发生了 R1 的先写后读 ( `RAW`) 数据相关
解决这种数据相关的方法：
① 推迟后续指令进入流水线。即遇到数据相关时，就停顿后继指令的运行，直至前面指令的结果已经生成。
② 采用定向技术，又称为旁路技术或相关专用通路技术，如图5.16所示。
需要说明的是，对于图 5.15所示的两条指令，由于第一条 ADD 指令是在时钟 3结束时才有运算结果，而第二条指令 SUB 也是在时钟 3 的一开始就需源操作数，这一内部定向传送是无法实现的。下面举出能够实现定向传送的 5 条指令解释过程，如图5.17所示。

图 5.16 采用定向技术解决寄存器数据相关

 
图 5.17 定向传送 R1 的值到 SUB，AND 和 OR 指令
由图 5.17 可以看出，第一条指令 ADD 将向 R1 寄存器写入操作结果，后继的 4条指令中都要使用 R1 中的值作为一个源操作数。显然，这样就出现了前述的 `RAW`数据相关。在 `WB` 时钟段(时钟 5 )时第一条指令才将结果写入 R1，而后继的指令除XOR 外，都需在此之前使用 R1 中的内容。若采用后推法则会使流水线停顿 3 拍。
实际上，ADD 的结果在时钟 3 的末尾处已经形成，如果设置专用通道将此产生的结果直接送往需要它的 SUB，AND 和 OR 指令的 `EX` 段，就可使流水线不发生停顿。
但是，对于这种情况必须要对 3 条指令进行定向传输操作。为了减少这种定向传送操作的次数，可将 `ID` 段中的读寄存器操作安排在时钟的后半部分，而将 `WB` 中的写寄存器操作安排在前半部分，这样就可以将 OR 指令的定向传输操作取消了。
推迟后续指令的执行和采用定向传送技术是解决数据相关的两种基本方法。前者是以降低速度为代价，基本上不需增加设备； 后者是以增加设备为代价，使指令解释速度不下降。可以看出，若相关的概率较低，就不宜采用定向技术，节省了设备，指令解释效率也不会明显下降。
根据指令间的对同一寄存器读和写操作的先后次序关系，数据相关冲突可分为读与写(`RAW`)、写与读(`WAR`)和写与写 (`WAW`) 三种类型。例如，程序中有 i 和 j 两条指令，i 指令在前，j 指令在后，则三种不同类型的数据相关的含义为：
① 读与写(`RAW`)相关： 若顺序指令 i(写) 先于指令 j(读) 对同一寄存器访问，由于异步流动可能使得指令 j 先于指令 i 之前执行。
例如： MUL R1，R2
； ( R1 ) × (R2 )→R1
ADD R3，R1
； ( R1 ) + (R3 )→R3
两条指令在寄存器 R1 上出现了先写后读数据相关。
② 写与读(`WAR`)相关： 若顺序指令 i(读) 先于指令 j(写) 对同一寄存器访问，由于异步流动可能使得指令 j 先于指令 i 之前执行。
例如： MUL R1，R2
； ( R1 )× (R2 )→R1
MOV R2，# 00 H ； 0→ R2
两条指令在寄存器 R2 上出现了先写后读数据相关。
③ 写与写 (`WAW`)相关：若顺序指令 i(写) 先于指令 j( 写)对同一寄存器访问，由于异步流动可能使得指令 j 先于指令 i 之前执行。
例如： 
MUL R1，R2
； ( R1 )× (R2 )→R1
MOV R1，# 00 H ； 0→ R1
两条指令之间出现了寄存器 R1 上的写与写相关。
上述的三种数据相关，在按序流动的流水线中，只可能出现 `RAW` 相关。解决这种相关，通常采用上述内部定向传送方法来解决。在异序( 乱序)流动流水线中，则由于允许后进入流水线的指令超过先进入流水线的指令而先流出流水线，那么既可能发生 `RAW` 相关，还可能发生 `WAR` 和 `WAW` 相关。
## 5.2.2 全局性相关及处理
全局性相关是指进入流水线的转移指令(尤其是条件转移指令) 与其后续指令之间存在相关。统计表明，转移指令占总指令的 1/4 左右。因此，与数据相关相比，它会使流水线丧失更多的性能。当转移发生时，将使流水线的连续流动受到破坏。当执行转移指令时，依据是否发生转移，它可能将程序计数器 PC 内容改变成转移目标地址，也可能只是使 PC 加上一个增量，指向下 一条指令的地址。由于通常要 在MEM 段末尾才会使 PC 内容发生改变，如图5.18所示。这样就要使流水线停顿 3个节拍，直至 PC 中生成新的地址后才可能取出下一条指令。
由转移指令所造成的流水线性能下降程度，可通过下面的例子来加以说明。
假定所有执行指令中有 25% 的指令为转移指令，进一步假设其中有 2/3 是会发生转移的，由于这些转移发生的指令，使得完成一条指令平均需要：
0.75×1 + 0.25×(1/3×l + ( 2/3) ×(3 + 1) ) = 1.5 周期
这将使流水线的性能降低 33% 。
 
图 5.18 转移指令引起相关时使流水线产生停顿
为了减少因转移指令而引起的流水线性能下降，可采用一些如下的方法进行处理。
### 1. 猜测法
对于条件转移指令，其执行情况必存在两个分支，即转移成功和转移不成功分支。对于流水方式执行的指令，可采用猜测法进行处理。
设程序中第 i 条指令为条件转移指令，其一个分支是 i + 1，i + 2，⋯，按原来顺序执行，为转移不成功分支。另一个分支是 p，p + 1，⋯，为转移成功分支。如图5.19所示。
图 5.19 用猜测法处理条件转移指令
使用猜测法处理条件转移指令应注意以下几个问题：
#### (1) 分支的选择
对于条件转移指令，猜选哪个分支好呢 ?如果两个分支概率相近时，宜选 i + 1 不成功转移分支。这是因为它已预取进(指令缓冲器)，可以很快地从中取出进入流水线而不必等待。如果猜选成功转移分支，指令 p 很可能不在(指令缓冲器) 中，需花较长时间访存去取，使流水线实际上断流。IBM 360/91 猜选的就是转移不成功分支。
现假设指令 i 所用条件码是在 i + 4 流入流水线时才建立的，若条件码是对应于转移不成功分支就猜对了，可继续流下去； 若条件码是对应于转移成功分支就猜错了，这时需对 i + 1，i + 2，i + 3，i + 4 已有的解释作废，重新回到原分支点，沿转移成功分支去解释 p，p + 1，⋯，使流水线的吞吐率和效率都下降。但是，只要猜测法猜对的机会占大多数，流水线的吞吐率和效率就会比不用猜测法要高得多。
#### (2) 提高猜测准确率
当转移的两个分支概率不均等时，宜猜高概率分支。那么转移概率的值如何确定呢 ? 可采用静态及动态两种方法。静态方法不考虑转移历史，而动态方法考虑了转移历史，因而有较高的准确率。一种具有较高猜准率的动态方法是考虑以前两次转移的历史，如图5.20所示的那样，图中每个转移状态用 2 位二进制位表示。11 和10 表示转移发生，00 和 01 表示转移不发生。从一个状态变到另一个状态时，若为不转移，用 0 表示； 若为转移，用 1 表示。在水平方向发生状态变化时，将使低位状态位发生变化，如从 11 变为 10 或从 l0 变为 11 ；而在垂直方向发生状态变化时，将使高位状态位发生变化，如从 10 变为 00，或从 01 变为 11。这种方法，仅当两次连续猜错
时，预测状态才会发生改变。如从 11 状态变为 10，再变为 00。这种方法猜准率经在`RISC` 机上测试可高达 83%。
图 5.20 转移预测状态图
#### (3) 现场恢复
采用猜测法时应能保证猜错时可恢复分支点处原先的现场，以便流水线的正常执行。处理此问题一般有三种方法。第一种方法是使计算机沿猜测分支解释指令时，应当与正常情 况下的指令解释不同。例如，假设 转移指令之前的某条 指令是(R1 ) + ( N) →N，即对某存储单元 N 写入操作结果，当沿着不成功分支继续流动的 i+ 4 之前的某指令修改了 N 单元的内容后，流水线又返回转移成功分支执行，这时，从 N 单元读出的便是修改后的错误值。在 IBM 360/91 中采取对指令只译码和准备好操作数，在转移条件码出现之前不进行运算。第二种方法是让它运算完但不送回运算结果，有的计算机就是如此。以上介绍的是早期计算机所用的这两种方法，使用起来不是很方便，因为若猜对后还要让这些指令继续完成余留的操作。第三种方法是采用后援寄存器，把可能被破坏的原始状态都用后援寄存器保存起来，一旦猜错，就取出后援寄存器的内容来恢复分支点的现场。这些后援寄存器实际上不是单独为流水线设置的，因为为提高系统可靠性，实现指令复执、程序卷回，本来就已设置了这些后援寄存器。一般猜对的概率要高，猜对后既不用恢复，也不用再花时间去完成余留的操作。因此，采用后援寄存器法的实现效率会更高一些。
### 2. 加快和提前形成条件码
提前形成条件码，以便提前知道程序流向哪个分支，会有利于流水计算机简化对条件转移的处理，这可以从两方面采取措施。
一方面是加快单条指令内部条件码的形成。例如，乘、除结果是正、负或零的条件码可在运算前形成。只要两个操作数符号位相同就是正，符号位相反就为负。相乘时有一个操作数为零或除法时被除数为零，则结果为零。由于相乘、相除操作时间较长，条件码提前形成对加速条件转移的处理大有好处。Amdahl 470V/6 就是在具体运算前就能将运算结果的条件码送到指令分析部件。
另一方面是在一段程序内提前形成条件码，这特别适合于循环型程序在判断循环是否继续时的转移情况。例如 FORTRAN 语言中的 DO 循环，每当执行到循环终端语句时，总要对循环次数减 1，如果结果为 0 就跳出循环，否则转回去继续执行循环体，这通常用减 1 (DEC)和等于零条件转移 (BE) 两条指令来实现。为了使等于零条件转移指令(BE )的条件码能提前形成，可以将减 1 指令( DEC) 提前到与其不相关的其他指令之前，甚至提前到循环体开始时进行。这样，执行到 BE 指令时，减 1 指令的条件码早已形成，马上就能知道是否需要转移，不至于因等待条件码形成而使流水线的吞吐率和效率下降。
### 3. 加快短循环程序的处理
加快短循环程序的处理是将长度小于指令缓冲器容量的短循环程序整个一次性地放入指令缓冲器内，并暂停预取指令。这样有两个好处： 一是暂停预取指令后，避免执行循环时由于指令预取导致指令缓冲器中需循环执行的指令被冲掉，减少了访主存重复取指的次数；二是由于循环分支概率高，因此，让循环出口端的条件转移指令恒猜循环分支，减少因条件分支造成流水线断流的机会。例如，在 IBM 360/91 中设置了“向后 8 条”检查，即转向去址往回走且与条件转移指令之间相隔不超过 8 条时，将其间的指令全部移入指令缓冲器并停止预取新指令。并为上述第二点设置了“循环方式”工作状态。采取这些措施后可使循环时流水加快 1/3～3/4。
有的计算机还采取在顺序执行时，让预取的指令既放入正常使用的指令缓冲器，也放入转移目标指令缓冲器中。一旦检测出是循环时，可把转移目标指令缓冲器的内容作为短循环程序控制用，省去了第一次循环时，重新从主存中取此短循环程序中指令的操作开销。还有的机器允许将这两种指令缓冲器连接起来使用，使更大的循环程序也能得到加快处理。
### 4. 采用延迟转移技术
延迟转移技术是一种有效的软件手段，以减少由于控制相关而造成的流水线性能下降。实现时不必增加硬件，在编译生成目标指令程序时，将转移指令与其前面不相关的一条或多条指令交换位置，让成功转移总是延迟到这一条或多条指令之后再执行。这样可使转移造成流水性能损失减少到 0。如图5.21所示，是将转移指令之前的一条与转移指令不相关的加法指令调入到延迟槽中。
图 5.21 转移指令延迟槽的调度方法之一
## 5.2.3 流水线的中断及处理
中断会引起流水线断流，但出现概率比条件转移的概率要低得多，且又是随机发生的。所以，流水计算机处理中断主要是如何处理好断点现场的保存和恢复，而不是如何缩短流水线的断流时间。
假若在执行指令 i 时有中断发生，断点本应是在指令 i 执行结束，指令 i + 1 尚未开始执行的地方，但流水机器是同时解释多条指令，指令 i + 1，i + 2，⋯，可能已进入流水线被部分解释。对于异步流动流水线，这些指令中有些可能已流到指令 i 的前面去了。
流水线中对于中断处理的方法有不精通断点和精通断点法。
- 所谓不精通断点法处理，是指不论指令 i 在流水线的哪一段发生中断，未进入流水线的后续指令不再进入，已在流水线的指令仍继续流完，然后才转入中断处理程序。这样，断点就不一定是 i，可能是 i + 1 或 i + 2，i + 3，⋯，即断点是不精确的。仅当指令 i 在第 1 段响应中断时，断点才是精确的。早期的流水机器，如 IBM 360/91，为简化中断处理采用不精确断点法。不精确断点法不利于编程和程序的排错。
- 所谓精通断点法处理，是指不论指令 i 是在流水线中哪一段响应中断，给中断处理程序的现场全都是对应 i 的，i 之后流入流水线的指令的原有现场都能恢复。精确断点法需设置很多后援寄存器，以保证流水线内各条指令的原有现场都能保存和恢复。后来的流水机器多数采用精确断点法，如 Amdahl 470V/6。

---
# 5.3 流水线的调度技术
本节首先介绍非线性流水线的调度方法 (策略)，这种方法主要是借助软件对指令执行的顺序进行调度，以减少流水线中存在功能段冲突而引起的流水线的停顿时间。这种方法也称为静态调度。然后介绍流水线的更高级调度方法，即采用硬件重新安排指令的执行顺序，以减少流水线的停顿时间。
## 5.3.1 非线性流水线的静态调度技术
在线性流水线中，每个任务执行时仅一次通过各流水段。当流水线中各功能段的执行时间都相等时，每拍( 单位时间)都可流入一个新的任务，它们不会争用同一个流水段。但对非线性流水线来讲，由于每个功能段之间存在有前馈或反馈通路，因此一个任务在执行的过程中，可能会多次通过同一流水段，如果仍要向流水线每隔一拍送入一个新任务，就会发生几个任务同时争用同一流水段的现象，这就是功能段的使用冲突。
为了避免这种功能段冲突，必须解决以下两个问题： 一是当前一个任务流入流水线后，后继任务需要间隔多少拍进入流水线，才不会引起功能部件冲突。二是由于间隔拍数可能有多个方案，如何确定最佳的送入新任务的间隔拍数，以使流水线有较高的吞吐率和效率。这就需要对流水线作适当的调度。
流水线调度采用了 1971 年 Dav`ID`son 等人提出的二维预约表进行。

若一个非线性、单功能流水线，由 S 段组成，每个任务流过流水线需 N 个时钟周期( t1，t2，⋯，tn )，以段为纵坐 标，时间为横 坐标，就可画 出此流水 线的预约 表，如图 5.22所示。图中每一行代表一个段，每一列表示相应的时钟周期。若某个任务在周期 ti 需要使用 Si 段进行处理，则在行 Si 和列 ti 的相交处以“×”表示。

图 5.22 一个 5 功能段非线性流水线预约表
根据预约表可较容易地推算出一个任务执行时，各段所需的间隔周期拍数及最佳调度方案(策略) 。下面以图 5.22 预约表为例，介绍其分析过程：
1. 根据预约表写出禁止表 F
对于功能段 1，两任务禁止间隔的拍数为 8 (这只需要将同一行中相互间隔的“√”处所对应的拍数值相减即可) ； 对于功能段 2，两任务禁止间隔的拍数为 1，5，6；对于功能段 3，两任务禁止间隔的拍数≥8； 对于功能段 4，两任务禁止间隔的拍数为1； 对于功能段 5，两任务禁止间隔的拍数为 1。
将各段上所有的这种间隔汇集起来，就构成一个禁止表 F = {1，5，6，8}。
禁止表说明，要想使流入的任务不发生同时争用功能段的情况，相邻两个任务进入流水线的间隔拍数就一定不能为 1，5，6，8 拍。
2. 根据禁止表 F 写出冲突向量 C
冲突向量是用二进制数表示的，二进制的位数为禁止间隔的最大拍数。本例为8，所以冲突向量的位数为 8 位二进制 C = ( C7 C6 ⋯C1 C0 )。另外，冲突向量 C = ( C7 C6 ⋯C1 C0 )的定义为： Ci = 0 表示允许间隔 i 拍流入后续任务； Ci = 1表示禁止间隔 i 拍流入后 续 任 务。根 据 上 述 预 约 表 所 得到 的 禁 止 表 F，可 形 成 冲 突 向 量 C = (10110001)，称为原始冲突向量。
3. 根据原始冲突向量 C 画出状态转移图
状态转移图的求解方法是，由当前的冲突向量 Ci 求出下一冲突向量 Cj 。其算符表达式为： Cj = SH R ( k ) (Ci ) ∨C，式中 C 为原始冲突向量，SH R
( k ) ( Ci ) 表示将当前冲突向量 Ci 右移 k 位，且高位补零。
例如，在本例中由 C 求 C1 ：将 C = (10110001) 右移 2 位(由 C 可知第二个任务与第一个任务间隔 2 拍时可以进入 )，高位补 0，并得到 C1 = ( 00101100 ) ∨( 10110001 ) =( 10111101 )。由 C1 可知，第三个任务与第二个任务之间可以间隔的拍数分别为 2 和7，因此，按 上 述 方 法，将 C1 右 移 2 位，高 位 补 0，并 得 到 C2 = ( 00101111 ) ∨(10110001) = (10111111) 。由 C2 可知，后继任务与第三个任务之间只能间隔 7 拍，
将 C2 右移 7 位，高位补 0，再与 C 做逻辑加后，得到的向量与原始向量 C 相同。到此为止，我们仅取 C 间隔 2 拍时的分析情况。还需完成 C 分别取间隔 3，4 和7 拍时，状态图的转移情况，分析方法与上述方法完全相同，其状态转移图如图5.23所示。
4.根据状态转移图写出调度策略
状态转移图中的任何一个闭合回路即为一个调度策略，如 ( 2，7)，表示第二个与第一个间隔 2 拍，第三个与第二个间隔 7 拍，第四个与第三个间隔 2 拍，第五个与第四个间隔 7 拍，⋯，如此循环调度指令，便不会发生功能段冲突。还有可能的调度策略以及它们的平均延迟拍数如表 5.2所示。

图 5.23 非线性流水线的状态转移图
最后，根据列出的所有调度方案和平均延迟拍数，找出平均延迟最小的最佳调度策略。由表中可见，采用先隔 3 拍，再隔 4 拍轮流往流水线输入任务的调度法为最佳。因为，此时平均每隔 3.5 拍即可流入一个任务，从而达到最高吞吐率。当然这是一种不等间隔的调度方案，相应的控制要复杂些。为了简化控制也可采用等间隔调度，本例中只有一种，即每隔 7 拍输入一个任务，此时吞吐率就比最佳的调度方案降低了 1/2。
表 5.2
各种调度策略及平均延迟拍数

## 5.3.2 流水线的动态调度技术
流水线的动态调度具有如下的优点：
● 能处理某些在编译时无法知道的相关情况；
● 能简化编译程序设计；
● 使代码有可移植性。
这种方法的主要缺点是相应的硬件较为复杂。
### 1. 流水线的集中式动态调度
前面讨论的流水线技术在应用时必须要按序启动指令 ( In-order Instruction Issue)，如果一条指令在流水线中发生了停顿，后继指令就不再前进，当功能部件较多时，就会使功能部件出现闲置的情况。要改善这一情况，就应允许流水线中能按无序( Out-of-Order)方式工作。
按这种无序方式工作，从前面讨论中已知将会引起更多的相关冲突。解决这一问题可采用集中式动态调度的方法。这种方法要依靠硬件在程序运行过程中对可能出现的相关情况加以检测，从而可保证流水线中的各个功能部件能最大限度地重叠工作。图 5.24 中示出了这种集中式动态调度方式的框图。
图 5.24 集中式动态调度
这种动态调度方法主要用一个称为状态记录控制器 ( 或记分牌) 的调度部件对流水线中的各个功能部件的工作状态、进入流水线中的各条指令的工作状态、它们所使用的源寄存器和目的寄存器情况等进行集中的统一记录和调度。
在译码阶段，记录控制器根据所记录的状态决定是否将译码后的指令发送给有关功能部件进行处理。其中，主要检查该指令要使用的功能部件是否已被流水线中的其他指令占用，即检查是否有资源使用冲突。该指令的源操作数寄存器是否为其他指令的目的寄存器，或者它所要写入的目的寄存器又正好是前面其他指令所要读出的操作数，或是要写入的目的寄存器，即是检查是否有 `RAW`，`WAR` 和 `WAW` 的数据相关。当发现有任何一种冲突时，便不再启动此指令而将它挂起。经检查没有发现任何冲突的指令便送到相应部件去执行，由执行而引起的状态变化将被登录到记录控制器中。此时，再由后者来判别以前已挂起的指令是否可启动等。这种集中式动态调度方法，早在 20 世纪 60 年代的 CDC 6600 计算机中采用。现在的 `RISC` 机中的超级标量机通常也采用与此类似的方法。
### 2. 流水线的分布式动态调度
在流水机 IBM 360/91 中，采用了另一种动态调度方法，即分布式方法。此调度方法是由日本学者 TOMASULO 在 1967 年提出的，又称为 TOMASULO 调度法。
它采用公共数据总线 CDB 来实现某些相关专用通路连接，并通过给每个浮点数寄存器 FLR 设置一个忙标志来判别指令间所用的数据是否发生数据相关，只要某些FLR 正在使用，就将忙位置 l 表示存在数据相关，一旦使用完成就置成 0。
图 5.25 中示出了 IBM 360/91 的浮点运算部分，它包括了以下主要部件：
① 运算部件。一个加法部件和一个乘除部件。
② 保存站。加法部件中有 A1 ～A3 三个保存站，乘除部件有 M1 和 M2 两个保存站，用来保存当前参加运算的数据。当两个源操作数都到齐且运算部件空闲时，便可进行运算。这些保存站都有称为站号的地址号。它与 FLB 浮点操作数缓冲寄存器统一编址，FLB1 ～6 的编号为 0001～0110，M1 和 M2 编号为 1000 和 1001，A1 ～A3编号为 1010～l100。
③ 指令操作缓冲栈。存放经分析后由指令部件送来的浮点操作指令，译码后，产生相应的控制信号到达各个部件。
④ 浮点操作数寄存器( FLB)。存放由主存预取来的操作数，它作为源操作数使用。
⑤ 浮点数寄存器( FLR)。存放操作数寄存器，运算时，作为另一源操作数，同时也是目的操作数寄存器，即通常操作时有( FLR) + ( FLB)→ FLR，故常会发生数据相关。
因此，在该浮点数寄存器中，给每个寄存器附加一忙位，当它为 1 时，表明该数据已作为操作数使用，另外还有一个标记( 即站号)表示数据由何处送来。 FLR 由 F0 ～F7 组成。
⑥ 存储数据缓冲站( SDB)。用于暂时存放将要写入主存储器的结果数据。也有站号，但单独编号。
⑦ 公用数据总线(CDB)。以上各部件间的连接总线，有 11 个部件可向 CDB 提供信息。它们是 6 个 FLB，3 个加法部件保存站和 2 个乘除部件保存站，而 CDB 则向加法部件和乘除部件的保存站、FLR 浮点寄存器 以及 SDB 存储缓冲站 提供数据。
下面通过一个例子来说明这些部件的使用，以及在运算过程中如何解决数据相关问题。例如，有如下的一串指令：
S1 ： LD F0，FLB1
； (FLB1 ) →F0
图 5.25 IBM 360/91 的浮点运算部件结构框图

可以看到，指令间存在相关性。
S1 译码后，将 F0 的站号置成 0001，向 CDB 表明由 FLB1 读出的内容应送入 F0中。S2 译码后，将 F0 的忙位置 1，表明乘法指令 MD 将使用 F0 中的内容。同时，将M1 中的源 1 寄存器站号置为 0001，表明需由 FLB1 中得到源 1 操作数，将 M1 中的源 2 寄存器站号置为 0010，表明 FLB2 的输出应送到这里作源 2 操作数。此外，还需将 F0 的站号由刚才设置的 0001 改为 1000，以便站号为 1000 的 M1 在得到乘积后经CDB 送回 F0 。一旦结果送到 F0 后，便将 F0 的忙位置 0，以使其他指令可使用 F0 中的值。S3 译码后，将存数缓冲器 C1 的站号置为 1000，表明由乘法产生的乘积应存放到写数缓冲器 C1 中。S4 译码后，将 F0 的站号改为 0011，类似于 S1 的动作。S5 译码后，将 A1 源 2 寄存器站号置成 0100，表明加法指令 ADD 将由 FLB4 处得到源 2 操作数，将 A1 源 1 寄存器站号置成 0011，表明由 FLB3 处得到源 1 操作数，并将 F0 的站号由 0011 改为 1010，表明由加法器保存站 A1 处得到的加法结果应送回到 F0 中。
这种调度方法的特点是：
① 由于为加法器和乘法器部件分别设置了 3 个和 2 个保存站，从而减少了资源使用冲突的机会，仅当这些保存站都处于忙碌状态时，才有可能发生资源使用冲突。
② 调度算法使用保存站，通过 对寄存器重 新命名 ( 改写站 号 ) 自 然地消除 了`WAR` 和 `WAW` 数据相关可能性。
③ 通过对 FLR 寄存器忙位状态的判别，来检测是否存在 `RAW` 数据相关。
④ 借助 CDB 公共数据总线作为专用相关通路，将有关数据直接送往所有需要它的功能部件，而不必先写入寄存器，然后再从此寄存器读出。
这种调度方法是借助 FLR 中的各寄存器的忙标志是否为 1 来判别指令间是否存在 `RAW` 数据相关。借助 CDB 公共数据总线作为相关专用通路，由于这种流水调度是通过分布在各个部件中的站号、忙标志以及 CDB 总线实现的，称为分布式调度。这种方式简化了同时出现的多个相关及多重相关处理，因此，比集中式的调度更加灵活。
### 3. 动态硬件预测转移方法
前面提及的延迟转移方法是在编译阶段完成的，因此，这是一种面向软件的静态方法。这里介绍的方法是在程序运行时，借助硬件来动态地预测转移方向。实际上，这是一种尽早生成转移目标地址的方法，它将过去发生过的转移指令地址以及它的转移目标地址存入一个由类似 `Cache`、称为 `Branch Target Buffer, BTB` 的转移目标缓冲器中。其中，转移指令地址作为标志，供检测用，它的工作原理如下：
将欲取出指令的 PC 值与 `BTB` 中的所有标志作相联比较，若有相符的标志时，便将该项中相应的预测转移目标地址读出，送到 PC 中。当转移条件成立时，便可确认其为有效，马上取转移目标地址处的指令； 否则，便取消送到 PC 中的转移目标地址，并对 `BTB` 中的内容做相应更新。这是一种使用硬件支持来加快生成转移目标地址的方法，在 Intel Pentium 处理器中已被采用。

---
# 5.4 先进的流水技术
一般的标量流水处理机在每个时钟周期最快只能完成( 输出 ) 一条指令，其并行度 `ILP` 小于或等于 1。假设指令流水线的功能段数 k = 4，即它把一条指令的解释过程分解为取指令、分析、执行和写回运算结果 4 个阶段。指令所要执行的功能主要在多功能操作部件中，在执行这一功能段完成。多数流水线处理机的多功能操作部件采用流水线结构。有的简单指令，只要 1 个时钟周期就能够在执行功能段中完成，而比较复杂的指令往往需要多个时钟周期才能够做完。
本节介绍的几种先进的流水技术是： 超标量处理机 (Superscalar Processor ) 、超流水处理机(Superpipelinig Processor)、超标量超流水处理机( Superpipelinig Superscalar Processor) 和超长指令字( Very Long Instruction Word) 。它们的指令并行度 `ILP` 大于 1。
## 5.4.1 超标量流水线技术
### 1. 超标量流水原理
现设有 12 条无任何相关指令，要在 4 功能段 ( 其中，段 1 为 `IF`，段 2 为 `ID`，段 3 为 `EX`，段 4 为 `WB`，)流水的一般标量处理机上执行，共需 15 个时钟周期。在每个时钟周期只能发射一条指令，如图5.26所示。
图 5.26 12 条指令在一般标量处理机上完成时空图超标量流水处理机在每个时钟周期可同时发射两条或两条以上的指令。在这种处理机中设置有多套功能部件。如图5.27 中，在 1 个时钟周期平均发射 3 条指令，其并行度 `ILP` = 3。完成 12 条无相关指令只需 7 个时钟周期。

图 5.27 12 条指令在超标量处理机上完成时空图
### 2. 超标量流水线处理机结构
在有些超标量流水线(简称超标量处理机) 处理机中，操作部件的个数要多于每个周期发射的指令条数。例如，在许多每个时钟周期发射两条指令的超标量处理机中，通常有 4 个或 4 个以上独立的操作部件，在有的超标量处理机中有 16 个独立的操作部件。与单发射处理机相同，多发射处理机的操作部件可以采用流水线结构，也可以不采用流水线结构，每个操作部件的时间延迟可以多于一个时钟周期。超标量处理机的一般结构如图5.28所示。
在超标量处理机中，不仅需要设置多套取指令部件和指令译码部件，而且要判断指令之间确无功能部件冲突，有无数据相关和由于条件转移引起的控制相关等。另外，还要通过一套交叉开关把几个指令译码器的输出送到多个操作部件中执行。因此，超标量处理机的控制逻辑是比较复杂的。
目前，在多数超标量处理机中，每个时钟周期发射 2 条指令，通常不超过 4 条。由于存在有数据相关和条件转移等问题，采用一般的指令调度技术，理论上的最佳情况是每个时钟周期发射 3 条指令。对大量程序的模拟统计结果也表明，每个时钟周期发射 2～4 条指令比较合理。例如，Intel 公司的 i860，i960，Pentium 处理机，Motolora 公司的 MC88110 处理机，IBM 公司的 Power 6000 处理机等每个时钟周期都发射 2 条指令； 美国德州仪器公司 ( TI) 为 SUN 公司生产 SuperSPARC 处理机每个时钟周期发射 1 条指令。
超标量处理机每个时针周期可以平均执行完成多条指令，因此，它的指令级并行度 `ILP` 一般都大于 1。如果一台超标量处理机每个时钟周期发射 m 条指令，则它的指令级并行度 `ILP` 的期望值就为 m。但是，由于数据相关、条件转移和资源冲突等原因，实际的 `ILP` 不可能达到 m，只会小于 m。通常有： 1 < `ILP` < m 。
图 5.28 超标量流水线处理机结构
### 3. 超标量流水调度方法
在超标量处理机中，有多条指令流水线在同时工作，设置有多个能够独立工作的操作部件，因此，必须解决多流水线的调度问题和操作部件的资源冲突问题。而多条流水线的调度问题非常复杂。已经证明，多流水线实现优化调度所需要的代价很大，包括硬件代价和软件代价，通常需要软件 (主要是编译器 ) 和硬件的共同结合才能获得比较好的调度效果。
在有多条流水线同时工作时，指令的发射顺序和完成顺序对提高超标量处理机的性能非常重要。如果指令的发射顺序是按照程序中的指令排列顺序进行的，称为顺序发射( In-order Issue) ； 否则，称为乱序发射 ( Out-order Issue) 。同样，如果指令的完成顺序必须按照程序中的指令排列顺序进行，称为顺序完成 ( In-order Completion ) ；否则，称为乱序完成( Out-order Completion) 。
根据多流水线中指令发射顺序和完成顺序的不同组合，多流水线的调度主要有三种方法，即顺序发射顺序完成，顺序发射乱序完成和乱序发射乱序完成。下面通过一个具体的程序例子来介绍这三种方法。程序如下：
```cpp
`I1` ： LOAD R1，A
；主存单元 A→R1
`I2` ： FADD
R2，R1
； (R1 ) + ( R2 ) →R2
`I3` ： FMUL
R3，R4
； (R3 )×( R4 ) →R3
`I4` ： FADD
R4，R5
； (R4 ) + ( R5 ) →R4
`I5` ： DEC
R6
； (R6 ) - 1→ R6
`I6` ： FMUL
R6，R7
； (R6 )×( R7 ) →R6
```
在这个由 6 条指令组成的程序中，指令 `I1` 和指令 `I2` 之间有先写后读数据相关，指令`I3` 和指令 `I4` 之间有先读后写数据相关，而指令 `I5` 和指令 `I6` 之间除了有先写后读数据相关之外，还有写—写数据相关。另外，在指令 `I2` 和指令 `I4` 之间，指令 `I3` 和指令`I6` 之间有功能部件冲突。因此，在这个由 6 条指令组成的短程序中已经包含了所有可能的数据相关和功能部件冲突，这是一个很有代表性的程序。
下面，以这个典型程序的执行过程为例，分别介绍在超标量处理机中所采用的三种不同的指令调度方法。
方法一 顺序发射顺序完成
图 5.29 是采用顺序发射顺序完成的指令调度方法时，上面这个短程序的指令流水线时空图。6 条指令按照程序中的指令排列顺序从 `I1`，`I2`，⋯，`I6` 分别在流水线 1 和流水线 2 中分 3 个时钟周期发射。
图 5.29 顺序发射顺序完成的指令流水线时空图
由于指令 `I1` 与指令 `I2` 之间有先写后读数据相关，指令 `I2` 在流水线 2 中要等待1 个时钟周期才能从流水线 l 中通过专用数据通路得到数据； 因此，指令 `I2` 在流水线2 中译码( `ID2` )完成之后要等待 1 个时钟周期才能进入浮点加法部件 ( FA1 ) 中执行，在图中用(`RAW`)表示。同样，因为指令 `I5` 与指令 `I6` 之间也有先写后读数据相关，因此，指令 `I6` 也要等待 1 个时钟周期才能进入乘除法部件( MD1 )中执行。
指令 `I4` 在译码完成之后要再等待 1 个时钟周期才能进入浮点加法部件中执行，这是因为在指令 `I2` 和指令 `I4` 都要使用浮点加法器，它们之间有功能部件冲突。

为了维持顺序完成的要求，后发射的指令必须后进入写结果功能段。因此，指令`I3` 在乘除法部件中执行完成之后要延迟 1 个时钟周期进入写结果功能段。指令 `I5`在定点算术逻辑部件中执行完成之后要延迟 3 个时钟周期进入写结果功能段。由于指令 `I5` 和指令 `I6` 之间有写—写数据相关，因此，指令 `I6` 的写结果功能段要延迟 1 个时钟周期。
另外，指令 `I3` 与指令 `I4` 之间虽然有先读后写数据相关，由于 2 条指令在同 1 个时钟周期中发射，这种数据相关自然得到满足。
从图 5.29 中可以看到，采用顺序发射顺序完成的调度方法，6 条指令共用了 l0个时钟周期才完成。其中，除了流水线的装入和排空部分之外，还有 8 个空闲的时钟周期，在图中用阴影部分表示。在这 8 个空闲的时钟周期中，有 5 个时钟周期实际上是为了维持顺序完成才插入的(如果 `I5` 提前完成，那么 `I6` 与 `I5` 之间的 `WAW` 相关就不存在了)。
方法二 顺序发射乱序完成
采用顺序发射乱序完成的流水线时空图如图5.30所示。与图 5.29 中的顺序发射顺序完成相比，相同的地方是 6 条指令按照程序中的指令排列顺序分别在流水线1 和流水线 2 中分 3 个时钟周期发射，所不同的是，指令在流水线中完成的顺序是混乱的。指令的完成顺序与指令在程序中的排列顺序和在流水线中的发射顺序都无关。
图 5.30 顺序发射乱序完成的指令流水线时空图
从图 5.30 中可以看到，只有 2 个先写后读数据相关和一个功能部件冲突，需要流水线空闲等待各 1 个时钟周期。与顺序发射顺序完成调度方法相比，少了 5 个空闲时钟周期。6 条指令总的执行时间为 9 个时钟周期，与顺序发射顺序完成调度方法相比节省 1 个时钟周期。因此，采用顺序发射乱序完成的指令调度方法，流水线的总的执行时间和功能部件的利用率都得到了改善。

图 5.31 是采用乱序发射乱序完成指令调度方法时的指令执行时序( 指令流水线时空图)。
图 5.31 乱序发射乱序完成的指令流水线时空图
方法三 乱序发射乱序完成
由于指令 `I1` 与指令 `I2` 之间有先写后读数据相关，通常，指令 `I1` 要早些发射； 因此，指令 `I1` 于第一个时钟周期在流水线 l 中发射，而指令 `I2` 于第二个时钟周期也在流水线 1 中发射。指令 `I3` 与指令 `I4` 之间有先读后写数据相关，没有功能部件冲突，2条指令可以同时发射。这样，先读后写数据相关也就自然消除了。指令 `I3` 在流水线2 中发射，而指令 `I4` 通过先行指令窗口发射。通常，先行指令窗口除了能够做数据相关性分析和功能部件冲突的检测之外，还应该至少有一套取指令部件和一套指令译码部件。
指令 `I5` 必须在指令 `I6` 之前先发射，这是因为指令 `I5` 与指令 `I6` 之间存在有先写后读数据相关。因此，在第二个时钟周期，指令 `I2` 在流水线 1 中发射，而指令 `I5` 在流水线 2 中发射。先行指令窗口不发射指令。
在第三个时钟周期指令 `I6` 在流水线 l 中发射。
在采用乱序发射时，指令的完成次序必然也是乱序的。从图 5.31 中可以看出，除了流水线的装入和排空之外，已经没有空闲的时钟周期，因此，功能部件得到了充分利用。6 条指令总的执行时间缩短为 8 个时钟周期，与顺序发射顺序完成调度方法相比节省了 2 个时钟周期，与顺序发射乱序完成调度方法相比节省了 1 个时钟周期。
### 4. 超标量流水处理机的性能
为了便于比较，把单流水线普通标量处理机的指令级并行度记做( 1，1 )，超标量处理机的指令级并行度记做 ( m，1 )，超流水线处理机的指令级并行度记做 ( 1，n)，而超标量超流水线处理机的指令级并行度记做( m，n) 。
在理想情况下 N 条没有资源冲突、没有数据相关和控制相关的指令在单流水线普通标量处理机上的执行时间为：
T(1，1 ) = ( k + N - 1 )Δt
其中，k 是流水线的级数，Δt 是一个时钟周期的时间长度。
如果把相同的 N 条指令在 1 台每个时钟周期发射 m 条指令的超标量处理机上执行，所需要的时间为：
T( m，1) = ( k + N - m m )Δt
其中，第一项是第一批 m 条指令同时通过 m 条指令流水线所需要的执行时间，而第二项是执行其余 N - m 条指令所需要的时间，这时，每一个时钟周期有 m 条指令分别通过 m 条指令流水线。
因此，超标量处理机相对于单流水线普通标量处理机的加速比为：
Sp ( m，1) =T(1，1 )
T( m,1 ) = m( k + N - 1) N + m( k - 1)
目前，在许多高性能超标量处理机中已经采用了乱序发射乱序完成的指令调度方法。通常设置有一个存储容量为几条指令到十几条指令的比较小的先行指令窗口，一个比较简单的数据相关性分析部件和一个功能部件冲突的检测机构，一般采用计分牌机制来表示数据相关性和功能部件的冲突。另外，通过优化编译器对指令序列进行重组来共同开发程序中指令级并行性。
## 5.4.2 超流水线技术
在前面介绍的一般标量流水线处理机中，通常把一条指令的执行过程分解为取指、译码、执行和写回 4 级流水线。如果把其中的每级流水线再细分，将每一级分解为两级延迟时间更短的流水线，则 1 条指令的执行过程就要经过 8 级流水线。这样，在 1 个基本时钟周期内就能够取指、译码、执行和写回各 2 条指令。这种在 1 个基本时钟周期内能够分时发射多条指令的处理机称为超流水线处理机。在有些资料上把指令流水线的级数为 8 级或超过 8 级的流水线处理机称为超流水线处理机。
超流水线处理机的工作方式与上一节中介绍的超标量处理机不同，超标量处理机是通过重复设置多个取指、译码、执行和写回部件，并让这些功能部件同时工作来提高指令的执行速度，实际上是以增加硬件资源为代价来换取处理机性能的； 而超流水线处理机则不同，它只需要增加少量硬件，是通过各部分硬件的充分重叠工作来提高处理机性能的。从流水线的时空图上看，超标量处理机采用的是空间并行性，而超流水线处理机采用的是时间并行性。
超流水线处理机的指令执行时空图如图5.32所示。

图 5.32 超流水处理机的指令执行时空图
图中只是超流水线处理机原理上的指令执行时空图，实际上，功能段还要进一步细分，一个功能段要细分为多个流水级，每一个流水级也都有名称。在分解功能段时要根据实际情况，有些功能段分解的流水级数可多些； 例如，图 5.32 中的“译码( `ID`)”功能段，可以再细分为“译码”流水级、“取第一个操作数”流水级和“取第二个操作数”流水级等； 有些功能段分解的流水级数可少些，有的功能段可以不再细分，如“写回”结果功能段一般不再细分。
在早期生产的计算机中，巨型计算机 `CRAY-1` 和大型计算机 CDC-7600 属于超流水线处理机，其指令级并行度 `ILP` = 3。在目前大量使用的微处理器中，只有 SGI公司的 MIPS( Microproccssor Without Interlocked Piped Stages) 系列处理机属于超流水线处理机。MIPS 是除 Intel 公司的 X86 系列微处理器之外，生产量最大的一种微处理器。MIPS 系列的微处理器主要有 R2000，R3000，R4000，R5000 和最近刚投放市场的 R10000 等几种，其中，R4000 是典型的超流水线处理机，其流水操作示意如图5.33所示。
图 5.33 MIPS R4000 处理机的超流水线示意图
图中，`IF` 表示取第一条指令； IS 表示取第二条指令； RF 表示读寄存器堆，指令译码；`EX` 表示执行指令；DF 表示取第一个操作数；DS 表示取第二个操作数； TC 表示数据标志检验； `WB` 表示写回结果。
在一台指令级并行度为 ( 1，n) 的超流水线处理机上，执行 N 条没有数据相关和控制相关的指令所需要的时间为：
T( 1，n) = ( k + N - 1n)Δt
其中，k 是指令流水线的功能段数，或时钟周期数，而不是流水线级数。在一般超流水线处理机中，指令流水线的级数实际应为 kn。上式中的头一项是第一条指令通过指令流水线执行完成所需要的时间，而第二项是执行其余 N - 1 条指令所需要的时间，这时，每一个时钟周期有 n 条指令要在指令流水线中执行完成，也就是每一个流水线周期执行完成 1 条指令。
超流水线处理机相对于单流水线普通标量处理机的加速比为：
Sp (1，n) = T(1，1 )
T(1，n) = n( k + N - 1 )
nk + N - 1
## 5.4.3 超标量超流水线技术
为了进一步提高处理机的指令级并行度，可以把超标量技术与超流水线技术结合在一起，这就是超标量超流水线处理机。
超标量超流水线处理机的指令执行时空图如图5.34所示，它在 1 个时钟周期内要发射指令 m 次，每次发射指令 n 条，因此，超标量超流水线处理机每个时钟周期总共要发射指令 m× n 条。
图 5.34 超标量超流水线处理机的指令执行时空图
在图中，每 1 个时钟周期分为 3 个流水线周期，每一个流水线周期发射 3 条指令，从图中可以看出，每个时钟周期能够发射并执行完成 9 条指令。因此，在理想情况下，超标量超流水线处理机执行程序的速度应该是超标量处理机和超流水线处理机执行程序速度的乘积。

在当今的主微处理器中，只有 DEC 公司的 Alpha 21064 采用的是超标量超流水线结构。
在一台指令级并行度为( m，n) 的超标量超流水线处理机上，连续执行 N 条没有资源冲突、没有数据相关和控制相关的指令所需要的时间为：
T( m，n) = k + N - 1 mn Δt
其中，k 是指令流水线的时钟周期数，而不是流水线级数。例如，在 Alpha 21064 超标量超流水线处理机中，k = 4。Δt 是 1 个时钟周期的时间长度。上式中的第一项是开始 m 条指令通过指令流水线所需要的时间，第二项是执行其余 N - 1 条指令所需要的时间，每一个时钟周期平均执行完成 m× n 条指令，也就是每一个流水线周期平均执行完成 n 条指令。
超标量超流水线处理机相对于单流水线标量处理机的加速比为：
Sp ( m，n) =T(1，1 )
T( m，n) = mn ( k + N - 1)
mnk + N - m
## 5.4.4 超长指令字(VLIW)技术
超长指令字方法是在 1983 年由美国耶鲁大学的 Fisher 教授首先提出的，它与超级标量方法有许多类似之处，但它以 1 条长指令来实现多个操作的元并行执行，以减少对存储器的访问。这种长指令字往往达上百位，甚至上千位。并发操作主要是在流水的执行阶段进行的。
超长指令机的主要特点是：
① 单一的控制流，只有一个控制器，每个周期启动 1 条长指令。
② 超长指令字被分成多个控制字段，每个字段直接独立地控制每个功能部件。
③ 含有大量的数据通路和功能部件，由于编译器在编译时间已考虑可能出现的数据相关和资源相关，故控制硬件较简单。
④ 在编译阶段完成超长指令中多个可并行执行操作的调度。
图 5.35 中示出了一个含有两个存取部件、一个浮点加部件和一个浮点乘部件的VLIW 机。所有功能部件均由同一时钟驱动，在同一时刻控制每个功能部件的操作字段组成一个超长指令字。指令字长度和功能部件数有关。超长指令字的生成是由编译器来完成的，由它将串行的操作序列合并为可并行执行的指令序列，以最大限度地实现操作并行性。下面通过一个例子来说明这种过程。假设要执行以下的赋值语句：
C = A + B，K = I + J，L = M - K，Q = C×K
若按串行操作进行，则其所用的指令序列如图5.36所示。
图 5.35 VLIW 机的结构框图
图 5.36 串行操作指令序列及时钟周期
假设 `LOAD/STROE` 指令以及 FADD 操作需 1 个周期完成，而 FMUL 需 2 个周期完成，则上述的指令串操作共需 14 个周期方可完成。
在超长指令字技术中，常采用两种压缩技术。
第一种是局部性压缩———表调度法。这种方法是在程序基本块范围内进行压缩(只有 1 个入口和 1 个出口的代码段)，若采用表调度的编译方法，则可将原来的 13条指令序列，压缩成 6 条长字指令，此时完成同样的操作，仅需 6 个周期。图 5.37 中示出了经压缩后(经表调度法调度后) 的 VLIW 指令序列。

图 5.37 经表调度法调度后的 VLIW 指令序列
第二种是全局压缩法。这种方法允许代码操作可在基本块之间移动，从而可获得更好的压缩效果。当然，这种代码操作在基本块间移动是受到一定限制的，而且为了保持程序原来的语义，某些代码操作移动后，通常还需要增加一些辅助操作。全局压缩主要有三种方法： 路径调度 ( Trace Scheduling )、渗透调度 ( Percolation Scheduling)和软件流水( Soft`WAR`e Pipelining)。
VLIW 计算机曾有过商品化机器，如美国原 Mult`IF`low 公司生产的 TRACE 型号机器，以及 Cydrome 公司生产的 Cydra 5 型号机器。但由于性能价格比不理想等原因，这两家公司已停止生产 VLIW 计算机，而 VLIW 计算机中所采用的压缩技术已广泛流传开来。

---
# 5.5 `Pentium` 微处理器中的流水技术
Intel 的第五 代微处理 器芯片 Pentium ( P54C) 和 Pentium MMX ( P55C) 以 及 `Pentium Pro`，具有一些 `RISC` 的特征，同时也具有更多的 CISC 的特征。为加深对`Pentium II/III`微处理器的理解，本节先介绍 `Pentium` 微处理器的超标量流水线结构，然后再介绍 `Pentium II/III`的动态执行技术。
## 5.5.1 `Pentium` 微处理器的超标量流水线
`Pentium` 微处理器与它的前身 80486 有两个重要的不同点： 一是它具有片内分立的 L1 级、容量各为 8KB 的指令 `Cache` 和数据 `Cache`，二是它有 2 个 32 位的 ALU来完成整数运算和逻辑操作，因而能支持两条整数指令流水线的并行执行，这种流水结构属于超标量流水线结构，如图5.38所示。
两条指令流水线分别称之为 U 流水线和 V 流水线。`U, V` 两个字母没有别的含义，它们只是未被执行部件所引用的两个连续字母。每条指令流水线分为 5 段： 预取指令( `IF`)段，译码 1( `ID1`) 段。译码 2( `ID2` )段，执行( `EX`)段和写回寄存器( `WB`)段。
图 5.38 `Pentium` 微处理器中的超标量流水线结构
### 1. 指令预取器和预取缓冲器
虽然，`U, V` 流水线各有一个预取 ( `IF`) 段，但实际上指令预取器和预取缓冲器对两条流水线是共有的，它们的主要功能是：
① 指令预取器总是按给定的指令地址，由 L1 指令 `Cache` 顺序地取指令，直到在`ID1` 段遇到一条转移指令并预测它在 `EX` 段将发生转移时为止。此时，由转移目标缓冲器 `Branch Target Buffer, BTB` 提供预测发生转移的目标地址。按此地址开始又是顺序取指令，直到遇到一条转移指令并预测转移将发生时为止。指令预取器总
是以这种折线式顺序由指令 `Cache` 取指，读取的内容整行( 32 字节 )装入当前活跃的预取缓冲器。有时，折线顶点给定的起始指令地址位于指令 `Cache` 一行的中、后部，一条指令跨两个 `Cache` 行。为此，指令预取器能指挥指令 `Cache` 完成分立行存取(Split-line Access)，将两行内容装入预取缓冲器。
② 预取缓冲器有两个，每个 64 字节的容量，也常称为队列 A 和 B。两个队列任何时候只有一个是当前正在使用的，或称之为活跃的； 另一队列是空闲的。例如，当前队列 A 是活跃的，只要它有 32 字节空位置，指令预取器总是由指令 `Cache` 取整行装入它。若在 `ID1` 段遇到一条转移指令并预测它在 `EX` 段将发生转移时，指令预取器依 `BTB` 提供的转移目标地址开始顺序取指令装入队列 B，而队列 A 空闲被冻结。
如果此转移指令在 `EX` 段执行时确实发生转移，此转移目标地址处开始的指令流已进入流水线(到达 `ID2` 段)，没有任何性能损失，队列 B 继续是活跃的。如果此转移指令在 `EX` 段执行时实际未发生转移，即预测错误，此时要将已进入流水线的指令清
除并激活队列 A，按原转移指令下一条指令的地址顺序取指令装入流水线。队列 A和 B 以这种乒乓方式交替工作。
③ 指令预取器不仅读取指令 `Cache` 整行内容装入当前活跃的预取队列，并在队列中标志每条指令的边界。我们知道，IA 指令长度是变动的，不算前缀，指令长度可以是 $1～12$ 字节。当译码器 1 ( `ID1` ) 段空时，由当前活跃的队列将连续的两条指令(it，it + 1 )送入 `U, V` 流水线的 `ID1` 段，即 it 进入 U 的 `ID1` 段，it + 1 进入 V 的 `ID1` 段。
### 2. 指令译码 1
指令译码在流水线的两段中出现，被称为译码 1 (`ID1`) 和译码 2( `ID2` )。`ID1` 段的主要功能是：
① 对指令操作码部分进行译码，检查是否为转移指令； 若是转移指令，则将此指令的地址送往 `BTB`。若 `BTB` 命中，则根据该项的历史位状况预测此指令在 `EX` 段是否发生转移，并预测为发生时将该项登记的转移目标地址提交给指令预取器。若`BTB` 失效，则意味着 `BTB` 预测逻辑没有该指令的历史。固定预测为在 `EX` 段该指令将不发生转移(即使是一条无条件转移指令也是如此 )，即不指挥预取器更改预取的指令流。注意，在将转移指令的地址提交给 `BTB` 后，不论预测是否发生，此转移指令都要进入 `ID2` 段，在 `EX` 段最终实际执行。
② 指令配对检查。根据 `Pentium` 微处理器的指令配对规则，检查进入 `ID1` 段的it 、it + 1 两条指令是否可配对。若可配对，则 it 在 U 流水线，it + 1 在 V 流水线，两指令同时离开 `ID1` 段进入 `ID2` 段，从而真正开始两指令的并行操作。若不可配对，则 U流水线中的 it 指令先进入 `ID2` 段，然后 `ID1` 段 V 中的 it + 1 指令移送到 `ID2` 段 U 中，即 it，it + 1 两条指令都使用 U 流水线先后顺序操作。
### 3. 指令译码 2
指令译码 2( `ID2`)段的主要功能是，生成存储器操作数地址，并按保护模式的规定检查是否有保护违约，若有则产生例外。因此，`ID2` 段也常称为地址生成段，它使用分段部件、分页部件以及 DT LB(Data Translation Look - as`ID`e Buffer，数据转换后援缓冲器)，将产生的存储器操作数的物理地址提交给 L1 数据 `Cache`。能同时产生两个地址，分别为 `U, V` 流水线服务。 Pentium 的地址生成器比 80486 有所增强，即使是基址加变址的寻址方式也能在 1 个时钟周期内完成 ( 80486 需 2 个时钟周期)。
值得注意的是，不需要存储器操作数的指令也要历经 `ID2` 段，而且两条配对指令要同时离开 `ID2` 段进入 `EX` 段。
另外，转移指令的目标地址计算也是在 `ID2` 段完成的。
### 4. 执行
执行段以两个 ALU 为中心，完成 `U, V` 流水线的两条指令的算术逻辑运算。 U流水线的 ALU 带有一个桶形移位器(Barrel Sh`IF`ter )，因而功能要强于 V 流水线的ALU。执行( `EX`)段的主要功能有：
① 以 `ID2` 段提供的存储器操作数地址，在 L1 数据 `Cache` 中存取操作数 (若 L1数据 `Cache` 失效，在 L2 `Cache` 或主存中查找) 。总之，在 `EX` 段前部，指令所需的存储器操作数、寄存器操作数要全部就绪，在 `EX` 段后部完成指令所要求的算术逻辑运算。
② `U, V` 两条流水线中的执令同时进入 `EX` 段。若 U 流水线的指令先执行完，可先行离开 `EX` 段进入 `WB` 段；但是，V 流水线的指令先执行完则必须等待 U 流水线的指令执行完，然后一起进入 `WB` 段。
③ 一条转移指令在 `EX` 段确认是否实际发生转移。若实际情况与预测相符，则除了修改 `BTB` 该项历史位之外，什么事情也不发生。若预测错误，则除修改该项历史位外，还要清除该指令之后已在 U、V 流水线中的全部指令并指挥指令预取器按相反方向重新取指令装入流水线。即若预测发生转移而实际不发生时，立即解冻另一指令队列，由此转移指令的下一条指令开始顺序取指令。若预测不发生转移而实际发生时，则以计算出的转移目标地址，指挥预取器由此地址开始顺序取指令 (必要的话，还要修改 `BTB` 中此项内容) 。前一种预测错误要浪费处理器 3～4 个时钟周期，后一种预测错误要浪费处理器 5～6 个时钟周期。
④ 前面已经说过，当一条转移指令在 `ID1` 段将指令地址提交给 `BTB` 而 `BTB` 未命中时，则 `BTB` 不做预测而实际上就是预测不发生，指令预取器仍顺序取指令。在`EX` 段，若此指令确实没发生转移，则什么也没发生，以后遇到此转移指令时仍是作为一个“新面孔”的转移指令按上述对待。在 `EX` 段若此指令发生转移的话，则按上一点所说的后一种预测错误处理，还要将转移目标地址提交给 `BTB`，结合在 `ID1` 段提交的转移指令地址，在 `BTB` 中建立一个新项，并设定历史位为强发生 ( Strongly Taken )转移状态。
⑤ 同 80486 一样，`Pentium` 微处理器内部已有浮点运算器 FPU，但 F PU 的性能已做了很大改进。 FPU 内有 8 个 80 位的浮点寄存器 FR0～ FR7，内部数据总线为80 位宽，并有分立的浮点加法器、乘法器和除法器，可同时进行 3 种不同的运算。
浮点指令流水线为 8 段，即预取指令 ( `IF` ) 段、指令译码 1 ( `ID1` ) 段、指令译码 2( `ID2` )段、取操作数 ( `EX`)段、执行 1 (X1) 段、执行 2 ( X2 )段、结果写回 (`WB`)段和错误报告( ER)段。前 4 段与 `U, V` 流水线的 `IF`，`ID1`，`ID2`，`EX` 段共享，后 4 段在 F PU 中完成。
从结构上讲，浮点指令流水线也是双指令流水线。但 1 条浮点运算指令既不能与浮点运算指令配对也不能与整数运算指令配对，只能与 FCXH 浮点交换这样的少数指令配对。于是，常常是只在 U 流水线中执行浮点运算指令，V 流水线空闲或配对执行 FCXH 指令(有浮点编程经验的人都知道，这已是性能的很大改善 )。故一般而言，Pentium `U, V` 流水线每次只能执行 1 条浮点运算指令。
### 5. 写回
写回 ( `WB` ) 段 的 主 要 功 能 是 以 ALU 运 算 结 果 修 改 IA 寄 存 器，这 包括对EFLAGS 标志寄存器的修改。
`Pentium` 微处理器的寄存器分为系统级寄存器组和基本结构寄存器组两类。
系统级寄存器组包括 GDTR，LDTR，`ID`TR，IR 这类 的表基地址寄存器和 CR0 ～CR4 控制寄存器以及用于调试和测试目的的寄存器。基本结构寄存器包括，指令指针 EIP 和标志寄存器 EFLAGS，以及 CS，DS，ES，FS，GS 和 SS 6 个 段寄存器和EAX，EBX，ECX，EDX，ESI，EDI，EBP 和 ESP 8 个通用寄存器。一般情况下，程序员大量使用的是 8 个通用寄存器，可用于编程的寄存器太少。
## 5.5.2 `Pentium` 微处理器 U,V 流水线指令配对
`Pentium` 微处理器比 80486 的一大进步是，指令流水线由单一流水线变为 `U, V`双流水线，即是一个超标量为 2 的流水线。但是，Pentium 调度指令的能力极其有限，它只能对由预取缓冲器取来的连续两条指令进行判测。若两条指令是可配对的，则前一条指令进入 U 流水线后一条指令进入 V 流水线，两条指令可并行操作。若两条指令是不可配对的，则两条指令要先后进入 U 流水线，串行操作将不能展现超标量流水线的优势。为此，本小节讨论指令配对( Istruction Pairing) 问题，并只讨论整数流水线。
### 1. 整数指令的配对规则
由上节知道，指令配对的检查是在 `ID1` 段进行的。图 5.39 ( a) 给出可配对的两条整数指令在 `U, V` 流水线并行操作的情况，图 5.39 ( b) 给出不可配对的两条指令在U 流水中先后顺序操作的情况。从图中可看出，后者带来性能损失。
图 5.39 Pentium `U, V` 流水线操作时空图
`ID1` 段检查 it，it + 1 两条连续指令是否可配对，其可配对规则是：
① 两条指令都是简单指令。简单指令大多数是以硬联逻辑实现的指令，执行段只需 1 个时钟周期。少数涉及到寄存器到存储器或存储器到寄存器的 ALU 指令，它们在执行段需要 2～3 个时钟周期，但 Pentium 包含了某些排序化硬件，允许将它们作为简单指令对待。即使两条指令都是简单指令，但由于 Pentium 的 `U, V` 流水线功能不对称，有的指令可配对但只能出现在 U 流水线中，有的只能出现在 V 流水线中。
② 两条指令都不同时含有立即数和偏移量。
(3) 只有 it 指令允许带有指令前辍 (Prefix)。
(4) 两条指令间不存在 `RAW`( 写与读) 相关和 `WAW`( 写与写 ) 相关。即 it 的目标寄存器既不是 it + 1 的源寄存器，也不是 it + 1 的目标寄存器。但要注意，如 it 为 MOVAL，13； it + 1 为 MOV AH，15； 这样的两条指令仍有 `WAW` 相关，因为 AL，AH 是同一 32 位寄存器的两部分，而 Pentium 将所有寄存器参照都作为整个 32 位寄存器存取对待。至于第 3 种冲突即 `WAR` 冲突，由于 Pentium 的 `U, V` 流水线采用了按序发射按序完成策略而予以避免了，详见下述内容。
### 2. `U, V` 流水线按序发射按序完成策略
指令的发射和完成策略，即超标量流水线的调度，对于充分利用指令级的并行度，提高超标量处理器的性能十分重要。前面已经介绍，超标量流水线的调度策略共有三种：即顺序发射顺序完成，顺序发射乱序完成，乱序发射乱序完成。
无论采用哪种调度策略，都要保证程序运行最终结果的正确性。我们将看到，`Pentium` 微处理器采用的是顺序发射顺序完成策略； Pentium Ⅱ/Ⅲ处理器采用的是按序发射乱序完成策略，而以按序回收来保证程序最终结果的正确性。下面我们考察 Pentium 超标量流水线是如何实现顺序发射顺序完成的。图 5.40 给出了可配对的 4 对指令通过 `U, V` 流水线各段的时空图。
Pentium 的 `U, V` 流水线的 `ID2` 段虽名为译码 2 段，但它的主要功能是生成存储器操作数地址，实际上已属于指令执行功能范畴。故 `U, V` 流水线的指令发射实际上指由 `ID1` 段进入 `ID2` 段。在 `ID1` 段检查配对合格的一对指令，即为简单指令又无 `RAW`，`WAW` 数据冲突，则同时被发射到 `U, V` 流水线的 `ID2` 段。
图 5.40 的 `I1` 、`I2` 两条指令用了 5 个时钟周期通过流水线，是各段都无延迟的一般情况。因为执行( `EX`)段总在写回 (`WB`)段之前完成，即指令读源操作数总在写目标寄存器之前完成，`WAR` 冲突自然避免。在时钟 5 的 1 个周期内，`I1` 、`I2` 指令将其执行结果写回 IA 寄存器，虽然是同时完成写回的，但两指令已无数据冲突，写回必定是正确的并符合程序顺序运行的要求。
上一小节说过，配对指令要同时进入，同时离开 `ID2` 段。若一条指令在 `ID2` 段滞留，另一条指令也必须在 `ID2` 段停顿。图 5.40 的 `I3`，`I4` 两条指令的情况是 `I4` 在 `ID2`段滞留，`I3` 也被迫在 `ID2` 段停顿。
图 5.40 可配对指令通过流水线的几种情况
图 5.40 中 `I5`，`I6` 指令情况是，由于 `I3`，`I4` 指令在时钟 6 才离开 `ID2` 段，故 `I5`，`I6` 指令在 `ID1` 段停顿 1 个时钟周期在时钟 6 才进入 `ID2` 段。在 U 流水中的 `I5` 指令在执行( `EX`)段用了 2 个时钟周期，而 V 流水中的 `I6` 指令虽实际执行只用 1 个时钟周期，但为保证按序完成它被迫在 `EX` 段停顿 1 个时钟周期。然后，在时钟 9 时 `I5`，`I6` 指令同时离开 `EX` 段进入 `WB` 段。
图 5.40 中 I7，I8 指令情况是，由于 `I5`，`I6` 的占用，它们进入 `ID1` 段和进入 `EX` 段都推迟了 1 个时钟周期。现在，U 流水线中的 I7 在执行段只用了 1 个时钟周期，而V 流水线中的 I8 在执行段却用了 2 个时钟周期。即前面的指令先执行完，先进入`WB` 段，后面的指令后进入 `WB`，这种情况是允许的。
总之，`U, V` 流水线可配对指令同时由 `ID1` 段发射到 `ID2` 段，并同时进入 `EX` 段，`U` 流水线中的指令可先执行完，或两条指令同时执行完。于是，实现了超标量流水线的顺序发射顺序完成。
## 5.5.3 `Pentium` 微处理器中的 `BTB`
转移目标缓冲器 `Branch Target Buffer, BTB`。正是由于处理器指令集中有控制程序流向改变的指令，才使得程序功能丰富并编制得灵巧。这些指令包括有，跳转(JMP)指令、调用 (CALL) 指令、返回 ( RET ) 指令、中断 ( T NT ) 指令等，可以用转移(Branch)指令一词来代表。转移指令又可分为条件转移指令和无条件转移指令，无条件转移指令执行时肯定发生转移，条件转移指令执行时是否发生转移取决于指令所要求的条件当时是否能满足。
但是，转移指令会对流水线造成性能损失。因为转移发生时要排空流水线，由转移目标地址开始取指令重新注入流水线，而且指令流水线的段数越多和并行流水线的条数越多，转移指令造成的性能损失越大。

已有许多技术用于减少转移指令对流水线性能的影响，其中两种最常用的技术是：基于编译软件的延迟转移 (Delayed Branching )技术和基于硬件实现的转移预测(Branch Prediction)技术。这里只介绍后一种技术。
转移预测技术的基本思想是，在指令实际执行之前，在流水线的指令译码段期间，即使对所遇到的转移指令进行预测，若预测它在执行段将发生转移，则现在就由转移目标处取指令，以此来减少流水线的排空量。当然，预测正确与否还要待此转移指令具体执行结果的检验。若预测正确，转移指令对流水线造成的性能损失确实减小了。若预测不正确，仍要重新注入流水线，尤其是对实际不发生转移的指令却预测为转移发生，反而凭空增加了一次性能损失。因此，转移预测技术要努力提高预测的正确率，一般要求正确率要高于 80% 。
转移预测有静态、动态之分。静态预测法只依据转移指令类型来预测。例如，对某一类条件转移指令总是预测为转移发生，对另一类总是预测为转移不发生。又如，对朝前向转移的条件转移指令总是预测为转移不发生，对朝后向转移的指令总预测为发生，等等。静态预测法简单但正确率不高，只能作为其他转移处理技术的辅助手段。
动态预测法是依据一条转移指令过去的行为来预测此指令的将来行为。因为程序结构中重复或循环执行的机会众多，较好的预测算法会使动态预测法有较高的正确率，故普遍被当代处理器所采用。这里，我们只介绍 `Pentium` 微处理器依据 `BTB` 所实现的动态预测法。
图 5.41 给 出 Pcntium 微 处理器 的 `BTB` 的 逻辑 结构，它是 一个 4 路 组相 联Look-as`ID`e式 `Cache`，共有 256 行。以转移指令地址的低 6 位为组索引，转移指令地址的高 26 位为 `Cache` 行的标记字段。转移指令的转移目标地址 ( 32 位 )与历史位 (2位)及有效位( 1 位)为 `Cache` 行的内容。
`BTB` 项的历史位登记该项转移指令以前的执行行为( 最近两次连续发生转移的次数)，用于在 `ID1` 段预测此指令是否发生转移。在 `EX` 段要根据实际是否发生转移，来修改命中项的历史位； 或对于 `BTB` 未命中的转移指令而在 `EX` 段实际发生转移的情况，在 `BTB` 中建立新项并设定历史位为 11。图 5.42 给出 `BTB` 历史位的意义及状态转换。
由图中可看出，`Pentium` 微处理器的 `BTB` 对历史位意义的设定更倾向于预测转移发生。11 历史位常称为强发生 (Strongly Taken ) 状态，10 位称为发生 ( Taken ) 状态，01 位称为弱发生( Weakly Taken) 状态，3 种历史位都预测转移发生。并且，对一个新遇到的 转移 指令 并实 际发 生转 移的 情 况，则 所 建新 项 设置 为 强发 生 状态。
Pentium 更倾向于预测发生的原因有两方面： 一是条件转移指令发生转移的概率一般为 60% 左右； 二是 Pentium 的双指令队列结构，使预测为转移发生而实际上不发生时流水线蒙受的损失，要小于预测为转移不发生而实际上发生时的损失。


图 5.41 `Pentium` 微处理器的转移目标缓冲器 (`BTB`)逻辑结构
图 5.42 `Pentium` 微处理器 `BTB` 历史位状态转换

`Pentium` 微处理器的 `BTB` 操作分为两个阶段： 指令译码 ( `ID1`) 段的预测阶段和指令执行( `EX`)段的预测验证及修改阶段。
## 5.5.4 `Pentium II/III`微处理器中动态执行技术
Intel 对 `Pentium Pro`，`Pentium II/III`处理器的核心结构进行了全新设计。处理器呈现给用户的仍是 IA( Intel 结构)指令集，保持与 x86 处理器 (包括 Pentium 处理器)的兼容； 处理器内部，将由存储器取来的 IA 指令翻译成 `RISC` 指令来执行，并将最后结果写回 IA 寄存器组。这种全新设计的核心结构成功地实现了动态执行技术，全面改善了 Intel 第三代 32 位处理器的超标量超流水的指令流水线性能。
本节先简要讨论动态执行技术的要点，然后简要介绍 `Pentium II`处理器的流水线结构。
### 1. 动态执行技术概述
动态执行( Dynamic `EX`ecution ) 技术也称为随机推测执行 ( `Nandomly Speculative Execution`) 技术，此技术可概括为： 通过预测程序流来调整指令的执行，并且分析程序的数据流来选择指令执行的最佳顺序。具体而言，它由如下三项技术组成：
(1) 多路分支预测( Multiple Branch Prediction)
利用先进的转移预测技术(预测正确率高达 90% )，允许程序的几个分支流向同时在处理器中进行。这样，处理器在取指令时，还会在程序中寻找未来要执行的指令，加速了向处理器传递任务的过程，并为指令执行顺序的优化提供了可调度基础。
(2) 数据流分析( Dataflow Analysis)
通过分析指令之间的数据相关性，产生优化的重排序的指令调度。处理器读取软件指令并经过译码后，判断该指令能否与其他指令一道处理，然后处理器分析这些指令的数据相关性和资源可用性，以优化的执行顺序高效地处理这些指令。
(3) 推测执行( Speculative `EX`ecution)
将多个程序流向的指令序列，以调度好的优化顺序送往处理器的执行部件去执行，尽量保持多端口多功能的执行部件始终为“忙”，以充分发挥此部件的效能。因为程序流向是建立在转移预测基础上的，因此指令序列的执行结果也只能作为预测结果而保留。一旦证实转移预测正确，已提前建立的预测结果立即变成最终结果并修改机器的状态。显然，推测执行可保证处理器的超标量流水线始终处于忙碌状态，加快了程序执行的速度，从而全面提高了处理器的性能。
图 5.43 `Pentium Pro` 微处理器的核心结构
下面结合图 5.43，简要介绍 `Pentium Pro`，`Pentium II/III`核心结构的新特征。
① 分立的双总线结构，即处理器的总线接口单元 BIU 通过分立的两条总线，分别与系统主存和级 2 `Cache` 连接。
②采用超标度为 3 的超标量结构，并将指令流水线由 5 段细分成 12 段，即它们的指令流水线是一个超标量与超流水线相结合的流水线。12 段流水线可分成三个大阶段：取指/译码段，调遣/执行段和回收段。
③ 取指/译码段由 L1 指令 `Cache` 取来的 IA 指令转换成 Intel 称为微操作 ( mop或 uop)的 `RISC` 指令，这将大大简化以复杂著称的 IA 指令处理。
④ 核心结构以 `RISC` 指令缓冲池 ( Instruction Pool) 为中心。多重程序流向的IA 指令序列译码成 uop 后暂存于指令缓冲池，可多达 40 项。然后，以优化的重排序送往执行部件去执行，推测执行的结果也暂存于指令缓冲池，等待回收。
⑤ 采用寄存器换名(Renaming) 策略。将 IA 指令使用的 IA 寄存器映射成微操作使用的 `Pentium Pro` 内部寄存器( 数量、名称、长度，Intel 未公布 )，这样，可极大地消除指令的数据相关性。只有在推测执行指令序列前面的全部转移指令处理完毕，此指令序列已属正确程序顺序时，推测执行的结果才写回存储器和 IA 寄存器组，并删除缓冲池中此指令序列，这即是回收阶段。
⑥ 采用动态转移预测法和静态转移预测法相结合的两级转移预测技术。其动态转移预测法使用的 `BTB` 结构已增至 512 行，并采用 Yeh 的一种扩充算法，可得到90 % 以上的预测正确率。
### 2. `Pentium II`超标量流水线结构
`Pentium II` 微处理器将一条指令的解释过程细分为 12 个子过程，即指令流水线由 12 个子功能段组成。各功能段的定义如图5.44所示。

图 5.44 `Pentium II`微处理器中流水线组成
图 5.45 `Pentium II`微处理器核心结构图
下面结合图 5.45 简要描述流水线各段的主要功能：
`IF`U1 取指单元段 1(Instruction Fetch Unit stage 1 )
该段主要由 32 字节的“预取流式缓冲器”( Prefetch Streaming Buffer )构成。由L1 指令 `Cache` 取一 32 字节的行，装入该缓冲器。
`IF`U2 取指单元段 2(Instruction Fetch U nit stage 2 )
该段主要由“指令长度译码器”构成。预取流式缓冲器中的内容以 16 字节块向前传递，`IF`U2 的功能主要是在 16 字节块中标志指令边界，如果发现转移指令，即将此指令地址提交给 `BTB` 进行动态转移预测。
`IF`U3 取指单元段 3(Instruction Fetch U nit stage 3 )
该段由“译码器对齐段”构成。因为下一段(DEC1 )使用译码器 0 (复杂 )、译码器1 (简单) 、译码器 2(简单 )三个译码器； `IF`U3 的功能是旋转 1 6 字节块中的 3 条指令，使它们能按照复杂、简单，简单或简单、简单、复杂的次序同时递交给 DEC1。
DEC1 译码段 1(DECode stage 1 )
DEC1 译码段 1 包括译码器 0、译码器 1 和译码器 2。其功能是将 IA 指令译码(或者说翻造) 成 `RISC` 型的微操作 ( uop) 。
译码器 0 可将一条复杂指令翻造成多达 4 个的 uop，译码器 1、2 只能各生成 1个 uop。每个 uop 定长为 118 位 ( Intel 未公布 uop 的结构 )。于是，DEC1 段的三个译码器可同时生成 6 个 uop。某些 IA 指令需要翻造成 5 个或更多的 uop，则 DEC1段将它们提交给微指令序列器 MIS( Micro Instr nction Sequencer) 。MIS 本质上是一个微代码 ROM。某些指令(如重复的串操作指令 ) 经 MIS 可翻造成非常大的、重复的微操作序列。
DEC2 译码段 2(DECode stage 2 )
该段是译码或翻造后的指令队列。在 DEC1 段由译码器 0，1，2 或 MIS 翻造生成的 uop 序列，每次最多 6 项送往 DEC2 段，在译码后指令队列 DIQ ( Decoded Instruction Queue)中按原始程序顺序排队。并且，若在这些已排队的 uop 中发现转移型 uop 并且为 `BTB` 失效时，则将其提交给静态转移预测机构，这是第二级的转移预测。
RAT 寄存器别名表和分配器段( Register Alias Table and Allocator stage)
此段每次由 DIQ 按程序顺序取 3 项 uop，检查 uop 中是否使用 IA 寄存器，若有将其换名成 `Pentium Pro` 内部 的 ( 隐藏 的 ) 寄 存器，然后 将 其送 往微 操作 缓冲 池ROB。
IA 的通用寄存器只有 16 个，即整数的 EAX，EBX，ECX，EDX，ESl，EDI，EBP,ESP，和浮点数的 FR0～FR7。这样少的通用寄存器不仅编程不太方便 ( 这种事实已无法改变)，而且先后两条指令使用同一寄存器很易产生 `WAR`，`WAW` 和 `RAW` 数据相关，不利于超标量流水线的执行。现将 IA 寄存器换名成 `Pentium Pro` 内部寄存器(约有 40 个之多)，极大地减少了指令间的数据相关。
ROB 重排序缓冲器段(ReOrder Buffer stage)
RAT 按程序顺序以每 时钟 3 个 uop 的速率，将 uop 序 列送入重 排序缓冲 器ROB，即微操作缓冲池。ROB 是一个 40 项的环形队列缓冲器，它有两个指针： 一个是缓冲器首指针 ( Start-of-Buffer Pointer )，一个 是 缓 冲 器尾 指 针 ( End-of-Buffer Pointer )。尾指针是存放指针，首指针是回收指针。开始的时候首指针同于尾指针，意为缓冲器空，每存放—个 uop，尾指针即增 1，而首指针指向最“老”存入的 uop 项，等待执行完毕后的回收。
ROB 每项有状态位，登记此 uop 的当前运行状态，例如是否已调度到保留站，是否已派遣到相应执行单元端口，是否正在执行单元中执行，是否执行已完成正在将结果返回 ROB 项，是否正在检查结果 ( 是否有误 )，是否标志回收就绪，是否已回收而为空项。
DIS 派遣段( Dispatch stage)
在 uop 已放入微操作缓冲池(ROB) 后，保留站( RS)能以任何顺序由缓冲池拷贝多个微操作并派遣到相应的执行单元端口。这是一个乱序过程 OOO ( Out-Of-Or-der)。调度所遵循的基本原则是，uop 的操作数已就绪并且相应的执行单元可用。
其中，操作数已就绪还表示已排除指令间的 `RAW` 数据相关，相应的执行单元可用表示已排除指令间的结构相关(即资源冲突) 。
`EX` 执行段( `EX`ecution stage)
该段的主要功能是执行 uop。保留站有端口 0～4。其中，端口 0 有 5 个执行单元，端口 1 有 3 个执行单元。它们完成全部的简单或复杂的整数运算、浮点运算以及多媒体扩展( MMX)功能的运算，还有一个转移执行单元 (JEU ) 处理转移 uop。转移结果，即是否实际发生转移，除返回 ROB 外还要返回给 `BTB`。
端口 2 的装入执行单元负责生成读数据的存储器地址，存储器读指令只产生一个微操作。存储器写指令产生两个微操作，一个微操作送往端口 3 的存储地址执行单元用于生成写入的存储器位置，一个微操作送往端口 4 的存储数据执行单元用于生成写入数据。写数据及其存储器地址同时送往存储顺序缓冲器 MOB。然后，再以严格的程序顺序写回到 L1 数据 `Cache`(或 L2 `Cache` 以至主存)。
执行所需的处理器时钟周期数是微操作指定的，大多数微操作只需 l 个时钟周期。
`WB` 写回段(Write Back stage)
uop 执行结果写回 ROB 项并进行错误检查，这包括对由 L1 数据 `Cache`( 或 L2 `Cache`)读入数据的 ECC 检查和修正。同 DIS，`EX` 段一样，`WB` 段也是一个乱序过程，但要避免出现 `WAR` 和 `WAW` 数据相关。
RR 回收就绪段 (Retirement Ready stage)
当 uop 执行结果写回 ROB 项且结果无误时，RR 段逻辑判测它的上游的转移指令是否已全部解决。若已全部解决，则按程序顺序以 IA 指令为单位，标志它相应的uop 已回收就绪，这是一个有序过程。
RET 回收段 (RE Tirement stage)
按程序顺序以 IA 指令为单位，每时钟回收 3 个 uop。即将已回收就绪的 IA 指令对应 uop 的结果，最终写回 IA 寄存器集以及设置 EFLAGS 标记；并通知 MOB 将已回收就绪的存储器写指令实际完成，具体写入 L1 数据 `Cache`(或 L2 `Cache` 以至主存)。这也是一个有序过程。被回收的 uop 由 ROB 中删除，该 ROB 项变为空项，缓冲器的首指针增量。
综上所述，12 段的超流水线中的前 7 段 ( `IF`U1～ ROB) 是有序取指/译码阶段，中间 3 段 (DIS，`EX`，`WB`)是乱序的调度、派遣/执行阶段，最后 2 段( RR，RE T) 是有序的回收阶段。有序的取指/译码阶段每次能同时译码 3 条 IA 指令，产生最多为 6 个的 `RISC` 型 uop，以每时钟周期 3 个 uop 的速率按序送往微操作缓冲池。乱序的调遣/执行阶段以优化的无结构相关、无数据相关的重排顺序执行指令，保留站的 5 个端口可同时执行 5 个 uop。最后以有序的回收阶段保证程序最终结果的正确性，RET段以每时钟可回收 3 个 uop 的速率工作。因此，可以说 `Pentium II`的指令流水线是超标度为 3 的流水线。采用动态转移预测与静态转移预测的两级预测，使预测正确率高达 90% 以上，从而极大地减小了由于转移(控制相关) 可能给超标量超流水线带来的性能损失。

---
# 5.6 向量流水技术
向量流水技术是向量数据表示与流水技术的结合。在前面所讨论的流水技术中我们已经知道，为了获取高的流水处理性能，应该设法增加流水线中的段数，即记水深度。或者设法在每个时钟周期能同时启动多条指令。但在实际应用中要使标量流水机的性能有进一步的提高，通常受到以下两个因素的约束：
一是流水线工作的时钟周期不可能取得很短。加深流水深度可以使时钟周期缩短，但流水深度的增加会使流水线中出现相关性的可能性也增加，造成较大比例的断流，而为等待相关消除就需要更多的时钟周期，这导致每条指令执行所需的时钟周期数的增加。
二是取指令及译码的速率受限。即在一个时钟周期内最多只能启动一条指令，通常称为 Flynn 瓶颈。
本章所讨论的向量流水处理在一定程度上将不受上述两个因素的约束。
## 5.6.1 向量流水的基本概念
### 1. 向量流水处理的基本特点
向量流水处理具有以下基本特点：
① 在向量操作中，每个当前结果向量元素的计算与以前结果向量元素的计算是相互独立的，很少发生数据相关，这就允许向量流水线有较深的深度。
② 一条向量指令相当于一个标量循环，从而可降低对指令访问带宽的要求。此外，这也消除了由循环转移可能引起的控制相关。
③ 若向量指令所要访问的向量元素均相邻，则可以在交叉存储体中高速地依次访问它们。由于一个向量中通常含有多个元素，因此对存储器访问的延迟平均到每个元素上，其访存等待时间开销是较小的。
上述的这些特点使得对相同数量的数据项进行操作时，向量操作要比一串标量指令操作更快，此外，向量流水机还可使访存和有效地址计算流水化，高档的向量机还允许多个向量操作同时进行，从而可开发对不同元素进行多个向量操作的并行性。
### 2. 向量处理方式
向量处理机中对向量的各种运算可以采用不同的加工处理方式，但最为有效的加工方式应该尽量避免出现数据相关和向量操作功能的切换。下面以向量运算 D =A× (B + C)为例，讨论几种加工方式对向量运算的影响，其中，A，B，C 和 D 都有是长度为 N 的向量。

#### (1) 横向处理方式
这种处理方式过程如图5.46 (a)所示。
图 5.46 向量处理方式
横向处理方式具有如下特点：
① 只需要 1 个暂存单元 k ；因为每个分量的完成过程可细分为 ( bi + ci )→k； k×ai→di 。
② 每个向量元素在加、乘过程中都有数据相关，一共出现了 N 次相关。
③ 当使用静态流水线时，流水线功能需切换 2N 次。因此，这种方式不适合于向量流水处理。
#### (2) 纵向处理方式
这种处理方式过程如图4.46 ( b)所示。
显然，由图 5.46( b )可见，纵向处理方式具有如下特点：
① 需要 1 个中间向量 K，其长度与运算向量相同。
② 数据相关只在两指令间出现一次，因为其运算过程可表示为 K = B + C，D= K×A。
③ 当使用静态流水线时，只有一次功能切换。
这种向量处理方式在存储器—存储器型向量处理机中实现。
#### (3) 纵、横向处理方式
不管是存储器—存储器型向量处理机，还是寄存器—寄存器型向量处理机，它们所能表示的向量长度是有限的。当需要处理 (运算) 的向量长度 N 大于实际机器所能表示的向量长度时，就需要对处理向量长度 N 进行分组，然后再进行处理。
设用户需处理的向量长度为 N，向量处理机所能表示的向量长度为 n，而且有 n <N，则可将待处理的向量分成 k′组，每组元素个数为 n，则有 N = k′n + r。
向量处理过程是组内纵向处理，组间为横向处理，故称之为纵横向处理。`CRAY-1` 等巨型计算机都是采用这种处理方式工作的。处理过程示意如图5.47 所示。

图 5.47 向量的纵、横向处理示意图 ( 共完成 k’+ 1 组 )
### 3. 向量处理机的分类
向量机处理机按照向量操作对象及结果主要存放在寄存器中还是存放在存储器中，可分为两大类：
(1) 存储器—存储器型向量处理机
这种向量处理机的主要特点是，向量操作的原向量都取自主存，操作生成的结果向量也存放在主存中。最先的向量处理机都是存储器—存储器型的，如 TI 公司的ASC(1972 年)，CDC 公司的 STAR-100 (1973 年)和 CYBER-205 (1980 年)等。
(2) 寄存器—寄存器型向量处理机。这种向量处理机的主要特点是，向量操作的原向量和结果 向量 都取 自或 存放 到 向量 寄存 器中。如 CRAY 公司 研制生产的`CRAY-1` 向量处理机( 1976 年 )，日本富士通公司的 FACOM 系列向量机，日立公司的 S810/820 向量机以及我国的银河向量机等。
### 4. 向量访问步长及控制
连续访问的向量元素之间在存储器地址上具有相等的间隔，这个相等的间隔称为向量访问步长。
对于二维或多维向量元素，它们的存储必须通过一种映射方式将其存放在一维存储器空间中。例如，对于一个二维向量，若存储顺序是以行为主。当以行为主顺序访问时，访问顺序与存储顺序相同，即访问元素之间在地址上是连续的； 当以列为主顺序访问时，而访问元素之间在地址上是不连续的，元素存储地址上是等间隔的。那么，在向量处理机中是如何支持这种跨步访问的呢 ?
① 在存储器—存储器型向量处理机中，利用软件重新排序方法，将存储器中的元素按照访问顺序重新排序，以支持访问顺序。
② 在寄存器—寄存器型向量处理机中，利用硬件重组的方法，自动调整存储器中被访问元素，支持这种跨步访问。

## 5.6.2 `CRAY-1` 型向量流水处理机
向量流水处理机的结构因具体机器不同相互有所不同。`CRAY-1` 型向量处理机是美国 CRAY 公司于 1976 年研制完成的寄存器—寄存器型向量处理机。
### 1. `CRAY-1` 型向量处理机结构
`CRAY-1` 型向量处理机是由中央处理机、诊断维护控制处理机、大容量磁盘存储子系统、前端处理机组成的功能分布异构型多处理机系统。中央处理机的控制部分中有总容量为 256 个 16 位的指令缓冲器，分成 4 组，每组 64 个。图 5.48 为中央处理机向量流水处理部分结构。
图 5.48 CRAY - 1 向量处理机结构图
#### (1) 三类基本寄存器
8 个向量寄存器 V0 ～ V7 。每个向量寄 存器的长度为 N = 64 ( 每个寄存 器 64字)，即每个向量寄存器可存放 64 个分量元素，每个字长度为 64 位。
V0 ～V7 可直接与 6 个向量运算 ( 整数和浮点 ) 部件、主存储器之间交换数据。
V0 ～V7 中的任何一个寄存器都可作为向量运算中的源、目的操作数寄存器。如指令：
ADDV V0，V1
； V0 + V1 →V0
8 个标量寄存器 S0 ～ S7 。每个标量寄存器长度为 64 位，即可直接存放 64 位标量。它可为 6 个向量运算部件、4 个标量运算部件提供运算数据和存放运算结果，并能通过中间暂存器 T 或直接与主存储器交换数据。
8 个地址寄存器 A0 ～A7 。每个地址寄存器长度为 24 位，为地址运算提供操作数。通过中间暂存器或直接与主存储器之间交换数据。
#### (2) 两组中间寄存器
中间寄存器组 T，它由 64 个 64 位的寄存器组成，为标量寄存器与主存储器之间交换数据起到缓冲作用。
中间寄存器组 B，它由 64 个 24 位的寄存器组成，在地址寄存器与主存储器之间交换数据起到缓冲作用。
#### (3) 两个控制寄存器
向量长度寄存器 VL，它由 6 位组成，用于存放向量运算中实际参加运算元素个数。( VL)≤64，当实际参与运算的向量长度大于 64 时，必须将其分组后再运算。

向量屏蔽寄存器 VM，是一 64 位的寄存器，每一位对应于一向量元素，控制其是否实际参与向量运算。VMi = 0 时，表示屏蔽； VMi = 1 时，表示允许。
### 2. `CRAY-1` 型向量处理机的 4 类指令
`CRAY-1` 有标量类和向量类指令共 128 条，其中 4 种向量指令如图5.49所示。
图 5.49 `CRAY-1` 向量处理机的 4 种向量指令
第一种是两个参与运算的源向量分别取自两个向量寄存器 Vj，Vk，结果送入向量寄存器 Vi 。如向量运算 V1 + V2 →V3 属于此类，其功能部件为加法部件。
第二种是一个标量与一个向量运算，结果为一向量。它与第一种指令的差别只在于它的一个操作数取自标量寄存器 Sj 。
大多数向量指令都属于这两种。由于它们不是由主存而是由向量寄存器组取得操作数，从而减轻了对主存数据流量要求高的压力，所以流水速度可以很高。这里的 $n$ 是通过流水线功能部件的时钟数。
第三、四种用于控制主存与 Vi 向量寄存器组之间的成组数据传送。访存流水线建立时间为 6 拍。
## 5.6.3 增强向量处理性能的方法
本小节讨论几种改善向量处理性能的方法。第一种是采用多功能部件使它们并行工作；第二种是加快一串相关指令的操作速度，又称为链接技术，这种技术首先在`CRAY-1` 型向量处理机中得到应用，目前的向量处理机都支持这种技术； 最后两种主要是为了增加能以向量方式操作的循环类型，这两种方法在许多向量处理机中采用。
### 1. 多功能部件的并行操作
在向量处理机中，为了加快向量处理的速度，通常采用多个相对独立的功能部件并行工作。如前面所讲述的在 `CRAY-1` 型向量处理机中，共有四组 12 个单功能流水部件，这些功能部件都是相互独立的，只要它们满足一定的约束条件，可以并行工作。
多功能部件可并行工作的约束条件：
(1) 不存在向量寄存器的使用冲突
例如，有些向量运算指令功能可描述为 V1 + V2 →V3 和 V4 ×V2 →V5，由于这两条指令操作中都使用了同一向量寄存器 V2，因此，这两条指令不能并行( 同时) 执行。
这是因为两条指令中使用 V2 时的首元素下标可能不相同，向量运算的长度也有可能不相同。
(2) 不存在功能部件的使用冲突
例如，有些向量运算指令功能可描述为 V1 + V2 →V3 和 V4 + V4 →V6，如果这两条指令的操作都是浮点运算，那么它们将使用同一浮点加法功能部件，从而引起功能部件冲突。
在一组向量运算指令中，如果这些指令既不存在向量寄存器的使用冲突，也不存在功能部件的使用冲突，则这些指令称为一个指令编队。也就是说，在一个指令编队中的所有指令，是可以并行执行的。
### 2. 链接技术
利用向量指令间存在的先写后读的数据相关性来加快向量指令序列执行速度的技术称为链接技术。链接技术实质上是第四章中所讨论的标量流水定向传送方法在向量寄存器中的应用。例如，对于如下的向量加和向量乘的操作：
```cpp
ADDV V1，V2，V3  ; V3 + V2 →V1
MUL TV V4，V1，V5 ; V1 ×V5 →V4
```
由于这两条指令对 V1 向量寄存器存在先写后读相关，通常必须等加法指令做完后才可开始乘法指令，但如果使向量寄存器 ( 例中的 V1 ) 在同 1 时钟周期内，既接收一个功能部件送来的运算结果，又可把这一结果作为下一个向量指令运算所需的源操作数送给另一个功能部件，那就可使这两个部件链接起来进行操作。通常把这种链接称为超级向量操作。当链接进入充分流水操作状态后，在 1 个时钟周期内就可同时获取两个操作结果。在 `CRAY-1` 中，计算机能自动检查每一条向量指令是否可与它的前 1 条指令形成链操作。若满足链接条件时，便在前 1 条指令的第一个运算分量结果到达作为本条指令的源操作数时，立即启动本指令工作而形成链。

下面以 `CRAY-1` 为例，说明多功能部件并行操作和链接操作，如进行向量运算：
D = A×(B + C)
假设向量长度 N≤64，且 B 和 C 已由存储器取至 V0 和 V1，则下面 3 条向量指令就可完成上述运算：
```cpp
LD V3，A  ； A→V3
ADDV V2，V0，V1 ； V1 + V0 →V2
MUL TV V4，V2，V3 ； V3 ×V2 →V4
```
第一、二条指令间因既无向量寄存器使用冲突，也无功能部件使用冲突，因而可并行执行。第三条指令与第一、二条指令均存在先写后读相关冲突，因而可将第三条指令与第一、二条指令链接执行，如图5.50所示。
`CRAY-1` 启动访存、把元素送往功能部件、将结果存入某向量寄存器都需要有 1拍的传送延迟，那么完成上述三条指令功能分别按三种不同的执行方式时总的时间如下：
(1) 三条指令顺序( 串行)执行时，总的完成时间为：
T1 = [ 1 + 6 + 1 + ( N - 1 ) ] {第一条访存指令的完成时间} + [ 1 + 6 + 1 + ( N - 1 ) ]
{第二条加法指令的完成时间} + [1 + 7 + 1 + ( N - 1 ) ] {第三条乘法指令的完成时间}
= 3N + 22(拍 )
(2) 前两条指令并行执行完后，再执行第三条指令，完成时间为：
T2 = [ 1 + 6 + 1 + ( N - 1 ) ] {前两条指令并行执行时的完成时间} + [ 1 + 7 + 1 +( N - 1 ) ] {第三条乘法指令的完成时间}
= 2N + 15(拍 )
(3) 前两条指令并行，再与第三条指令链接，完成时间为：
T3 = ( 1 + 6 + 1) + (1 + 7 + 1 ) + N - 1
= N + 17 (拍)
图 5.50 向量的并行和链接操作

可见，采用并行加链接技术的加速效率还是较高的。但要实现链接除了前述的条件之外，还应注意以下三个问题： 一是链接的时间，即只有当前一指令的第一个结果分量送入结果向量寄存器的那一个时钟周期方可链接，若错过该时刻就无法进行链接，只有等前一向量指令全部执行完毕，释放向量寄存器资源后才能执行后面的指令。二是当一条向量指令的两个源操作数分别是两条先行指令的结果寄存器时，要求先行的两条指令产生运算结果的时间必须相等，即要求有关功能部件的延迟时间相等(如上例中的访存和浮点加功能部件延时均为 6 个时间单位) 。三是要求两条先行向量运算指令的向量长度必须相等，否则就不可能链接。针对不同的向量机，可能对链接还有其他特殊限制。
### 3. 条件语句的加速处理方法
当程序中含有条件执行语句时，通常会使向量处理的优点无法发挥，如对于如下的循环：
```cpp
do 100 i = 1，64
`IF` A(i)≠0 then
A(i) = A(i) - B(i)
end`IF`
100 continue
```
由于要执行条件语句，使循环体无法向量化，但若采用向量屏蔽控制技术，使减法只有当 A(i)不为 0 时才执行，就可使上述循环向量化。
这里的关键是要生成一个屏蔽向量，然后借助它来控制那些向量元素参加运算。屏蔽向量是通过向量测试得到的。本例中即是对 A(i)进行是否为 0 的测试，当被测试的 A(i)位元素等于 0 时，就使屏蔽向量中的对应位置 0，而 A(i) 不为 0 时，就使相应位置 1。经上述测试得到的屏蔽向量，放在一个向量屏蔽寄存器 VM 中，在进行向量减法操作时，对应于屏蔽向量位为 0 的那些目的向量寄存器位的内容将不会改变。
对屏蔽向量寄存器清零时，将使所有位都置为 1，因此，此后的向量指令将对所有的向量元素进行操作。下面给出实现上述循环的代码，假定向量 A 和 B 的起始地址存放在 Ra 和 Rb 中：
```cpp
LV
V1，Ra
；将向量 A 装入 V1
LV
V2，Rb
；将向量 B 装入 V2
LD
F0，# 0
；将浮点 0 装入 F0
SENSV F0，V1
；若 V1 (i) ≠F0，则将 VMi 置为 1
SUBV V1，V1，V2
；在屏蔽向量控制下进行减法操作
CVM
；将屏蔽向量寄存器置为全 1
SV Ra，V1
；将结果存入 A
```
其中 SENSV 为屏蔽向量生成指令，CVM 为使屏蔽向量寄存器全置为 1 的指令。
屏蔽向量寄存器控制向量指令执行方法的缺点是：
① 执行时间没有减少。
② 在某些向量机中，屏蔽向量仅用来禁止向目的寄存器写入，而相应的向量操作实际仍是进行的，这就可能导致某些向量操作出现错误。如要进行的向量操作是：
`IF` A(i)≠0 then B(i) = B(i)/A(i)
时，就会出现 B(i)被零除的错误。因此，比较好的实现方案是： 根据屏蔽向量既禁止将结果写入目的寄存器，也禁止该操作的执行。
### 4. 向量归约的加速处理方法
归约(Reduction)操作一般难于向量化。因为对一个像一维数组那样的向量归约求值的结果将得到一个标量值。归约操作是递推 ( Recurrence ) 操作中的一个特例，可用如下的点积操作来说明这种归约：
```cpp
dot = 0.0
do 10 i = l，64
10
dot = dot + A(i) ×B(i)
```
由于此循环存在迭代层间的数据相关，因而无法直接向量化。一个比较好的方法是设法将此循环分成可向量化部分和递推部分，可将循环改写成如下形式：
```cpp
do 10 i = 1，64
10 dot(i) = A(i)×B(i)
dot l = 0.0
do 20 i = 1，64
20 dotl = dotl + dot(i)
```
这样已将原为标量变量的 dot 扩展成一个向量，显然第一部分循环可加以向量化，而第二部分则仍需用递推方法。对于这一递推求和部分可采用使叠加向量长度逐步缩短的方法加以完成。如首先相加两个 32 元素向量，然后再相加两个 16 元素向量等。
这种技术称为递归折叠方法( Recursive Doubling )。这种方法显然比全部以标量方式的求和方法要快。例如，对于上述的第二部分递推循环，可用递归方法写成如下的代码：
```cpp
len = 32
do 100 j = l，6
do 10 i = 1，len
10 dot(i) = dot( i) + dot(i + len )
len = len/2
100 continue
```
其中 j 用来表示递推次数，对于向量长度为 32 的操作，只需递推 6 步就可在 dot ( 1)中得到所需的递推和，因而 j 取值由 1 到 6。当 j = 1 时，dot ( 1 ) 与 dot ( 33 ) 相加，dot(2) 与 dot(34) 相加，依次类推，直至 dot( 32 ) 与 dot ( 64 ) 相加； 当 j = 2 时，len 已由 32缩短为 16，所以，dot( 1) 与 dot( 17 )相加，dot (2)  与 dot( 18 ) 相加，直至 dot( 16 ) 与 dot(32) 相加。当 j = 6 时，len 已折叠变为 1，因而只进行 dot( 1 ) 与 dot( 2 )相加，结果存入 dot( 1) 。这种递归折叠方法是一种加快向量归约操作的有效方法，因而在许多向量机上得到了应用。
