@[toc]

指令系统是计算机系统中软件与硬件分界面的一个主要标志 , 它历来是计算机
体系结构设计者、系统软件设计者和硬件设计者共同关注的问题。在计算机系统的
设计过程中 , 指令系统的设计是非常关键的 , 它必须由软件设计人员和硬件设计人员
共同完成。
本章主要介绍指令系统及与指令系统直接相关的数据表示和寻址方式等方面的
内容 , 重点讨论在指令系统属性上的传统机器级界面及软、硬件功能分配 , 以及缩小
与软件之间的语义差距的改进措施。在此基础上给出一种指令集结构的实例———
DLX 指令集结构。
2 .1 浮点数据表示和 IEEE754 标准
2. 1. 1 数据表示、数据类型、数据结构的关系
计算机中所使用的数据一般可分为三类:第一类是用户定义的数据 , 这类数据通
常是由程序设计语言所确定的;第二类是系统数据 , 它是程序在执行时由计算机系统
蕴含生成的;第三类是指令 , 即被执行的程序可看成是数据的复合。这里讲的是“数
据”, 那么“数据类型”是什么呢 ?
数据类型不同于数据 , 它除了指一组值的集合外 , 还定义了可作用于这个集合上
的操作集 , 比如有一组整数值的集合 , 连同定义在这个集合上可进行的加减乘除等算
术操作 , 这个整数的集合就成为了整数数据类型。计算机中定义数据类型的目的是
为了防止不同数据类型间的误操作。从系统结构的观点来看 , 数据类型可分为基本
数据、结构数据、访问指针和抽象数据等类型。我们这里讲的主要是基本数据和结构
数据。
基本数据类型一般包括二进制位及其位串、整数及自然数、实数 ( 浮点数 )、字符
和布尔数等。可以说所有系统结构都支持基本数据类型。结构数据类型是一组由相
互有关的数据元素复合而成的数据类型 , 这些数据元素可以是基本数据类型中的元
素 , 也可以是结构数据类型本身中的元素。也就是说这些数据是有结构的 , 它们的结
构在编译时就被确定 , 在执行过程中是不允许改变的。如向量和数组、字符串、堆栈、
队列、记录等 , 结构数据类型中的元素不一定都具有相同类型。如向量和数组中的元

39
素都具有相同类型 , 而记录中的数据元素往往具有不同的类型。大多数系统结构只
能部分地支持结构数据类型。
计算机系统结构中的数据表示指的就是机器硬件能直接识别和引用的数据类
型。这里讲到硬件能够直接识别 , 就是说在系统中能够直接由硬件实现相应数据的
运算 , 也就是系统结构中要有相应的运算指令和运算部件来完成这项任务。那么怎
样表示才能让硬件识别某种数据类型 ?这就涉及到软硬件的交界面了。数据结构所
研究的是软的方面 , 而数据表示考虑的是硬的方面 , 让计算机能够识别处理 , 并尽量
节约存储空间。
数据结构就是指前面所讲的结构数据类型的组织方式 , 它反映了结构数据类型
中各种数据元素或信息单元之间的结构关系 , 它是面向应用和软件的 , 如串、栈、队
列、向量、树、图等线性和非线性的数据结构 , 它们反映了实际应用中各种数据元素或
信息单元之间的联系。比如树这种数据结构 , 里面的元素就有根和叶的层次逻辑关
系。数据结构一般是通过高级语言描述建立的 , 但是计算机硬件并不懂什么是根 , 什
么是叶 , 它只认 0 和 1。这就需要我们确定如何在计算机系统中进行数据表示 , 让硬
件能认识各种数据类型。所以说数据表示是数据结构的一个基础子集合 , 数据结构
通过一定的算法变成数据表示才能在系统中处理 , 不同的数据表示对数据结构提供
不同程度的支持 , 它关系到数据结构的实现效率及方便性 , 它们的差距是高级语言与
机器语言的语义差距 , 数据结构课程的研究范围就是填补这一差距的算法和映像。
关键在于确定哪些数据类型用数据表示实现 , 哪些数据类型采用数据结构来实
现。这本质上是一个软硬件取舍的问题。引入数据表示的原则主要有两个: 一是看
系统效率是否提高 , 这主要体现在程序的执行时间和目标代码所占的存储空间是否
减少。二是看该数据表示的通用性和利用率是否高 , 否则会因为硬件成本的增加而
降低性能价格比。
如要实现向量操作 A = A + B, A 和 B 都是 200×200 的矩阵。如果在没有向量
数据表示的计算机系统上实现 , 一般需要 6 条指令 , 其中有 4 条指令要循环 40 000
次 , 但若在有向量数据表示的机器上实现 , 只需要 1 条“向量加”指令即可 , 这样 , 在访
存和处理机之间的信息传送量仅取指令就减少了 4×40 000 = 160 000 个字。这当然
会使实现时间大大减少 , 而且向量运算部件的流水运算也可节省时间 , 同时可使辅助
开销时间减少(如判越界 , 同时使编译简单 , 主存空间用量节省 ) , 所以说向量指令既
减少了指令存储空间 , 又减少了主存和处理机之间信息量的传送 , 加快了程序的执
行。
如果引入某种数据表示以后 , 只对某种数据结构的实现效率很高 , 而对其他数据
结构的实现效率很低 , 或者引入这种数据表示在应用中很少用到 , 那么为此所花的硬
件代价过多却并未在性能上得到好处 , 必然导致性能价格比的下降 , 特别是对一些复
杂的数据表示。例如 , 引入具有树形数据表示的所谓树结构式机器 , 增加的硬件对树
数据结构的实现是高效的 , 但对堆栈、向量、链表等其他数据结构的实现却是低效的。

40
但若用指针实现树数据结构 , 尽管效率没有树形数据表示的那么高 , 但它能同时比较
高效地实现树、向量、链表、栈、图等多种数据结构 , 花的代价不大 , 但实现数据结构的
适应性、通用性强 , 有利于机器性能价格比的提高。
一般来说 , 一些简单的、常用的、通用的数据类型采用 数据表示 , 如 int , float ,
Boolean, String, stack 等。而复杂的数据结构一般通过数据结构实现或通过软硬件
联合设计实现。如 table, Graph, Tree 等。当前的发展趋势是 , 除基本数据表示外 ,
还不断引入一些复杂数据表示 , 给予数据结构更多的支持。如在目前的计算机系统
中 , 字符串数据表示、向量数据表示、堆栈数据表示等已经普遍使用 , 有些很复杂的数
据表示 , 如图、表等数据表示也开始在某些计算机系统中出现。
另外 , 对于一些复杂的数据类型 , 如果用数据表示来实现 , 硬件的代价可能非常
大 , 然而 , 如果用硬件给予适当的支持 , 或者说 , 用软件和硬件相结合的方法来实现 ,
效果会很好。例如 , 用字节编址和字节运算指令来支持字符串数据表示 , 用变址寻址
方式来支持向量数据表示等。
因此 , 在设计计算机系统时 , 对于数据类型 , 系统结构设计者首先要做的是: 确定
哪些数据类型全部用硬件实现 , 即数据表示 , 哪些数据类型用软件实现 , 即数据结构 ,
哪些数据类型可由硬件给予适当的支持 , 即由软件和硬件共同实现 , 并确定软件与硬
件的适当比例关系。
对于一些基本数据表示 , 也有一些问题是要精心设计的 , 如浮点数的尾数基值的
选取 , 上、下溢处理方法的选择等。下面主要讨论浮点数据表示中尾数基值的选取对
浮点数的影响。
2. 1. 2 浮点数据表示
1 .问题的提出
早期的计算机只有定点数据表示法 , 这种计算机的优点是硬件结构简单 , 但存在
以下不足:
(1 ) 编程困难 , 程序设计人员要做大量的数据规格化工作。即编程人员首先要
把参加运算的数据扩大或缩小某一个倍数后送入机器 , 等运算结果出来后再恢复到
正确的数据。
(2 ) 数据的表示范围小 , 要表示两个大小相差很大的数据 , 需要很长的机器字
长。例如 , 16 位字长的表示范围为 [ - 32768 , 32767 ] , 如要表示相差为 10
61 以上的
数 , 即 2
X > 10
61 , 解为 X > 203 位 , 如再要求精度不低于 10 进制 7 位 , 则有: 2
- X <
10
- 7 , 解为: X > 23 位 , 这样定点数表示总共需要:203 + 23 = 230 位。
(3 ) 数据存储空间的利用率低。例如 , 为了把小数点的位置定在数据最高位前
面 , 必须把所有参与运算的数据至少都除以这些数据中的最大数 , 只有这样才能把所
有数据都化成纯小数 , 因而会造成很多数据有大量的前置零 , 从而浪费了许多数据存

41
储单元。为此 , 引入了浮点数据表示法。
浮点数表示方式研究的核心内容是数据字长与这种数据表示方式下的表数范
围、表数精度和表数效率三者之间的关系。在数据字长确定的情况下 , 研究各种浮点
数表示方式下的表数范围、表数精度和表数效率及它们三者之间的关系 , 其目的是找
到具有最大表数范围、最高表数精度和最优表数效率的浮点数表示方式。
2 .浮点数的表示范围
对任意浮点数 N, 可表示为: N = m× r
e
m 的形式 , 其中: e= r
g
e ;
一种浮点数据表示方式需要 6 个参数来定义 , 分别为:
m: 尾数 , 多数机器中采用规格化小数表示 , 只有少数机器采用整数表示;
e:阶码的值 , 一般采用整数、移码表示 , 只有少数采用补码表示;
rm : 尾数的基 , 一般采用二进制、四进制、八进制、十六进制和十进制等;
re : 阶码的基 , 在目前见到的所有浮点数据表示方式中 , 均为 2;
p:尾数长度 (不包括符号位) , 不是指尾数的二进制位数 , 如当 rm = 16 时 , 每 4 个
二进制位表示一位尾数;
q:阶码长度 , 由于 re = 2, 所以 , 在一般情况下 , q 就是阶码部分的二进制位数。
一种浮点数表示方式 , 即在数据存储单元中的存放方式 , 如图 2 .1 所示 , 其中 ,
mf 表示尾数的符号 , ef 表示阶码的符号。
1
1
q
p
mf
ef
e
m
图 2 .1 浮点数的表示方式
在尾数采用原码、纯小数 , 阶码采用移码、整数的浮点数表示方式中 , 规格化浮点
数 N 的表数范围 , 如表 2 .1 所示。
表 2 .1
尾数用原码、纯小数时规格化浮点数的表数范围

当尾数用补码表示时 , 正数区间的表数范围与尾数采用原码时完全相同 , 而负数
区间的表数范围为: - r
rq
e - 1
m
≤ N≤ - ( r
- 1
m
+ r
- p
m )× r
- rq
e
m
, 如表 2 .2 所示。
表 2 .2
尾数用补码、纯小数时规格化浮点数的表数范围

例如 , 尾数用补码、纯小数表示 , 阶码用移码、整数表示 , p = 6 , q = 6 , rm = 16, re =
2, 规格化浮点数 N 在正数区间的表数范围是:
1
1616
- 26 ≤ N ≤ ( 1 - 16
- 6 ) × 16
2 6 - 1
在负数区间的表数范围是: - 16
63 ≤ N≤ - ( 1
16 + 16
- 6 )×16
- 6 4
在浮点数表示方式中尾数采用规格化小数的目的是为了在尾数中表示最多的有
效数据位及数据表示的惟一性。如:
0 .003475 - - - > 0 .3475 * 10
- 2
从上面的分析中可以看到 , 规格化浮点数的表数范围主要与阶码的长度 q 和尾
数的基值 rm 有关。这时 , 能表示的绝对值最大的浮点数可近似为:
Nmax
= r
rq
e
m
( 2 .1)
可以看出 , 表数范围随着 q 和 rm 的增加而扩大。
3 .浮点数的表数精度
表数精度也称为表数误差 , 浮点数存在表数精度的根本原因是由于浮点数的不
连续性造 成的。由 于 在上 述 表示 方 法下 , 浮 点数 能 够表 示 数据 的 个数 最 多为:
2
p + q + 2 , 而实际数据(实数) 的变化是连续的 , 即数的个数是无限的。因此 , 浮点数表
示的仅仅是实数的一个子集 , 称为浮点数集 F。

43
令 N 为实际要表示的实数 , 而 M 是 F 中最接近 N 的浮点数 , 且被用来代替 N
的浮点数 , 则浮点数表数的绝对误差为:
δ= | M - N |
而相对表数误差为:
δ=
M - N
N
产生表数误差的原因有两个 , 一是假设两个数 a, b∈ F, 但 a 和 b 运算后不一定
在 F 集内 , 设 c= a op b, 但 c| F, 因此只好用数 c′∈ F 来表示数 c, 因此可能造成表
数的绝对误差和相对误差。另一个是原始数据从外部进入计算机的过程中 , 通常要
将数据从十进制转换成二进制、四进制、八进制等 , 而这一转换过程就有可能产生表
数误差。如遇到循环小数时 , 用有限长度的尾数是不能精确表示循环小数的。
如一种浮点数表示方式的 q = 1, p = 2, rm = 2, re = 2, 尾数用原码、纯小数表示 , 阶
码用移码、整数表示 , 则所能表示的浮点数 , 如表 2 .3 所示。
表 2 .3
一种浮点数表示方式所能表示的全部浮点数

若有两个浮点数: a1 = 1/ 2, b1 = 3/ 4 都在所定义的浮点集内 , 而它们相加的结果
a1 + b1 = 5/ 4 , 则不在这个浮点数集内 , 为此必须用该浮点数集内的最靠近 5/ 4 的浮
点数 1 或 3/ 2 来代替 , 从而产生绝对表数误差:
δ= | 5/ 4 - 3/ 2 | = 1/ 4 或 δ= | 5/ 4 - 1 | = 1/ 4
相对表数误差为:
δ=
5/ 4 - 3/ 2
5/ 4
= 1/ 5 或 δ=
5/ 4 - 1
5/ 4
= 1/ 5
由于浮点数的尾数有效位长度是确定的 , 因此 , 对规格化浮点数而言 , 相对误差
是确定的 , 而绝对误差是不确定的。
又如把十进制数 0 .1 输入二进制的计算机中 , 会出现循环小数 , 即:
0 .1( 1 0 ) = 0 .000110011001100⋯( 2 )
= 0 .0121212⋯( 4 )
= 0 .06146314⋯( 8 )

44
= 0 .1999⋯( 1 6 )
由于物理存储空间的有限和数据表示的无限是矛盾的 , 只好采用舍入的方法 , 这
些都会造成浮点数的表数误差。
实际上尾数的基 rm 需要用 m′个二进制位表示 , 具体如下:
m′=
log2 rm
例如 , 十进制数下的 m′= 4, 表示一个十进制数位要用 4 个二进制位表示。因此 , 尾
数 m 的实际数位 k 为: k = p× m′, 这样 , 浮点数的表示方法如图 2 .2 所示
。
图 2 .2 浮点数的实际表示方式
由以上分析可知 , 规格化浮点数的表数精度主要与尾数基值和尾数长度有关 ,
在一般情况下 , 认为规格化尾数最后 1 位的精确度是一半 , 这样可以定义表数精度如
(2 .2 )式所示:
δ( rm , p) = 1
2 r
- ( p - 1 )
m
( 2 .2)
当 rm = 2 时 , 有δ( 2) = 1
2 ×2
- ( p - 1 ) = 2
- p
( 2 .3)
这样 , 可以得出 , 当用 p2 个二进制位表示尾数 rm 时 , rm 的实数位为:
p =
p2
log2 rm , rm = 2
log2 r m , 代入 (2 .2 )式 , 有:
δ( rm ) = 2
log2 rm - 1 × 2
- p2
( 2 .4)
比较式(2 .4 )和式( 2 .3) , 由于式( 2 .4 )中的 p2 就是式 ( 2 .3) 中的 p, 所以可得出
如下结论:
当浮点的尾数长度( P2 值)相同时 , 尾数取值 rm = 2 具有最高的表数精度。当尾
数取基值 rm > 2 时 , 浮点数的精度和 rm = 2 相比将损失 2
log 2 r m - 1 倍 , 即相当于尾数减
少了 log2 rm
- 1 个二进制位。
实际上 , 得出上述结论是很显然的 , 因为 , 当尾数基值 rm = 2 时 , 规格化浮点数的
尾数肯定没有前置 0, 全部尾数都是有效位 , 而当尾数基值 rm > 2 时 , 规格化浮点数
的尾数最多可能有 log2 rm
- 1 个前置 0 , 所以 , 当尾数 rm > 2 时 , 浮点数的表数精度
与 rm = 2 相比将损失 2
l og2 r m - 1 倍。
例如 , 当尾数基值 rm = 16 时 , 规格化浮点数的尾数可能有 3 个前置 0 , 因此其表

45
数精度与 rm = 2 时相比将损失 2
3 倍 , 即相当于尾数减少了 3 个二进制位。
4. 浮点数的表数效率
通常把最高位为非 0 的浮点数称为规格化浮点数。因此 , 规格化尾数 x 值可表
示为:1/ rm < | x| < 1( 0 除外)。因机器零的尾数和阶码都是 0, 所以它也是一个规格
化浮点数。
同一种浮点数表示方式中 , 规格化浮点数具有最长的尾数有效位数 , 所以 , 规格
化浮点数的表数精度是最高的。
在采用浮点数表示方式的计算机中 , 一般规定存放在存储部件中的浮点数、进入
运算部件的浮点数、从运算部件中输出的浮点数都必须是规格化浮点数 , 只有在运算
过程中才可能出现非规格化的浮点数。浮点数的表数效率定义为:
η= 可表示的规格化浮点数
全部浮点数个数
= 2 × ( rm - 1 ) × r
p - 1
m
× 2 × r
q
e + 1
2 × r
p
m × 2 × r
q
e
≈ rm - 1
rm
( 2 .5)
在上式的分子分母中 , 第一个 2 表示尾数的正负数各半 , 第二个 2 表示由于阶码的符
号位使编码种数增加 1 倍。分子中的最后一个 1 表示机器 0。
从式(2 .5 )可以看出 , 浮点数的表数效率主要与尾数的基值有关。
例如 , rm = 2 时 ,η(2 ) = 50%
rm = 16 时 ,η( 16 ) = ( 16 - 1)/ 16 = 93 .75%
尾数基值 rm = 2 与 rm = 16 相比 , 浮点数的表数效率提高了:
T = η( 16 )
η(2 )
= 1 .875 (倍)
5 .浮点数尾数基值的选取
从上面的分析中可以看到 , 浮点数的表数范围、表数精度和表数效率三个主要特
征都与尾数的基值 rm 有关 , 因此 , 这里主要讨论在浮点数表示方法中 , 尾数基值 rm
应当如何选取。
尾数基值 rm 的选择主要考虑两个因素: 一是在机器字长一定的情况下 , 即 p + q+
2 为定值时 , 如何使表数范围最大、表数精度和表数效率最高; 二是在尾数基值确定之
后, 如何根据表数范围和精度的要求 , 确定 p 和 q 值。下面主要讨论第一种因素。
从式(2 .1 )中看到 , 浮点数的表数范围主要与阶码的长度 q 和尾数基值 rm 有关 ,
从式(2 .2 )中看到 , 表数精度主要与尾数长度 p 和尾数基值 r m 有关。现假设两种浮
点数表示方式 F1 和 F2, 它们的二进制字长相同 , 尾数都用原码或补码、小数表示 , 阶
码都用移码、整数表示 , 阶码的基值均为 2, 而尾数的基值不同。
设浮点数表示方式 F1 : 尾数基值 rm1 = 2, 尾数长度 p1 , 阶码长度 q1 , 二进制字

46
长: L1 = p1 + q1 + 2
浮点数表示方式 F2: 尾数基值 rm2 = 2
k , 尾数长度 p2 , 阶码长度 q2 , 二进制字长:
L2 = k p2 + q2 + 2
(1 )当 L1 = L2 , 且
N1max
=
N2 max
时 , 分析尾数基值和精度的关系:
分析:由于
N1max
=
N2max
, 且
N1 max
= 2
2
q1 ,
N2 max
= (2
k )
2
q2 = 2
k×2
q2 , 所以:
2
q1
= k× 2
q2 , 即: q1 = q2 + log2 k
( 2 .6)
由于 L1 = L2 , 即 p1 + q1 = kp2 + q2
( 2 .7)
将式(2 .6 )代入式( 2 .7) 得:
p1 = kp2 - log2 k
( 2 .8)
由式(2 .2 )可知 , F1 的表数精度是:
δ
1 (2, p1 ) =
1
2 × 2
1 - p1
( 2 .9)
把式(2 .8 )代入式( 2 .9) 得:
δ
1 (2, p1 ) =
1
2 × 2
1 - kp2 + log2 k
(2 .10)
F2 的表数精度是:
δ
2 (2
k , p2 ) =
1
2 × 2
k( 1 - p2 )
(2 .11)
为了考察 F1 与 F2 的表数精度之间的关系 , 取它们的比值:
T = δ
2
δ
1
= 2
k - l og2 k - 1
(2 .12)
由式(2 .12) 可以得出 , 只有当 k= 1(表示 rm = 2) 或 k = 2 (表示 rm = 4 )时 , 比值 T = 1,
否则 T > 1。这说明:
① 当 k > 2 时 , 即 rm > 4 时 , F2 的表数精度将低于 F1。
② 在浮点数的字长和表数范围一定时 , 尾数基值取 2 或 4 具有最高的表数精度
(2 )分析在浮点数的字长和表数精度一定时 , 尾数基值与表数范围之间的关系。
即 L 和δ一定的情况下 , rm 和
N max
间的关系 ?
由 F1 与 F2 的表数精度相同得到:
1
2 ×2
1 - p1 = 1
2 ×(2
k )
1 - p2 , 即:
p1 = kp2 - k + 1
(2 .13)
把式(2 .13) 代入式(2 .7 )得到:
q1 = q2 + k - 1
(2 .14)
则 F1 的表数范围:
N1 max
= 2
2 q1 = 2
2
q2 + k - 1
= 2
2
q2 ×2 k - 1

47
F2 的表数范围:
N2 max
= (2
k )
2 q2 = 2
2 q2 × k
现假设 F2 的表数范围大于 F1 的表数范围 , 则 F2 的阶码的最大值要大于 F1 的阶码
的最大值:
2
q2 × k > 2
q2 × 2
k - 1
即:
k > 2
k - 1
(2 .15)
式(2 .15) 在整数定义域内是无解的 , 这表明:
① 不存在比 F1 的表数范围更大的浮点数表示方式。
② 当 k = 1 ( rm = 2)或 k = 2( rm = 4 )时 ,
N1 max
=
N2 max
。
由以上(1 ) , (2 )的分析 , 可以得出如下结论:
当浮点数字长确定后 , rm 取 2 或 4 时 , 具有最大的表数范围和最高的表数精度。
实际上发生这种情况的根本原因是:当浮点数的尾数基值从 rm = 2 增大时 , 表数
精度是按尾数字长的指数关系变小 , 而表数范围却按阶码字长的指数的指数关系变
大 , 因此 , 为了保持同样的表数精度和表数范围 , 损失的尾数字长大于节省的阶码字
长 , 从而造成浮点数的总字长增加。
上面的结论说明 , 从浮点数的表数范围和表数精度看 , 尾数基值取 2 或 4 时最
好 , 但由于 rm = 2 时 , 表数效率却最低 , 只有 50 % , 为了提高表数效率 , 许多计算机系
统采用了隐藏位表数法。其主要原因是当 rm = 2, 且采用规格化方法时 , 尾数 m 的最
高位一定为 1, 故可以隐藏或省去 , 此时表数效率η= 100% , 但 rm = 4 时 , 就不能采用
隐藏位表数法 , 因为尾数可从 00, 01, 10, 11 中取值。
由上述综合分析可以得出:当 rm = 2 时 , 且采用隐藏位表数法时 , 能使浮点数的
表数范围最大 , 表数精度最高 , 表示效率最优。
IBM 公司的 IBM 360 系列机、IBM 370 系列机、IBM 4300 系列机等 , 浮点数的
尾数基值是 16。Burroughs 公司的 B6700 , B7700 等大型计算机 , 浮点数的尾数基值
取的是 8。DEC 公司的 VAX-11 和 Alphs 等 计算机 , CDC 公 司的 CDC6600, CY-
BER70 等大型计算机及应用最广泛的 Intel 公司的 X86 系列机等的浮点数均采用尾
数基值 2。浮点数尾数基值不取 2 的原因可能是早期计算机设计人员对浮点数的研
究不够深入 , 后来虽然弄明白了尾数基值取 2 最好 , 但是为了系列计算机具有兼容
性 , 也只能如此了。
2. 1. 3 IEEE754 标准浮点数表示
二进制浮点数的表示 , 由于不同机器所选用的基值、尾数位长度和阶码位长度不
同 , 因此对浮点数表示有较大差别 , 这就不利于软件在不同计算机间的移植。美国
IEEE(电气及电子工程师协会 )为此提出了一个从系统结构角度支持浮点数的表示
方法 , 称为 IEEE 标准 754 (1985) , 它是一种优化表示法 , 当今流行的计算机几乎都采

48
用了这一标准。
IEEE754 标准在表示浮点数时 , 每个浮点数均由三部分组成: 符号位 S , 指数部
分 E 和尾数部分 M。
浮点数一般采用以下四种基本格式:
(1 ) 单精度格式( 32 位 ) :除去符号位 1 位后 , E = 8 位 , M = 23 位。
(2 ) 扩展单精度格式: E≥11 位 , M≥31 位。
(3 ) 双精度格式( 64 位 ) : E = 11 位 , M = 52 位。
(4 ) 扩展双精度格式: E≥15 位 , M≥63 位。
在 IEEE754 标准中 , 约定小数点左边隐含一位 , 通常这位数就是 1, 这样实际上
使尾数的有效位数为 24 位( 单精度) , 即尾数为 1 .M。指数的值在这里称为阶码 , 为
了表示指数的正负 , 所以阶码部分采用移码表示 , 移码值为 127, 阶码值即从 1 到 254
变为 - 126 至 + 127, 在 IEEE754 标准中所有的数字位都得到了使用 , 明确地表示了
无穷大和 0, 并且还引进了“非规格化数”, 使得绝对值较小的数得到更准确的表示。
IEEE754 标准的单精度和双精度浮点数表示格式 , 如图 2 .3 所示。
1 位 S
指数 E(8 位 )
尾数 M(23 位 )
(a)单精度
1 位 S
指数 E(11 位 )
尾数 M(52 位 )
( b) 双精度
图 2 .3 IEEE754 标准浮点数表示格式
其中 , 阶码值 0 和 255 分别用来表示特殊数值: 当阶码值为 255 时 , 若分数部分为 0,
则表示无穷大;若分数部分不为 0 , 则认为这是一个非数值 NaN( Not a Number) 。当
阶码和尾数均为 0 时 , 则表示该值为 0, 因为非零数的有效位总是大于等于 1, 因此特
殊约定其表示为 0。
概括起来, 由 32 位单精度所表示的 IEEE754 标准浮点数 N 的解释 ,如表 2 .4 所示。
表 2 .4
IEEE754 单精度浮点数的表示方法
S(1 位)

49
注意当数字 N 为非规格化数或是 0 时 , 隐含位是 0。
由此可见 , IEEE754 标准使 0 有了精确表示 , 同时也明确地表示了无穷大 , 所
以 , 当 a/ 0( a 不等于 0 ) 时得到结果值为±∞; 当 0/ 0 时得到结果值为 NaN。对于绝
对值较小的数 , 为了避免下溢而损失精度 , 允许采用比最小规格化数还要小的数来表
示 , 这些数称为非规格化数( Denormal number ) , 应注意的是 , 非规格化数和正、负零
的隐含位值是 0, 而不是 1。
IEEE754 标准单、双精度浮点数的特征如表 2. 5 所示。
表 2 .5
IEEE754 标准单、双精度浮点数的特征

2+ 128
2+ 1024
十进制数范围
10 - 38 ～ + 10 + 38
10 - 308 ～ + 10+ 308
最小非规格化数
10
- 45
10
- 324
下面举两个例子来说明 IEEE754 标准浮点数的表示:
(1 ) N = - 1 .5, 它的单精度格式表示为:
1 01111111 10000000000000000000000
其中 , S = 1, E = 127, M = 0 .5 , 因此 N = ( - 1 )
1 ×2
1 27 - 127 ×(1 .5 ) = - 1 .5
(2 ) 以下的 32 位数所表示的单精度浮点数为:
1 10000001 01000000000000000000000
其中 , S = 1, E = 129, M = 0 .25, 由公 式 N = ( - 1 )
1 × 2
1 29 - 12 9 × ( 1 .25 ) = - 2
2 ×
1 .25 = - 5
2 .2 高级数据表示
一般可把数据表示分为两大类:基本数据表示和高级数据表示。基本数据表示
包括定点数据表示、浮点数据表示、逻辑数据表示、十进制数据表示等; 而把自定义数

50
据表示、向量数据表示、堆栈数据表示等归纳为高级数据表示一类。第一节已经介绍
了浮点数这种基本数据表示方法 , 这节主要了解在机器中不断引入的一些高级数据
表示对数据结构提供的支持等。
2. 2. 1 自定义数据表示
高级语言中数据运算表达式是统一的 , 而数据类型是用专门的类型说明语句来
说明的 , 但在机器语言中对同一运算要针对不同的数据类型使用不同的指令。即对
于目前的大多数计算机 , 数据存储单元( 如寄存器、主存、外存等 ) 里存放的都是纯数
据 , 而对这些数据的类型( 如定点数、浮点数、复数、字符串、逻辑数等 )、进位制 (如二
进制、十进制、十六进制)、字长(如字、半字、双字等 )、寻址方式、功能( 如地址、数值、
控制字、标志等) 等的解释要通过指令中的操作码来进行。如 IBM 370 的加法指令
就有 8 条 , 这些指令所用到的操作类型、字长、进位制和操作数所采用的寻址方式等
均不相同。又如 Intel86X 中的乘法指令也有 Mul , Imul 两种。
为了缩小这一语义差距 , 减轻编译软件工件量 , 在有些计算机中引进带数据类型
标志的自定义数据表示 , 这样就可以把不同类型的同种运算指令统一起来 , 使每种指
令的种类大为减少 , 称为通用化指令( 即操作说明与数据类型无关)。
自定义数据表示包括带标志符的数据表示和数据描述符二类。下面分别介绍这
两种数据表示方式。
1 .带标志符的数据表示(Tagged data representation)
带标志符的数据表示指的是用以定义某个数据的数据类型和数值的数据表示方
法。格式如图 2 .4 所示。
标志符
数据
图 2 .4 带标志符的数据表示方式
美国 Burroughs 公司在 20 世纪 60 年代初期生产的 B5000 大型计算机中 , 每个
数据有一位用来区分是操作数还是描述符; 在 60 年代后期生产的 B75000 大型计算
机中 , 每个数据用三位标志符来区分 8 种数据类型。在 70 年代生产的 R-2 试验性计
算机中采用了 10 位标志符 , 如图 2 .5 所示。
图 2 .5 中的最高两位用来区分操作数、指令、地址、控制字; 两位陷阱位可由软件
定义四种捕捉方式 , 为程序员跟踪程序的执行提供方便; 一位封写指定数据是只读的
还是可读可写的;四位类型可以在最前面两个功能位定义的基础上进一步定义是二
进制、十进制、定点数、浮点数、复数、字符串、单精度、双精度等 , 如果最前面两位已经
定义了是地址 , 则四个类型位可进一步说明是绝对地址、相对地址、变址地址、未连接

51
的地址等;最后一位是奇偶检验位。

数值
图 2 .5 R-2 计算机中带标志符的数据表示方式
由上可知 , 带标志符的数据表示 , 不仅可以定义数据类型 , 而且还可以用来描述
机器中用到的各种有用信息。它通常由系统软件和高级语言的编译器建立 , 对高级
程序员和计算机用户是透明的。
(1 ) 采用标志符数据表示方法主要有以下几方面的优点:
1) 便于实现一致性检验 , 硬件自动实现数据转换
在采用标识符的数据表示后 , 数据类型的一致性检查和转换等都用硬件完成 , 能
快速检测出参加运算的数据是否定义错误 (如一个浮点数与一个字符相乘 ) , 是否不
相容(如一个浮点数与一个定点数相加 , 两个字长不相等的定点数相加等) 。如果发
现数据类型定义有错误 , 则进入出错中断处理程序 , 如果发现数据类型不相容 , 则由
硬件自动进行数据类型和数据长度的变换 , 从而缩短了目标程序的长度 , 减少了占用
的空间。因为在 Compiler 中 , 这种数据一致性检测程序要反复使用 , 如能通过硬件
实现加以优化 , 则将大大提高程序执行的效率并减小占用空间。
2) 标志符方法减少和简化了指令系统
指令中的操作码只需指出操作种类 , 不必指出数据类型 , 指令的条数必然减少很
多 , 而且数据的一些信息也不必再通过指令系统进行描述 , 因而可简化指令的地址
码 , 简化访问主存的命令、输入输出指令和程序控制指令。
3) 简化了系统程序和编译程序的设计
自动实现数据类型的一致性检验和数据转换 , 简化了编译程序的设计 , 而且这种
数据表示缩小了人与计算机之间的语义差距 , 从而使程序设计变得更加容易。
4) 方便程序调试和应用软件开发
通过设置陷阱位 trap 位 , 可以捕捉指令执行状态。陷阱位可通过软件设置 , 也
可在调试程序时手工设置 , 这一功能为软件的跟踪和调试提供了极大的方便 , 必然会
缩短软件开发的周期。
5) 支持 DBS 的实现与数据类型无关的需求
即一个软件不加修改就可适用于多种数据类型 , 标志符数据表示方式正好支持
这种要求。在一般计算机系统中要实现软件与数据类型无关是非常困难的。
(2 ) 对采用带标志符数据表示的主要质疑是:
1) 当采用标志符数据表示时 , 整个程序的存储空间是增大还是变小了呢
由于每个数据都带有标志符 , 这必然要加长数据的字长 , 从而使数据所占用的存

52
储空间增加。但由于这种表示方法简化了指令系统 , 指令只需指出操作种类 , 不需要
指出数据类型等 , 每条指令的字长可以缩短 , 只要设计合理 , 整个程序( 包括指令和数
据)的总存储量反而有可能减少 , 即使增加也不会增加得太多 , 如图 2 .6 所示
。
图 2 .6 采用标志符表示后可能节省的程序空间
从图 2 .6 中可以看出 , 采用标志符数据表示方法后 , 总的存储空间的占用是否
增加 , 取决于面积 A 和面积 B 哪一个大。通常情况下 , 数据字增长所占用存储空间
的增加(面积 A)是小于指令字缩短所减少占用的存储空间( 面积 B)的 , 此外 , 由于带
标志符数据表示使编译简化 , 从而使编译程序所占用的程序空间减小 , 所以说 , 总的
存储空间一般情况下是减小的。
但在这种情况下 , 会造成数据和指令的长度可能不一致。解决的方法通常有两
种:一种是把数据和指令分别存放在两个存储器中 , 即采用多体存储方案 (第四章中
详细介绍) ; 另一种是合理设计数据字长和指令字长 , 一般的设计原则是指令字长向
数据字长靠拢。
2) 指令的执行速度降低
这是因为在指定的执行过程中 , 要对每个标志符进行逐个解释 , 并判断数据是否
相容 , 因此将导致指令本身的执行速度降低 , 但可使程序的宏观速度加快。这是因为
程序的宏观执行时间是程序的设计时间、编译时间、调试时间和执行时间的总和。前
三项称为宏观速度 , 执行时间称为微观速度。采用标志符数据表示法提高了宏观速
度 , 而降低了微观速度。
3) 硬件设计的复杂性提高
由于要用硬件实现数据相容性、一致性测试 , 实现数据类型的自动转换 , 并解释
所有标志符 , 因此采用标志符数据表示法的计算机系统 , 其硬件复杂度很大 , 过去仅
在少数大型计算机和巨型计算机中采用 , 然而 , 随着 VLSI 技术的迅速发展 , 硬件复

53
杂度将不再成为一个大的问题。
带标志符的数据表示在商品化计算机中并不流行 , 但在需要支持含有动态数据
类型的高级语言中(如 LISP 和 PROLOG 的系统结构)应用得较多。美国 Intel 公司
生产的 8087 微处理器 , 日本为研制第五代计算机而生产的个人计算机中都采用了标
志符数据表示方法。
综上所述 , 采用标志符数据表示法虽然硬件复杂度高 , 机器的微观速度可能降
低 , 但是 , 由于它能缩短人与计算机之间的语义差距 , 能减少高级语言与机器语言之
间的语义差距 , 能提高机器的宏观性能 , 因此这是一种很有前途的数据表示方法 , 目
前有待研究的关键问题是如何定义好标志符 , 如何进一步扩大标志符的用途等。
2 .数据描述符表示法(Data descriptors)
上面提到的带标志符的数据表示 , 对每一个数据都需要附加标志位 , 但在数组
中 , 不一定要对数组中的每个元素都附加标志位 , 因为数组中各个元素具有相同属
性 , 只需对整个数组配以一个标志符就可以了 , 从而引出了另一种自定义数据表示 ,
即数据描述符。所以说数据描述符是用于描述复杂和多维结构的数据类型 , 对于这
类数据 , 可用一个描述符来说明一个同类数据的集合 , 如向量、矩阵、记录等。
数据描述符的格式如图 2 .7 所示
。
图 2 .7 数据描述符的格式举例
图 2 .7 中描述符标志位部分指明了这是一个数据描述符; 特征标记部分指明了
所描述数据的各种特征;长度部分指明所描述数据的长度 , 即数组中元素个数; 起始
地址部分则指明了所描述的一组数据的首址。
美国 Burroughs 公司率先在它的商品化计算机 B-6700 中采用了数据描述符 , 格
式如图 2 .8 所示。

图 2 .8 B-6700 计算机的数据描述符表示法

54
每个 48 位长的字 , 附加有 3 位标志符。当标志符为 000 和 010 状态时 , 分别表
明后面 48 位长的字为单精度和双精度数据 , 此时就成为 51 位长的带标志位的数据
字。当标志符为 101 时 , 就表示该字为描述符。它的后 48 位被分成 3 个字段 , 前 8
位为特征标志位 , 指明要描述的数据块的主要属性 , 后面两个 20 位长的字段则分别
指明数据块的长度和数据所在的首地址。应注意的是 , 描述符是对它所指向的数据
块的共性描述 , 为数据块中所有数据字所共享 , 但对数据块中的每个数据字 , 则仍有
3 位附加标志符以表明它是属于哪一类型的数据字。
8 位标志位的含义:分别表示是否描述另一个数据描述符 , 描述的是单个数据还
是数据块 , 是连续存放还是分段存放 , 是字还是串 , 是单精度数据还是双精度数据 , 是
可读可写还是只读。
借助描述符访问指令所需操作数的过程 , 如图 2 .9 所示。按指令操作数地址 X,
Y 访存 , 若取来的字 , 其前三位为“000”, 就是所需的操作数 , 若为“101”, 表明它是描
述符 , 将它取到描述符寄存器 , 由它的标志位、长度和地址字段联合控制 , 经地址形成
逻辑、操作数的地址 , 再访存取操作数。当然 , 对于数据块 , 访存取到寄存器的描述
符 , 能应用于块内的所有元素 , 不必每次访存取元素时都去加上访存取描述符的操
作。这样 , 只需用这样一条指令就能执行对整个数据块的运算。
采用描述符方式操作处理数据块时可以有较简单的访存过程及越界校验等操
作。这种表示方法为向量、多维数组等数据结构提供了较好的硬件支持 , 可以用一条
指令控制整个阵列的运算 , 采用数据描述符方法形成数据地址的速度比常规计算机
中采用的变址寻址要快得多 , 这样有利于简化编译中的代码生成 , 加快处理。
例如 , 通过多次使用描述符访问可方便地描述多维数据结构 , 如要构成一个 3×
2 的二维数组 , 可用图 2 .10 所示的方法加以描述。
采用数据描述符表示法的优点、缺点与带标志符数据表示法相同 , 它的计算机结
构可能比标志符数据表示法更复杂。
两种自定义数据表示方法的主要区别是:
① 标志符要与每个数据相连 , 两者合存在一个存储单元中 , 而描述符则和数据
分开存放。
② 要访问数据集中的元素时 , 必须先访问描述符 , 这就至少要增加一级寻址。
③ 描述符可看成是程序的一部分 , 而不是数据的一部分 , 因为它是专门用来描
述要访问的数据的特性的 , 例如 , 指明是访问整块还是单个数据 , 访问数据块或数据
元素所需要的地址 , 数据块的长度等。
2. 2. 2 向量数据表示
如何为向量数据结构的实现和快速运算提供更好的硬件支持 , 是系统结构设计
的另一个重要问题。

55
图 2 .9 通过描述符取指令所需操作数的过程
图 2 .10 用描述符描述二维数组
为了较好地从硬件角度支持向量数据结构的实现和快速运算 , 在 20 世纪 60 年
代中期就已在一些向量计算机系统结构中提供了向量数据表示 , 如 CDC STAR-100

56
计算机系统以及 TI-ASC 计算机系统。70 年代以后 , 出现了向量计算机 , 如 CRAY
公司推出的 CRAY-1 巨型计算机 , 更使向量数据表示得到了进一步的改进和完善。
在这种计算机中 , 把向量数据类型直接作为一种有硬件支持的数据表示。
例如 , 若要计算 ci = ai + bi - 8 , i = 4, 5, ⋯ , 11 的向量加法时 , 用 FORTRAN 可
写成如下的 DO 循环部分:
DO 20 I = 4, 11
20 C( I) = A (I ) + B( I - 8 )
像这种情况就很难采用数据描述符进行优化。
如果在标量机上运行时 , 因没有向量数据表示 , 故在编译后需借助变址操作实
现 , 各条指令只能顺序执行。但若在有向量数据表示的计算机上运行 , 由于设置了相
应的向量运算指令和快速的向量运算部件 , 就可大大加快这种向量运算操作。为了
实现上述 DO 循环的全部功能 , 可设置如下的一条向量加法指令:
向量加
X
A
Y
B
Z
C
X , Y, Z 各区段表示寄存器号 , 分别存放源向量 A , B 和结果向量 C 的位移量 , 而
A , B, C 各区段分别存放源向量 A , B 和结果向量 C 的基址及长度。
图 2 .11 示出了根据上述向量加法指令中所给出的参数 , 对 A , B, C 三个向量进
行编址的情况。图中各向量的脚标 b , d, s 和 e 分别表示相应向量的基址、位移量、起
始地址和向量有效长度 , 其中操作向量的起始地址 = 基址 + 位移量 , 而向量有效长
度 = 向量长度 - 位移量 , 若向量指令中 X, Y 和 Z 所指明的寄存器内容分别为 4, - 4
和 4, A , B 和 C 的值分别为 12, 4 和 12 , 图 2 .11 中标出了其有关的参数值。此时仅
需用一条向量指令:
C( 4∶11 ) = A(4∶11) + B( - 4∶3)
就可代替前述的 DO 循环语句。
在向量处理中经常会遇到稀疏向量( 即含有大量零元素的向量) , 为了节省存储
空间和处理时间 , 通常采用压缩向量的表示方法。压缩一般要分为两步实现: 第一
步 , 先形成一个向量 Z, 它是一个“位向量”, 用来指明稀疏向量中各元素的状况及所
在位置。第二步 , 根据 Z 向量的内容将稀疏向量与 Z 向量中“1”元素相对应的向量
元素存入指定存储单元 , 转变成压缩向量 , 如图 2 .12 所示。这样不但可节省存储稀
疏向量的空间 , 也可使实际的向量运算长度减少 , 从而可加快稀疏向量的运算。有序
向量 Z 在稀疏向量的生命周期内应予以保存 , 这样在运算结束后仍可根据有序向量
Z 再恢复原来的稀疏向量。
2. 2. 3 堆栈数据表示
在计算机系统软件和程序设计技术中较为广泛应用的一种数据结构是堆栈。堆
栈实际上是一种有序表 , 对堆栈数据处理是依据后进先出的原则 , 所以堆栈也称为后

57
图 2 .11 向量数据表示所用的参数
进先出表。堆栈只是一个数据出入的端口 , 数据存入堆栈称为压入 , 数据从堆栈取出
称为弹出。数据在堆栈中的存取过程 , 就像子弹在弹夹中压入与弹出的过程一样 , 先
将堆栈内原来存放的数据依次向栈底移动一个单元 , 使栈顶空出来存放新的数据; 当
从堆栈弹出数据时 , 从栈顶单元取数据 , 并使下边所存数据依次向栈顶移动一个单
元 , 使栈顶后的第二个单元数据填充到栈顶。可见 , 数据的存取只能在栈顶单元进
行。
为了控制简单 , 便于逻辑实现 , 一般在压入、弹出时 , 栈内数据单元地址不变 , 而
使栈顶单元改变。
堆栈数据操作的重要特点是指令只需指出进行什么样的操作 , 而无需指出操作
数地址。但由于堆栈在主存中 , 取栈顶操作数和次栈顶操作数以及运算结果压入堆
栈都需要访问主存 , 所以堆栈指令是很慢的。为了改善这种情况 , 在有的堆栈型计算
机中 , 由高速寄存器组成硬件堆栈 , 并附加控制电路使之与主存中的堆栈联为一体 ,
这样 , 指令中对栈顶和次栈顶数操作时可直接在寄存器中进行 , 不必访存操作 , 可大
大加速堆栈指令的执行速度。

58
图 2 .12 稀疏向量、有序向量和压缩向量
堆栈数据表示 , 对于复杂的算术表达式的求解是比较方便的。将算术表达式转
用逆波兰表示法 , 在堆栈上进行计算很方便 , 可以缩短计算程序。
另外 , 堆栈数据表示支持对子程序的嵌套和递归调用 , 在堆栈计算机上还含有很
丰富的堆栈操作类指令且功能很强 , 直接可对堆栈中的数据进行各种运算和处理。
堆栈结构及逆波兰表示法的特点被广泛应用于高级语言的编译技术和程序调用
技术等方面 , 所以现代计算机系统结构中一般都设置有堆栈型数据表示。具有堆栈
型数据表示且以面向堆栈寻址方式为主的计算机称为堆栈型计算机。
2 .3 寻址方式与指令格式的优化设计
指令系统是软件与硬件的一个主要分界面 , 是计算机系统结构的一个重要组成
部分。而寻址技术又是指令格式设计中要重点考虑的一个方面 , 本节就主要介绍常
用的几种寻址方式及其优缺点、指令中操作码的几种编码方法 , 在此基础上给出如何
进行指令格式的优化设计 , 并举例说明。
2. 3. 1 寻址方式
指令在执行过程中需要操作数 , 运算结果要送到存储单元中保持 , 寻找操作数及
数据存放单元的方法称为寻址方式。
寻址方式在指令中的指明方式有两种:一是利用操作码的某些位来指明; 二是在
地址码部分专门设置寻址方式位来指明 , 如在 PDP-11 计算机中 , 用 3 位表示 8 种寻
址方式 , 在 VAX-11 计算机中 , 用 4 位表示 16 种寻址方式。在汇编语言和计算机组
成原理课程中我们已经学习了寻址方式的基本原理 , 本课程主要从计算机体系结构

59
的角度介绍寻址方式的设计思想和设计方法。
寻址方式的多样性和灵活性可使指令系统对各种应用需要 ( 对各种数据结构的
处理)提供好的支持。那么如何根据寻址方式找到指令在执行过程中所需要的操作
数和存放运算结果呢 ? 计算机中的操作数可能存放的位置有主存储器、寄存器、堆栈
等 , 因此 , 计算机中的寻址方式就有面向主存储器寻址 (直接、间接、基址和变址) , 面
向寄存器寻址 , 面向堆栈寻址 , 下面介绍这几种寻址方式的设计思想和设计方法。
1 .立即寻址
操作数除了可存放在主存储器、堆栈和寄存器外 , 还有一种来源 , 就是直接在指
令中给出 , 这种寻址方式称为立即数寻址方式 , 通常仅仅用来指定一些精度要求不高
的整型常数。
立即寻址方式的优点是无须再去寻找操作数存储单元 , 指令执行速度快。但它
只能用于源操作数寻址 , 数据长度不能太长( 受指令字长度限制) , 大量使用会使程序
的通用性降低。
也可以把这种方式归为主存储器寻址方式。
2 .寄存器寻址
以寄存器寻址方式为主的计算机称为通用寄存器型计算机。
指令在执行过程中所需要的操作数来源于寄存器 , 运算结果写回到寄存器中 , 这
种寻址方式在所有的计算机中都普遍采用。这是因为目前的处理机 ( 特别是 RISC
系统计算机)中通常都有几十个、几百个甚至几千个寄存器。
当然 , 对于输入输出指令和一些特殊的处理机控制指令 , 指令中所给出的寄存器
可能是设备的控制寄存器、状态寄存器和处理机的程序计数器、堆栈指针、状态字寄
存器等。
(1 ) 寄存器寻址可分为两种:
① 直接寻址:指令在执行过程中所需要的操作数直接取自通用寄存器 , 运算结
果也保存在通用寄存器中 , 这样 , 运算型指令只要指定通用寄存器的编号 , 无须指定
主存储器的地址 , 这就是寄存器直接寻址方式。
② 间接寻址:即在通用寄存器中存放的是操作数在主存储器中的地址 , 或者是
操作数在主存储器中的地址的地址等(多重间址 ) , 这种寻址方式称为寄存器间接寻
址。它能解决操作数地址的修改问题 , 可以做到在程序设计过程中对操作数所存放
的主存地址进行修改 , 而不必去修改程序中的指令本身。
(2 ) 寄存器寻址方式的优点主要有:
① 指令字长短。由于通用寄存器的个数一般只有几十个 , 在指令中只需要很少
几位就能表示一个操作数的地址。例如 , 在 IBM370 系列计算机中 , 有 16 个通用寄
存器 , 只要用 4 个二进制位就能表示一个操作数的地址 , 即使是三地址指令 , 也只要

60
12 位地址码。
由于通用寄存器的字长可以比较长 , 如 32 位或 64 位 , 在采用寄存器间址方式
时 , 在通用寄存器中可以存放字长很长的主存地址 , 对于数据为 64 位的计算机系统 ,
在一个通用寄存器中不仅可以存放一个字长很长的主存地址 , 还可以同时存放地址
的偏移量及各种标志等其他许多信息。
② 指令执行速度快。由于寄存器的速度很快 , 访问寄存器的时间和访问主存的
时间相比几乎可以忽略不计 , 因此 , 大多数寄存器型指令都能在一个节拍内完成。对
于那些要连续使用的数据 , 把它们存放在通用寄存器中 , 能够大幅度提高程序的执行
速度。而且 , 对于普遍使用的二地址指令 , 必须要有通用寄存器的支持 , 否则执行速
度将明显下降。
③ 支持向量、矩阵运算。当通用寄存器的数量比较多时 , 比如在 CRAY-1 向量
计算机中 , 有 512 个寄存器 , 这样可以把一个向量或向量的一部分放在通用寄存器
内 , 从而提高运算速度。
(3 ) 寄存器寻址方式也有明显的缺点 , 主要是:
① 不利于编译程序的设计。通用寄存器的分配是否合理 , 直接影响到编译程序
的设计。这是因为通常要把那些连续使用或用得比较频繁的变量分配在通用寄存器
内 , 这就给编译程序在寄存器的优化使用方面带来很大的麻烦 , 这说明 , 面向寄存器
寻址方式为主的通用寄存器型计算机不适应高级语言的数据模型。
另外 , 通用寄存器使用中的一些特殊用法及某些限制也给优化编译造成很大的
困难。如在 IBM370 系列机中规定: R0 寄存器不能作变址寄存器和基址寄存器使
用 , 对于双字长指令只能用编号是偶数的通用寄存器等。
② 不利于中断和子程序的递归调用。在程序运行的过程中 , 当发生了中断或子
程序调用时 , 需要保护和恢复现场状态。这时要把有关通用寄存器中的内容都保存
到主存储器(简称“主存”) 中 , 在中断返回和子程序返回时 , 又要全部恢复这些寄存器
中的内容 , 寄存器的数目越大 , 保存和恢复所要的时间就越长。为了解决这个问题 ,
在 RISC 计算机中现在普遍使用了重叠寄存器窗口技术 , 这在下一节将具体讲述。
③ 增加了硬件复杂度。在处理机中设置大量的通用寄存器 , 一方面使硬件成本
增加 , 另一方面 , 由于这些寄存器在使用过程中的控制也相当复杂 , 这些都使硬件设
计复杂化。如在超标量超流水线处理机中 , 同时要从寄存器中取多个源操作数 , 还要
写回多个运算结果 , 可见其译码控制逻辑是相当复杂的。
3 .主存储器寻址
这是几乎所有计算机都有的一类寻址方式 , 也是最复杂的寻址方式。
指令中如果有存储器操作数 , 存储器操作数个数及寻址方式将直接影响到指令
系统的设计和计算机系统的性能。下面我们就来简要地介绍一下存储器操作数的各
种寻址方式及其优缺点。

61
主存储器寻址方式主要包括直接寻址、间接寻址和变址寻址三种类型。
(1 )直接寻址
在指令中直接给出操作数的有效地址。这种寻址方式在早期的计算机和目前一
些专用计算机中用得比较多 , 但随着主存容量的不断扩大及虚拟存储器的普及 , 这种
寻址方式逐渐暴露出它的弱点 , 主要为:
① 地址码字段比较长。特别是在二地址和三地址指令中 , 字长有限的指令是无
法容纳比较长的地址码的。
② 不支持程序的可再入性。如为了支持数组运算编制一段循环程序 , 那么在每
次执行循环体时数组元素的地址是必须修改的 , 而采用这种寻址方式 , 修改数据地址
就必须修改指令本身 , 采用这种方法编写的程序无法支持程序的再入性要求 , 这是现
代程序设计思想所不能接受的。
③ 不适用于多任务和多用户环境。在多任务及多用户操作系统下 , 要求程序能
够在主存中浮动 , 采用直接寻址方式编写的程序会给多任务多用户的操作系统作业
调试带来很大的麻烦 , 而现在的操作系统几乎都是多任务和多用户操作系统。
鉴于以上的缺点 , 必须要有其他寻址方式来支持。
(2 )间接寻址
和寄存器间接寻址的原理相同 , 只不过在采用主存储器间接寻址方式的指令中 ,
给出的地址是主存地址而不是寄存器的编号。
间接寻址也可进一步分为一次间接寻址和多重间接寻址方式。一次间接寻址 ,
在指令中给出的是操作数地址的地址 , 而在多重间接寻址方式中 , 指令中给出的是下
一级间接寻址的地址。通常第一级间址的标志由指令给出 , 以后各次的间址标志要
由紧接着访问主存储器所取出来的地址码给出 , 如果取出的地址码的间址标志位( 通
常是指定最高位)为“1”, 则要用除去标志位后的部分作为地址码继续访问主存储器 ,
直至取出来的地址码的间址标志位为“0”时为止 , 这时 , 除去间址标志位之后的地址
即为有效地址。
通常划出主存储器最低端的一小部分存放间接地址 , 因此 , 采用间接寻址方式
时 , 指令中需要表示的地址码的长度可以很短。
采用间接寻址方式 , 由于必须经过两次或两次以上的访问主存储器操作才能得
到操作数 , 所以采用这种方式的指令执行速度不高。
(3 )变址寻址
采用这种寻址方式时 , 需要设置一个或多个变址寄存器。变址寄存器的长度由
主存储器的寻址空间决定。也可以直接采用通用寄存器作为变址寄存器来使用。变
址寄存器的主要作用是用来存放数组的基地址。
指令中如采用这种寻址方式 , 只需要给出变址寄存器的编号和地址的偏移量 , 在
指令的执行过程中 , 用一个硬件加法器 , 把变址寄存器中给出的基地址与指令中给出
的偏移量做算术加法 , 相加的结果就是有效地址。如果变址寄存器只有一个 , 可以隐

62
含不表示出来。
另外 , 变址寻址还有两种特殊的形式。一种称为 PC 相对寻址方式 , 另一种称为
基址寻址方式。
① 相对寻址方式: 当变址寄存器就是程序计数器本身时称为 PC 相对寻址方式 ,
这种寻址方式主要在控制转移指令中用来指定代码位置。用这种寻址方式实现分支
转移或者无条件转移的优点很明显 , 这是因为目标通常都和当前的指令离得不远 , 而
且使用相对偏移地址可以减少指令的长度。使用 PC 相对寻址还可以使程序的运行
与加载的位置无关 , 可以减少程序在链接时的工作 , 对在执行时才链接的程序也有好
处。
② 基址寻址方式:这是为了支持程序的动态再定位而引入的一种寻址方式。实
际上 , 它也是一种变址寻址方式。在有些计算机系统中 , 既有变址寻址 , 又有基址寻
址 , 这时 , 在指令执行过程中 , 对于每一个操作数都要进行两次变址运算 , 即做两次加
法运算才能得到操作数的地址。
(4 )间接寻址与变址寻址
间接寻址与变址寻址的目标都是为了解决操作数地址的修改问题 , 它们都能做
到在程序设计过程中能够对操作数的地址进行修改 , 而不必去修改指令本身 , 既然它
们的作用和目标一样 , 那么 , 就会提出这样一个问题:在设计一台计算机系统时 , 间接
寻址与变址寻址方式是选择一种 , 还是二者兼用 ? 又如何选取间接寻址与变址寻址
方式呢 ?
对于这个问题 , 就需要对间接寻址和变址寻址方式作一个比较 , 比较结果如表
2 .6 所示。
表 2 .6
间接寻址与变址寻址的主要差别

对数组运算的支持较好 , 因基 地址加偏移
量能够很有效地表示向量、矩阵等运算
在变址寻址方式中 , 偏移量是带有符号的 , 通常用补码表示 , 这样 , 不仅可以向前

63
转移 , 也可向后转移。偏移量的长度一般短于基地址的长度 , 在做加法时要进行符号
扩展。
如果在一台计算机中同时设置了间址和变址这两种寻址方式 , 先做变址运算还
是先做间址运算也需要事先定义。在指令中如给出一个变址寄存器 X 和一个相对
地址 A , 有效地址 EA 的计算方法有如下两种:
第一种:前变址寻址方式。EA = ( ( X) + A)
第二种:后变址寻址方式。EA = (X) + ( A)
另外 , 无论采用间接寻址 , 还是变址寻址方式编写程序 , 对于数组运算 , 都必须有
对地址进行增量的指令 , 为省去这些对地址进行增量的指令 , 在许多计算机中对于这
两种寻址方式都增加了自动变址的功能。地址增量的先后关系是必须清楚的 , 一般
有三种方式:
第一种:先用后增与先减后用方式 , 即(X) + , - (X)。这种方式多用于有后进先
出堆栈 , 且堆栈指针指向栈顶元素的计算机中。第二种: 先增后用与先用后减方式 ,
即 + (X) , (X) - 。这种方式多用于有后进先出堆栈 , 而且堆栈指针指向栈顶第一个
空元素的计算机中。第三种:先增后用与先减后用方式 , 即 + (X) , - (X) 。这种方式
多用于没有后进先出堆栈的计算机中。
4 .堆栈寻址
操作数放在堆栈中的寻址方式称为堆栈寻址 , 这种方式只能对栈顶元素进行操
作。
从 20 世纪 60 年代开始 , 出现了一批以堆栈寻址方式为主的堆栈计算机。这类
计算机系统与以寄存器寻址方式和主存寻址方式为主的计算机系统相比 , 具有如下
特点:
① 程序所占的主存空间最小。由于堆栈指令不需要地址码 , 指令的长度很短 ,
与以寄存器和以主存寻址方式为主的计算机系统相比 , 程序的总存储量要缩短很多。
② 有力支持程序的嵌套和递归调用 , 支持中断处理。在程序的嵌套和递归调用
过程中 , 要保存返回地址 , 保存处理机状态 , 保存程序现场 , 并向子程序传送参数 , 在
堆栈型计算机中 , 可以把这些信息都压入堆栈 , 而不必为它们赋予地址。当从子程序
返回时 , 可以直接从堆栈中弹出所需要的信息 , 这些都使辅助操作减少 , 加快运算速
度。中断的处理过程与程序调用很相似 , 使用堆栈能加快中断的处理过程 , 简化中断
程序的设计。
③ 有力地支持高级语言程序的编译。因为一般的算术表达式可以很容易地转
化成逆波兰表达式 , 而逆波兰表达式能够直接形成由堆栈指令组成的程序 , 这样就缩
小了高级语言和机器语言之间的差距 , 简化了编译程序的设计。而在以主存寻址为
主的计算机中 , 在编译一个算术表达式时 , 要为每一个变量分配主存单元 , 如何合理
为变量分配存储单元 , 减少中间变量的个数 , 是编译器的一项相当困难的工作。对于

64
以寄存器寻址方式为主的计算机系统 , 编译器必须优化寄存器的使用 , 减少访问主存
的次数 , 同样 , 也存在如何减少中间变量、节省存储空间的问题。
堆栈型计算机的主要缺点是运算速度比较低 , 这是由于堆栈与处理机之间的信
息传送量很大造成的。另外 , 也不能随机访问堆栈 , 从而很难生成有效代码 , 堆栈是
整个系统的瓶颈 , 所以很难被高效地实现。
以上比较了面向寄存器、面向主存储器和面向堆栈这三种主要的寻址方式 , 这三
种寻址方式各有优缺点 , 很难笼统地说哪一种寻址方式最好 , 对不同的用户程序和不
同的工作阶段会得到不同的效果。而且由于用户程序的多样性及高级语言源程序从
编译到运行的阶段不同反映出的工作特点也不同 , 所以这三种寻址方式不应相互排
斥。在同一系统中 , 这三类面向的寻址方式都应采用 , 只是根据应用的特点 , 选择某
一种面向的寻址方式为主 , 其他面向的寻址方式为辅 , 以相互取长补短。例如 , 在通
用寄存器型机器系统结构中可增加堆栈及堆栈寻址方式 , 以支持高级语言程序中表
达式的编译和子程序的调用。在堆栈型计算机中 , 可以增加面向通用寄存器的寻址
方式以及除可以直接访问栈顶外 , 也能实现直接访问栈内任意单元的能力。为提高
堆栈的运算速度 , 可以设置硬堆栈或者增设栈顶寄存器组。
2. 3. 2 程序定位技术
上面所讲的各种操作数的寻址方式 , 都是按地址访问的方式。如果按地址访问 ,
必须对这些可访问的存放操作数的部件进行编址 , 地址的编址 , 通常有三种方式: 第
一种 , 按各种部件分类编址。各类部件分别从“0”开始单独编址 , 形成多个一维的线
性地址空间。第二种 , 隐式编址 , 如堆栈和某些专用寄存器 , 多数采用事先约定好的
编址方式隐式寻址 , 以加快对这些部件的访问。第三种 , 统一编址 , 即把各部件编址
成一个从“0”开始的一维线性地址空间 , 对不同部件的访问反映在对这个空间中不同
地址的访问上。但无论是哪种编址方式 , 在计算机中有两个地址概念应该加以区别 ,
一个是逻辑地址 , 另一个是物理地址。
逻辑地址指的是程序员在编制程序时所使用的地址 , 包括高级语言的符号名称
地址和通过编译生成的逻辑地址 , 它所对应的空间称为逻辑地址空间。前面所讨论
的寻址方式 , 主要是指逻辑地址的寻址方式。一般各个程序的逻辑地址空间是独立
的 , 都是从“0”开始的一维线性地址空间 , 它们独立于实际存储空间。在冯·诺依曼
计算机中主存是由一个从“0”开始编址的一维线性地址来访问的 , 这一地址称为实际
的主存物理地址 , 对应的空间称为主存物理地址空间。
为了把一个程序交给处理机运行 , 必须先把这个程序的指令和数据装入到主存
储器的一个或几个区域中 , 一般情况下 , 程序所分配到的主存物理空间与程序本身的
逻辑地址空间是不相同的 , 因此 , 当程序装入主存时需要进行逻辑地址空间到物理地
址空间的变换 , 即进行程序的定位。定位技术就是主要研究程序中的指令和数据的
主存物理地址在什么时间确定 ? 采用什么方式来实现 ?

65
根据程序中指令和数据的主存物理地址的确定时间 , 定位方式可分为直接定位、
静态再定位和动态再定位三种。
1 .直接定位方式
一般适用于单任务工作方式。
程序装入主存之前 , 程序中的指令和数据的主存物理地址就已经确定了的方式
称为直接定位方式。
在早期的计算机系统、目前的某些小型微型计算机和一些专用计算机中 , 在编译
程序时 , 就已经可以确定程序在主存储器中将要存放的实际位置 , 因此 , 能够把指令
和数据的地址直接编译成主存储器的物理地址。在这种情况下 , 逻辑地址空间和主
存物理地址空间是一致的。可以采用这种方式。但目前在多道程序、多用户等系统
中 , 它们是不同的 , 在装入程序时就必须使用其他定位方式。
2 .静态再定位方式
采用这种方式的程序必须是可重定位的 , 即要修改地址的指令和数据需具有某
种标识。静态定位要求程序在运行之前 , 由专门设计的定位装入程序集中一次完成
逻辑地址到物理地址的变换 , 程序一旦进入主存储器之后 , 地址就不能再修改。如早
先在 DOS 操作系统中的 LINK 过程 , 在某些单片机、专用机中采用这种定位方式。
静态定位技术是由专门设计的静态定位装入软件来完成地址变换的 , 不需要增
加任何硬件设备 , 而且可对多个程序段组成的程序进行静态链接 , 但是在执行期间 ,
程序的地址是不能修改的 , 这对提高主存的利用率不利。倘若程序所需空间超过了
分配给它的主存物理空间 , 还必须采用覆盖技术 , 而且 , 多个用户也不能共享放在主
存储器中的同一个程序 , 如果几个用户要使用同一个程序 , 则在每个用户程序中都必
须包含这个程序的副本。采用动态定位技术可以解决这些问题。
3 .动态再定位方式
对于采用这种方式定位的程序 , 在装入主存储器时 , 指令和数据地址不做任何修
改 , 只把此程序在主存中的起始地址存入与之对应的基址寄存器中。在程序执行过
程中 , 再用地址加法器将指令中的逻辑地址和基址寄存器中的程序起始地址相加 , 就
形成实际的主存物理地址。
采用基址寻址实质上是把原来由装入程序完成的功能 , 改用地址加法器和基址
寄存器完成 , 使地址变换的速度加快了。动态再定位和静态再定位相比 , 具有如下优
点:
① 提高了主存的利用率。由于地址变换是在程序执行的过程中完成的 , 程序运
行之前也不必全部装入主存 , 这样一个程序可分配在多个不连续的主存空间内 , 只要
为每个连续空间设定一对上、下界寄存器即可 , 而且这种界限寄存器的设置 , 还有利

66
于实现主存信息的保护。
② 主存中的同一个程序段可为多个程序所共享。
③ 支持虚拟存储器。在虚拟存储器中 , 进一步发展和改进了动态定位技术 , 地
址的转换和程序的调度完全由系统管理程序来完成 , 这在第四章中会进一步讲述。
但是为实现动态再定位 , 需要有相应的硬件支持 , 而且在虚拟存储器中 , 实现存
储管理的软件算法也比较复杂。
2. 3. 3 指令格式的优化与设计
在“计算机组成原理”课中已学过 , 指令由操作码和操作数寻址信息两部分组成。
操作码指明操作种类和所用操作数的数据类型 , 地址码包括操作数的地址、地址的附
加信息、寻址方式等。如何用较少的位数来表示指令的操作信息和地址信息 , 将影响
到编程后的目标程序长短及执行速度 , 所以指令格式的优化设计是指令系统设计的
一个重要问题。指令格式优化设计的主要目标有两个 , 一是节省程序的存储空间 , 二
是指令格式要尽量规整 , 以减少硬件译码的复杂程序。下面 , 分别介绍指令中操作码
和地址码的设计方法 , 再以 IBM370 指令格式为例说明整个指令格式的优化设计方
法。
1 .操作码优化设计
操作码优化设计的目的主要是为了缩短指令字的长度 , 增加指令字所能表示的
操作信息和地址信息。要对操作码进行优化设计 , 就需知道每种操作指令在程序中
出现的概率或使用频度(这一般可通过对大量已有的典型程序进行统计求得) 。按信
息论的观点 , 当各种指令的出现是相互独立的时候 , 操作码的信息源熵 (信息源所包
含的平均信息量) H 为(以二进制位数表示) :
H = - ∑
n
i = 1 pilog2 pi
其中 , Pi 表示第 i 类指令的使用频度 , 共有 n 类指令。这里的 H 即为操作码可以达
到的最短平均码长。
而实际编码的操作码平均码长为: l = ∑
n
i = 1 li p i
式中 , li 为第 i 类指令的编码长度 , pi 为第 i 类指令的使用频度。这种编码的信息冗
余量为:
R = 1 - H
l
操作码的优化表示就是要使信息冗余量 R 最小。
操作码的表示方法通常有三种 , 等长编码、H uffman 编码法和扩展编码 , 下面分
别加以介绍。
1 .等长编码

67
在系统中所有指令的操作码长度都是相同的 , 即所占用的二进制位数相同。
一般处理机的指令条数通常为几十条到几百条之间 , 用一个字节 ( 8 位 ) 表示 , 指
令规整 , 硬件译码简单 , 但操作码的长度增加了 , 信息冗余现象严重。
现设一台模型机 , 共有 7 条不同的指令 , 使用频度如表 2 .7 所示。其最短二进制
平均码长为:
H = - ∑ pilog2 pi = 0 .40× 1 .32 + 0 .26× 1 .94 + 0 .15 ×2 .74 + 0 .06 ×4 .06
+ 0 .05 × 4 .32 + 2 × 0 .04 × 4 .64 = 2 .27
即要表示这 7 条指令 , 只需 2 .27 位就够了。
若用等长操作码编码方法 , 则至少需要 3 位二进制数来表示( log2 7
= 3 ) , 平均
码长 l = 3, 信息冗余量为:
R = 1 - 2 .27/ 3 = 0 .24 , 即 24% 。
表 2 .7
模型机的操作码的使用频度和三种不同编码方法

2 .H uffman 编码法
利用哈夫曼压缩概念的思想 , 根据每类指令的使用频度 , 使使用频度高的指令的
操作码用较短的二进制位来表示 , 频度较低的指令的操作码用较长的二进制位表示 ,
使得平均二进制位数变短(与等长编码相比) 。哈夫曼编码的优点是实际平均码长最
短;但各类码长种类太多 , 实际不能采用。
求哈夫曼编码的方法如下:
① 构造哈夫曼树。将所有的使用频度值作为树的叶节点 , 找出两个权值最小的
相加 , 相加后的值作为新节点的权值 , 放入其中再作比较 , 继续用两个权值最小的节
点相加 , 形成一个新节点 , 重复以上过程 , 直至根节点 , 根节点的权值必定为 1 .00。
② 编码。按照二叉树左“1”右“0”或者是左“0”右“1”的原则 , 在树上标出 , 遍历
所有的叶节点。然后 , 在根节点至叶子节点的路径上的二进制符号 , 即为叶子节点对
应的该类指令操作码的哈夫曼编码。

68
如上面所讲的模型机 , 哈夫曼树及编码如图 2 .13 所示。由图 2 .13 可得出哈夫
曼编码的平均码长为:
l= 0 .40×1 + 0 .26×2 + 0 .15×3 + 0 .06×5 + 0 .05×5 + 0 .04×5 + 0 .04×5 = 2 .
32
图 2 .13 利用 Huffman 树进行操作码编码
信息冗余量为: R = 1 - 2 .27/ 2 .32 = 0 .02(即 2 % )。
从表 2 .7 中可看出 , 哈夫曼编码的平均码长最短 , 只比最优编码多 0 .05 位。
实际上 , 操作码不可能达到最优哈夫曼编码法的最短平均长度 , 这是因为操作码
的位数必须是正整数 , 然而 , 可以利用哈夫曼思想 , 通过构造哈夫曼树对操作码进行
编码 , 达到实际平均码长最短的哈夫曼编码 , 但这种编码方法不是惟一的 , 只要将任
意一个二叉节点上的“0”和“1”交换 , 就可以得到一组新的操作码编码 , 无论怎样交
换 , 操作码的平均长度是惟一的。
3 .扩展编码法
采用哈夫曼编码能够使操作码的平均长度最短 , 信息的冗余量最小 , 但这种方法
形成的操作码很不规整 , 即全哈夫曼码是完全不等长码 , 如表 2 .7 中所示 , 7 条指令
就有 4 种不同的码长 , 这样 , 既不利于硬件的译码 , 也不利于软件编译 , 还很难与地址
码配合 , 形成有规则的指令字长。
鉴于以上两种编码方法各自的特点 , 在许多处理机中 , 采用了一种新的折中的编
码方法 , 即哈夫曼扩展编码法 , 简称扩展编码。这种方法是由等长操作码与哈夫曼操
作码编码方法相结合形成的。

69
扩展编码法的基本思想就是对哈夫曼编码 , 根据使用频度宏观分布 , 将编码长度
扩展成几种长度的编码。使这种编码的平均码长接近全哈夫曼码的码长 , 但又保持
了定长码指令的规整性。
常用的扩展方法有等长扩展和不等长扩展两种。扩展编码中选择某些特征位用
于扩展。但无论采用哪一种方法 , 衡量的标准是操作码平均码长是否最短 , 即信息冗
余量是否最小。
如对模型机的 7 条指令采用 2-4 等长扩展编码 , 使码长由全哈夫曼编的 4 种减
为 2 种 , 最高两位二进制“11”作为扩展标志 , 区分 2 位码长和 4 位码长。
为了便于实现分级译码 , 一般采用等长扩展法。例如 , 操作码按 4-8-12 位进行
扩展 , 当然要根据实际情况 , 也可以采用每次扩展的位数不等的不等长扩展。如美国
的 Burroughs 公司生产的 B-1700 计算机中就采用 4-6-10 扩展操作码。
对于等长和不等长扩展法 , 根据采用不同的扩展标志还可以有多种不同的扩展
方法。如对于等长扩展 4-8-12 扩展法 , 有采用保留一个码点标志的 15/ 15/ 15 扩展
法 , 采用每次保留一个标志位的 8/ 64/ 512 扩展法等。对于不等长扩展 4-6-10, 可以
有 15/ 3/ 16, 8/ 31/ 16, 4/ 32/ 256 等多种编码方法。但具体采用哪种扩展 , 还要根据所
设计系统中各种指令出现的概率分布情况决定。
例如 , 假设指令系统共有 42 种指令 , 前 15 种使用频度平均为 0 .05, 中间 13 种
使用频度平均为 0 .015, 最后 14 种使用频度平均为 0 .004。如何编码 ?
因 42 种指令的频度分布有三种 , 故码长可有三种;又因每段指令数基本相同 , 故
可采用等长扩展(4-8-12 位) , 结果如图 2 .14 所示。
从图 2 .14 中可以看出 , 采用的是 15-15-15 扩展方法 , 最后一种编码用于扩展 ,
每段 0000-1110 用于编码 , 1111 用于扩展。

图 2 .14 一种 15-15-15 的扩展编码方式

70
2. 地址码的优化表示
有了操作码的优化设计 , 如果没有在地址码表示和寻址方式上采取相应的措施 ,
程序所需总位数还是难以减少的 , 操作码的优化将没有任何意义。这是因为 , 现在通
用的主存结构一般为定长字 , 且绝大多数计算机的最小可寻址单位是字节地址 , 计算
机可定位的地址很少是二进制位。那么 , 为了保证只需一次访存便可取出一条指令 ,
要求指令字遵从整数边界存储原则 , 实际上 , 为了保证所需的各种信息都只用一个存
储周期访问到 , 信息在主存中的存放都要遵守这个原则 , 这就要求信息在主存中存放
的地址必须是该信息宽度(字节数) 的整数倍 , 否则可能发生信息跨主存边界存放 , 影
响速度。即:
字节信息地址为:X⋯XXXX
半字信息地址为:X⋯XXX0
单字信息地址为:X⋯XX00
双字信息地址为:X⋯X000
这就是信息在存储器中按整数边界存储的概念。像 CDC STAR-100 那样的计算机
是按位编址的 , 信息在存储器中的存放是用该信息的首位地址表示的 , 为保持信息按
整数边界存储 , 就要求存储在主存中的各种信息的地址必须是其信息位数的整数倍。
指令字的存放也需遵守这个存储规则 , 在此前提下 , 如何使操作码优化后的表示
能够发挥其优点呢 ? 这与指令字是定长或变长有关。若指令字为定长 , 则在操作码
优化表示后 , 将使指令字有效部分变长 , 操作码部分必须取操作码优化后的长度中最
长者作为操作码部分标准。因此若地址码部分不随之作相应的长度变化 , 则操作码
优化的效果就显示不出来。所以地址码必须与操作码相配合 , 完成整个指令格式字
的优化设计 , 一般采取的办法有以下几种:
① 采用多种地址码长:长操作码与短地址码相结合, 短操作码与长地址码相结合。
实际上 , 由于寻址方式的种类很多 , 每种寻址方式所占用的操作数地址码位数变
化很大 , 如寄存器寻址和主存直接寻址 , 所占位数相差很大。这说明地址码长度可在
很宽的范围内变化 , 只要恰当安排 , 就可与变长的操作码相配合构成定长指令字。
② 可以采用多种地址制 , 使多种地址制都可以在指令中使用 , 同一种地址制还
可以采用多种地址形式和长度 , 如果操作码和地址码之外还有空余的码位 , 则设法用
来存放立即操作数或常数。
如果让最常用的操作码最短 , 其地址码字段个数越多 , 采用二地址、三地址甚至
多地址制 , 就越能使指令的功能增强 , 越可以从宏观上减少所需的指令条数 , 进一步
缩短程序占用的空间 , 也会因减少访存次数而加快程序的执行速度。而对操作码长
的指令 , 可以采用单地址或零地址制等。
③ 进一步 , 还可以考虑采用多指令字长度的指令 , 这比只有一种长度的定长指
令字方式更能减少信息的冗余量 , 缩短程序的长度。

71
在 PDP-11 和 VAX-11 系列机中 , 都采用扩展操作码方式。在单字长及双字长
的指令格式中 , 操作码的长度有 4, 7, 8, 10, 12 位和 13 位 6 种 , 对于不同长度的操作
码 , 配以不同的操作码地址个数 , 就能充分利用非操作码部分的空间。而且 , 在当今
的 RISC 机的指令系统中 , 都是定字长指令格式 , 为了充分利用指令字空间 , 通常采
用扩展码形式 , 实际上这也是一种变相的可变操作码长度格式。
最后 , 以 IBM370 为例 , 介绍指令格式的设计。
IBM 370 系列计算机的指令长度有 16 位、32 位和 48 位 3 种 , 所有指令的操作
码都是 8 位固定长度 , 操作码的最高两位用来指明指令的长度和格式。具体如下:
00 为 RR 格式 , 指令字长 16 位
01 为 RX 格式 , 指令字长 32 位
10 为 RS 或 SI 格式 , 指令字长 32 位
11 为 SS 格式 , 指令字长 48 位
这里 R 代表寄存器 , S 代表存储器 , X 代表变址 , I 代表立即操作数。操作码的
其余 6 位用来区分每种格式下的各种指令 , 因此每种格式最多可表示 64 种指令。这
5 种主要指令的格式如图 2 .15 所示
。
图 2 .15 IBM 370 指令的主要格式

72
在 IBM370 中有 16 个通用寄存器 , 可兼做变址寄存器和基址寄存器使用。5 种
指令格式都采用两地址制 , 其中 , RR 型指令字长只需要 16 位 , 两个参加运算的操作
数都在通用寄存器中 , 运算结果也放在通用寄存器中 , 一个存储字可以放两条指令。
RX 型指令参加运算的操作数一个来自主存储器 , 并采用变址寻址方式 , 一个来自通
用寄存器 , 运算结果也放在通用寄存器中 , 指令字长 32 位 , 正好一个存储字。 RS 型
指令字长也是 32 位 , 它用来在通用寄存器与主存储器之间一次传送多个数据 , R1 为
起始通用寄存器编号 , R3 为结束通用寄存器编号 , 只要用一条指令就能把这连续编
号的通用寄存器中的所有数据存入相邻的主存单元。同样 , 也可以从主存储器的相
邻单元读出多个数据到通用寄存器中。这种指令在程序调用和中断处理时 , 可以加
快现场的保护和恢复。SI 型指令同样也是 32 位长的指令字 , 它的一个操作数来自
主存储器 , 一个为立即数 , 立即数的长度为 8 位 , 而 SS 型指令的两个操作数都在主存
储器中 , 并且支持“串”操作 , 如字符串运算 , 十进制运算等 , 可支持用来把长度 L≤
256 个字节的数据块从主存储器中的一个区域传送到另一个区域中去。
2 .4 指令系统设计的两种风格
指令系统是指计算机所具有的全部指令的集合 , 它反映了计算机所拥有的基本
功能 , 是机器语言程序员所看到的计算机的主要属性之一。指令系统的设计主要是
功能设计和指令格式的设计 , 上节已经详细介绍了指令格式的优化设计方法 , 本节主
要介绍两种不同风格的指令系统: CISC 和 RISC 各自的特点、实现的关键技术等。
2. 4. 1 指令系统的功能设计
指令系统是机器软硬件的主要交界面 , 对软件和硬件设计的影响都非常大 , 那
么 , 一种指令集结构中的指令到底要支持哪些类型的操作呢 ? 这就是指令集功能设
计问题 , 下面就从不同的方面来简要介绍指令的功能设计。
1. 指令系统的组成
各种类型的计算机由于结构不同、具体硬件构成不同、对软件的支持要求不同 ,
所以对应的指令系统也不同。除了系列机以外 , 各种计算机的指令系统是不兼容的。
但一般指令系统应包括下面的一些基本功能指令:
① 算术和逻辑运算类指令。计算机现在在许多应用领域的主要任务仍然是做
运算 , 因此 , 运算型指令在指令集中应该占有比较大的比重 , 否则影响系统的性能。
② 数据传送类指令。主要是在相同或不相同的数据存储设备之间传送数据。
如在 CPU 和寄存器、存储器之间的数据传送。
③ 程序控制指令。包括各种类型的转移指令、程序调用和返回、循环控制指令
等。

73
④ 输入输出指令。这种指令在多用户或多任务环境下属于特权指令。当程序
需要进行输入输出操作时 , 用系统调用进入 OS, 由 OS 对设备统一进行管理。
⑤ 处理机控制和调试指令。处理机控制指令主要是对系统状态进行切换 , 系统
资源进行分配和管理等。调试指令主要用于硬件和软件的调试。硬件调试指令主要
有:钥匙位置的读取、开关状态的读取、内部主要寄存器和主存单元的显示等。软件
调试指令主要有断点的跟踪和自陷指令等。一般处理机都设置有调试指令 , 但这些
指令对一般用户是不公开的。
以上这 5 类指令 , 每一个计算机系统基本上都有 , 且一般是必须具备的。
2. 指令系统的扩展
各种计算机除以上基本指令外 , 还有扩展的指令部分 , 这部分扩展功能指令主要
是提供一些对高级语言和操作系统的支持 , 如访管和访问监督指令; 存储管理和保护
指令(实际上也是 OS 功能 ) ; 控制系统状态指令; 诊断指令 ( 计算机里 , 如军用计算
机 , 还提供对系统的诊断 , 可用软件实现 , 但硬件实现更容易 , 性能更好) ; 高级运算指
令等。详细扩展方向在 CISC 和 RISC 中再介绍。
3. 指令保护问题
为了防止用户程序破坏系统软件 , 在指令系统中 , 把指令分成特权指令和非特权
指令。用户只能使用非特权指令。特权指令只能在操作系统的管态下运行 , 即只有
系统管理程序可以使用 , 主要包括处理机状态的设置和管理、系统硬件和软件资源的
管理、进程的管理等。所以只有在管态下才能够使用机器所提供的全部指令 , 包括特
权指令。在用户态下 , 只能使用一般指令 , 不能使用特权指令。
4. 指令功能设计
指令功能设计的基本思想是:计算机系统中的一些基本操作应由硬件实现还是
由软件实现;某些复杂操作是由一条专用的指令实现 , 还是由一串基本指令实现。希
望能在充分发挥硬件功能的条件下 , 尽可能多地对高级语言和操作系统提供支持。
从性能价格比来讲 , 如何达到最优呢 ?
从目前操作系统和高级语言来说 , 对一种计算机 , 指令系统的功能设计总体上要
求具有完整性、规整性和可扩充性。
① 完整性(Completeness) :要包括各种基本指令类型 , 能处理机器所具有的各
种数据表示。
② 规整性(Consistency) :各寄存器和内存单元在指令系统中处于对等地位 , 这
对将来译码、执行比较有利 , 主要表现在“对称性”和“均匀性”两个方面。
对称性指各种与指令系统有关的数据存储设备的使用、操作码的设置等都要对
称。如所有寄存器要同等对待。这一点在目前的许多计算机系统中都没有做到 , 往

74
往隐含规定某一个或某几个通用寄存器有特殊用途。
如有: ( R1) op(R2 )→R1
或
( R2 ) op (R1)→ R1
也应有: ( R2) op(R1 )→R2
( R1 ) op (R2)→ R2
均匀性是指对于各种不同的数据类型、字长、数据存储设备、操作种类等 , 指令的
设置要同等对待。如某计算机有 5 种数据表示、4 种字长、8 种数据存储的有效排列 ,
则设计加法指令时 , 指令种类应该有 5×4×8 = 160 种两地址加法指令 , 如果再考虑
对称性的要求和不同的寻址方式等 , 指令种类还要增加很多倍 , 这实际上很难做到 ,
也是不现实的。因此 , 在设计指令功能时 , 对于规整性的要求必须有所选择 , 在 RISC
体系结构中 , 规定运算型指令都在通用寄存器内进行操作 , 即使在 CISC 中 , 如果采
用二地址通用寄存器结构 , 通常也规定 , 两个地址中必须有一个是通用寄存器。对于
逻辑数、十进制数、字符串数据表示、双字长、半字长和字节等数据长度 , 可以适当减
少指令种类。这样 , 可以把加法指令的种类压缩在 10 种之内。另外 , 如果采用自定
义数据表示方式 , 每个数据只要带有几个标志位 , 规整性问题就不难解决了。
③ 可扩充性( Extendibility ) : 要保留一定余量的操作码空间 , 为以后的扩展所
用。这一点主要是考虑兼容性的要求。没有兼容性 , 大量的系统软件和更多的各种
应用软件将无法使用 , 计算机也就没有了市场 , 所以兼容性是必须考虑的。一般来
讲 , 后生产的机器 , 总要对原有指令进行扩充 , 以提高计算机的性能。
为了使指令系统对软件层次有较好的支持 , 指令集在其基本功能之上都要进行
扩展和改进。当前在指令功能的设计、发展和改进上有两种截然不同的方向 , 一种是
强化指令功能的复杂指令系统计算机 CISC; 另一种是降低指令集结构的复杂性 , 以
达到简化实现 , 提高性能目的的精简指令系统计算机 RISC。下面将分别从这两个方
向讨论指令系统功能设计的一些问题。
2. 4. 2 复杂指令系统计算机(CISC)设计风格
CISC(Complex Instruction Set Computer) : 它的改进方向是怎样进一步增强原
有指令的功能 , 设置复杂的功能更强的新指令代替原先由软件子程序实现的功能 , 进
行软件功能的硬化。按照这种方向来发展 , 必将使指令系统越来越庞大和复杂 , 因
此 , 具有这样指令集结构的计算机被称为 CISC。
早期计算机的指令系统还是比较简单的 , 当时受制于计算机中的硬件比较昂贵
和可靠性较低的约束。随着器件技术和微组装技术的不断发展 , 这些不再是计算机
性能不高的主要问题; 另一方面 , 大量的系统软件和应用软件对计算机兼容性的要
求 , 都促使计算机科学家为提高计算机的性能 , 满足软件发展的需要 , 不断增强原有
指令的功能和引入一些复杂的、功能更强的指令 , 这就开始出现了 CISC。可以说 , 大
约从 1964 年的 IBM360 系列机开始 , 逐步确立这一设计风格 , 后来又有 DEC 公司推
出的多功能小型机 PDP-11 系列、20 世纪 70 年代末期的 VAX-11 系列 , 以及 70 年代
后出现的各种微机 , 如 Intel 80X86 系列、Motorola 68020 等 , 基本上都是遵循这种风

75
格的。通过对这些计算机进行分析研究 , 可以看到它们增强计算机指令功能的主要
改进方向为:支持目标程序的优化实现、高级语言的优化实现及操作系统的优化实
现 , 下面就从这三个方面介绍 CISC 的设计风格。
1 .面向目标程序的指令功能的优化与改进
目标程序是由处理机直接执行的机器代码 , 面向目标程序来改进的目标主要是
缩短程序的长度 , 减少程序执行过程中处理机和主存之间信息交换的次数 , 减少指令
的执行时间。改进的方法是通过对目标程序中指令的静态使用频度和动态使用频度
的统计分析 , 确定改进措施。
静态使用频度指的是对程序中出现的各种指令或指令串进行统计得出的百分
比。动态使用频度指的是在目标程序的执行过程中对出现的各种指令和指令串进行
统计得出的百分比。按静态使用频度来改进指令系统是着眼于减少目标程序所占用
的存储空间 , 按动态使用频度来改进指令系统是着眼于减少目标程序的执行时间。
按这两种频度来改进都可以减少处理机和主存之间信息的交换量。改进的具体思路
就是对于那些使用频度高的指令 , 可以增强其功能 , 加快其执行速度 , 缩短其指令字
长;对频度高的常用指令串可以增设新指令来代替 , 这样 , 不但减少了目标程序所占
用的空间 , 而且能减少目标程序访存取指令的次数 , 加快目标程序的执行。
IBM 公司曾对 IBM360 上运行的 19 个典型程序统计出几种常用指令的使用频
度 , 如表 2 .8 所示。从这个表可以看出 , 大部分常用指令的静态使用频度和动态使用
频度非常接近 , 这说明可只对其中一种频度进行统计分析 , 根据这种频度进行改进 ,
同样可以实现对目标程序的优化与改进。根据表 2 .8 的统计 , 最常用的指令其实有
三种:第一种是数据传送指令 , 如取指令的静态使用频度是 28 .6% , 动态使用频度是
27 .3 % ;存指令的静态使用频度是 15 .0% , 动态使用频度是 9 .8 % 。第二种是程序控
制类指令 , 如条件转移指令 , 静态使用频度为 10 .0% , 动态使用频度是 13 .7 % 。第三
种是算术和逻辑运算类指令 , 如表中的加减指令 , 比较与逻辑左移指令的使用频度也
很高 , 因此 , 优化目标程序的主要途径就有以下几个方面:
表 2 .8
IBM360 指令的动、静态使用频度

(1 )增强数据传送指令的功能
由于这类指令在整个指令系统中占有非常重要的地位 , 设计好这类指令对提高
计算机系统的性能至关重要。现在在一些数据处理和通用计算机中 , 为方便主存储
器和通用寄存器组之间、通用寄存器和通用寄存器之间、主存储器和主存储器之间的
信息块的传送 , 一般都设置了成组传送指令。
在 IBM370 机上增设了用单条指令完成多个数据传送的功能。如“成组取”和
“成组存”指令 , 属于 RS 型指令格式:
成组取或成组存
R1
R3
B2
D2
8 位
4 位
4 位
4 位
12 位
“成组取”指令完成从(B2) + D2 地址指明的主存地址起始的一个字向量 ( 32 位 )读到
号为 R1 到 R3 的一组顺序的通用寄存器中 , 而“成组存”指令刚好相反 , 它把通用寄
存器组中的一组数据传送到指定的主存储器中。另外 , 为完成主存储器中不同区域
之间的信息传送 , IBM370 还增设了一条“成组传送”指令 , 属于 SS 型格式:
成组传送
L
B1
D1
B2
D2
8 位
8 位
4 位
12 位
4 位
12 位
它将从(B2) + D2 指明的主存起始地址、长度为 L 的字符行或字节向量传送到从
(B1) + D1 指明的主存起始地址开始的顺序单元中。这些支持向量传送和字符行传
送的指令有利于缩短目标程序的长度 , 也便于进行汇编语言程序的设计。
由于对向量、数组等处理的需要 , 也要在寄存器之间或寄存器与处理部件之间设
置一些一次就能传送多个数据的指令 , 如向量计算机中的向量传送指令等。这在向
量处理机中将会详细讲述。
(2 )增强程序控制指令的功能
控制类指令主要包括条件分支、无条件跳转、过程调用和过程返回。这类指令的
使用频度也是比较大的。如使用基准测试程序 SPECint92 在一台 loda/ store 型指令
集结构的机器上运行 , 对指令的使用频度进行分析 , 得出表 2 .9 的统计结果。
表 2 .9 中的数据是 SPECint92 的 5 个程序 compress, espresso, eqntott , gcc, li 运
行结果的平均值。从表 2 .9 中可看到 , 常用的指令仍然是前面所述的三种 , 控制流指

77
令中的条件分支指令的使用频度高达 20% , 而其他三类 , 即调用和返回、无条件跳转
相对低一些。同样 , 在一台 Load/ store 型指令集结构的机器上运行 SPECint92 和
SPECfp92 基准程序 , 测试控制类指令出现的相对频度如表 2 .10 所示。
根据表 2 .10 中的统计结果 , 控制类指令中使用最多的是条件分支指令 , 因此在
进行条件分支指令设计时 , 确定如何表示分支条件就非常重要。现在常用的比较条
件分支的技术有三种:第一种是条件码 (Condition Code , CC) , 由 ALU 操作设定的某
些特定位 , 在程序的控制下 , 从一条指令将分支条件信息传送到分支指令 , CC 是额
外状态 , 它限制了指令顺序 , 但可以自由设置分支条件。第二种是条件寄存器 , 根据
比较结果测试条件寄存器 , 这种方式简单 , 但占用一个寄存器。第三种是比较且分
支 , 即把比较和分支两条指令功能合在一条指令中完成 , 使分支指令的操作增多 , 这
种测试条件分支的方法通常受一定的限制 , 比较只限于子集内部。如在 80×86 中就
有一个专用的标志寄存器 , 标志寄存器中就有条件码 CF , ZF 等状态位。条件分支指
令根据 这些 状态位 实现 相应的 转移。常用 的控制 指 令有 JNZ, JZ, JMP, JMPF ,
CALL, CALLF , RET , RETF , LOOP 等。
表 2 .9
80X86 的最常用的 10 种指令

表 2 .10
控制指令的使用频度

(3 )增强运算型指令的功能
可通过增设强功能复合指令来取代原先由常用宏指令或子程序实现的功能。如
在科学计算的计算机中 , 为减少程序调用的额外开销 , 减少子程序所占用的主存空
间 , 加快运算型指令的速度 , 常设置有复杂函数运算类指令 , 如开平方、求三角函数、
对数函数、指令函数等。在一些经常进行事务处理的计算机中 , 设置有二—十进制转
换、编辑、翻译等指令。例如 , IBM370 上增设的翻译指令 , 属于 SS 型指令 , 它可以完
成码制转换 , 如 ASCII 码与 BCD 码之间的转换。指令实现的功能如下:
翻译
L
B1
D1
B2
D2
8 位
8 位
4 位
12 位
4 位
12 位
( (B2 + D2 ) + ( (B1) + D1 + G) )→(B1 ) + D1 + G
其中 , G = 0 ,1 , ⋯ , L - 1。即将由 (B1 ) + D1 形成的主存字节单元起始 , 连续 L 个字
符 , 逐个通过查变换表进行变换 , 而指令中的 (B2 ) + D2 指明变换表在主存中的起始
地址。
用新指令替代常用指令串的办法实际上是尽量减少程序中如存、取、传送、转移、
比较等不执行数据变换的非功能型指令的使用 , 让真正执行数据变换的加、减、乘、除
等功能型指令所占的比例提高。有时也以程序中功能型指令与非功能型指令的条数
比值作为衡量计算机系统结构设计好坏的一个标志 , 不过 , 这个比值也与所选定的工
作负荷有很大关系 , 在实际使用时 , 要在指令的执行速度、使用频度、复杂度等多方面
综合分析和权衡。
2. 面向高级语言及其编译程序的指令功能的优化与改进
今天几乎所有的程序都是用高级语言编写的 , 而高级语言源程序必须经相应的
编译程序编译生成目标程序后才能在机器上运行 , 这与直接用机器语言或汇编语言
编写的程序相比 , 时间开销和空间开销都要大一个数量级 , 因此 , 从面向高级语言及
编译程序来改进指令的功能 , 主要是为了缩小高级语言与机器语言之间的语义差距 ,
支持编译系统 , 使编译过程加快 , 目标程序形成效率高。它的主要改进方法有如下方
面:
(1 )用指令实现高级语言中的高频度语句
这种改进方法也是对语句的使用频度进行统计 , 和前面不同的是对各种高级语
言源程序中的不同的指令进行统计 , 根据统计结果 , 对常用的指令或指令串提供支
持。如 IBM370 中为优化循环时的循环控制的辅助操作而增设的“小于等于转移指
令”、
“计数转移指令”等。
(2 )从编译系统代码生成的优化算法的要求 , 使指令系统更加规整和对称
编译优化应使各存储单元和寄存器在指令系统中都具有同等的地位 , 运算数据
可以取自任意单元 , 存入任意单元 , 这样可以提高编译速度 , 使名称符号易于与暂存

79
单元对应 , 有利于 减少名称暂存单元的 冗余 , 减少一些附加操作程 序指令。如在
IBM370 中就有许多不规整、不对称的地方。如通用寄存器并不真正通用 , 有的指令
只能使用指定的几个寄存器 , 对寄存器使用的种种限制 , 造成在编译时凡指令要用到
这些指定的寄存器时 , 必须先腾空再移入数据 , 增加了不必要的数据传送次数 , 使通
用寄存器的优化管理复杂化。像存、取、加、减和乘这类指令 , 都有对应的全字 ( 32
位)、半字(16 位)指令 , 但除法指令却只有全字的 , 这些都是 IBM370 不对称的地方。
还有一些特殊使用也给软件的设计带来不便 , 如“十—二进制”指令 , 其溢出却是以
“定点除溢出”形式出现。
(3 )指令系统对高级语言的支持 , 应保持对各种高级语言的语义差距的一致性
高级语言和机器语言之间存在着很大的语义差距 , 如果试图适应某一种语言结
构的特殊性质而设计指令 , 通常却难以使用。而且多种语言同时存在 , 它们之间的语
法结构差别也很大。为可以对更多的高级语言提供支持 , 应设法提供基本原语 , 而不
是解决方案 , 使指令集 结构能 与各 种高级 语言的 语义 差距都 有共 同的缩 小。如
IBM370 中的“小于等于转移”复合指令 , 对各种语言的循环控制都有支持 , 这也符合
软硬取舍的原则。
微程序的发展 , 特别是可读写控存的采用 , 可采用动态指令系统结构 , 分别面向
不同的高级语言。在不同语言环境下 , 引入不同的指令系统 , 由可读写控存分别装入
不同指令系统的解释微程序 , 其余的微程序放在主存中 , 使用时调入 , 这样使编译工
作量减少 , 而代之解释过程。如 1972 年的 B-1700 就是这样一种思路。它为 BASIC,
FORTRAN , COBOL 与 RPG , SDL 语言每种都设计了一个对应的系统结构 , 这种系
统结构由微程序解释实现。其中 , 因 COBOL 与 RPG 的语义相近 , 所以这两种语言
共用一种系统结构。SDL 语言的系统结构是为操作系统提供支持的。各种系统结
构都有自己的指令系统和数据表示 , 对这种高级语言来说都是最优化的 , 这样 , B-
1700 就具有多种系统结构 , 在运行过程中根据需要动态地切换。
(4 )发展高级语言机器
如果进一步缩小高级语言和机器语言之间的语义差距 , 不断减小编译的工作量 ,
而增大解释的比例 , 最后发展出来的就是高级语言计算机 , 不再需要编译优化。如高
级语言作为计算机的汇编语言来使用 , 称为间接执行高级语言计算机 , 如直接作为机
器语言来使用 , 则称为直接执行高级语言计算机。20 世纪 70 年代初出现过一些高
级语言计算机 , 但性能价格比不理想 , 没有产生过巨大的商业影响。且在 20 世纪 80
年代初期 , RISC 思想的萌芽 , 使计算机系统结构的方向 , 开始由为语言提供高级硬件
支持的方向后退。
3. 面向操作系统的指令功能的优化与改进
比起高级语言来 , 操作系统对系统结构的依赖性更大。如没有系统结构提供的
中断响应硬件支持 , 实时操作系统就很难实现。在操作系统中 , 直接由指令系统支持

80
的功能主要有:
● 进程管理:进程切换、进程的生成与撤消、进程间的同步与通信;
● 存储管理:存储空间的分配、页表的管理等;
● 保护:存储保护、程序保护和数据保护等。
像以上这些“机构型”的功能 (基本的、较固定的功能 ) 适宜于硬件实现 , 而一些
“策略型”的功能(会随不同的环境而异 , 而且用户应能修改的功能 ) , 如作业排队、资
源管理、进程优先级的确定等 , 是不稳定的 , 会随环境不同而发生变化 , 它在操作系统
的运行期间会不断变化 , 所以不适于硬件实现 , 而适于软件实现。具体的支持途径有
三条:
(1 )用硬件实现一些管理类指令
如 IBM370 的“测试与置定”指令、
“比较与交换”指令 , 是为了支持多个进程正确
使用公用区的管理而增设的专用指令。
(2 )用固件实现一些使用频繁、对速度影响大的子程序( HOT SPORTS 过热点)
固件可做扩展固件 , 可保证与原系统的兼容。
不少机器(如 IBM370) 是将操作系统中的下述过热点采用固化和硬化实现 , 它
们是:
● 进管处理:对要求进入管态 , 调用 OS 的申请进行分析 , 并按它执行 N 向转移 ,
进入相应的管理程序。
● I/ O 中断处理:对中断申请进行分析并转移到相应的中断处理程序。
● 通道控制字翻译程序:对通道控制字进行翻译并传送到实存。
● I/ O 工作区的管理:动态地对 I/ O 工作区进行分配。
● 虚拟存储管理:对不同容量要求的各个用户进行主存分配。
● 页面管理:在辅存与主存之间进行页面交换 , 等等。
如 IBN370 配上这种选件可提高 OS 速度 20 % 以上。
(3 )用固件实现原语
可避免中断的执行干扰关键程序段 , 又可减少中断开、闭的辅助操作。
总之 , 正确的指令系统改善途径是: 在尽量缩小语义差距的前提下 , 充分发挥软、
硬件的特长 , 即硬件实现可提高系统执行效率和速度 , 减少系统管理调度的开销 , 而
软件实现能提供较高的灵活性和较复杂常变的算法。今后指令系统功能的改进 , 还
将进一步对应用软件提供支持 , 如支持数据库软件的比较、搜索、排序等处理过程 , 这
可提高计算机对事务处理应用的支持能力。
2. 4. 3 精简指令系统计算机(RISC)设计风格
RISC(Reduced Instruction Set Computer ) , 指令系统功能优化和改进的另一种
方向 , 它和 CISC 的指导思想完全相反 , 是研究如何通过减少指令总数和简化指令的
功能来降低硬件设计的复杂度 , 提高指令的执行速度。沿着这条途径和方向发展 , 使

81
计算机指令系统精练简单 , 因此 , 称采用这种途径设计成 CPU 的计算机为精简指令
系统计算机 RISC。当今 RISC 的典型代表如 Hewlett Packard PA - RISC, IBM 和
Motorola PowerPC, SGI MIPS, 最初由 Sun Microsystem 开发的 SPARC, DEC Al-
pha, Motorola 88110, Intel 80860, 80960。另外 , 在有些典型的 CISC 处理机中也采
用了 RISC 设计思想 , 如 Intel 公司的 80486 , Pentium, Pentium Pro, Pentium Ⅱ及以
后的产品。
1. 精简指令系统的设计思想
最早的计算机 , 包括 UNIVAC I, EDSAC 和 IAS 计算机 , 都是基于累加器的计
算机 , 这类计算机的简单性 , 在硬件资源十分有限的条件下成了很自然的选择。从这
些简单计算机的出现 , 特别是 1964 年 IBM360 系列机推出之后 , 人们一直在改进计
算机的结构 , 不断地改进指令的功能 , 不断地增强机器的功能 , 强调的都是如何为高
级语言、操作系统、程序设计环境及应用等提供更多更好的硬件支持 , 缩小它们与系
统结构和机器语言之间的语义差距。就像上面所讲的 , 这种改进和发展的计算机就
是 CISC。但是到了 20 世纪 70 年代中期以后 , 开始感到采用这种日益庞大复杂的指
令系统不但实现起来越来越困难 , 实际上还有可能降低整个系统的性能。因此 , 1975
年 IBM 公司就组织力量研究采用复杂的指令系统是否合理的问题 , 在 John Coche
领导下 , 于 1979 年研制出了 32 位的 IBM 801 小型计算机。IBM 801 计算机是为
100 万门交换机而设计的 , 它作为大型电话交换系统的高速控制器 , 当时要求探索新
的设计途径 , 性能指标要求达到 6MIPS。在设计这台计算机时 , John Coche 等人对
指令系统作了精选 , 只选取了少量简单、使用频度高的指令来构成指令系统 , 并设法
使每条指令都在一个周期内执行完毕 , IBM 801 只有 120 条指令 , 指令字长固定为
32 位 , 采 用硬 联线 控制 , 设有 32 个 通用 寄 存器 , 两 个 cache ( 指令 cache 和 数 据
cache) , 强调了流水线的实现。由于采用了这一系列的措施 , 尽管在当时还没有 VL-
SI 芯片 , 仍使 IBM 801 性能达到了 10 MIPS , 超过了原先的 6 MIPS 的设计要求。虽
然早在 1964 年 , Control Data 发表的第一台超级计算机 , 即 CDC 6600, 该机的设计
者们为了流水线的效率 , 采用了简单的系统结构 , 但 IBM 801 仍是计算机领域首先
使用 RISC 思想研制出的计算机 , IBM 801 是一个试验项目 , IBM 从来没有把 IBM
801 直接转化成产品 , 而是采纳了它的设计思想 , 它是 1986 年正式推出的 IBM RT-
PC 工作站的雏形。
1979 年 , 美国加州大学伯克利分校以 David Pat terson 为首的研究小组进一步开
展了这方面的研究工作 , 他们发现 , CISC 并没有使计算机系统性能有明显提高 , 反而
与软硬件的发展出现了很不协调的情况 , 其原因主要是 CISC 存在如下一些问题:
(1 )指令系统复杂
具体表现在以下几个方面:
CISC 的指令条数一般多于 100 条 , 寻址方式大于 4 种 , 指令格式大于 4 种。如

82
VAX 11/ 780 (1978)包括 304 条指令 , 24 种寻址方式 , 2～57 个字节不等的可变长指
令格式 , 微代码存储器 480KB, 而 1985 年公布的 Intel 386 有 111 条指令 , 11 种寻址
方式 ,1～17 个字节不等的可变长指令格式。这么庞大的指令系统 , 多种指令格式和
复杂的寻址操作 , 使指令译码、硬件设计复杂化 , 这不利于 VLSI 的设计 , 复杂的指令
还需复杂的控制器 , 这使微程序执行速度也很难提高 , 同样延长了设计周期 , 降低了
系统的可靠性。
(2 )有些复合以后的指令 , 并不比几条简单的指令执行速度快
在 CISC 中 , 为了支持目标程序的优化 , 缩小高级语言与机器语言之间的语义差
距 , 增加了许多复杂指令 , 用一条这样的指令代替原来的一串指令 , 但为了实现这些
指令的功能 , 不仅仅是增加了硬件的复杂度 , 而且使指令的执行周期大大加长了。据
统计 , 一般 CISC 处理机的指令平均执行周期都在 4 个以上 , 有些在 10 个以上 , 如
Intel 公司的 8088, Motorola 公司的 MC68010 等。
(3 )复杂的指令系统使编译效率难以提高 , 编译程序复杂
编译程序的基本任务是完成大量的各种情况的分析 , 生成高效的目标代码。指
令系统越复杂 , 选择目标指令的范围越大 , 则分析情况的数目就越多 , 分析就越困难 ,
需要的时间就越长 , 而且就更加难以获得优化的目标程序。
(4 )扩展的指令使用频度不很高
在 CISC 中 , 各种指令的使用频度相差很大 , 大量的统计数字表明 , 存在这样一
个规律:约有 80% 的指令只有 20 % 的时间用到。如在表 2 .9 中的统计结果 , 80×86
中常用的指令只有 10 条 , 占了总指令条数的 96% 。所以说 , 扩展指令对提高整机性
能价格比不利。
针对 CISC 结构存在的这些问题 , Patterson 等人首先提出了 RISC 这一术语 ,
RISC 是一种计算机系统结构的设计思想 , 它不是一种产品。由 Pat terson 领导的研
究组 , 根据这一思想 , 先后研制了 RISC-Ⅰ和 RISC-Ⅱ计算机。 RISC-Ⅰ是 32 位的微
处理器 ,1981 年研制成功 , 总共有 31 条指令(算术逻辑运算 12 条 , 访问存储器指令 8
条 , 程序控制指令 7 条 , 其他指令 4 条) , 3 种数据类型 , 2 种寻址方式(变址寻址和 PC
相对寻址)。寻址单位为字节 , 指令字长是 32 位 , 采用三地址制 , 有少量指令采用二
地址和一地 址 , 时钟 频 率 8M Hz, 所 有 指 令 都在 一 个 周 期 ( 500ns ) 内 完 成 , 只 有
LOAD/ STORE 指令可以访问存储器 , 其他指令的操作都在通用寄存器之间进行。
设置了 78 个通用寄存器 , 采用重叠寄存器窗口技术(后面将讲到) , 使用 NMOS VL-
SI 电路 , 控制芯片的面积只占约 6% , MC68000 为 50% , Z8000 为 53% , 设计错误和
布线错误都只有大约 12 个 , 而 MC68000 的设计错误和布线错误各有 70 个 , Z8000
为 60 个和 100 个。研制周期只用了 10 个月 , 其性能却比当时最先进的商品化微处
理器 MC68000 和 Z8000 快 3 ～ 4 倍 , 有 些 方 面 还 超 过了 小 型 机 PDP-11/ 70 和
VAX11/ 780。1983 年 RISC-Ⅱ研制成功 , 采用与 RISC-Ⅰ相同的 NMOS 工艺 , 指令
系统扩充到 39 条( 增加了采用变址寻址方式的取数指令 5 种和存数指令 3 种) , 通用

83
寄存器增加到 138 个 , 时钟频率提高到 12MHz, 指令执行周期缩短到 330ns, 存取指
令只能使用变址寻址一种方式 , 设计错误大约只有 18 个 , 布线错误大约只有 12 个 ,
控制部分只占 CPU 总面积的 10% 。
1981 年美国的斯坦福大学在 J .Hemnessy 教授领导下研制了 MIPS( Micropro-
cessor Without Interlocking Pipeline Stages, 无互锁多级流水线处理器) 的 RISC 芯
片 , 强调流水高效实现和采用编译方法进行流水调度 , 使 RISC 技术设计风格得到很
大补充和发展。1985 年后推出商品化的 MIPS2000RISC 机 (1986 ) , 1987 年 SUN 公
司推出了基于伯克利分校 RISC 机的 SPARC 系统结构 , 从此以后 , RISC 技术在计算
机工业界被广泛采用。从 1985 年以后所宣布的任何计算机 , 基本上都采用了 RISC
技术。那么 , 什么样的计算机才是 RISC 计算机呢 ? RISC 计算机应有哪些特点呢 ?
主要特点归纳如下:
① 大多数指令在单周期内完成。
② 采用 Load/ Store 结构: 尽量将运算的数据存放在寄存器中 , 从而减少访问
RAM 的次数。
③ 硬布线控制逻辑:真正由硬件完成 , 而不是通过 Micro program 完成。
④ 减少指令和寻址方式的种类。
⑤ 固定的指令格式。
⑥ 注重译码优化。
⑦ 面向寄存器设计指令系统。
⑧ 注重 pipeline 的效率设计。
⑨ 重视优化编译设计。
2. RISC 基本设计原则
由于 RISC 是针对 CISC 结构存在的问题而提出的另外一种完全相反的设计思
想 , 在具体设计 RISC 处理器时 , 指令集的选取就应当遵循一些原则 , 主要包括如下
几个方面:
(1 )采用寄存器间的运算结构
除 LOAD 和 STORE 指令以外 , 其余指令都在寄存器之间进行 , 使编译优化 , 尽
量减少访存的次数。
(2 )选取核心的和较常用的指令
确定指令系统时 , 应选择高频度指令 , 在此基础上增加少量扩展指令 , 使指令条
数尽量少。
(3 )采用单字指令、固定操作数域
这样 ,90% 以上的指令可在一个执行周期内完成 , 访存可通过寄存器间址方式扩
展寻址范围。
(4 )硬联控制为主 , 固件实现为辅

84
所有简单指令直接用硬件译码 , 由硬件提供 Cache , I/ O , 虚存管理、内存管理等
的支持 , 提高指令执行速度 , 少数指令采用微程序实现。
(5 )支持高级语言
对一些既实现简单 , 又对高级语言支持较大的复杂指令 , 如 CALL 指令用微程
序来实现 , 再加上编译的优化及协处理器的支持 , 使 RISC 能更好地支持高级语言环
境。
3. RISC 实现的关键技术
如上所述 , RISC 之所以有如此良好的性能 , 除了在设计 RISC 处理机时应遵守
的那些原则外 , 主要是由于它采用了一些特殊实现技术 , 目前 , 在 RISC 处理机中主
要采用如下几种技术:
(1 )重叠寄存器窗口技术( overlapping register windows)
CISC 中的一条复杂指令 , 在 RISC 中通常要用一段由简单指令组成的程序段来
实现 , 因此 , RISC 中的过程调用 (CALL)和返回指令( RET URN )要比 CISC 中的多。
据统计 , 在 PASCAL 语言和 C 语言中分别有 15% 和 12 % 的 CALL 和 RE TU RN 操
作 , 而它们访问存储器的信息量却占整个访存信息量的 44 % 和 45 % , 这是因为这两
种指令需要传递大量的参数 , 因此缩短 CALL 语句和 RE TU RN 语句的操作时间在
RISC 结构中就非常重要。
为减少 CALL 和 RE TU RN 大量的访存操作 , 美国加州伯克利分校的 F .Basket t
提出了重叠寄存器窗口技术 , 它的基本思路就是在处理机中设置一个数量较大的寄
存器堆 , 并把它分为若干个寄存器组 , 每组有若干个寄存器 , 称为寄存器窗口。每个
寄存器窗口中 , 又分成大小固定的三个区: 高区、本区和低区。每当有过程调用时 , 就
分配一个未被使用的寄存器窗口 , 在这个寄存器窗口中 , 高区用来存放调用过程传来
的参数 , 在本过程返回时用来存放要返回给调用者的参数。本区用来存放局部变量 ,
只有本过程可以访问 , 而低区作为本过程调用其他过程时传递参数给被调用过程 , 被
调用过程执行完时送回的结果也存放在此区中。在使用时 , 每一对调用和被调用过
程的寄存器窗口各自的低区和高区相互重叠。一旦发生过程调用或返回 , 由一个窗
口转换到另一窗口时 , 这些参数就通过两个窗口间的重叠的寄存器部分自动地被传
送 , 而不再需要额外的传送时间。另外还要设置一个为所有过程公用的寄存器组 , 用
来存放全局变量 , 所有的过程都可以直接访问。
重叠寄存器窗口技术首先在 RISC-Ⅰ上应用 , 后又在 RISC-Ⅱ上实现 , 下面就以
RISC-Ⅱ为例 , 说明这种技术的应用。
RISC-Ⅱ机共有 138 个 32 位的工作寄存器 , 编号从 0 ～137, 其中第 0 号至第 9
号共 10 个寄存器中存放全局变量 , 可被所有正在系统中运行的程序或过程直接访
问 , 故称为全局寄存器。剩下的 128 个寄存器分为 8 个寄存器窗口 , 每个窗口中有
22 个逻辑寄存器 , 编号为 R10 到 R31, 它们被分为三部分: 其中逻辑编号为 R10 到

85
R15 的 6 个寄存器为低区 , 存放输出参数 ( 本过程是主调程序) ; 编号为 R16 到 R25
的 10 个寄存器为本区 , 存放只有本过程访问的局部变量; R26 到 R31 的 6 个寄存器
称为高区 , 存放输入参数( 本过程是被调用程序)。这样 , 每个过程可以直接使用的寄
存器总共有 32 个。整个系统共有 8 个窗口 , 窗口号是 0～7。只要调用的深度不超
过 8 层 , 重叠寄存器窗口技术可以减少大量的访存操作 , 当调用层数超过 8 层时 , 称
为寄存器溢出 , 这时就需将一个窗口中的内容传送到主存 , 以腾出一个空窗口。实验
表明 , 调用深度一般不会超过 6 层 , 发生寄存器溢出的机会大约只占 1% 。
图 2 .16 中所示的是 A 过程调用 B 过程、B 过程又调用 C 过程的情况。A 的低
区和 B 的高区重叠 , B 的低区和 C 的高区重叠 , 这样 , 不需要花费任何附加的操作时
间就可以实现调用和被调用过程的参数传递 , 因而可以大量减少调用和返回时的访
存信息量。
表 2 .11 是 RISC-Ⅱ和 VAX-11 , PDP-11 , MC 68000 执行调用和返回时的开销
比较 , 可以看出 , 在执行时间、执行指令条数、访问存储器次数方面 , 采用重叠寄存器
窗口技术都是非常有效的。
表 2 .11
过程调用/ 返回的开销

(2 )采用流水和优化延迟转移技术
RISC 中由于大部分指令都可以在一个机器周期内执行完毕 , 很适合流水处理。
为了加快计算机中的指令执行速度 , 一般都采用了让本条指令的执行和下条指令的
预取在时间上重叠起来的流水方式。取指令和执行还可进一步流水处理 , 如在指令
的执行阶段 , 又可将从源寄存器读操作数、运算及运算结果打入目的寄存器三者之间
采用流水方式实现 , 具体流水线的级数因计算机而异。
正常情况下 , 流水处理每一个机器周期就能执行完一条指令。然而 , 在遇到转移
指令且转移成功时 , 流水线就要断流。在 CISC 机中 , 为实现灵活转移 , 一般将比较
和转移功能分为两条指令 , 这样比较指令结束后才能对相应条件码进行置位 , 转移指
令才能根据条件码进行相应的处理。RISC 中 , 为加快转移指令的处理 , 减少断流时
间 , 一般将这两条指令合并成一条“比较转移”指令 , 该指令将直接对两个对象进行相
等或不等比较 , 然后根据比较结果判别是否进行转移 , 若转移成功 , 转移目标地址也
只能在这条指令执行完成后才能计算出来 , 这时必须使流水线停顿一段时间 , 直到转

86
图 2 .16 RISC-Ⅱ的重叠寄存器窗口
移目标地址已产生为止。在转移指令后 , 需延迟到后继指令进入流水线的时间段称

87
为转移延迟槽。转移目标地址生成得越晚 , 转移延迟槽就越长 , 因转移指令使用频度
较大 , 为尽量减少转移指令对流水线性能的影响 , 减少损失 , 通常在延迟槽内插入一
些指令 , 这就需要采用延迟转移技术。
延迟转移技术就是在转移延迟槽中插入空指令 , 减少转移方向错误的损失。虽
然这种方法可避免预取的转移指令后的下一条指令作废 , 减少访存开销 , 但这同样要
浪费一个机器周期 , 如果在转移延迟槽中插入一条有效指令 , 即这条指令的执行不影
响转移指令的执行和转移后后续指令执行的结果 , 也不影响指令的流水执行 , 这样就
可少花费一个机器周期 , 这种技术就称为优化延迟转移技术 , 如表 2 .12 所示。
表 2 .12 中示出了一小段程序 , 其中 , R1, R2, R3 为寄存器单元 , X, Y 为主存单
元。表中第二列为不采用延迟转移技术的常规转移方法 , 如果执行到地址为 102 处
的转移指令“BRANCH 105”时 , 如果转移成功 , 则采用流水方式预取的下一条指令
“ADD R1 , R2”将作废 , 否则将导致错误。第三列为在转移指令后插入一条空指令 ,
这样 , 即使转移成功了 , 也可直接从目的地址重新取指令执行 , 不影响程序的结果。
但执行空操作同样浪费了一个机器周期 , 为避免这种浪费 , 如果将 101 处指令和 102
处的转移指令的顺序对调一下 , 且原 101 处的指令的执行不影响转移指令的执行和
其后续指令的执行结果 , 如第四列所示 , 则采用这种方法后 , 即使转移成功也是在其
后的指令执行完毕后才发生 , 从而使预取的指令不作废 , 就可减少一个机器周期 , 这
就是优化延迟转移技术。
表 2 .12

在优化延迟转移技术中 , 插入的这条有效指令如何选取呢 ? 一般来说 , 如果转移
指令的前一指令与转移指令不相关 , 则直接插入转移指令前一指令即可 , 如上表所
示。如果转移指令前一指令与转移指令相关 , 则可以选取某转移方向指令插入转移
延迟槽。当然 , 这部分工作是由编译程序自动进行的。所以说 , 优化延迟转移技术对
应用程序员透明 , 对系统程序员不透明。这也说明了在 RISC 计算机中 , 流水属于系
统结构 , 不像一般的流水机中流水只属于计算机组成。
模拟统计结果表明: RISC 的转移延迟槽一般为一条指令 , 填入转移延迟槽中的

88
指令 , 其中 50% 以上的将是有效指令。
如果遇到条件转移指令时 , 调整指令序列非常困难 , 在许多情况下找不到可以用
来调整的有效指令 , 有些 RISC 处理机中采用指令取消技术。如果指令被取消 , 相当
于执行了一条空操作指令 , 不影响流水线的运行 , 但为了减少指令取消带来的流水线
效率的降低 , 应该尽量少取消指令。因此 , 可采用如下规则:
如果转移目标地址小于当前程序计数器 PC 值的向后转移 , 则在转移不成功时
取消下条指令 , 否则执行下条指令; 如果转移目标地址大于当前程序计数器 PC 值的
向前转移 , 则正好相反 , 在转移不成功时执行下条指令 , 否则 , 取消下条指令。
向后转移指令取消技术的例子:
LOOP : XXX
XXX
YYY
LOOP: YYY
…
…
ZZZ
ZZZ
COMP R1, R2 , LOOP
COMP R1, R2, LOOP
WWW
XXX
WWW
(a) 调整前的程序
( b) 调整后的程序
循环体的第一条指令 XXX 经调整后安排在两个位置 , 第一个是进入循环体之前先
要执行一次 , 第二个是在循环条件判断指令的下面 , 执行完条件判断指令后 , 如果转
移成功 , 则 XXX 指令的执行有效 , 接着返回到 LOOP , 再重新进入循环; 如果转移不
成功 , 则取消 XXX 指令的执行 , 接着执行 WWW 指令。
由于向后转移时 , 绝大多数情况下是转移成功的 , 只有在循环结束时转移才不成
功 , 因此 , 采用这种指令取消技术能够使指令流水线在绝大多数情况下不断流 , 保持
高的流水线效率。
向前转移的情况 , 主要适用于像 IF⋯ ⋯T HEN 这样的控制结构 , 如下面一段程
序:
XXX
⋯
YYY
“IF”部分的程序代码
COMP R1 , R2, T HU R
ZZZ
⋯
WWW
“ T HEN”部分的程序代码
T HU R: VVV
由于向前转移成功与不成功的概率通常各为 50% , 因此 , 采用常规的指令取消
技术就可以了。在上面的程序中 , 如比较指令 COMP 指令的转移条件成立 , 则取消

89
下条指令 ZZZ 的执行 , 程序转向 T HU R 位置 ,“ T HEN”部分的指令全部不执行; 如
转移不成功 , 则下条指令 ZZZ 不取消 ,“T H EN”部分的指令全部执行。
另外 , 还有一种情况 , 即在条件分支中只有一条指令的情况 , 可以采用隐含转移
技术 , 例如实现下面的语句:
IF(a < b) TH EN b = b + 1
用汇编语言改写为:
COMP > = , Ra, Rb; 通用寄存器 Ra, Rb 中分别存放变量 a 和 b
INC Rb
指令 COMP 如转移成功 , 则取消下条指令 , 否则 , 执行下条指令 INC。
这里要特别注意的是 , 调整指令序列绝对不能改变原来程序的数据相关关系 , 即
被移动指令中所有的数据存储单元与移动过程中所涉及指令的数据存储单元之间不
能有数据的读—写、写—读、写—写相关。而且 , 被调整的指令也不能破坏 CPU 的
条件码。如果不能满足上述条件 , 则只能在转移指令后 , 插入一条 NOP 指令。
(3 )在逻辑上采用硬件实现为主 , 固件实现为辅的技术
用微程序实现机器指令的主要优点是容易实现复杂指令的功能 , 且指令系统容
易修改 , 增加了计算机的灵活性和适应性 , 但由于多次访问控制存储器取微指令要花
费一定的时间 , 所以降低了指令的执行速度。而在 RISC 中要求绝大多数的指令都
是单周期指令 , 因此 , 在 RISC 计算机中 , 一般采用让大多数的简单指令用硬联方式
实现 , 少数复杂指令可用微程序解释实现 , 且最好采用高度水平型微指令 , 即用固件
的方式实现。现在大多数商用的 RISC 处理机中指令系统的实现方法 , 都采用以硬
件为主固件为辅的方法。
(4 )采用优化编译技术
RISC 的处理机在采用硬件技术提高性能的同时 , 优化编译技术也起着非常重要
的作用。优化的目的主要是对程序重新排序和调度 , 优化代码顺序 , 减少目标代码长
度 , 提高程序运行效率。
在 RISC 中所采用的优化编译技术 , 除了要充分利用常规的优化技术和手段进
行编译程序设计外 , 还要注意以下方面的优化设计: 高级优化阶段中对原始程序进行
优化(如用过程体代替过程调用) ;局部优化阶段的块内优化( 如消去公共子表达式、
常数传递、降低堆栈高度等) ;全局优化阶段的块间优化( 如拷贝传递、代码移动、消去
索引变量等) ; 寄存器的分配(提高寄存器的利用率 , 这一步较少依赖计算机) ; 代码生
成阶段(利用计算机的特点进行优化 , 如降低计算量、流水线调度、分支偏移的优化 ,
这一步需依赖计算机) , 主要突出了两个方面的优化调度:一是如何最佳地分配 RISC
中大量寄存器的使用 , 从而减少访问存储器的次数; 二是设法对程序中的指令序列进
行调整 , 在保持原来语义正确的基础上尽量减少计算机的空等时间。另外 , 还可设法
对指令序列进行调整 , 消除指令中不必要的等待时间。
例如:设 A , A + 1, B, B + 1 为主存单元 , 则程序段

90
LOAD
R1 , A
STORE
B, R1
LOAD
R1 , A + 1
STORE
B + 1, R1
该程序实现的是将主存单元 A , A + 1 的内容传送到 B, B + 1 两个主存单元中去。因
LOAD 和 STORE 指令交替进行 , 都要用到同一个寄存器 R1, 所以上条指令没有执
行完 , 下条指令就无法执行 , 这不利于流水处理 , 如果将这段程序改为如下的程序段:
LOAD
R1 , A
LOAD
R2 , A + 1
STORE
B, R1
STORE
B + 1, R2
则实现的功能和上面的程序段一样 , 但这四条指令可流水执行 , 这样每隔一个机器周
期就解释完一条指令 , 速度提高了 1 倍。
综上所述 , RISC 中的优化编译技术 , 主要是为了在编译时就可发现可能出现的
阻塞情况 , 由编译器通过寄存器置换、调整指令序列等手段来消除可能出现的阻塞情
况 , 从而使流水线的运行效率达到最高。当无法消除时就填入相应的空操作 , 因此不
需要硬件的互锁流水支持。
以上所述的这些实现技术在目前流行的 RISC 计算机中经常采用 , 但并不是在
每一种 RISC 处理机中都必须采用以上的所有技术。实际上 , 在 RISC 处理机的设计
上 , 主要有两个典型代表。一个是遵循加州大学伯克利分校的 RISC-Ⅰ , RISC-Ⅱ机
的思路 , 侧重采用由大量寄存器组成的寄存器组 , 以及寄存器窗口重叠技术; 另一个
则是遵循斯坦福大学的 MIPS 计算机的思路 , 侧重采用优化编译技术。
如 RISC-Ⅱ中 , 采用了多寄存器和寄存器窗口重叠技术 , 同时也采用了优化延迟
转移技术。该机器的主要设计思想在以后的 SUN SPARC 系统结构中被广泛采用 ,
而斯坦福大学的 MIPS( Microprocessor without Interlocked Pipeline Stage, 无互锁
的多级流水线处理机 ) 系列 , 即 MIPS R2000/ 3000/ 4000/ 4400/ 10000 等则主要侧重
于借助软件手段 , 特别是优化编译来提高计算机性能。它们的主要特征就是不采用
硬件互锁流水 , 而依靠优化编译器进行指令序列的调整 , 防止流水线中出现的相关冲
突 , 没有采用寄存器窗口重叠技术。
2. 4. 4 CISC 机和 RISC 机的比较
RISC 是针对 CISC 中存在的问题而提出的一种指令系统的设计思路 , 和 CISC
机相比 , RISC 机具有以下特点:
1. RISC 系统结构的主要特点
(1 ) 强调系统结构与 VLSI 实现技术之间的配合

91
硬件实现要求逻辑电路具有简单性、规格化和高度重复性。在 CISC 处理器中 ,
指令译码和控制电路相当复杂 , 控制逻辑占用芯片面积的 50% 以上。而在 RISC 处
理器中 , 由于指令简单、规整 , 方便 VLSI 设计和验证 , 适合 VLSI 技术的实现。控制
器和 CISC 相比也很简单 , 控制逻辑只占用芯片面积的 10 % 左右 , 这样就可以有多余
的空间来加强处理器的其他功能 , 除了前面所讲的寄存器窗口重叠技术外 , 还可以广
泛采用高速缓冲技术提高处理机的速度。
(2 ) 强调系统结构与编译器的优化配合
前面所述的延迟转移技术、延迟取数等指令流调整的优化编译技术 , 可充分利用
寄存器的快速访问及流水处理的高速处理。具体方法在第五章介绍。
(3 ) 强调流水线技术及对并行度的开发
由于单周期的简单指令有利于流水处理 , 所以执行速度可提高很多。另外 , 高速
缓存的采用 , 加快了 CPU 对内存的访问(第四章详述) , 有利于流水处理。
由于 RISC 可节省空间 , 可加入多处理机相连的接口 , 如 Transputer T800 中有
一 100MB/ S 的通信连接接口 , 可直接使处理器之间互连成多机并行系统。如 CON-
NECT MAC HINE 是一个多达 65 536 个处理单元、系统峰值速度可达 28GFLOPS
多机并行系统。
另外还出现了几种新型结构的 RISC, 如超级流水线结构、超级标量结构、超长指
令字等。这将在第五章中详细介绍。
如果用 CPU 性能公式来比较这两种不同风格的处理机 , 则 CISC 处理机主要是
减少了指令的条数 , RISC 主要是减少了指令平均执行周期数 , 虽然就目标代码来讲 ,
RISC 的目标代码可能比 CISC 中长 2～3 倍 , 但由于流水处理和优化编译技术的使
用 , 总体上 RISC 的执行速度是 CISC 的 5～10 倍 , 所以总的处理速度可成倍提高。
2. RISC 系统结构存在的某些不足和问题
(1 ) 要设计复杂的子程序库
因为在 CISC 中的一 条复杂指令 , 在 RISC 中要用一段 子程序来 实现 , 所以 ,
RISC 的子程序库通常要比 CISC 的子程序库大得多。
(2 ) 对编译器要求较高
优化编译器必须精心安排每一个寄存器的使用 , 以充分发挥通用寄存器的功能 ,
尽量减少访存次数;同时 , 优化编译器还要做数据和控制相关性分析 , 要设法调整指
令序列 , 减少流水线断流的发生。
(3 ) 对浮点运算和虚拟存储器的支持虽有很大加强 , 但仍不够理想
由于 RISC 也存在某些不足和问题 , 使得在设计 CPU 时 , 有的机器向着采取将
RISC 和 CISC 概念和技术密切结合 , 互相取长补短的方向发展。如 Fairchild( 仙童)
公司的 CLIPPER 机就是这样一种典型的 32 位微处理机 , 在处理机内部有一块包括
CPU 与浮点运算单元的 CPU/ F PU。主 CPU 共有 101 条基本的硬联指令 , 其常用

92
指令的执行多数只需一个 30ns 时钟周期 , 设置了 32 个 32 位的通用寄存器 , 除存和
取指令可以访存外 , 所有操作都在寄存器之间进行 , 指令处理采用了 3 级流水 , 所有
这些都体现了 RISC 的特点。另外还包括 64 位浮点部件 F PU , 有 8 个 64 位的浮点
寄存器和独立的浮点运算部件 ALU , 包括 67 条 CISC 型的宏指令 , 可识别 10 种数据
类型 , 有 9 种寻址方式 , 14 种指令格式 , 有 16, 32, 48 位和 64 位共 4 种指令长度 , 这
些都体现了 CISC 的特点。所以说 , CLIPPER 机以提高整个计算机系统的性能为基
点 , 在结构上吸收了 RISC 和 CISC 各自的优点 , 并相互融合在一起。
RISC 技术经过近二十几年的发展 , 已逐步完善和成熟。目前各大计算机公司都
大力支持发展 RISC 系统 , 并且与 CISC 在结构上互相补充。1987 年 , 美国的 Phil
Koopmen 综合平衡 RISC 和 CISC 概念 , 提出了 WISC(Witable Instruction Set Com-
puter )结构设想 , 允许用户在 RISC 结构中 , 写入自己定义的复杂指令 , 这种针对用户
环境而采用自己定义的复杂指令是效益最高的指令 , 可使整机性能价格比提高。
2 .5 DLX 指令集结构
本节将讨论一种称为 DLX 的 Load/ Store 型指令集结构。DLX 是一种多元未
饱和型指令集结构 , 称之为多元未饱和型结构 , 是因为它不仅体现了当今多种机器
( AMD29K, DEXstation 3100, HP850, IBM801 , Intel i860, MIPS M/ 120A , MIPS M/
1000 , Motorola 88K , RISC-Ⅰ , SGI 4D/ 60, SPARCstation-1, Sun-4/ 110, Sun-4/ 260)
指令集结构的共同特点 , 而且它还将会体现未来一些计算机的指令集结构的特点。
这些机器的指令集结构设计思想都和 DLX 指令集结构的设计思想十分相似 , 它们都
强调以下几点:具有简单的 Load/ Store 指令集系统;设计上注重指令的流水效率; 简
化指令的译码;使编译器更容易产生高效的目标代码。
DLX 是一种适合于学习和研究的系统结构模型 , 下面就重点介绍其指令集结构
和效能。
2. 5. 1 DLX 指令集结构
1 .DLX 的寄存器
DLX 有 32 个 32 位通用寄存器 ( GPR) , 名称为 R0, R1, ⋯ , R31。寄存器 R0 的
值总是为 0, 稍后将会看到如何利用该寄存器由简单指令集来合成一组有用的操作。
另外 , DLX 还有 32 个 32 位的浮点寄存器( FPR) , 名称为 F0 , F1, ⋯ , F31。这些
浮点寄存器可以用来保存 32 位的单精度浮点数 , 或者通过相邻两个浮点寄存器奇偶
对 Fi Fi + 1 (i = 0 ,2 ,4 , ⋯ , 30 )来保存 64 位的双精度浮点数 , 这种组合而成的双精度浮
点寄存器被命名为 F0, F2 , ⋯ , F28, F30。

93
在 DLX 中还有一些特殊的寄存器 , 如用来保存浮点操作结果信息的浮点状态寄
存器 , 其中有些用来和通用寄存器交换数据。DLX 也提供了在 F PR 和 GPR 之间传
送数据的指令。
2 .DLX 的数据类型
DLX 提供了多种长度的整型数据和浮点数据。对整型数据而言 , 有 8 位、16 位
和 32 位三种长度; 对浮点数据而言 , 有 32 位单精度浮点数和 64 位双精度浮点数 , 遵
循 IEEE 754 标准。DLX 操作是面向 32 位的整数以及 32 位或 64 位的浮点数的。
字节或半字在调入 32 位的寄存器时 , 用零或者符号位来填充 32 位寄存器的剩余位。
一旦被调入以后 , 它们将按照 32 位整数的方式进行计算。
3 . DLX 数据传输的寻址方式
数据寻址方式只有立即数寻址、寄存器寻址、偏移寻址和寄存器间接寻址四种方
式。寄存器寻址字段的大小为 5 位 , 用来标识 32 个通用寄存器或浮点寄存器。
DLX 的存储器地址采用的是高端字节表示顺序 , 存储器按字节寻址 , 其地址宽
度为 32 位。由于 DLX 是一种 Load/ Store 结构 , 所以它通过寄存器 ( 通用寄存器和
浮点寄存器)和存储器之间的数据传送操作完成对存储器的访问。
由于 DLX 支持上述数据类型 , 所以对通用寄存器而言 , 相应的存储器访问数据
大小有 8 位、16 位和 32 位; 而对浮点寄存器而言 , 相应的存储器访问数据大小有 32
位的单精度浮点数和 64 位的双精度浮点数 , 所有内存访问必须是对准的。
4 . DLX 指令格式
由于 DLX 只有四种寻址方式 , 所以它们可以编码到操作码中。为了使计算机更
容易进行流水线操作和译码 , 所有指令都是固定的 32 位长 , 其中 6 位是基本操作码。
图 2 .17 是 DLX 指令的格式 , 从图可以看出 , 这些指令格式比较简单 , 同时还为偏移
寻址、立即数寻址或 PC 相对跳转地址提供了 16 位的域。
5 .DLX 操作
DLX 支持上面提到的一些简单操作 , 还有一些其他操作。DLX 指令大致可以
分为四大类:加载存储、ALU 操作、分支与跳转以及浮点数操作。
在后面对上述各种操作类型进行论述的过程中 , 将采用 C 语言的扩充形式来表
示指令的含义。所以这里首先介绍一些 C 语言扩充表示方法的约定。
① 符号“←”表示数据传送操作 , 其后附带一个下标 n, 即“←n ”表示传送一个 n
位数据。
② 符号“ # # ”表示两个域的串联操作 , 可以出现在数据传送操作的任何一边。


图 2 .17 DLX 的指令格式
③ 域的下标用来表明从该域中选择某一位。域中的位从最高位开始标记 , 并且
起始标记为 0。下标可以是一个单独的数字 , 如 Regs[ R4]0 表示选择寄存器 R4 中内
容的符号位;下标也可以是一个范围 , 如 Regs[R3]24 . .3 1 表示选择寄存器 R3 中内容的
最低一个字节。
④ 上标表示复制一个域 , 如 0
2 4 可以得到一个 24 位全为 0 的域。
⑤ 变量 Mem 用来表示存储器 , 存储器按照字节寻址 , 它可以传送任何数目的字
节。
为了进一步说明上述约定表示方法的用途 , 现设 R8 和 R10 均为 32 位寄存器 ,
那么 , Regs[R10 ]16 . .31 ←1 6 ( Mem [ Regs[ R8 ] ]0 )
8 # # Mem [ Regs [ R8 ] ] 的含义是: 以
R8 中的内容作为存储器地址寻址存储器相应单元的字节 , 将该字节的符号扩展形成

95
8 位的域 , 并和该字节的值串联形成一个 16 位的值 , 然后将该值传送到寄存器 R10,
保存在寄存器 R10 的低 16 位 , 而寄存器 R10 的高 16 位保持不变。
DLX 中的四种操作类型:
(1 )加载存储操作
DLX 中的所有通用寄存器与浮点寄存器都可作为加载 Load 和存储 Store 之
用 , 惟一例外的是加载 R0。单精度浮点数占用一个单精度寄存器 , 而双精度浮点数
占用一对 , 单精度与双精度之间的转换必须显式地进行。表 2 .13 给出了 DLX 的加
载和存储指令的例子。
表 2 .13
DLX 的加载和存储指令

(2 ) ALU 操作
在 DLX 中 , 所有的 ALU 指令都是寄存器—寄存器型指令 , 包括简单的算术和

96
逻辑操作:加、减、与、或、异或和移位。所有这些指令都支持立即数寻址模式 , 立即数
以 16 位符号扩展形式出现。L HI( 加载高位立即数 )操作将立即值加载到一个寄存
器的高半部分 , 而该寄存器的低半部分设为零。这样就可以通过两条 Load 指令构
造一个 32 位的常数。
正如上面所提到的 , R0 主要用来合成通用操作。如加载一个常数就可以看做是
一次简单的立即值加操作 , 其中一个源操作数是 R0 ; 寄存器—寄存器间的数据传送
可以通过其中一 个源操作 数是 R0 的加法来 完成 , 这两个 操作可以 分别用 LI 和
MOV 表示。
还有比较两个寄存器的比较指令( = , ≠ , > , < , ≥ , ≤) , 如果比较结果为真 , 则
比较指令将在目的寄存器中放入一个 1, 否则填入 0。因为这些比较操作都设置目标
寄存器 , 所以它们也被叫做 set-equal , set-not-equal, set-less-than 等。同时这些比较
指令也具有立即数的形式。表 2 .14 给出了 ALU 指令的例子。
表 2 .14
ALU 指令 ( 带有或不带有立即数 )

(3 )分支与跳转操作
在 DLX 中 , 对程序流程的控制是通过一组跳转与一组分支指令来实现的。根据
目标地址的两种指定方式和是否进行链接来区分 , 可以将跳转操作分为四种指令类
型。其中两种类型的跳转指令用带符号的 26 位偏移量加上程序计数器的值确定目
的地址 , 另外两种类型的跳转指令则指定一个包含目的地址的寄存器确定。跳转有
两种类型 , 一种是简单跳转 , 另一种是跳转并链接(用于过程调用) 。后者将返回一个
地址 , 即将下一条顺序指令地址( 返回地址) , 放入 R31 中加以保存。
DLX 中的所有分支指令都是条件分支指令 , 其源操作数寄存器中包含了一个数
值或某个比较结果。分支指令测试该源操作数寄存器中的值是 0 还是非 0, 从而决
定分支是否成功。分支目标地址由一个带符号的 26 位偏移量加上程序计数器的值
来确定 , 分支目的地址指向下一条要执行的指令。表 2 .15 给出了一些典型的分支和

97
跳转指令。
表 2 .15
典型的分支和跳转指令

(4 )浮点操作
在 DLX 中 , 浮点指令的操作数来源于浮点寄存器 , 同时该浮点指令还指明了相
应的操作是单精度浮点操作还是双精度浮点操作。DLX 的浮点操作包括有:加、减、
乘、除。后缀 D 代表双精度浮点操作 , 而后缀 F 代表单精度浮点操作 (如 ADDD,
ADDF, SUBD, SUBF , MULTD, MULTF , DIVD, DIVF)。值得提出的是 , DLX 的浮
点比较操作将设置浮点状态寄存器中的位 , 如果比较结果为真 , 则将该位设置为 1;
如果比较结果为假 , 则将该位设置为 0。浮点分支指令 BFPT 和 BFTF 则测试该寄
存器的值以决定分支是否成功。
另外 , 操作 MOVF 将一个单精度浮点寄存器的内容拷贝至另一个单精度浮点寄
存器; MOVD 则将一个双精度浮点寄存器的内容拷贝至另一个双精度浮点寄存器;
MOVFP2I 和 MOVI2FP 操作则是在一个浮点寄存器和通用寄存器之间移动数据。
如果要将一个双精度浮点数移入两个通用寄存器则需要两条指令。另外 , DLX 还提
供了在 32 位浮点寄存器中进行整数乘除操作的指令。
表 2 .16 列出了 DLX 的所有指令及其含义。表中 SP 表示单精度 , DP 表示双精
度。

98

99
表 2 .16
DLX 指令列表

2. 5. 2 DLX 指令集结构效能分析
综上所述 , DLX 指令集结构的指令格式、寻址方式和操作都非常简单。这些特
性看起来可能会使目标代码中指令条数增多 , 导致程序运算时间加长 , 从而使这种指
令集结构的机器性能不会太高 , 但实际情况并非如此。第一章的 CPU 性能公式提
示 , 程序的执行时间并不仅仅是一个指令条数的函数 , 它还与每条指令所需的平均时
钟周期数以及时钟周期这两个因素密切相关 , 因此不能从指令条数来考虑指令集结
构的性能。
那么 , 为了观察指令条数的减少能否被 CPI 以及时钟周期长度的增加所抵消 ,
需要把 DLX 与一个复杂的系统结构比较一下 , 这里选择出现于 20 世纪 70 年代中期
的 VAX 指令集结构作为参考结构。之所以选择 VAX , 是因为 VAX 的设计思想和
DLX 的设计思想截然不同 , VAX 中提供了多种指令格式、大量的寻址方式 , 所有的
寻址方式均可以适用于各种类型的指令操作 , 并且指令的操作也比较复杂。
VAX 采用这种设计思想的重要目标之一是希望尽可能地缩短目标代码 , 减少存
储空间的浪费 , 这和当时的时代背景是一致的。在 20 世纪 70 年代 中期 , 在设计
VAX 的时候 , 占主导地位的思想是创建一种与编程语言相近的指令集 , 从而简化编
译器。另一种盛行的设计思想是使代码的长度最小化。大家知道 , DRAM 的容量每
3 年提高 4 倍 , 因此 70 年代中期的 DRAM 芯片的容量只有当今 DRAM 芯片容量的
1/ 1000 , 所以对代码空间的要求非常严格。
VAX 机器的设计者后来对 VAX 和类 DLX 型计算机进行了一次定量的比较 ,
因为它们有可比的结构。他们选择了 VAX8700 和 MIPS M2000。VAX 与 MIPS 的
不同目标导致了它们完全不同的系统结构。VAX 的目标是简化编译器和减少执行
代码的长度 , 因此它有很强的寻址模式、很强的指令、高效的指令编码以及较少的寄

101
存器。MIPS 的目标是通过流水线获得高性能 , 易于用硬件实现 , 以及与高度优化编
译器的兼容性。这些目标导致了简单的指令、简单的寻址模式、固定长度的指令格式
和大量的寄存器。图 2 .18 是这两种机器运行 SPEC89 基准程序测试结果的比较 , 它
表明了两种机器执行的指令条数的比值、CPI 的比值和以时钟周期为单位的性能比
值。
因为 VAX8700 和 MIPS M2000 的组织结构类似 , 所以假设它们的时钟周期时
间一样。MIPS M2000 执行的指令数大约为 VAX8700 的 2 倍 , 而 VAX8700 的 CPI
将近是 MIPS M2000 的 6 倍 , 所以 MIPS M2000 在性能上将近是 VAX8700 的 3 倍。
另外 , 由于 MIPS 结构十分简单 , 所以实现 MIPS 的 CPU 比实现 VAX 的 CPU 所需
要的硬件要少得多。
也正是由于这种性能价格比上的差异使得过去研制 VAX 机器的公司现在已抛
弃了 VAX 指令集结构 , 而采用了和 DLX 类似的指令集结构
。
图 2 .18 VAX8700 和 MIPS M2000 的比较结果
