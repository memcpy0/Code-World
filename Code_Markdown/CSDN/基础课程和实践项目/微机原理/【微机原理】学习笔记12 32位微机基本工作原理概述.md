@[toc]


本章内容：
- `80486` 各部件的**功能和相互关系**，`Pentium` 在体系结构上的**新特点**。
- 32位CPU的**寄存器**以及和16位CPU的**区别**。
- 在保护模式下**中断和异常**。
- 在实模式、保护模式和虚拟8086模式下**存储管理**。
- **任务设置**，任务转换过程及检查的内容。
- `80486` 和 `Pentium` **高速缓存**的结构和功能。
- `80486` 和 `Pentium` **引脚**的功能及差别。
- `80486` 和 `Pentium` **主要总线周期**时序、总线状态变化及区别。
# 12.1  内部结构
## 12.1.1  `80486`的内部结构
<img src="https://img-blog.csdnimg.cn/20200603020045768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="70%">

各部分介绍：
`BIU` 总线接口部件：与芯片总线、指令预取部件、`Cache`部件相连，执行总线访问请求。
-   读：预取指令、读内存、`Cache`行填充
 -  写：写M和I/O、`Cache`通写写内存；写缓冲	(4×32b)。

指令预取：总线空闲时产生存储器地址，向	`Cache` 或通过`BIU`向内存取16B代码，命中`Cache`放入32B的指令队列中产生预取周期。跳转、中断、调子程时清空预取队列。`80486` 总是预取不执行的分支，如果预取错误，就会产生严重的性能损失。

指令译码：从指令预取队列取机器码**转换成控制信号**。两步译码：
① 指令执行时要访存，产生总线、周期、取存储器操作数。			   
② 指令译码由机器码产生对其它处理部件的控制信号。

控制部件：对整数、浮点运算和分段部件控制。

整数部件：`9` 个 `32` 位 `REG` 、`1` 个 `64` 位桶形移位器、ALU 。1T内完成整数传送、加减运算和逻辑操作。

分段和分页部件：进行**存储器保护**和**虚存管理**。
- 在8086/8086时代，存在的是逻辑地址(程序中使用的是 `段地址:偏移地址` )和物理地址；
- 80386之后，为了适应现代操作系统的**段页式内存管理**，Intel x86系列出现了分段分页部件。其中，程序中使用的地址称为逻辑地址——仍然是由段地址和偏移地址组成，随后经过分段（累加、错位等）转换成线性地址——这个线性地址，对应于操作系统课程中的“逻辑地址”。“逻辑地址”经过地址映射形成物理地址。
<img src="https://img-blog.csdnimg.cn/20200603020139400.png" width="40%">

FPU：增强 `80387` 的浮点运算功能。
<img src="https://img-blog.csdnimg.cn/20200603020155469.png" width="40%">

`Cache`：
- `L1 Cache`：`8KB`  数据和指令`Cache`。
-  `L2 Cache`：`128KB～256KB`
<img src="https://img-blog.csdnimg.cn/20200603020209372.png" width="40%">

## 12.1.2  `Pentium`的内部结构
<img src="https://img-blog.csdnimg.cn/20200603020219538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

### 1. 哈佛结构的`Cache` 
与之对应的、其他类型的结构是冯-诺依曼结构，宏观上来看，目前所有的计算机都是遵循冯-诺依曼结构，只有 `L1 Cache` 使用的是哈佛结构。
- 8KB的指令 `Cache` 和8KB数据 `Cache`
- 各自的TLB
- `Cache` 和 `BIU` 的 `DB` 是 $64$ 位
- 支持**突发式**总线周期和流水线总线周期

### 2. BTB和预取B
从奔腾开始，动态分支预测算法出现了，增强了预取指令的能力，不像 `80486`  总是预取不跳转分支。
 <img src="https://img-blog.csdnimg.cn/20200603020404979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

### 3. 指令译码、控制ROM和CU
<img src="https://img-blog.csdnimg.cn/20200603020418355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

### 4. 超标量体系结构IU
超标量处理机：1T内**同时发射多条指令**，资源重复，**空间并行**，提高指令执行的平均速度。
超流水线处理器：1T内**分时发射多条指令**，时间重迭，**时间并行**，提高指令执行的平均执行速度。

U流水线：地址生成、REG、ALU、数据 `Cache` 接口；**整数或浮点指令**/1T共享。
V流水线：地址生成、REG、ALU、数据 `Cache` 接口；**简单整数**，FXCH/1T。
### 5. 流水线式FPU
组成：控制器、 REGS 、加法器、乘法器、除法器、80位宽通道
速度：8级流水线，每T完成1～2个**浮点运算**，快 `80486` 十倍以上


---

# 12.2  寄存器组
32位环境下，寄存器组有如下变化：
- 通用寄存器从16位**扩展到了32位**。
- 段寄存器**仍为16位**，增加2个：`FS、GS` ； **每个段寄存器都有一个描述符寄存器**。
- 32位的 `EIP` 和 `EFLAGS` 。
- 增加了 `CR、DR、TR`、系统地址寄存器和 `Pentium` 的专用模型寄存器。
## 12.2.1  通用寄存器


<img src="https://img-blog.csdnimg.cn/20200603020600622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

## 12.2.2 段寄存器和描述符寄存器
<img src="https://img-blog.csdnimg.cn/20200603020613642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

## 12.2.3 指令指针
`(E)IP` 保存**下一条**将要执行的指令**相对于段基址的偏移量**。
- `IP` ：16位操作方式：**实地址模式、虚拟8086模式**。
- `EIP` ：32位操作方式：**保护模式**。


## 12.2.4 标志寄存器EFLAGS

32位中 `位1为1` ，`位31～位22、位15、位5、位3为0` 。其它16位分为**状态标志**、**控制标志**（DF）和**系统标志**。
<img src="https://img-blog.csdnimg.cn/20200603020748853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

## 12.2.5 控制寄存器
<img src="https://img-blog.csdnimg.cn/20200603020754650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
 
```clike
MOV CRX，r32;   
MOV r32，CRX
```
### 1. CR0
控制或指示**用于整个系统条件的标志**，低16位为 `MSW` 。
- 0位 `PE` ：保护模式允许
  -  PE＝1   系统**在保护模式**下工作
  -  PE＝0   系统**在实地址模式**工作

- 1位 `MP` ：监视**协处理器**
    - MP＝1并且TS＝1，WAIT指令发生**异常7**：协处理器不可用。即使在程序中使用浮点数指令，执行时发现协处理器不存在。
- 2位 `EM`：**仿真**协处理器（80386用`80486`以上FPU在片内）。
    - 系统**有FPU**：`EM＝0，MP＝1`
    - 系统**无FPU**：`EM＝1，MP＝0`
    - 遇到ESC前缀的FPU指令，发生异常7。异常7程序：**模拟**ESC指令**在无FPU时执行协处理器**。
- 3位 `TS` ：任务转换。
	- 任务切换完成，CPU自动把TS置1。
    - 若 `MP＝1` ，在遇到FPU opcode或Wait指令可正常工作。
    - 任务转换时**未切换FPU的运行状态**，只是在新任务需要FPU时才进行切换。

- 4位 `ET`：协处理器类型（仅对80386）
  - `ET＝1`，FPU为**与80387兼容**的32位FPU。
   - `ET＝0`，FPU为**与80386兼容**的32位FPU。
  - 上电时检测80387的 $\overline{\text{ERROR}}$ 引脚，设置ET。软件设置ET。
- 31位 `PG(Paging Enable)`：**页**管理**使能**
   - `PG＝1` ，分页存储管理：    线性地址 $\to$ 页变换 $\to$ 物理地址。
   - `PG＝0` ，无分页管理：线性地址 $\to$     物理地址。

以下各位对`80486`/`Pentium`有效
 - 5位 `NE` ：数据错误异常控制位
    - `NE＝1` 数字错误引起异常16，实现与80386兼容的数字异常。
   - `NE＝0`               ＝0，忽略数字异常。
              $\overline {\text{IGNNE}}$                ＝1，CPU停止工作，等待由                      			产生的中断模拟8087/80387的               。
- 16位 `WP`：写保护
  -  WP＝1   核心代码不能对用户级页面进行改写。
  -  WP＝0   核心代码能够对用户级只读页进行改写。

- 18位 `AM` ：对齐标志控制位
   - AM＝1 允许对齐检查     CPU对齐检查，非对齐
   - EFLAGS的AC＝1           时，要产生异常17，
   - CPL＝3的MEM操作       对齐检查异常。
- 29位 不通写位 `NW(Not Write-Through)`
    - `NW＝0` ：允许通写，既写`Cache`，又写内存。
    - `NW＝1` ：不许通写，写命中时不修改主存（此时CD＝1，`Cache` 不使能）。
	- 通写是指，要求 `Cache` 命中时，`Cache` 与存储器同时完成写修改，即处理器的写操作贯通 `Cache` ，直达存储器。
- 30位 `CD(Cache Disable)` ：`Cache`不使能。
  - CD＝0，`Cache`使能。
  - CD＝1，`Cache`作废     访问`Cache`未命中，则不填充`Cache`。
                                         访问`Cache`命中，`Cache`仍可工作。
   完全使`Cache`停止工作，要刷新`Cache`。
   CD＝0，NW＝0，`Cache`才能正常工作，产生`Cache`的有效周期。
### 2. CR2 页故障的线性地址(Page Fault Linear Address)
`CR0` 中 `PG＝1` 时 `CR2` 才有效。页不在内存中，**页转换时发生分页错误**，这时CPU**将缺页的线性地址暂时保存在CR2中**。

### 3.  CR3
用来存放页目录表的物理**基地址**，及页级外 `Cache` 使能和写属性。`CR0` 中 `PG＝1` 时 `CR3` 才有效。

位4：页外 `Cache` 不使能 `PCD(Page Cache Disable)` 位，控制使外部页`Cache` 是否工作的引脚PCD。
  -   PCD＝1，对页目录不进行外部高速缓存。
  -   PCD＝0，对页目录进行外部高速缓存。
  -   PCD位驱动CPU－PCD引脚控制外部`Cache`工作。

位3：页通写位 `PWT(Page Write-Through)`。
- `PWT＝1` ，外部 `Cache` 对页目录通写；
- `PWT＝0` ，回写。
- PWT位驱动CPU－PWT引脚控制外部`Cache`工作
位31－位12：当前任务的页目录表基址。

### 4.  CR4 Pentium处理器用
`Pentium` 扩充，位31－位7保留。
- 0位 `VME` ：虚拟8086模式扩充。
   -  VME=1，允许虚拟8086模式扩充，即允许虚拟8086中断，在VM8086下，VME=1，支持VIF。
- 1位  `PVI` ：保护模式虚拟中断。
    - PVI=1，允许保护模式虚拟中断。在保护模式下，VME=1，支持VIF。
- 2位 `TSD` ：禁止RDTSC指令，时间日期标记禁止。
   -  TSD=0，读时间标志计数器指令RDTSC可在任何特权级上执行。
   -  TSD =1，RDTSC仅在CPL=0的程序执行，否则发生异常13，即RDTSC为特权指令。

- 3位 `DE` ：允许调试扩充（Debug Extensions）。
   -   DE=1，允许支持I/O断点，I/O断点有效。
- 4位 `PSE` ：允许页面大小扩充。
    - PSE=1，允许采用4MB、2MB页。
- 5位 `PAE`：允许物理地址扩充。
    - PAE=1，允许采用32位以上物理地址，否则只用232物理地址。
- 6位 `MCE` ：允许机器检查异常。MCE=1，允许机器检查异常功能有效。


## 12.2.6 系统地址寄存器
下面的是这一节的重点，需要深刻理解，前面的虽然杂乱，但是不重要：
- `GDTR(Global Descriptor Table Register)` 全局描述符表寄存器
- `IDTR(Interrupt Descriptor Table Register)` 中断描述符表寄存器
- `TR(Task State Segment Register)` 任务状态段寄存器
- `LDTR(Local Descriptor Table Register)` 局部描述符表寄存器
<img src="https://img-blog.csdnimg.cn/20200603164823548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="45%">
<img src="https://img-blog.csdnimg.cn/20200603165506123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="55%">
 
 在保护模式下，**段寄存器中存放的是段选择子**，实际上是下标，指向 `GDT` 或者 `LDT` 中的中的一个描述符.
 - `List item`

## 12.2.7 调试寄存器DR
CPL=0的代码段MOV DRx，r32    MOV   r32，DRx
1. 断点寄存器：DR0－DR3
    • 每个寄存器存放一个断点的线性地址。
    • 断点的发生条件由DR7分别设定。
2. 调试控制：DR7
    （1）4个断点发生的条件和访问类型。
    （2）I/O断点。
    （3）精确断点。
    （4）GD位：如果置位，追踪下一条指令是否会访问调试寄存器。如果是，产生异常。使能由DR6.BD标志的调试寄存器保护状态。
        GD位进入调试异常处理程序时由CPU清0，这允许
        处理程序任意访问调试寄存器。
3. 调试状态：DR6
    （1）B3～B0：在DR、LEN、R/W中的条件为真，Bi置1，即使断
            点未被G或者L允许，说明断点已经发生，不一定能够进入
            调试异常程序。
    （2）BD：下条指令将读/写调试寄存器，而它们又被Intel在线仿
            真器使用时置1，并发生异常1（一般检测故障）。
    （3）BS：为1表示异常1是由EFLAGS中TF＝1时单步陷阱引起的。
            单步方式是最高优先级的调试异常。当BS＝1时，任何其他
            调试状态位也能被置。
    （4）BT：为1表示因转换到一个TSS中T＝1的任务而发生的异
            常1。DR7中没有允许/不允许这种异常的位。仅受TSS中T位
            使能。
4. DR4和DR5
    当CR4.DE＝0时，`Pentium`用DR4和DR作为
    DR6和DR7的别名寄存器。
    当CR4.DE＝1时，引用DR4和DR5将产生未定义的操作的异常。

## 12.2.8 测试寄存器
TR0：未定义。
TR1：奇偶校验逆寄存器。
TR2：指令`Cache`结束位。
TR3、TR4、TR5：`Cache`数据、状态、控制测试寄存器。
TR6、TR7：TLB命令，数据测试寄存器。

## 12.2.9 `Pentium`模型专用寄存器
控制：可测试性、执行跟踪、性能检测、机器检查错误。
R/W：用MOV指令直接访问其中TR会发生异常6，使用指令 RDMSR和WRMSR。
 
---
# 12.4  工作模式
Intel的**32位微处理器**有三种工作模式：
-	实地址模式
-	保护模式
-	虚拟8086模式。

## 1. 实模式的复位进入
前面学的16位汇编，都是以实模式为前提的：
<img src="https://img-blog.csdnimg.cn/20200603093219168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

寄存器的状态：
<img src="https://img-blog.csdnimg.cn/20200603093237717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

## 2. `Pentium`复位和自测试启动
  （1）`Pentium`的复位方式

<img src="https://img-blog.csdnimg.cn/20200603093252597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

（2）REGS的状态：略。
（3）引脚的状态
<img src="https://img-blog.csdnimg.cn/20200603093315846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
（4）内部自测试
        时间：220
        组成：硬件自测试和微代码自测试
        方法：对`Cache`、TLB和BTB进行两项阵列测试：原码和补码。
        常数ROM测试：使用微代码增加不同常数，检查结果值与存储值是否相等。
        复位结束时，程序从 `FFFFFFF0H` 开始执行，
        段间调用/转移指令时，转到 `000FFFFFH` 以内的地址。
        
## 12.4.2   保护模式
描述符的分类：
<img src="https://img-blog.csdnimg.cn/20200603093402385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
1. 选择符
<img src="https://img-blog.csdnimg.cn/20200603093412940.png" width="40%">

2. 段描述符：数组、把逻辑地址变换成物理地址，定义MEM用法，控制转移，切换任务
<img src="https://img-blog.csdnimg.cn/20200603093416627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">（1）段基址：段起始的32位线性地址
（2）段限长：20位限长与G位共同计算
（3）G：G＝0 限长单位为1B          限长1MB  最大地址000FFFFFH。
              G＝1 限长单位为1P（＝4KB）限长4GB  最大地址 FFFFFFFFH
              表中20位段限长值左移12位（即乘以212或1000H）加FFFH。
（4）D/B
        D 代码段：1   32位操作和寻址；0    16位操作和寻址。
        B 数据段：1   32位数据          ；0    16位数据。
           堆栈段：1   32位堆栈操作，ESP   ；0     16位堆栈操作，SP。
（5）访问权限：
<img src="https://img-blog.csdnimg.cn/20200603093427109.png" width="40%">
P 存在位：P＝1，段在内存中；P＝0，段不在内存中，访问该段引起异常。
DPL：描述符特权级，该段被访问的特权级，从0到3特权级降低。
S 描述符类型： S＝1，代码段，数据段，堆栈段。
                                S＝0，系统控制，TSS、LDT、  门描述符。
E 段可行性：    E＝1，代码段，可执行；E＝0，数据段，不可执行。
 
ED/C和W/R
   数据段：ED    W
   ED：扩展方向  ED＝0 向上  偏移量<=段限长；
                               ED＝1 向下  偏移量>段限长。
   W：可写性      W＝0 不可写；W＝1可写
   代码段：C      R
   C（Confirming）：C＝1 要证实代码段，访问和被访问特
                                                权级不总是相同；
				   C＝0 非证实代码段，访问和被访问特
                                                权级总是相同
A（Accessed）：访问过    A＝1 段被访问过；				A＝0  段未被访问过
3. 系统描述符（与门描述符一起包含在系统控制和描述符中）
    段基址、段限长、G位和段描述符相同
    访问权限字节不都相同
    <img src="https://img-blog.csdnimg.cn/20200603093443172.png" width="40%">
<img src="https://img-blog.csdnimg.cn/20200603093449158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">4. 中断描述符（又称门描述符）
<img src="https://img-blog.csdnimg.cn/20200603093459218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">P 门描述符符的有效性：P＝1，有效；P＝0，无效
DPL：描述符特权级
TYPE：4，6，7 286调用门、中断门、异常门
              C，E，F 32位调用门、中断门、异常门
                5           任务门
字计数：调子时，须从调用程序级堆栈拷贝到子程级堆栈去的参数个数（16/32栈分别指字/双字个数）
选择符和偏移量
对中断、异常、调用门表示服务程序或子程的首址。
对于任务门，偏移量无效，选择符指向任务的TSS描述符。
   TSSD时系统描述符：段线性基址、限长和属性
   段线性基址和限长确定TSS的位置和大小
   中断，异常，调用门中的选择符选中某一个代码段描述符代码段D中的32位线性基 址＋门D中的32位偏移量形成例程或子程的首地址。

5. 描述符表
<img src="https://img-blog.csdnimg.cn/20200603093517305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200603093523549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
6. 保护：特权级保护、存储器保护、OS保护
（1）特权级保护：数据存储、控制转移、指令集的限制，软件之 间实现隔离。
      （最高） PL0         PL1        PL2       PL3 （最低）
                   OS内核  系统服务  OS扩展   App
特权级低的程序                                                       允许向外提取数据    
                                                                                  调用特权级高的过程
 
特权级
		32位微处理器采用4级特权级，操作系统为0级，系统服务为1级，操作系统扩展为2级，用户程序为3级。
   CPL：当前代码段具有的访问特权级，CS中最低2位。	通过描述符转移控制到新代码段时，CPL改变。	CPL＝0的任务能够访问GDT及任务LDT中描述符	对应的数据段。
   DPL：段被访问特权级
            非证实代码段    CPL＝DPL。
            DPL＝0或LDT中描述符，CPL＝0的程序可访问。
            DPL＝3，所有程序都可以访问。

RPL：选择符的特权级，指向同一描述符的选择  	符可有不 同RPL对描述符指向段的访问须	RPL<=DPL
IOPL：CPL>IOPL时，执行I/O敏感执令产生保
             护异常13。
             IN、OUT、INS、OUTS、STI、CLI和 
             LOCK前缀
EPL：有效特权级
         EPL＝MAX（CPL、RPL）
 
特权级检查的原则
   数据段：只允许同级和高级的代码段访问。
   代码段：只允许向同级和更高级别的代码段转移控制。
   堆栈段：其特权级和执行代码段相同，控制转移时随之变化 。
特权级检查的规则 
     a. 读/写数据类段规则
       现行代码段堆栈操作：   CPL＝DPL  
       现行代码段R/W数据段：CPL<=DPL，否则发生异常13。 
   b. 数据类段寄存器装入规则
     装入堆栈段选择符：CPL＝RPL＝DPL，否则发生异常12。
      装入数据类段选择符：EPL<=DPL，否则发生异常13。
   c. 代码段寄存器装入规则
       控制转移——代码段装入——可能引起CPL改变
中断/异常：CPL>=中断/异常处理程序DPL
              异常：异常门的DPL>=CPL
通过门的段间调用：EPL<=调用门的DPL
                                          CPL>=代码段的DPL
任务转换时，转入任务的CPL<=任务门的DPL
       JMP：只能转移到与CPL具有相同级的段
       CALL：使用调用门把控制转移到更高级代码段
       RET：把控制转移到更低级代码段

d. IOPL规则
  IO敏感指令：IN、OUT、INS、OUTS、STI、CLI和LOCK前缀
  CPL<=IOPL
  TSS的I/O位图允许，否则将发生异常13。
e. 特权级指令使用规则
  仅CPL＝0的代码段才能执行如下特权指令，否则发生异常13。
  CLTS、HLT、LGDT、LIDT、LLDT、LMSW、LTR；
  涉及CR、DR、TR的MOV指令，RDMSR、WRMSR
f. 页访问规则
  违反页表项、页目录项规定权限或访问不存在页将发生异常14。

（2）存储器保护
MOV、POP、LDS、LES、LFS、LGS、LSS指令将选择符装入DS、ES、FS、GS、SS；
JMP、CALL、RET、IRET指令进行段间转移、更新CS时
保护检查：段类型、R/W权限、段限长、存在性。
 段类型检查
     代码段选择符     CS
      可写数据段选择符      SS
      可读代码段/数据段选择符      DS、ES、GS、FS
 读写权限检查
            代码段/只读数据段不能写
                 不可读代码段不能读
                 违反读写权限将发生异常13
 段限长检查
   对数据段和代码段，ED＝0，向上扩展，偏移量<=段限长；
   对堆栈段，ED＝1，向下扩展，偏移量>段限长；
   堆栈段越限发生异常12，其它数据段越限发生异常13。
  存在性检查
   将P＝0的段选择符         SS，发生异常12；
   将P＝0的段选择符         其它段REG/中断门/异常门，					         发生异常11；
   访问的段无效（段选择符为全0）时，发生异常13；
   访问的页不在内存时，发生异常14。
   （3）对OS的保护
   子程在要证实代码段，用户程序调用它时，CPL不变化。
         有效保护OS的数据结构。
   子程在非证实代码段，用户通过调用门进入子程时，CPL将提高到非证实代码段的0级。用户程序可以破坏未加保护的OS的数据结构，子程可以防止用户程序对OS的破坏。

   PROC FAR
    MOV EBP，ESP                               EBP＋0处是EIP的值
    MOV AX，WORD PTR[EBP＋4]         ；0级堆栈中断点处CS值取调用者的CPL
    ARPL SELECTOR-PARM，AX             ；CPL与用户传给OS的指针选择符RPL比				较，使指针选择符的RPL为两者特权级低者
    
   用户传给OS的指针中选择符RPL与调用者段选择符中的CPL比较取特权级低者。
（4）保护模式下的转子与返回
  无任务转换时段间调用的转子与返回
  CALL   段值：偏移量
         
 子程的段选择符值     段描述符中C      代码段证实性
子程在证实代码段，调子不改变CPL，段选择符       子程段描述符
子程在非证实代码段，若CPL＝DPL，段选择符       子程段描述符 
                                              若CPL>DPL，段选择符      调用门描述符
 此时要进行系列保护属性检查：调用非证实代码段中更高级子程
序。
<img src="https://img-blog.csdnimg.cn/20200603093622241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
调用门检查
      调用程序 CPL<=调用门DPL。
      调用程序选择符中RPL<=调用门DPL，否则发生异常13。
      调用门中P＝1，否则发生异常11。
      调用门不越限，否则发生异常13。
子程代码段检查，不合法时发生异常13。
      选择符非全0
      描述符不越限
      可执行代码段
      选择符中RPL<=DPL
      子程的首址中新EIP不越限
子程序堆栈段检查
      下列条件都要符合，否则发生异常10。
         选择符非全0；选择符中RPL＝子程代码段DPL；
         堆栈段DPL＝子程代码段DPL；堆栈段为可写数据段。
      下列条件都要符合，否则会发生异常12。
         描述不越限；堆栈段须存在；
         堆栈段地址空间>=参数个数×4＋16B（32位模式）
                                     >=参数个数×4＋8B（16位模式）
       CALL指令的堆栈操作
        从TSS中取具有子程特权级的堆指针         SS：ESP
        
         
压调用程序的： 全0   旧栈SS选择符
                             旧栈ESP值
压调用门中的：  参数1
“字计数”              。。。
                             参数M
压调用程序的： 全0    断点CS选择符
                             断点EIP
从调用门中取子程所在段选择符       CS
                   子程代码段中DPL        CS中CPL
                   子程代码段偏移量       EIP
RET  m中m使参数个数的4倍
<img src="https://img-blog.csdnimg.cn/20200603093642734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
## 12.4.3 虚拟8086模式
1. 虚拟8086模式与实模式的区别
    虚拟8086模式是保护模式，可运行多个OS
     实模式是整个CPU的工作模式，CPU相当快速8086
虚拟8086模式下各段特权级为3，执行特权指令发生异常13；
       LIDT，LGDT，LMSW，CLTS，HLT，INVD，WBINVD，INVLPG及传给CR、TR、
       DR的MOV，RDMSR，WRMSR
都不能使用下列指令，否则发生异常6（非法操作码）
       APRL，LAR，LSL，VERR，VERW，STR，LTR，SLDT，LLST
在虚拟8086模式下，当IOPL<3时，执行I/O敏感指令发生异常13
       CLI，STI，PUSHF，POPF，INT n，IRET，带LOCK的指令
在虚拟8086模式下，IOPL＝3，当I/O位图不允许时，执行I/O指令也发生异常13
       IN，OUT，INS，OUTS
虚拟8086模式下，CR4.TSD＝0不允许执行RDTSC，否则发生异常13

2. 虚拟8086模式与保护模式的区别
（1）VM8086在形成20位线性地址与实模式一样，不需要像保护模式那样使用段描述符的基址和限长及属性
（2）各种描述表中不会有VM8086的段描述符
3. 虚拟8086模式的进入与退出
（1）32位CPU进入虚拟8086模式
        0级代码段：EFLAGS.VM=1的堆栈映像，IRET把栈映像压入EFLAGS和CS:IP。
        任务转换：32位新任务：EFLAGS.VM=1（在高位字b17中）
                        TSS保存的值装入段寄存器：段基址，限长，属性
（2）32位CPU退出虚拟8086模式
        虚拟8086模式下的中断/异常使CPU退出该模式：中断/异常处理程序为0级保护模式代码段，EFLAGS.VM =  0
任务转换
32位新任务：TSS中相应项装入EFLAGS
VM＝0，表明新任务已退出虚拟8086模式
<img src="https://img-blog.csdnimg.cn/20200603093708842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
## 12.4.4 工作模式的转换

1. 实模式        保护模式
建立数据结构和初始化GDTR，IDTR和TR
CR0.PE＝1： MOV  CR0，REG
进入保护模式后：用CPL＝0的程序重装段寄存器
2. 保护模式          实模式
      CR0.PE＝0：MOV CR0，REG
保护模式下的分页转移过程
    使线性地址、GDT，IDT映射到实模式；CR0.PG＝0；CR3＝0，
    清洗TLB
设CS段限长为64KB，使GDT，IDT在1MB内
选择符装入SS、DS、ES、FS、GS时，段基址任意，描述符
    中限长＝64KB    G＝0，E＝0，W＝1，P＝1
CLI屏蔽INTR，外部屏蔽NMI
CR0.PE＝0
远程JMP跳转到实模式
LIDT指令装实模式下中断向量表的基址和限长
STI开中断
实模式下的代码装段寄存器

---
# 12.5  中断与异常
在程序正常执行过程中，为了处理外部事件和报告错误或异常状态而中止现行程序的运行，将CPU的控制权转向处理程序，待处理完以后再继续执行被中断程序的过程称为中断。
32位微处理器的中断分为两大类：中断	（Interrupt)和					 异常(Exception).

## 12.5.1 中断与异常的类型

中断：由外部设备引起的异步事件（外中断、硬 中断）
          INTR：受TF影响（STI/CLI），由PIC接入
          NMI：不受TF影响，处理器设有防止NMI的机制，
                   NMI服务程序由2号中断描述符确定
异常：指令执行期间，处理机响应检测的某种状态的同步事件（内中断、软中断）
Trap：出现异常的指令后边界检测，出现异常立即报告，返回执行下条指令。像INT n、INTO，单步.
Fault：出现异常的指令前边界检测，异常处理后的返回地址是引起异常指令，可以重启动。
Abort：出现异常的指令无须精确定位，无法重启动，例如：将控制转移到0号、10号、12号或13号异常时又发生一个异常， 为双异常；硬件错。
 
## 12.5.2 32位CPU的中断与异常
0  Divide Error 除法错异常
    DIV or IDIV指令的除法为0，Fault 商太大使目标寄存器容纳不下。
     入 栈是指令的段值和指针，0号中断是除法指令的一部分。

1  Debug Exceptions 调试异常  排错异常
Fault：DR中的断点与代码段中指令地址一致时发生的调试异常。
Trap：单步执行
              数据断点，I/O断点，任务转换断点引起调试Trap。
2  NMI
    非屏蔽中断，响应时直接转入INT 2处理程序，不受IF影响。
3 INT3  Breakpoint Instruction Trap 单字节断点指令
    断点指令的操作码是单字节。
     调试程序装断点：一条指令的第一个操作码字节置换成断点指令的操作码（CCH）。 程序执行到断点处，INT3的执行调用异常处理程序，返回地址应是指向INT3指令后的指令的第一个字节，但处理程序应该在返回时，把原被CCH置换出去的断点 处指令的第一个操作码字节再置换回来，以便断点处的指令能够执行。
     INT3的作用： • 16位处理器中用于设置指令断点；
                                  32位CPU用调试寄存器设置指令断点。
                               • 调用其它异常处理程序。
                               • 设置比调试寄存器允许的更多的断点。
                               • 置于开发程序的源代码中。


4  INTO  Overflow   Trap  溢出中断   溢出陷阱
 <img src="https://img-blog.csdnimg.cn/20200603101842671.png" width="40%">

5  Bounds  Check    Fault  边界检查故障
    执行Bound指令的处理器发现操作数超越指令的界限
     Bound  r16,m16&16        Bound  r32,m32&32
     IF （LeftSRC<[RightSRC] OR LeftSRC>[RightSRC+OperandSize/8]）
     Then Interrupt 5 

6  Invalid  Opcode   Fault  检测指令流中的错误
     检测时间：虽预取了一个非法操作码，不异常，到执行部件才引起异常。
7 Device Not Available     Fault  协处理器不可用故障

 无FPU：CR0.EM=1  or  CR0.TS=1,ESC 协处理器仿真，80386和`80486` SX用模拟在没有FPU的情况下执行协处理器指令（有些软件需要）。
     有FPU：CR0.MP=1  and  CR0.TS=1,ESC、WAIT 设置协处理器运行现场只是在新任务需要FPU时才切换FPU的运行现场。
8 Double Fault                Abort 双故障
在指令预取时遇到了一个段或页故障，当处理器试图把控制转移到处理程序时又发生了故障，导致双故障。
双故障处理程序推到堆栈上的错误码为0。
引起双故障的指令不能再启动，指令的重新启动不支持双故障。
异常8处理程序调用时又遇到一个异常，CPU进入Shutdown模式类似于要执行HLT的状态。
用NMI（保护模式）或RESET（实模式）退出（CPU执行NMI处理程序时发生了 Shutdown）。
双异常：系统表（描述符表，页表）发生了严重问题。
      系统一个段或页故障时，又检测到一个段故障，或者系统一个页故障时，又检测到一个段或页故障，都会引起双故障。系统一个段故障时又检测到一个页故障，这是页故障而不是双故障。
9  Coprocessor Segment Overrun   Trap  协处理器越限异常
在传送80387 FPU操作数的中间部分时80386检测到页或段的违反。
 `80486`/`Pentium`不会发生异常9，对协处理器段超越限将引起异常13。

10 Invalid TSS                             Fault  非法TSS故障
 任务转换向一个有非法TSS的段（即发生除段不存在以外的段异常时）。
 非法TSS状态涉及到TSS段，LDT段，堆栈段，数据段和码段。
 为了确保处理异常的TSS是可采用的，非法TSS异常处理程序必须是一个使用任务门调用的任务。错误码中EXT位表示使用一个任务门的外部中断试图将一个任务转向一个无效的TSS。
 当无效故障发生装入故障处理程序时，压入栈中的CS及EIP值指向引起此故障的指令；而与该故障作为任务切换的一部分发生时，则指向任务切换的第一条指令。
TSS 段 ：TSS段限长小于103B
LDT段： 无效LDT或LDT不存在
堆栈段： 选择符超出描述符表的限长
           堆栈段是不可写的
           描述符的DPL与CPL不相等（兼容）
           选择符的RPL与CPL不相等（兼容）
代码段： 选择符超出描述符表的限长
           代码段是不可执行的
           非证实代码段：DPL＝CPL
           证实代码段：DPL>CPL
数据段 ： 选择符超出描述符表的限长
                  数据段不可读
11 Segment Not Present 段不存在异常 Fault    有错误码
（1）CPU检测到描述符中P＝0
在试图装入CS、DS、ES、FS、GS时，P＝0，Fault       异常11。
                  装入SS时P＝0，引起堆栈Fault        异常12。
在用LLDT装入LDTR时P＝0，Fault        异常11。
          任务转换时装入LDTR时P＝0，引起非法TSS异常       异常10，
使用了一个段不存在的门描述符。
（2）本Fault是可以重启动的
        段不存在异常发生进入故障处理程序时，压入栈的CS、EIP是引起故障的指令，或当该故障作为任务切换时的一部分发生时，指向任务切换的第一条指令。
与段相关错误代码

<img src="https://img-blog.csdnimg.cn/20200603101935397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
12 Stack Exception   堆栈异常   Fault     有错误码
（1）涉及SS任何操作的限长违反
        • POP、PUSH、ENTER、LEAVE
        • 显式、隐式使用SS的存储器操作
（2）P＝0的描述符在装载SS时检测到
        • 任务转换
        • 调用不同特权级的CALL指令
        • 返回不同特权级的返回指令
        • 装入SS的MOV、POP
（3）堆栈异常的指令是可以重启动的
        • 引起异常的指令
        • 在任务转换时由于装入不存在的堆栈级描述符引起的堆栈异常，处理后启动的指令是新任务的第一条指令。
13 General Protection  一般保护异常Fault
所有没有引起其它异常的保护违反引起一般保护异常
使用CS、DS、ES、FS、GS时段越限长
涉及描述符表的段越限：
      • 控制转移到一个不可执行的段
      • 写只读的码段或数据段
      • 读只执行的码段
      • 用涉及只读段的选择符装SS
      • 用涉及系统段的选择符装SS
      • 用涉及系统段的选择符装DS、ES、FS、GS
      • 用涉及执行码段的选择符装数据段寄存器DS、ES、FS、GS
      • 用涉及可执行码段的选择符装SS
      • 用空选择符（全0）的DS、ES、FS、GS访问存储器  
 • 切换到一个忙的任务
 • 违反特权规则
 • 指令长度超过15B，有太多的前缀加在指令前面
 • 用PG＝1和PE＝0装入CR0
 • 从VM8086通过中断门或异常门的中断或异常的处理程序的特权级不是0。
 • 企图把1写进CR4的保留位
 • 实方式下，内存操作数地址超越段内限制时，产生异常13，但无错误码压栈。
 * 关于错误码
     全0错误码：异常8，17
     无错误码：异常0，1，2，3，4，5，6，7
     存在错误码：异常10，11，12，13
14 Page Fault;取指，访存；Fault 页故障。
	有特殊格式的错误码
（1）CR0.PG=1,在线性地址转换成物理地址时CPU检测下列状态
       • 地址转换所需的页目录项或页表项中P＝0，指示页表或包含
         操作数的页不在物理存储器
        • 程序没有足够的特权访问指向的页
        • 用不适当的访问类型访问一内存页
（2）页级保护违反引起异常，这时
        • 页目录项中访问位A＝1
        • 页表项中访问位A＝1时是没有页级保护违反
        
• 页故障错误码在堆栈上

 
<img src="https://img-blog.csdnimg.cn/2020060310200089.png" width="40%">
  P＝0，页Fault由页不在内存引起，P＝1，页故障是由页级保护违反引起
      W/R＝0，Fault由R操作，W/R＝1，Fault由W操作
      U/S＝0，CPU在SuperVisor（0，1，2级），U/S＝1，CPU在用户级

（3）用32位线性地址装入CR2引起异常
        异常处理程序能用此地址定位相应的页目录项和页表项，在页故障处理程 
        序执行时发生了另一个页故障，处理程序将把CR2的内容推向堆栈。
（4）页故障是可以重新启动的异常，一旦引起页故障的原因在处理程序中被排除，即可由IRET返回，重新执行产生过故障的指令。

16 Floating－Point Error
 CR0.NE=1，非屏蔽数的浮点异常将产生异常16。在执行下一条非控制的的浮点
       指令或WAIT指令。
CR0.NE=0           $\overline {\text{IGNNE}}$              ＝1
                                 CPU在执行下一条非控制浮点指令或WAIT指令前冻结系统外
                                 部中断（由响应        引起的）带出不管NE值，非屏蔽的数值
                                 异常而引起        ＝0这时外部中断能够调用异常处理程序。
                                              ＝0，CPU将忽略数字异常。
数字异常处理的基本步骤
        a.存FPU环境：控制、状态和标记字，操作数和指令指针。
        b.清状态字中的异常位。
        c.如果是由于INTR、NMI、SMI异常屏蔽了中断时使能它。
        d.由存在环境中的状态和控制字检查标识异常。
        e.为纠正（rectify）异常进行一些依赖系统的活动。
        f.返回被中断的程序继续正常执行。
17 Alignment Check    Fault
（1）访问非对齐的操作数产生对齐检查故障
        • 地址能被2整除的数据类型：字、选择符、32位段指针。
        • 地址能被4整除的数据类型：双字、短实数、48位段指针、32位Flat指针、
          48位伪描述符（描述符表基寄存器内容的MEM映像）。
        • 地址能被8整除的数据类型：长实数、TEMPREAL	。
        • 地址能被4或2（取决于操作数的尺度）的数据类型。
          FSTENV/FLDENV    save area
          FSAVE/FRSTOR      save area
（2）对齐检查的条件：CR0.AM=1；EFLAGS.AC=1；CPL＝3
        存储器引用（references）约定在CPL＝0，为段描述符装入不会产生对齐检查Fault，即使是在用户模式下引起的存储器引用。
        
18 Machine Check    Fault
`Pentium`处理器的模型专用寄存器产生的异常。
CPUID：当EAX＝1时，执行后，EDX（7）        机器检查异常处理。
当CR4.MCE=1,系统可执行机器检查异常处理。
 `Pentium`中$\overline {\text{PEN}}$       输入，当 $\overline {\text{PEN}}$        <0，通知CPU发生了读数据检验错；
        或 $\overline {\text{BUSCHK}}$            输入，当         $\overline {\text{BUSCHK}}$  <0，通知CPU发生了总线周期错。
        当前总线周期地址           MSR－00H：MCA 机器检查地址R
        当前总线周期类型           MSR－01H：MCT 机器检查类型R
 
<img src="https://img-blog.csdnimg.cn/2020060310214836.png" width="40%">
 数据锁存到MCT：CHK＝1，读MCT：CHK＝0
 用RDMSR读MCA和MCT   EDX：EAX        MSR[ECX]
        MOV ECX,Imm;   Imm代表寄存器编号，如00H，01H
        RDMSR


## 12.5.3中断和异常的处理过程
1、中断检测和响应
（1）外部中断请求在指令后边界检测。
（2）Trap异常也在指令后边界检测。
（3）Fault异常在指令前边界检测。

2、中断处理和服务
实地址模式下的中断如图：
<img src="https://img-blog.csdnimg.cn/20200603102212355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">实模式下中断向量表
1.中断向量
对应中断类型号的中断服务程序入口地址。
每个中断向量占4字节。
2.中断向量表
位于内存地址0000 : 0000开始的1KB范围内。
按中断类型号顺序存放中断向量。
3.中断向量指针
指向存放中断向量地址第一字节的指针。
中断向量指针=中断类型号×4。
软件中断中自由中断的中断向量需用户自己装入。

## 12.5.5 保护模式下的中断和异常
1、中断的处理
（1）通过中断门和异常门的中断处理
<img src="https://img-blog.csdnimg.cn/20200603102339823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
（2）中断/异常后的堆栈结构
<img src="https://img-blog.csdnimg.cn/20200603102353659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
（3）通过任务门的中断处理
<img src="https://img-blog.csdnimg.cn/2020060310240571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
优点：中断任务和被中断任务完全隔离。
缺点：中断响应过程耗时长。
2、特权级保护
通过中断门或异常门的转移控制，目标代码段DPL<=现行代码段CPL。
通过任务门的中断不对目标代码段的特权级进行检查。
对INT N和INTO指令产生的中断：门的DPL>=现行代码段CPL。
对于外部中断和异常，不进行门的特权级的检查。

## 12.5.6 虚拟8086模式下的中断和异常
（1）要求中断和异常处理程序必须具有0级特权级。
（2）保存现场时压入堆栈的内容增多，按32位操作来保存现场。
（3）将EFLAGS寄存器内容压栈后将17位清0。
（4）执行IRET时，检测CPL的特权级。

## 12.5.4 实模式下的中断和异常
	
32位微处理器运行在实地址下，可以响应和处理异常0、1、3、4、5、6、7、8、9、12、13、16。

# 12.6  存储管理
三种工作模式下如何完成存储管理？
## 12.6.1 实模式存储管理
1. 物理地址的形成
           
<img src="https://img-blog.csdnimg.cn/20200603092459116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">2. 段式存储管理
    CR0.PG=0：页部件不工作，线性地址即物理地址。
    段值×16           相应描述符的段基址（Base19～0）
    段限长：64KB，P＝1，G＝0，ED＝0
    代码段：CPL＝0，R＝1，C＝0
    其他段：DPL＝0，W＝1，数据段：ED＝0，
                                                             FFFF
  0000H≤偏移量 ≤ 限长  段基址      0000    

## 12.6.2 保护模式存储管理
CR0.PE=1，CPU处于保护模式。
存储器的保护机制。
分段机制不同，引入虚存概念。
1. 段式存储管理
   （1）地址空间变换
       虚拟（逻辑）存储空间：214×232＝246＝64TB
            实模式：216×24＋216＝220＋216
   （2）虚拟地址到线性地址的变换

        <img src="https://img-blog.csdnimg.cn/20200603092626478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
2. 页式存储管理
CR0.PG＝1，页部件自动将线性地址转换成物理地址
段长可变：0～4GB
页长固定：CR4.PSE=1，页4MB；
			   CR4.PSE＝0，页4KB
物理地址：CR4.PAE=1，超过32位
（1）页变换原理
<img src="https://img-blog.csdnimg.cn/20200603092655938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
   • CR3（页目录基址）＋线性地址高10位（页目录号）×4
                                   页目录项低位地址；得到页表基址
    • 页表基址＋线性地址中10位（页号）×4
                                   页表项低位地址；得到页基址
     • 页基址＋线性地址低12位（偏移量）
                                   页内单元的偏移地址
  页变换：线性地址高20位的线性页号变换为物理页号
                             页内的偏移量不变换。
（2）页目录项和页表项
<img src="https://img-blog.csdnimg.cn/2020060309273582.png" width="40%">
• P 存在： P＝1，页目录项/页表项在内存中；
                  P＝0则表示其不在内存中 。
• R/W 读/写： R/W＝1，页目录项/页表项可读、写、执行；
                          R/W＝0，页目录项/页表项可读、执行。
• U/S 用户/监控： U/S＝1，页的用户级——段的PL3。
                                U/S＝0，页的监控级——段的PL0，PL1，
                                                                             PL2 。

• PWT 页通写（外部`Cache`）：PWT＝1，当前页通写；
                                                   PWT＝0，当前页回写。
• PCD为页`Cache`禁止位。PCD＝l表示禁止片上`Cache`；PCD＝0表示允许片上`Cache`工作。
• A 访问性：A＝1，页表项/页中内容被访问。
                  A＝0，页表项/页中内容未被访问。
• D 页修改位：D＝1，页被修改过。
 （二级页表） D＝0，页未被修改过。
• AVAIL 保留附加信息 （对应页表或页）。
（3）转换后援缓冲器TLB
     •  TLB是页部件中的相联存储器。
     •  CPU近期访问过的32个页的有关信息：
          线性页号、物理页号、D、A、U/S、R/W、P。
     •  线性页号在TLB中，找出物理页号，快速完成转换，有效 线性页号不在TLB中，查页目录表、页表、页方式访问内存，注意P、A、R/W属性将其线性页号、物理页号、属性 调入TLB。
    •  当TLB满时，按LRU算法调出最近最少使用的页信息及调入刚访问的页。
    •  程序局部性和数据的簇聚性可使CPU访问TLB的命中率在 98％以上。
<img src="https://img-blog.csdnimg.cn/20200603092753186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">•  线性地址高17位当作TAG，在同一组号的4项中按内容相联查找；
  若命中，找出其20位物理页号拼接线性地址低12位形成物理地
  址，表TLB中有符合的项，但权限及页目录项/页表项中P＝0，
  产生异常14。
           产生异常的线性地址            CR2
           错误代码             异常14处理程序的堆栈中
• 关键程序和数据常驻内存，使页请求虚拟存储系统能正常工作，如：
页目录表。
IDT、GDT、TSS及0级堆栈及其页表。
页Fault处理程序代码和数据及其页表。
<img src="https://img-blog.csdnimg.cn/20200603092806237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
## 12.6.3 虚拟8086模式存储管理
1. 段式管理
    与实模式下存储管理相同：段基址=段R值×16，Limit=FFFFH，DPL=3，P=1，代码段C=0，E=1，R 数据段：ED=0，R=1，W
2. 页式管理
    （1）多个VM8086任务的1MB线性地址空间映射到物理空间的不同区域
   （2）VM8086地址偏移量超过1MB时，可仿真实现8086地址回绕
   （3）页请求虚拟存储系统和调页Fault（异常14）在虚拟空间的内存和外存之间实现页的调度
   （4）多个VM8086任务共享8086 OS或ROM代码
   （5）由存储器映射I/O编址的设备，其端口地址可对应不同线性地址

---
# 12.7  多任务与多处理

## 12.7.1 任务状态段TSS
   需要重存一个任务的处理器状态信息被存于一种叫做TSS的段类型
1. 动态域：每个任务转换时处理器更新
通用寄存器（EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI）
 段寄存器（ES、CS、SS、DS、FS、GS）
 标志寄存器（EFLAGS）
指令指针（EIP）
 老任务TSS选择符（仅当返回执行时更新） 
      在TSS＋01～02H：Link与NT＝1配合返回调用/被中断程序
2. 静态域：处理器可以读，但不改变；这些域在任务建立时设置
任务的LDT的选择符
 CR3寄存器（DDBR：页目录基址寄存器）
 特权级0、1、2堆栈的逻辑地址
       SS0：ESP0    SS1：ESP1     SS2：ESP2
 调试陷阱位T
      当T＝1（偏移量64H的0位），在任务转换发生时，在新任务第一条指令执行前，处理器将发生一个调试异常，使软件在任务之间根据需要有效地共享调试寄存器
     
 I/O允许位图基址
        基址指向I/O位图开始处。
        CPL<=IOPL 允许访问所有I/O端口。
        CPL>IOPL   I/O位图对应位为0的端口，否则产生异常13。
 位图偏移量：位图首地址，TSSD的Limit限制长度，最后全1字节，在限长内。
 关于分页
   避免页边界放在TSS内，如果页边界放在TSS内，那么边界的每一个边都要同时在TSS内。
   当分页使用时，老任务的TSS、新任务的TSS和描述符表项都应该被标记为存在和可读/写，处理器开始读TSS后再收到一个页故障或一般保护异常将是一个不可恢复的错误。




## 12.7.2 TSS D、Task G、TR
1. TSSD

<img src="https://img-blog.csdnimg.cn/20200603021323111.png" width="40%">


忙的任务是现行运行或等待运行的任务
     驻留在GDT中
2. Task G
<img src="https://img-blog.csdnimg.cn/20200603021331615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">（1）DPL控制对任务转换的门描述符的访问
           当一个过程的CPL和选择符RPL数值小于等于TSS D的DPL时，这个过程不需要选择门描述符来实现任务转换。这防止低优先级的过程引起一个任务转换。
         当任务门被用时，目标TSS D的DPL不用。CPL，RPL只和门DPL比较。
（2）Task G和TSS D满足多项要求
  一个任务仅有一个忙位，忙位存在TSS D中，每个任务都只有一个TSS D。
  任务门能够在LDT中：门的DPL与TSS D中 DPL不同，没有足够的特权使用GDT中TSS D（DPL＝0）的过程能够访问LDT中的任务门，用任务门，OS能够限制任务转换到特殊的任务。
  任务门在IDT中：当中断或异常的向量指向IDT中的任务门时，中断或异常能够引起任务转换。
  多个任务门可以指向同一个任务。
  任务门中指向TSS D的选择符其RPL不用，门中偏移量也不用。
  任务门可以在GDT、LDT和IDT中，但TSS D只能在GDT中，TSS可以定 位在内存中任何位置 。
3. TR 
<img src="https://img-blog.csdnimg.cn/20200603021406230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">（1）LTR
     • 16位段选择符装入TR的可见部分，指向GDT中的TSS D。
     • 48位的段基址和段限长从TSS D中装入TR不可见部分——			段`Cache`。
     • 特权指令，仅在CPL＝0程序中执行。
     • 用于系统初始化时给TR赋初值，以后由引起任务转换的时
       间改变其中的内容。
（2）STR
      • TR中的可见部分存入存储器或通用寄存器。
      • 非特权指令，可以在任何特权级程序中运行。


## 12.7.3 任务转换
1. 任务转换的启动
    • 段间JMP或CALL指令操作数选择符直接选择GDT中TSS D
    • 段间JMP或CALL指令操作数选择符通过Task G选择符指向 
      GDT中TSS D。
    • 中断或异常指向IDT中的任务门，Task G选择GDT中TSSD。
      注意：索引IDT中的中断门或陷阱门不会发生任务转换。
    • 当EFLAGS.NT＝1时现行任务执行IRET/IRETD指令。返回任务的选择符在现行任务的TSS的Link字段中（Old TSS Selector）。

2. 任务转换的过程

   检查现行任务允许转换到新任务。数据访问特权规则应用到JMP、CALL。
     CALL、JMP：现行CPL，选择符RPL<=DPL of TSS D
                                现行CPL、门选择符RPL<=DPL of Task G
     新任务：TSS D中P＝1，Limit>＝67H，B＝0（即Type＝9）。
  存现行任务的状态TSS中：EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI、ES、CS、SS、DS、FS、GS、EFLAGS、EIP（引起任务转换指令的下一条指令）。
现行TSS的基址由TR的不可见部分TSS D在段`Cache`中映象指出。
现行任务的TSS D的选择符在TR中。
 新任务TSS D的选择符装入TR可见以及不可见部分（选择符指向的描述符装`Cache`）。
      选择符是JMP or CALL的操作数或Task G中选择符。
      新任务：B＝1，CR0.TS=1
 从TSS装入新任务的状体，新任务开始执行LDTR，CR3（PDBR），EFLAGS，EIP，EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI，ES，CS，SS，DS，GS，GS。
   老任务TSS D的选择符在新任务TSS的Link当中，NT＝1。
Check Made During a Task Switch

<img src="https://img-blog.csdnimg.cn/20200603021442754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200603021503528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
## 12.7.4 32位CPU的多处理
`Cache`一致性（`Cache` Consistency）
通信可靠性

1. 总线锁定
            MOV  AL,1                ;AL＝1
Tryagain: XCHG AL,Semaphore  ;(1)Temp     AL=1,AL     Semaphore=0  M1 
                                                         (2)Semaphore         Temp=1                  M2
              TEST AL,AL               ;AL=0
              JNZ  Tryagain            ;进入共享资源
                …
              MOV Semaphore,0

<img src="https://img-blog.csdnimg.cn/20200603021538332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">32位CPU接口特性的加锁措施
 • CPU引脚上输出 $\overline {\text{LOCK}}$         低电平
 • Lock前缀使指令执行时输出低电平 $\overline {\text{LOCK}}$       
 • 某些存储器操作时，CPU自动发生 $\overline {\text{LOCK}}$       

2. Lock前缀
   目标操作数是存储器的写指令前加Lock，否则是非法操作码。
    • 位测试与设置：BTS、BTR、BTC。
    • 交换指令：XCHG（32位CPU除外）、XADD、CMPXCHG、CMPXCHG8B。
    • INC、DEC、NOT和NEG。
    • ADD、ADC、SOB、SBB、AND、OR、XOR。

3. 自动锁定
• 中断响应：连续两个中断响应周期锁定以便PIC传送中断类型码。
• TSSD中B位置1：测试和设置TSS描述符期间。
• 修改段描述符：装入段描述符时，如果A=0，则A     1，
       P＝0，标识段不在内存中，锁定总线。
       修改其它属性或地址、限长，不锁定总线。
       P＝1，标识段是有效和在内存。
• 修改页目录项和页表项：A     1，D     1，锁定总线。
• 无论XCHG是否加前缀Lock，只要目标操作数是存储器。
   均锁定总线，为XCHG REG，MEM
   不锁定总线，为XCHG REG，REG
4. 伪锁定：`80486`CPU的 $\overline {\text{PLOCK}}$        ：CPU访问64位操作数或搜索64位指令。
   关于指令XCHG（Exchange Register/Memory With Register）
     XCHG AX,REG16                 ;       XCHG REG16,AX
     XCHG EAX,REG32               ;       XCHG REG32,EAX  
     XCHG REG/MEM8,REG8       ;       XCHG REG8,REG/MEM8
     XCHG REG/MEM16,REG16   ;        XCHG REG16,REG/MEM16
     XCHG REG/MEM32,REG32   ;        XCHG REG32, REG/MEM32



---
# 12.8  高速缓存
<img src="https://img-blog.csdnimg.cn/20200603020958281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
## 12.8.1 `Cache`工作原理
相联存储器，TAG命中与未命中，未命中需要总线周期访存。
`Cache`行：相联存储器中的存储块。
     • `80486`的L1`Cache`为16B一行。
    • `Pentium`的L1`Cache`为32B一行。
    • L2`Cache`更多的字节。
    • 不支持局部充满的`Cache`行，单位是行，不是字，双字。
    • `Cache`行仅映射内存中对齐于16B或32B的块，其起始地址应设计成低4位/低5位为全0。
    • `Cache`填充：从内存中调16B或32B块到`Cache`中。

`Cache`写操作：软件是页表中PWT位；硬件是WB/ $\overline {\text{WT}}$     。
     • 通写Write-through：写`Cache`和写内存。
     • 回写Write-back：只写`Cache`，不立即写到内存，它们在`Cache`中累计起来。
      当回写操作执行时，修改的`Cache`行是在后来才写向内存的。
写回内存的触发机制 ：
     a. `Cache`行需要重新分配：如新`Cache`行在一个已经是充满的`Cache`中分配。
     b. 维持`Cache`一致性时也要触发写回主存。

`Cache`行需要重新分配时，要用LRU算法进行Line调出调入处理。
## 12.8.2 `80486`内部`Cache`结构
<img src="https://img-blog.csdnimg.cn/20200603021049791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
## 12.8.3 `80486`内部`Cache`操作
![ ](https://img-blog.csdnimg.cn/20200603021118319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
## 12.8.4 `80486`页级`Cache`管理
<img src="https://img-blog.csdnimg.cn/20200603021133669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
## 12.8.5 `Pentium`的`Cache`
1、一个8KB的数据`Cache`和一个8KB的指令`Cache`。
2、每个`Cache`有2路128组,每个`Cache`行有32个字节。
3、`Cache`按回写和通写相结合的方式工作。回写方式，在`Cache`的标签域附有一更新位。
4、多CPU结构中，为保持一致性，采用MESI一致性协议。
               M状态：修改状态；
               E状态：互斥状态；
               S状态：共享状态；
               I状态：无效状态。
MESI `Cache` Line States
<img src="https://img-blog.csdnimg.cn/20200603021154879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200603021209107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

---
# 12.9  引脚和功能
## 12.9.1  `80486`的引脚和功能
<img src="https://img-blog.csdnimg.cn/20200603020910529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
## 12.9.2  `Pentium`引脚与功能
<img src="https://img-blog.csdnimg.cn/20200603020929335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

---
# 12.10  总线周期
## 12.10.1  `80486`的总线周期
1. 不可高速缓存非突发单周期
（1）特点：R/W都含2个时钟周期T1、T2，基本2－2周期。
（2）时序
 $\overline {\text{ADS}}$           ：T1                ，定义总线周期信号和地址有效。
                A31－A2、 $\overline {\text{BE 3}}$   -  $\overline {\text{BE 0}}$     ${\text{M/}\overline {\text{IO}}}$     $\text{D}/\overline {\text{C}}$    $\text{W}/\overline {\text{R}}$   
 $\overline {\text{RDY}}$                 ：外系统在T2输入有效：R/W数据有效，非突发周期CPU在T2结束时采样：
                      =0,定义的总线周期完成。
 $\overline {\text{BLAST}}$                 ：CPU在总线传输的最后一个周期， T2输出有效，单周期的每个传送完成。
 $\overline {\text{PCHK}}$                 ：CPU在准备终止一个读周期后输出低电平，前一个时钟周期结束时采样数
                据的奇偶状态。
 $\overline {\text{DATA}}$                 ： T2完成数据的R/W。
（3）插入等待状态
        CPU在T2结束时，采样   $\overline {\text{RDY}}$          =1，插入一个T2 ，再采样  $\overline {\text{RDY}}$            =1，再T2 。R/W需要3个时钟周期T1 、 T2 、 T2 ，基本3－3周期。


基本的2-2周期
<img src="https://img-blog.csdnimg.cn/20200603102738200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">2. 不可高速缓存非突发多周期
（1）特点
        由        控制的多个单周期序列。
（2）时序
        每个周期由输出      =0开始，到输入       =0结束。
                 ：传输中第一个周期的T2采样          =1         多周期传输。
        CPU使         =0         多周期传输的最后一个周期，由下一个       =0结束传输。
               ：外系统在输入        =0前一个T，输入       =1，非突发周期。
        DATA： T2结束时，      =0，R/W数据。
（3）应用
        64位浮点装入、128位指令预取。
不可高速缓存的非突发多周期
<img src="https://img-blog.csdnimg.cn/20200603102751649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
3.不可高速缓存的突发周期
    特点
     •  $\overline {\text{KEN}}$      =1：不可高速缓存。
     •   $\overline {\text{BRDY}}$         取代$\overline {\text{RDY}}$         的作用，$\overline {\text{RDY}}$         =1：突发周期（外系统输入）。
     •   $\overline {\text{BLAST}}$         =1（CF的T2）指示多周期，  $\overline {\text{RLAST}}$       =0（CL的T2）结束多周期。
     •  $\overline {\text{ADS}}$        仅在CF的T1有效，后继地址将由外部硬件产生。
     • 仅CF有T1，其它只有T2，每个T2读入数据。

不可高速缓存的突发周期

<img src="https://img-blog.csdnimg.cn/20200603102919643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
4.可高速缓存的非突发周期
（1）特点
        `Cache`行填充的非突发多周期。
（2）时序
     •       ： CF T1和CL T1时       =0，读4个双字写入`Cache`行。
     •       ：每T1有效，非突发周期。
     •       ：每T2有效，读取数据。
     •        ： CFT2无效          CLT2有效，多周期。
     
可高速缓存的非突发周期
<img src="https://img-blog.csdnimg.cn/20200603102935597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">5.可高速缓存的突发周期
（1）特点
        `Cache`行填充的突发多周期。
（2）时序
     •        ：CF T1时和CL T2前       =0，突发式读4个双字写入`Cache`行。
     •        ：代替      （总为1），每个T2有效，读取数据。
     •       ：仅CF T1有效，输入第一个地址。
     •        ：CFT2无效          CLT2有效，多周期。
     •       ：前一个T时采样数据的奇偶状态。
<img src="https://img-blog.csdnimg.cn/20200603102945799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">6.可高速缓存的慢突发周期
（1）特点
        在可高速缓存的突发周期中插入等待状态。
        CF：T1、T2，其它C可有2个T2。
（2）时序
               /        ：T2时为0输入数据，T2时为1，插入一个T2。
                                 等如同可高速缓存突发周期。
<img src="https://img-blog.csdnimg.cn/20200603102956874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">7.被中断的可高速缓存的突发周期
（1）特点
        外系统在任何时候输入       =0可中断突发周期，同时传输一个数据。
        CPU输出       =0，启动另一总线周期继续完成`Cache`行填充。
（2）时序
               ：每个C的T1开始有效。
               ：      =0中断突发周期及传输一个数据。
               ：       =0，传输数据，        =0时结束传输。
               ：CFT1及CL最后一个数据读入之前       =0。
                ：      =0                =1，传输未完成，         =0的         结束传输。        
<img src="https://img-blog.csdnimg.cn/20200603103008194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">8. 8位和16位周期
    特点：      /         有效前，      /        =0使CPU进行8/16位传输。
                   、       同时有效忽略        进行8位传输（每周期） 。  
            可用于突发或非突发周期R/W。
                      ：CFT2时无效，多周期；CLT2为低，结束总线周期。  

9.锁定周期
    特点：1）Lock前缀、存储器操作数的某些指令、段或页表项的修改、中断
                   响应等为锁定周期。        =0，禁止其它总线主控设备占用系统
                   总线。
              2）CPU占用外部总线直到读－改－写周期完成。
   <img src="https://img-blog.csdnimg.cn/20200603103021725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
10. 伪锁周期
     特点：1）操作数传输的多个周期期间禁止其它主控设备获取总线。
                     控制权：64位浮点数R/W
                                  64位描述符的装入
                                  `Cache`行填充
                2）伪锁定周期由           指示，存储器操作数必须对齐。
                3）突发读时不需要检查          ：对齐的64位操作能在一个突发周
                     期完成。
                4）突发写时需要检查          ，`80486`不能突发写多于32位，但突发
                     写能够用于BS8/BS16的每一个32位的写周期，一个64位的写将
                     由2个非突发总线周期完成。
11. 总线保持周期
（1）特点
        当外系统HOLD               CPU          HLDA响应总线请求
        现行总线周期结束：        完成传输
        立即让出系统总线，发出HLDA响应总线请求
        CPU进入总线保持周期，插入Ti
（2）时序
        总线保持期间浮空的三态线
        A31－A2、
        D31－D0、DP3－DP0
<img src="https://img-blog.csdnimg.cn/20200603103034851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">12. 行无效周期
（1）特点
        行无效周期用于保持CPU内部`Cache`内容与外部存储器一致，486包含一种基址监视其它设备对内存的写，当发现一个对外部存储器的写，其地址也
        包含在内部`Cache`中，则要让内部`Cache`行无效。
（2）时序
        AHOLD：AHLOD=1，输入，CPU浮空AB，      仍可在DB上传送一个总线
        周期的数据。
                 ：          =0，输入，AB上地址有效，寻址`Cache`行，找到则使其它
        数据无效。
13.中断周期
（1）特点
        • `80486`在当前指令周期完成后可响应INTR中断请求。
        • 连续两个中断周期：每个中断周期由T1，T2和4个Ti组成。
        • 第1个周期       =0忽略数据总线上信号，第2个周期从D7－D0上输入8位向量。
        • 整个中断响应期间          =0，不响应总线请求。
（2）时序
        • 每个中断响应周期由       或         结束，如果两者都无效，则可加入等
          待状态。
        • CPU自动加入         信号。
<img src="https://img-blog.csdnimg.cn/20200603103052824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">14. 重启周期
（1）特点
        `80486`的总线周期能被其它总线主控设备申请占用，执行总线任务后重启原来的总线周期：      有效，驱动地址和状态线。
（2）时序
                 ：（Backoff) 
        • CPU在每个T采样        ，可以在T1，T2，T1b响应，中止总线周期。
        •          =0，CPU在下一时钟周期Tb立即悬空三态线，返回CPU的任何数据忽略但不输出HLDA信号。
        •          级别高于        /        。
        • 存储器可把          看成          ：现行传送中最后一个周期。
        •          =0使突发周期，8位，16位等多周期中读时钟返回数据无效，但
          此之前返回的数据有效。
          重启读周期

<img src="https://img-blog.csdnimg.cn/20200603103103225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%"><img src="https://img-blog.csdnimg.cn/20200603103126587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

## 12.10.2  `Pentium`的总线周期
数据传送周期 Data Transfer Cycle
             =0时进出`Pentium`的多至8B宽度的数据传送 。
总线周期 Bs Cycle
     从        =0驱动地址和状态开始，到最后的        =0输入到CPU结束可以有124个数据传递。
突发周期 Burst Cycle
     具有4个数据传递的总线周期，突发周期数据项的地址都恰在同一32B对齐区域 通过        实现。突发序列只给出第一个地址，后续传递的地址应该由外部硬件计算。不是每个传输都再驱动。    
总线操作 Bus Operation
     实现特指功能的一系列总线周期。
1. Non-Pipelined Read and Write (With Wait States)非流水线式读写总线周期

（1）特点：单传递、不可高速缓存、非流水线式、带或不带等待状态，64位的数据传递周期。
（2）时序：       ：OUT，每C的T1有效，指明总线上地址和状态信号可用。
                         ：IN，每C的T2有效时，数据总线上的R/W数据可用。
                                   每C的T2无效时，总线周期插入一个或多个等待的T2。
                  DP：奇偶校验信息，同DATA双向
                         ：OUT，        =0后2个时钟          被驱动到读数据奇偶检测
                            的结果。
                       =1，         =1，非流水线式不可高速缓存的单传送周期。

<img src="https://img-blog.csdnimg.cn/2020060310314677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">2. Burst Read/Write Cycle代码读/数据读突发式行填充、突发式回写。
（1）Burst Read Cycle
                ：
                ：第一个         =0时，输入        =0，表明是多传递`Cache`行填充
                   1个周期仅采样一次以确定可高速缓存性。
                ：
                ：每个        后2个时钟周期输入奇偶检测的状态。
                ：         =0时，采样数据。
                            =1时，插入1个T2等待。
                        突发式读总线周期

<img src="https://img-blog.csdnimg.cn/2020060310320394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
（2）Burst Write Cycle突发式写总线周期

  突发写周期忽略
                   =0          突发回写周期，突发写周期总是回写在数据`Cache`中的修改行。
        回写周期的几个起因：
        a.替换一个在数据`Cache`中修改过的行需要回写。
        b.一个询问周期命中了数据`Cache`中修改过的行需要回写。
        c.一个内部窥探命中了数据`Cache`中一个修改过的行激发回写。
        d.输入引脚          被外部驱动为有效引起回写。
        e.执行WBINVD指令引起回写。
        仅能被`Pentium`突发的写周期是回写周期，其它所有的写周期都是<=64b的单传送总线周期，对于回写周期，第一个突发地址的低5位总是在0开始，因此突发地址的顺序是0、8H、10H、18H，突发传送第一个地址的后继地址必须是外部系统计算，因为`Pentium`不为每个传送驱动地址和字节允许信号。
<img src="https://img-blog.csdnimg.cn/20200603103217962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
3. Pipelined Read/Write Cycle 流水式背对背突发读总线周期

    特点：  • 输入      ，`Pentium`形成流水线式总线周期
               • 下一个总线周期地址在前一个总线周期的数据传递时产生
               • 单传送周期和突发多周期均可以是流水线式的
（1）Pipelined Back-to-Back Burst Read Cycles
        •          ：IN，指示`Pentium`在现行周期完成前可驱动另一个周期       或         先有效的变为0，同时采用           和WB/
        •          ：输入，`Cache` ability
        •WB/    ：输入，`Cache` Policy           
        •      =0后2个时钟周期另一个总线周期（pending cycle）被驱动通知CPU把一个总线周期的地址放在AB上，同时         =0
        • P117 F2.61：Two Pipelined `Cache` Line Fills
<img src="https://img-blog.csdnimg.cn/20200603103235772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">（2） Pipelined Back-to-Back Read/Write Cycles流水式背对背突发读写总线周期

 特点：• 写周期能流水进读周期，读周期能流水进写周期.
                   • 一个过渡的时钟(dead clock)插在读写周期之间，允许总线
                    状态 的翻转 。
                   • 图示（F2.62)第一周期为缓存式突发读多周期
                                        第二周期为非缓存非突发写单周期
                     
<img src="https://img-blog.csdnimg.cn/20200603103254142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
`Pentium`初始的总线周期
*:在M/    =0或PCD=1时
               信号无关紧要

<img src="https://img-blog.csdnimg.cn/20200603103313364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">`Pentium`特殊总线周期译码
 <img src="https://img-blog.csdnimg.cn/20200603103340694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">
 CPU片内总线请求Request Pending定义
<img src="https://img-blog.csdnimg.cn/20200603103353707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">



简述32位x86 CPU在分页的保护模式下将DS段的某个逻辑地址转换为物理地址的过程。
答：
首先需要经过分段：
① 从段寄存器 `DS` 中取出段选择子的值，如果段选择子中的 `TI = 0`，则到全局描述符表 `GDT` 中找相应段的段描述符，否则到 `LDT` 表中寻找段描述符。然后根据 `Index` 的值，可以从 `LDT` 表或者 `GDT` 表中得到某一个段描述符，由段描述符可以得到该段的32位**段基地址**(线性基地址)和**段限长**。

② 偏移地址则由立即数或者几个寄存器的值构成，这些值经过加法器形成偏移地址。

③ 随后，**偏移地址**经过加法器**与段描述符中给出的段基地址相加**，**得到线性地址**；同时，通过一个减法器与段的界限进行比较，检查是否越界。

得到 $32$ 位线性地址后，当 $CR_0$ 的 `PG` 字段设为1时，允许分页，则通过页转换机制把线性地址转换为物理地址；如果 `PG = 0`，则禁止分页，线性地址就是物理地址。
① 线性地址的高 $10$ 位是页目录的索引号，指向 $2^{10} = 1024$ 个**页目录项**中的某一项，其中每一项都有 $32$ 位，高 $20$ 位指向页表基地址，低 $12$ 位为其属性。
线性地址的中间 $10$ 位作为页表的索引，指向 $2^{10} = 1024$ 个**页表项**中的某一项，其中每一项的内容都是 $32$ 位，高 $20$ 位用来形成物理地址的高 $20$ 位，低 $12$ 位为其属性；
线性地址的低 $12$ 位作为页面的偏移地址，即物理地址的低 $12$ 位。

② 先查询 $CR_3$，得到指示的**页目录的基地址**；

③ 取线性地址中的高 $10$ 位，作为**页目录索引号**，由于每个目录项占据 $4$ 个字节，所以要将索引号左移 $2$ 位，得到页目录项的偏移地址。此后得到某一个页目录项的物理地址，其中页目录项内容的高 $20$ 位是页表的基地址的高 $20$ 位。

④ 再根据线性地址中间 $10$ 位 左移 $2$ 位得到**页表索引号**，联同页表的基地址，可以得到某一个页表项的物理地址，其中页表项内容的高 $20$ 位是物理地址的高 $20$ 位，即页帧。

③ 线性地址的低 $12$ 位是物理地址的低 $12$ 位，加上页帧，最终形成物理地址。
