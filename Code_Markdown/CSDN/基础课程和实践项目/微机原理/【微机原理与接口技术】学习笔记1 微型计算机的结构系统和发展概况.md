@[toc]

# 一、数的表示方法
## 1.1 进位计数制（略）
学过了，跳过。
## 1.2 进制编码（略）
这些都学过了，跳过。

---
## 1.3 带符号数的表示方法
### 1.3.1 符号表示法
做法：无论多少位，最高位做**符号位**。是最早最容易想到的做法。

例：对于长度 $8$ 位的数（ $D_7$～$D_0$ ），用 $D_7$ 位作符号位，$D_7=1$ 表示负数，$D_7=0$ 表示正数。如：`0101 1101B = +93`，`1101 1101B = −93`
对于长度 $16$ 位的数（ $D_{15}$～$D_0$），$D_{15}=1$ 表示负数，$D_{15}=0$ 表示正数。

带符号位的数称为机器数，它表示的**实际数值**称为机器数的**真值**。

### 1.3.2 原码、反码和补码
#### (1) 原码
正数的符号位用 $0$ 表示，负数符号位用 $1$ 表示，其余位为数值，这种表示方法称为**原码**。就是上面的符号表示法。例：  
-  `X=+105`，`[X]原=0110 1001B`；
- `X=−105`，`[X]原=1110 1001B`

原码简单易懂，**与真值换算很方便**。若要进行两个异号数相加，或两个同号数相减的运算，就要做减法操作。一般的计算机中没有减法运算部件，减法运算也要用加法部件实现，因此**要引进反码和补码**。


#### (1) 反码
正数的反码与原码相同。例：
- `[+4]反=0000 0100B`；
- `[+31]反=0001 1111B`；
- `[+127]反=0111 1111B`  (最大值) 

负数的反码为**它的正数原码**按位取反。
- `[−4]反 = 1111 1011B`
- `[−31]反 = 1110 0000B`
- `[−127]反 = 1000 0000B`  (最小值)

`8` 位二进制数的反码范围为 `−127～+127` 。
 
带符号数用反码表示时，**最高位为符号位**，当它为正数时，后 `7` 位为真正的值；**它为负数时，后7位要取反后才能得到真正的值**。比如说， `[X]反=1001 0100B，[X]真值=−[110 1011]= −107` 。
	       


#### (3) 补码
正数的**补码同原码**；负数的**补码为其反码加1**，即为**它的正数原码按位取反再加1**。例： 
- `[+4]原=0000 0100B = [+4]反 = [+4]补`
- `[−4]原=1000 0100B`
   ` [−4]反=1111 1011B`     （正数 `4` 按位取反；或者 `[-4]原` 后七位按位取反）
   `[−4]补=1111 1100B`     （反码+1）
- `[+127]原=0111 1111B = [+127]反 = [+127]补`
   `[−127]原=1111 1111B`
   `[−127]反=1000 0000B`
  `[−127]补=1000 0001B`
- `[−128]补=1000 0000B`

**补码**可看成“带符号位的数”，符号位也参加运算。**要减去一个数，只要加上其补码**。我们有 `[A+B]补=[A]补+[B]补` 和 `[A-B]补=[A]补+[-B]补` 。如，要做减法 `7−19` ，可用 `7+[−19]补`来完成。
-	`[7]补 = 0000 0111B;    [+19]补 = 0001 0011B`    
- `[−19]补 = 1110 1101B`	
	```cpp
	    0000 0111B   	    -------- [7]补
	+	1110 1101B   	    -------- [−19]补   
	 	1111 0100B = F4H	-------- 和的补码
	```
-	和的补码 = `F4H = 1111 0100B`
	和的反码 = `F3H = 1111 0011B`
	和的原码 = `1000 1100B`，其真值为 `-12`
- 可见，`7 +（−19）=  −12`，答案正确。



## 1.4 实数的表示（略）
见计算机组成原理。

---
# 二、计算机的基本结构
## 2.1 计算机的基本结构（略）
跳过。
## 2.2 计算机软件
跳过。
### 2.2.1 指令和程序
下面是一些概念：
- 指令—用**命令形式表示**让计算机执行的各种**操作**。
- 指令集 — 一台计算机所能**识别和执行**的**全部命令**称为该机器的**指令集**（<b><font color="#0000FF">Instruction Set</font></b>）或指令系统。
- 不同计算机有不同的指令系统，包含的指令数也不一样。
- 程序—让计算机求解一个数学问题或者完成一项复杂工作前，要把解决问题的过程分解为若干步骤，并用**指令序列**来表示，以便控制计算机完成这项任务，这样的指令序列就叫程序(<b><font color="#0000FF">Program</font></b>)。

### 2.2.2 指令的组成和机器码
计算机只认得二进制，因此**指令都用二进制表示**，称为机器码（<b><font color="#0000FF">Machine Code</font></b>）。

指令由**操作码**（<b><font color="#0000FF">Opecode</font></b>）和操作数（<b><font color="#0000FF">Operand</font></b>）组成，**操作码说明**计算机执行什么**操作**，**操作数**指出参加操作的**数的本身**或**操作数所在的地址**。这样看来，指令很像语法中的动宾结构。

例如，在 `8086 CPU` 中，把数字 `1200H` 取到累加器 `AX` 中去的指令的机器码为：
 <img src="https://img-blog.csdnimg.cn/20200516082719947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
操作码 `B8H` ，规定了要从**后面两个字节单元**中**取出**一个 $2$ 字节数（ `1200H` ），送到累加器 `AX` 中的操作。

需要记住的是，这里的数据存放——<b><font color="#FF0000">低字节放在前面，高字节放在后面</font></b>，或者说，大多数计算机系统中，<b><font color="#FF0000">低位字节放在低地址，高位字节放在高地址</font></b>。

初期，就是用指令的机器码直接来编制程序的，处于机器语言阶段。机器码是一连串的0和1组成的代码，输入计算机时，由纸带穿孔机在纸带上凿孔，有孔表示 $1$ ，无孔表示 $0$ 。这种代码不好理解和记忆，还很容易出错，所以最开始，编程是一件极其繁杂而困难的工作。

### 2.2.3 汇编语言Assemble Language
汇编语言用**助记符**（<b><font color="#0000FF">Mnemonic</font></b>）代替**二进制的机器码**，用**指令功能的英文缩写**代替**操作码**，用符号代替地址，**用寄存器存放地址**等，用汇编语言程序编程比机器语言方便。

例如，对于8086：
- 数据传送指令用助记符 `MOV`（Move）
- 加法指令用 `ADD`（Addition）
-  跳转指令用 `JMP`（Jump）
-  用 `RESULT` 、`SUM` 等符号来表示存储单元地址

将 `1200H` 送到累加器 `AX` 中去的指令为：`MOV  AX，1200H`。

例：编写求解 `2+3=5` 的汇编语言程序，要求将和存入 `SUM` 单元。程序如下：
```
MOV   	AX, 2     ;累加器AX←2
ADD   	AX, 3     ;AX←AX+3
MOV 	SUM, AX   ;结果单元SUM←和数5
```
计算机只认识由0、1组成的机器码。因此，**汇编语言程序**必须**翻译**(用 `MASM` )成机器码表示的**目标程序**（<b><font color="#0000FF">Object Program</font></b>），才能**被计算机识别和执行**。能让计算机自动完成翻译工作的程序称为汇编程序（<b><font color="#0000FF">Assembler</font></b>）。

汇编语言程序比机器语言程序进了一大步，但是其本质仍然是助记符，和机器语言一一对应，因此**汇编语言程序语句很多，编程工作很繁琐**。这是它的不足之处。而且，**汇编语言的针对性很强**，在某种机器上编写的汇编语言程序，不能直接在别的机器上运行，无法跨平台，程序员必须十分熟悉CPU的指令系统，于是，各种高级语言应运而生。
 
## 2.3 高级语言（略）
## 2.4 操作系统（略）

---
# 三、微型计算机结构和系统
微型计算机与冯·诺依曼结构计算机无本质区别。主要不同在于：`CPU` 采用**集成化的微处理器**，**各部件通过总线相连**，**所有外设都应通过I/O接口电路才能连到 `CPU`**。微型计算机基本结构框图：
<img src="https://img-blog.csdnimg.cn/20200516083102713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
虽然上图不是放之四海而皆准，架构不完全一样（还有哈佛结构），但是我们可以看出，**CPU可以直接访问内存存储器，访问IO接口，而且我们的CPU不可以直接访问IO设备**。这是我们需要知道的，而且是我们课程的核心内容。


## 3.1 微处理器（略）
## 3.2 存储器
存储器用来存放数据和指令，其内容以二进制表示。**每个单元**可存 $8$ 位( $1$ 字节)二进制信息。即一个存储器单元为一个字节。

为了正确存取内存单元，需要为每个单元编1个存储器地址(<b><font color="#0000FF">Memory Address</font></b>)。地址是**不带符号整数**，从 $0$ 开始，顺序加 $1$ ，到最大值后又回 $0$。

例如，`CPU` 有 $16$ 根地址线 $A_{15}$～$A_0$ ，可表示的地址范围为 $2^{16}=65536$ 个单元，地址编号为 $0$～$65535$ 或 `0000～FFFFH` （最后的 `H` 表示是十六进制的 ）

$1$ 个存储单元中存放的信息称为**该存储单元的内容**。例如，下图中，地址 `0003H` 单元中存放内容为 `3CH` ，记作：`(0003H）= 3CH`。同理 `(1200H)= 8FH` 。
 <img src="https://img-blog.csdnimg.cn/20200516083157767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="20%">
从上图中，还有如下例子：
- 从 `0000H` 单元**开始存放**的 $3$ 个字节数据依次为 `B8H`、`02H`和`00H`；
- `1200H` 开始存放**字数据** `A28FH`，`(1200H)`字 `=A28FH`；
- `1202` 开始存放的**字数据**为 `1234H`，(1202H)字=1234H
- 如果是32位机，1200H单元开始存放的双字数据为1234  A28FH

地址与内容的关系：
- $16$ 位机，**数据以字(Word，W)为单位**，用**两个字节单元存放一个字**，并规定：<b><font color="#0000FF">低位字节在前，高为字节在后</font></b>。而且，<b><font color="#FF0001">整个数据的地址为最低字节的地址</font></b>。极少数系统中，字数据也会按高字节在前、低字节在后的规则存放； 
- $32$ 位机中，$32$ 位数应以 $4$ **字节**或**双字**来表示。



## 3.3 输入输出设备和接口电路
### 3.3.1 I/O设备
一些概念：
- 输入—将原始数据和程序传送到计算机。
- **输入设备**：键盘、鼠标、扫描仪、CD-ROM、数码相机。
- 输出—将计算机处理好的数据以各种形式（数字、字母、文字、图形、图像和声音等）送到外部。
- **输出设备**：激光打印机、显示终端、七段发光二极管显示器、液晶显示器、扬声器。
- 磁盘和磁带，**既可看成存储设备，也可当成I/O设备**。

### 3.3.2 接口电路（Interface）
**I/O设备种类繁多**，其速度、信号电平与主机不一致，**要通过接口电路连到计算机**。**接口电路是主机和外设间的桥梁**，提供数据缓冲驱动、信号电平转换、信息转换、地址译码、定时控制等各种功能。声卡和显卡都是接口电路。

各厂商都有与自己CPU**配套的外设接口芯片**，例如，后面将分别学习的 `Intel` **可编程接口芯片**：
- `8255A` 通用并行I/O接口
- `8253/8254` 计数器/定时器
- `8259A` 中断控制器
- `8251A` 串行通信接口
- `8237A DMA` 控制器

目前，它们已被集成到 $32$ 位、$64$ 位 `CPU` 的配套芯片中，其**功能、控制方法和地址等均向前兼容**。

### 3.3.3 总线
从**CPU和各I/O接口芯片**的内部各功能电路的连接，到**计算机系统内部**的各部件间的数据传送和通信，乃至计算机主板与适配器卡的连接，以及计算机与外部设备间的连接，都要通过总线（<b><font color="#0000FF">Bus</font></b>）来实现。

总线标准，是设计计算机部件、I/O设备甚至计算机软件的依据。
按总线中传送的信息分为：地址总线，数据总线，控制总线，还有电源和地。
- 地址总线（<b><font color="#0000FF">Address Bus</font></b>）：用于传送地址信息，是**单向总线**，**总从CPU指向存储器或I/O**。CPU通过地址总线对存储器或I/O端口寻址。
	<b><font color="#FF0001">**地址总线数目**决定了CPU能**直接寻址的范围**</font></b>。
	- `8` 位CPU，如 `8080` ，有 `16` 根地址线 `A15～A0` ，可直接寻址的范围为 $2^{16}=65536$ 字节单元，即 `64KB` ；
    - `16` 位CPU如 `8086/8088` ，有 `20` 根地址线 `A19～A0` ，最大可寻址 $2^{20}=1048576$ 字节单元，即 `1MB` ；
    - `80286` 有 `24` 根地址线，可直接寻址 $2^{24}=16MB$ ；
	- `80386` 有 `32` 根地址线，可寻址 $2^{32}=4GB$ ；
	- `Pentium` 以上CPU有 `36` 根地址线，寻址范围高达 $2^{36}=64GB$ 。
- 数据总线（<b><font color="#0000FF">Data Bus</font></b>）：用于传送数据信号的总线，是**双向总线**，CPU既可以通过它**从存储单元或I/O端口读取数据**，也可**将数据传送到存储单元或I/O端口**。
<b><font color="#FF0001">数据总线的多少决定了一台计算机的字长</font></b>。`16` 位机一次可**并行传送16位数据**，`32` 位机则可传送32位数据。
	- `8086` 和 `8088` 都是16位CPU。但8088内部有16根数据线，**外部只有8根**，故称它为准16位CPU。 
	- 以 `80386、80486` 及 `Pentium` 等为CPU的微型计算机都是 `32` 位机。
	- 现在的主流微型机是64位机。

- 控制总线（<b><font color="#0000FF">Control Bus</font></b>）：是CPU对存储器、外围芯片和I/O接口的**控制**以及它们对CPU的**应答、请求等信号**组成的总线。例如：
	- CPU要从存储器或I/O端口读出数据时，就要向外部发读（ $\overline {RD}$ ）信号。
	- CPU想向外部写入数据，则要发写（ $\overline {WR}$ ）信号。
	- 控制存储器和外设的信号  $M/\overline {IO}$ ，**访问存储器时**该信号为高电平，**访问I/O端口时**则为低电平。


  


