@[toc]



**当一个进程需要操作系统的帮助时，它可以通过系统调用让内核来替它完成一些工作**。我们已经熟悉了系统调用的工作机制，并且已经实现了不止一个系统调用。接下来，用户进程将会有更多事情依赖于内核。

比如实现一个文件系统，读写硬盘的工作要求助于内核。可以逐渐地增加系统调用；但也可以采用另一种方案：将这些工作剥离出来，交给一些系统进程来完成，让内核只负责它必须负责的工作，比如进程调度。**这种将内核工作简单化的思想，便是微内核；而所有工作通过系统调用扔给内核态的做法，被称为宏内核。**


基于宏内核的操作系统中，完成具体任务时，用户进程通过系统调用让内核来做事；基于微内核的操作系统中，这个过程复杂一些。在完成具体任务时，内核的角色像中介。比如实现文件系统：
- 用户进程 `P` 读取一个文件，首先通过内核告诉进程 `FS` ，然后 `FS` 再通过内核告诉驱动程序（也是一个独立的进程），驱动程序读取硬盘，返回结果。
- 这样一来，一项工作的完成变得曲折，需要多个进程协同工作。于是，进程间通信也就至关重要。

到如今，我们要用 `Orange's` 来管理磁盘、磁盘上的文件以及内存等，这些都要向应用程序提供接口。到了决定用微内核还是宏内核的时候了。我们先找两个具体的例子来看看它们分别是怎么回事。

---
# 8.1 微内核还是宏内核
我们一直借鉴的Minix和每天在用的Linux，就是微内核和宏内核的典型例子。Minix是微内核的，Linux则是宏内核的。`Tanenbaum` 和 `Linus` 还留下了一段微内核与宏内核的经典论述，其中 `Andy(Andrew S. Tanenbaum)` 说：
- 老的操作系统都是宏内核的，即整个操作系统是一个运行在核心态的单独的 `a.out` 文件，这个二进制文件包含**进程管理、内存管理、文件系统以及其他**。实例包括 `UNIX、 MS-DOS、VMS、MVS、OS/360、MULTICS` 等。
- 在微内核系统中，操作系统的大部分都运行在单独的进程，而且多数在内核之外，它们之间通过消息传递来通信。**内核的任务是处理消息传递、中断处理、底层的进程管理**，**以及可能的I/O**。其他事情都交给内核之外单独的进程来完成。实例有 `RC4000、Amoeba、Chorus、Mach、Windows/NT` 。

**在实际设计操作系统的领域中，争论早已结束，微内核取得了胜利。** 对于宏内核来说，可能存在的争论焦点在于效率，但是事实证明，微内核可以像宏内核一样快。

下面实地勘查一下，两种内核是什么样子的。以系统调用作为突破口，看看它们的代码。
## 8.1.1 Linux的系统调用
简单起见，先拿 `Linux 0.01` 作为Linux方代表——最新的Linux内核代码量太大，不利于短时间内弄懂。其中的系统调用不止一个，以 `fork( )` 为例来分析一下。具体代码可以在 `Linux 0.01` 的 `init/main.c, include/unistd.h, kernel/sched.c, include/linux/sys.h, kernel/system_call.s` 这些文件夹中找到，直接看程序的流程图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200724181957854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
从图8.1中可以看出，调用 `fork( )` 实际上调用了中断 `0x80` ，通过事先初始化好的IDT，程序转移到 `_system_call` ，最终通过一个函数指针数组 `sys_call_table[ ]` 转化成了调用 `sys_fork( )` 。这个过程和我们实现过的系统调用是很相似的，此处不再多说。

## 8.1.2 Minix的系统调用
Linux的 `fork` 系统调用很容易理解，但Minix的刚开始甚至可能让人感到迷惑。打开Minix代码文件 `src/kernel/proc.c` ，看函数 `sys_call( )` 的开头：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200724182644416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

开头这段注释非常重要：在Minix 中，不像Linux那样有许许多多的系统调用（`sys_call_table[ ]` 中列出的有几十个），而仅有**发送和接收消息的系统调用**。通过 `sys_call` 的参数 `function` 的注释可以知道，系统调用的种类总共有三个，那就是 `SEND, RECEIVE, BOTH` 。

Minix怎样通过三个系统调用就实现与**以Linux为代表的宏内核OS**一样多的功能呢？以 `fork( )` 为例看一下Minix是怎么做的，Minix的机制显得有点复杂，直接来看图8.2：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200724183619326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)




跟图8.1所示的Linux不同，这里多出来一个内存管理器（MM），fork( )所要做的工作是由它来负责的（如果是另外的系统调用，那么具体工作可能就不是由MM 来负责，比如系统调用read( )就是由FS来负责的，跟MM 类似，FS是单独运行的另一个进程），那么MM是如何得到用户进程的通知的呢？正是消息机制在进程之间起到了重要作用，它类似于邮政系统，在信封（或包裹单）上写明目的地，消息就送达了。图中使用了三种箭头，实线（）表示消息的发送过程，点线（）表示消息的获取过程，虚线（）表示发送和接收消息都会经历的过程。用户进程对fork( )的调用将最终转化成调用内核态的函数sys_call( )（位于src/kernel/proc.c中），消息（即图中的m）的地址这时已经作为参数被传递进来，sys_call( )可以据此得知m的内容，并在适当的时候将内容传递给MM。MM的工作其实说起来很简单，它不断地获取并处理消息，所以它能够得到用户进程发送的m，并将其存放在mm_in中。当MM 通过获得的mm_in得知了消息的内容是要进行fork操作，它就进一步调用其do_fork( )完成整个过程。消息的一送一收之间，fork( )的大致过程我们就已经基本了解了。其实我们也完全可以猜测出其他系统调用的情况。不外乎是通过调用_syscall( )转化成发送消息，将来会有相应的进程取出消息进行处理。说到这里，有一个情况需要说明，就是我们拿Linux 中的fork( )和Minix中的fork( )来比较是有些不公平的。因为你也一定已经看到，实现方式真正与Linux的fork( )相同的是Minix的_sendrec( )和_receive()，它们都是通过中断进入内核，在内核中完成任务。而Minix 中的fork( )是通过两个进程分别调用_sendrec( )和_receive( )这两个系统调用来实现的，从这个意义上来说，Minix中的fork( )其实不算系统调用（这也是函数sys_call( )的开头注释中说Minix的系统调用只有三个的原因），它只是在完成一个紧密依赖系统调用的工作罢了。不过从用户的角度，这种差别是看不到的，而且只要调用fork( )时能实现需要的功能，这种差别就无关紧要。因此用户完全可以称fork( )为一个系统调用。实现方法的差别源于设计思路的不同。在Minix 中，真正的系统调用只有三个，这意味着内核不必事无巨细地处理用户进程要求的所有工作，只需要做好其“邮局”的职能，将消息按照需求来回传送就够了。在Linux 中内核所做的工作，在Minix 中被交给专门的进程来完成。你可能一下子就明白了，原来微内核的“微”字是让内核功能最简化的意思。8.1.3 我们的选择到这里，微内核和宏内核各自的工作原理我想读者已经明白了。同时它们的优缺点也基本上清楚了。宏内核的优势在于其逻辑简单，直截了当，实现起来也容易，而且也因为它的直接，避免了像微内核那样在消息传递时占用资源。而微内核的优势在于，它的逻辑虽相对复杂但非常严谨，结构上显得非常优雅和精致，而且程序更容易模块化，从而更容易移植。从编程的难易程度上来看，宏内核看上去具有一定优势，因为它很直接，不需要绕弯子，但从长期来看，当内核逐渐变大，微内核的结构会更加清晰。虽然选择微内核意味着有调试起来有些困难的消息机制摆在面前，但从设计理念上来看，微内核更加“摩登”，更“酷”。而且，从学习编程的角度看，搞一个微内核可以为将来架构其他东西作为很有益的参考。基于这些原因，我们选择微内核。选择了微内核，首要的任务就比较明显了，那就是实现一个进程间通信（IPC）机制。其实这也没有想像中那么难，我们下面就来看一看。
8.2 IPCIPC是Inter-Process Communication的缩写，直译为进程间通信，说白了就是进程间发消息。我们在上一节中把这种消息传递比作邮政系统，但实际上这种比喻并不全对。有的消息机制是很像收发邮件的，这种叫做异步IPC，意思是说，发信者发完就去干别的了，收信者也一样，看看信箱里没信，也不坐在旁边傻等。而有另一种消息机制正好相反，被称为同步IPC，它不像邮寄，倒像接力赛，发送者一直等到接收者收到消息才肯放手，接收者也一样，接不到就一直等着，不干别的。当然你可以把同步IPC也比作邮寄，只不过寄信的人从把信投到信箱里的那一刻开始，就住在邮局不走了，其他什么也不干了，就等着邮局说：“哥们儿，你的信对方已经收到了，放心回家吧！”这才恋恋不舍地离开。收信的也一样，一旦决定收信，就守在自家信箱前面不走了，一直等，连觉也不睡，望穿秋水，等信拿在手里了，这才回屋，每收一次信，就得瘦个十几斤。我们都是性情中人，我们选择傻等，或曰同步IPC。同步IPC有若干的好处，比如：操作系统不需要另外维护缓冲区来存放正在传递的消息；操作系统不需要保留一份消息副本；操作系统不需要维护接收队列（发送队列还是需要的）；发送者和接收者都可在任何时刻清晰且容易地知道消息是否送达；从实现系统调用的角度来看，同步IPC更加合理——当使用系统调用时，我们的确需要等待内核返回结果之后再继续。这些特性读者可能无法一下子全部明白，不要紧，我们接下来写完代码，你就全都明白了。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200724042157994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200724042218657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200724042231854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

