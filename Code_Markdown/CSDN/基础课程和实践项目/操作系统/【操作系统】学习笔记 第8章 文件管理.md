> 本文属于「操作系统学习实践」系列文章之一。这一系列着重于「操作系统知识的学习与实践」。由于文章内容随时可能发生更新变动，欢迎关注和收藏[操作系统系列文章汇总目录](https://memcpy0.blog.csdn.net/article/details/120663693)一文以作备忘。需要特别说明的是，为了透彻理解和全面掌握操作系统，本系列文章中参考了诸多博客、教程、文档、书籍等资料，限于时间精力有限，这里无法一一列出。部分重要资料的不完全参考目录如下所示，在后续学习整理中还会逐渐补充：
> - 计算机操作系统，郑鹏、曾平、金晶编著，武汉大学出版社
> - 深入理解计算机系统 *Computer Systems: A Programmer’s Perspective* ，`Randal E.Bryant, David O'Hallaron` 等著，龚弈棋利、雷迎春译，机械工业出版社

@[toc]

所有的计算机系统，都需要长期保存大量信息，而这些信息均以文件的形式存放到外存上。为了管理外存上的文件，操作系统中设置了管理文件的功能模块——文件系统。文件系统是操作系统的重要组成部分，==它负责管理文件，用统一的方式管理用户和系统信息的存储、检索、更新、共享和保护，并为用户提供一整套方便有效的文件使用和操作方法==。

本章介绍文件系统的概念（文件、文件系统、文件分类）、文件的结构与存储设备（文件的逻辑结构、物理结构、存取方法、**存储设备**、**磁盘调度算法**）、**文件存储空间的分配与管理**、文件目录管理、文件的共享与保护（包括文件的转储和恢复）、文件的使用。

---
# 8.1 文件系统的概念
## 8.1.1 文件和文件系统
### 1. 文件
[**文件**](https://en.wikipedia.org/wiki/Computer_file)是**具有符号名**（即**文件名**）的**一组相关信息**的**集合**。通常，文件由若干记录组成，**记录是一些相关数据项的集合**，而数据项是数据组织中可以命名的最小逻辑单位。例如，每个职工情况记录由姓名、性别、出生年月、工资等数据项组成，一个单位的职工情况记录就组成了一个文件。

文件表示的范围很广，系统或用户可以将「具有一定功能的程序或数据集合」命名为一个文件。例如，一个命名的源程序、目标程序、一批数据以及系统程序等都可以看做文件。在有的操作系统中，**设备也被看成一种特殊的文件**，这样系统可以对设备和文件实施统一的管理，既简化了系统设计又方便了用户。

### 2. 文件系统
[**文件系统**](https://en.wikipedia.org/wiki/File_system) ` file system` 是指==操作系统中与管理文件有关的软件和数据的集合==：
- 从系统的角度看，**文件系统是「对文件的存储空间进行组织和分配、负责文件的存储、并对存入文件进行保护和检索」的系统**。具体来说，文件系统负责为用户建立、撤销、读写、修改和复制文件（即为用户提供接口）。
- 从用户的角度看，文件系统主要实现了**按名存取**。即，当用户要求系统保存一个已命名文件时，文件系统按照一定的格式，将用户的文件存放到文件存储器中适当的地方；当用户需要使用文件时，系统根据用户所给的文件名，能够从文件存储器中找到所需的文件。

文件系统由三部分组成：实施管理文件所需的**数据结构**、**与文件管理有关的软件**和**被管理的文件**。文件系统的层次结构包含四层：基本I/O控制层、基本文件系统层、基本I/O管理程序层及逻辑文件系统层。
- 基本I/O控制层 `Basic I/O control level` ：又称**设备驱动程序层**，该层主要由**磁盘驱动程序
和磁带驱动程序**组成，负责**启动设备I/O操作**及**对设备发来的中断信号进行处理**。
- 基本文件系统层 `Basic file system level` ：又称**物理I/O层**，该层负责处理**内存和外存（磁盘或
磁带）之间的数据块交换**。它关心的是「数据块在辅存设备和在主存缓冲区中的位置」，而无须了解所传送数据块的内容或文件结构。
- 基本I/O管理程序层：又称**文件组织模块层** `File-organization module level` ，该层完成大量与磁盘I/O有关的工作，包括选择文件所在的设备、进行**文件逻辑块号到物理块号的转换**、优化磁盘调度的性能、对文件空闲存储空间进行管理、指定I/O缓冲区、负责**所有文件I/O的初始化和终止**等。
- 逻辑文件系统层 `The logical file system level` ：该层处理文件及记录的相关操作。如允许用户利用文件名访问文件及其中的记录、实现对文件及记录的保护、实现目录操作等。
- 文件系统接口：位于最上层。
![](https://img-blog.csdnimg.cn/a060db937aeb430b851b53df1f3735f3.png)


不同操作系统中，文件系统的组成方法不一样，但**这种组成具有一定的代表性**。

## 8.1.2 文件分类
为了便于管理和控制文件，通常将文件分为若干类型。不同系统对文件的管理方式不同，因而**对文件的分类方法也有很大差异**。这里介绍几种常用的文件分类方法。
### 1. 按用途分类
按用途可以将文件分为以下几类：
- 系统文件。是指**由系统软件构成的文件**。==大多数系统文件只允许用户调用执行，而不允许用户去读或修改它==。
- 库文件。是指**由系统提供给用户使用的各种标准过程、函数和应用程序文件**。这类文件允许用户调用执行，但不允许用户修改。
- 用户文件。是指**用户委托文件系统保存的文件**。如源程序、目标程序、原始数据等。这类文件只能由文件所有者或所有者授权用户使用。
### 2. 按保护级别分类
按保护级别可以将文件分为以下几类：
- 只读文件。允许**所有者或授权用户**对文件进行**读**，但不允许写。
- 读写文件。允许**所有者或授权用户**对文件进行**读写**，但禁止未核准的用户读写。
- 执行文件。允许核准用户**调用执行**，但不允许对它进行读写。
- 不保护文件。**不加任何访问限制的文件**。

### 3. 按信息流向分类
按信息流向可以将文件分为以下几类：
- 输入文件。**来自输入设备的文件**。如来自读卡机或键盘的输入文件，只能读入，所以它们是输入文件。
- 输出文件。**写向输出设备的文件**。如写向打印机的输出文件，只能写出，所以它们是输出文件。
- 输入输出文件。如磁盘、磁带上的文件，既可以读又可以写，所以它们是输入输出文件。

### 4. 按数据形式分类
按数据形式可以将文件分为以下几类：
- 源文件。**由源程序和数据构成的文件**。由终端或输入设备输入的源程序和数据所形成的文件都属于源文件。源文件一般由ASCII码或汉字组成。
- 目标文件。指源文件经过编译程序编译，但尚未链接成可执行代码的目标代码文件。目标文件属于二进制文件。
- 可执行文件。编译后的目标代码，经链接程序链接后形成的可以运行的文件。

---
# 8.2  文件结构及存储设备
文件结构指**文件的组织形式**，文件结构分为文件的逻辑结构和文件的物理结构。
- 逻辑结构：又称**文件组织**，是**从用户观点出发**所看到的文件组织形式，是用户可以直接处理的数据及其结构。文件的逻辑结构与存储设备特性无关。
- 物理结构：又称**文件的存储结构**，是文件**在外存上的存储组织形式**。它与存储设备特性、外存分配方式有很大关系。

## 8.2.1 文件的逻辑结构
文件的逻辑结构可以分为两种形式。一种是有结构的记录式文件，另一种是无结构的流式文件。
### 1. 记录式文件
记录式文件是一种**有结构的文件**，它由**一组相关记录**组成。记录式文件又可以分为等长记录文件和变长记录文件。等长记录文件（又称定长记录文件）中的所有记录的长度相等，变长记录文件中的各记录长度可以不相等。

**记录是记录式文件的基本单位**，它让文件在信息管理领域显得十分方便。所谓记录，是一段有独立意义的信息集合。例如学生成绩文件，是由全部学生的成绩记录组成的，每个记录包括学生姓名、学号、各科成绩等多个字段。**记录是文件进行存取的基本单位**，所以顺序访问时文件读/写指针每次步进1个记录长度。

根据用户或系统管理的需要，记录式文件可以组织成顺序文件、索引文件、索引顺序文件。
- 顺序文件中的记录**按关键字的大小顺序**排列，其中的记录通常是**定长**的。
- 索引文件为文件设置一个索引表，文件中的每个记录在索引表中有一个表项，用于存放记录的存放地址及长度。
- 索引顺序文件是前两者的结合，它将「顺序文件中的所有记录」分成若干组，为顺序文件建立一张索引表，为「每组中的第一个记录」建立一个索引项，其中含有该记录的键值和指向该记录的指针。

### 2. 流式文件
流式文件是一种**无结构的文件**，它由**字符序列**构成。可以将流式文件看成记录式文件的特例。构成流式文件的基本单位是字符，即流式文件是具有符号名、且在逻辑上意义完整的有穷字符流序列。因为以字节为单位访问流式文件，所以顺序访问时，文件的读/写指针每次步进 $1$ 个字节长度。虽然字符流没有结构，但并非意味着文件不能有结构。**在UNIX系统中，所有文件都被看成流式文件，系统不对文件进行格式处理**。

## 8.2.2 文件的物理结构
文件的物理结构是指一个文件在外存上的存储组织形式，它与存储介质的存储特性及外存分配方式有关。也有学者把文件的物理结构看成是**文件的实现**。为了有效地管理文件存储空间，通常将**文件存储设备**划分为**大小相等的物理块**，物理块是分配及传输信息的**基本单位**。==物理块的大小与设备有关，但与逻辑记录的大小无关，因此一个物理块中可以存放若干个逻辑记录，一个逻辑记录也可以存放在若干个物理块中==。

把文件中的若干个逻辑记录合并成一组、写入一个物理块中的操作称**记录的成组**。把逻辑记录从物理块中分离出来的操作称**记录的分解**。为了有效地利用外存设备和便于系统管理，一般也**把文件信息划分为与物理存储块大小相等的逻辑块**。
### 1. 顺序结构
顺序结构又称连续结构，是一种最简单的物理文件结构，它将一个逻辑文件的信息存放在外存的连续物理块中。**以顺序结构存放的文件称为顺序文件或连续文件**。

顺序文件的主要优点是**顺序存取时速度较快**。当文件为定长记录文件时，还可以根据文件起始地址及记录长度进行随机访问。但因为文件存储要求连续的存储空间，**可能会产生碎片**，同时**也不利于文件的动态扩充**。
### 2. 链接结构
链接结构又称串联结构，它将一个逻辑文件的信息存放在外存的若干个物理块中，这些物理块可以不连续。为了使系统能方便地找到后续的文件信息，**在每一个物理块中设置一个指针，指向该文件的下一个物理块的位置**，从而使得存放同一个文件的物理块链接起来。**采用链接结构存放的文件称为链接文件或串联文件**。

链接文件的优点是**可以解决外存的碎片问题**，因而提高了外存空间的利用率，同时**文件的动态增长也很方便**。但链接文件只能按照文件的指针链顺序访问，因而**查找效率较低**，且指针占用了一定的存储空间。

### 3. 索引结构
索引结构将一个逻辑文件的信息存放于外存的若干个物理块中，这些物理块可以不连续。系统为每个文件建立一个索引表，索引表中的每个表项存放「文件信息所在的逻辑块号」和「与之对应的物理块号」。**以索引结构存放的文件称为索引文件**。

索引文件的优点是既可以**顺序访问**，也可以**随机访问**，也易于进行文件的增删，但索引表的使用**增加了存储空间的开销**。另外，索引表的查找策略对文件系统的效率影响很大，且要**两次访问外存**。

## 8.2.3 文件存取方法
文件的基本作用是存储信息。使用文件时，必须将文件信息读入计算机内存中。**文件的存取方法** `Access Methods` 是指**读写文件存储器上的一个物理块的方法**，通常有三种文件存取方法：顺序存取
法、直接存取法和按键存取法。
### 1. 顺序存取法
顺序存取法 `Sequential Access` 是**按照文件信息的逻辑顺序依次存取**。
- 在记录式文件中，顺序存取反映为**按记录的排列顺序**来存取。如果当前存取的记录为 $R_i$ ，则下次要存取的记录自动地确定为 $R_{i+1}$ 。
- 在流式文件中，顺序存取反映为**当前读写指针的变化**，即在存取完一段信息之后，读写指针
自动加上这段信息的长度，以便指出下次存取的位置。
- 对于定长记录的顺序文件，如果知道了当前记录的地址，则很容易确定下一个要存取记录的地址。例如，设置一个读指针 $rptr$ ，令它总是指向**下一次要读出的记录首地址**。当该记录读出后，对 $rptr$ 进行相应的修改。对于定长记录文件，$rptr$ 修改为 $$rptr=rptr+L$$ 其中 $L$ 为文件记录的长度。此时 $rptr$ 指向下一次要读出的记录首地址。
- 对于变长记录文件，$rptr$ 修改为 $$rptr=rptr+L_i$$ 其中 $L_i$ 为文件第 $i$ 个记录的长度。此时 $rptr$ 指向下一次要读出的记录首地址。

### 2. 直接存取法
直接存取 `Direct Access`（又称随机存取）法，允许**按任意顺序存取**文件中的任何一个物理记录，可以根据记录的编号来直接存取文件中的任意一个记录，或者是根据存取命令、把读写指针移到欲读写信息处。
- 在流式文件中，直接存取法必须事先用必要的命令，把读写指针移到欲读写的信息开始处，然后再进行读写。
- 对于定长记录的顺序文件，若知道文件的起始地址和记录长度，则第 $i\ ( i=0, 1, 2,…)$ 个记录的首地址为 $$rptr=addr+i×L$$ 其中 $addr$ 是该文件的首地址，$L$ 为记录长度。
- 对变长记录文件，则无法实现直接存取。

### 3. 按键存取法
按键存取法实质上也是直接存取法，它不是根据记录编号或地址来存取，而是根据文件记录中**数据项**（通常称为键）的内容进行存取。即**把键经过某种方法计算处理**，转换成相应的物理地址后进行存取。

## 8.2.4 文件存储设备
文件的存储设备主要有磁带、磁盘、光盘等。由于**存储设备的特性可以决定文件的存取方法**，因此这里介绍「以磁带为代表的顺序存储设备」和「以磁盘为代表的直接存储设备」的特性，以及**存储设备、文件物理结构与存取方法之间的关系**，同时还将介绍**磁盘调度算法**。
### 1. 文件存储设备（磁带）
磁带 `magnetic tape` 是一种典型的**顺序存储设备**，==这种设备只有在前面的物理块被存取访问过之后，才能存取后续物理块的内容==。由于磁带机的启动和停止都要花费一定的时间，因此在磁带的相邻物理块之间、**设计有一段间隙将它们隔开**，如下图所示。
 ![](https://img-blog.csdnimg.cn/d893b38fb2ba4a2da67b0994105a864a.png)

磁带的存取速度与**信息密度**（字符数/英寸）、**磁带带速**（英寸/秒）和**块间间隙**有关。

如果磁带的带速高、信息密度大且块间间隙（磁头启动和停止时间）小，则磁带**存取速度高**。反之，若磁带的带速低、信息密度小且块间间隙（磁带启动和停止时间）大，则磁带存取速度低。==由于磁带读写时只有在第 $i$ 块被存取之后，才能对第 $i+1$ 块进行存取操作，因此某个特定物理块的存取访问时间，与该物理块到磁头当前位置的距离有很大关系==。

### 2. 文件存储设备（磁盘）
磁盘是典型的**直接存取设备**，这种设备允许文件系统直接存取磁盘上的任意物理块。
- 磁盘机一般由**若干磁盘片**组成，可**沿一个固定方向**高速旋转。**每个盘面对应一个磁头**，磁臂可沿半径方向移动。
- 磁盘上的一系列同心圆称为**磁道** `track` ，磁道沿径向又分成**大小相等的多个扇区** `sector` ，与盘片中心**有一定距离的所有磁道**组成一个**柱面** `cylinder` 。因此，磁盘上的每个物理块可以用**柱面号、磁头号和扇区号**表示，下图给出了磁盘结构、磁盘数据组织和格式示意图。
![](https://img-blog.csdnimg.cn/d4fb28a277084c8fb6f2856503086b9e.png)

磁盘访问时间由三部分组成：寻道时间、旋转延迟时间和传输时间（所以对应有移臂调度算法、旋转调度算法）。
- 寻道时间 `seek time` ：指**将磁头从当前位置移动到指定磁道**所经历的时间。由**启动磁臂时间**和**磁头移动多条磁道**的时间构成。
- 旋转延迟时间 `rotational latency` ：指**将指定扇区扇区移动到磁头下面**所经历的时间。平均旋转延迟时间是每转所需时间的一半。
- 传输时间（`tranfer time`）： 指**从磁盘上读出数据**或**向磁盘写入数据**所经历的时间。

由于这三部分操作**均涉及机械运动**，故磁盘块的访问时间约为 `0.01～0.1s` 之间，其中**寻道时间所占的比例最大**，约为整个访问时间的 $70\%$ 。

### 3. 存储设备、存取方法和物理结构的关系
文件的**物理结构**与**文件存储器的特性**和**存取方法**密切相关。存储设备、存取方法和物理结构之间的关系如下表所示。
- 磁带是一种**顺序存取设备**，若用它作为文件存储器，则适合采用**顺序结构存放文件**，相应的存取方法通常是**顺序存取法**。在顺序存取时，当存取一个记录后，由于磁头正好移到下一个记录的位置，因而可以随即存取该记录，不再需要额外的寻找时间。如果采用其他文件结构、或采用直接存取方式进行存取都不太合适，因为来回倒带要花费很多时间。
- ==磁盘属于**直接存取存储设备**，前述的几种物理结构**都可以采用**。存取方法也可以**多种多样**==。采用何种物理结构和存取方法，要看系统的应用范围和文件的使用情况。如果采用顺序存取法，则前述的几种文件结构都可以采用。如果采用直接存取法，则索引文件效率最高，顺序文件效率居中，链接文件效率最低。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529172014857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

**磁盘上的物理块，还可以按磁盘旋转的反方向依次排列编号，也可以采用间隔顺序排列**。图8.4中的(a)和(b)给出了这两种排列方法。==第二种排列方法的优点是：读完前面的物理块并加以处理后，磁盘刚好旋转到下一个物理块的位置==。如果按第一种排列方法，那么前一个物理块读出处理后，下一个物理块已转过磁头，只好等到下次该物理块转到磁头下面时才能读取，这显然降低了存取速度。
![](https://img-blog.csdnimg.cn/981f97f107da4dc9871039b56e798f04.png)

### 4. 磁盘调度算法
磁盘是**可以被多个进程共享**的设备。当有多个进程都请求访问磁盘时，应采用**一种适当的调度算法**，以使各进程对磁盘的**平均访问时间**（**主要是寻道时间**）最短。下面介绍几种磁盘调度 `Disk Scheduling` 算法。
- 先来先服务 `FCFS` 。先来先服务算法是一种最简单的磁盘调度算法。该算法**按进程请求访问磁盘的先后次序**进行调度。该算法的特点是合理、简单，**但未对寻道进行优化**。
- 最短寻道时间优先 `Shortest-Seek-Time-First, SSTF` 算法。该算法选择「与当前磁头所在磁道距离最近的请求」作为下一次服务的对象。该算法的寻道性能比 `FCFS` 好，但它**不能保证平均寻道时间最短**，且可能**会使某些进程的请求总也得不到服务**，这种现象称为饥饿。
- 扫描 `SCAN` 算法。`SCAN` 算法在磁头当前移动方向上，选择「与当前磁头所在磁道距离最近的请求」作为下一次服务的对象。由于这种算法中磁头移动的规律颇似电梯的运行，故又称为**电梯调度**算法。**`SCAN` 算法既具有较好的寻道性能，又避免了饥饿现象**，但它**对两端磁道请求不利**。
- 循环扫描 `CSCAN` 算法。`CSCAN` 算法是对 `SCAN` 算法的改良，它规定**磁头单向移动**。例如，自里向外移动，当磁头移到最外磁道时立即又返回到最里磁道，如此循环进行扫描。**该算法消除了对两端磁道请求的不公平**。
- `N-Step-SCAN` ：若多个进程反复请求对某一磁道的访问，则**磁臂可能停留在某处不动**，这一现象称为**磁臂粘着**。`N-Step-SCAN` 算法**将磁盘请求队列分成**若干个长度为 $N$ 的**子队列**，磁盘调度按 `FCFS` 算法**依次处理这些子队列**，而**处理每个队列**时按 `SCAN` 算法进行，一个队列处理完后，再处理其他队列。
- `FSCAN` 算法：是 `N-Step-SCAN` 算法的简化，它**只将磁盘请求队列分成两个子队列**。一个是**当前所有**请求磁盘I/O的进程形成的队列，由磁盘调度按 `SCAN` 算法进行处理，另一个队列则是**在扫描期间新出现**的磁盘请求。


例如，有一个磁盘请求序列，其磁道号为：$86, 147, 91, 177, 94, 150, 102, 175, 130$ ，磁头当前正在 $143$ 号磁道上、并向磁道号增加的方向移动。表8.2给出了使用先来先服务算法和最短寻道时间优先算法的调度情况，表8.3给出了使用扫描算法和循环扫描算法的调度情况。

![](https://img-blog.csdnimg.cn/f5962a23e2404325a734fd499e82685b.png)
![](https://img-blog.csdnimg.cn/63c6ae8d1c3d45a69a5a0676c4d802c4.png)

下面再举一个例子。从 $100$ 号磁道开始，磁盘访问请求为：$55, 58, 39, 18, 90, 160, 150, 38, 184$ 。 
- 先来先服务算法的磁臂调度顺序如下。平均寻道长度为 $(45+3+19+21+72+70+10+112+146) / 9 = 55.3$ 。
![](https://img-blog.csdnimg.cn/274f90d70fcf4d019da23e2d6c97a080.png)

- 最短寻道时间优先算法的磁臂调度顺序如下。平均寻道长度为 $27.6$ 。
![](https://img-blog.csdnimg.cn/08d34bb90bc64c2388f9f70d624a75f6.png)

- 扫描算法的磁臂调度顺序如下。对同样的请求，它从 $100$ 号磁道开始，**向磁道号增加方向移动**。平均寻道长度为 $27.8$ 。
![](https://img-blog.csdnimg.cn/ce2fc1d506084c67a8835a139dec15c2.png)

- 循环扫描算法的磁臂调度顺序如下。它从 $100$ 号磁道开始，**向磁道号增加方向移动**。平均寻道长度为 $35.8$ 。
![](https://img-blog.csdnimg.cn/ea749aba9df2495faf7728064ff188a8.png)


### 5. 磁盘容错技术
容错技术是通过在系统中**设置冗余部件**来**提高系统可靠性**的一种技术。磁盘容错技术也称为系统容错技术，它是通过**增加冗余磁盘驱动器**、**磁盘控制器**等方法来**提高磁盘系统可靠性**的一种技术。系统容错可分为三个级别。

第一级容错技术 `SFT-I` 是低级磁盘容错技术，是**最基本**的一种磁盘容错技术，主要用于防止因**磁盘表面发生缺陷**所造成的数据丢失。它包含以下技术：
- 双份目录、双份文件分配表：**目录和文件分配表**是文件管理的**重要数据结构**，为防止它们被破坏，可在不同的磁盘上或在磁盘的不同区域中，建立**双份目录和文件分配表**，一份称为主目录或主文件分配表，另一份称为**备份文件目录及备份文件分配表**。
	一旦主目录或主文件分配表被破坏，则启用备份文件目录及文件分配表。**系统启动时**也要对两份数据结构进行**检查**，以验证**它们的一致性**。
- 当磁盘出现**较少缺陷**时，可采用以下两种补救措施：
	- 热修复重定向：将**磁盘中的一部分**作为<ins>热修复重定向区</ins>，用于存放当发现磁盘有缺陷时的**待写数据**，并**对写入该区的所有数据进行登记**，便于以后对数据进行访问。
	- 写后读校验：每次向磁盘中写入一个数据块后**又立即**从磁盘上读出该数据块，与写入数据进行比较，**若相同则写下一块**，否则重写。若重写后仍不一致，则认为该盘块有缺陷，此时便**应将该块数据写入热修复重定向区**。


`SFT-II` 是中级磁盘容错技术。`SFT-I` 只能用于防止由磁盘表面部分故障造成的数据丢失。若**磁盘驱动器发生故障**，则应采用第二级容错技术。`SFT-II` 主要用于防止由**磁盘驱动器及磁盘控制器故障**所导致的系统不能正常工作。它采用了以下技术：
- 磁盘镜像 `disk mirroring`：在同一磁盘控制器下，再增**设一个完全相同的磁盘驱动器**。每次向主磁盘写入数据后，都采用**写后校验**方式，将数据**再同样写到备份磁盘上**，使两个磁盘上有**完全相同的位像图**。当主磁盘发生故障时，启用备份磁盘并发出警告。
 
	![](https://img-blog.csdnimg.cn/9ab11a2fc2a649e3aae50646c6d69a6b.png)

- 磁盘双工 `Disk Dupluxing`：将**两台磁盘驱动器**分别接到**两个磁盘控制器**上，同样使这两台磁盘驱动器**镜像成对**。在磁盘双工时，文件服务器**同时将数据写到**两个处于不同控制器下的磁盘上，使两者有**完全相同的位像图**，如果其中的一台磁盘发生故障，另一台仍然可以工作，同时发出警告。

	![](https://img-blog.csdnimg.cn/258d9a1a4ec0469f9eea4eab166d5541.png)


`SFT-III` 是高级系统容错技术，它在提供一、二级容错的基础上，提供**文件服务器镜像功能**。
- 主服务器与从服务器是**配置完全相同的两台计算机**。每台服务器除了按常规加插网卡外，还需**插入一块镜像服务器接口卡**，然后**用光缆将两块镜像服务器接口卡连接起来**。
主服务器是当前正在为工作站提供网络服务的服务器。系统自动将主服务器的内存和硬盘中的数据复制到从服务器。当主服务器发生故障时，从服务器成为网中的主服务器，使网络不受影响地正常工作。当故障排除后，**两台服务器重新同步**。

---
在并行交叉磁盘存储系统中，有**多台磁盘驱动器**，系统将每一盘块中的数据**分为若干个子盘块的数据**，再把每一子盘块的数据**分别存储到各个不同磁盘中的相同位置**。以后要读写数据时，采取**并行传输方式**，将各个盘块中的子盘块数据同时向内存中传输，从而使传输时间大大减少。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529190000105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

---
为了组合小的廉价磁盘来代替大的昂贵磁盘，以降低大批量数据存储的费用，同时也希望采用冗余信息的方式，使得磁盘失效时不会使对数据的访问受损失，于是**廉价磁盘冗余阵列** `Redundant Arrays of Inexpensive Disks, RAID` 作为高性能的存储系统，得到了广泛的应用。`RAID` 又称独立磁盘冗余阵列 `Redundant Array of Independent Disks` ，是利用**一台磁盘阵列控制器**来统一管理和控制**一组磁盘驱动器**，组成一个高速可靠的、大容量磁盘系统。

`RAID` 是一个驱动器阵列，作为一个单驱动器使用。数据通过一种“分拆 `striping` ”技术、均匀地写在每一个驱动器上。数据分拆可在位级或扇区级进行。==分拆提高了吞吐量，并且提供了一种冗余的形式，可以保证磁盘阵列中一个磁盘出现故障时，不影响系统正常工作==。`RAID` 提供了与磁盘镜像和磁盘双工类似的冗余。冗余的级别取决于所使用的 `RAID` 级。

`RAID` 有多级，当购买使用 `RAID` 系统时，需要检查一下 `RAID` 的级别是否符合系统需要。下面
简单介绍几个主要的级别。
- `RAID 0` ：要实现 `RAID 0` 必须有两个以上硬盘驱动器，`RAID 0` 实现了带区组，数据并不是保存在一个硬盘上，而是分成数据块保存在不同驱动器上。因为将数据分布在不同驱动器上，所以数据吞吐率大大提高，驱动器的负载也比较平衡。**`RAID 0` 仅提供并行交叉存取**，如果刚好所需要的数据在不同的驱动器上，效率最好。它不需要计算校验码，实现容易，能**有效地提高磁盘I/O速度**。缺点是**它没有数据差错控制，如果一个驱动器中的数据发生错误，即使其他盘上的数据正确也无济于事**。在所有的级别中，`RAID 0` 的速度是最快的；但 **`RAID 0` 没有冗余校验功能，致使磁盘系统的可靠性不好**，如果一个磁盘（物理）损坏，则所有的数据都无法使用。故很少使用。

- `RAID 1` ：具有**磁盘镜像功能**，它把磁盘阵列中的硬盘分成相同的两组，互为镜像，当任一磁盘介质出现故障时，可以利用其镜像上的数据恢复，从而提高系统的容错能力。对数据的操作仍采用**分块后并行传输**方式，利用这一并行读写特性，将数据分块并同时写入两组硬盘。`RAID 1` 的数据安全性，在所有的 `RAID` 级别上来说是最好的，但是其磁盘的利用率却只有 $50\%$ ，是所有 `RAID` 级别中最低的。

- `RAID 2` ：从概念上讲，`RAID 2` 同 `RAID 3` 类似， 两者都是将数据条块化，分布于不同的硬盘上，条块单位为位或字节。然而 `RAID 2` **使用一定的编码技术来提供错误检查及恢复**。这种编码技术需要多个磁盘存放检查及恢复信息，使得 `RAID 2` 技术实施更复杂，因此，**在商业环境中很少使用**。
- `RAID 3` ：这种校验码与 `RAID 2` 不同，它利用**一台奇偶校验盘**来完成容错，**只能查错不能纠错**。它是具有**并行传输**功能的磁盘阵列，访问数据时，一次处理一个带区，这样可以提高读取和写入速度，它像 `RAID 0` 一样**以并行的方式来存放数据**，但速度没有 `RAID 0` 快。校验码在写入数据时产生、并保存在另一个磁盘上，需要实现时用户必须要有三个以上的驱动器。`RAID 3` 的写入速率与读出速率都很高，因为校验位比较少，因此计算时间相对而言比较少。利用单独的校验盘来保护数据，虽然没有镜像的安全性高，但是硬盘利用率得到了很大的提高，比磁盘镜像减少了所需的冗余磁盘数。**常用于科学计算和图像处理**。
- `RAID 4` ：此级与 `RAID 3` 相似，但数据是按扇区、不是按位或字节分拆的，它对数据的访问是按数据块进行的，也就是按磁盘进行的，每次一个盘。在失败恢复时，它的难度比 `RAID 3` 大，在商业环境中也很少使用。
- `RAID 5` ：是一种**具有独立数据传送功能**的磁盘阵列。每个驱动器都**有自己独立的数据通道**，独立地进行读写。向阵列中的磁盘写数据，**奇偶校验数据存放在阵列中的各个盘上**，允许单个磁盘出错。`RAID 5` 也是以数据的校验位来保证数据的安全，但它不是以单独硬盘来存放数据的校验位，而是将数据段的校验位交互存放于各个硬盘上。这样任何一个硬盘损坏，都可以根据其他硬盘上的校验位来重建损坏的数据。**常用于I/O繁忙的事务处理**。
- `RAID 6` ：与 `RAID 5` 相比，`RAID 6` 增加了第二个独立的奇偶校验信息块，即设置了一个**专用的可快速访问的异步校验盘**，该盘具有独立的数据访问通道，比 `RAID3` 、`RAID5` 级性能更好。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效，也不会影响数据的使用。
- `RAID 7` ：这是一种新的 `RAID` 标准，其自身带有智能化实时操作系统、和用于存储管理的软件工具，可**完全独立于主机运行**，不占用主机CPU资源。
 

---
# 8.3 文件存储空间的分配及管理  
为了实现文件系统，必须解决**文件存储空间**的**分配和回收**问题，还应对文件存储空间进行**有效的管理**。本节主要讨论文件存储空间的分配、和空闲存储空间的管理方法。
## 8.3.1 文件存储空间的分配
一般来说，文件存储空间的分配常采用两种方式：静态分配与动态分配。**静态分配**是在文件建立时一次分配所需的全部空间；而**动态分配**则是根据动态增长的文件长度进行分配，甚至可以一次分配一个物理块。在分配区域大小上，也可以采用不同方法。可以为文件分配一个完整的区域以装下整个文件，这就是**文件的连续分配**。但文件存储空间的分配通常以块或簇（几个连续物理块称为簇，一般是固定大小）为单位。常用的文件存储空间分配方法有连续分配、链接分配、索引分配。
### 1. 连续分配 
**连续分配** `Continuous Allocation` 是最简单的磁盘空间分配策略，该方法要求**为文件分配连续的磁盘区域**。在这种分配算法中，==用户必须在分配前，说明待创建文件所需要的存储空间大小==。然后系统查找空闲区的管理表格，看看是否有足够大的空闲区供其使用。==如果有，就给文件分配所需要的存储空间；如果没有，该文件就不能建立，用户进程必须等待==。
![](https://img-blog.csdnimg.cn/bf30efbc33a84f0780a8d7f417429bb8.png)

上图给出了连续分配的示例。在上图中，文件 $A$ 的起始盘块号为 $2$ ，文件长度为 $3$ ，表示它占用的盘块依次为 $2, 3, 4$ 。文件 $B$ 的起始盘块号为 $9$ ，文件长度为 $5$ ，表示它占用的盘块依次为 $9, 10, 11, 12, 13$ 。为了记录各文件的存储分配及其他情况，每个文件在文件目录中占一个表项，表项中包括文件名、起始块号、文件长度等。

连续分配的优点是**顺序访问容易**且查找速度比其他方法要快，**目录中关于文件物理存储位置的信息也比较简单**，只需要起始块号和文件大小。其主要缺点是**容易产生碎片问题**，需要定期进行存储空间的紧缩。很显然，==这种分配方法不适合文件随时间动态增长和减少的情况，也不适合用户事先不知道文件有多大的应用情况==。

### 2. 链接分配 
对于文件长度需要动态增减、以及用户不知道文件有多大的应用情况，往往采用链接分配 `Linked Allocation` 。这种分配策略通常有以下两种实现方案。 
- 以扇区为单位的链接分配。按文件的要求**分配若干个磁盘扇区**，这些扇区在磁盘上可以不相邻接，属于同一个文件的各扇区**按文件记录的逻辑次序**用链接指针连接起来。==当文件需要增长时，就为文件分配新的空闲扇区，并将其链接到文件链上。同样，当文件缩短时，将释放的扇区归还给系统==。
下图给出了链接分配的示例。在下图中，文件 $B$ 的起始盘块号为 $1$ ，文件长度为 $5$ ，从 $1$ 号盘块中的链接指针、可以知道文件的下一个存放盘块为 $8$ ，以此类推，可以知道存放文件的后续盘块依次为 $3, 14, 28$ 。
	链接分配的优点是**消除了碎片问题**（消除了外部碎片，类似于内存管理中的分页策略），**不需要采取压缩技术**。但是检索逻辑上连续的记录时，查寻时间较长，同时链接指针的维护有一些开销，且链接指针也要占用存储空间。
![](https://img-blog.csdnimg.cn/f213a73928904296a977eb0e73174845.png)

- 以区段（或簇）为单位的链接分配。这是一种广为使用的分配策略，其实质是**连续分配和非连续分配的结合**。通常，扇区是磁盘和内存间信息交换的基本单位，所以常以扇区作为最小的磁盘空间分配单位。==本分配策略不是以扇区为单位进行分配，而是以区段（或称簇）为单位进行分配。区段是由若干个（在一个特定系统中其数目是固定的）连续扇区组成的==。一个区段往往由一条或几条磁道所组成，**文件所属的各区段可以用链接指针、索引表等方法来管理**。当为文件动态分配一个新区段时，该区段应尽量靠近文件的已有区段，以减少查寻时间。
此策略的优点是**对辅存的管理效率较高**，减少了文件访问的查寻时间，所以被广为使用。

**文件分配表** `File Allocation Table, FAT` 是以链接方式存储文件的系统中，记录磁盘分配和跟踪空白盘块的数据结构。**该表整个文件系统仅设一张**，其结构如下所示。表的序号是物理块号，从 $0$ 开始直至 $N－1$（ $N$ 为盘块总数）。每个表项中的内容为存放文件数据的下一个盘块号。文件的首地址（第一个盘块号）存放在目录中。因此，从目录中找到文件的首地址后，就能找到文件在磁盘上的所有存放地址。
![](https://img-blog.csdnimg.cn/8a03e204c3b5454e8738cc4a767d7cec.png)

【文件分配表例】假定磁盘块的大小为 $1\textrm{KB}$ ，对于 $1.2\textrm{MB}$ 的软盘，其文件分配表 `FAT` 需要占用多少存储空间？若硬盘容量为 $200\textrm{MB}$ 时，`FAT` 需要占用多少空间？
答：软盘大小为 $1.2\textrm{MB}$ ，磁盘块的大小为 $1\textrm{KB}$ ，所以该软盘共有盘块 $1.2\textrm{M} /1\textrm{K} =1.2\textrm{K}$ 个。又 $1\textrm{K}＜1.2\textrm{K}＜2\textrm{K}$ ，故 $1.2\textrm{K}$ 个盘块号要用 $11$ 位二进制表示，为了方便存取，每个盘块号用 $12$ 位二进制描述，即文件分配表的每个表目为 $1.5$ 个字节。`FAT` 要占用的存储空间总数为：$1.5×1.2\textrm{K}=1.8\textrm{KB}$ 。

若硬盘大小为 $200\textrm{MB}$ ，硬盘共有盘块 $200\textrm{M}/1\textrm{K}=200\textrm{K}$ ，又  $128\textrm{K}＜200\textrm{K}＜256\textrm{K}$ ，故 $200\textrm{K}$ 个盘块号要用 $18$ 位二进制表示。为方便文件分配表的存取，每个表目用 $20$ 位二进制表示，即文件分配表的每个表目大小为 $2.5$ 个字节。`FAT` 要占用的存储空间总数为：$2.5×200\textrm{K}=500\textrm{KB}$ 。

### 3. 索引分配
**链接分配方式虽然解决了连续分配方式中存在的问题，但又出现了新的问题**。首先，当要求随机访问文件中的一个记录时，需要按链接指针依次进行查找，这样查找十分缓慢。其次，链接指针要占用一定数量的磁盘空间。
#### (1) 直接索引
==在索引分配方式中，系统为每个文件分配一个索引块，索引块中存放索引表，索引表中的每个表项对应分配给该文件的一个物理块==。下图给出了索引分配的示例。在图中，文件 $B$ 的索引盘块号为 $24$ ，读出索引盘块知道文件长度为 $5$ ，文件占用的盘块依次为 $1, 8, 3, 14, 28$ 。
![](https://img-blog.csdnimg.cn/3bb9e04c55e14de9bfde4c72d3571a78.png)

索引分配方式不仅**支持直接访问**，而且**不会产生外部碎片**，文件长度受限制的问题也得到了解决。其缺点是**由于索引块的分配增加了系统存储空间的开销**。对于索引分配方式，索引块的大小选择是一个很重要的问题。为了节约磁盘空间，希望索引块越小越好。但索引块太小无法支持大文件，所以要采用一些技术来解决这个问题。另外，**存取文件需要两次访问外存**——首先要读取索引块的内容，然后再访问具体的磁盘块，因而降低了文件的存取速度。

#### (2) 二级索引
==为了更有效地使用索引表、避免访问索引文件时两次访问外存，可以在访问文件时，先将索引表调入内存中，这样文件的存取就只需要访问外存一次了==。当文件很大时，文件的索引表也会很大。如果索引表的大小超过了一个物理块，==可以将索引表本身作为一个文件，再为其建立一个“索引表”，这个“索引表”作为文件索引的索引，从而构成了二级索引==。第一级索引表的表项指向第二级索引，第二级索引表的表项指向文件信息所在的物理块号。以此类推可再逐级建立索引，进而构成多级索引。两级索引分配示意图如下：
![](https://img-blog.csdnimg.cn/83fb5af3268e49b99d4672dbdddf5da2.png)

两级索引分配允许的文件最大长度：在两级索引分配方式下，如果每个盘块的大小为 $1\textrm{KB}$ ，每个盘块号占 $4$ 字节，则一个索引块中可以存放：
       $$1\textrm{KB}/4\textrm{B}=256个盘块号$$
       
两级索引最多可以存放的盘块数为：
     $$256×256=64\textrm{K}个盘块号$$
     
因此可以允许的最大文件长度为：
         $$64\textrm{K}×1\textrm{KB}=64\textrm{MB}$$


#### (3) 混合索引
**混合索引分配方法**是将多种索引分配方法结合在一起形成的一种分配方法。例如，==系统中既采用直接索引地址，又采用一次间接索引地址、二次间接索引地址，甚至三次间接索引地址==。这种混合索引分配方法已在UNIX等操作系统中应用。

在UNIX System V中，共设有 $13$ 个地址项，包括 $10$ 个直接地址项、一个一次间接地址项、一个二次间接地址项和一个三次间接地址项。
- 直接地址：为了提高对文件的检索速度，在索引节点中建立了 $10$ 个直接地址项，每个地址项中存放相应文件所在的盘块号。假定一个盘块的大小为 $4\textrm{KB}$ ，当文件长度不大于 $40\textrm{KB}$ 时，可以直接从索引节点中得到文件存储的所有盘块号。
- 一次间接地址：一次间接地址项中存放的不是存储文件数据的盘块号，而是先将多个盘块号存放在一个磁盘块中，再将该磁盘块的块号存放在一次间接地址项中。若盘块大小为 $4\textrm{KB}$ ，一个盘块号占 $4$ 字节，则一个盘块中可以存放下 $4\textrm{KB}/4\textrm{B}=1\textrm{K}$ 个磁盘块号。一次间接地址项寻址范围为 $1\textrm{K}×4\textrm{KB}=4\textrm{MB}$ 。
- 多次间接地址：该地址结构中还有二次间接地址和三次间接地址。二次间接地址的寻址范围是 $1\textrm{K}×1\textrm{K}×4\textrm{KB}=4\textrm{GB}$ 。三次间接地址的寻址范围是 $1\textrm{K}×1\textrm{K}×1\textrm{K}×4\textrm{KB}=4\textrm{TB}$ 。
![](https://img-blog.csdnimg.cn/ec1dda758cad44f4919f0de157f0823e.png)

## 8.3.2 空闲存储空间的管理
为了实现空闲存储空间的分配，系统应**记住空闲存储空间**的情况，以便实施存储空间的分配。下面介绍几种常用的空闲存储空间管理 `Free-Space Management` 方法。
### 1. 空闲文件目录
**文件存储设备上的一个连续空闲区**可以看作一个**空闲文件**，又称空白文件或自由文件。==空闲文件目录方法为所有这些空闲文件单独建立一个目录，每个空闲文件在该目录中占一个表项，表项的内容至少包括：空闲区序号、第一个空闲块的地址（物理块号）、空闲块数目等信息==。下表给出了一个空闲目录的例子。
![](https://img-blog.csdnimg.cn/3d938f11d4384324a84b3532feaf384e.png)
从表中可以看出，每个空闲文件在表中占据一个表项，其中存放空闲文件的第一个空闲块号、空闲块个数及相应的物理块号。例如表中的第 $1$ 项，其第一个空闲块号为 $5$ ，空闲块个数为 $3$ ，即该空闲文件的组成盘块依次为 $5, 6, 7$ 。

这种空闲文件目录方法，类似于**内存动态分区**的管理。显然，**<font color="red">只要将动态分区管理方法中的算法稍作修改，即可用于空闲文件目录方法</font>**。
- **当某用户请求分配存储空间时，系统依次扫描空闲文件目录，直到找到一个满足要求的空闲文件为止**。若空闲文件的大小与用户申请的空间大小相等，则将该表项从空闲文件目录中删除；==若该空闲文件的容量大于用户申请空间容量，则要对该空闲文件进行划分，一部分分配给用户，剩余部分仍然留在空闲文件目录中==。
- 当用户撤销一个文件时，系统回收该文件所占用的空间，这时也需要顺序扫描空闲文件目录。如果回收盘块与已有空闲文件邻接，则需要将它们合并为一个大的空闲文件；==若回收盘块与已有空闲文件不邻接，则应寻找一个空表项，并将回收空间的第一个物理块号及它所占的块数填到这个表项中==。

仅当文件存储空间中只有少量空闲文件时，这种方法才有较好的效果。如果存储空间中有大量的小空闲文件，则空闲文件目录将变得很大，因而其效率大为降低。**这种管理技术仅适用于连续文件**。

### 2. 空闲块链
空闲块链方法 `Linked Free Space List` **将文件存储设备上的所有空闲块（又称自由块或空白块）链接在一起**，并设置一个头指针指向空闲块链的第一个物理块，最后一个物理块的指针为空。这种对空闲文
件空间的管理方法类似于**文件的连接结构**，只是链表上的盘块都是空闲块而已。

当用户建立文件、申请分配存储空间时，就按需要从链首依次取下几个空闲块分配给文件。当撤销文件时，回收其存储空间，并将回收的空闲块依次链入空闲块链中。

这种方法的优点是**实现简单，但工作效率低**。因为每当在链表上增加或移去空闲块时，对空闲块链要做较大的调整，因而**会有较大的系统开销**。

一种改进方法是==将空闲块分成若干组，再用指针将组与组链接起来，将这种管理空闲块的方法称为**成组链接法**==。这种成组链接法，在进行空闲块的分配与回收时，要比空闲块链方法节省时间。

### 3. 位示图
这种方法是为文件存储器建立一张**位示图** `Bit Map`（也称位图），以反映**整个存储空间的分配情况**。在位示图中，每一个二进制位都对应一个物理块，当某位为 $1$ 时，表示对应的物理块已分配，若某位为 $0$ ，则表示对应的物理块空闲，如下图所示。
![](https://img-blog.csdnimg.cn/b19a54ec127e46dcbda4f294edadef55.png)
当请求分配存储空间时，系统顺序扫描位示图，并按需要从中找出一组值为 $0$ 的二进制位，再经过简单的换算就可以得到相应的盘块号，再将这些位置 $1$ 。当回收存储空间时，只需将位示图中的相应位清 $0$ 。

在位示图方法中，盘块分配分为三步：
- 系统顺序扫描位示图，从中找出一个（组）值为 $0$ 的二进制位。
- 再经过换算得到相应的盘块地址：$$\mathrm{盘块号=行号\times 每行二进制位数+列号}$$
- 修改位示图，将相应位置1。

盘块回收分两步：
- 将回收的盘块号转换成图中的行号、列号。
$$\begin{aligned}行号&=盘块号 / 每行二进制位数\\
列号&=盘块号 \bmod 每行二进制位数\end{aligned}$$
- 修改位示图，将相应位清 $0$ 。

**位示图的大小由磁盘空间的大小（物理块总数）确定**，因为位示图仅用一个二进制位代表一个物理块，所以它通常比较小，**可以保存在内存中**，这就使得存储空间的分配与回收较快。但这种方法实现时，需要进行位示图中二进制所在位置与盘块号之间的转换。
 
### 4. 成组链接法
UNIX系统采用成组链接法对空闲盘块加以组织。==它将若干个空闲盘块划归一组，将「每组中的所有盘块号」存放在「其前一组的第一个空闲盘块号」指示的盘块中，而将第一组中的所有空闲盘块号放入超级块的空闲盘块号表中==。成组链接法示意图如下：
![](https://img-blog.csdnimg.cn/243dd6917a284c548dc81895e8bed4a9.png)



**空闲盘块的分配**：当要分配一个盘块时，首先将「超级块空闲盘块号表」中下一个可用盘块分配出去；==如果所分配盘块号是超级块中「最后一个可用盘块号」，则先将该盘块中的内容读入超级块空闲盘块号表中，然后才将该盘块分配出去==。分配超级块中最后一个盘块号的例图如下：
![](https://img-blog.csdnimg.cn/465c44c51a1e4c6797650cccd791afef.png)
**空闲盘块的回收**：在回收空闲盘块时，如果超级块中的空闲盘块号表未满，可直接将回收盘块的编号放入空闲盘块号表中；==若空闲盘块号表已满，需先将空闲盘块号表中的所有盘块号、复制到新回收的盘块中，再将新回收盘块的编号放到超级块空闲盘块号表中，此块号就成了表中惟一的盘块号==。超级块已满时回收盘块的例图如下：
![](https://img-blog.csdnimg.cn/83f7cbf944cd476d9b78bfcaeef712f3.png)

---
# 8.4 文件目录管理
计算机系统中的文件种类繁多，数量庞大，为了有效地管理这些文件，提高系统查找文件的效率，应对它们**加以适当的组织**。文件的组织可以**通过目录来实现**。

## 8.4.1 文件目录
从文件管理的角度看，文件由**文件说明**和**文件体**两部分组成。**文件体即文件本身**，而==文件说明（又称为**文件控制块** `file control block, FCB` ）则是保存文件属性信息的数据结构，它包含的具体内容因操作系统而异==，但至少应包括以下信息： 
1. **文件名**。标识一个文件的符号名。每个文件必须具有唯一的名字，这样，用户可以按文件名进行文件操作。
2. **文件的结构**。**说明文件的逻辑结构**是记录式文件还是流式文件，若为记录式文件还需进一步说明记录是否定长、记录长度及个数；**说明文件的物理结构**是顺序文件、链接文件还是索引文件。
3. **文件的物理位置**。==指示文件在外存上的存储位置，包括存放文件的设备名、文件在外存的存储地址以及文件长度等==。文件物理地址的形式取决于物理结构，如连续文件应给出文件第一块的物理地址及所占块数，对于链接文件只需给出第一块的物理地址，而索引文件则应给出索引表地址。
4. **存取控制信息**。**指示文件的存取权限**，包括文件拥有者（也称做文件主）的存取权限，与文件主同组用户的权限和其他一般用户的权限。
5. **管理信息**。包括文件建立的日期及时间、上次存取文件的日期及时间以及当前文件使用状态信息。

==文件说明（文件控制块）的集合称为**文件目录**，一个文件控制块就是一个目录项==。目录最基本的功能就是通过文件名存取文件。一般来说，目录应具有如下几个功能：
1. 实现“按名存取”。**用户只需提供文件名，就可以对文件进行操作**。这既是目录管理的**最基本功能**，也是文件系统向用户提供的**最基本服务**。
2. 提高检索速度。这就需要在设计文件系统时合理地设计目录结构，对于大型文件系统来说，这是一个很重要的设计目标。
3. 减少命名冲突。为了便于用户按照自己的习惯来命名和使用文件，**文件系统应该允许对不同文件使用相同名称**。这时，文件系统可以**通过不同工作目录来加以解决**。
4. 允许文件共享。**在多用户系统中，应该允许多个用户共享一个文件**，这样就可以节省文件的存储空间，也可以方便用户共享文件资源。当然，还需要相应的安全措施，以保证不同权限的用户只能取得相应的文件操作权限，防止越权行为。

通常文件目录也作为一个文件来处理，称为**目录文件**。由于文件系统中一般有很多文件，故文件目录也很大，因此**文件目录并不放在内存中，而是放在辅存中**。当文件很多时，文件目录可能要占用大量的盘块。在检索目录文件的过程中，只用到了文件名，不需要其他的说明信息；仅当找到指定的文件时，才需要其他说明信息。因此有些系统采用了「将文件名与文件描述信息分开」的方法，即==把文件描述信息单独形成一个称为索引节点的数据结构，简称 $i$ 节点；而文件目录中的目录项则仅由文件名和所对应的 $i$ 节点组成==。**这样做可以减少平均启动磁盘的次数，降低系统开销**。

常用的文件目录结构有单级目录、二级目录和多级目录三种形式。

> DOS的文件控制块：文件名及扩展名占 `11` 字节；属性占 `1` 字节，包括**只读、隐藏、系统、卷标、子目录及归档**；上次存取时间及日期各占 `2` 个字节；文件**起始簇号**占 `2` 个字节；文件长度占 `4` 个字节。整个 `FCB` 的长度为 $32$ 字节。
![](https://img-blog.csdnimg.cn/b3cdbc2b446147a2bae809edbf9517bf.png)

## 8.4.2 单级目录结构
单级目录结构 `Single-Level Directory Structure`（或称一级目录结构）是最简单的目录结构。在整个文件系统中，**单级目录结构只建立一张目录表**，每个文件占据其中的一个表项，如下表所示。
![](https://img-blog.csdnimg.cn/1adbaa1d50be40b695eddd97e29a14cb.png)
- 当建立一个新文件时，首先应确定该文件名在目录中是否唯一，**若不与已有文件名冲突**，则从目录表中找出一个空表项，将新文件的相关信息填入其中。
- 在删除文件时，首先**从目录表中找到该文件的目录项**，从中找到该文件的物理地址，对文件占用的存储空间进行回收，然后**再清除它所占用的目录项**。
- 当对文件进行访问时，系统首先根据文件名去查找目录表、以确定该文件是否存在。如果文件存在，则找出文件的物理地址，进而完成对文件的操作。
 
单级目录结构的优点是易于实现，管理简单。但是存在以下缺点：
1. **不允许文件重名**。单级目录下的文件不允许和另一个文件有相同的名字，但是对于多用户系统来说，这又是很难避免的。即使是单用户环境，当文件数量很大时，也很难弄清到底有哪些文件，这就导致文件系统极难管理。
2. **文件查找速度慢**。对于稍具规模的文件系统来说，由于拥有大量的目录项，致使查找一个指定的目录项需要花费较长的时间。平均而言，查找一个文件需要扫描半个目录表。
## 8.4.3 二级目录结构
二级目录结构 `Two-level Directory Structure` 将文件目录分成**主文件目录** `master file directory, MFD` 和**用户文件目录** `user file directory, UFD` 两级。**系统为每个用户建立一个单独的用户文件目录**，其中的表项登记了该用户建立的所有文件及其说明信息。**主文件目录则记录系统中各个用户文件目录的情况**，每个用户占一个表项，表项中包括用户名、及相应用户目录所在的存储位置等。这样就形成了二级目录结构，如图8.9所示。
![](https://img-blog.csdnimg.cn/408d75ff37da44f4bdfd907c0c2751fa.png)
二级目录结构的操作：
- 当用户要访问一个文件时，系统先根据用户名，在主文件目录中查找该用户的文件目录，然后再根据文件名，在其用户文件目录中找出相应的目录项，从中得到该文件的物理地址，进而完成对文件的访问。
- 当用户想建立一个文件时，**如果是新用户**，即主文件目录表中无此用户的相应登记项，则**系统为其在主目录中分配一个表项**，并为其分配存放用户文件目录的存储空间，同时在用户文件目录中为新文件分配一个表项，然后在表项中填入有关信息。
- 文件删除时，只需**在用户文件目录中删除该文件的目录项**。如果**删除后该用户目录表为空**，则表明该用户已脱离了系统，从而可以**将主文件目录表中该用户的对应项删除**。

二级目录可以**解决文件重名问题**，并可**获得较高的查找速度**；但二级目录结构缺乏灵活性，特别是**无法反映真实世界复杂的文件组织形式**。
## 8.4.4 多级目录结构
为了让系统和用户更灵活方便地组织管理和使用各类文件，将二级目录的层次关系加以推广，便形成了多级目录结构，又称为**树型目录结构** `Tree-structured Directories Structure` 。
### 1. 目录结构
在多级目录结构中，第一级目录称为**根目录**（树根），目录树中的**非叶节点均为目录文件**（又称子目录），叶节点为数据文件。图8.10给出了多级目录结构示例。在图8.10中，矩形框表示目录文件，圆圈表示数据文件，文件旁标注的数字为系统赋予该文件的唯一标识符，目录中的字母表示目录文件或信息文件的符号名。例如，在图8.10中，根目录中含有三个子目录 $A, B, C$ ，子目录 $B$ 的内部标识符为 $3$ 。子目录 $B$ 又有三个子目录 $F, E, D$ ，其内部标识符分别为 $12, 13, 14$ 。每个子目录中包含若干个文件，如目录 $13$ 中有三个文件，其内部标识符为 $17, 18, 19$ ，其符号名为 $I, M, K$ 。
![](https://img-blog.csdnimg.cn/5d52f62a71be4835ae56f7cf05114c94.png)

### 2. 文件路径名
在多级目录结构中，往往使用路径名 `path name` 来唯一地标识文件。文件的路径名是一个**字符串**，该字符串由**从根目录出发到所找文件的通路上的、所有目录名与数据文件名用分隔符连接起来**而形成，从根目录出发的路径称为绝对路径 `absolute path` 。例如，图8.10中，文件 $10$ 的路径名为 `/A/A/A` ，文件 $20$ 的路径名为 `/B/D/A` 。
### 3. 当前目录
当多级目录的层次较多时，如果每次都要使用完整的路径名来查找文件，那么对用户来说将会感到不便，系统本身也需要花费很多时间进行目录搜索。为此应采取有效措施解决这一问题。

考虑到**一个进程在一段时间内所访问的文件通常具有局部性**，即在某一范围之内。因此，**可在这一段时间内、指定某个目录作为当前目录** `current directory`（或称工作目录）。进程对各文件的访问，都是相对于当前目录进行的，此时文件使用的路径名为相对路径 `relative path` ，它由**从当前目录出发到所找文件的通路上的、所有目录名与数据文件名用分隔符连接起来**而形成。系统允许文件路径往上走，并用 `..` 表示给定目录（文件）的父目录、用 `.` 表示当前目录。例如，假定系统的当前目录是目录文件 $12$ ，那么文件 $15$ 的相对路径名为 `J` 、绝对路径为 `/B/F/J` ，文件 $8$ 的相对路径名为 `../../C/G` 。
  
## 8.4.5 图形目录结构 
树型目录结构的自然推广就是图形目录结构 `Graph Directory` 。**它允许一个文件或目录出现在多个父目录中**。在 `UNIX` 中，这种结构称为**链接**。

---
# 8.5 文件共享及管理的安全性
实现文件共享是文件系统的重要功能。文件共享是指**不同的用户可以使用同一个文件**。==文件共享可以节省大量的辅存空间和主存空间，减少输入/输出操作，减少文件的不一致性，为用户间的合作提供便利条件==。文件共享并不意味着用户可以不加限制地随意使用文件，那样文件的安全性和保密性将无法保证。也就是说，**文件共享应该是有条件的，是要加以控制的**。因此，文件共享要解决两个问题，一是如何实现文件共享，二是对各类需要共享文件的用户进行操作权限的控制。

文件共享是指不同用户（进程）共同使用同一个文件，文件共享有时不仅为不同用户完成共同的任务所必须，而且还可以节省大量的外存空间，减少由于文件复制而增加的访问外存次数。

文件共享的动机是，用户因合作而要进行通信来交换相关信息，如共享管道文件进行通信；减少文件副本来节约访问时间和存储空间；保留一个文件副本可减少文件的不一致性。

共享就有可能引起访问冲突。**文件系统的共享语义 `file share semantics` 是文件系统对共享文件或目录冲突访问的处理方法**，有些参考文献也称为一致性语义 `consistency semantics` 。不同的文件共享语义定义了对于缓存一致性问题的不同解决方案。
## 8.5.1 文件共享
在20世纪60—70年代，已经出现了不少实现文件共享的方法，现代的一些文件共享方法、是在这些早期文件共享方法的基础上发展起来的。
### 1. 早期的文件共享方法
早期实现文件共享的方法有三种，即**绕道法、链接法和基本文件目录表**方法。
- 绕道法：要求**每个用户在当前目录下工作**，用户对所有文件的访问都是相对于当前目录进行的。**用户使用相对路径访问文件**。用户文件的路径名，是由当前目录到数据文件通路上所有各级目录的目录名、加上该数据文件的符号名组成。==当所访问文件不在当前目录下时，用户应从当前目录出发向上、返回到与所要共享文件所在路径的交叉点，再顺序向下访问到共享文件==。绕道法需要用户指定「所要共享文件的逻辑位置」或到达「被共享文件的路径」。显然，**绕道法要绕弯路访问多级目录，这使其搜索效率不高**。

- 链接法：为了提高共享其他目录中文件的速度，另一种实现文件共享的方法是**在相应目录表之间进行链接**。即**将一个目录中的链指针直接指向被共享文件所在的目录**，如图8.10中的虚线 $a$ 和 $b$ 。==采用这种链接方法实现文件共享时，应在文件说明中增加“连访属性”和“用户计数”两项==。前者说明**文件物理地址是指向文件、还是指向被共享文件的目录项**，后者说明**共享文件的用户数目**。若要删除一个共享文件，必须判别是否有多个用户共享该文件。若是，则只需将用户计数减 $1$ ；否则，才真正删除此共享文件。
![](https://img-blog.csdnimg.cn/966db4d84c154036bec07f7f3d892be7.png)

- 基本文件目录表方法：**把所有文件目录的内容分成两部分，一部分包括文件的说明信息**，如文件存放的物理地址、存取控制信息和管理信息等，**并由系统赋予唯一的内部标识符来标识**；另一部分则**由「用户给出的符号名」和「系统赋予文件说明信息的内部标识符」组成**。这两部分分别称为**符号文件目录表** `SFD` 和**基本文件目录表** `BFD` 。`SFD` 中存放文件名和文件内部标识符，`BFD` 中存放除了文件名之外的文件说明信息和文件的内部标识符。这样组成的多级目录结构如图8.11所示。
 ![](https://img-blog.csdnimg.cn/20e8e4872bae4ecfad6b260693bf47b3.png)
	在图8.11中，为了简单起见，未在 `BFD` 表项中列出说明信息的具体值。另外，在文件系统中，通常规定基本文件目录、空闲文件目录、主目录的标识符分别为 $0, 1, 2$ 。==采用基本文件目录表方法，可以较方便地实现文件共享。如果用户要共享某个文件，则只需要在相应的目录文件中增加一个目录项，在其中填上一个符号名及被共享文件的标识符==。
	例如在图8.11中，用户 `Li` 和用户 `Zhang` 共享标识符为 $6$ 的文件。对于系统来说，标识符 $6$ 指向同一个文件；而对 `Li` 和 `Zhang` 两个用户来说，则对应于不同的文件名 `Alpha` 和 `Beta` 。

### 2. 基于索引节点的共享方式
当几个用户在同一个项目里工作时，他们常常需要共享文件。为此，可以将共享文件链接到多个用户的目录中，如图8.12所示，其中 $C$ 的一个文件现在也出现在 $B$ 的目录下，**$B$ 称为该共享文件的一个链接**。此时，该文件系统本身是一个有向图，而不是一棵树。
![](https://img-blog.csdnimg.cn/030befd9cf0340c3a86b20ccc51de8a3.png)

实现文件共享很方便，但也带来一些问题。如果目录中包含文件的物理地址，则在链接文件时，必须将文件的物理地址复制到 $B$ 目录中去。但==如果 $B$ 或 $C$ 随后又往该文件中添加内容，则新的数据块将只会出现在进行添加操作的用户目录中，这种改变对其他用户而言是不可见的，因而新增加的这部分内容不能被共享==（？）。

为了解决这个问题，可以**将文件说明中的文件名和文件属性信息分开**，使文件属性信息单独构成一个数据结构，这个数据结构称为索引节点（又称 $i$ 节点），而文件目录中的每个目录项、仅由文件名及该文件对应的 $i$ 节点号构成，如图8.13所示。此时，==任何用户对文件的修改都会反映在索引节点中，其他用户可以通过索引节点存取文件，因此文件的任何变化对于所有共享它的用户都可见==。
 ![](https://img-blog.csdnimg.cn/9860458e5a0d4d0d87ad45dfae63e8cd.png)

**在索引节点中还应有一个链接计数 $count$ 字段，用于表示链接到本索引节点的目录项的数目**。当 $count=2$ 时，表示有两个目录项链接到本文件上。例如，当用户 $C$ 创建一个新文件时，他是该文件的所有者，此时 $count = 1$ 。当有用户 $B$ 希望共享此文件时，应在用户 $B$ 的目录中增加一个目录项，并设置指针指向该文件的索引节点，此时文件的所有者仍然是 $C$ ，但索引节点的链接计数应加 $1$ ，即此时 $count =2$ 。如果以后用户 $C$ 不再需要该文件，此时系统只是删除 $C$ 的目录项（若删除该文件，也将删除该文件的索引节点，这使B的指针悬空），并将 $count$ 减 $1$ ，即此时 $count=1$ ，如图8.14所示。此时，只有 $B$ 拥有指向该文件的目录项，而该文件的所有者仍然是 $C$ 。如果系统进行记账或配额，$C$ 将继续为该文件付账、直到 $B$ 不再需要它，此时 $count=0$ ，该文件被删除。
![](https://img-blog.csdnimg.cn/4dfb5e01954e479b8adfd079de0ed5e1.png)

这种基于索引节点的共享方式也称为**硬链接** `hard link` ，它通过在不同目录项中、对多个文件名设置相同索引节点号、以链接 `link` 到同一个索引节点，来共享同一个文件。**硬链接的不足是无法跨越文件系统**。

> **磁盘索引节点**：每个文件有一个惟一的索引节点，主要包含：文件主标识；文件类型：正规、目录、特别；文件存取权限；文件物理地址；文件长度；==文件链接计数：目录树中指向此文件的路径数==；文件存取时间。
> **内存索引节点**：**文件打开时，要将磁盘索引节点拷贝到内存**。内存索引节点除包含磁盘索引节点内容外，还应增加：索引节点号；状态：索引节点是否上锁、修改；==访问计数：正在使用此文件的进程数==；文件所属文件系统的逻辑设备号；链接指针：如空闲队列、散列队列。

### 3. 利用符号链接实现文件共享
利用符号链接也可以实现文件共享。**它是一种特殊类型的文件，其内容是到另一个目录或文件路径的链接**。建立符号链接文件，并不影响原文件，实际上它们各是一个文件。可以建立任意符号链接，甚至原文件是在其他计算机上。

例如，$B$ 为了共享 $C$ 的一个文件 $F$ ，这时可以由系统创建一个 `LINK` 类型的新文件，并把新文件添加到 $B$ 的目录中，以实现 $B$ 的一个目录与文件 $F$ 的链接。**新文件中只包含被链接文件 $F$ 的路径名，称这种链接方式为符号链接**，也称为软链接。当用户 $B$ 要访问被链接的文件 $F$ 时，操作系统发现要读的文件 $F$ 是 `LINK` 类型的文件，因此由操作系统根据 `LINK` 文件中的路径名去读该文件，从而实现了用户 $B$ 对文件 $F$ 的共享。
![](https://img-blog.csdnimg.cn/2f92d6d3de6d42c883d30bad34935888.png)

在利用符号链接实现文件共享时，==因为只有文件所有者拥有指向其索引节点的指针，共享该文件的用户只有其路径名、而没有指向索引节点的指针。当文件所有者删除文件后，其他用户若试图通过符号链接访问该文件将导致失败，因为系统找不到该文件，于是将符号链接删除==。

**符号链接的不足是需要额外的开销**。当其他用户去读共享文件时，系统是根据给定的文件路径名逐个分量进行查找的，这些操作需要多次访问磁盘，使得共享文件的访问开销很大。另外，符号链接需要配置索引节点、以及一个磁盘块用于存储路径，这也要消耗一些磁盘空间。

符号链接的优点是，**只要提供一个机器的网络地址、以及文件在该机器上的驻留路径，就可以链接全球任何地方的机器上的文件**。

上述两种链接共享方法都存在一个共同的问题，即每一个共享文件都具有多个文件名，也就是说，每增加一个链接，就增加一个文件名。

---
## 8.5.2 文件保护 
==系统中的文件既存在保护问题，又存在保密问题==。
- 文件保护是指避免文件拥有者或其他用户、因有意或无意的错误操作使文件受到破坏。
- 文件保密是指文件本身不得被未授权的用户访问。

**这两个问题都涉及用户对文件的访问权限**，即文件的存取控制。在实现文件存取控制时，不同系统采用了不同的方法。下面介绍几种常用的文件存取控制方法。
### 1. 存取控制矩阵
存取控制矩阵是一个二维矩阵，其中一维列出**使用该文件系统的全部用户**；另一维列出**存入系统中的全部文件**。矩阵中的每一个元素，用来表示**某个用户或用户组对某个文件的存取权限**，存取权限可以为读、写、执行以及它们的任意组合。表8.6给出了一个存取控制矩阵的例子，其中 $R$ 表示读，$W$ 表示写，$E$ 则表示执行，例如表中用户 `ZHAO` 对文件 `ALPHA` 可以进行读和写操作。
![](https://img-blog.csdnimg.cn/757f7818cdee452ba27af36ce2678397.png)
当一个用户向文件系统提出存取请求时，由存取控制验证模块利用存取控制矩阵，将本次请求和该用户对这个文件的存取权限进行比较，如果不匹配就拒绝执行。

存取控制矩阵法的优点是**简单、清晰**，缺点是**不够经济**。存取控制矩阵通常放在内存，该矩阵本身占据了大量空间，管理起来也较复杂，尤其是当文件系统很庞大时更是如此。例如，若某系统有 $500$ 个用户，他们共有 $20 000$ 个文件，那么这个存取控制矩阵就有 $500×20 000=10 000 000$ 个元素，它将占据相当大的存储空间，查找这么大的表，既不方便又很费时，而且每增加或减少一个用户或文件都要修改存取控制矩阵。因此，**存取控制矩阵法没有得到普遍应用**。
 
### 2. 存取控制表
分析一下存取控制矩阵，可以发现某一个文件只与少数几个用户有关。也就是说**存取控制矩阵是一个稀疏矩阵**，因而可以对它进行简化，即**减少不必要的登记项**（用户名或文件名）。为此，我们可以**按用户对文件的存取权限，将用户分成若干组**，同时**规定每一组用户对文件的存取权限**。这样，==「所有用户组存取权限的集合」称为该文件的存取控制表==，表8.7给出了一个存取控制表的示例。
![](https://img-blog.csdnimg.cn/9f206a334d714d6cb6e9c8ee8df9f1f3.png)
从表8.7中可以看出，文件拥有者可以读、写和执行 `ALPHA` ，用户组 `A` 可以读和写该文件，用户组 `B` 可以执行该文件，其他用户对该文件没有任何操作权限。

显然，这种方法实际上是对存取控制矩阵的一种改进，==它不像存取控制矩阵那样，对整个系统中所有文件的访问权限进行集中控制，而是**对系统中的每个文件设立一个存取控制表**==。由于文件存取控制表的表项数较少，可以把它放进我们前面讲过的文件目录中。当文件打开时，它的文件目录项被复制到内存，供存取控制验证模块检验存取的合法性。
### 3. 用户权限表
==用户权限表是将「一个用户或用户组所要存取的文件名」集中存放在一个表中，其中每个表项指明该用户或用户组对相应文件的存取权限，这种表称为**用户权限表**==。表8.8给出了一个用户权限表的示例。

从表8.8中可以看出，用户组 `A` 对文件 `SQRT, TEST` 可以读和执行，对文件 `ALPHA, BETA` 只能读。通常，把所有用户权限表集中存放在一个特定的存储区中，且只允许存取控制验证模块访问这些权限表，这样就可以达到有效保护文件的目的。当用户对一个文件提出存取要求时，系统通过查找相应的权限表，就可以判定其存取的合法性。
![](https://img-blog.csdnimg.cn/c96c4b72acb74a408a6e424ad9f0a407.png)
### 2. 口令
上述三种文件保护方法都要建立相应的权限控制表格，这些表格本身需占据一定的存储空间，而且由于表格的长度不一，使得管理比较复杂。为此，又提出了**一种简单可行的文件保护办法**，即**口令**。

使用口令的方法时，==文件主为自己的每个文件规定一个口令，一方面进行口令登记，另一方面把口令告诉允许访问该文件的用户==。文件的口令通常登记在该文件的目录中，或者登记在专门的口令文件中。当用户请求访问某文件时，首先要提供该文件的口令，经系统证实口令正确后才允许访问文件。

口令方法的优点是**只需为每个被保护文件提供少量的保护信息**，口令的管理也比较简单且口令方法易于实现。但该方法也存在一些缺点，如**口令的保密性不强，不易更改存取权限**等。如果你想让别的用户存取你的文件，就必须把该文件的口令告诉他们。操作员和系统管理员可能会得到系统的全部口令，因为文件的口令全部登记在系统中。如果某文件主希望收回某个持有口令的用户继续访问他的文件的权限，该文件主只能更改文件的访问口令，而且还需要将新口令告诉其他能访问该文件的用户。因此，==这种方法常用于识别系统的合法用户，而存取权限则用其他方法实现==。
### 3. 密码
防止文件泄密以及控制存取访问的另一种方法是**密码**，该方法是**对需要保护的文件进行加密**。这样，虽然所有用户均可以存取该文件，但是只有那些掌握了译码方法的用户，才能读出正确的信息。

==文件写入时的编码、及读出时的译码，都由系统存取控制验证模块承担，但要求发出存取请求的用户提供一个变元——代码键==。一种简单的编码方式是，**利用代码键作为生成一串随机数的起始码，编码程序把这些随机数加到被编码文件的字节中去**；译码时，**用和编码时相同的代码键启动随机数发生器，并从存入文件的各字节中依次减去所产生的随机数，这样就能恢复原来的数据**。由于只有核准的用户才知道这个代码键，因而他可以正确地存取该文件。

在密码方法中，由于代码键不存入系统，仅当用户要存取文件时，才需要将代码键输入给系统。这样，对于那些不诚实的系统管理员来说，由于他们在系统中找不到各个文件的代码键，所以也就无法偷读或篡改他人的文件了。

密码技术具有**保密性强、节省存储空间**的优点，但**编码和译码要花费一定的时间**。
## 8.5.3 文件的转储和恢复
 全量转储的不足：转储期间应停止对文件系统进行其他操作，**转储时间长**。
- 增量转储 `incremental backup` ：将**上次转储以来修改过**的文件和**新增加**的文件**转储到某存储介质上**。增量转储能使系统遭到破坏后，**恢复到数小时前文件系统的状态**，从而**使得所造成的损失减到最小**。
在实际工作中，两种方法要配合使用，根据实际情况，确定全量转储的周期和增量转储的时间间隔。
### 1. 全量转储
全量转储 `full backup` 方法要求将文件存储器中的所有文件定期备份，转储到某存储介质上，如磁盘或磁带。**一旦系统出现故障破坏了文件信息，便可以将最近一次转储的内容复制到文件系统中去**，使系统恢复到上次转储时的状态。这种方法虽然简单，但有如下缺点：
1. 在转储期间，应停止对文件系统进行其他操作，以免造成混乱。因此，==全量转储影响系统对文件的操作，因而不应转储正在打开进行写操作的文件==。
2. 转储时间长。如果使用磁带，一次转储可能长达几十分钟，因此不能经常进行，一般每周一次。==这样，从转储介质上恢复的文件系统，可能与被破坏前那一时刻的文件系统差别较大==。
### 2. 增量转储
增量转储是一种部分文件的转储，即将「上次转储以来修改过的文件和新增加的文件」转储到某存储介质上。可以每隔一定时间进行一次增量转储，如几小时。==增量转储能使系统在遭到破坏后，恢复到数小时前文件系统的状态，从而使得所造成的损失减到最小==。
### 3. 文件恢复
在实际工作中，文件转储非常重要，不可忽视，否则会造成前功尽弃或无法弥补的后果。在进行文件转储时，**两种方法要配合使用**，根据实际情况，确定全量转储的周期和增量转存的时间间隔。一旦系统发生故障，文件系统的恢复过程大致如下：
1. **从最近一次全量转储中装入全部系统文件**，使系统得以重新启动，并在其控制下进行后续的恢复工作。
2. **从近到远从增量转储盘上恢复文件**。同一个文件可能曾被转储过若干次，但只恢复最近一次转储的副本，其他的转储副本则被略去。

---
# 8.6  文件使用
为使用户能灵活方便地使用和控制文件，文件系统提供了一组进行文件操作的系统调用命令。最基本的文件操作命令有建立文件、删除文件、打开文件、关闭文件、读文件和写文件。

当用户想把一批信息作为文件保存时，可用建立文件命令向系统提出建立文件的要求。当建立新文件时，系统首先要**为新文件分配必要的外存空间**，并在文件系统的目录中**为之建立一个目录项**。目录项中**应记录新文件的文件名**、及其**在外存的存放地址等属性**。

当一个文件不再使用时，可用删除文件命令将文件删除。在删除文件时，系统应**先从目录中找到要删除文件的目录项**，使之成为空闲目录项，然后**回收该文件所占用的存储空间**。

所谓读文件就是把文件中的数据从外存读入内存的用户区。在读一个文件时，需要给系统提供文件名和存放读出内容的内存地址。此时，系统同样要查找目录，找到指定文件的目录项，从中得到被读文件在外存的地址，然后**从外存将数据读入内存**。

当用户要求对文件添加和修改信息时，可用写文件命令将信息写入文件。在写一个文件时，需要给系统提供文件名和要写入信息在内存的地址。为此，系统也同样要查找目录，找到指定文件的目录项，再**利用目录中的文件指针将信息写入文件**。

为了避免用户在每次访问文件时从外存中查找文件目录，系统提供了打开文件命令。该命令的功能是**将待访问文件的目录信息读入内存活动文件表中，建立起用户和文件的联系**。一旦文件被打开就可以多次使用，直到文件被关闭为止。==在有些系统中，也可以通过读命令隐含地向系统提出打开文件的要求。若在读写命令中不包含打开文件功能，则在使用文件之前，必须先打开文件==。

若文件暂时不用，应将其关闭。关闭文件的功能是**撤销内存中有关该文件的目录信息，切断用户与该文件的联系**；若在文件打开期间，该文件作过某种修改，则应将其写回辅存。文件关闭之后，若要再次访问该文件，则必须重新打开。
