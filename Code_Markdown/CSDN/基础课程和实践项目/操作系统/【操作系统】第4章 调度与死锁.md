


@[toc]

本章内容：
-  掌握调度的类型和方式
- 掌握**常用进程调度算法**及其特点
- 掌握死锁的概念、死锁产生的原因及必要条件、**死锁的处理方法**
- 深入领会**银行家算法**

一个作业从**提交到完成**通常要经历**多级调度**。
# 4.1  调度的层次
在不同操作系统中所**采用的调度层次不完全相同**。有的系统中仅采用一级调度，而在另一些系统中则可能采用两级或三级调度。 

处理机的三级调度：
- 作业调度
- 进程调度
- 交换调度
<img src="https://img-blog.csdnimg.cn/20200412102900400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
## 4.1.1 作业调度Job scheduler
作业调度又称高级调度、宏观调度或长程调度(`Long-term scheduler`)，其主要任务是**按一定的原则**从**外存上**处于后备状态的作业中**选择一个或多个作业**，给它们**分配内存**、**输入/输出设备**等必要的资源，并**建立相应的进程**，以使该作业具有获得竞争处理机的权利。

作业调度的**运行频率较低**，通常为几分钟一次。

## 4.1.2  进程调度Process scheduler
进程调度又称低级调度、微观调度或短程调度(`Short-term scheduler`) ，其主要任务是**按照某种策略和方法**从就绪队列中**选取一个进程**，将处理机分配给它。

进程调度的**运行频率很高**，一般几十毫秒要运行一次。 

## 4.1.3 中级调度
中级调度又称中程调度(`Medium term scheduling`)或交换调度，其功能是将**内存中暂时不用的信息移到外存**，以**腾出空间**给内存中的进程使用，或将需要的信息从外存读入内存。

引入中程调度的目的是**提高内存利用率和系统吞吐量**。中级调度的运行频率介于两者之间。
 
## 4.1.4  调度性能评价
由于**操作系统的类型及目标不同**，因此选择的**调度策略及算法**也不同。

有很多评价准则，下面介绍几种主要的评价准则：
- CPU利用率(`CPU utilization`)高
- 系统吞吐量大。系统吞吐量(`throughput`)表示单位时间内CPU完成作业的数量。
- 周转时间(`turnaround time`)短。
- 响应时间快。响应时间(`response time`)是指**从用户提交请求到系统首次产生响应**所用的时间。 

周转时间 `Turnaround time`：作业的周转时间是指**从作业提交**到**作业完成**之间的**时间间隔**。
平均周转时间是指**多个作业**的周转时间的平均值。$n$ 个作业的平均周转时间（$T_i$ 为作业 $i$ 的周转时间）：
   $$T =(T_1 + T_2+ ... ＋T_n)/n$$
带权周转时间：
- 带权周转时间是指**作业周转时间**与**作业实际运行时间**的**比**。
- 平均带权周转时间是指**多个作业**的带权周转时间的平均值。$n$ 个作业的平均带权周转时间：
 $$W＝(W_1＋W_2＋ ... ＋W_n) /n$$（$W_i$ 为作业 $i$ 的带权周转时间）

---
# 4.2  作业调度
**作业**是用户**在一次解题或一个事务处理过程中**要求计算机系统所做**工作的集合**，包括用户程序、所需的数据及命令等。

计算机系统在**完成一个作业的过程**中所做的**一项相对独立的工作**称为一个**作业步**。

例如，在编制程序过程中通常要进行编辑输入、编译、链接、运行几个作业步。 

## 4.2.1 作业的状态及转换
作业从提交到完成要经历**四种状态**：
- 提交状态：用户作业由**输入设备**向**系统外存输入**时作业所处的状态。
- 后备状态：作业**输入到外存**后，系统为其**建立了作业控制块**，并把它**插入到后备作业队列**中**等待调度**运行。
- 运行状态：作业**在内存中执行**。
- 完成状态：作业**正常或异常结束**，但作业占有的资源还未被系统全部回收。 

作业状态转换图：
<img src="https://img-blog.csdnimg.cn/20200412112345769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
作业调度程序**主要完成以下工作**：
- 记录进入系统的**各个作业情况**；
- 从后备作业中**挑选一些作业**投入执行；
- 为被选中的作业做好执行前的**准备工作**；
- 在作业运行结束或运行过程中因某种原因需要撤离时，作业调度程序还要完成作业的善后处理工作。

## 4.2.2 作业控制块
为管理作业，系统**设置了作业控制块**。系统通过JCB感知作业的存在，`JCB` 是**作业存在的唯一标志**。通常作业控制块中包括的主要内容有：
- 资源要求：是指作业运行需要的资源情况，包括：估计运行时间、最迟完成时间、需要的内存容量、外设类型及数量等。
- 资源使用情况：包括作业进入系统的时间、开始运行时间、已运行时间、内存地址、外设台号等。
- 作业的控制方式、类型和优先级等：
作业的控制方式有**联机作业控制**和**脱机作业控制**；
从不同角度出发可以对作业进行不同的分类，如终端型和批量型；
作业的优先级是指**作业进入系统运行的优先级别**，优先级高的作业可以优先进入系统运行。
- 作业名、作业状态：记录**作业的标识信息**及**作业的当前状态**。
 

---
# 4.3 进程调度
## 4.3.1 进程调度的功能
进程调度程序主要完成以下功能：
- 记录系统中**所有进程**的**状态、优先数和资源情况**。
- 选择获得处理机的进程。
- 实施处理机的**分配及回收**。

引起进程调度的原因：
- 正在运行进程**结束**；
- 运行进程因某种原因**阻塞**，如P操作、I/O等；
- 从系统调用或中断返回时，**有进程进入就绪队列**且**就绪队列为空**，**或**进程优先级**高于**当前运行进程且**为剥夺调度方式**；
- 时间片用完
## 4.3.2 进程调度的方式
进程调度有两种方式：
- 抢占(`Preemptive`)方式：又称剥夺方式、可剥夺方式。这种调度方式是指允许**调度程序**根据某种原则**去停止正在执行的进程**，将已分配给该进程的**处理机重新分配给其他进程**。抢占原则有：优先权、时间片。 
- 非抢占(`Nonpreemptive`)方式：又称非剥夺方式、不可剥夺方式、不可抢占方式。这种调度方式是指**一旦将处理机分配给某进程后**，便**让该进程一直执行**，直到该进程**完成**或发生某事件而进入**阻塞**状态，才把处理机分配给其他进程。
非抢占方式中引起进程调度的因素有：**进程结束**、因某种原因而**阻塞**、执行**同步原语**等。
特点：简单，系统开销小，但无法处理紧急任务。

---
# 4.4  调度算法
调度算法(`Scheduling Algorithms`)是指根据**系统资源分配策略**所规定的**资源分配算法**。本章的算法有些适合作业调度，有些适合进程调度，有些适用于两者。

## 4.4.1 先来先服务调度算法First-come, first-served
先来先服务算法既可用于**作业调度**，也可用于**进程调度**。
- 在作业调度中：从**后备作业队列**中选择一个或多个**最先进入该队列**的作业，将它们调入内存，为它们**分配资源，创建进程**，然后**放入就绪队列**。
- 进程调度中：从就绪队列中选择一个**最先进入该队列的进程**，为之分配处理机，使之投入运行。该进程**一直运行到完成**或因等待某一事件而**阻塞**时**才释放处理机**。

设有 `4` 道作业，它们的**提交时间及执行时间**如下表，若按**先来先服务调度算法**进行调度，试计算 `4` 个作业的**平均周转时间**和**平均带权周转时间**。（时间单位：小时，以十进制计算）。
<img src="https://img-blog.csdnimg.cn/20200412112545959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
**作业周转时间**及**带权周转时间**的计算：
<img src="https://img-blog.csdnimg.cn/20200412112554775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
先来先服务算法特点：
- 算法简单，易于实现，
- 但不利于短作业及**I/O繁忙型**作业。 

## 4.4.2 短作业优先调度算法Shortest-job-first
在作业调度中，从后备队列中选择一个或多个**估计运行时间最短的作业**，将它们**调入内存**运行。

在进程调度中，从就绪队列中选择一个**估计运行时间最短的进程**，为之**分配处理机**，使之投入运行。该进程一直运行到完成或因等待某一事件而阻塞时才释放处理机。

<img src="https://img-blog.csdnimg.cn/20200412112625711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">

短作业优先调度算法的特点：算法调度性能较好，如上例中：
|        | 先来先服务   |       短作业优先 |
|:--:|:--:|:---:|
|平均周转时间 |               2.8        |             2.45 
|平均带权周转时间  |       5.25      |             3.85

但**对长作业不利**，**未考虑作业的紧迫程度**，运行时间为估计。

## 4.4.3 最短剩余时间优先调度算法
最短进程优先调度算法可以是**非抢占式**的，也可以是**抢占式**的。若无特别说明，通常是**指非抢占式的算法**。

**抢占式**的最短进程优先调度算法也称为**最短剩余时间优先调度算法**(`shortest-remaining-time-first`)，即<b><font color="#ff0000">当一个新进程进入就绪队列时，若其需要的运行时间比当前运行进程的剩余时间短，则它将抢占CPU</font></b>。

下图是抢占式的最短进程优先调度算法的示例，也就是最短剩余时间优先：
<img src="https://img-blog.csdnimg.cn/20200412112651370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
平均周转时间：$T=(17＋4＋24＋7)\ /\ 4=13$
平均带权周转时间：$W=(2.125＋1＋2.67＋1.4)\ /\ 4=1.8$
 
最短平均周转时间：当**一批作业同时到达**时，**最短作业优先调度**算法才能获得**最短平均周转时间**。
设一组作业 $p_1, p_2, ..., p_n$ ，其运行时间为 $t_1, t_2,  ..., t_n$ ，且假定 $t_1 <t_2< …<t_n$，则**短作业优先调度**算法的总周转时间为：
$$t_1+(t_1+t_2)+ … + (t_1+ … +t_n) =n*t_1+(n-1)t_2+ ... +t_n$$

可以证明：若 $a_1≤ a_2≤ … ≤ a_n$ 且 $b_1≤b_2≤ … ≤b_n$ ，则
$$a_1b_n+a_2b_{n-1} +…+a_nb_1 ≤ a_1b_{i_1}+a_2b_{i_2} +…+a_nb_{i_n}  ≤ a_1b_1+a_2b_2 +…+a_nb_n$$
其中 $i_1$、$i_2$、 …、$i_n$ 是 `1, 2, ... , n`的一个排列。


## 4.4.4 优先级调度算法
在作业调度中，从后备作业队列中选择**若干优先级高的作业**调入内存。
在进程调度中，将处理机分配给**就绪队列**中**优先级最高的进程**。

优先级(`Priority`)表示进程的重要性及**运行优先性**，通常用优先数来衡量。在某些系统中，优先数越大优先级越高；而在另一些系统中，优先数越大优先级越小。

按调度方式对优先级调度算法分类：
- **非抢占式**优先级调度算法：系统一旦**将处理机分配给就绪队列中优先级最高的进程**后，该进程便**一直运行下去**，直到完成或因发生某事件使该进程放弃处理机时，系统才将处理机分配给另一个更高优先级的进程。
- **抢占式**优先级调度算法：**将处理机分配给优先级最高的进程**，使之运行。在进程运行过程中，**一旦出现了另一个优先级更高的进程时**，进程调度程序就**停止原运行进程**，而将处理机分配给新出现的高优先级进程。 

优先级分为两种：
- 静态优先级：是在**创建进程时确定**的，确定之后**在整个进程运行期间不再改变**。特点：简单易行，系统开销小，**但不精确**。
确定依据有：
	- 进程类型：系统，用户
	- 进程对资源的需求：执行时间，资源数量
	- 用户要求：紧迫程度

- 动态优先级：是指在创建进程时，根据进程的特点及相关情况**确定一个优先级**，**在进程运行过程中**再根据情况的变化**调整优先级**。确定原则有：占用CPU时间，等待时间。
例：`优先数 = CPU使用时间 / 2 + 基本优先数`
	- CPU使用时间衰减函数:
	- `Decay(CPU使用时间) = CPU使用时间 / 2`

## 4.4.5  时间片轮转调度算法
### 1. 算法介绍和示例
时间片轮转法(`Round Robin`)：系统将**所有就绪进程**按**到达时间的先后次序**排成一个队列，每次调度时**把CPU分配给队首进程**，并令其**执行一个时间片**。当时间片用完时，停止该进程的执行，将它送至就绪队列末尾等待下一次执行，然后**再把处理机分配给就绪队列中的新队首进程**。如此不断循环，直至完成为止。

设有 `A、B、C、D、E` 五个进程，其到达时间分别为 `0、1、2、3、4` ，要求运行时间依次为 `3、6、4、5、2` ，采用**时间片轮转调度算法**，当时间片大小为 $1$ 和 $4$ 时，试计算其**平均周转时间**和**平均带权周转时间**。

① 时间片大小为 $1$：`A、B、C、D、E` 要求运行时间依次为 `3、6、4、5、2`，到达时间依次为 `0、1、2、3、4` 。          
<img src="https://img-blog.csdnimg.cn/20200412112818438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%"><img src="https://img-blog.csdnimg.cn/20200412112825455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
② 时间片大小为 $4$：`A、B、C、D、E` 要求运行时间依次为 `3、6、4、5、2` ，到达时间依次为 `0、1、2、3、4` 。 
<img src="https://img-blog.csdnimg.cn/20200412112904748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%"><img src="https://img-blog.csdnimg.cn/20200412112913846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
### 2. 时间片大小的选择和考虑
 时间片大小的选择：
- 若时间片太大，所有进程都能**在一个时间片内**完成，则时间片轮转算法**退化为先来先服务**；
- 若时间片太小，则**进程调度频繁**，**系统开销增加**。
- 因此时间片大小选择应适当。
- 现代操作系统的时间片一般为 `10-100ms` ，**上下文切换时间一般少于** `10us` 。

**确定时间片大小**应考虑的因素：
- 系统对响应时间的要求：`响应时间=时间片*进程数`。进程数一定，则**时间片与系统响应时间成正比**。
- 就绪队列中的进程数目：**时间片与就绪进程数成反比**。
- 系统处理能力：人所能承受的响应时间一定，系统速度快则时间片可增长。

### 3. 时间片轮转算法的特点及改进
对**偏重I/O的进程不公平**。为此**改进为虚拟时间片轮转算法**。

虚拟时间片轮转算法：新进程基于 `FCFS` 进入就绪队列，进程**用完时间片后也进入就绪队列**；进程**因I/O阻塞进入I/O队列**，I/O完成时**进程进入附加队列**，<font color="#FF0000">**附加队列的优先级高于就绪队列**</font>，当进程从附加队列被调度时，**其运行时间不超过上次发生中断时剩余的时间**。

虚拟时间片轮转调度示意图：
<img src="https://img-blog.csdnimg.cn/20200412112953625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
## 4.4.6 高响应比优先调度算法
高响应比优先调度算法是对**短作业优先调度**算法和**先来先服务调度**算法的一种**综合**。

响应比定义如下：`响应比 ＝ 作业响应时间 / 估计运行时间`。由于响应时间为**作业进入系统后的等待时间**加上**估计运行时间**。因此 `响应比＝1＋作业等待时间 / 估计运行时间`。

高响应比优先调度算法思想：在每次调度作业运行时，先**计算后备作业队列**中每个作业的**响应比**，然后**挑选响应比最高者投入运行**。
特点：
- 有利于短作业-----等待时间相同，短作业优先，
- 考虑等待时间----运行时间相同，等待时间长的作业优先运行。

最高响应比优先算法例子：
设有 `A、B、C、D、E` 五个进程，其到达时间分别为 `0、1、2、3、4` ，要求运行时间依次为 `3、6、4、5、2` ，采用**最高响应比优先调度算法**，试计算**其平均周转时间**和**平均带权周转时间**。
答：分析作业的调度顺序：`A、B、C、D、E` 的到达时间依次为 `0、1、2、3、4` ，要求运行时间依次为 `3、6、4、5、2`。
- 0：$A$ 运行，`BCD` 依次到达；
- 3：$r_B =1+2/6$，$r_C =1+1/4$ ，$r_D =1$；$B$ 先运行；
- 9：$r_C =1+7/4$，$r_D =1+6/5$，$r_E =1+5/2$；$E$ 先运行。
- 11：$r_C =1+9/4$，$r_D =1+8/5$；$C$ 先运行。

由此可知作业的运行顺序为 `A、B、E、C、D`。 周转时间的计算：顺序`A、B、E、C、D`：
<img src="https://img-blog.csdnimg.cn/20200412113046859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">

---
## 4.4.7  多级队列调度算法Multilevel Queue Scheduling
实现思想：根据**作业性质或类型**不同，**将进程就绪队列分为多个**，每个队列**采用不同的调度算法**。

例如：终端型作业为前台作业，批处理作业为后台作业。**前台采用时间片轮转算法**，**后台采用先来先服务**，前台作业的**优先级高**。

## 4.4.8 多级反馈队列调度算法Multilevel Feedback Queue Scheduling
应设置**多个就绪队列**，并**为每个队列赋予不同的优先级**。第 $1$ 个队列的**优先级最高**，第2队列次之，其余队列的**优先级逐次降低**。

每个队列中**进程执行的时间片大小也各不相同**，进程所在队列的**优先级越高**，其相应的**时间片就越短**。

当一个新进程进入系统时，**首先**将它放入第 $1$ 个队列的末尾，按**先来先服务**的原则排队等待调度。当轮到该进程执行时，**如能在此时间片内完成，便可准备撤离系统**；如果它在一个时间片结束时**尚未完成**，调度程序便将该进程转入第 $2$ 队列的末尾，再**同样地按先来先服务**原则等待调度执行。如此下去，<b><font color="#ff0000">最后一个队列中使用时间片轮转调度算法</font></b>。

**仅当第 $1$ 个队列为空时**，调度程序才调度第 $2$ 队列中的进程运行；仅当第 $1$个至第 $i－1$ 个队列均为空时，才会调度第 $i$ 个队列中的进程运行。

当处理机**正在为第 $i$ 个队列中的某进程服务**时，若又**有新进程进入优先级较高的队列**中，则此时**新进程将抢占正在运行进程的处理机**，即由调度程序**把正在执行进程放回第 $i$ 个队列末尾**，重新将处理机分配给新进程。
<img src="https://img-blog.csdnimg.cn/20200412113114870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
示例：设有 `A、B、C、D、E` 五个进程，其到达时间分别为 `0、1、3、4、5` ，要求运行时间依次为 `3、8、4、5、7`，采用**多级反馈队列调度算法**，系统中共有 `3` 个队列，其时间片依次为 `1`、`2` 和 `4`，试计算其**平均周转时间和平均带权周转时间**。

答：`A、B、C、D、E` 到达时间依次为 `0、1、3、4、5`，要求运行时间依次为`3、8、4、5、7` 。          
<img src="https://img-blog.csdnimg.cn/20200412113145136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
<img src="https://img-blog.csdnimg.cn/20200412113135239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
多级反馈队列调度算法的性能**能较好满足各类用户的需求**：
- 终端型用户：**大多能在一个时间片内完成**，响应时间较短；
- 短批处理作业用户：**能在前几个队列完成**，周转时间较短；
- 长批处理作业用户：依次在 `1～n` 队列中运行，**不会长时间得不到处理**。

---

# 4.5 死锁Deadlocks 
**多道程序的并发执行**可以**改善系统的资源利用率**，但也可能**导致死锁的发生**。
## 4.5.1  死锁的概念

死锁是指**多个进程**因**竞争系统资源或相互通信**而造成的一种僵局，若无外力作用，这些进程都**将永远不能向前推进**。

死锁例子：当两辆车在十字路口逼近时，它们要完全停下来，且在一辆车开走之前，另一辆车不能启动。

另外，假设一条河上有一座独木桥，若桥两端的人相向而行……
<img src="https://img-blog.csdnimg.cn/20200412113245427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%"> 
## 4.5.2 死锁产生的原因和必要条件
死锁产生的原因与**资源的使用相关**。下面介绍资源分类。

**可剥夺和非剥夺资源**：
- 可剥夺资源是指某进程获得这类资源后，该资源**可以被其他进程或系统剥夺**。如CPU，存储器。==注意：竞争可剥夺资源不会产生死锁！==
- 非剥夺资源又称不可剥夺资源，是指系统将这类资源分配给进程后，**再不能强行收回，只能在进程使用完后主动释放**。如打印机、读卡机。
竞争非剥夺资源例子。如，打印机 `R1` 和读卡机 `R2` 供进程 `P1` 和 `P2` 共享：
<img src="https://img-blog.csdnimg.cn/20200412113321575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">

永久性资源和消耗性资源：
- 永久性资源：**可顺序重复使用**的资源。如打印机。
- 消耗性资源：由一个进程产生，被另一个进程**使用短暂时间后便无用**的资源，又称为临时性资源。如消息。
- ==竞争永久性资源和临时性资源都可能产生死锁。==

总结一下，死锁产生的原因是：
- 竞争资源：**多个进程竞争资源**，而资源又不能同时满足其需求。
- 进程推进顺序不当：进程**申请资源和释放资源的顺序**不当。

竞争资源引起的死锁中，如消息通信按下述顺序进行，则不会发生死锁：
- `P1：...Release(S1)；Request(S2)；...`
- `P2：...Release(S2)；Request(S1)；...`

若按下述顺序，则**可能发生死锁**，原因在于它们还没有释放彼此申请的资源：
- `P1：... Request(S2)；Release(S1)；...`
- `P2：... Request(S1)；Release(S2)；..`.
<img src="https://img-blog.csdnimg.cn/20200412113402139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">

进程推进顺序不当引起的死锁：当进程 `P1、P2` 共享资源 `A、B` 时，若**推进顺序合法**则不会产生死锁，否则会产生死锁。
- 合法的推进路线：①②③    
-  不合法的推进线路：④，此时向上还是向右都会导致死锁。
<img src="https://img-blog.csdnimg.cn/20200412113415646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
死锁产生的**必要条件**：
- 互斥条件：在**一段时间**内某**资源仅为一个进程所占有**。
- 请求和保持条件：又称部分分配条件、**占用并等待**条件。**当进程因请求资源被阻塞时，已分配资源保持不放**。
- 不剥夺条件：进程所获得的资源在未使用完毕之前，**不能被其他进程强行夺走**。
- 循环等待条件：死锁发生时，**存在一个进程资源的循环**。

注意：
- 死锁是**因资源竞争**造成的僵局
- 通常死锁一般**至少涉及两个进程**
- 死锁与部分进程及资源相关

## 4.5.3 处理死锁的基本方法
用于处理死锁的**方法**主要有：
- 忽略死锁。这种处理方式又称鸵鸟算法，指像鸵鸟一样对死锁视而不见。 
- 预防死锁：**设置某些限制条件**，通过**破坏死锁产生的四个必要条件之一**来预防死锁。
- 避免死锁：在资源的动态分配过程中，用某种方法来**防止系统进入不安全状态**。
- 检测死锁及解除：系统**定期检测是否出现死锁**，若出现则**解除死锁**。

## 4.5.4  死锁的预防
预防死锁。通过**破坏产生死锁的四个必要条件中的一个或几个条件**，来防止发生死锁。
特点：**较易实现**，广泛使用，但限制较严，**资源利用率低**。

### 1. 破坏互斥条件
互斥是设备本身固有的属性，**此条件不能破坏**。

### 2. 破坏请求和保持条件
要求**进程一次申请**它所需的**全部资源**，若有足够的资源则分配给进程，**否则不分配资源，进程等待**。这种方法称为**静态资源分配法**。

特点：简单、安全且易于实现；但**资源利用率低，进程延迟运行**。

### 3. 破坏不剥夺条件
一个**已获得某些资源**的进程，若**新的资源请求得不到满足**，则它<ins>必须释放已获得的所有资源</ins>。

特点：**实现较复杂**；释放已获得资源**可能造成前一段工作的失效**；重复申请和释放资源会**增加系统开销，降低系统吞吐量**。 

### 4. 破坏循环等待条件
将**所有资源按类型排队**，并赋予不同序号，要求进程**均严格按照序号递增的次序**请求资源，**同类资源一次申请完**。这种方法称为**有序资源分配法**。

特点：比前两种方法资源**利用率高，吞吐量大**。但要求**资源序号相对稳定**，从而**限制了新设备的增加**；使用资源的顺序与系统规定顺序不同，**造成资源的浪费**；使用资源的次序限制用户编程。

为什么有序资源分配法可以防止死锁？
- 假设**循环已经出现**并且**含于环中的进程**是 $p_0,\ ...\ , p_n$ ，这意味着 $p_i$ 正占有 $r_i$ 类资源，而请求 $r_i+1$ 类资源，
- 设函数 $f$ 能获得资源序号，则有 $f(r_i) < f(r_i+1)$，故 $f(r_0) <f(r_1)<…< f(r_n)<f(r_0)$ 。
- 矛盾，原假设不成立。
<img src="https://img-blog.csdnimg.cn/20200412113553562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">- 采用有序资源分配法，系统中的进程**必须按照资源编号的升序**申请资源。
- 因此在任一时刻，系统中总会存在一个进程，它占有**已申请资源中编号最高的资源**，且它**继续请求的资源**必定是**空闲**的，因而它**可以一直向前推进直至完成**。
- 当该进程运行完成后，即**会释放它所占有的全部资源**。这样剩余进程集合中**又会存在一个进程**，它占有已申请资源中编号最高的资源，且它继续请求的资源必定是空闲的，因而它也可以一直向前推进直至完成。
- 以此类推，**最终所有进程均可运行完成**，故不会发生死锁。

---
## 4.5.5 死锁的避免
死锁的避免是在**资源的动态分配**过程中，用某种方法**防止系统进入不安全状态**，从而避免死锁的发生。

特点：以**较弱的限制**获得**较高的利用率**，但实现有一定难度。

### 1. 安全状态
在避免死锁的方法中，允许进程**动态地申请资源**。系统在进行资源分配之前，**先计算资源分配的安全性**。若此次分配**不会导致系统进入不安全状态**，便将资源分配给进程，否则进程等待。

安全状态是指**系统能按某种顺序**如 `<P1、P2… 、Pn>` 来**为每个进程分配其所需的资源**，直至最大需求，**使每个进程都可以顺利完成**，则称此时的系统状态为安全状态，称序列 `<P1、P2、…、Pn>` 为安全序列。

不安全状态：若**某一时刻系统中不存在一个安全序列**，则称此时的系统状态为不安全状态。进入不安全状态后，便**可能进而进入死锁状态**；因此<b><font color="#ff0000">避免死锁的本质是使系统不进入不安全状态</font></b>。

安全状态例子：
- $T_0$ 时刻，系统资源状态如下：
<img src="https://img-blog.csdnimg.cn/20200412113625910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
- 这时**可用资源能满足 $P_2$ 的需要**，$P_2$ 获得运行需要的所有资源并**能顺利运行结束**。$P_2$ 运行结束的系统资源状态：
<img src="https://img-blog.csdnimg.cn/2020041211363764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
- 这时可用资源能满足 $P_1$ 的需要，$P_1$ 获得运行需要的所有资源并能顺利运行结束。 $P_2$ 、 $P_1$ 运行结束的系统资源状态：
<img src="https://img-blog.csdnimg.cn/20200412113658965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
- 这时**可用资源能满足 $P_3$ 的需要**， $P_3$ 获得运行需要的所有资源并**能顺利运行结束**。
- 因此**存在一个安全序列** `<P2、P1、P3>`，系统状态安全。

由安全状态向不安全状态转换：
- 若在 $T_0$ 之后，又将 $1$ 个资源分配给了 $P_3$ ，则系统**进入了不安全状态**：
<img src="https://img-blog.csdnimg.cn/20200412113710697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
---
### 2. 银行家算法  Banker’s Algorithm
**最具代表性**的死锁避免算法是 `Dijkstra` 的银行家算法。银行家算法要求**新进程进入系统**时，必须**说明**其可能**需要的每类资源最大数量**。

假定系统中有 `n` 个进程 `P1、P2、…、Pn` ，`m` 类资源 `R1、R2、…、Rm` ，银行家算法中**使用的数据结构**如下：
- 可用资源向量 `Available`：是一个含有 $m$ 个元素的数组，其中**每一个元素**代表**一类资源**的**空闲资源数目**。
如果 `Available(j)＝k` ，表示系统中现有空闲的 $R_j$ 类资源 $k$ 个。
- 最大需求矩阵 `Max`：是一个 $n×m$ 的矩阵，定义了**系统中每个进程**对 $m$ 类资源的**最大需求数目**。这个矩阵不会改变。
如果 `Max(i，j)＝k` ，表示进程 $P_i$ 需要 $R_j$ 类资源的最大数目为 $k$ 。
- 分配矩阵 `Allocation`：是一个 $n×m$ 的矩阵，定义了系统中**每一类资源**当前**已分配**给**每一个进程**的**资源数目**。
如果 `Allocation(i，j)＝k` ，表示进程 $P_i$ 当前已分到 $R_j$ 类资源的数目为k。
`Allocation`$_i$ 表示进程 $P_i$ 的分配向量，由矩阵 `Allocation` 的第 $i$ 行构成。
- 需求矩阵`Need`：是一个 $n×m$ 的矩阵，它定义了系统中**每一个进程**还**需要的各类资源数目**。
如果 `Need(i，j)＝k`，表示进程 $P_i$ 还需要 $R_j$ 类资源 $k$ 个。`Need`$_i$ 表示进程 $P_i$ 的需求向量，由矩阵 `Need` 的第 $i$ 行构成。
- 三个矩阵间的关系： 
       $$Need(i，j)＝Max(i，j)－Allocation(i，j)$$

银行家算法如下：设 `Request`$_i$ 是进程 $P_i$ 的请求向量，`Requesti(j)＝k`表示进程 $P_i$ 请求分配 $R_j$ 类资源 $k$ 个。

当 $P_i$ **发出资源请求后**，系统**按下述步骤进行检查**：
1) 如果 $Request_i ≤Need_i$ ，则转向步骤 `2` ；否则**出错**；
2) 如果 $Request_i≤Available$ ，则转向步骤 `3` ；否则 $P_i$ 等待；
3) **试分配**并**修改数据结构**：
    -  $Available ＝ Available－Request_i$ ；
    - $Allocation_i ＝ Allocation_i ＋ Request_i$ ；
    -  $Need_i ＝ Need_i－ Request_i$ ；
4) 系统**执行安全性算法**，检查此次资源分配是否安全。**若安全，才正式分配**；否则，**试分配作废，让进程 $P_i$ 等待**。

安全性算法 `Safety Algorithm`：
1) 设置两个向量
	- `Work`：表示系统**可提供给进程**继续运行的**各类空闲资源数目**，含有 $m$ 个元素，执行安全性算法**开始时**，`Work＝Available` (试分配后的Avail) 。
	- `Finish`：表示系统**是否有足够的资源分配给进程**，使之运行完成，开始时，`Finish(i)＝false`；当有足够资源分配给进程Pi时，令 `Finish(i)＝true` 。
2) 从进程集合中**找到一个能满足下述条件的进程**，如找到则执行步骤3；否则执行步骤4：
	- $Finish(i)= false$ ；
	- $Need_i≤Work$ ；
3) 当进程 $P_i$ 获得资源后，可顺利执行直到完成，并**释放出分配给它的资源**，故应执行：
   - $Work＝Work ＋ Allocation_i$；
    - $Finish(i)＝true$ ；
    - `Goto step 2` ；
4) 若所有进程的 `Finish(i)` 都为 `true` ，则表示系统**处于安全状态**；否则，系统**处于不安全状态**。 

假定系统中有 $5$ 个进程 `P0、P1、P2、P3、P4` 和三种类型的资源 `A、B、C` ，数量分别为 `12、5、9` ，在 $T_0$ 时刻的资源分配情况如下所示。
<img src="https://img-blog.csdnimg.cn/20200412113809772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
① $T_0$ 时刻的安全性：利用安全性算法对 $T_0$ 时刻的资源分配情况进行分析，可得如下所示的 $T_0$ 时刻的安全性分析。 $T_0$ 时刻的安全性检查：
- Need0：7,4,3    Need1：1,2,2    Need2：6,0,0      Need3：0,1,1     - Need4：4,3,1
- Alloc0： 1,1,0    Alloc1： 2,0,1    Alloc2：3,0,3      Alloc3： 2,1,1     Alloc4：1,0,2
- Avail 3,3,2，因此 $Work$ 为3,3,2
- $Finish_i$ 全部为false
- 第一个找到的能满足下述条件 $Finish(i)= false$ 和 $Need_i≤Work$ 的，是 $P_1$，因此 $P_1$ 可以顺利执行，从而 `Finish(1) = true` 。而后，$P_1$ 释放原来就分配的资源 $Alloc$ ，从而 `Work += Alloc` 。
- ...
<img src="https://img-blog.csdnimg.cn/20200412113829919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
从上述分析得知，$T_0$ 时刻存在着一个安全序列 `<P1、P3、P4、P2、P0>`，**故系统是安全的**。

② $P_1$ 请求资源：$P_1$ 发出请求向量 `Request1(1，0，2)`，系统按银行家算法进行检查：
  - `Request1(1，0，2) ≤ Need1(1，2，2)`
  - `Request1(1，0，2) ≤ Available(3，3，2)`
  - 系统先假定可为 $P_1$ 分配资源，并修改 `Available`、`Allocation1` 、`Need1` 向量，由此，为P1试分配资源后**形成的资源变化情况**如下所示：
<img src="https://img-blog.csdnimg.cn/20200412113854108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
- 再利用安全性算法检查此时系统是否安全，可得如下所示的安全性分析。$P_1$ 申请资源后的安全性检查：
	- `Need0：7,4,3    Need1：0,2,0     Need2：6,0,0     Need3：0,1,1     Need4：4,3,1`
	- `Alloc0：1,1,0     Alloc1：3,0,3     Alloc2： 3,0,3     Alloc3： 2,1,1     Alloc4：1,0,2`
	- `Avail  2, 3, 0`
<img src="https://img-blog.csdnimg.cn/20200412113906975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
从上述分析得知，可以找到安全序列 `<P1、P3、P4、P0、P2>` ，系统安全，可以为 $P_1$ 分配资源。

③ $P_4$ 请求资源：$P_4$ 发出请求向量 `Request4(3，3，0)` ，系统按银行家算法进行检查：
  - `Request4(3，3，0) ≤Need4(4，3，1)`
 - `Request4(3，3，0)＞ Available(2，3，0)`，让 $P_4$ 等待。

④ $P_0$ 请求资源：$P_0$ 发出请求向量 `Request0 (0，2，0)` ，系统按银行家算法进行检查：
 - `Request0(0，2，0) ≤ Need0(7，4，3)`
  - `Request0(0，2，0) ≤ Available(2，3，0)`
  - 系统先假定可为 $P_0$ 分配资源，并修改有关数据，为 $P_0$ 试分配资源后，如下所示。 
<img src="https://img-blog.csdnimg.cn/20200412113936318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%"> 
- 再利用安全性算法检查此时系统是否安全。从上表中可以看出，可用资源 `Available(2，1，0 )` 已**不能满足任何进程的需要**，故**系统进入不安全状态**，此时系统不分配资源。

---
## 4.5.6 死锁的检测及解除
通过系统的检测机构**及时地检测出死锁的发生**，然后采取某种措施**解除死锁**。
特点：死锁检测和解除可**使系统获得较高的利用率**，但是**实现难度最大**。

### 1. 资源分配图 
**系统死锁**可以利用资源分配图描述。资源分配图(`Resource-Allocation Graph`)又称进程—资源图，由一组结点 `N` 和一组边 `E` 所构成：
- `N` 被分成**两个互斥的子集**：进程结点子集 `P＝{p1，p2，…，pn}`，资源结点子集 `R＝{r1，r2，…，rm}`。
- `E` 是边集，它连接着 `P` 中的一个结点和 `R` 中的一个结点，`e＝<pi，rj>` 是**资源请求边**，`e＝<rj，pi>` 是**资源分配边**。 

通常，用**圆圈**代表一个进程，用**方框**代表一类资源，方框中的一个点代表**一类资源中的一个资源**。
<img src="https://img-blog.csdnimg.cn/20200412114002359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
### 2. 死锁判定法则
将资源分配图**简化**可以**检测系统状态 `S` 是否为死锁状态**，方法如下：
- 在资源分配图中，找出一个**既不阻塞又非孤立**的进程结点 $p_i$ ，进程 $p_i$ **获得**了它所需要的**全部资源**，**能运行完成**然后**释放所有资源**。这相当于<b><font color="#00FCbc">消去 $p_i$ 的所有请求边和分配边，使之成为孤立结点</font></b>。
- 进程 $p_i$ 释放资源后，可以**唤醒**因**等待这些资源而阻塞的进程**，从而可能使原来阻塞的进程**变为非阻塞进程**。
- 在进行一系列化简后，<b><font color="#FF9C00">若能消去图中所有的边，使所有进程都成为孤立结点，则称该图是可完全简化的</font></b>；若不能使该图完全化简，则称该图是不可完全简化的。 

### 3. 死锁定理
可以证明：
- <b><font color="#FF0000">所有的简化顺序将得到相同的不可简化图</font></b>。
- $S$ 为死锁状态的条件是当且仅当 $S$ 状态的**资源分配图是不可完全简化的**。该条件称为死锁定理。

资源分配图简化例1：
<img src="https://img-blog.csdnimg.cn/20200412114022744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
资源分配图简化例2：下图是否存在死锁？
<img src="https://img-blog.csdnimg.cn/20200412114038726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
资源分配图简化例3：下图是否存在死锁？
<img src="https://img-blog.csdnimg.cn/20200412114051536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
### 4. 死锁检测算法 
很像前面的银行家算法：
- 可利用资源向量`Available`：表示 $m$ 类资源中每类资源的**可用数目**。
- 请求矩阵`Request`：表示**每个进程**当前对**各类资源**的**请求数目**。
- 分配矩阵`Allocation`：表示每个进程**当前已分配的资源**数目。
- 工作向量`Work`：表示系统**当前可提供资源数**。
- 进程集合`L`：记录**当前已不占用资源**的进程。

死锁检测的算法：
```cpp
Work = Available; 
L = <Li | Allocationi = 0 ∩ Requesti = 0>
for all  Li not in L do {
    if (Requesti ≤ Work) {
         Work = Work + Allocationi;
         L = L ∪ Li;
    }
}
deadlock = not (L == <p1,p2,...,pn> )
```

### 5. 死锁解除
一旦检测出系统中出现了死锁，就应**将陷入死锁的进程从死锁状态中解脱出来**，常用的死锁解除方法有两种：
- 资源剥夺法：当发现死锁后，**从其他进程那里剥夺足够数量的资源**给死锁进程，以解除死锁状态。
- 撤消进程法：**最简单的方法是撤消全部死锁进程**，**使系统恢复到正常状态**。但这种做法付出的代价太大。另一方法是**按照某种顺序逐个撤消死锁进程**，直到有足够的资源供其他未被撤消的进程使用，消除死锁状态为止。

处理死锁的综合方法：
- 单独使用处理死锁的某种方法**不能全面解决**OS中遇到的所有死锁问题。
- 综合解决的办法是：将系统中的**资源按层次分为若干类**，对每一类资源使用最适合它的办法解决死锁问题。即使发生死锁，**一个死锁环也只包含某一层次的资源**，因此整个系统不会受控于死锁。

综合方法例子：将系统的资源分为四个层次：
- 内部资源：由系统本身使用，如PCB，采用**有序资源分配法**。
- 主存资源：采用**资源剥夺法**。
- 作业资源：可分配的设备和文件。采用**死锁避免法**。
- 交换空间：采用**静态分配法**。
 

