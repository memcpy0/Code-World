@[toc]

在多道程序系统中，==进程是并发执行的，同一时刻可能存在多个进程，且它们之间存在着**不同的相互制约的关系**，这种关系来源于**并发进程相互合作完成同一项任务**以及**对资源的共享**==，体现在如下两个方面：
- **合作进程**之间产生的制约关系：某一进程若收不到另一进程给它提供的必要信息，就不能继续执行下去，表明**两个进程之间在某些点上要交换信息，相互交流运行情况**。这种制约关系的基本形式是：**进程——进程**，（进程之间因相互合作而产生的制约关系）称为直接制约关系，即**同步**。
- **共享资源**产生的制约关系：某一进程若要求使用某一资源，而该资源正被另一进程使用，并且这一资源不允许两个进程同时使用，于是**该进程只能等待已占用资源的进程释放资源后才能使用**。这种制约关系的基本形式是：**进程——资源——进程**，（进程之间因共享资源而产生的相互制约关系）称为间接制约关系，即**互斥**。

进程之间的这种**相互依赖又相互制约、相互合作又相互竞争**的关系，使得进程之间需要某种形式的通信，主要表现为**同步和互斥**两个方面。这里的重点就是：进程的同步与互斥、实现进程同步与互斥的设施/算法、进程间通信。

---
# 3.0 内容总结  
2．一次仅允许一个进程使用的资源称为**临界资源**。进程中访问临界资源的那段代码称为**临界区**。 

3．对临界资源的访问过程可以分成四个部分：进入区、临界区、退出区及剩余区。

4．访问临界资源的进程必须满足如下条件： 
- 当有若干进程要求进入它们的临界区时，应在有限时间内使一个进程进入临界区。 
- 每次至多有一个进程处于临界区内。 
- 进程在临界区内仅逗留有限的时间。 

5．多个相互合作的进程在一些关键点上可能需要互相等待或互相交换信息，这种相互制约关系称为**进程同步**。当一个进程正在使用某资源时，其他希望使用该资源的进程必须等待，当该进程用完资源并释放后，才允许其他进程去访问此资源，进程之间的这种相互制约关系为**互斥**。

6．锁是一个代表资源状态的变量，通常用 $0$ 表示资源可用，用 $1$ 表示资源已被占用。利用锁机制解决互斥问题的方法是：**上锁、访问临界资源、开锁**。 

7．**信号量**由两个成员构成，其中一个是具有非负初值的整型变量，另一个是初始状态为空的队列。除信号量的初值外，信号量的值仅能由P、V操作改变。 

8．信号量值的含义是：当其大于 $0$ 时表示系统中**当前可用资源的数目**；当其小于 $0$ 时，其绝对值表示系统中**因请求该资源而阻塞等待的进程数目**。 

9．设 $s$ 为一个信号量，$P(s)$ 的主要功能是：先执行 `s = s - 1` ；若 `s ≥ 0` 则进程继续运行；若 `s < 0` 则阻塞该进程，并将它插入该信号量的等待队列中。 $V(s)$ 的主要功能是：先执行 `s = s + 1` ；若 `s > 0` 则进程继续执行；若 `s ≤ 0` 则从该信号量等待队列中移出第一个进程，使其变为就绪状态并插入就绪队列，然后再返回原进程继续执行。 

10．管程定义了**一个数据结构**和**能为并发进程所执行的一组操作**，这组操作能**同步进程**和**改变管程中的数据**。管程由**局部于管程的共享数据结构说明**、**对这些数据结构进行操作的一组过程**以及**对这些数据结构设置初值的语句**组成。 

11．管程具有以下基本特性： 
- 局部于管程的数据只能被局部于管程内的过程所访问。 
- 一个进程只有通过调用管程内的过程才能进入管程访问共享数据。 
- 每次仅允许一个进程在管程内执行某个内部过程。 

12．**进程通信**是指进程之间的信息交换。**高级进程通信方式**是指进程之间以较高的效率传送大量数据。 

13．目前**常用的高级进程通信方式**有：共享存储器系统、消息传递系统以及管道通信系统。 

14．根据消息传递系统的实现方式不同可以分为： 
- 直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。 
- 间接通信方式：发送进程把消息发送到信箱中，接收进程从信箱中取得消息。


---
# 3.1  同步与互斥的概念
## 3.1.1 临界资源与临界区
进程在运行过程中，一般会与其他进程**共享资源**，但是**有些资源的使用具有排他性**。比如：打印机的使用，如果两个进程一起使用一台打印机，它们的输出可能混在一起。解决方法是：
- 进程一要使用打印机时提出申请，如打印机空闲则系统将打印机分配给进程一。此后，打印机一直被进程一占有；
- 进程二如要使用打印机，就必须等待，直到进程一用完打印机并释放后，再提出申请，由系统进行分配。

因此，尽管系统中的多个进程可以共享系统中的各种资源，然而**许多资源一次只能被一个进程使用**：
- 临界资源：**一段时间**内**仅允许一个进程使用**的资源称为临界资源。如：打印机、绘图机等。除物理设备外，还有许多变量、数据等都可由若干进程所共享，它们也属于临界资源。
- 临界区（`critical section`） ：进程中**访问临界资源**的那段**代码**称为临界区，又称临界段。
- 同类临界区：所有**与同一临界资源相关联**的临界区。

共享变量的例子如下。有两个进程 `A, B` 共享一个变量 `x` ，`R1, R2` 是处理机中的两个寄存器，对其进行如下的访问和修改：
```sql
A:           	B:
R1 = x;         R2 = x;
R1 = R1 + 1;    R2 = R2 + 1;
x = R1;         x = R2;
```

如果先执行 `A` 再执行 `B` ，两个进程依次对 `x` 做了加一操作，则 `x` 值增加 `2` 。如果按顺序 `R1 = x; R2 = x; R1 = R1 + 1; x = R1; R2 = R2 + 1; x = R2;` ，则 `x` 值只增加`1` 。这种错误被称为**与时间有关的错误**，产生的原因是**没有互斥使用共享变量**(间接制约关系)。为了防止这种错误的出现，必须将变量 `x` 作为**临界资源**处理，即让两个进程顺序使用 `x`（串行化）。
> 在数据库中，这两个进程可看做两个事务，要想事务执行的结果是正确的，就要保证「这些事务执行的结果」等于「某一串行事务序列的结果」。然而，事务的操作之间会产生冲突，包括读写冲突、写写冲突……
> <b></b>
> 上述的时间错误，可被归为**丢失修改** 这一类错误。此外，还有**不可重复读/幻读**、**脏读**等错误，通过使用（多级）封锁协议和 `S` 读锁、`X` 写锁，可保证不出现这些错误。
> <b></b>
> 具体内容见[【数据库系统】第三部分 数据库系统(11) 并发控制](https://memcpy0.blog.csdn.net/article/details/121550702)，可以比较操作系统与数据库的并发控制机制。

为规范和保证临界资源的正确使用，可以把临界资源的访问过程分成如图3.1所示的四个部分：
- 进入区：为了进入临界区使用临界资源，应该**在进入区检查是否可以进入临界区**；如果可以进入临界区，通常设置对应的"**正在访问临界区**"标志，以阻止其他进程同时进入临界区。
- 临界区：进程中**访问临界资源**的那段代码。
- 退出区：临界区后，用于清除"**正在访问临界区**"标志的部分。
- 剩余区：进程中除了进入区、临界区、退出区之外的其他部分。
![在这里插入图片描述](https://img-blog.csdnimg.cn/e2042ac52de34fb5bc17bf2f561cd9f9.png)

为了使临界资源得到合理使用，必须**禁止两个或以上的进程进入临界区内**，即进入临界区的进程必须满足以下条件：
1. 当有若干进程要求进入它们的临界区时，应在有限时间内使一个进程进入临界区。
2. 每次至多有一个进程处于临界区内。
3. 进程在临界区内仅逗留有限的时间。

也可以将上述条件描述如下：
- 空闲让进：若**无进程处于临界区**时，可以允许「**一个请求进入临界区的进程**」立即进入临界区。
- 忙则等待：当**已有进程进入临界区**，其他**试图进入临界区的进程**必须等待。
- 有限等待：对**要求进入临界区访问临界资源的进程**，应保证**在有限时间内**进入自己的临界区。
- 让权等待：当**进程不能进入自己的临界区**时，应**释放处理机**。

**只有满足前三条，才能正确访问临界资源**；如还满足第四条，就可以提高CPU的效率。

---
## 3.1.2 同步与互斥
一般来说，一个进程相对于另一个进程的运行速度是不确定的，即进程之间是在异步环境下运行的，每个进程都以各自独立的、不可预知的速度向运行的终点推进。

但是，**「相互合作完成同一项任务的几个进程」** 需要在某些确定点上**协调它们的工作**，一个进程到达这些点后，除非另一进程已完成了某些操作，否则就不能继续执行下去，必须停下来等待这些操作的结束，等待其他进程给它提供必要信息。<font color="red">**多个相互合作的进程，在某些关键点上需要相互等待、或相互交换信息与运行情况，进程间的这种相互制约关系称为进程同步 `Synchronization`（直接制约关系）**</font>。

例如，系统中有两个合作进程，它们共享一个单缓冲区。这两个进程一个为计算进程，完成对数据的计算工作；另一个为打印进程，负责打印计算结果。它们实现同步的方式如下： <img src="https://img-blog.csdnimg.cn/20200412083635743.png#pic_center" width="35%">
- 当计算进程对数据的计算尚未完成时，计算结果没有发送到缓冲区，打印进程不能执行打印操作；
- 一旦计算进程完成计算，结果被送到缓冲区后，就**应该给打印进程发送一个信号**；
- 打印进程收到该信号后，便可以从缓冲区中取出计算结果进行打印，在打印进程尚未把缓冲区中的计算结果打印完之前，计算进程也不能把下一次的计算结果送入缓冲区中；
- 只有在打印进程打印完缓冲区中的内容，**给计算进程发出一个信号**之后，计算进程才能将下一次的计算结果送入缓冲区。
 - 计算进程和打印进程之间，就是用这种发信号的方式实现同步的。

而互斥是由于进程间共享某些（互斥）资源而引起的。<font color="blue">**当一个进程正在使用某资源时，其他希望使用该资源的进程必须等待；当该进程用完资源并释放后，才允许其他进程去访问此资源。进程间的这种相互制约关系称为互斥 `Mutual Exclusion`（间接制约关系）**</font>。

例如，某计算机系统中只有一台打印机，有两个进程需要共享使用它，为了保证打印结果的正确性，要求两进程以互斥方式使用打印机。实现互斥的方式如下：
- 当进程需要使用打印机时，先提出使用请求，如果打印机空闲，就将它分配给申请进程（空闲让进），同时将打印机设置为忙状态，此后打印机一直归属该进程；
- 在此期间，如果另一进程申请使用打印机，就必须等待使用打印机的进程释放打印机后，才能使用（忙则等待）；
- 当进程使用完打印机后，需要释放打印机并将打印机设置为空闲状态。

我们可以发现，上述同步的例子，也是对单缓冲区这一资源的互斥访问。那么，同步和互斥的区别是什么呢？
1.  互斥是指某一资源一次只允许一个访问者（进程）对其进行访问，具有**唯一性和排它性**。但互斥**无法限制访问者对资源的访问顺序**，即访问是无序的。
2. 同步是指在互斥的基础上（大多数情况），通过其它机制**实现访问者对资源的有序访问**，即必须有先后顺序。
3. 同步其实已经实现了互斥，特别是所有写入资源的情况必定是互斥的，少数情况下也可以允许多个访问者同时访问资源。所以<font color="red">**同步是一种更为复杂的互斥，互斥是一种特殊的同步**</font>。

综上，我们必须先学习如何实现互斥，在此基础上学习进程的同步。

---
# 3.2 互斥的实现方法
互斥的实现**既有硬件方法**也**有软件方法**，下面对进程互斥的一些实现方法进行介绍。

## 3.2.1 互斥算法
对互斥访问技术的研究始于20世纪60年代，早期主要从软件方法上进行研究。下面简单介绍这些实现互斥的软件算法，它们有的正确、有的错误。之所以介绍这些方法，是为了说明**用软件方法解决互斥和同步问题的困难和复杂性**。

例如，有两个进程 $P_0$ 和 $P_1$ **互斥地共享**某个**临界资源**。 $P_0$ 和 $P_1$ 是**循环进程**，它们执行一个无限循环程序，每次**使用**该资源一个**有限的时间间隔**。

### 1. 算法1：使用轮转变量（强制交替）
设置一个公用整型变量 `turn` ，用来指示**允许进入临界区的进程标识**。进程 $P_0$ 的算法如下：
- 若 `turn = 0` ，则允许进程 $P_0$ 进入临界区；否则**循环检查该变量**，直到 `turn` 变为**本进程标识符**；
- 在退出区，修改**允许进入进程的标识**为 `turn = 1` ，即允许进程 $P_1$ 进入临界区。

进程 $P_1$ 的算法与此类似。两个进程的程序结构如下：
```cpp
int turn = 0;
P0 : { 
	do {
		while (turn != 0); 	// 进程0不允许进入临界区,直到turn等于0时
		进程 P0 的临界区代码 CS0;
		turn = 1; 			// 允许进程1进入临界区
		进程 P0 的其他代码;
    } while (true);
}
P1 : { 
    do {
		while (turn != 1); 	// 进程1不允许进入临界区,直到turn等于1时
		进程 P1 的临界区代码 CS1;
		turn = 0;			// 允许进程0进入临界区
		进程 P1 的其他代码;
    } while (true);
}
```
我们把临界区视作一个房间，**轮转变量则是一把打开房间的钥匙，如果钥匙不在自己手中，就无法打开门**。上述算法的过程就是：
- 进程如果想要进入房间，就需要判断钥匙是否在自己手中，不在时就只有等待另一进程访问完后将钥匙转交过来；
- 如果钥匙在手中，就能进入临界区的房间，访问临界资源，然后关上门退出，将钥匙交给其他进程。

这个算法是错误的，不知道你看出了它的问题没有。此算法可以**保证两个进程互斥访问临界资源**，但存在的问题是：它强制并发执行的两个进程**以交替次序**进入临界区，**不能实现空闲让进准则**，因此导致资源利用不充分。

例如，当进程 $P_0$ 关上门（退出临界区）后会将钥匙转交给 $P_1$（ `turn` 设置为 `1` ），以便允许进程 $P_1$ 进入临界区。但是如果进程 $P_1$ 暂时没有访问该临界资源的想法，而 $P_0$ 此时想再度访问该临界资源，就会很尴尬的发现，自己关上了门，又把钥匙交给了他人，是无法进入临界区的（此时临界区中不存在进程，却进不去）。只有等待 $P_1$ 又一次访问临界资源后，将钥匙转交过来。

---
### 2. 算法2：使用访问标志数组 `flag[]`（可能同时访问）
算法 $2$ 中设置标志数组 `flag[]` ，`flag[i] = true` 表示**进程 `i` 正在访问临界区**，显然**初值均为 `false`** 。它的执行过程如下：
- 在每个进程访问临界资源之前，**先检查**另一个进程**是否在临界区中**，若不在则**修改本进程的临界区标志为真**并**进入临界区**；
- 在**退出临界区**时，**修改本进程的临界区标志为假**。

两个进程的程序结构如下：
```cpp
enum bool {false, true};
bool flag[2] = {false, false};
P0 : {
	do {
		while (flag[1] == true); // 当另一进程1在临界区时,本进程0等待
		flag[0] = true; // 表示本进程0在临界区中
		进程 P0 的临界区代码 CS0;
		flag[0] = false; // 表示本进程0退出临界区
		进程 P0 的其他代码;
	} while (true);
}

P1 : {
    do  {
        while (flag[0] == true); // 当另一进程0在临界区时,本进程1等待
        flag[1] = true; // 表示本进程1在临界区中
        进程 P1 的临界区代码 CS1; 
        flag[1] = false; // 表示本进程1退出临界区
        进程 P1 的其他代码;
    } while(true);   
}
```
此算法解决了空闲让进（通过判断对方不在临界区中，可知临界资源是空闲的）的问题，但又出现了新问题，即**有可能两个进程同时进入临界区**。具体来说就是，当两个进程都未进入临界区时，它们各自的访问标志值都为 `false` ，若此时刚好**两个进程同时都想进入临界区**，并且都发现对方标志值为 `false` ，于是两个进程**同时进入了各自的临界区**，这就**违背**了临界区的访问原则"**忙则等待**"。

---
### 3. 算法3: 使用目标数组 `flag[]`（可能互相谦让）
算法 $3$ 中仍然设置标志数组 `flag[]` ，但标志用来表示**进程是否希望进入临界区**：
- 在每个进程**访问临界资源之前**，先将自己的标志**设置为真**，表示**进程希望进入临界区**；
- 然后再互相谦让，即**检查另一个进程的标志**，若另一个进程的标志为真，则让其先访问临界区，本进程等待；否则进入临界区。

两个进程的程序结构如下，只是在算法2的基础上**修改了两条语句的语序和标志数组 `flag[]` 的语义**：
```cpp
enum bool {false, true};
bool flag[2] = {false, false};
P0 : {
    do {             
        flag[0] = true; // 进程0想要进入临界区
        while (flag[1] == true); // 进程1也想要进入临界区,于是等待
        进程 P0 的临界区代码 CS0;
        flag[0] = false; // 进程0退出临界区
        进程 P0 的其他代码;
    } while (true);
}
P1: {
    do {             
        flag[1] = true; // 进程1想要进入临界区
        while (flag[0] == true); // 进程0也想要进入临界区,于是等待 
        进程 P1 的临界区代码 CS1;
        flag[1] = false; // 进程1退出临界区
        进程 P1 的其他代码;
     } while(true);   
}
```
算法 $3$ 可以**有效地防止两个进程同时进入临界区**，解决了**忙则等待**的问题，但存在**两个进程都进不了临界区的问题**，即违反了**空闲让进**的原则。

具体来说，当两个进程**同时想进入临界区**时，它们分别将自己的标志位设置为 `true` ，并且同时去检查对方的状态，发现对方也要进入临界区，于是双方互相谦让，结果**谁也进不了临界区**。

---
### 4. 算法4：正确算法
算法 $4$ 的基本思想是算法 $1, 2, 3$ 的有机结合，它是**一个正确的算法**。标志数组 `flag[]` 表示进程**是否正在临界区中执行**或**是否希望进入临界区**（结合算法 $2, 3$ 的标志数组 `flag[]` ），相当于进入房间的动机、房间内部的状态。

同时，为了解决算法 $3$ 的问题，还设置了一个 `turn` 变量（结合算法 $1$ 的 `turn` 标志），用于指示**允许进入临界区的进程标识**，相当于打开房门的钥匙。两个进程的程序结构如下：
```cpp
enum bool {false, true};
bool flag[2] = {false, false};
int turn;

P0 : { 
     do  {                 
         flag[0] = true; // 希望进入临界区
         turn = 1; 		 // 让出钥匙
         while (flag[1] && turn == 1); // 当对方也希望进入临界区/就在临界区中执行,且对方有钥匙时等待
         进程 P_0 的临界区代码 CS0;
         flag[0] = false; // 不希望进入临界区/离开了临界区
         进程 P0 的其他代码;
     } while (true);
}

P1 : { 
     do  {                 
         flag[1] = true;  // 希望进入临界区
         turn = 0;		  // 让出钥匙
         while (flag[0] && turn == 0); // 当对方也希望进入临界区/就在临界区中执行,且对方有钥匙时等待
         进程 P1 的临界区代码 CS1;
         flag[1] = false; // 不希望进入临界区/离开了临界区
         进程 P1 的其他代码;
     } while (true);
}
```
至此，算法 $4$ 可以完全正常工作。从上面的软件算法中可以看出，之所以这些算法出现问题，**最主要的原因**是**临界资源状态的检查和修改没有作为一个整体来实现**。

---
## 3.2.2  硬件方法
==完全采用软件方法实现互斥局限性很大，现在已很少单独采用软件方法==。利用硬件方法实现互斥的**主要思想**是：
- 用一条指令完成标志的检查和修改两个动作，**保证检查操作与修改操作不被打断**。
- 或者通过关闭中断的方式，**保证一段代码作为一个整体来执行**。
### 1. 禁止中断方法
当进程**执行临界区代码**时，要**防止其他进程进入**其临界区访问，最简单的方法是**禁止中断**。因为CPU只在发生中断时进行进程切换，而禁止中断能保证**当前运行进程将临界区代码顺利执行完**，从而**保证了互斥的正确实现**，然后**再允许中断**。 

用禁止中断方法实现互斥：
<img src="https://img-blog.csdnimg.cn/20200412083856672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center" width="17%">

开关中断方法的优势是**实现进程之间的互斥既简单又有效**，但是这种方法也存在一些不足：
- 限制了处理机交替执行程序的能力，因此**执行的效率将会明显降低**；
- 对于操作系统内核而言，将**关中断的权力交给用户进程**则很不明智，若一个进程关中断之后不再开中断，则系统可能会因此终止。

---
### 2. 硬件指令方法 
许多计算机中提供了**专门的硬件指令**，实现**对字节内容的检查**和**修改或交换两个字节内容**的功能。使用这样的硬件指令就可以解决临界区互斥的问题。下面介绍两条硬件指令和利用它们实现互斥的方法。

#### (1) TS指令
`TS (Test-and-Set)` 指令的功能是，**读出指定标志后把标志设置为真**。用代码描述如下：
```cpp
bool TS(bool *1ock) {
    bool old = *lock;
    *lock = true;
    return old;
}
```
如果要实现多个进程对临界资源的互斥访问，就要**为每个临界资源设置一个共享布尔变量 `lock` 表示资源的两种状态** ：`true` 表示正被占用，`false` 表示空闲，初值为 `false` 。 算法的过程如下：
- 进程访问临界资源之前，利用 `TS` 指令检查和修改标志 `lock` ；
- 若有进程在临界区，则原值为 `true` ，修改也是 `true` ( `old = true, *lock = true` )，重复检查过程，直到其他进程退出。

算法伪代码如下：

```c
	...
	while (TS(&lock) == true); 
	进程的临界区代码CS;
    lock = false;
    进程的其他代码;
	...
```

---
#### (2) Swap指令（或Exchange指令）
`Swap` 指令的功能是**交换两个字（字节）的内容**，用代码描述如下：
```cpp
Swap(bool *a, bool *b) {
   bool temp;
   temp = *a;
   *a = *b;
   *b = temp;
}
```

用Swap指令实现进程互斥
为每个临界资源设置一个共享布尔变量lock表示临界资源状态；再设置一个局部布尔变量key用于与lock交换信息。算法如下：
       ┆
  key=true；
  while(key！=false)Swap(&lock，&key)；
  进程的临界区代码CS ；
  lock=false ；
  进程的其他代码；
       ┆
3.2.3 锁机制
锁是一个代表资源状态的变量，通常用0表示资源可用（开锁），用1表示资源已被占用（关锁）。
在使用临界资源前需先考察锁变量的值，如果值为0则将锁设置为1（关锁），如果值为1则回到第一步重新考察锁变量的值。当进程使用完资源后，应将锁设置为0（开锁）。
上锁原语
lock（w）
 {
    while（w==1）；
    w = 1；
 }
开锁原语
unlock（w）
 { 
     w = 0；
 }
用锁机制实现互斥
进程 $P_1$              进程P2
   ┆                ┆
 lock(w)；         lock(w)；
 临界区；           临界区；
 unlock(w)；       unlock(w)；
   ┆                ┆
自旋锁
上述锁机制也称为自旋锁。
可以用于中断处理程序，因为中断处理程序中不允许睡眠。
持有自旋锁的时间最好小于两次上下文切换的时间。持有自旋锁时不允许睡眠。
读/写自旋锁：允许多个进程同时读一个共享对象，但进程写共享对象时需要先获得写锁，写锁只允许独立访问该对象。
前述实现方法不能实现让权等待！即存在忙等待
3.3 信号量 semaphore
信号量是由荷兰科学家Dijkstra提出的，是一种卓有成效的进程同步机制。
3.3.1 信号量的定义
信号量由两个成员（s，q）组成，其中s是一个具有非负初值的整型变量，q是一个初始状态为空的队列。又称信号灯。
除信号量的初值外，信号量的值仅能由P操作（又称为wait操作）和V操作（又称为signal操作）改变。
P、V来自荷兰语Proberen和Vershogen，分别表示探查和增加
信号量的物理含义
信号量中的整型变量S表示系统中某类资源的数目。
当其值大于0时，表示系统中当前可用资源的数目；
当其值小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目。
P操作
设S为一个信号量，P（S）执行时主要完成下述动作：
 S=S－1；
if（S＜ 0） {设置进程状态为等待；
                     将进程放入信号量等待队列；
                     转调度程序；}
V操作
V(S)执行时主要完成下述动作：
S=S＋1；
if（S≤0）{将信号量等待队列中的第一个进程移出；
                   设置其状态为就绪状态并插入就绪队列；
                   然后再返回原进程继续执行；}
注意
P操作可能阻塞执行进程，而V操作可以唤醒其他进程。
P、V操作在封锁中断的情况下执行，即一个进程在信号量上操作时，不会有别的进程同时修改该信号量。也就是说P、V操作是原语。
信号量比自旋锁有更好的处理器利用率，但开销比自旋锁大，信号量更适合锁会长时间持有的情况。
3.3.2  利用信号量实现互斥
设S为两个进程 $P_1$ 、P2实现互斥的信号量，S的初值应为1（即可用资源数目为1）。
只需把临界区置于P（S）和V（S）之间，即可实现两进程的互斥。
互斥访问临界区的描述
进程 $P_1$ ：                    进程P2：
              ┆                          ┆
             P(S);                     P(S);
       进程 $P_1$ 的临界区；     进程P2的临界区；
             V(S)；                   V(S)；
              ┆                         ┆
互斥信号量的取值范围
若2个进程共享一个临界资源，信号量的取值范围是：
若没有进程使用临界资源  1
若只有1个进程使用临界资源   0
若1个进程使用临界资源，另1个进程等待使用临界资源 1
3.3.3 利用信号量实现前趋关系
例如： $P_1$ 、P2、P3、P4、P5、P6为一组合作进程，其前驱图如下所示，试用P、V操作完成这六个进程的同步。
<img src="https://img-blog.csdnimg.cn/20200412090747931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">解法1
设七个同步信号量a、b、c、d、e、f、g分别表示进程之间的前驱关系，如图所示，其初值均为0。这六个进程的同步描述如下： 
<img src="https://img-blog.csdnimg.cn/20200412090802824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%"> $P_1$ （）
{      
     执行 $P_1$ 的代码；
      v(a)；
      v(b)；
 }
P2（）
{
     p(a)；
     执行P2的代码；
     v(c)；
     v(d)；
 }
P3（）
{
    p(b)；
    执行P3的代码；
    v(e)； 
 }
P4（）
{
    p(c)；
    执行P4的代码；
    v(f)；
}
P5（）
{
    p(d)；
   执行P5的代码；
    v(g)；
}
P6（）
{
     p(e)；
     p(f)；
     p(g)；
    执行P6的代码；
}

解法2

设五个同步信号量f1、f2、f3、f4、f5分别表示进程 $P_1$ 、P2、P3、P4、P5是否执行完成，其初值均为0。这六个进程的同步描述如下: 
 $P_1$ （）
{      
    执行 $P_1$ 的代码；
    v(f1)；
    v(f1)；
 }
P2（）
{
     p(f1)；
    执行P2的代码；
     v(f2)；
     v(f2)；
 }
P3（）
{
    p(f1)；
   执行P3的代码；
    v(f3)； 
 }
P4（）
{
    p(f2)；
   执行P4的代码；
    v(f4)；
}
P5（）
{
     p(f2)；
    执行P5的代码；
     v(f5)；
}
P6（）
{
    p(f3)；
    p(f4)；
    p(f5)；
    执行P6的代码；
}
3.3.4  经典进程同步问题
多道程序环境中的进程同步是一个非常有趣的问题，吸引了很多学者研究，从而产生了一系列经典进程同步问题。
1.  生产者—消费者问题
生产者—消费者问题是最著名的进程同步问题。
它描述了一组生产者进程向一组消费者进程提供产品，它们共享一个有界缓冲池。缓冲池中的每个缓冲区可以存放一个产品，生产者进程不断生产产品并将产品放入缓冲池中，消费者进程不断从缓冲池内取出产品并消费。
生产者—消费者问题示意图
同步关系有：当缓冲池满时生产者进程需等待，当缓冲池空时消费者进程需等待。诸进程应互斥使用缓冲池。
<img src="https://img-blog.csdnimg.cn/20200412090919560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">生产者                 消费者
   生产一个产品；
     p(empty)；
     p(mutex)；
将一个产品送入缓冲区；
     v (mutex)；
       v(full)；
     p (full)；
     p (mutex)；
从缓冲区中取一个产品；
     v (mutex)；
     v (empty)；
   消费一个产品；
注意

无论在生产者进程还是在消费者进程中，P操作的次序都不能颠倒，否则将可能造成死锁。
用信号量解决生产者—消费者问题
设置两个同步信号量empty、full，其初值分别为n、0。
有界缓冲池是一个临界资源，还需要设置一个互斥信号量mutex，其初值为1。
生产者—消费者问题的同步描述如下：
   生产一个产品；
     p(empty)；
     p(mutex)；
将一个产品送入缓冲区；
     v (mutex)；
       v(full)；
     p (full)；
     p (mutex)；
从缓冲区中取一个产品；
     v (mutex)；
     v (empty)；
   消费一个产品；
无论在生产者进程还是在消费者进程中，P操作的次序都不能颠倒，否则将可能造成死锁。
颠倒生产者进程中的P操作
当mutex=1，full=n，empty=0，且生产者先执行时
生产一个产品；
p(mutex)；
p(empty)；
将一个产品送入缓冲区；
v(mutex)；
v(full)；
mutex      full     empty
     0            n          -1
2.读者—写者问题
一个数据对象（如文件或记录）可以被多个并发进程所共享，
其中有些进程只要求读数据对象的内容，而另一些进程则要求修改或写数据对象的内容，
允许多个读进程同时读此数据对象，
但是一个写进程不能与其他进程（不管是写进程还是读进程）同时访问此数据对象。
读者—写者问题分类
读者优先：当写者提出存取共享对象的要求后，仍允许新读者进入。总是给读者优先权，只要写者当前没有进行写操作，读者就能获得访问权。这种情况存在于读者很多，写者不经常更新的时候使用，如图书馆参考数据库采用读者优先比较好。
写者优先：当写者提出存取共享对象的要求后，不允许新读者进入，且等待的写者可以跳过等待的读者进行写操作。通常把优先权交给写者，而将读者延迟到所有等待的或活动的写者都完成了为止。这种情况存在于经常更新的系统，而读者对最新信息感兴趣，如机票预定系统，写者进行机票价格的更新，读者获取当前机票价。

 
简单的说就是资源没人占用，则谁先到先用，用的时候上锁，读者上读者锁，写者上写者锁。

1.假设先来的读者上读者锁，接下来再a）来读者，可以读资源，将读者计数器+1，b）来写者则等待（阻塞或者不断尝试）直到读者释放资源（计数器为0），选取一个写者开始写
   2.若先来的是写者上写者锁，这时候又来了比如N个读者，M个写者等待（写者锁排他），这时候要是
   a）读者优先，则写者释放锁后，让等候的N个读者先读（其他写者接着等着等，变为情况1），这时候要是
   b）写者优先，则写者释放锁后，让等候的M个中的一个写者写，读者接着等待直到没有写者为止（等的的M个写者全写完还有中途再来的写者）。
用信号量解决读者-写者问题
为解决读者写者问题，应设置两个信号量和一个共享变量：
互斥信号量mutex，用于使读进程互斥地访问共享变量readcount，其初值为1；
共享变量readcount，用于记录当前正在读数据集的读进程数目，初值为0。
写互斥信号量writer，用于实现写进程与读进程的互斥以及写进程与写进程的互斥，其初值为1；
读者描述

            p(mutex)；
            if (readcount==0) p(writer)；
            readcount=readcount+1；
            v(mutex)；
            读数据集；
            p(mutex) ；
            readcount=readcount-1 ；
            if (readcount==0) v(writer)；
            v(mutex)；
写者描述
           
             p(writer)；
             写数据集；
             v(writer)；
对读者写者问题的理解

请注意对信号量mutex意义的理解。
mutex是一个互斥信号量，用于使读进程互斥地访问共享变量readcount。该信号量并不表示读进程的数目，表示读进程数目的是共享变量readcount。
3. 哲学家进餐问题

哲学家进餐问题描述有五个哲学家，他们的生活方式是交替地进行思考和进餐，
哲学家们共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子，
平时哲学家进行思考，饥饿时便试图取其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐，
进餐完毕，放下筷子又继续思考。
<img src="https://img-blog.csdnimg.cn/20200412091800911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
用信号量解决哲学家进餐问题
用五支筷子的信号量构成信号量数组：
 semaphore stick[5] ；
所有信号量初值为1， 
笫i个哲学家的活动算法描述 

        p(stick[i])；
    p(stick[(i+1) %  5])；
            进餐；
         v(stick[i])；
    v(stick[(i+1) % 5])；
           思考；
算法描述存在的问题

上述算法有可能引起死锁。对于这样的死锁问题有如下办法解决：
至多允许四个哲学家同时进餐。
仅当左、右两支筷子均可用时，才允许拿起筷子进餐。
奇数号哲学家先拿左筷子再拿右筷子，偶数号哲学家相反。
4.睡眠的理发师问题
理发店里有一位理发师，一把理发椅和N把供等候理发顾客坐的椅子。
如果没有顾客，理发师睡眠，当一个顾客到来时叫醒理发师；
若理发师正在理发时又有顾客来，那么有空椅子就坐下，否则离开理发店。
要求描述理发师和顾客的行为，因此需要两类进程Barber ()和Customer()分别描述理发师和顾客的行为。当理发师看报时顾客近来需要唤醒理发师为其理发，当有顾客时理发师为其理发，没有的时候理发师看报，因此理发师和顾客之间是同步的关系，由于每次理发师只能为一个人理发，且可供等侯的椅子有限只有n个，即理发师和椅子是临界资源，所以顾客之间是互斥的关系。

用信号量解决睡眠的理发师问题
为解决睡眠的理发师问题，应使用三个信号量和一个控制变量：
1）控制变量count用来记录等候理发的顾客数，初值均为0；
2)信号量customers用来记录等候理发的顾客数，并用作阻塞理发师进程，初值为0；
3)信号量barbers用来记录正在等候顾客的理发师数，并用作阻塞顾客进程，初值为0；
4)信号量mutex用于互斥，初值为1
理发师描述

	p(customers)；/*若无顾客，理发师睡眠*/
 	p(mutex)；    /*进程互斥*/
 	count=count－1；/*等候的顾客数少1人*/
	v(barbers)；  /*理发师去为一个顾客理发*/ 
 	v(mutex)；     /*开放临界区，无须再锁住
                            沙发数目了*/
   理发师理发；     


顾客描述

  p(mutex)；  /*进程互斥，顾客进店后首先看是否
                                  有空位子*/
  if(count < N）
  { count=count+1   /*等候顾客数加1*/
    v(customers)；  /*必要的话唤醒理发师*/
    v(mutex) /*开放临界区，无须再锁住沙发数目*/
    p(barbers)；  /*如果理发师忙，顾客等待*/ 
    坐下等待理发；     }
   else     v(mutex)； /*无空椅子则离开*/

3.3.5 信号量集机制-AND型信号量

AND型信号量的基本思想是：将进程在整个运行过程中需要的多类资源，一次性地全部分配给进程，待该进程使用完后再一起释放。只要有一个资源未能分配给该进程，其他所有资源也不分配。
我们称AND型信号量的P原语为SP或Swait， V原语为SV或Ssignal。 
 SP操作
 SP（S1，S2，…，Sn）   
 {  if（S1＞=1 & S2＞=1 & … & Sn＞=1）
        for （i=1; i<= n; i++)  Si= Si-1;
     else
    {将进程插入第一个小于1的信号量等待队列；
      将调用进程的程序计数器置为SP的第一条指令；
    }
 } 
SV（S1，S2，…，Sn ）
{  for （i=1； i<=n; i++)  
   {   Si= Si+1;
       唤醒Si等待队列上的所有进程
       并将它们插入就绪队列；
   }
 }
 一般信号量集

信号量集是AND型信号量的扩充，其基本思想是：在一次原语操作中完成对所有资源的申请，即进程可以一次申请多类资源，每类资源可以申请多个，当某类资源的数量低于其下限值或不能满足进程的申请要求时，则不进行分配。
SP
SP（S1,t1,d1，S2,t2,d2，…，Sn,tn,dn）
     /*ti为下限值，di为资源申请量*/
{  if S1>=t1 && S1>=d1 && … && Sn>=tn && Sn>=dn )
     for (i=1 ; i<=n; i++) Si=Si－di；
   else
   { 将进程插入第一个资源数小于ti或di的信号量的等待队列；
      将调用进程的程序计数器设置为SP的第一条指令；    }  }
SV（S1,d1，S2,d2，…，Sn,dn ）
{   for（ i=1； i<=n; i++)  
     {  Si=Sｉ＋di；
        唤醒队列Si上的所有进程
        并将它们插入就绪队列；
    }
}


用AND型信号量集解决生产者-消费者问题
生产者

mutex=1；full=0；empty=n；
   生产一个产品；
   sp(empty,mutex)；
将一个产品送入缓冲区；
   sv(mutex,full)；

消费者

     sp (full, mutex)；
从缓冲区中取一个产品；
     sv (mutex, empty)；
     消费一个产品；


用AND型信号量解决哲学家进餐问题

   sp(stick[i]，stick[(i+1) % 5])；
          进餐；
    sv(stick[i]，stick[(i+1) % 5])；
           思考；

信号量集的几种特殊的情况

SP（S，d，d）:此时信号量集中只有一个信号量，它每次申请d个资源，当资源数量少于d个时，便不予分配。
SP（S，1，1）：此时的信号量集已退化为记录型信号量。
SP（S，1，0）：这是一种很特殊的信号量，可作为一个可控开关。当S≥1时，允许多个进程进入特定区域；当S=0时，禁止任何进程进入特定区。

用信号量集解决读者-写者问题

为了实现方便增加一个限制条件，即最多只允许RN个读进程同时读。
设置两个信号量：
mx表示写互斥的信号量，用于实现写进程与读进程的互斥以及写进程与写进程的互斥，其初值为1；
L表示允许读进程数目的信号量，用来说明系统还可以允许多少个读进程进入，其初值为RN。
     读者                               写者


sp(L,1,1；mx,1,0)；           sp(mx,1,1；L,RN,0)；
读数据集；                    写数据集；
 sv(L,1)；                       sv(mx,1)；


3.4  管程机制
信号量的同步操作分散在各进程中不便于管理，还可能导致系统死锁。如：生产者消费者问题中将P颠倒可能死锁。
为此Dijkstra于1971年提出：把所有进程对某一种临界资源的同步操作都集中起来，构成一个所谓的秘书进程。凡要访问该临界资源的进程，都需先报告秘书，由秘书来实现诸进程对同一临界资源的互斥使用。
3.4.1 管程定义 monitor
Hansan为管程所下的定义是：管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。
管程的构成
局部于管程的共享数据结构
对共享数据结构进行操作的一组函数
对局部于管程的数据设置初始值的语句
管程的语法
Monitor  monitor _name；/*管程名*/
variable  declarations；     /*共享变量说明*/
  $P_1$ (...)           /*对数据结构操作的函数*/
   { … }
 P2(...)
   { … }
         ┆
 Pn(...)
    { … }
{
     initialization code;     /*设初值语句*/
}
管程的基本特性

局部于管程的数据只能被局部于管程内的函数所访问。
一个进程只有通过调用管程内的函数才能进入管程访问共享数据。
每次仅允许一个进程在管程内执行某个函数。
由于管程是一个语言成分，所以管程的互斥访问完全由编译程序在编译时自动添加上，无需程序员关心，而且保证正确。 

条件变量

利用管程实现同步时，还应设置条件变量和在条件变量上进行操作的两个同步原语。
条件变量用于区别各种不同的等待原因。其说明形式为： condition   x，y；
同步原语Cwait和Csignal。Cwait使调用进程等待，并将它排在相应的等待队列上；Csignal唤醒等待队列的队首进程。

3.4.2 用管程解决生产者-消费者问题
管程模块PC控制用于保存和取出字符的缓冲区，缓冲区大小为n。
PC中包括两个函数：append将字符放入缓冲区中；take从缓冲区中取出字符。
管程中设置了两个条件变量： notempty及notfull。变量count表示缓冲池中的产品数目。
管程PC描述.doc

3.4.3 利用管程解决哲学家进餐问题
用三种不同状态表示哲学家的活动：进餐、饥饿、思考。（thinking，hungry，eating）state[5]；
为每个哲学家设置一个条件变量self（i），当哲学家饥饿又不能获得筷子时，用self来阻塞自己；
管程设置三个函数：pickup取筷子，putdown放筷子，test测试是否具备进餐条件。
管程DP描述.doc

3.5  进程通信

进程通信（processe communication）：是指进程之间的信息交换。
进程互斥与同步交换的信息量较少且效率较低，因此称这两种进程通信方式为低级进程通信方式，相应地也将P、V原语称为两条低级进程通信原语。
高级进程通信方式是指进程之间以较高的效率传送大量数据。
3.5.1 进程通信的类型
高级进程通信方式可分为三大类：
共享存储器系统
消息传递系统
管道通信系统或共享文件系统
### 共享存储器系统
相互通信的进程共享某些数据结构或共享存储区。
基于共享数据结构的通信方式：诸进程通过公用某些数据结构交换信息。如生产者-消费者问题。
基于共享存储区的通信方式：在存储器中划出一块共享存储区，诸进程可通过对共享存储区进行读或写来实现通信。包括建立共享存储区、附接及断接。
Shared-Memory Systems
### 消息传递系统
在消息传递系统中，进程间的数据交换以消息为单位，程序员直接利用系统提供的一组通信命令（原语）来实现通信。
消息传递系统因其实现方式不同可分为：
直接通信方式：发送进程将消息发送到接收进程，并将其挂在接收进程的消息队列上；接收进程从消息队列上取消息。
间接通信方式：发送进程将消息发送到信箱，接收进程从信箱中取消息。
Message-Passing System
### 管道（共享文件）通信
管道（pipe）通过连接读进程和写进程的共享文件来实现读写进程之间通信。
3.5.2 消息传递系统
消息传递系统是实现进程通信的常用方式，这种通信方式既可以实现进程间的信息交换，也可以实现进程间的同步。 
1. 消息缓冲通信
消息缓冲通信是直接通信方式的一种实现。
消息缓冲队列通信机制中的数据结构
所谓消息是指一组信息，消息缓冲区的数据结构如下：
   struct message 
    {
             sender; 发送者进程标识符
             size; 消息长度
             text; 消息正文
             next; 指向下一个消息缓冲区的指针
    }
struct PCB
   {     ┇
           mq;消息队列队首指针
           mutex;消息队列互斥信号量
           sm;消息队列资源信号量
          ┇
   } 
消息缓冲通信的实现思想
为了实现消息通信，发送进程应先在自己的工作区中设置一个发送区，把欲发送的消息填入其中，然后再用发送原语将其发送出去。
接收进程调用接收原语从自己的消息缓冲队列中摘下第一个消息，并将其内容复制到自己的消息接收区内。
两个进程进行通信的过程

<img src="https://img-blog.csdnimg.cn/20200412101633132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="30%">
发送原语描述
void send（receiver，a）receiver为接收者标识号，a为发送区首址
    {
       向系统申请一个消息缓冲区i；
       将发送区a中的消息复制到i中；
       获得接收进程的内部标识j;
       P（mutex）；
       把消息插入j的消息队列上；
       V（mutex）；
       V（sm）；
    }

接收原语描述

void  receive（b）b为接收区首址
{
          获得接收进程内部标识j;
          P（sm）；
          P（mutex）；
          将消息队列中的第一个消息移出；
          V（mutex）；
          将消息复制到接收区b；
  }
2.信箱通信
信箱通信方式中，进程之间通信需要通过共享数据结构实体--信箱来进行。
信箱是一种数据结构，其中存放信件。
信箱逻辑上分成信箱头和信箱体两部分。
信箱头中存放有关信箱的描述。
信箱体由若干格子组成，每格存放一个信件，格子的数目和大小在创建信箱时确定。 
信箱通信原语
信箱通信原语包括：
信箱的创建和撤消：
消息的发送和接收：
Send(mailbox,message);
Receive(mailbox,message);
消息通信中的同步问题1
进程间的消息通信存在同步关系
对于发送进程来说，它在执行发送原语后有两种可能选择：
发送进程阻塞，直到这个消息被接收进程接收到，这种发送称为阻塞发送。
发送进程不阻塞，继续执行，这种发送称为非阻塞发送。
对于一个接收进程来说，在执行接收原语后也有两种可能选择：
如果一个消息在接收原语执行之前已经发送，则该消息被接收进程接收，接收进程继续执行。
如果没有正在等待的消息，则该进程阻塞直到有消息到达；或者该进程继续执行，放弃接收的努力。前者称为阻塞接收，后者称为非阻塞接收。
根据发送进程和接收进程采取方式的不同，通常有三种常用的组合方式：
非阻塞发送、阻塞接收。
非阻塞发送、非阻塞接收。
阻塞发送，阻塞接收。

3.管道

使用管道通信时，基本上采用文件系统的原有机制实现。包括创建、打开、关闭、读写等。
管道机制应提供以下三方面的协调能力：
互斥：诸进程互斥读写管道
同步：管道空、满情况处理
存在：确定对方是否存在
管道通信示意图1

初始时，其长度为4，系统将管道看成一个循环队列。按先进先出的方式读写。
<img src="https://img-blog.csdnimg.cn/20200412101728239.png" width="30%">
写入字符E后，管道长度为5
<img src="https://img-blog.csdnimg.cn/20200412101732112.png" width="30%">读一个字符后，管道长度为4
<img src="https://img-blog.csdnimg.cn/20200412101739823.png" width="30%">若管道容量为n且in=n时，再写入一个字符，则in移到管道的另一端。
<img src="https://img-blog.csdnimg.cn/20200412101747200.png" width="30%">P73
3（1）
3（3）
3（6）
3（8）
考研题-1

三个进程 $P_1$ 、P2、P3互斥使用一个包含N(N>0)个单元的缓冲区，
 $P_1$ 每次用produce()生成一个正整数并用put()送入缓冲区某一空单元中；
P2每次用getodd()从该缓冲区中取出一个奇数并用countodd()统计奇数个数；
P3每次用geteven()从该缓冲区中取出一个偶数并用counteven()统计偶数个数。
请用信号量机制实现这三个进程的同步与互斥活动，并说明所定义的信号量含义。要求用伪代码编写。 09


semaphore empty=N；semaphore odd=0,even=0；
semaphore mutex=1；
main（）
cobegin
 {  Process  $P_1$ ()
     while(true)
     {  number=produce();
         P(empty);
         P(mutex);
         put();
         V(mutex);
    if (number % 2 = 0) V(even);
    else V(odd);
}
Process P2()
  while(true)
  {   P(odd);
      P(mutex);
      getodd();
      V(mutex);
      V(empty);
     countodd();   }
Process P3()
  while(true)
  {  P(even);
      P(mutex);
      geteven();
      V(mutex);
      V(empty);
     counteven();
}   } coend 


某银行提供一个服务窗口和10个供顾客等待的座位。顾客到达银行时，若有空座位，则到取号机上领取一个号，等待叫号。取号机每次仅允许一个顾客使用。当营业员空闲时，通过叫号选取一位顾客，并为其服务。顾客及营业员的活动描述如下：11
cobegin
{  process 顾客
   { 从取号机获取一个号码；
      等待叫号；
      获得服务；  }
      process 营业员
   {   while（TRUE）
     {  叫号；
        为顾客服务；}  }
}coend
请添加必要的信号量和P、V（或wait（）、signal（））操作，实现上述过程中的互斥与同步。要求写出完整的过程，说明信号量的含义并赋初值。11

semaphore mutex=1;   //互斥使用取号机
semaphore seets=10;     //空座位的数量
semaphore full=0;     //已占座位的数量
semaphore service=0;        //等待叫号
cobegin
{  process 顾客i
   {  P(empty);      P(mutex);
      从取号机获得一个号;
     V(mutex);   V(full);
      P(service);           // 等待叫号   }
  process 营业员
  {  while(TRUE)
     {   P(full);
         V(empty);
         V(service);          //叫号
         为顾客服务;
     }
  }
}coend








