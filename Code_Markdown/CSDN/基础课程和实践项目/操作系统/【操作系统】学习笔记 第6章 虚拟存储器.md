@[toc]

前面介绍的各种存储管理方法中，有一个共同的特点，即==同时将多个作业保存在内存中，以便允许多道程序设计，并且每个作业在执行前都必须全部装入内存==。这样，**当作业的地址空间大于分配给它的内存空间容量时，该作业就无法运行**。

这种存储管理方式**限制了大作业的运行**。为解决该问题，可以从物理上增加内存容量，但这样会增加系统成本。而**虚拟存储器技术能从逻辑上对内存进行扩充，达到扩充内存的效果**。虚拟存储器技术**允许作业不全部装入就可以执行**，而且**将内存抽象成一个巨大的、统一的存储数组**，进而将用户看到的逻辑内存和物理内存分开。这种技术允许程序员不受内存存储的限制，本章将讨论虚拟存储器技术。

---
# 6.1 虚拟存储器概念
当把有关作业的全部信息都装入主存储器后，作业执行时实际上不是同时使用全部信息的，有些部分运行一遍便再也不用，甚至有些部分在作业执行的整个过程中都不会被使用（如错误处理部分）。==作业在运行时不用的，或暂时不用的，或某种条件下才用的程序和数据，全部驻留于主存中，是对宝贵的主存资源的一种浪费，大大降低了主存利用率==。

于是，人们提出了这样的问题：作业提交时，先全部进入辅助存储器，作业投入运行时，不把作业的全部信息同时装入主存储器，而是**将其中当前使用部分先装入主存储器**，其余暂时不用的部分先存放在「作为主存扩充的辅助存储器」中，待用到这些信息时，再由系统自动把它们装入到主存储器中，这就是虚拟存储器的基本思路。

虚拟存储器 `Virtual Memory` 的理论基础是<b><font color="#FF0000">程序执行时的局部性原理</font></b>。大多数程序执行时，在一个较短的时间内仅使用程序代码的一部分。相应地，程序所访问的存储空间也局限于某个区域，这就是程序执行的局部性原理。局部性原理体现在两个方面：时间局部性和空间局部性。时间局部性是指**一条指令的一次执行和下次执行、一个数据的一次访问和下次访问，都集中在一个较短时期内**。空间局部性是指**当前指令和邻近的几条指令、当前访问的数据和邻近的数据，都集中在一个较小区域内**。

Denning、Knuth、Tanenbaum等人的研究表明：
- 程序中只有少量分支和过程调用，大多是顺序执行的，即要取的下一条指令紧跟在当前执行指令之后。
- 程序往往包含若干个循环，这些是由相对较少的几个指令重复若干次组成的，**在循环过程中，计算被限制在程序中一个很小的相邻部分中（如计数循环）**。
- 很少会出现连续不断的过程调用序列，相反，程序中过程调用的深度限制在一个小的范围内，因而一段时间内，指令引用被局限在很少几个过程中。
- 对于连续访问数组之类的数据结构，往往是对存储区域中的数据或相邻位置的数据（如动态数组）的操作。
- **程序中有些部分是彼此互斥的，不是每次运行时都用到的**，例如，出错处理程序，仅当在数据和计算中出现错误时才会用到，正常情况下，出错处理程序不放在主存，不影响整个程序的运行。

上述种种情况充分说明，「作业执行时没有必要把全部信息同时存放在主存储器中、而仅仅只需装入一部分的假设」是合理的。==在装入部分信息的情况下，只要调度得好，不仅可以正确运行，而且可以在主存中放置更多进程，有利于充分利用处理器和提高存储空间的利用率==。

基于局部性原理，对前面提出的问题就可以做出肯定的回答。
- 在程序装入时，不必将其全部读入内存，而只需将当前执行需要的部分放入内存，而将其余部分放在外存，就可以启动程序执行。
- 在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的信息调入内存，然后继续执行程序。

另一方面，操作系统将内存中暂时不使用的内容**换出**到外存上，从而腾出空间存放将要调入内存的信息。从效果上看，**这样的计算机系统好像为用户提供了一个存储容量比实际内存大得多的存储器**，这个存储器称为“虚拟存储器” `virtual memory`（简称虚存）。==之所以将其称为虚拟存储器，是因为这个存储器实际上并不存在，只是由于系统提供了**部分装入、请求调入和置换功能**后，给用户的感觉好像是存在一个比实际物理内存大得多的存储器==。

虚拟存储器最基本的特征是**离散性**，在此基础上又形成了**多次性**和**对换性**的特征，其表现出来的特征是**虚拟性**。
- 离散性指的是**在内存分配时，采用非连续的分配方式**；我们前面介绍的分配方式中，分页和分段技术就属于非连续分配方式。
- 多次性指的是**一个作业被分成多次装入内存**，而不是一次性全部装入。
- 对换性是指**允许作业在运行过程中换进、换出**。
- 虚拟性是指**从逻辑上扩充了主存容量**。

实际上<font color="red">**虚拟存储器是为扩大主存而采用的一种设计技巧，是一种以时间换空间的技术**</font>。虚拟存储器的实质是，把「程序存在的地址空间」和「运行时用于存放程序的存储空间」区分开。**程序员可以在地址空间内编写程序，而完全不用考虑实际内存的大小**。在多道程序环境下，可以为每个用户程序建立一个虚拟存储器。当然，**虚拟存储器的容量与主存大小无直接关系**，虚拟存储器的最大容量也不是无限的，而受限于计算机的地址结构、及可用的辅助存储器的容量。

实现虚拟存储器，需要有一定的物质基础。其一**要有相当数量的外存**，足以存放多个用户的程序；其二**要有一定容量的内存**，因为在处理机上运行的程序必须有一部分信息存放在内存中；其三是**地址变换机构**，以动态实现逻辑地址到物理地址的变换。常用的虚拟存储器实现方案有**请求分页存储管理**、**请求分段存储管理**和**请求段页式存储管理**。

 

---
# 6.2 请求分页存储管理
## 6.2.1 请求分页存储管理的实现思想
请求分页存储管理系统在**作业地址空间的分页、存储空间的分块**等概念上和分页存储管理完全一样，==它是在分页存储管理系统的基础上，增加了**请求调页功能、页面置换功能**所形成的一种虚拟存储系统==。

在请求分页存储管理系统中，作业运行之前，只要求将当前需要的一部分页面装入内存，便可以启动运行，在作业运行过程中，**若所要访问的页面不在内存，则通过调页功能将其调入**，同时**还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间**。
## 6.2.2 页表
在请求分页存储管理系统中使用的主要数据结构仍然是**页表**，其基本作用是将「程序地址空间中的逻辑地址」转换成「内存空间中的物理地址」。由于请求分页存储管理系统只将作业的一部分调入内存，还有一部分存放在磁盘上，故**需要在页表中增加若干项，供操作系统在实现页面的调入、换出功能时参考**，扩充后的页表项如图6.1所示。
![](https://img-blog.csdnimg.cn/e577544ba7c94327bd47c73f518cf5c4.png)

页表项中各字段的作用如下：
- 页号和物理块号。其定义同分页存储管理，这两个信息是进行地址变换所必需的。
- 状态位。**用于表示页面是否在内存中**。每当进行内存访问时，根据该位判断要访问的页面是否在内存，若不在内存中，则产生缺页中断。
- 访问字段。**用于记录页面在一段时间内被访问的次数**，或最近已有多长时间未被访问。该字段供置换算法在选择换出页面时参考。
- 修改位。**用于表示页面调入内存后是否被修改过**。当处理机以写方式访问页面时，系统将设置该页面的修改位。==由于内存中的页面在外存上都有副本，因此，若页面未修改，则在该页面换出时不需要将页面写到外存，以减少磁盘写的次数；若页面被修改，则**必须将页面重新写到外存上**==。
- 外存地址。**用于指出页面在外存上的存放地址**。该字段供调入页面时使用。

## 6.2.3 缺页中断与地址变换
在请求分页存储管理系统中，**当所访问的页在内存时，其地址变换过程与分页存储管理相同**；当所访问的页不在内存时，则**应先将该页调入内存，再按「与分页存储管理相同的方式」进行地址变换**。

当系统发现所要访问的页不在内存时，便产生一个缺页中断信号，此时用户程序被中断，控制转到「操作系统的缺页中断处理程序」。缺页中断处理程序根据该页在外存的地址，把它调入内存。
- 在调页过程中，若内存有空闲空间，则缺页中断处理程序只需把缺页装入某一个空闲物理块中，再对页表中的相应表项进行修改，如填写物理块号、修改状态位、设置访问字段及修改位初值等；
- 若内存中无空闲物理块，则需要先淘汰内存中的某些页，**若淘汰页曾被修改过，则还要将其写回外存**。

其处理流程如图6.2所示。
 ![](https://img-blog.csdnimg.cn/e86fbcf667214dee8dea05ea75daca1c.png)


缺页中断是一个比较特殊的中断，**它与一般中断相比有着明显的区别**，主要表现如下：
1. **在指令的执行期间产生和处理缺页中断**。通常，CPU是在每条指令执行完毕后，检查是否有中断请求到达，若有便去响应；而**缺页中断是在一条指令的执行期间，发现要访问的指令和数据不在内存时产生和处理的**。
2. **一条指令可以产生多个缺页中断**。例如，执行一条复制指令 `copy A to B` ，假定指令和操作数都不在内存中，并且每个操作数不在同一页面中，则这条指令执行时，将产生多次缺页中断，如图6.3所示。请求分页系统要想顺利工作，至少应保证一条指令能完全装入内存。
3. **缺页中断返回时，执行产生中断的那一条指令**；而一般中断返回时，执行下一条指令。
![](https://img-blog.csdnimg.cn/7a8b2d6ce2cc4670ba1bef197485a5d4.png)


## 6.2.4 页面分配和置换策略
**请求分页存储管理系统能使更多的作业同时多道运行，从而提高了系统的效率**，但缺页中断的处理要付出相当的代价，由于页面的调入、调出，要增加I/O的负担而且影响系统效率，因此，**应尽可能地减少缺页中断的次数**。

在请求分页存储管理系统中，不可能也不必要把一个进程的所有页面调入主存，那么，==操作系统决定为某进程分配多大的主存空间，需要考虑以下因素：分配给一个进程空间的大小，装入内存中的进程个数==。
- 基于这些因素，可以采用两种页面分配策略，即**固定分配**和**可变分配**。固定分配是指**分配给进程的主存块数是固定的，且在进程创建时确定块数**。可变分配允许**分配给进程的主存块数随进程的执行而改变**。
- 在进行页面置换时，也可以采用两种策略，即**全局置换**和**局部置换**。全局置换允许**一个进程从全部内存物理块集合中选择淘汰对象**，而局部置换规定**每个进程只能从分配给它的物理块中选择淘汰对象**。

将页面分配策略和页面置换策略组合起来，有如下三种可行的策略：
1. **固定分配局部置换**。采用这种策略时，==为每一个进程分配固定数量的物理块，在进程的整个运行期间进程拥有的物理块数不再改变。如果进程在运行中出现缺页，则只能从「该进程的几个页面」中选择一页换出，然后再调入缺页==，以**保证分配给该进程的内存空间量不变**。
实现这种策略的困难在于，**难以确定应为每个进程分配多少个物理块**。若分配的物理块太少，会频繁出现缺页中断，降低了系统性能；若分配的物理块太多，又必然使驻留内存的进程数目减少，进而可能造成CPU或其他资源的利用率下降。
2. **可变分配全局置换**。采用这种策略时，==先为系统中的每一个进程分配一定数量的物理块，操作系统本身也保持一个空闲物理块队列。当某个进程发生缺页时，由系统从空闲物理块队列中取出一个物理块分配给该进程，并将缺页装入其中==。这样，凡产生缺页的进程都将获得新的物理块。==当空闲物理块队列中的物理块用完时，操作系统才从内存中选择一页调出==，该页可能是系统中某一个进程的页面。这是一种**容易实现的页面分配和置换策略**，目前已用于若干操作系统中。
3. **可变分配局部置换**。采用这种策略时，==为每一个进程分配一定数量的物理块，当某个进程发生缺页时，只允许从该进程的页面中选出一页换出，这样就不会影响其他进程运行==。如果某个进程在运行过程中频繁地发生缺页中断，则系统再为该进程分配若干物理块，直到进程的缺页率降低到适当程度为止；反之，若一个进程在运行过程中的缺页率特别低，则系统可适当减少分配给该进程的物理块数，但不应引起缺页率的明显增加。

影响缺页率的因素如下：
1. **主存页框数**。**作业分得的主存块数多，则缺页中断率就低**，反之，缺页中断率就高。试验分析表明，对每个作业来说，要使其有效工作，它在主存中的页面数应不低于它的总页面数的一半。所以，如果一个作业总共有 $n$ 页，那么，只有当主存至少有 $n/2$ 块页框时才让它进入主存执行，这样可以使系统获得高效率。
2. **页面置换算法**。置换算法的优劣影响缺页中断次数。在6.2.5节讨论页面置换算法。
3. **页面大小**。**如果划分的页面大，则缺页中断率就低**；否则，缺页中断率就高。在6.2.6节讨论页面大小的选择。
4. **程序特性**。程序编制的方法不同，对缺页中断的次数有很大影响，程序的局部性要好。

例如：有一个程序要将 $128×128$ 的数组置初值为 $0$ 。现假定分给这个程序的主存块数只有一块，页面的尺寸为每页 $128$ 个字，数组中的元素每一行存放在一页中，开始时第一页在主存。若程序编制如下：
```cpp
int i, j, a[128][128];
for ( j = 0; j < 128; j++)
	for ( i = 0; i < 128; i++)
		a[i][j]=0;
```
则每执行一次 $a[i][j]＝0$ 就要产生一次缺页中断，于是总共要产生 $128×128－1$ 次缺页中断。如果重新编制这个程序如下：
```cpp
int i, j, a[128][128];
for ( i = 0; i < 128; i++)
	for ( j = 0; j < 128; j++)
		a[i][j]=0;
```
那么，总共只产生 $128-1$ 次缺页中断。

从该例中可以看出，**虚拟存储器的效率与程序的局部性程度密切相关**，局部性的程度因程序而异，一般说，总希望编出的程序具有较好的局部性。这样，程序执行时可经常集中在几个页面上进行访问，减少缺页中断率。
## 6.2.5 页面置换算法
当被访问页不在内存时，系统便产生缺页中断。若此时没有空闲内存空间存放缺页，则需要将内存中的某页面换出到外存上，以腾出空间存放缺页。**页面置换算法就是用来选择换出页面的算法**，也称为页面淘汰算法。下面介绍几种比较常用的页面置换算法。
### 1. 最佳置换算法 `OPT`
最佳置换算法是从内存中选择**不再访问的页面**，或**在最长时间以后才需要访问的页面**予以淘汰。实际上，这种算法实现困难，因为页面访问的未来顺序是很难精确预测的。但可以利用该算法评价其他算法的优劣。

假定系统为某进程分配了3个物理块，进程运行时的页面走向为：$4、3、2、1、4、3、5、4、3、2、3、5$ ，开始时 $3$ 个物理块均为空闲，采用最佳置换算法时的页面置换情况如表6.1所示。
![](https://img-blog.csdnimg.cn/bacad27e8b54494db4f44adf29056d6f.png)
从表6.1中可以看出，共发生了6次缺页数，其缺页率为6/12=50% 。
### 2. 先进先出置换算法 `FIFO`
先进先出置换算法总是选择「在内存中驻留时间最长的页面」予以淘汰，即**先进入内存的页面先退出内存**。这种算法的出发点是最早调入内存中的页面，其不再使用的可能性会大一些。==先进先出置换算法的实现比较简单，对具有按线性顺序访问的程序比较合适，而对其他情况则效率不高==。因为经常被访问的页面，往往在内存中停留得最久，结果这些常用的页面终因“变老”而被淘汰。另外，==先进先出算法还存在一种异常现象，即在某些情况下会出现分配给进程的页面数增多，缺页次数反而增加的奇怪现象==，这种现象称为 *Belady* 现象。表6.2及表6.3说明了这一现象。

设某进程执行时的页面走向为 $1、2、3、4、1、2、5、1、2、3、4、5$ ，置换算法采用先进先出。表6.2给出了分配给进程的物理块数为 $3$ 时的页面置换情况，表6.3给出了分配给进程的物理块数为 $4$ 时的页面置换情况。
![](https://img-blog.csdnimg.cn/7b739c722bf4406385ce7bb8de2910b3.png)
从表6.2中可以看出，当分配给进程的物理块数为 $3$ 时，产生的缺页次数为 $9$ ；从表6.3中可以看出，当分配给进程的物理块数为 $4$ 时，产生的缺页次数为 $10$ 。

*Belady* 现象的描述如下：一个进程 $P$ 要访问 $M$ 个页，操作系统分配 $N$ 个内存页框给进程 $P$ ；对一个访问序列 $S$ ，发生缺页次数为 $PE(S,N)$ 。当 $N$ 增大时，$PE(S, N)$ 时而增大，时而减小。产生 *Belady* 现象的原因是，**FIFO算法的置换特征与进程访问内存的动态特征是矛盾的**，即被置换的页面并不是进程不会访问的。

### 3. 最近最久未使用算法 `LRU`
最近最久未使用算法选择「最近一段时间内最长时间没有被访问过的页面」予以淘汰。这种算法的主要出发点是，**如果某个页面被访问了，则它可能马上还要被访问**。或者反过来说，如果某页很长时间未被访问，则它在最近一段时间也不会被访问。

假定系统为某进程分配了 $3$ 个物理块，进程运行时的页面走向为：$4、3、2、1、4、3、5、4、3、2、3、5$ ，开始时 $3$ 个物理块均为空闲，采用最近最久未使用算法时的页面置换情况如表6.4所示。
![](https://img-blog.csdnimg.cn/8ce0f4d6e89446a383291f1252ed5992.png)
从表6.4中可以看出，共发生了 $9$ 次缺页数，其缺页率为 $9/12=75\%$  。LRU算法的性能接近于最佳算法，但实现起来比较困难。因为==要找出最近最久未使用的页面，必须为每一页设置相关记录项，用于记录页面的访问情况，并且在每一次页面访问时都要更新这些记录==。这显然要花费巨大的系统开销，因此，在实际系统中往往使用LRU的近似算法。

可采用**以下两种方法**来实现LRU算法：
1. 链表法。用一个单链表保存「当前进程所访问的各页面号」，刚使用过的页面放表尾，则表头一定是最近最久未使用的页面。其实现思想为：==当分配给进程的物理块未用完时，则将进程装入内存的页面按先后顺序构成一个链表==；当进程访问的页面在内存时，将页面从链表中移出放到表尾；**当进程访问的页面不在内存时，则发生缺页中断，将表头页面置换**。
例如：设分配给某进程 $4$ 个物理块，页面访问序列为：$3、2、4、1、5、4、3、2$ ，用单链表实现LRU算法的过程如图6.4所示。
![](https://img-blog.csdnimg.cn/333f795585954b12bf10ee9ed0e66d11.png)
2. 计数器法。为每个页面设立一个寄存器记录页面访问情况。==每当进程访问某页面时，将该页面对应寄存器的最高位置 $1$ ，系统定期将寄存器右移一位并且将最高位补 $0$ ，于是「寄存器数值最小的页面」是最近最久未使用的页面==。利用 $8$ 位寄存器记录 $8$ 个页面访问情况的示例如图6.5所示。
![](https://img-blog.csdnimg.cn/a89030209e784332b9efaee6c7ebc9f4.png)	从图6.5中可以看出，页面 $7$ 是最近最久未使用的页面。

### 4. 其他页面置换算法
#### (1) 二次机会 `second chance` 算法。
FIFO算法可能会把经常使用的页面淘汰掉，可以**对FIFO算法进行改进，把FIFO算法与页表中的“引用位”结合起来使用**，算法可实现如下：
- 首先检查FIFO中的队首页面（这是最早进入主存的页面），如果它的“引用位”是 $0$ ，那么，这个页面既老又没有用，选择该页面淘汰；
- 如果它的“引用位”是 $1$ ，说明虽然它进入主存较早，但最近仍在使用。于是把它的“引用位”清成 $0$ ，并把这个页面移到队尾，把它看做是一个新调入的页，再给它一个机会。

其含义是最先进入主存的页面，如果最近还在被使用的话，仍然有机会作为像一个新调入页面一样留在主存中。

#### (2) 简单时钟算法 `clock`
==如果利用标准队列机制构造FIFO队列，第二次机会页面调度算法将可能产生频繁的出队入队，实现代价较大==。因此，往往采用**循环队列机制**构造页面队列，这样就形成了一个类似于钟表面的环形表，**队列指针则相当于钟表面上的表针，指向可能要淘汰的页面**，这就是时钟页面替换算法的得名。`clock` 与第二次机会算法本质上没有区别。

**简单时钟算法**也称为**最近未使用算法** `NRU` ，**它是LRU和FIFO的折中**。该算法要求为每页设置一个访问位，并将内存中的所有页链接成一个循环队列。当某页被访问时，系统将其访问位设置为 $1$ 。==置换时采用一个指针，从当前指针位置开始按序检查各页，若访问位为 $0$ 则选择该页换出，若访问位为 $1$ ，则将其设置为 $0$ ，最后指针停留在被置换页的下一页上==。

例如，在某时刻系统置换后循环链表如图6.6(a)所示。现在需要装入一个新页 $72$ ，装入后的结果如图6.6(b)所示。
![](https://img-blog.csdnimg.cn/658f50552e0e48f0bfcd9d061427fce0.png)

#### (3) 改进的时钟算法
将一个修改过的页面换出需要写磁盘，其开销大于未修改页面。为此在时钟算法的基础上，考虑页面的修改情况，增加修改位。设 $U$ 为访问位，$M$ 为修改位，将页面分为以下四种类型：
- $1$ 类 $(U=0，M=0)$ ：未被访问又未被修改；
- $2$ 类 $(U=0，M=1)$ ：未被访问但已被修改；
- $3$ 类 $(U=1，M=0)$ ：已被访问但未被修改；
- $4$ 类 $(U=1，M=1)$ ：已被访问且已被修改。

该算法的置换策略是：
1. 从指针当前位置开始扫描循环队列，寻找 $U=0, M=0$ 的页面，将满足条件的第一个页面作为淘汰页。
2. 若第 $1$ 步失败，则开始第 $2$ 轮扫描，寻找 $U=0, M=1$ 的页面，将满足条件的第一个页面作为淘汰页，并将所有经历过页面的访问位置 $0$ 。
3. 若第 $2$ 步失败，则将指针返回到开始位置，然后重复第 $1$ 步，若仍失败则必须重复第 $2$ 步。**此时一定能找到淘汰页面**。

该算法的特点是**减少了磁盘I/O次数，但算法本身开销增加**。

#### (4) 最不常用算法 `LFU`
最不常用算法选择「到当前时间为止访问次数最少的页」淘汰。该算法要求为每页设置一个访问计数器，每当页被访问时，该页的访问计数器加 $1$ 。发生缺页中断时，淘汰计数值最小的页面，并将所有计数器清零。
#### (5) 页面缓冲算法
页面缓冲算法是对FIFO算法的发展，**通过建立置换页面的缓冲，就有机会找回刚被置换的页面，从而减少系统I/O的开销**。页面缓冲算法用FIFO算法选择被置换页，**选择出的页面不是立即换出，而是放入两个链表之一**——如果页面未被修改，就将其归入到空闲页面链表的末尾，否则将其归入到已修改页面链表末尾。

这些空闲页面和已修改页面会在内存中停留一段时间。如果这些页面被再次访问，只需将其从相应链表中移出，就可以返回给进程，从而减少了一次磁盘I/O。需要调入新的物理页时，将新页面读入到空闲页面链表的第一个页面中，然后将其从该链表中移出。==当已修改页面达到一定数目后，再将它们一起写入磁盘，然后将它们归入空闲页面链表。这样能大大减少I/O操作的次数==。
## 6.2.6 页面大小的选择
从**页表大小**考虑。在虚拟空间大小一定的前提下，不难看出页面大小的变化对页表大小的影响。如果页面较小，虚拟空间的页面数就增加，页表也随之扩大。由于每一个作业都必须有自己的页表，因此，**为了控制页表所占的主存量，页面的尺寸还是较大一点为好**。

从**主存利用率**考虑。主存是以块为分配单位的，作业程序一般不可能正好划分为整数倍的页面。于是，作业的最后一个页面进入主存时，总会产生内部碎片，平均起来一个作业将造成半块的浪费。**为了减少内部碎片，页面的尺寸还是小一点为好**。

从**读写一个页面所需的时间**考虑。作业都存放在辅助存储器上，==从磁盘读入一个页面的时间包括等待时间（移臂时间+旋转时间）和传输时间，通常等待时间远大于传输时间==。显然，**加大页面的尺寸，有利于提高I/O的效率**。

最佳页面尺寸。目前采用页式虚拟存储管理的计算机系统中，页面大小大多选择在 $512$ 字节到 $4\textrm{K}$ 字节之间。之所以如此，是从减少内部碎片和页表耗费的存储空间两个角度出发推导出来的。

假定 $S$ 表示用户作业程序的字节数平均长度，$P$ 表示以字节为单位的页面长度，且有 $S>>P$ ，而每个页表项需要 $e$ 个字节。则每个作业的页表长度为 $S/P$ ，占用了 $Se/P$ 个字节的页表空间，在作业的最后一页，假定浪费的主存平均为 $P/2$ 个字节。则对一个作业而言，有：
$$浪费的存储字=页表使用的主存空间+内部碎片=Se/P+P/2$$

==在页面比较小时页表占用空间多（因 $Se/P$ 较大)，在页面比较大时内部碎片浪费多（因 $P/2$ 较大）==，那么，$P$ 的最优值一定在中间的一个点。现在对 $P$ 求一阶导数并令其为 $0$ ，得到方程：
$$-Se/P^2+1/2=0$$

假如仅考虑**碎片浪费的和页表占用的主存**，那么，从这个方程可以得出最优页面尺寸为
$$P = \sqrt{ 2Se}$$

时，浪费的存储字节最少，称 $P$ 为最佳页面尺寸。对于 $S=128\textrm{KB}$ ，每个页表项 $e=8\textrm{B}$ 时，最优页面尺寸是 $1448$ 字节。考虑到其他因素，如页面地址变换方式、磁盘速度，实际可使用 $1\textrm{KB}$ 或 $2\textrm{KB}$ 长的页面。大部分商用计算机使用的页面尺寸在 $512\textrm{B}$ 至 $4\textrm{KB}$ 之间。

## 6.2.7 工作集和抖动
### 1. 工作集
工作集理论是1968年由 *Denning* 提出并推广的。*Denning* 认为，**程序在运行时对页面的访问是不均匀的，往往比较集中**。在某段时间内，其访问范围可能局限于较少的若干页面；而在另一段时间内，其访问范围又可能局限于另一些较少页面。==如果能够预知程序在某段时间间隔内要访问哪些页面，并能提前将它们调入内存，将会大大降低缺页率，从而减少置换工作==，提高CPU的利用率。

所谓**工作集**是指**在某段时间间隔 $Δ$ 里，进程实际访问的页面集合**。具体地说，便是把某进程在时间 $t-Δ$ 到 $t$ 之间所访问的页面集合记为 $W(t, Δ)$ ，把变量 $Δ$ 称为**工作集窗口尺寸**。通
常还把 **「工作集中所包含的页面数目」称为工作集尺寸**，记为 $\mid W(t, Δ)\mid$ 。

*Denning* 认为，==虽然只要装入少数几页就可以启动程序运行，但为使程序能有效地运行，较少地产生缺页，就必须使程序的工作集全部在内存中==。然而，由于我们无法预知、程序在不同时刻将访问哪些页面，因而只能像置换算法那样，利用程序过去某段时间内的行为，作为程序在将来某段时间内行为的近似。

**正确选择工作集窗口尺寸，对存储器的有效利用和系统吞吐率的提高，都将产生重要影响**。一方面，如果把 $Δ$ 选得很大，进程虽不易产生缺页，但存储器也将不会得到充分利用；另一方面，如果把 $Δ$ 选得过小，则会使进程在运行过程中频繁地产生缺页中断，反而降低了系统的吞吐率。
### 2. 抖动
在分页存储管理系统中，内存中只存放了那些经常使用的页面，而进程中的其他部分则存放在外存中，当进程运行需要的内容不在内存时，便启动磁盘读操作将所需内容调入内存，若内存中没有空闲物理块，还需要将内存中的某页面置换出去。也就是说，**系统需要不断地在内外存之间交换信息**。==若在系统运行过程中刚被淘汰出内存的页面，过后不久又要访问它，需要再次将其调入，而该页面调入内存后不久又再次被淘汰出内存，然后又要访问它，如此反复，使得系统把大部分时间用在了页面的换入/换出上，而几乎不能完成任何有效的工作==，这种现象称为**抖动**（又称**颠簸**）。

在多道程序系统中，如果CPU的利用率太低，CPU调度程序就会增加多道程序度，将新进程引入系统，以提高CPU的利用率。**随着新进程的启动运行，它们需要从其他进程那里取得一些内存物理块，这将使其他进程的缺页次数增加**，使等待页面换入/换出的进程数目增加，从而导致CPU利用率的进一步下降。为此调度程序进一步增加多道程序度，如此恶性循环，最终出现抖动。

图6.7给出了CPU利用率和多道程序度之间的关系。开始时，随着多道程序度的增加，CPU的利用率也随之增加，当CPU的利用率达到最大值后，如果继续增加多道程序度，就会产生抖动，使CPU利用率急剧下降。此时，**为了增加CPU的利用率和消除抖动，必须减少多道程序度**。
![](https://img-blog.csdnimg.cn/43341a1dbe8f42928806c4b82595baa2.png)

抖动产生的原因有：进程分配的物理块太少，置换算法选择不当，**全局置换使抖动传播**。

抖动发生前会出现一些征兆，可利用这些征兆发现抖动并加以防范。这些技术有：全局范围技术；L=S准则；利用缺页率发现抖动；利用平均缺页频率。
- **全局范围技术**采用时钟置换算法，用一个计数器 $C$ 记录「搜索指针扫描页面缓冲的速度」。若 $C$ 的值大于给定的上限值，说明缺页率太高（可能抖动）或找不到可供置换的页面，这时应减少程序道数。若 $C$ 小于给定的下限值，表明缺页率小或存在较多可供置换的页面，这时应增加程序的道数。
- $L=S$ 准则。实际证明，**产生缺页的平均时间 $L$ 等于系统处理缺页的平均时间 $S$ 时，CPU的利用率达到最大**。当 $L<S$ 时，表明系统频繁缺页，CPU利用率低，会导致系统抖动。
- **利用缺页率发现抖动**。==当缺页率超过上限时会引起抖动，因此应增加分配给进程的物理块；此时每增加一个物理块，其缺页率明显降低；当进程缺页率达到下限值时，物理块的进一步增加对进程缺页率的影响不大==。该方法要求为每页设一个使用位，当该页被访问时，相应位置 $1$ 。同时设计一个计数器，记录自上次进程产生缺页以来进程执行的时间。
	- 方法1：**设置一个阈值 $F$ ，如最近两次缺页时间间隔小于 $F$ ，则分配一个物理块给该进程**；否则淘汰使用位为 $0$ 的页，并减少该进程的物理块数，同时将该进程的剩余页使用位重置为 $0$ 。
	- 方法2：**设置两个阈值，当缺页率达到上限值时为进程增加物理块，当缺页率达到下限值时减少进程的物理块**。

	该算法的缺点是：==当进程由一个局部转移到另一个局部时，在原局部中的页面未移出内存之前，连续的缺页会导致「该进程在内存的页面」迅速增加，产生对内存请求的高峰==。
- **利用平均缺页频率**。设 $t_i$ 为两次缺页之间的间隔时间，$f_i$ 为其缺页频率，则有： $f_i= 1/t_i$ 。设 $F$ 为平均缺页频率，则有：$F=（f_1+f_2+\dots +f_n) /n$ 。当 $F$ 大于系统中规定的允许缺页频率时，则说明系统中缺页率过高，有可能引起抖动。

下面介绍一些**防止抖动发生与限制抖动影响**的方法。
1. **采用局部置换策略**，可以防止抖动的传播。当一个进程出现抖动时，由于采用了局部置换算法，使它不能从其他进程那里获得物理块，从而不会引起其他进程出现抖动，使抖动局限于一个小范围内。当然，==这种方法并未消除抖动，而且当一些进程发生抖动后，还会使等待磁盘I/O的进程增多，使得平均缺页处理时间延长==。
2. **利用工作集模型防止抖动**。引入工作集模型后，由操作系统记录每个进程的工作集，并且给它分配工作集所需的物理块。若系统中还有足够多的空闲物理块，则可以从外存上装入并启动新进程。
3. **通过挂起进程来解决抖动问题**。当出现CPU利用率很低、而磁盘I/O很频繁的情况时，可能因为多道程序度太高而造成抖动。为此可以挂起一个或几个进程，腾出内存空间供抖动进程使用，从而消除抖动。**选择挂起进程的策略有多种**，如选择优先级最低的进程、选择发生缺页中断的进程、选择最近激活的进程、选择最大的进程等。

## 6.2.8 页的共享与保护
==在分页存储管理系统中，实现共享的方法是**使多个作业的页表项指向相同的物理块**==。在分页存储管理系统中实现共享，比分段存储管理系统中要困难，这是因为
- 「分页存储管理系统中将作业的地址空间划分成页面」的做法对用户是透明的；
- 同时作业的地址空间是线性连续的，当系统将作业的地址空间分成大小相同的页面时，被共享的部分不一定被包含在一个完整的页面中，这样不应共享的数据也被共享了，不利于保密。
- 另外，共享部分的起始地址在各作业的地址空间也不相同，因此在划分成页的过程中，其页内位移也可能不同，这也使共享比较困难。

分页存储管理系统可以为内存提供两种保护方式。一种是**地址越界保护**，即通过地址变换机构中的页表长度和所访问逻辑地址中的页号相比较来完成；另一种是通过页表中的**存取控制**信息，对内存信息提供保护。例如，在页表中设置一个存取控制字段，根据页面使用情况将该字段定义为读、写、执行等权限，==在进行地址变换时，不仅要从页表的相应表项中、得到该页对应的物理块号，同时还要检查本次操作与存取控制字段允许的操作是否相符，若不相符，则由硬件捕获并发出保护性中断==。

---
# 6.3 请求分段存储管理
## 6.3.1 请求分段存储管理的实现思想
请求分段存储管理系统是在分段存储管理系统的基础上，增加了**请求调段功能、分段置换功能**所形成的一种虚拟存储系统。

在请求分段存储管理系统中，作业运行之前，只要求将当前运行需要的若干个分段装入内存，便可启动作业运行。在作业运行过程中，如果要访问的分段不在内存，则通过调段功能将其调入，同时还可以通过置换功能将暂时不用的分段换出到外存上，以便腾出内存空间。为此，需要对段表进行扩充，扩充后的段表项如图6.8所示。
![](https://img-blog.csdnimg.cn/0a5ee76de0354bedb9e51c76d94c9b81.png) 
在如图6.8所示的段表中，**段号、段长和内存始址三个信息是进行地址变换所必需的**，其他字段的含义与请求分页存储管理类似，状态位用于表示分段是否在内存中，访问字段用于记录分段在一段时间内被访问的次数、或最近已有多长时间未被访问，修改位用于表示分段调入内存后是否被修改过，**外存地址用于指出分段在外存上的存放地址**。

在请求分段存储管理系统中，当被访问分段在内存时，其地址变换过程与分段存储管理相同；当分段不在内存时，应先将该段调入内存，然后再进行地址变换。

当系统发现所要访问的分段不在内存中时，将产生一个缺段中断信号。此时用户程序被中断，控制转到操作系统的缺段中断处理程序，缺段中断处理程序根据该分段在外存的地址把它调入。在调段过程中，若内存中有足够大的空闲分区存放该段，则缺段中断处理程序只需把缺段装入某一个空闲分区中，如需要还应进行分区的划分，再对段表中的相应表项进行修改，如填写内存始址、修改状态位、设置访问字段及修改位初值等；**若没有满足要求的空闲分区，则检查空闲分区容量总和，确定是否需要对分区进行拼接，或者调出一个或几个分段后、再装入所需要的分段**。缺段中断处理流程如图6.9所示。
![](https://img-blog.csdnimg.cn/ced5aa10111844acb0ba5d90912eb594.png)

## 6.3.2 段的共享与保护
在分段存储管理系统中，分段的共享是通过**使多个作业的段表中相应表项、都指向被共享段的同一个物理副本**来实现的。

为了实现分段的共享，**除了原有的进程段表外，还要在系统中建立一张段共享表**，每个共享分段占一个表项，每个表项包含两部分内容：
- 第一部分有共享段名、段长、主存起址、状态位（如在不在主存位）、**辅存地址**、**共享进程个数计数器**。
- 第二部分有共享该段的所有进程名、状态、段号、存取控制位（通常为只读）。

由于共享段是供多个进程公用的，对它的主存分配要如下进行。
1. ==当出现第一个要使用某个共享段的进程时，由系统为此共享段分配物理主存区，再将共享段调入该区==。
2. 同时，将共享段主存区始址填入「共享段表中对应项的主存始址」处，共享进程个数计数器加 $1$ ，修改状态位（“在主存位”为 $1$ ），填写使用该共享段进程的有关信息（进程名、使用共享段的段号、存取控制等）。而进程段表中共享段的表项指向主存共享段表地址。
3. 此后，==又有进程使用已调入「主存的同名共享段」时，仅需直接填写共享段表和进程段表，以及把共享进程个数计数器加 $1$ 就行了==。
4. 当进程不再使用共享段时，应释放该共享段，除了在共享段表中删去进程占用项外，还要把共享进程个数计数器减 $1$ 。
5. 当共享进程个数计数器为 $0$ 时，说明已没有进程使用此共享段了，系统需回收该共享段的物理内存，并把占用表项也取消。

这样做有许多优点：
- **不同进程可以用不同段号，使用同一个共享段**；
- 由于进程段表中共享段的表项指向主存共享段表地址，所以，==每当共享段被移动、调出或再装入时，只要修改共享段表的项目，不必修改共享段的每个进程的段表==。

在多道程序环境下，必须注意共享段中信息的保护问题。**当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据**。在当今大多数实现信息共享的系统中，程序被分成**代码区**和**数据区**。==不能修改的代码称为纯代码或可重入代码，这样的代码和不能修改的数据是可以共享的，而可修改的程序和数据则不能共享==。

与分页存储管理系统类似，分段存储管理系统的保护方法主要有两种。一种是**地址越界保护**，另一种是**访问控制保护**。关于访问控制保护的实现方式已在前一小节中介绍，这里不再重复。而地址越界保护，则是利用段表寄存器中的段表长度、与逻辑地址中的段号比较，若段号大于段表长度则产生越界中断；再利用段表项中的段长、与逻辑地址中的段内位移进行比较，若段内位移大于段长，也会产生越界中断。==不过在允许段动态增长的系统中，段内位移大于段长是允许的。为此，段表中应设置相应的增补位，以指示该段是否允许动态增长==。
## 6.3.3 虚拟段页式存储管理
虚拟段页式存储管理是虚拟页式和虚拟段式存储管理的结合。**虚地址以程序的逻辑结构划分成段**，**实地址划分成位置固定、大小相等的页框（块）**，对于用户来说，段式虚拟地址应该由段号 $s$ 和段内位移 $d'$ 组成，操作系统内部再自动把 $d'$ 解释成两部分：段内页号 $p$ 和页内位移 $d$ ，也就是说，$d'=p×块长+d$ 。

**请求段页式虚存管理的数据结构更为复杂，包括作业表、段表和页表三级结构**。作业表中登记了进入系统中的所有作业及该作业段表的起始地址，段表中至少包含这个段是否在内存，以及该段页表的起始地址，页表中包含了该页是否在主存（中断位）、对应主存块号。

**请求段页式虚存管理的「动态地址转换机构」由段表、页表和快表构成**。当前运行作业的段表起始地址，已被操作系统置入段表控制寄存器，其动态地址转换过程如下：
1. 从逻辑地址出发，先以段号 $s$ 和页号 $p$ 作索引去查快表，如果找到，那么立即获得页 $p$ 的页框号 $p'$ ，并与位移 $d$ 一起拼装、得到访问主存的实地址，从而完成了地址转换。
2. 若查快表失败，就要通过段表和页表来做地址转换了，用段号 $s$ 作索引，找到相应表目，由此得到 $s$ 段的页表的起始地址 $s'$ ，再以 $p$ 作索引得到 $s$ 段 $p$ 页对应的表目，由此得到页框号 $p'$ 。
3. 这时一方面把 $s$ 段 $p$ 页和页框号 $p'$ 置换进快表，另一方面用 $p'$ 和 $d$ 生成主存的物理地址，从而完成地址转换。

上述过程是**假设所需信息都在主存的情况下**进行的，事实上，许多情况会产生意外，如查段表时，发现 $s$ 段不在主存，于是产生“缺段中断”，引起操作系统查找 $s$ 段在辅存的位置，并将该段页表调入主存；如查页表时，发现 $s$ 段的 $p$ 页不在主存，于是产生“缺页中断”，引起操作系统查找 $s$ 段 $p$ 页在辅存的位置，并将该页调入主存，当主存已无空闲页框时，就会导致页面置换。
