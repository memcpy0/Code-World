> 本文属于「数据库系统」系列文章之一，这一系列着重于「数据库系统知识的学习与实践」。由于文章内容随时可能发生更新变动，欢迎关注和收藏[数据库系统系列文章汇总目录](https://memcpy0.blog.csdn.net/article/details/119996493)一文以作备忘。需要特别说明的是，为了透彻理解和全面掌握数据库系统，本系列文章中参考了诸多博客、教程、文档、书籍等资料，限于时间精力有限，这里无法一一列出。部分重要资料的不完全参考目录如下所示，在后续学习整理中还会逐渐补充：
> - 数据库系统概念 第六版 `Database System Concepts, Sixth Edition` ，作者是 `Abraham Silberschatz, Henry F. Korth, S. Sudarshan` ，机械工业出版社
> - 数据库系统概论 第五版，王珊 萨师煊编著，高等教育出版社


@[toc]
 
关系数据库应用**数学方法**来处理数据库中的数据。最早将这类方法用于数据处理的是1962年CODASYL发表的“信息代数”，之后有1968年David Child在IBM 7090机上实现的集合论数据结构，但是**系统、严格地提出关系模型的是美国IBM公司的E. F. Codd**。
- 1970年，E. F. Codd在美国计算机学会会刊 *Communications of the ACM* 上发表了题为 *A Relational Model of Data for Shared Data Banks* 的论文，开创了数据库系统的新纪元。
- ==1983年，ACM把这篇论文列为从1958年以来的四分之一世纪中，具有里程碑意义的25篇研究论文之一==。此后，**E. F. Codd连续发表了多篇论文，奠定了关系数据库的理论基础**。
- 20世纪70年代末，关系方法的理论研究和软件系统的研制，均取得了丰硕的成果，IBM公司的San Jose实验室在IBM 370系列机上研制的关系数据库实验系统 *System R* ，历时6年获得成功。
- 1981年，IBM公司又宣布了具有 *System R* 全部特征的、新的数据库软件产品 *SQL/DS* 问世。
- 与 *System R* 同期，美国加州大学伯克利分校也研制了 *INGRES* 关系数据库实验系统，并由 *INGRES* 公司发展成为 *INGRES* 数据库产品。

40多年来，关系数据库系统的研究和开发取得了辉煌的成就。关系数据库系统从实验室走向了社会，成为最重要、应用最广泛的数据库系统，大大促进了数据库应用领域的扩大和深入。因此，==关系数据模型的原理、技术和应用十分重要，是数据库课程的重点==。

简单地说，==**关系数据库系统就是支持关系（数据）模型的数据库系统**==。第一章初步介绍了关系模型及其基本术语，这里深入介绍关系模型。按照数据模型的三个要素，关系模型由**关系数据结构、关系操作集合和关系完整性约束**三部分组成。下面分别介绍这三部分内容，2.1讲解关系的形式化定义、**关系数据结构的形式化定义**及有关概念；2.2讲解**关系操作**；2.3讲解**关系的三类完整性约束**；2.4讲解关系代数，即关系数据库系统中实现关系操作的一种语言；最后，在2.5节介绍关系演算。

---
# 本章参考文献
<img src="https://img-blog.csdnimg.cn/d698f38c6e634589aa98bc7d4af6e5d9.png#pic_center" width="25%">

---
# 2.0 常见的关系型数据库管理系统
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202212312027008.png)
接下来对上面列举的数据库管理系统进行简单的介绍：  
- Oracle：收费的大型数据库，Oracle公司的产品，比较昂贵。
- MySQL： 开源免费的中小型数据库。后来Sun公司收购了 MySQL，而Sun公司又被Oracle收购。
- SQL Server：MicroSoft公司收费的中型的数据库。C#、.net 等语言常使用。  
- PostgreSQL：开源免费中小型的数据库。
- DB2：IBM 公司的大型收费数据库产品，没太多人用了。
- SQLite：嵌入式的微型数据库，小巧精致。如作为Android内置数据库。
- MariaDB：开源免费中小型的数据库，是MySQL幕后人员在MySQL被收购后重新做的。

---
# 2.1 关系数据结构及形式化定义
## 2.1.1 关系
==关系模型的数据结构非常简单，只包含**单一的数据结构**——关系==。在用户看来，**关系模型中数据的逻辑结构是一张扁平的二维表**。

关系模型的数据结构虽然简单，但能够表达丰富的语义，描述出现实世界的实体以及实体间的各种联系。也就是说，==在关系模型中，现实世界的实体、实体间的各种联系，均用单一的结构类型，即关系来表示==。

前面已经非形式地介绍了关系模型及有关的基本概念。关系模型是建立在集合代数的基础上的，这里从集合论角度，给出**关系数据结构的形式化定义**。

### 1. 域 `domain`
**定义2.1** ==**域**是一组具有相同数据类型的值的集合，一个域允许的不同取值个数称为这个域的**基数** `cardinal number`==（集合的基数）。
例如，自然数、整数、实数、长度小于 $25$ 字节的字符串集合，$\{0,1\}$ 等，都可以是域。

### 2. 笛卡尔积 `cartesian product`
笛卡尔积是域上的一种集合运算。
 
**定义2.2** 给定一组域 $D_1, D_2, \dots, D_n$ ，允许其中某些域是相同的，==$D_1, D_2, \dots, D_n$ 的笛卡尔积为==：
$$D_1 \times D_2 \times \dots \times D_n = \{ (d_1, d_2, \dots, d_n) \mid d_i \in D_i, i = 1, 2, \dots, n \}$$ 其中，每个元素 $(d_1, d_2, \dots, d_n)$ 叫做一个 **$n$ 元组** `n-tuple` 或简称**元组** `tuple` 。元素中的每个值 $d_i$ 叫做一个**分量** `component` 。

若 $D_i\ (i = 1, 2, \dots, n)$ 为有限集合，其基数为 $m_i\ (i = 1, 2, \dots, n)$ ，则 $D_1 \times D_2 \times \dots \times D_n$ 的基数 $M$ 为：$$M = \prod^n_{i = 1}m_i$$ 

笛卡尔积可表示为一张二维表，**表中的每行对应一个元组，表中的每列的值来自一个域**。例如给出三个域：
- `D1 = 导师集合 SUPERVISOR = {张清玫，刘逸}`
- `D2 = 专业集合 SPECIALITY = {计算机专业，信息专业}` 
- `D3 = 研究生集合 POSTGRADUATE = {李勇，刘晨，王敏}`
- `D1` ，`D2` ，`D3` 的笛卡尔积为
	 ```cpp
	 D1 × D2 × D3＝ {
        (张清玫，计算机专业，李勇)，(张清玫，计算机专业，刘晨)，
        (张清玫，计算机专业，王敏)，(张清玫，信息专业，李勇)，
        (张清玫，信息专业，刘晨)，(张清玫，信息专业，王敏)，
        (刘逸，计算机专业，李勇)，(刘逸，计算机专业，刘晨)，
        (刘逸，计算机专业，王敏)，(刘逸，信息专业，李勇)，
        (刘逸，信息专业，刘晨)，(刘逸，信息专业，王敏) 
	 }
	 ```
	该笛卡尔积的基数为 $2×2×3＝12$ 。也就是说，$D_1 \times D_2 \times D_3$ 一共有 $2 \times 2 \times 3 = 12$ 个元组，这些元组可列成一张二维表，如表2.1所示：
<img src="https://img-blog.csdnimg.cn/1b2da747dcaf4a2094fa9d2e84ee1b18.png#pic_center" width="25%">

### 3. 关系 `relation`
**定义2.3** $D_1 \times D_2 \times \dots \times D_n$ 的子集叫做在域 $D_1, D_2, \dots, D_n$ 上的**关系**，表示为：$$R(D_1, D_2, \dots, D_n)$$ 这里 $R$ 表示关系的**名字**，$n$ 是关系的**目**或**度** `degree` ——当 $n = 1$ 时，称该关系为**单元关系** `unary relation` 或一元关系；当 $n = 2$ 时，称该关系为**二元关系** `binary relation` 。关系中的每个元素是关系中的元组，通常用 $t$ 表示。

**关系是笛卡尔积的有限子集**，笛卡尔积可表示为一张二维表，关系也可表示为一张二维表，**表的每行对应一个元组（关系的元素），表的每列对应一个域**。==由于域可以相同，为了区分，必须对每列起一个**名字，称为属性** `attribute`== 。$n$ 目关系必有 $n$ 个属性。

若关系中的==某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为**候选键** `candidate key`== 。若一个关系有多个候选键，则选定其中一个为**主键** `primary key` 。候选键的诸属性称为**主属性**，不包含在任何候选键中的属性称为**非主属性** `non-prime attribute` 或**非键属性** `non-key attribute` 。在最简单的情况下，候选键只包含一个属性；在最极端的情况下，关系模式的所有属性是这个关系模式的候选键，称为**全键** `all-key` 。在第6章中，我们会在**函数依赖**和**多值依赖**的基础上，更加深入地讨论这些概念。

==一般来说，$D_1, D_2, \dots, D_n$ 的笛卡尔积是没有实际语义的，只有它的某个真子集才有实际含义==。例如，可以发现表2.1的笛卡尔积中许多元组是没有意义的。因为在学校中，一个专业方向有多个导师，而一个导师只在一个专业方向带研究生；一个导师可以带多名研究生，而一名研究生只有一个导师，学习某一个专业。因此，表2.1中的一个子集才是有意义的，才可以表示导师与研究生的关系，把该关系命名为 `SAP` ，如表2.2所示。李勇和刘晨是计算机专业张清玫老师的研究生；王敏是信息专业刘逸老师的研究生。
<img src="https://img-blog.csdnimg.cn/3d4deb31a624415bbfd91d6a55ad2404.png#pic_center" width="25%">

把关系 `SAP` 的属性名取为域名，即 `SUPERVISOR, SPECIALITY, POSTGRADUATE` ，则这个关系可以表示为：`SAP(SUPERVISOR, SPECIALITY, POSTGRADUATE)` 。假设研究生不会重名（这在实际生活中是不合适的，这里只是为了举例方便），则 `POSTGRADUATE` 属性的每个值都唯一地标识了一个元组，因此可作为 `SAP` 关系的主键。



==关系可以有三种类型：基本关系（通常又称为基本表或基表）、查询表和视图表==。其中，**基本表是实际存在的表，它是实际存储数据的逻辑表示**；查询表是查询结果对应的表；视图表是由基本表或其他视图导出的表，是虚表，不对应实际存储的数据。

按照定义2.2，关系可以是一个无限集合。由于**组成笛卡尔积的域不满足交换律**，所以按照数学定义，$(d_1, d_2, \dots, d_n) \ne (d_2, d_1, \dots, d_n)$（说是元组，其实准确来说是 $n$ 元序偶）。**当关系作为关系数据模型的数据结构时，需要给予如下的限定和补充。**
- 无限关系在数据库系统中是无意义的。因此，限定**关系数据模型中的关系必须是有限集合**。
- **通过为关系的每个列附加一个属性名的方法，取消关系属性的有序性**，即 $(d_1, d_2, \dots, d_i, d_j, \dots, d_n) = (d_1, d_2, \dots, d_j, d_i, \dots, d_n)\ (i,j = 1, 2, \dots, n)$ 。

因此，==基本关系具有以下 $6$ 条性质==：
1. 列是同质的 `homogeneous` ，即每一列中的分量是同一类型的数据，来自同一个域。
2. 不同的列可出自同一个域，称其中的每一列为一个属性，**不同的属性要给予不同的属性名**。例如，在上面的例子中，也可以只给出两个域：`人(PERSON) = {张清枚, 刘逸, 李勇, 刘晨, 王敏}, 专业(SPECIALITY) = {计算机专业, 信息专业}` 。
`SAP` 关系的导师属性和研究生属性都从 `PERSON` 域中取值。**为了避免混淆，必须给这两个属性取不同的属性名，而不能直接使用域名**。例如，定义导师属性名为 `SUPERVISOR-PERSON` ，研究生属性名为 `POSTGRADUATE-PERSON` 。
3. （命名属性名后）**列的顺序无所谓，即列的次序可以任意交换**。==由于列顺序是无关紧要的，因此在许多实际关系数据库产品中，增加新属性时永远是插至最后一列==。
4. 任意两个元组的候选键不能取相同的值；
5. **行的顺序无所谓，即行的次序可以任意交换**；
6. ==分量必须取原子值，即每个分量都必须是不可分的数据项==。关系模型要求关系必须是规范化 `normalization` 的，即要求关系必须满足一定的规范条件。==这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项==。规范化的关系简称为**范式** `Normal Form, NF` 。范式的概念将在第6章关系数据理论中进一步讲解。
例如，表2.3虽然很好地表达了导师与研究生之间的一对多关系，但由于属性 `POSTGRADUATE` 中分量取了两个值，不符合规范化的要求，因此这样的关系在数据库中是不允许的。通俗地讲，关系表中不允许还有表，即不允许表中有表。直观地描述，表2.3中还有一个小表。
<img src="https://img-blog.csdnimg.cn/7c796008dd5d4dc2ad1b59f03d51ddf5.png#pic_center" width="25%">



> 注意，许多实际关系数据库产品中，基本表并不完全具有这 $6$ 条性质。例如，有的数据库产品仍然区分了属性顺序和元组顺序。许多时候，人们把元组称为记录，元组和记录是同一个概念。

## 2.1.2 关系模式
在数据库中要区分型和值。**关系数据库中，关系模式是型，关系是值，关系模式是对关系的描述**。那么一个关系需要描述哪些方面呢？关系是笛卡尔积的有限子集，是元组的集合，因此关系模式必须指出这个元组集合的结构，即**它由哪些属性构成**，**这些属性来自哪些域**，以及**属性与域之间的映像关系**。

现实世界随着时间在不断地变化，因而在不同的时刻，关系模式的关系也会有所变化。但是，**现实世界的许多已有事实和规则限定了，关系模式所有可能的关系必须满足一定的完整性约束条件**。==这些约束条件或者通过对属性取值范围的限定==，例如职工年龄小于 $60$ 岁（之后退休），==或者通过属性值间的相互关联反映出来==，例如如果 $2$ 个元组的主键相等，那么元组的其他值也一定相等，因为主键唯一标识一个元组，主键相等就表示这是同一个元组。**关系模式应当刻画出这些完整性约束条件**。

**定义2.4** 关系的描述称为**关系模式** `relation schema` ，它可以形式化地表示为：
$$R(U, D, DOM, F)$$ 其中，$R$ 为**关系名**，$U$ 为**组成该关系的属性名集合**，$D$ 为 $U$ 中**属性所来自的域**，$DOM$ 为**属性向域的映像集合**，$F$ 为「**属性间数据的依赖关系**」（将在第6章讨论，本章的关系模式只涉及关系名、各属性名、域名、属性向域的映像四部分）**集合**。

例如，在上面的例子中，由于导师和研究生出自同一个域——人，所以要取不同的属性名，并在模式中定义属性向域的映像，即说明它们分别出自哪个域，如：
$$\textrm{DOM(SUPERVISOR) = DOM(POSTGRADUATE) = PERSON}$$ 

关系模式通常可以简记为：$$R(U)$$ 或 $$R(A_1, A_2, \dots, A_n)$$ 其中 $R$ 为关系名，$A_1, A_2, \dots, A_n$ 为属性名。而**域名、属性向域的映像常常直接说明为属性的类型、长度**。

**关系是关系模式在某一时刻的状态或内容**。==关系模式是静态的、稳定的，关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据==。例如，学生关系模式在不同的学年，学生关系是不同的。在实际工作中，人们常常把关系模式和关系都笼统称为关系，这不难从上下文加以区别。

## 2.1.3 关系数据库
**在关系模型中，实体以及实体间的联系都是用关系来表示的**。例如导师实体、研究生实体、导师与研究生之间的一对多联系，都可以用一个关系来表示。在一个给定的应用领域中，**所有关系的集合构成一个关系数据库**。

关系数据库也有型和值之分。==关系数据库的型也称为**关系数据库模式**，是对关系数据库的描述==，包括若干域的定义，以及在这些域上定义的若干关系模式。==关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为**关系数据库**==。

## 2.1.4 关系模型的存储结构
==在关系数据模型中，实体及实体间的联系都用（关系）表来表示，但**表是关系数据的逻辑模型**==。在关系数据库的物理组织中，有的关系数据库管理系统中，一个表对应一个操作系统文件，将物理数据组织交给操作系统完成；有的关系数据库管理系统中，从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理。

---
# 2.2 关系操作
**关系模型给出了关系操作的能力的说明**，但不对关系数据库管理系统的语言给出具体的语法要求，也就是说，不同的关系DBMS可以定义和开发不同的语言，来实现这些操作。
## 2.2.1 基本的关系操作
关系模型中，常用的关系操作包括**查询** `query` 操作和**插入** `insert` 、**删除** `delete` 、**修改** `update` 操作两大部分。关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为**选择** `select` 、**投影** `project` 、**连接** `join` 、**除** `divide` 、**并** `union` 、**差** `except` 、**交** `intersection` 、**笛卡尔积**等，其中==选择、投影、并、差、笛卡尔积是五种基本操作==，其他操作可用基本操作来定义和导出，就像乘法可用加法来定义和导出一样。

关系操作的特点是**集合操作方式**，即==操作的对象和结果都是集合==。这种操作方式也称为**一次一集合** `set-at-a-time` 。相应的，非关系数据模型的数据操作方式则为**一次一记录** `record-at-a-time` 。

## 2.2.2 关系数据语言的分类
早期的关系操作能力，通常用代数方式或逻辑方式来表示，分别称为**关系代数** `relational algebra` 和**关系演算** `relational calculus` 。关系代数用**对关系的运算**来表达查询要求，关系演算则用**谓词**来表达查询要求。关系演算又可按谓词变元的基本对象是元组变量还是域变量，分为==元组关系演算==和==域关系演算==。一个关系数据语言能够表示关系代数可以表示的查询，称为**具有完备的表达能力**，简称**关系完备性**。已经证明，==关系代数、元组关系演算、域关系演算三种语言在表达能力上是等价的，都具有完备的表达能力==。

关系代数、元组关系演算和域关系演算均是抽象的查询语言，这些抽象的语言与具体的关系DBMS中实现的实际语言并不完全一样，但它们能用做评估实际系统中查询语言能力的标准或基础。实际的查询语言，除了提供关系代数或关系演算的基本功能外，还提供了许多附加功能，例如聚集函数 `aggregation function` 、关系赋值、算术运算等，使得目前实际查询语言的功能十分强大。

另外，还有一种介于关系代数和关系演算之间的==结构化查询语言 `structured query language, SQL`==，SQL不仅具有丰富的查询功能，而且具有数据定义和数据控制功能，==是集查询、数据定义语言、数据操纵语言和数据控制语言 `data control language, DCL` 于一体的关系数据语言==。它充分体现了关系数据语言的特点和优点，是关系数据库的标准语言。

因此，关系数据语言可以分为三类：
- 关系代数语言：*ISBL*
- 关系演算语言：
	- 元组关系演算语言：*ALPHA*、*QUEL*
	- 域关系演算语言：*QBE*
- 具有关系代数和关系演算双重特点的语言：*SQL*

特别地，==SQL语言是一种**高度非过程化**的语言，用户不必请求数据库管理员为其建立特殊的存取路径，存取路径的选择由关系DBMS的优化机制来完成==。例如，在一个存储有百万条记录的关系中，查找符合条件的某一个或某一些记录，从原理上讲可以有多种查找方法，例如，可以顺序扫描这个关系；可以通过某一种索引来查找。不同的查找路径（或称为**存取路径**）的效率是不同的，有的完成某个查询可能很快，有的可能极慢。==关系DBMS中研究和开发了查询优化方法，系统可以自动选择较优的存取路径，提高查找效率==。

---
# 2.3 关系的完整性
**关系模型的完整性规则是对关系的某种约束条件**。也就是说，关系的值随时间变化时应该满足一些约束条件。这些约束条件实际上是现实世界的要求。**任何关系在任何时刻都要满足这些语义约束**。

==关系模型中有三类完整性约束：**实体完整性** `entity integrity` 、**参照完整性** `referential integrity` 、**用户定义的完整性** `user-defined integrity`==，其中实体完整性和参照完整性是关系模型**必须满足**的完整性约束条件，被称作==关系的两个不变性==，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了==具体领域中的语义约束==。

## 2.3.1 实体完整性
关系数据库中每个元组应该是**可区分的**、**唯一的**。这样的约束条件用实体完整性来保证。

**规则2.1 实体完整性规则** ==若属性（指一个或一组属性）$A$ 是基本关系 $R$ 的主属性，则 $A$ 不能取空值 `null value` 。所谓空值就是“不知道”或“不存在”或“无意义”的值==。有关空值的处理，见[【数据库系统】第一部分 数据库基础(3) 关系数据库标准语言SQL(6) 空值的处理](https://memcpy0.blog.csdn.net/article/details/120913964)。

例如，`学生(学号, 姓名, 性别, 专业号, 年龄)` 关系中，学号为主键，则学号不能取空值。

==按照实体完整性规则的规定，如果主键由若干属性组成，则所有这些主属性都不能取空值==。例如 <code>选修(<u>学号, 课程号</u>, 成绩)</code> 关系中，<u>学号, 课程号</u>为主键，则学号和课程号两个属性都不能取空值。

对于实体完整性规则的说明如下：
（1）**实体完整性规则是针对基本关系而言的**，一个基本表通常对应现实世界的一个实体集。例如学生管理对应于学生的集合。
（2）**现实世界中的实体是可区分的，即它们具有某种唯一性标识**。例如每个学生都是独立的个体，是不一样的。
（3）相应地，**关系模型中以主键作为唯一性标识**。
（4）**主键中的属性即主属性不能取空值**。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第(2)点相矛盾，因此这个规则称为实体完整性。

## 2.3.2 参照完整性
**现实世界中的实体之间往往存在某种联系**，在关系模型中实体及实体间的联系都是用关系来描述的，这样就自然存在着「**关系与关系间的引用**」。先看三个例子。

### 1. 关系间的引用
【例2.1】学生实体、专业实体可用下面的关系来表示，其中主键用下划线标识：
- 学生(<u>学号</u>，姓名，性别，专业号，年龄)
- 专业(<u>专业号</u>，专业名)

这两个关系之间存在着属性的引用，即学生关系引用了专业关系的主键“专业号”，显然，学生关系中的“专业号”值必须是确实存在的专业的专业号，即专业关系中有该专业的记录。也就是说，学生关系中的某个属性的取值，需要参照专业关系的属性取值。

【例2.2】学生、课程、学生与课程之间的多对多联系，可以用如下三个关系表示：
- 学生(<u>学号</u>，姓名，性别，专业号，年龄)
- 课程(<u>课程号</u>，课程名，学分)
- 选修(<u>学号，课程号</u>，成绩)

这三个关系之间也存在着属性的引用，即选修关系引用了学生关系的主键“学号”和课程关系的主键“课程号”。同样，选修关系中的“学号”值必须是确实存在的学生的学号，即学生关系中有该学生的记录；选修关系中的“课程号”值也必须是确实存在的课程的课程号，即课程关系中有该课程的记录。换句话说，选修关系中某些属性的取值需要参照其他关系的属性取值。

==不仅两个或两个以上的关系间可以存在引用关系，同一关系内部属性间也可能存在引用关系==。

【例2.3】 在学生(<u>学号</u>，姓名，性别，专业号，年龄，班长)关系中，“学号”属性是主键，“班长”属性表示该学生所在班级的班长的学号，它引用了本关系“学号”属性，即“班长”必须是确实存在的学生的学号。

这三个例子说明关系与关系之间存在着相互引用、相互约束的情况。下面先引入外键的概念，然后给出表达关系之间相互引用约束的参照完整性的定义。

### 2. 外码 `foreign key`
**定义2.5** ==设 $F$ 是基本关系 $R$ 的一个或一组属性，但不是关系 $R$ 的键。如果 $F$ 与基本关系 $S$ 的主键 $K_s$ 相对应，则称 $F$ 是 $R$ 的外键 `foreign key`  ，并称基本关系 $R$ 为**参照关系** `referencing relation` ，基本关系 $S$ 为**被参照关系** `referenced relation` 或**目标关系** `target relation`== 。<font color="red">**关系 $R$ 和 $S$ 不一定是不同的关系**</font>。

显然，目标关系 $S$ 的主键 $K_s$ 和参照关系 $R$ 的外键 $F$ 必须定义在同一个（或同一组）域上。

在【例2.1】中，学生关系的“专业号”属性与专业关系的主键“专业号”相对应，因此“专业号”属性是学生关系的外键。专业关系是被参照关系，学生关系为参照关系。如图所示：

<img src="https://img-blog.csdnimg.cn/f56e28ef41994fc88492ee6de65f0d8d.png#pic_center" width="30%">
在【例2.2】中，选修关系的“学号”属性与学生关系的主键“学号”相对应，选修关系的“课程号”属性与课程关系的主键“课程号”相对应，因此，“学号”和“课程号”是选修关系的外键。这里，学生关系和课程关系均为被参照关系，选修关系为参照关系。如图所示：

<img src="https://img-blog.csdnimg.cn/65dbd31faeb143ecb043946323933cc6.png#pic_center" width="43%">


在【例2.3】中“班长”属性与本身的主键“学号”属性相对应，因此“班长”是外键。这里，学生关系既是参照关系也是被参照关系。如图所示：
<img src="https://img-blog.csdnimg.cn/7499aed7aa0748688fd3507899b1d084.png#pic_center" width="23%">

需要指出的是，==外键并不一定要与相应的主键同名==，如【例2.3】中学生关系的主键为学号，外键为班长。不过，==在实际应用中为了便于识别，当外键与相应的主键属于不同关系时，往往给它们取相同的名字。==

参照完整性规则就是定义外键与主键之间的引用规则。

**规则2.2 参照完整性规则** 若属性（属性组）$F$ 是基本关系 $R$ 的外键，它与基本关系 $S$ 的主键 $K_s$ 相对应（基本关系 $R$ 和 $S$ 不一定是不同的关系），则对于 $R$ 中每个元组在 $F$ 上的值必须：
- 或者取空值（$F$ 的每个属性值均为空值）；
- 或者等于 $S$ 中某个元组的主键值

例如，对于【例2.1】，学生关系中每个元组的“专业号”属性只能取下面两类值：
（1）空值，表示尚未给该学生分配专业；
（2）非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配到一个不存在的专业。即被参照关系“专业”中一定存在一个元组，它的主键值等于该参照关系“学生”中的外键值。

对于【例2.2】，按照参照完整性规则，“学号”和“课程号”属性也可以取两类值：空值或目标关系中已经存在的值。但由于“学号”和“课程号”是选修关系中的主属性，按照实体完整性规则，它们均不能取空值，所以选修关系中的“学号”和“课程号”属性，实际上只能取相应被参照关系中已经存在的主键值。

参照完整性规则中，$R$ 和 $S$ 可以是同一个关系。例如对于【例2.3】，按照参照完整性规则，“班长”属性值可以取两类值：
（1）空值，表示该学生所在班级尚未选出班长；
（2）非空值，这时该值必须是本关系中某个元组的学号值。

## 2.3.3 用户定义的完整性
==任何关系数据库系统都应该支持实体完整性和参照完整性，这是关系模型所要求的==。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。==用户定义的完整性，就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求==。例如某个属性必须取唯一值、某个非主属性不能取空值等。

举例，在【例2.1】的学生关系中，若按照应用的要求，则学生不能没有姓名，于是可以定义学生姓名不能取空值；某个属性如学生的成绩的取值范围，可以定义在 $0 \sim 100$ 之间等。

**关系模型应提供定义和检验这类完整性的机制，以便用统一的、系统的方法处理它们，而不需由应用程序承担这一功能**。

在早期的关系数据库管理系统中，没有提供定义和检验这类完整性的机制，因此需要应用开发人员在应用系统的程序中进行检查。例如，在【例2.2】的选修关系中，每插入一条记录，必须在应用程序中写一段程序，来检查其中的学号是否等于学生关系中的某个学号，并检查其中的课程号是否等于课程关系中的某个课程号。如果等于，则插入这一条选修记录，否则就拒绝插入，并给出错误信息。

---
# 2.4 关系代数
关系代数是一种抽象的查询语言，==它用「对关系的运算」来表达查询==。了解基本的关系代数，是学习SQL的前提，也是深入学习数据库设计的前提。

任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果，所以运算对象、运算符、运算结果是运算的三大要素。==「对关系的运算」以（一个或多个）关系为运算对象，运算结果也是关系==。关系代数用到的运算符则包括两类：集合运算符和专门的关系运算符，如表2.4所示：
<img src="https://img-blog.csdnimg.cn/eeeed92ee5194e90aa5058e080f10782.png#pic_center" width="35%">
 

关系代数的运算，按运算符的不同可分为==传统的集合运算和专门的关系运算==。其中，**传统的集合运算将关系看做元组的集合，其运算是从关系的「水平」方向，即行的角度进行**；而**专门的关系运算不仅涉及行，而且涉及列**。比较运算符和逻辑运算符是用来辅助专门的关系运算符进行操作的，基本的比较与逻辑运算符如下：
| 符号 | 含义 | $\LaTeX$ |
|:--:|:--:|:--:|
| $\lt$  | 小于 | `$\lt$` |
| $\leq$  | 小于等于  | `$\leq$` |
| $\gt$  | 大于 | `$\gt$` |
| $\geq$  | 大于等于 | `$\geq$` |
| $=$  | 等于 | `$=$` |
| $\ne$  | 不等于 | `$\ne$` |
| $\urcorner$  | 非 | `$\lnot$` |
| $\wedge$  | 与 | `$\wedge$` |
| $\vee$  | 或 | `$\vee$` |

此外，关系代数还含有==扩充的关系运算==——广义投影、外连接、半连接、聚集等。
## 2.4.1 传统的集合运算 `Union, Difference, Intersection, Cartesian Product`
==传统的集合运算是二目运算，包括并、差、交、广义笛卡尔积==。其中前三者都要求，参与运算的两个关系必须是**相容的同类关系**，即它们必须有**相同的列数**，且对应的**属性值取自同一个域**（属性名可以不同），前三者运算的结果仍为**同类** $n$ 元关系。

设关系 $R$ 和 $S$ 为**同类**（**同为 $n$ 目**，即两个关系都有 $n$ 个属性，且**相应属性取自同一个域**）的 $n$ 元关系， $t$ 为元组变量，$t \in R$ 表示 $t$ 是 $R$ 的一个元组。可以定义并、差、交、笛卡尔积运算如下：
- **并运算** `union` 。关系 $R$ 与 $S$ 的并记作：
$$R∪S =\ \{ t\mid (t∈R) \lor (t∈S)\}$$ 其结果由属于 $R$ 或属于 $S$ 的元组组成。==注意：并运算不会重复出现相同的元组！==
 - **差运算** `except` 。关系 $R$ 与 $S$ 的差记作：$$R-S=\ \{ t\ |\ (t∈R) \land (t \notin S)\}$$
 其结果由属于 $R$ 而不属于 $S$ 的所有元组组成。
 - **交运算** `intersection` 。关系 $R$ 与 $S$ 的交记作：
 $$R∩S=\ \{ t\ |\ (t∈R)\land (t∈S)\}$$
其结果由既属于 $R$ 又属于 $S$ 的元组组成。关系的交可用差来表示，即 $$R\cap S= R-  (R - S)$$ 上述三种运算的示例如下图：
<img src="https://img-blog.csdnimg.cn/20200402155154296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,,t_70#pic_center" width="40%">
- **笛卡尔积** `cartesian product` 。这里的笛卡尔积严格地说应该是**广义笛卡尔积** `extended cartesian product` ，因为这里笛卡尔积的元素是元组。
$R$ 为 $k_1$ 元关系，有 $n_1$ 个元组；$S$ 为 $k_2$ 元关系，有 $n_2$ 个元组。则广义笛卡尔积运算的结果关系为一个 $k_1+k_2$ 元的不同类新关系，有 $n_1 \times n_2$ 个元组。
 $$R \times S = \{\ t_r,\ t_s\ |\ (t_r \in R) \wedge (t_s \in S)\}$$    显然， $R, S$ 可以是不同类的关系，结果也是不同类关系。特别地，==当需要得到一个关系 $R$ 和自己的广义笛卡尔积时，必须引入 $R$ 的别名==（比如 $R'$ ），把表达式写成 $R\times R'$ 或者 $R' \times R$。==运算中出现同名的属性也要同样区别==，如果是两个不同的关系 $R$ 和 $S$ 中存在同名的属性 $a_1$ 时，可以写成 $R.a_1$ 与 $S.a_1$ ，其他属性同样操作。
	 <img src="https://img-blog.csdnimg.cn/20200402160532152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,,t_70#pic_center" width="40%">
 

**上述运算中，并、交、积运算均满足结合律，但差运算不满足结合律**。其中，==笛卡尔积运算是相当重要的，它是后面的条件连接、等值连接、自然连接的基础——**连接中先做笛卡尔积，然后根据条件、等值来选择元组**==。自然连接在不存在公共属性时，结果就是笛卡尔积。同样，==自然连接则是外连接、左外连接、右外连接的基础==。这些都会在后面提到。？

---
## 2.4.2 专门的关系运算
专门的关系运算包括选择、投影、连接、除运算等。为了叙述的方便，先引入几个记号：
1. 设关系模式为 $R(A_1,\ A_2,\ \dots,\ A_n)$ ，它的一个关系设为 $R$ ，$t$ 为 $R$ 的元组变量，$t \in R$ 表示 $t$ 是 $R$ 的一个元组。==$t[A_i]$ 则表示元组 $t$ 中、相应于属性 $A_i$ 的一个分量==。
2. 若 $A = \{ A_{i1},\ A_{i2},\ \dots,\ A_{ik}\}$ ，其中 $A_{i1}, A_{i2}, \dots, A_{ik}$ 是 $A_1, A_2, \dots, A_n$ 中的一部分，则 $A$ 称为**属性列**或**属性组**。==$t[A] = (t[A_{i1}],\ t[A_{i2}],\ \dots,\ t[A_{ik}])$ 则表示元组 $t$ 在**属性列**或**属性组** $A$ 上诸分量的集合==，$\overline A$ 则表示  $\{A_1,\ A_2,\ \dots,\ A_n\}$ 中去掉 $\{ A_{i1},\ A_{i2},\ \dots,\ A_{ik}\}$ 后剩余的属性组。例如，$t[学号, 姓名]$ 表示 $R$ 在学号、姓名两列上的所有属性值。
<img src="https://img-blog.csdnimg.cn/20200402172735578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center" width="25%">
3. $R$ 为 $n$ 目关系，$S$ 为 $m$ 目关系。$t_r\in R,\ t_s \in S$ ，==$\overgroup{t_rt_s}$ 称为**元组的连接** `concatenation` 或**元组的串接**==，它是一个 $n+m$ 列的元组，前 $n$ 个分量为 $R$ 中的一个 $n$ 元组，后 $m$ 个分量为 $S$ 中的一个 $m$ 元组。
4. 给定一个关系 $R(X, Z)$ ，$X$ 和 $Z$ 为属性组。当 $t[X] = x$ 时，$x$ 在 $R$ 中的**象集** `images set`（象的集合）定义为：$$Z_x = \{ t[Z] \mid t \in R,\ t[X] = x \}$$  它表示 ==$R$ 中属性组 $X$ 上值为 $x$ 的诸元组，在 $Z$ 上分量的集合==。例如，图2.3中 $x_1$ 在 $R$ 中的象集 $Z_{x_1} = \{ Z_1, Z_2, Z_3\}$ ，$x_2$ 在 $R$ 中的象集 $Z_{x_2} = \{Z_2, Z_3 \}$ ，$x_3$ 在 $R$ 中的象集 $Z_{x_3} = \{ Z_1, Z_3\}$ 。
<img src="https://img-blog.csdnimg.cn/47cdd0ac75af4d688c56ad5808c0705d.png#pic_center" width="13%">


### 1. 选择运算 `selection`
<img src="https://img-blog.csdnimg.cn/ee7da08c0f3e4b26a6b95be8e7c34ae2.png#pic_center" width="30%">

选择运算又称为**限制** `restriction` ，它是在关系的**行**上进行的**横向**筛选，选择出满足给定条件的诸元组，结果**产生同类关系**。设 $t$ 为 $R$ 的元组变量，选择运算记作：
$$\sigma_F(R) = \{\ t\ |\ (t \in R) \wedge F(t) = true\}$$

含义：$\sigma_F(R)$ 表示从关系 $R$ 中选出的、**满足 $F$ 条件表达式的那些元组**所构成的**关系**。其中，选择条件 $F$ 是「由属性名（或列号）、比较符、逻辑运算符构成的逻辑表达式」，取逻辑值“真”或“假”。$F$ 的基本形式为：
$$X_1 \theta Y_1$$       $\theta$ 表示比较运算符；$X_1, Y_1$ 等是属性名，或为常量或为简单函数，属性名也可以用它的序号来代替。在基本的选择条件上，可以进一步进行逻辑运算，即进行求非、与、或运算。

一个示例是，$σ_{A2\ >\ 5\ ∨\ A3\ ≠\ “f”} (R)$ 或 $σ_{[2]\ >\ 5\ ∨\ [3]\ ≠\ “f”}(R)$ ，对下面的图来说，打勾的四行满足条件，会被**选择**出来构成新关系。
<img src="https://img-blog.csdnimg.cn/20200402175541931.png#pic_center" width="18%">

设有一个学生-课程数据库，包括学生关系 `Student` 、课程关系 `Course` 和选修关系 `SC` 。如图2.4所示，下面的多个例子将对这三个关系进行运算：
<img src="https://img-blog.csdnimg.cn/74b86172ffc64a378746aac011abfd2a.png" width="40%"><img src="https://img-blog.csdnimg.cn/32ea1e38dcaa404297f9e197cfde9cc1.png" width="30%"><img src="https://img-blog.csdnimg.cn/dede909e7e1c4ac2804217ea04cb9c9e.png" width="30%">

【例2.4】查询信息系（`IS` 系）的全体学生。
答：$\sigma_{Sdept = 'IS' } (Student)$ 。结果如图所示：
<img src="https://img-blog.csdnimg.cn/1320c557289d4a6f92cefdf7f55e694b.png#pic_center" width="40%">

【例2.5】查询年龄小于 $20$ 岁的学生。
答：$\sigma_{Sage < 20}  (Student)$ 。结果如图所示：
<img src="https://img-blog.csdnimg.cn/8fa8747392ae4fe8b76e9d7ebeb5962f.png#pic_center" width="40%">
### 2. 投影运算 `projection`
<img src="https://img-blog.csdnimg.cn/a5ad7ed53fd6444b835b80082a3f098d.png#pic_center" width="25%">

投影是在关系的**列**上进行的**纵向**筛选，选择出若干属性列组成新的关系，结果**产生不同类关系**，只有被选中的几列可能构成新的关系。设 $t$ 为 $R$ 的元组变量，投影运算记作：
$$\prod {}_A(R) = \{\ t[A]\ |\ (t \in R)\ \}$$      含义：$\prod {}_A(R)$ 表示从关系 $R$ 中取出 $A$ 属性指定的**列**，并**消除重复的元组**。这里的 $A$ 属性可以有多个。一个示例是 $\prod _{A2,A3}(R)$，结果如下： 
<img src="https://img-blog.csdnimg.cn/bbe0f560457d47e7b204a9cefc63d0c2.png#pic_center" width="28%">   
 

显然，==投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组==，因为取消了某些属性列后，就可能出现重复行，应取消这些完全相同的行。

【例】对下面的学生选课表，用关系代数进行查询。
 <img src="https://img-blog.csdnimg.cn/20200402180831982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center" width="22%">
 （1）查选 $2$ 号课程的**学生记录**。答：$\sigma _{[2] == '2'}(SC)$
（2）成绩在 $90$ 分及以上的**学生号**。答：$\prod _{Sno}(\sigma_{Grade\ \ge\ 90}(SC))$

【例2.6】查询学生的姓名和所在系。即求 `Student` 关系上学生姓名和所在系两个属性上的投影
答：$\prod_{Sname,Sdept}(Student)$ 。结果如下图所示。
<img src="https://img-blog.csdnimg.cn/005ba3083fcd48b790555f129fea24ef.png#pic_center" width="18%">

【例2.7】查询学生关系 `Student` 中都有哪些系。           
答：$\prod_{Sdept}(Student)$ 。结果如下图所示，`Student` 关系原来有四个元组，而投影结果取消了重复的 `CS` 元组，因此只有三个元组。
<img src="https://img-blog.csdnimg.cn/f5e178885b5744a4bd5d4265e715bea1.png#pic_center" width="7%">


### 3. 连接运算 `join`
连接运算也被称为 $\theta$ 连接，它是从**两个关系的笛卡尔积**中**选择**「属性间满足一定条件的**元组**」。
$$R\mathop{\Join} \limits_{A \theta B} S = \{\ \overgroup{t_r  t_s} \ |\ (t_r \in R) \wedge (t_s \in S) \wedge (t_r[A]\ \theta\ t_s[B])\  \}$$ 其中，$A$ 和 $B$ 分别为 $R$ 和 $S$ 上列数相等且可比的属性组，$\theta$ 是比较运算符。==连接运算从 $R$ 和 $S$ 的笛卡尔积 $R\times S$ 中，选取「$R$ 关系在 $A$ 属性组上的值」与「$S$ 关系在 $B$ 属性组上的值」满足「比较关系 $\theta$」的元组，构成一个新关系==。上式可以用其他关系代数式表示为：
$$R\mathop{\Join} \limits_{A \theta B} S = \sigma _{R.A\ \theta\ S.B}\ (R \times S)$$     除了上面的**一般条件连接**外，连接运算中有两种最为重要也最为常用的连接，一种是**等值连接** `equijoin` ，另一种是**自然连接** `natural join` 。==$\theta$ 为 $=$ 的连接运算称为**等值连接**==，它是从关系 $R$ 与 $S$ 的广义笛卡尔积中选取 $A, B$ 属性值相等的那些元组，即等值连接为：$$R\mathop{\Join}\limits_{A=B} S = \{ \overgroup {\ t_r t_s} \mid (t_r \in R) \land (t_s \in S) \land (t_r[A] = t_s[B])\  \}$$

==**自然连接**是一种特殊的等值连接==。它要求==两个关系中进行比较的分量必须是「**同名的属性组**」，并在结果中把重复的属性列去掉==。即若 $R$ 和 $S$ 中具有相同的属性组 $B$ ，$U$ 为 $R$ 和 $S$ 的全体属性集合，则自然连接可记作：
$$R \mathop{\Join} S = \{\ \overgroup{t_rt_s} [U - B] \mid (t_r \in R)\land (t_s \in S) \land (t_r[B] = t_s[B])\ \}$$  一般的连接操作是从行的角度进行运算，但**自然连接还需要取消重复列，所以是同时从行和列的角度进行运算**。
<img src="https://img-blog.csdnimg.cn/cdccab73f2884568977d479d606a52d1.png#pic_center" width="25%">


【例2.28】
 
### (1). 等值连接
即 $\theta$ 关系为 $=$ 的连接，可以用其他关系代数式表示为：
$$R \Join _{A\ =\ B} S = \sigma_{R.A = S.B}\ (R \times S)$$

### (2). 自然连接Natural Join
这是一种**特殊的等值连接**，要求两个关系中**进行比较的分量**是**公共的属性组**，并且要`去掉重复的属性`！若 $R$ 和 $S$ 具有相同的属性组 $B$，则自然连接记作：

$$R \Join S = \{\overbrace {t_r, t_s}\ |\ (t_r \in R) \wedge (t_s \in S) \wedge (t_r[B] = t_s[B])$$

自然连接可以用其他关系代数式表示，设 $R$, $S$ 有同名属性 $B_i\ (i = 1, 2,..., k)$，有：
$$R \Join S = \prod_{无重复属性名者}\ (\theta _{R.B_1 = S.B_1\ \wedge\ ...\ \wedge\ R.B_k = S.B_k}\ (R \times S))$$

比起一般的等值连接，自然连接有特殊要求：$R$、$S$ 有同名属性，其连接结果：满足 **同名属性 值也对应相同**，并且 **去掉重复属性**后 的连接元组集合。自然连接的运算步骤可分解为：
$1.$ 计算 $R\times S$；
$2.$ 选择满足等值条件 $R.B_1 = S.B_1 \wedge\ ...\ \wedge R.B_k = S.B_k$ 的元组；
$3.$ 去掉重复属性 $S.B_1, ...\ , S.B_k$。

如果 $R$, $S$ 无公共属性，则 $R \Join S  = R\times S$。

**等值连接与自然连接**的区别：
   （1）**自然连接一定是等值连接，但等值连接不一定是自然连接**。因为自然连接要求`相等的分量必须是公共属性`，而等值连接`相等的分量不一定是公共属性`。
   （2）等值连接不要求把重复的属性去掉，而自然连接要`把重复属性去掉`。


例子：已知有图所示的关系 $R$, $S$如下：
<img src="https://img-blog.csdnimg.cn/20200402204453782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,,t_70#pic_center" width="40%">
其笛卡尔积 $R \times S$ 为：
<img src="https://img-blog.csdnimg.cn/20200402204708381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,,t_70#pic_center" width="25%">
（1）条件连接 $R \Join_{[2] \gt [1]} S$ 示例，运算结果如下：
<img src="https://img-blog.csdnimg.cn/20200402205836513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,,t_70#pic_center" width="30%">
（2）等值连接 $R\Join _{[2] = [1]} S$ 运算结果如下：
<img src="https://img-blog.csdnimg.cn/20200402210219740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,,t_70#pic_center" width="30%">
（3）自然连接 $R \Join S$ 运算结果如下：
<img src="https://img-blog.csdnimg.cn/20200402210231804.png#pic_center" width="25%">

## 4. 除法运算Divide
设关系 $R(X,Y)$ 与 $S(Y, Z)$，$X,Y,Z$ 为属性 **组**，$X$ 属性**组**上的值为 $x_i$，除法运算记作：
$$R \div S = \{\ t[X]\ |\ t \in R \wedge \prod {}_Y(S) \subseteq Y_X\}$$
分解 $R\div S$ 的步骤如下：
$1.$ 求 $\prod {}_X(R)$；
$2.$ 求 $\prod{}_Y(S)$；
$3.$ $Y_X$ 为 $X$ 在 $R$ 中的像集(Image Set)，它表示 $R$ 中属性组上 $X$ 值为 $x_i$ 的各个元组**在 $Y$ 上的分量集合**，每个 $x_i$ 都有一个 $Y$ 的分量集合；求像集 $Y_X$ 的方法：对于每个值 $x_i \in \prod {}_X(R)$，求出 $\prod {}_Y(\sigma _{X = x_i}(R))$；
$4.$ $R \div S$ 运算结果为：像集 $Y_X$ 包含了 $\prod {}_Y(S)$ 的所有 $x_i$。

例：设关系 $R(A,B,C), S(B,C,D)$，如下图所示，求 $R\div S$ 的结果。
<img src="https://img-blog.csdnimg.cn/20200402223509448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,,t_70#pic_center" width="40%">
$1.$ 求 $\prod {}_X(R)$，易知：$\prod {}_X(R) = \{a_1, a_2, a_3, a_4\}$，即在关系 $R$ 中，$A$ 可以取 $4$ 个值 $\{a_1, a_2, a_3, a_4\}$；
$2.$ 求 $\prod {}_Y(S)$，易知：$\prod {}_Y(S) = \{(b_1,c_2),(b_2,c_1), (b_2,c_3)\}$；
$3.$ 求 $x_i$ 或者说 $a_i, 1 \le i \le 4$ 在 $R$ 中的像集 $Y_X$，对每个 $x_i \in \prod{}_X(R)$，求 $\prod {}_Y(\sigma _{X = x_i}(R))$：
- $x_1 = a_1$，$\sigma _{x_1=a_1}(R)$如下：
 <img src="https://img-blog.csdnimg.cn/2020040222411519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,,t_70#pic_center" width="40%">
 可得在 $R$ 中的像集：$\prod {}_Y(\sigma _{x_1=a_1}(R)) = \{\{b_1,c_2\},\{b_2,c_3\},\{b_2,c_1\}\}$
 - $\prod {}_Y(\sigma _{x_2=a_2}(R)) = \{\{b_3,c_7\},\{b_2,c_3\}\}$
 - $\prod {}_Y(\sigma _{x_3=a_3}(R)) = \{\{b_4,c_6\}\}$
 - $\prod {}_Y(\sigma _{x_4=a_4}(R)) = \{\{b_6,c_6\}\}$

$4.$ 求出像集 $BC_{a_i}$ 或者说 $Y_X$ 中包含了 $\prod {}_Y(S)$ 的 $a_i$，显然，只有 $a_i$ 在 $R$ 中的像集 包含了所有 $\prod {}_Y(S) = \prod {}_{B,C}(S)$ ，则 $R\div S = \{a_1\}$。

> 关系代数定义了除法运算。但是实际运用中，当关系  $R$ 真包含了关系 $S$ 时，$R\div S$ 才有意义。$R$ 能够被 $S$ 除尽的**充分必要条件**是：$R$ 中的属性包含 $S$ 中的所有属性；$R$ 中有一些属性不出现在 $S$ 中。
>
> $R = (X,Y), S = (Y)$： 可以这样理解 $R \div S$，即 $R$ 中包含了 $S$ 中全部属性值的那些元组，在 $R$ 与 $S$ 的属性名集合之差 $R - S$ 即 $X$ 上的投影。

---
# 2.5 关系演算
关系演算是以**数理逻辑中的谓词演算**为基础的，按谓词变元的不同，关系演算分为**元组关系演算**和**域关系演算**。这里先计算元组关系演算，再简单介绍域关系演算。

## 2.5.1 元组关系演算语言ALPHA


## 5. 实际练习【重点】
设一学生选课关系数据库，见下表，在 $3$ 个关系中，除学号、年龄、学分、成绩属性的值为整型数外，其余均为字符串型。
$$\begin{aligned}
&student(sno，sname，sex，age，dept，place)\\
&course(cno，cname， credit ， pcno)\\
&sc(sno，cno，grade)
\end{aligned}
$$
<img src="https://img-blog.csdnimg.cn/20200402230825765.png#pic_center" width = "55%">
<img src="https://img-blog.csdnimg.cn/20200402230857568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,,t_70#pic_center" width="55%">

（1）求年龄在 $25$ 岁以下的**女**学生：
$$\sigma _{age\ <\ 25\ \wedge\ sex='女'}(S)$$
（2）求成绩在 $85$ 分及以上的学生的学号和姓名：
$$\prod {}_{sno, sname}(\sigma _{grade\ >\ 85}(student \Join sc))$$
公共属性是 $sno$。
（3）查询**至少选修了一门**其 **直接先修课为 $003$ 号课程** 的课程的学生姓名。由于涉及到了先修课程号、学生姓名，必然涉及到course表，以及student表，还需要sc表。多表查询，需要自然连接。
$$\prod {}_{sname}(\sigma _{pcno='003'}(student \Join sc \Join course))$$
可以进一步优化，==对于有选择运算的，优先进行选择，以减少笛卡尔积的规模；选择完毕后可以适当增加投影，投影那些后面的自然连接会用到的公共属性，和那些要求的属性==。
$$\prod {}_{sname}(\prod {}_{sno,name}(student) \Join sc \Join \prod {}_{cno}(\sigma _{pcno='003'}(course))$$
（4）求选修数据库课程的学生的姓名和成绩。$$\prod {}_{sname, grade}(\sigma _{cname='数据库'}(student \Join sc \Join course))$$
同样可以进行优化：
$$\prod {}_{sname, grade}(\prod {}_{sno, sname}(student) \Join sc \Join \prod {}_{cno}(\sigma _{cname='数据库'}(course)))$$
（5）查询**没有选择** $005$ 号课程的学生的学号。
下面的式子是错误的！
$$\prod{}_{sno}(\sigma _{cno \ne '005'}(SC))$$
因为这样是从 **选了课程** 的学生中进行查找，没有考虑到那些没选课的学生；而且，这样做也会输出那些 **选了005号课程**但也选了其他课程的学生。因此是大错特错的！

我们应该先找到选了005号课程的学生，然后从所有学生中减去这部分学生。
$$\prod {}_{cno}(student) - \prod {}_{cno}(\sigma _{cno = '005'}(SC))$$
（6）查询**没有选择** $005$ 号课程的学生**姓名与年龄**。
同上：
$$\prod {}_{sname,age}(student) - \prod {}_{sname, age}(student \Join \sigma _{cno = '005'}(SC))$$

（7）查询选择了全部课程的学生的姓名和学号。
这个怎样做呢？需要用除法，用学生选课表 $\div$ 课程表，得到选修了全部课程的学生的学号。然后用得到的学号和学生表进行自然连接。

$$\prod {}_{sno,cno}(sc) \div \prod {}_{cno}(course) \Join \prod {}_{sname, sno}(student)$$
（8）查询**至少选择了**两门课程的学生学号。
这个题目更麻烦了，需要==用差运算，用全部的学生学号-没有选的-选了一门的学生学号==。其实简单的想，可以用自己与自己进行笛卡尔积，这里用列号进行区分。
$$\prod {}_{[1]} (\sigma _{[1] = [4]\ \wedge\ [2] \ne [5]} (sc \times sc))$$

---
## 6. 关系代数基本运算总结【重点】
关系代数基本运算是五种：交，差，笛卡尔积，投影，选择：
- 投影：$\prod {}_{A_1,A_2,...,A_k}(R)$ 实现关系属性**列的指定**；
- 选择：$\sigma _{F}(R)$ 实现关系**行的选择**；
- 并：$R \cup S$ 实现两个关系的合并或者说关系中元组(行)的**插入**；
- 差：$R - S$ 实现关系中元组(行)的**删除**；
- 积：$R \times S$ 实现两个关系的**无条件全连接**。

非基本运算可以用基本运算来表示：
- 交：$R \cap S = R - (R - S)$；
- 条件连接：$R \Join_{i\ \theta\ j}  = \sigma_{[i]\ \theta\ [m + j]} (R \times S)$
- 等值连接：$R \Join _{A\ =\ B} S = \sigma_{R.A = S.B}\ (R \times S)$
- 自然连接：$R \Join S = \prod_{A_1,A_2,...,A_k}\ (\sigma _{R.B_1 = S.B_1\ \wedge\ ...\ \wedge\ R.B_k = S.B_k}\ (R \times S))$，其中 $B_1,B_2,...,B_k$ 为 $R$, $S$ 的公共属性，而 $A_1,A_2,...,A_k$ 为从 $R$ 与 $S$ 的属性集中去掉 $S.B_1,S.B_2,...,S.B_k$ 后剩余的属性；
- 除法：设关系 $R(X,Y)$，$S(Y,Z)$，$X$、$Y$、$Z$ 为属性集，$R \div S$ 的过程如下：
$(1).$ $T = \prod _X(R)$；
$(2).$ $W = (T \times \prod {}_Y(S)) - R$：算出 $T\times \prod{}_Y(S)$ 中不存在于 $R$ 中的元组；
$(3).$ $V = \prod{}_X(W)$；
$(4).$ $R \div S = T - V$
$\Rightarrow R \div S = \prod{}_X(R) - \prod{}_X\Big(\big(\prod_X(R) \times \prod_Y(S)\big) - R\Big)$ 
	
---
# 四、扩充的关系运算
随着数据库的发展和应用情况，关系运算被扩展。
## 1. 广义投影
设有关系模式 $R$，对其进行广义投影运算 $\prod{}_{F_1,F_2,...,F_n}(R)$，其中 $F_1,...,F_n$ 涉及到 $R$ 中常量和属性的算术表达式。通过这种广义投影运算对投影进行扩充。

例：若将查出的学生关系 $student$ 中学号为 $000101$ 学生的年龄加 $1$ 岁，可以用广义投影运算表示为：
$$\prod {}_{sno, sname,sex,age=age+1}(\sigma_{sno='000101'}(student)$$

## 2. 赋值
设有相容的关系  $R$ 和 $S$ ，则通过赋值运算可以对关系 $R$ 赋予新的关系 $S$，记为：$R \leftarrow S$，其中 $S$ 是通过关系代数运算得到的关系。通过赋值，可以把复杂的关系表达式化为若干个简单的表达式进行运算。特别是对于插入、删除和修改操作来说，很方便。

例：在关系 $course$ 中新增一门新课：(099, 电子商务, 2, 003)，可以用赋值操作表示如下：
$$course \leftarrow course \cup \{099,电子商务,2,003\}$$

例：设学号为 200108 的学生因故退学，在关系 student 和 sc中将其相关记录删除，可表示为：
$$\begin{aligned}
&student \leftarrow student - (\sigma _{sno='200108'}(student))\\
&sc \leftarrow sc - (\sigma _{sno='200108'}(sc))\end{aligned}$$

**对关系进行修改时，可以先将要修改的元组删除，再将新元组插入即可**。

## 3. 几种外连接
### (1). 外连接
设有关系 $R$ 和 $S$，它们的**公共属性组成的集合**为 $Y$，则对 $R$ 和 $S$ 进行自然连接时，在 $R$ 中可能存在某些元组，无法在 $Y$ 上与 $S$ 的任一元组相等；同样对于 $S$ 也是如此，可能存在某些元组无法在 $Y$ 上与 $R$ 的任一元组相等。那么当 $R \Join S$ 时，这些元组都会被舍弃。

如果**不舍弃这些元组**，并且在这些元组**新增加的属性**上赋**空值**，这种操作就被称为“外连接”。表示如下……

我在 $\href{https://katex.org}{\KaTeX}$ 找了半天，没看到外连接的符号，算了。
 

### (2). 左外连接
如果只保存 $R$ 中原来要舍弃的元组，则称为 $R$ 与 $S$ 的 “左外连接”。表示为：
$$R\ ⟖\  S$$

### (3). 右外连接
如果只保存 $S$ 中原来要舍弃的元组，则称为 $R$ 与 $S$ 的 “右外连接”。

## 4. 半连接
设有关系 $R$ 和 $S$，则 $R$ 和 $S$ 的**自然连接**只在关系 $R$ **或** $S$ 的**属性集上的投影**，称为“半连接”。$R$ 和 $S$ 的半连接记作 $R \ltimes S$，$S$ 与 $R$ 的半连接记作 $R \rtimes S$ 或者 $S \ltimes R$ 。

## 5. 聚集
关系的聚集是指根据**关系中的一组值**，经过统计计算得到**一个值**作为结果。

比较常用的有 $\max,\min,avg,sum,count$ 等。使用聚集函数时需要在前面写上符号 $G$。

例：对于学生-选课关系数据库的统计：
（1）求男同学的平均年龄：$G\ avg(age)(\sigma _{sex='男'}(student))$
（2）计算年龄不小于 $20$ 岁的学生人数：$G\ count(sno)(\sigma _{age\ge 20}(student))$
（3）计算选修数据库课程的平均分数：$G\ avg(grade)(\prod _{cno}(\sigma _{cname='数据库'}(course)) \Join sc)$

## 6. 外部并
设有关系 $R$ 和 $S$，$R$ 和 $S$ 的外部并得到一个新关系，其属性由 $R$ 和 $S$ 中的所有属性组成，公共属性仅取一次，其元组由属于 $R$ 或属于 $S$ 的元组组成，且元组在新增加的属性上填上空值。

## 7. 重命名
- $ρ_x(E)$：其含义为 **给一个关系表达式赋予名字**。它返回表达式 $E$ 的结果，并把名字 $x$ 赋给 $E$。
- $ρ_x(A_1，A_2，……，A_n)(E)$：其含义为返回表达式 $E$ 的结果，并把名字 $x$ 赋给 $E$，同时**将各属性更名为** $A_1，A_2，……，A_n$ 。

实际上，关系可以被看做一个最小的关系代数式，可以将重命名运算施加到 **关系** 或 **属性** 上，得到具有不同名字的 **同一关系** 或 不同属性名的 **同一关系** 。这对==同一关系多次参与同一运算时==很有用。

例：设关系 $R(姓名，课程，成绩)$，求**数学**成绩比**王红**同学高的学生。
解：因为在同一关系上难以进行比较，采用重命名运算：
$$\prod {}_{S.姓名}((\sigma _{课程='数学' \wedge 姓名='王红'}(R)) \Join_{R.成绩 \lt S.成绩} (\sigma _{课程='数学'}\ \rho_S(R)))$$

## 8. 扩充运算示例【重点】
需要注意的是，无论是外连接，还是半连接，都是**基于自然连接**之上的。这些连接的例子，有 $R$ 和 $S$ 关系如下：
<img src="https://img-blog.csdnimg.cn/20200403175122152.png" width="40%">
自然连接 $R \Join S$ 是**建立在公共属性** $X,Y$ **上的等值连接**，连接后需要抛弃 $S$ 中多余的公共属性 $S.X,S.Y$，保留 $R$ 中没有的 $S$ 的属性 $S.Z$，保留 $S$ 中没有的 $R$ 的属性 $R.W$。
<img src="https://img-blog.csdnimg.cn/20200403175344677.png" width="20%">
可以看出，画了紫色下划线的这两个元组，无法在公共属性上与另一个关系中的任一元组相等，因此在自然连接中会被舍弃。
<img src="https://img-blog.csdnimg.cn/20200403175716535.png" width="30%">

如果**保留左边 $R$ 的那些要被舍弃的元组**，并在新的属性 $Z$ 上赋空值的话，这就是左外连接：
<img src="https://img-blog.csdnimg.cn/20200403180552187.png" width="15%">
 
如果**保留右边 $S$ 的那些要被舍弃的元组**，并在新的属性 $R.W$ 上赋空值的话，这就是右外连接：
<img src="https://img-blog.csdnimg.cn/20200403180936997.png" width="17%">

如果**同时保留两边要舍弃的元组**，并在各自新的属性上赋空值，这就是外连接：
<img src="https://img-blog.csdnimg.cn/20200403181052296.png" width="17%">

==注意，这些都是要被舍弃的元组！它们不会发生自然连接！==

半连接基于自然连接，但和外连接不同，**半连接仅仅保留一边的属性**。
<img src="https://img-blog.csdnimg.cn/20200403191523299.png" width="20%">

对于 $R\Join S$，保留 $R$ 的属性，$R$ 和 $S$ 的半连接记作 $R \ltimes S$，$S$ 与 $R$ 的半连接记作  $S \ltimes R$：
<img src="https://img-blog.csdnimg.cn/20200403191427226.png" width="20%">

另外，需要清楚的是外部并，并运算是集合运算，基于同类关系；外部并**可以对不同类的关系进行运算**，其**结果的属性列为** $R$ 和 $S$ **属性列的并集，其中公共属性只取一次**；**结果的行**为 $R$ 和 $S$ **记录的并集**，只不过它们各自对新增的属性列填上空值：
<img src="https://img-blog.csdnimg.cn/20200403192113179.png" width="16%">

---
# 五、实际练习
1、设有下图所示的5个关系表 $R$、$S$、$T$、$U$和$V$，请写出下列各种运算结果。
<img src="https://img-blog.csdnimg.cn/2020040320173021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width ="45%">
(1) $R∪S$   
解：
<img src="https://img-blog.csdnimg.cn/20200403202327213.png" width="35%">
(2) $R∩S$     
解：
<img src="https://img-blog.csdnimg.cn/20200403202637925.png" width="35%">
(3) $R×S$     
解：
<img src="https://img-blog.csdnimg.cn/20200403202956551.png" width="35%">
(4) $U÷V$
解：可得，公共属性为 $Z,W$：
$a.$ $\prod {}_{X,Y}(U) = \{(a,b),(c,a)\}$；
$b.$ $\prod {}_{Z,W}(V) = \{(e,f),(c,d)\}$；
$c.$  求像集如下：
- 对于 $(a,b)$，有 $\prod {}_{Z,W}\Big(\sigma _{X=a\ \wedge\ Y = b}(U)\Big) = \{(c,d),(e,f)\}$；
- 对于 $(c,a)$，有 $\prod {}_{Z,W}\Big(\sigma _{X=c\ \wedge\ Y = a}(U)\Big) = \{(c,d)\}$.

$d.$ 可以发现，包含了 $∏{}_{Z,W}(V)$ 的只有 $(a,b)$，所以 $U \div V = \{(a,b)\}$.

(5) $R$ 与 $T$ 的外部并
解：
<img src="https://img-blog.csdnimg.cn/20200403205042731.png" width="20%">
(6) $U$ 与 $T$ 的外连接、左外连接及右外连接   
解：
<img src="https://img-blog.csdnimg.cn/20200403205916668.png" width="18%"><img src="https://img-blog.csdnimg.cn/20200403210448981.png " width="20%"><img src="https://img-blog.csdnimg.cn/20200403210404670.png" width="22%">
(7) $T ⋈ S$
<img src="https://img-blog.csdnimg.cn/20200403211017831.png" width="20%">
2、已知学生表 $S$、仼课表 $C$ 和选课表 $SC$ 如下所示，试用关系代数表示下列查询。
- S(sno,sname,sex,age)
- C(cno,cname,teacher)
- SC(sno,cno,grade)

（1）查询＂张景林＂老师所授**课程号**和**课程名**。
答：$$\prod {}_{cno, cname}(\sigma _{teacher='张景林'}(C))$$
（2）查询**选修课程名**为＂C语言＂或者＂数据库＂的**学生号**。
答：$$\prod {}_{sno}\bigg(\prod {}_{cno}\Big(\sigma _{cname='C语言'\ \vee\ cname = '数据库'}(C)\Big) \Join SC\bigg)$$
（3）查询＂高晓灵＂同学所选俢课程的**课程号**及**课程名**。
答：$$\prod {}_{cno, cname}\bigg(\prod {}_{sno}\Big(\sigma _{sname='高晓灵'}(S)\Big) \Join SC \Join C\bigg)$$
（4）查询至少选俢两门课程的学生学号。
答：$$\prod {}_{[1]} (\sigma _{[1] = [4]\ \wedge\ [2] \ne [5]} (SC \times SC))$$
（5）查询**全部学生**都**选修**的课程的**课程号和课程名**。
答：$$\prod {}_{sno,cno}(SC) \div \prod {}_{sno}(S) \Join \prod {}_{cno, cname}(C)$$
（6）查询**至少**选修＂张景林＂老师**所授全部课程**的学生姓名。
答：$$\prod {}_{sname}\Bigg(\prod {}_{sno,sname}(S) \Join \bigg( \prod {}_{sno,cno}(SC)\div \prod {}_{cno}(\sigma _{teacher='张景林'}(C))\bigg) \Bigg)$$

 


 除法运算的定义：除法运算 $\div$ 是同时从关系的水平和垂直方向进行运算。

给定关系 $R(X,Y)$ 和 $S(Y,Z)$，$X,Y,Z$ 为属性组。$R \div S$ 为：元组在 $X$ 上的分量值 $x$ 的 像集 $Y_x$ ，**包含** 关系 $S$ 在属性组 $Y$ 上投影 $\pi_y(S)$ 的 **集合**。形式定义：
$$R \div S = \{\ t_n[X]\quad |\quad  t_n \in R \wedge \pi_y(S) \subseteq  Y_x\}$$

这个概念非常抽象，我反正是没有听懂的。所以，这里通过一个实例来说明除法运算的求解过程：
  
  设有关系 $R、S$ 如图所示，求 $R÷S$ 的结果：
<img src="https://img-blog.csdnimg.cn/20200322193125378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center" width="25%">
求解步骤过程：
1. 第一步：找出被除关系 $R$ 和关系 $S$ 中 **相同的属性列**，即 $Y$ 属性。关系 $S$ 中对 $Y$ 做投影（即将 $Y$ 无重复的列举出）；所得结果如下：
<img src="https://img-blog.csdnimg.cn/2020032219323152.png" width = "6%">
2.  第二步：找出被除关系 $R$ 中与 $S$ 中**不相同的属性列**，即 $X$ 属性。关系 $R$ 中对 $X$ 做投影（即将 $X$ 无重复的列举出）；所得结果如下：
<img src="https://img-blog.csdnimg.cn/20200322193449400.png#pic_center" width="25%">
3.  第三步：求关系 $R$ 中 $X$ 属性对应的 **像集** $Y$。根据关系 $R$ 的记录，可以得到与 $X_1$ 值有关的记录，如图3所示，与 $X_2$ 有关的记录，如图4所示：
<img src="https://img-blog.csdnimg.cn/20200322193641182.png#pic_center" width="25%">


4. 第四步：**判断包含关系**。$R÷S$ 其实就是判断关系 $R$ 中 $X$ 各个值$x$ 的像集 $Y_x$ 是否包含关系 $S$ 中属性 $Y$ 的所有值。对比即可发现：
   * $X_1$ 的像集只有 $Y_1$，不能包含关系 $S$ 中属性 $Y$ 的所有值，所以排除掉 $X_1$；
   * $X_2$ 的像集包含了关系 $S$ 中属性 $Y$ 的所有值，所以 $R÷S$ 的最终结果就是 $X_2$。

       


也许现在有点明白除法运算是如何操作的了，下面来引申一下，**除法运算可以解决什么问题呢**？

$e.g.$ 设有关系 $R，S$ 以及 $RS$，如图所示，求 $RS÷S$ 的结果：
 <img src="https://img-blog.csdnimg.cn/20200322194540961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center" width="25%">  
重复一遍上面的求解过程：
1. 找到 关系 $RS$ 和 $S$ 中相同的属性列 $课程名$，即为 $Y$ 属性，对其投影，得到 $\pi_{课程名}(RS) = \{语文, 数学\}$。
2. 找到关系 $RS$ 中和 $S$ 不相同的属性列 $学生名$，即为 $X$ 属性，对其投影，得到 $\pi_{学生名}(RS) = \{张三, 李四\}$。
3. 对于 $X$ 属性中的每一个分量值 $x$，有像集 $Y_x$：张三的像集为 $\{语文, 数学\}$；李四的像集为 $\{语文\}$。
4. 判断包含关系，只有张三包含了关系 $S$ 中的属性 $Y$ 的所有值，因此求得结果为：$\{张三\}$。 
 
所以，可以容易看出来 $RS÷S$ 在这里解决的问题就是：“**得到选修了所有课程的学生**”。$RS÷S$ 的意义就是：“在 $R$ 和 $S$ 的联系 $RS$ 中，找出与 $S$ 中 **所有的元组有关系** 的 $R$ 元组”。


 除法运算的定义：除法运算 $\div$ 是同时从关系的水平和垂直方向进行运算。

给定关系 $R(X,Y)$ 和 $S(Y,Z)$，$X,Y,Z$ 为属性组。$R \div S$ 为：元组在 $X$ 上的分量值 $x$ 的 像集 $Y_x$ ，**包含** 关系 $S$ 在属性组 $Y$ 上投影 $\pi_y(S)$ 的 **集合**。形式定义：
$$R \div S = \{\ t_n[X]\quad |\quad  t_n \in R \wedge \pi_y(S) \subseteq  Y_x\}$$

这个概念非常抽象，我反正是没有听懂的。所以，这里通过一个实例来说明除法运算的求解过程：
  
  设有关系 $R、S$ 如图所示，求 $R÷S$ 的结果：
<img src="https://img-blog.csdnimg.cn/20200322193125378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center" width="25%">
求解步骤过程：
1. 第一步：找出被除关系 $R$ 和关系 $S$ 中 **相同的属性列**，即 $Y$ 属性。关系 $S$ 中对 $Y$ 做投影（即将 $Y$ 无重复的列举出）；所得结果如下：
<img src="https://img-blog.csdnimg.cn/2020032219323152.png" width = "6%">
2.  第二步：找出被除关系 $R$ 中与 $S$ 中**不相同的属性列**，即 $X$ 属性。关系 $R$ 中对 $X$ 做投影（即将 $X$ 无重复的列举出）；所得结果如下：
<img src="https://img-blog.csdnimg.cn/20200322193449400.png#pic_center" width="25%">
3.  第三步：求关系 $R$ 中 $X$ 属性对应的 **像集** $Y$。根据关系 $R$ 的记录，可以得到与 $X_1$ 值有关的记录，如图3所示，与 $X_2$ 有关的记录，如图4所示：
<img src="https://img-blog.csdnimg.cn/20200322193641182.png#pic_center" width="25%">


4. 第四步：**判断包含关系**。$R÷S$ 其实就是判断关系 $R$ 中 $X$ 各个值$x$ 的像集 $Y_x$ 是否包含关系 $S$ 中属性 $Y$ 的所有值。对比即可发现：
   * $X_1$ 的像集只有 $Y_1$，不能包含关系 $S$ 中属性 $Y$ 的所有值，所以排除掉 $X_1$；
   * $X_2$ 的像集包含了关系 $S$ 中属性 $Y$ 的所有值，所以 $R÷S$ 的最终结果就是 $X_2$。

       


也许现在有点明白除法运算是如何操作的了，下面来引申一下，**除法运算可以解决什么问题呢**？

$e.g.$ 设有关系 $R，S$ 以及 $RS$，如图所示，求 $RS÷S$ 的结果：
 <img src="https://img-blog.csdnimg.cn/20200322194540961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center" width="25%">  
重复一遍上面的求解过程：
1. 找到 关系 $RS$ 和 $S$ 中相同的属性列 $课程名$，即为 $Y$ 属性，对其投影，得到 $\pi_{课程名}(RS) = \{语文, 数学\}$。
2. 找到关系 $RS$ 中和 $S$ 不相同的属性列 $学生名$，即为 $X$ 属性，对其投影，得到 $\pi_{学生名}(RS) = \{张三, 李四\}$。
3. 对于 $X$ 属性中的每一个分量值 $x$，有像集 $Y_x$：张三的像集为 $\{语文, 数学\}$；李四的像集为 $\{语文\}$。
4. 判断包含关系，只有张三包含了关系 $S$ 中的属性 $Y$ 的所有值，因此求得结果为：$\{张三\}$。 
 
所以，可以容易看出来 $RS÷S$ 在这里解决的问题就是：“**得到选修了所有课程的学生**”。$RS÷S$ 的意义就是：“在 $R$ 和 $S$ 的联系 $RS$ 中，找出与 $S$ 中 **所有的元组有关系** 的 $R$ 元组”。

