> 本文属于「数据库系统学习实践」系列文章之一，这一系列着重于「数据库系统知识的学习与实践」。由于文章内容随时可能发生更新变动，欢迎关注和收藏[数据库系统系列文章汇总目录](https://memcpy0.blog.csdn.net/article/details/119996493)一文以作备忘。需要特别说明的是，为了透彻理解和全面掌握数据库系统，本系列文章中参考了诸多博客、教程、文档、书籍等资料，限于时间精力有限，这里无法一一列出。部分重要资料的不完全参考目录如下所示，在后续学习整理中还会逐渐补充：
> - 数据库系统概念 第六版 `Database System Concepts, Sixth Edition` ，作者是 `Abraham Silberschatz, Henry F. Korth, S. Sudarshan` ，机械工业出版社
> - 数据库系统概论 第五版，王珊 萨师煊编著，高等教育出版社


@[toc]


本书第10章、第11章讨论[**事务处理**](https://en.wikipedia.org/wiki/Transaction_processing) *transaction processing* 技术，关于具体实现，见[**事务处理系统**](https://en.wikipedia.org/wiki/Transaction_processing_system) *transaction processing system* 。**事务是一系列的数据库操作，是数据库应用程序的基本逻辑单元**。事务处理技术主要包括本章的**数据库恢复技术**和下章的**并发控制技术**。数据库恢复机制和并发控制机制，是数据库管理系统的重要组成部分。本章讨论数据库恢复的概念和常用技术。

---
# 本章参考文献
<img src="https://img-blog.csdnimg.cn/bb8c3b58e37e4e748901a53e13469d77.png" width="55%">

---
# 10.1 事务的基本概念与性质
在讨论数据库恢复技术之前，先讲解事务的基本概念、事务的性质。即过程是：事务概念+性质 $\to$ 数据库恢复技术概述+技术实现+恢复策略 $\to$ 并发控制技术。

## 10.1.1 事务
所谓**事务**，是==用户定义的一个数据库操作序列==，事务把所有操作作为一个整体一起向系统提交或撤销操作请求，==这些操作要么全做、要么全不做，是一个不可分割的工作单位==。例如，在关系数据库中，**一个事务可以是一个SQL语句、一组SQL语句或整个程序**。

**事务和程序是两个概念**，一般来讲，一个程序中包含多个事务。

**事务的开始和结束可以由用户显式控制**。如果用户没有显式地定义事务，则由数据库管理系统按默认规定自动划分事务。在SQL中，定义事务的语句一般有三条：
```sql
begin transaction;
commit;
rollback;
```
MySQL中事务用法：
```mysql
-- 开启事务
START TRANSACTION;  
或者  
BEGIN;
-- 提交事务
COMMIT;
-- 回滚事务
ROLLBACK;
```
> 说明：  
> MySQL中事务是自动提交的。也就是说我们不添加事务执行SQL语句，语句执行完毕会自动的提交事务。 可以通过下面语句查询默认提交方式： 
> ```mysql
> SELECT @@autocommit;
> ```
> 查询到的结果是1则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式：
> ```mysql
> SET @@autocommit = 0;
> ```
 
事务通常以 `begin transaction` 开始，以 `commit` 或 `rollback` 结束。`commit` 表示提交，即==提交事务的所有操作==（读+更新），具体地说就是**将事务中所有对数据库的更新，写回到磁盘上的物理数据库中去**，事务正常结束。`rollback` 表示回滚，即==在事务运行的过程中，发生了某种故障，事务不能继续执行，系统将事务中「对数据库的、所有已完成的操作」全部撤销，回滚到事务开始时的状态==，这里的操作指**对数据库的更新操作**。

## 10.1.2 事务的 `ACID` 性质
事务具有四个特性：**原子性** `Atomicity` 、**一致性** `Consistency` 、**隔离性** `Isolation` 、**持续性** `Durability` 。这四个特性简称为**ACID特性** `ACID properties` 。
1. 原子性
事务是数据库应用程序的**基本逻辑工作单元**，是**不可分割的最小操作单位**，事务中包括的诸操作要么都做、要么都不做。
2. 一致性
保证数据一致性是对数据库最基本的要求。**事务完成时，必须使所有的数据都保持一致状态**。事务执行的结果，必须是使数据库从「一个一致性状态」变到「另一个一致性状态」（从一个胜利，走向另一个胜利）。因此当数据库只包含成功事务提交的结果时，就说**数据库处于一致性状态**；如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所做的修改，有一部分已写入物理数据库，这时**数据库就处于一种不正确的状态**（即不一致的状态）。
例如，某公司在银行中有 $A, B$ 两个账号，现在公司想从账号 $A$ 中取出一万元、存入账号 $B$ ，那么就可以定义一个事务，该事务包括两个操作：第一个操作是从账号 $A$ 中减去一万元，第二个操作是向账号 $B$ 中加入一万元。这两个操作要么全做、要么全不做。全做或者全不做，数据库都处于一致性状态。如果只做一个操作，则逻辑上就会发生错误，减少或增加一万元，这时数据库就处于不一致性状态了。**可见，一致性和原子性是密切相关的**。
3. 隔离性
**一个事务的执行不能被其他事务干扰**。即一个事务的内部操作及使用的数据，对其他并发事务是隔离的、不可见的，并发执行的各个事务之间不能互相干扰。
4. 持续性（也称**永久性** `Permanence` ）
**一个事务一旦提交或回顾，它对数据库中数据的改变就应该是永久性的**。接下来的其他操作或故障，不应对其执行结果有任何影响。

**事务是数据库恢复和并发控制的基本单位**，所以下面的讨论均以事务为对象。**保证事务ACID特性是事务管理的重要任务**，只要DBMS能保证系统中一切事务的ACID特性，也就保证了数据库处于一致状态。可能破坏事务ACID特性的因素有：
（1）多个事务并行运行时，不同事务的操作交叉执行；
（2）事务在运行过程中，被强制停止
在第一种情况下，DBMS必须保证，多个事务的交叉运行不影响这些事务的原子性；在第二种情况下，DBMS必须保证，被强制停止的事务对数据库和其他事务没有任何影响。

这些就是数据库管理系统中恢复机制（**保证事务的原子性、一致性、持续性**）和并发控制机制（**保证事务的隔离性、一致性**）的责任。

---
# 10.2 数据库恢复概述
尽管数据库系统中采取了各种保护措施，以防止数据库的安全性和完整性被破坏、保证并发事务的正确执行，但是计算机系统中硬件的故障、软件的错误、操作员的失误以及恶意的破坏，仍是不可避免的，这些故障轻则造成运行事务非正常中断，影响数据库中数据的正确性，重则破坏数据库，使数据库中全部或部分数据丢失。因此DBMS必须具有「**把数据库从错误状态恢复到某一已知正确状态（亦称为一致状态或完整状态）**」的功能，这就是数据库的恢复。

**恢复子系统**是DBMS的一个重要组成部分，而且相当庞大，常常占整个系统代码的10%以上。数据库系统采用的恢复技术是否行之有效，不仅**对系统的可靠程度起着决定性作用**，而且对系统的运行效率也有很大影响，是衡量系统性能优劣的重要指标。

---
# 10.3 故障的种类
数据库系统中可能发生各种各样的故障，大致可以分为以下几类。
## 10.3.1 事务内部的故障
事务内部的故障有的是可以通过事务程序本身发现的（见下面的转账事务），有的是非预期的、不能由事务程序处理的。例如，银行转账事务，这个事务把一笔金额从一个账户甲转到另一个账户乙。
```sql
begin transaction
	// 读账户甲的余额
	balance = balance - amount; /* amount为转账金额 */
	if(balance < 0) then
	{
		打印 '金额不足,不能转账';	/* 事务内部可能造成事务被回滚的情况 */
		rollback;				/* 撤销刚才的修改,恢复事务 */
	} else
	{
		/* 读账户乙的余额 */
		balance1 = balance1 + amount;
		commit;					/* 写回balance1 */
	}
```
**这一例子包括的两个更新操作，要么全部完成、要么全部不做，否则就会使数据库处于不一致状态**，例如可能出现只把账户甲的余额减少、没有把账户乙的余额增加的情况。在这段伪代码中，若产生账户甲余额不足的情况，应用程序可以发现、并让事务回滚，撤销已做的修改，恢复数据库到正确状态。

==事务内部更多的故障是非预期的，是不能由应用程序处理的==。如运算溢出、并发事务发生死锁而被选中撤销该事务、违反了某些完整性限制而被终止等。后续内容中，==事务故障仅指这类非预期的故障。==

**事务故障意味着事务没有达到预期的终点（`commit` 或者显式的 `rollback`）**，因此，数据库可能处于不正确状态。恢复程序要在不影响其他事务运行的情况下，强行回滚该事务，即撤销该事务已经作出的、任何对数据库的修改，使得该事务好像根本没有启动一样，这类恢复操作称为**事务撤销** `undo` 。

## 10.3.2 系统故障
==系统故障是指「造成系统停止运转的任何事件」，使得系统要重新启动==。例如，特定类型的硬件错误（CPU故障）、操作系统故障、DBMS代码错误、系统断电等。**这类故障影响正在运行的所有事务，但不破坏数据库**。此时主存内容，尤其是数据库缓冲区（在内存）中的内容都丢失，所有运行事务都非正常终止。

发送系统故障时，**一些尚未完成的事务的结果可能已送入物理数据库**，从而造成数据库可能处于不正确的状态。为保证数据一致性，要清除这些事务对数据库的所有修改。**恢复子系统必须在系统重新启动时，让所有非正常终止的事务回滚，强行撤销所有未完成的事务**。

另一方面，发送系统故障时，**有些已完成的事务可能有一部分、甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中**。系统故障使得这些事务对数据库的修改，部分或全部丢失，这也会使数据库处于不一致状态。因此应将这些事务已提交的结果，重新写入数据库。所以系统重新启动时，**恢复子系统需要撤销所有未完成的事务外**，还需要**重做** `redo` **所有已提交的事务**，以将数据库真正恢复到一致状态。
## 10.3.3 介质故障
系统故障常称为**软故障** `soft crash` ，介质故障称为**硬故障** `hard crash` 。硬故障指外存故障，如磁盘损坏、磁头碰撞、瞬间强磁场干扰等。**这类故障将破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务**。==这类故障比前两类故障发生的可能性小得多，但破坏性最大。==
## 10.3.4 计算机病毒
计算机病毒是一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序。这种程序和其他程序不同，它像微生物学所称的病毒一样，可以繁殖和传播，并造成对计算机系统包括数据库的危害。

计算机病毒的种类很多，不同病毒有不同的特征。小的病毒只有20条指令，不到50B；大的病毒像一个操作系统，由上万条指令组成。有的病毒传播很快，一旦侵入系统就马上摧毁系统；有的病毒有较长的潜伏期，计算机在感染后数天或数月才开始发病。有的病毒感染系统所有的程序或数据；有的只对某些特定的程序和数据感兴趣。多数病毒一开始并不摧毁整个计算机系统，它们可能只在数据库或其他数据文件中，将小数点向左或向右移一两位、增加或删除一两个零，从而导致系统运行不正常。

计算机病毒已成为计算机系统的主要威胁，自然也是数据库系统的主要威胁。为此，计算机的安全工作者已研制了许多预防病毒的“疫苗”，检查、诊断、消灭计算机病毒的软件也在不断发展。但是，至今还没有一种可以使计算机终生免疫的“疫苗”。因此，数据库一旦被破坏，仍要用恢复技术把数据库加以恢复。

总结==各类故障对数据库的影响有两种可能性==，一是==数据库本身被破坏==，二是==数据库没有被破坏、但数据可能不正确==，这是由于事务的运行被非正常终止造成的。

---
# 10.4 恢复的实现技术
==恢复的基本原理==十分简单，一个词：==冗余==！即，**数据库中被破坏的任何一部分或不正确的数据，可以根据存储在系统别处的冗余数据来重建**。尽管恢复的基本原理很简单，但是实现技术的细节却相当复杂，下面略去一些细节，介绍数据库恢复的实现技术。

恢复机制涉及的两个关键问题是：**如何建立冗余数据？如何利用这些冗余数据实施数据库恢复？** ==建立冗余数据最常用的技术是「数据转储 `backup` 」和「登记日志文件 `logging`」==，通常在一个数据库中，这两种方法是一起使用的。
## 10.4.1 数据转储
**数据转储是数据库恢复中采用的基本技术**。所谓转储，即数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程。这些备用的数据称为**后备副本** `backup` 或**后援副本**。

当数据库遭到破坏后，可以将后备副本重新装入，但==重装后备副本只能将数据库恢复到转储时的状态==，要想恢复到故障发生时的状态，==必须重新运行自转储以后的所有更新事务==。

例如，在下图中系统在 $T_a$ 时刻停止运行事务，进行数据库转储，在 $T_b$ 时刻转储完毕，得到 $T_b$ 时刻的数据库一致性副本（不是 $T_a$ 时的？还是说转储和其他事务一起执行？）。系统运行到 $T_f$ 时刻发生故障。为恢复数据库，首先由数据库管理员重装数据库后备副本，将数据库恢复至 $T_b$ 时刻的状态，然后重新运行自 $T_b \sim T_f$ 时刻的所有更新事务，这样就把数据库恢复至故障发生前的一致状态。
<img src="https://img-blog.csdnimg.cn/47f1f871715641b8b69d90536c97a36b.png#pic_center" width="50%">
转储是十分耗费时间和资源的，不能频繁进行。数据库管理员应根据数据库使用情况，确定一个**适当的转储周期**。转储分为**静态转储**和**动态转储**：
- 静态转储是**在系统中无运行事务时、进行的转储操作**。即转储操作开始的时刻，数据库处于一致性状态，而转储期间不允许（或不存在）对数据库的任何存取、修改活动。显然，**静态转储得到的一定是一个数据一致性的副本**。
静态转储实现简单，但转储必须等待正运行的用户事务结束才能进行。同样，新的事务必须等待转储结束才能执行，**这会降低数据库的可用性**。
- 动态转储指**转储期间允许对数据库进行存取或修改**，即转储和用户事务可以并发执行。动态转储可克服静态转储的缺点，它不用等待正在运行的用户事务结束，也不会影响新事务的运行。但是，**转储结束时后备副本上的数据不能保证正确有效**。例如，在转储期间的某个时刻 $T_c$ ，系统把数据 $A = 100$ 转储到磁带上，而在下一个时刻 $T_d$ ，某一事务将 $A$ 改为 $200$ 。转储结束后，后备副本上的 $A$ 已经是过时的数据了。
为此，必须把转储期间各事务对数据库的修改活动登记下来，建立**日志文件** `log file` 。这样，「后备副本+日志文件」就能把数据库恢复到某一时刻的正确状态。

转储还可分为**海量转储**和**增量转储**两种方式。海量转储是指**每次转储全部数据库**，增量转储则指**每次只转储上一次转储后更新过的数据**。从恢复角度看，使用海量转储得到的后备副本进行恢复，一般来说会更方便些；但如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效。

数据转储有两种方式，分别可在两种状态下进行，因此数据转储方法分为四类：==动态海量转储==、==动态增量转储==、==静态海量转储==、==静态增量转储==：
<img src="https://img-blog.csdnimg.cn/6c74204687534d498afbf47583ee1665.png#pic_center" width="40%">

## 10.4.2 登记日志文件
### ① 日志文件的格式和内容
==日志文件是用来记录「事务对数据库的更新操作」的文件==。不同数据库系统采用的日志文件格式并不完全一样，概括起来日志文件主要有两种格式：**以记录为单位的日志文件**和**以数据块为单位的日志文件**。

对于以记录为单位的日志文件，==日志文件中需要登记的内容包括==：
- 各个事务的开始 `begin transaction` 标记；
- 各个事务的结束 `commit` 或 `rollback` 标记；
- 各个事务的所有更新操作

这里每个事务的开始标记、每个事务的结束标记和每个更新操作，均作为日志文件中的一个日志记录 `log record` 。==每个日志记录的主要内容==包括：
- 事务标识（标明是哪个事务）；
- 操作的类型（插入、删除或修改）；
- 操作对象（记录内部标识）；
- 更新前数据的旧值（对插入操作而言，此项为空值）；
- 更新后数据的新值（对删除操作而言，此项为空值）

对于以数据库为单位的日志文件，日志记录的内容包括：
- 事务标识；
- 被更新的数据块——由于将「更新前的整个块」和「更新后的整个块」都放入日志文件中，操作类型和操作对象等信息就不必放入日志记录中了

### ② 日志文件的作用
日志文件在数据库恢复中，起着非常重要的作用，可以用来进行**事务故障恢复**和**系统故障恢复**，并**协助后备副本进行介质故障恢复**。具体作用是：
（1）**事务故障恢复和系统故障恢复，必须用日志文件**；
（2）**在动态转储方式中必须建立日志文件**，后备副本和日志文件结合起来才能有效地恢复数据库
（3）**在静态转储方式中也可建立日志文件**，当数据库毁坏后重新装入后备副本，把数据库恢复到转储结束时刻的正确状态，然后利用日志文件把已完成的事务进行重做处理、对故障发生时尚未完成的事务进行撤销处理。这样不必重新运行那些已完成的事务程序，就可把数据库恢复到故障前某一时刻的正确状态，如下图所示：
<img src="https://img-blog.csdnimg.cn/ddda645502eb4976a4ddd48478644d19.png#pic_center" width="50%">
### ③ 登记日志文件
==为保证数据库是可恢复的，登记日志文件时必须遵循两条原则：==
- ==登记的次序严格按并发事务执行的时间次序==；
- ==必须先写日志文件，后写数据库==

「把对数据的修改写到数据库中」和「把表示这个修改的日志记录写到日志文件中」，是两个不同的操作，有可能在这两个操作之间发生故障，即两个写操作只完成了一个。如果先写了数据库修改、而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。如果先写日志、但没有修改数据库，按日志文件恢复时只不过多执行一次不必要的 `undo` 操作，并不会影响到数据库的正确性。所以为了安全，一定要先写日志文件，即**首先把日志记录写到日志文件中，然后写数据库的修改**。这就是**先写日志文件**的原则。只是我有疑问，如果这两个操作都没有完成呢？

---
# 10.5 恢复策略
当系统运行过程中发生故障，利用数据库后备副本和日志文件，就可以将数据库恢复到故障前的某个一致性状态。**不同故障的恢复策略和方法也不一样**。
## 10.5.1 事务故障的恢复
事务故障指**事务在运行至正常终止点前被终止**（非预期的），这时恢复子系统应利用日志文件，撤销 `undo` 此事务已对数据库进行的修改。**事务故障的恢复是由系统自动完成的，对用户是透明的**。==系统对事务故障的恢复步骤是==：
（1）反向扫描日志文件（即从最后向前扫描日志文件），查找该事务的更新操作；
（2）对该事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库。这样，如果记录中是插入操作，则相当于做删除操作（因此时“更新前的值”为空）；若记录中是删除操作，则做插入操作；若是修改操作，则相当于用修改前的值替代修改后的值。
（3）继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理；
（4）如此处理下去，直到读到此事务的开始标记，事务故障恢复就完成了。

## 10.5.2 系统故障的恢复
前面讲过，系统故障造成数据库不一致状态的原因有两个，一是**未完成事务对数据库的更新可能已写入数据库**，二是**已提交事务对数据库的更新可能还留在缓冲区、没来得及写入数据库**。因此恢复操作就是要**撤销故障发生时未完成的事务、重做已完成的事务**。

**系统故障的恢复是由系统在重新启动时自动完成的，不需要用户干预**。==系统的恢复步骤是==：
（1）正向扫描日志文件（即从头扫描日志文件），找出在故障发生前已经提交的事务（这些事务即有 `begin transaction` 记录，也有 `commit` 记录），将其事务标识记入重做队列 `redo-list` ；同时找出故障发生时尚未完成的事务（这些事务只有 `begin transaction` 记录，无相应的 `commit` 记录），将其事务标识记入撤销队列 `undo-list` ；
（2）对撤销队列中的各个事务进行撤销 `undo` 处理，方法是：反向扫描日志文件，对每个撤销事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库；
（3）对重做队列中的各个事务进行重做 `redo` 处理，方法是：正向扫描日志文件，对每个重做事务重新执行日志文件登记的操作，即将日志记录中“更新后的值”写入数据库。

## 10.5.3 介质故障的恢复
发送介质故障后，磁盘上的物理数据和日志文件被破坏，这是最严重的一种故障，==恢复方法是重装数据库，然后重做已完成的事务。==
（1）装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。对于动态转储的数据库副本，还需同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法（即 `redo + undo` ），才能将数据库恢复到一致性状态；
（2）装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务，即首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列；然后正向扫描日志文件，对重做队列中的所有事务进行重做处理，即将日志记录中“更新后的值”写入数据库。
这样就可以将数据库恢复至故障前某一时刻的一致状态了。

**介质故障的恢复需要数据库管理员介入**，但数据库管理员只需要重装最近转储的数据库副本和有关的各日志文件副本，然后执行系统提供的恢复命令即可，具体的恢复操作仍由数据库管理系统完成。

---
# 10.6 具有检查点的恢复技术
利用日志文件进行数据库恢复时，恢复子系统必须搜索日志，确定哪些事务需要重做、哪些事务需要撤销。一般来说，需要检查所有日志记录。这样做有两个问题，一是搜索整个日志将耗费大量时间；二是很多需要重做处理的事务，实际上已经将它们的更新操作结果写到了数据库中，然而恢复子系统又重新执行了这些操作，浪费了大量时间。

为了解决这些问题，又发展了**具有检查点的恢复技术**。这种技术在日志文件中增加一类新的记录——**检查点 `checkpoint` 记录** ，增加一个重新开始文件，并让恢复子系统在登录日志文件期间动态地维护日志。

==检查点记录的内容==包括：
- 建立检查点时刻所有正在执行的事务清单；
- 这些事务最近一个日志记录的地址

重新开始文件用来==记录各个检查点记录在日志文件中的地址==。下图说明了建立检查点 $C_i$ 时对应的日志文件和重新开始文件：
<img src="https://img-blog.csdnimg.cn/de8116bb907e4fbf8b4df54549c1ae91.png#pic_center" width="55%">
==动态维护日志文件的方法是，周期性地执行「建立检查点、保存数据库状态」的操作==。具体步骤是：
（1）将当前日志缓冲区中的所有日志记录，写入磁盘上的日志文件上；
（2）在日志文件中写入一个检查点记录；
（3）将当前数据缓冲区的所有数据记录，写入磁盘的数据库中；
（4）把检查点记录在日志文件中的地址，写入一个重新开始文件中。

恢复子系统可以定期或不定期地建立检查点，保存数据库状态。检查点可以按照预定的一个时间间隔建立，如每隔一个小时建立一个检查点；也可以按照某种规则建立检查点，如日志文件已写满一半时建立一个检查点。

==使用检查点方法可以改善恢复效率==。当事务 $T$ 在一个检查点之前提交，$T$ 对数据库所做的修改一定都已写入数据库，写入时间是在这个检查点建立之前、或在这个检查点建立之时。这样，在进行恢复处理时，没有必要对事务 $T$ 执行重做操作。

系统出现故障时，恢复子系统将根据事务的不同状态，采取不同的恢复策略，如下图所示：
- $T_1$ ：在检查点之前提交；
- $T_2$ ：在检查点之前开始执行，在检查点之后、故障点之前提交；
- $T_3$ ：在检查点之前开始执行，在故障点时还未完成；
- $T_4$ ：在检查点之后开始执行，在故障点之前提交；
- $T_5$ ：在检查点之后开始执行，在故障点时还未完成。
<img src="https://img-blog.csdnimg.cn/4b0148224d5442698b96e5962df438e4.png" width="55%">

$T_3$ 和 $T_5$ 在故障发生时还未完成，所以予以撤销；$T_2$ 和 $T_4$ 在检查点之后才提交，它们对数据库所做的修改，在故障发生时可能还在缓冲区中，尚未写入数据库，所以要重做；$T_1$ 在检查点之前已提交，所以不必执行重做操作。

==系统使用检查点方法进行恢复的步骤==是：
（1）从重新开始文件中，找到**最后一个检查点记录**在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录；
（2）由该检查点记录，得到检查点建立时刻、所有正在执行的事务清单 `active-list` 。这里建立两个事务队列：
- `undo-list` ：需要执行 `undo` 操作的事务集合；
- `redo-list` ：需要执行 `redo` 操作的事务集合

把 `active-list` 暂时放入 `undo-list` 队列，`redo-list` 队列暂时为空。
（3）**从检查点开始正向扫描日志文件**：
① 如有新提交的事务 $T_i$ ，把 $T_i$ 暂时放入 `undo-list` 队列；
② 如有提交的事务 $T_j$ ，把 $T_j$ 从 `undo-list` 队列移到 `redo-list` 队列；直到日志文件结束。
（4）对 `undo-list` 中的每个事务执行 `undo` 操作，对 `redo-list` 队列中的每个事务执行 `redo` 操作。

---
# 10.7 数据库镜像
如前所述，介质故障是对系统影响最为严重的一种故障。系统出现介质故障后，用户应用全部中断，恢复起来比较费时。而且数据库管理员必须周期性地转储数据库，这也加重了数据库管理员的负担。如果不及时而正确地转储数据库，一旦发生介质故障，会造成较大的损失。

随着技术的发展，磁盘容量越来越大，价格越来越便宜。为避免磁盘介质出现故障影响数据库的可用性，许多数据库管理系统提供了**数据库镜像** `mirror` 功能，用于数据库恢复。即根据数据库管理员的要求，**自动把整个数据库或其中的关键数据复制到另一个磁盘上**，每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去，由数据库管理系统自动保证镜像数据与主数据库的一致性。如下图(a)所示。
<img src="https://img-blog.csdnimg.cn/22cec2445d6a47a8b5c020a4dc0c24e5.png#pic_center" width="55%">
这样，**一旦出现介质故障，可由镜像磁盘继续提供使用**，同时**数据库管理系统自动利用镜像磁盘数据、进行数据库的恢复**，不需要关闭系统和重装数据库副本，如下图(b)所示。
<img src="https://img-blog.csdnimg.cn/abd1e31acbef45029cf9d700761721f7.png#pic_center" width="55%">
在没有出现故障时，数据库镜像还可用于并发操作，即**当一个用户对数据加排他锁、修改数据时，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁**。

由于数据库镜像是通过复制数据实现的，频繁地复制数据自然会降低系统运行效率，因此在实际应用中，用户往往只选择对关键数据和日志文件进行镜像，而不是对整个数据库进行镜像。
