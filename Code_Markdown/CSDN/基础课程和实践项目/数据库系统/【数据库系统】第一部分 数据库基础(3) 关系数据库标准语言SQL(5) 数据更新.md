> 本文属于「数据库系统」系列文章之一，这一系列着重于「数据库系统知识的学习与实践」。由于文章内容随时可能发生更新变动，欢迎关注和收藏[数据库系统系列文章汇总目录](https://memcpy0.blog.csdn.net/article/details/119996493)一文以作备忘。需要特别说明的是，为了透彻理解和全面掌握数据库系统，本系列文章中参考了诸多博客、教程、文档、书籍等资料，限于时间精力有限，这里无法一一列出。部分重要资料的不完全参考目录如下所示，在后续学习整理中还会逐渐补充：
> - 数据库系统概念 第六版 `Database System Concepts, Sixth Edition` ，作者是 `Abraham Silberschatz, Henry F. Korth, S. Sudarshan` ，机械工业出版社
> - 数据库系统概论 第五版，王珊 萨师煊编著，高等教育出版社

@[toc]

---
# 3.5 数据更新
数据更新操作有三种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据，在SQL中有相应的三类语句。
## 3.5.1 插入数据
SQL的数据插入语句 `insert` 通常有两种形式，一种是**插入一个元组**，另一种是**插入子查询结果**，后者可以一次插入多个元组。

### 1. 插入元组
插入元组的 `insert` 语句的格式如下。功能是**将新元组插入指定表中**，其中新元组的属性列1的值为常量1，属性列2的值为常量2，……。**`into` 子句中没有出现的属性列，新元组在这些列上将取空值**。此外，若插入全部属性值，则属性列可以省略；或者说，**如果 `into` 子句中没有指明任何属性列名，则新插入的元组必须在每个属性列上均有值**。

必须注意的是，在表定义时说明了 `not NULL` 或 `unique` 或为主键的属性列不能取空值，否则会出错。==若已定义主键、外键及其他用户完整性约束，向表中更新元组、系统自动支持其完整性==。
```sql
insert into <表名> [(<属性列1>[, <属性列2>] ...)]
values(<常量1>[, <常量2>]...);
```
【例3.69】将一个新生元组（学号：201215128，姓名：辰东，性别：男，所在系：IS，年龄：18岁）插入到 `Student` 表中。
答：在 `into` 子句中指出了表名 `Student` ，并**指出了新增加的元组在哪些属性上要赋值，属性的顺序可以和 `create table` 中的顺序不一样**。`values` 子句对新元组的各属性赋值，==字符串常数要用单引号（英文符号）括起来==。
```sql
insert into Student(Sno, Sname, Ssex, Sdept, Sage)
values('201215128', '辰东', '男', 'IS', 18);
```
【例70】将学生张成民的信息插入到 `Student` 表中。
答：与【例3.69】不同的是，**在 `into` 子句中只指出了表名，没有指出属性名。这表示新元组要在表的所有属性列上都指定值，属性列的次序与 `create table` 中的次序相同**。`values` 子句对新元组的各属性列赋值，一定要注意值与属性列要一一对应，如果像【例3.69】那样，写成 `('201215126', '张成民', '男', 'CS', 18)` ，则会因为数据类型不匹配出错。
```sql
insert into Student
values('201215126', '张成民', '男', 18, 'CS');
```
【例3.71】插入一条选课记录 `('201215128', '1')` 。
答：如下所写，则关系DBMS将在新插入记录的 `Grade` 列上自动地赋空值。
```sql
insert into SC(Sno, Cno)
values('201215128', '1');
```
或因为==没有指出 `SC` 的属性名，在 `Grade` 列上要明确地给出空值==。
```sql
insert into SC
values('201215128', '1', null);
```
### 2. 插入子查询结果
**子查询不仅可以嵌套在 `select` 语句中，用以构造父查询的条件**（如3.4.3小节所述），也可以**嵌套在 `insert` 语句中，用以生成要插入的批量数据**。插入子查询结果的 `insert` 语句格式为：
```sql
insert into <表名> [(<属性列1>[, <属性列2>] ...)]
	子查询;
```
【例3.72】对每个系，求学生的平均年龄，并把结果存入数据库。
答：首先在数据库中建立一个新表，其中一列存放系名，另一列存放相应的学生平均年龄。
```sql
create table DeptAge (
	Sdept char(15),
	Avg_age smallint
);
```
然后对 `Student` 表按系分组、求平均年龄，再把系名和平均年龄存入新表中。
```sql
insert into DeptAge(Sdept, Avg_age)
	select Sdept, avg(Sage)
	from Student
	group by Sdept;
```

---
## 3.5.2 修改数据
修改操作又称为更新操作，其语句的一般格式为：
```sql
update <表名>
set <列名> = <表达式>
	[, <列名> = <表达式>] ...
[where <条件[子查询]>];
```
其功能是**修改指定表中满足 `where` 子句条件的元组**，其中 `set` 子句给出 `<表达式>` 的值、用以取代相应的属性列值。**如果省略了 `where` 子句，则表示要修改表中的所有元组。**
### 1. 修改某个元组的值
【例3.73】将学生 `201215121` 的年龄改为 `22` 岁。
答：
```sql
update Student
set Sage = 22
where Sno = '201215121';
```
### 2. 修改多个元组的值
【例3.74】将所有学生的年龄增加 `1` 岁。
答：
```sql
update Student
set Sage = Sage + 1;
```
### 3. 带子查询的修改语句
**子查询也可以嵌套在 `update` 语句中，用以构造修改的条件**。

【例3.75】将计算机科学系全体学生的成绩置零。
答：
```sql
update SC
set Grade = 0
where Sno in (
	select Sno
	from Student
	where Sdept = 'CS'
);
```
【例】学生“左彼”在001号课程考试中作弊，该课成绩作零分计。
```sql
UPDATE SC
SET grade = 0
where cno = '001' 
	and sno =
		(select sno
		from Student
		where sname＝'左彼');
```
【例】若某学生008号课程的成绩低于该门课程平均成绩时，提高5%。
```sql
UPDATE SC
SET grade = grade * 1.05
where cno = '008' 
   and grade <
	   (select AVG(grade)
	   from SC
	   where cno='008');
```

---
## 3.5.3 删除数据
删除语句的一般格式为：
```sql
delete from <表名>
[where <条件[子查询]>];
```
`delete` 语句的功能是，**从指定表中删除满足 `where` 子句条件的所有元组**。如果省略 `where` 子句，则表示删除表中全部元组，但表的定义仍在字典中，也就是说，==`delete` 语句删除的是表中的数据，而不是关于表的定义==。
### 1. 删除某个元组的值
【例3.76】删除学号为 `201215128` 的学生记录。
答：
```sql
delete from Student
where Sno = '201215128';
```
### 2. 删除多个元组的值
【例3.77】删除所有的学生选课记录。
答：这条 `delete` 语句将使 `SC` 成为空表，它删除了 `SC` 的所有元组。
```sql
delete from SC;
```
### 3. 带子查询的删除语句
**子查询同样也可以嵌套在 `delete` 语句中，用以构造执行删除操作的条件**。

【例3.78】删除计算机科学系所有学生的选课记录。
答：
```sql
delete from SC
where Sno in (
	select Sno
	from Student
	where Sdept = 'CS'
);
```
【例】将选课人数不足10人的课程记录删除。
```sql
DELETE from Course
	where cno in
		(select cno 
	      from SC
	      group by cno 
		      having COUNT(*) < 10);
```

对某个基本表中数据的增、删、改操作，有可能破坏参照完整性。在[【数据库系统】第一部分 数据库基础(5) 数据库完整性](https://memcpy0.blog.csdn.net/article/details/121433913)中，了解如何进行参照完整性的定义、检查控制和违约处理。
