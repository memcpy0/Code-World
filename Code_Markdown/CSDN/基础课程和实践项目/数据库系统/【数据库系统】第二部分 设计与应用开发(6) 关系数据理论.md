> 本文属于「数据库系统学习实践」系列文章之一，这一系列着重于「数据库系统知识的学习与实践」。由于文章内容随时可能发生更新变动，欢迎关注和收藏[数据库系统系列文章汇总目录](https://memcpy0.blog.csdn.net/article/details/119996493)一文以作备忘。需要特别说明的是，为了透彻理解和全面掌握数据库系统，本系列文章中参考了诸多博客、教程、文档、书籍等资料，限于时间精力有限，这里无法一一列出。部分重要资料的不完全参考目录如下所示，在后续学习整理中还会逐渐补充：
> - 数据库系统概念 第六版 `Database System Concepts, Sixth Edition` ，作者是 `Abraham Silberschatz, Henry F. Korth, S. Sudarshan` ，机械工业出版社
> - 数据库系统概论 第五版，王珊 萨师煊编著，高等教育出版社


@[toc]
 

本章学习关系数据理论（即关系规范化理论）。6.1节从**数据库逻辑设计**中如何构造一个好的**数据库模式**这一问题出发，阐明**关系规范化理论**研究的实际背景。6.2节介绍**规范化理论**，讨论各种范式及可能存在的插入、删除等问题，并直观描述解决方法。6.3节和6.4节进一步讨论关系数据理论，其中6.3节讨论**函数依赖的推理规则**，6.4节给出**模式等价的不同定义**及**模式分解算法**。6.1和6.2节是基本内容，本科学生需要掌握，6.3节和6.4节可作为研究生的学习内容。

---
# 本章参考文献
<img src="https://img-blog.csdnimg.cn/5de5cdf5e74e4c6d81addf841a1fbbb8.png#pic_center" width="65%">

---
# 6.1 问题的提出
前面讨论了**数据库系统**的一般概念，介绍了**关系数据库**的基本概念、关系模型的三个部分以及**关系数据库标准语言SQL**。但还有一个很基本的问题尚未涉及：针对一个具体问题，应该如何构造一个适合于它的数据库模式——应构造几个关系模式、每个关系由哪些属性组成……？这是**数据库设计**的问题，准确地说是**关系数据库逻辑设计**的问题。

实际上，设计任何一种数据库应用系统，不论是**层次的、网状的、关系的**，都会遇到**如何构造合适的数据模式**即逻辑结构的问题。由于关系模式有严格的数学理论基础，并且可向别的数据模型转换，因此人们**以关系模型为背景**来讨论这个问题，形成了**数据库逻辑设计**的一个有力工具——**关系数据库的规范化理论**。特别地，规范化理论虽然以关系模型为背景，但它对于一般的数据库逻辑设计同样具有理论上的意义。

首先回顾一下**关系模型的形式化定义**——在第2章关系数据库中已经讲过，**一个关系模式应当是一个五元组** $$R(U, D, DOM, F)$$
- 关系名 $R$ 是符号化的元组语义；
- $U$ 为一组属性；
- $D$ 为属性组 $U$ 中的属性所来自的域；
- $DOM$ 为属性到域的映射；
- $F$ 为属性组 $U$ 上的一个数据依赖 

由于 $D, DOM$ 与模式设计关系不大，因此本章中把关系模式看作一个三元组：$$R\langle U, F\rangle$$ 当且仅当 $U$ 上的一个关系 $r$ 满足 $F$ 时，$r$ 称为关系模式 $R\langle U, F\rangle$ 的一个关系。 

作为一个二维表，关系要符合一个最基本的条件——**每个分量必须是不可分的数据项**。满足了这个条件的关系模式就属于**第一范式** `1NF` 。

在模式设计中，假设已知一个模式 $S_\phi$ ，它仅由单个关系模式组成，问题是要设计一个模式 $S_D$ ，它与 $S_\phi$ 等价，但在某些指定的方面更好一些。这里通过一个例子说明，**一个不好的模式会有哪些问题**，分析它们产生的原因，并从中找到**设计一个更好的关系模式的方法**。

在举例之前，先非形式地讨论一下数据依赖的概念：==数据依赖是一个关系内部、**属性与属性之间的一种约束关系**==，这种约束关系是==通过**属性间值的相等与否**体现出来的数据间的关联==。它是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。人们已经提出了许多种类型的**数据依赖**，其中==最重要的是**函数依赖** `functional dependency, FD` 和**多值依赖** `multi-valued dependency, MVD`==（参考资料：[**Functional dependency in relational database theory**](https://en.wikipedia.org/wiki/Functional_dependency)、[**Multivalued dependency**](https://en.wikipedia.org/wiki/Multivalued_dependency)）。

函数依赖极为普遍地存在于现实生活中。比如描述一个学生的关系，可以有学号 `Sno` 、姓名 `Sname` 、系名 `Sdept` 等几个属性。由于一个学号只对应一个学生，一个学生只在一个系学习。因此当学号值确定之后，学生姓名、所在系的值也就被唯一地确定了。属性间的这种依赖关系，类似于数学中的[**函数**](https://memcpy0.blog.csdn.net/article/details/121336314) $y = f(x)$ ，自变量 $x$ 确定以后，相应的函数值 $y$ 也就唯一地确定了。类似地有 `Sno` 函数决定 `Sname` ，`Sno` 函数决定 `Sdept` ，记作 $Sno \to Sname,\ Sno \to Sdept$ 。
【例6.1】建立一个描述学校教务的数据库，该数据库涉及的对象包括学生的学号 `Sno` 、所在系 `Sdept` 、系主任姓名 `Mname` 、课程号 `Cno` 、成绩 `Grade` 。假设用一个单一的关系模式 `Student` 来表示，则该关系模式的属性集合为：$$U = \{ Sno, Sdept, Mname, Cno, Grade\}$$ 现实中的已知事实（语义）告诉我们：
① 一个系有若干学生，但一个学生只属于一个系；
② 一个系只有一名（正职）负责人；
③ 一个学生可以选修多门课程，每门课程有若干学生选修；
④ 每个学生学习每一门课程有一个成绩。
于是得到属性组 $U$ 上的一组函数依赖 $F$（即图6.1）：$$F = \{ Sno \to Sdept, Sdept \to Mname, (Sno, Cno) \to Grade \}$$   如果只考虑函数依赖这一种数据依赖，可以得到一个描述学生的关系模式 $Student \langle U, F\rangle$ 。表6.1是某一时刻关系模式 `Student` 的一个实例，即数据表：![在这里插入图片描述](https://img-blog.csdnimg.cn/a762b8b3375242f487a656eb46a2def6.png)
但是，这个关系模式存在以下问题，即**不是一个好的模式**：
1. **数据冗余**
比如，每个系的系主任姓名重复出现，重复次数与「该系所有学生的所有课程成绩」出现次数相同，**这将浪费大量的存储空间**。
2. **更新异常** `update anomalies` 
**由于数据冗余，当更新数据库中的数据时，系统要付出很大代价来维护数据库的完整性，否则会面临数据不一致的危险**。比如，某系更换系主任后，必须修改与该系学生有关的每个元组。
3. **插入异常** `insertion anomalies` 
如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。
4. **删除异常** `deletion anomalies`
如果某个系的学生全部毕业了，则在删除该系学生信息的同时，这个系及其系主任的信息也丢掉了。

鉴于存在以上种种问题，可以得出这样的结论：**`Student` 关系模式不是一个好的模式**。==一个好的模式应当不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。==

为什么会发生这些问题呢？因为**这个模式中的函数依赖存在某些不好的性质**。这就是本章要讨论的问题。假如把这个单一的关系模式改造一下，分成三个关系模式：
$$\begin{aligned}
&S(Sno, Sdept, Sno\to Sdept);\\
&SC(Sno, Cno, (Sno, Cno) \to Grade);\\
&DEPT(Sdept, Mname, Sdept\to Mname)
\end{aligned}$$ 这三个模式都不会发生插入异常、删除异常的问题，数据冗余也得到了控制。

**一个模式的数据依赖会有哪些不好的性质？如何改造一个不好的模式**？这就是下节「**规范化理论**」要讨论的内容。

---
# 6.2 规范化
本节首先讨论**一个关系的属性间的不同依赖情况**，讨论**如何根据属性间依赖情况、判定关系是否具有某些不合适的性质**，通常按属性间依赖情况来区分关系规范化程度，分为第一范式、第二范式、第三范式和第四范式等；然后直观地描述**如何将具有不合适性质的关系，转换为更合适的形式**。

6.1节关系模式 $Student\langle U, F\rangle$ 职工有 $Sno \to Sdept$ 成立，即在任何时刻 $Student$ 的关系实例（即 $Student$ 数据表）中，不可能存在两个元组在 $Sno$ 上的值相等、而在 $Sdept$ 上的值不等。因此，下表的 $Student$ 表是错误的，因为表中有两个元组在 $Sno$ 上都等于 $S_1$ ，而在 $Sdept$ 上一个为计算机系、另一个为自动化系。
## 6.2.1 函数依赖
**定义6.1** 设 $R(U)$ 是属性集 $U$ 上的关系模式，$X, Y$ 是 $U$ 的子集。若对于 $R(U)$ 的任意一个可能的关系 $r$ ，$r$ 中不可能存在两个元组，在 $X$ 上的属性值相等、而在 $Y$ 上的属性值不等，则称 **$X$ 函数决定 $Y$** 或 **$Y$ 函数依赖于 $X$** ，记作 $X\to Y$ 。

==函数依赖和别的数据依赖一样，都是语义范畴的概念，只能根据语义来确定一个函数依赖==。例如，姓名 $\to$ 年龄这一函数依赖，只有在该部门没有同名人的条件下成立，如果有同名人，则年龄就不再函数依赖于姓名了。

设计者也可对现实世界作强制性规定，例如规定不允许同名人出现，因而使姓名 $\to$ 年龄函数依赖成立。这样，当插入某个元组时，这个元组上的属性值必须满足规定的函数依赖，若发现同名人存在，则拒绝插入该元组（完整性约束条件）。

==注意，函数依赖不是指关系模式 $R$ 的某个或某些关系满足的约束条件，而是指 $R$ 的一切关系均要满足的约束条件==。下面介绍一些术语和记号。
- $X \to Y$ ，但 $Y \not \subseteq X$ ，则称 $X\to Y$ 是**非平凡的函数依赖**；
- $X \to Y$ ，但 $Y \subseteq X$ ，则称 $X\to Y$ 是**平凡的函数依赖**。对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。若不特别声明，总是讨论非平凡的函数依赖。
- $X \to Y$ ，则 $X$ 称为这个函数依赖的**决定属性组**，也称为**决定因素** `determinant` 。
- 若 $X \to Y,\ Y \to X$ ，则记为 $X \lrarr Y$ 。
- 若 $Y$ 不函数依赖于 $X$ ，则记为 $X \not \to Y$ 。

**定义6.2** 在 $R(U)$ 中，如果 $X \to Y$ ，并且对于 $X$ 的任何一个**真子集** $X'$ ，都有 $X' \not \to Y$ ，则称 **$Y$ 对 $X$ 完全函数依赖**，记作 $$X \stackrel{F} \to Y$$ 若 $X \to Y$ ，但 $Y$ 不完全函数依赖于 $X$ ，则称 **$Y$ 对 $X$ 部分函数依赖** `partial functional dependency` ，记作 $$X \stackrel{P} \to Y$$

【例6.1】中的 $(Sno, Cno) \stackrel {F}\to Grade$ 是完全函数依赖，$(Sno, Cno) \stackrel{P} \to Sdept$ 是部分函数依赖，因为 $Sno \to Sdept$ 成立，而 $Sno$ 是 $(Sno, Cno)$ 的真子集。

**定义6.3** 在 $R(U)$ 中，如果 $X\to Y\ (Y \not \subseteq X),\ Y \not \to X,\ Y \to Z\ (Z \not \subseteq Y)$ 则称 $Z$ 对 $X$ **传递函数依赖** `transitive functional dependency` ，记为 $$X\stackrel{T} \to Z$$ 或者写为 $X\stackrel{传递} \to Z$（这里加上条件 $Y\not \to X$ ，是因为如果 $Y \to X$ ，则 $X\lrarr Y$ ，实际上是 $X \stackrel{直接} \to Z$ ，是**直接函数依赖**而非**传递函数依赖**）。

【例6.1】中有 $Sno \to Sdept,\ Sdept \to Mname$ 成立，所以 $Sno \stackrel{T}\to Mname$ 。
## 6.2.2 键（码）
**定义6.4** 设 $K$ 是 $R\langle U, F\rangle$ 中的属性或属性组合，若 $K \stackrel {F} \to U$ ，则 $K$ 为 $R$ 的**候选键** `candidate key` 。

==键是关系模式中的一个重要概念==。在第2章已给出了关于键的若干定义，这里用函数依赖的概念重新定义键。注意，$U$ 是完全函数依赖于 $K$ 、而非部分函数依赖于 $K$ ，==如果 $U$ 部分函数依赖于 $K$ ，即 $K \stackrel{P} \to U$ ，则 $K$ 称为**超键** `super key` 。候选键是最小的超键，即 $K$ 的任意一个真子集都不是候选键==。若候选键多于一个，则选定其中的一个作为**主键** `primary key` 。

==包含在任何一个候选键中的属性，称为**主属性**== `prime attribute` ；不包含在任何候选键中的属性，称为**非主属性** `nonprime attribute` 或**非键属性** `non-key attribute` 。最简单的情况，单个属性是**键**（在后面的章节中，主键或候选键都简称为**键**，可根据上下文加以识别）；最极端的情况，整个属性组是键，称为**全键** `all-key` 。

【例6.2】关系模式 $S(\underline{Sno}, Sdept, Sage)$ 中单个属性 $Sno$ 是键，用下划线标识出来。$SC(\underline {Sno, Cno}, Grade)$ 中属性组合 $(Sno, Cno)$ 是键。

【例6.3】关系模式 $R(P, W, A)$ 中，属性 $P$ 表示演奏者、$W$ 表示作品、$A$ 表示听众。假设一个演奏者可以演奏多个作品，某一作品可被多个演奏者演奏，听众也可以欣赏不同演奏者的不同作品，这个关系模式的键为 $(P, W, A)$ ，即 `all-key` 。

**定义6.5** 关系模式 $R$ 中属性或属性组 $X$ 并非 $R$ 的键，但 $X$ 是另一个关系模式的键，则称 $X$ 是 $R$ 的**外键** `foreign key` 。

如在 $SC(\underline {Sno, Cno}, Grade)$ 中 $Sno$ 不是键，但 $Sno$ 是关系模式 $S(\underline{Sno}, Sdept, Sage)$ 的键，则 $Sno$ 是关系模式 $SC$ 的外键。

**主键与外键提供了一个表示关系间联系的手段**，如【例6.2】中关系模式 $S$ 与 $SC$ 的联系，就是通过 $Sno$ 来体现的。

## 6.2.3 范式
==关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式==。满足最低要求的叫**第一范式**，简称1NF；在第一范式中满足进一步要求的叫**第二范式**，简称2NF，其余以此类推。

有关范式理论的研究，主要是 `E. F. Codd` 做的工作。1971-1972年 `Codd` 系统地提出了1NF、2NF、3NF的概念，讨论了规范化的问题。1974年，`Codd` 和 `Boyce` 共同提出了一个新范式，即BCNF。1976年 `Fagin` 提出了4NF。后来又有研究者提出了5NF。

==所谓「第几范式」原本是表示关系的某一种级别==，所以常称某一关系模式 $R$ 为第几范式。现在则==把范式这个概念，理解成符合某一种级别的**关系模式的集合**==，即 $R$ 为第几范式就可以写成 $R \in \textrm{xNF}$ 。

对于各种范式之间的关系，有：
$$\textrm{5NF} \subset \textrm{4NF} \subset \textrm{BCNF} \subset \textrm{3NF} \subset \textrm{2NF} \subset \textrm{1NF}$$ 成立，如下图6.2所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/7f3edd8b1b3344bca934fc650ca15e0d.png)

==一个低一级范式的关系模式，通过模式分解 `schema decomposition` 可以转换为若干个高一级范式的关系模式的集合，这种过程就叫**规范化** `normalization`== 。
## 6.2.4 2NF
1NF很简单。关系模式作为一个二维表，只要符合一个最基本的条件——**每个分量必须是不可分的数据项**，就属于**第一范式** `1NF` 。

**定义6.6** 若 $R \in \textrm{1NF}$ ，且每一个**非主属性**完全函数依赖于任何一个**候选键**，则 $R \in \textrm{2NF}$ 。

下面先举一个不是 $\textrm{2NF}$ 的例子。
【例6.4】有关系模式 $SLC(Sno, Sdept, Sloc, Cno, Grade)$ ，其中 $Sloc$ 为学生的住处，并且每个系的学生住在同一个地方。$SLC$ 的键为 $(Sno, Cno)$ ，则函数依赖有：
$$\begin{aligned}
&(Sno, Cno) \stackrel{F} \to Grade \\
&Sno \to Sdept,\ (Sno, Cno) \stackrel {P} \to Sdept \\
&Sno \to Sloc,\ (Sno, Cno) \stackrel {P} \to Sloc \\
&Sdept \to Sloc
\end{aligned}
$$ 函数依赖关系如图6.3所示，用虚线表示部分函数依赖：
![在这里插入图片描述](https://img-blog.csdnimg.cn/b1c549e85dfc42e094c48e85546eb641.png)

另外，$Sdept$ 还能函数决定 $Sloc$ ，这一点在讨论第二范式时暂不考虑。可看到非主属性 $Sdept,\ Sloc$ 并不完全函数依赖于键，因此 $SLC(Sno, Sdept, Sloc, Cno, Grade)$ 不符合2NF定义，即 $SLC \notin \textrm{2NF}$ 。

==一个关系模式 $R$ 不属于 $\textrm{2NF}$ ，就会产生以下几个问题==：
（1）==插入异常==。假若要插入一个学生 $Sno = S7,\ Sdept = PHY,\ Sloc = BLD2$ ，但该生还未选课，即这个学生无 $Cno$ ，这一元组就插入进 $SLC$ 中。因为插入元组时必须给定键值，而此时键值的一部分为空，因而学生的**固有信息就无法插入**。
（2）==删除异常==。假定某个学生只选一门课，如 $S4$ 就选了一门课 $C3$ ，现在 $C3$ 这门课他也不选了，那么 $C3$ 这个数据项就要删除。而 $C3$ 是主属性，删除了 $C3$ ，整个元组就必须一起删除，使得 $S4$ 的其他信息也被删除了，从而造成删除异常，即**不应删除的信息也删除了**。
（3）==修改复杂==。某个学生从数学系 $MA$ 转到计算机科学系 $CS$ ，这本来只需修改此学生元组中的 $Sdept$ 分量即可，但因为关系模式 $SLC$ 中还含有系的住处 $Sloc$ 属性、学生转系将同时改变住处，因而还必须修改元组中的 $Sloc$ 分量。
此外，如果这个学生选修了 $k$ 门课程，则 $Sdept,\ Sloc$ 就重复存储了 $k$ 次，不仅存储冗余度大，而且必须无遗漏地修改 $k$ 个元组中的全部 $Sdept,\ Sloc$ 信息，造成修改的复杂化。

分析上面的例子可知，问题在于有两类非主属性，一类如 $Grade$ ，它是完全函数依赖于键的；另一类如 $Sdept,\ Sloc$ ，它们对键不是完全函数依赖。解决的方法是，==用投影分解把关系模式 $SLC$ 分解为两个关系模式：$SC(\underline{Sno, Cno}, Grade)$ 和 $SL(\underline{Sno}, Sdept, Sloc)$== 。关系模式 $SC,\ SL$ 属性间的函数依赖，可分别用图6.4、图6.5表示如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/66d5a9aac3994f07b0cf3aa1b8264a5b.png)
关系模式 $SC$ 的键为 $(Sno, Cno)$ ，关系模式 $SL$ 的键为 $Sno$ ，这样就使**非主属性**对**键**都是**完全函数依赖**了。
## 6.2.5 3NF
**定义6.7** 设关系模式 $R\langle U, F\rangle \in \textrm{1NF}$ ，若 $R$ 中不存在这样的**键** $X$ ，属性（组）$Y$ 及非主属性（组）$Z\ (Y \not \subseteq Z)$ ，使得 $X \to Y,\ Y \to Z$ 成立，$Y \not \to X$ ，则称 $R\langle U, F\rangle \in \textrm{3NF}$ 。

由定义6.7可证明，**若 $R \in \textrm{3NF}$ ，则每个非主属性既不传递依赖于键，也不部分依赖于键**。即，可以证明==如果 $R$ 属于 $\textrm{3NF}$ ，则必有 $R$ 属于 $2NF$== 。

在图6.4中关系模式 $SC$ 没有传递依赖，而图6.5中关系模式 $SL$ 存在非主属性对键的传递依赖——在 $SL$ 中，由 $Sno \to Sdept\ (Sdept \not \to Sno),\ Sdept \to Sloc$ ，可得 $Sno \stackrel {T}\to Sloc$ ，因此 $SC \in \textrm{ 3NF},\ SL \notin \textrm{3NF}$ 。

一个关系模式 $R$ 若不是 $\textrm{3NF}$ ，就会产生与6.2.4节中 $\textrm{2NF}$ 相类似的问题，可类比 $\textrm{2NF}$ 的反义加以说明。解决的办法同样是将 $SL$ 分解为：$SD(Sno, Sdept)$ 和 $DL(Sdept, Sloc)$ 。分解后的关系模式 $SD,\ DL$ 中不再存在传递依赖。
## 6.2.6 BCNF
`BCNF (Boyce Codd Normal Form)` 是由 `Boyce` 与 `Codd` 提出的，比上述的 $\textrm{3NF}$ 又进了一步，通常认为 $\textrm{BCNF}$  是修改的第三范式，有时也称为扩充的第三范式。

**定义6.8** ==关系模式 $R\langle U, F\rangle \in \textrm{1NF}$ ，若 $X \to Y$ 且 $Y\not \subseteq X$ 时 $X$ 必含有键，则 $R\langle U, F\rangle \in \textrm{BCNF}$== 。

也就是说，==关系模式 $R\langle U, F\rangle$ 中，若每个决定因素都包含键，则 $R\langle U, F\rangle \in \textrm{BCNF}$== 。更简单一点说，所有非平凡函数依赖的左部都必须包含候选键，即具有函数依赖集合 $F$ 的关系模式 $R$ 属于 $\textrm{BCNF}$  的条件是，==任何函数依赖 $X \to Y$ 都是非平凡函数依赖、且 $X$ 是 $R$ 的一个超键==。

由 $\textrm{BCNF}$  的定义可以得到结论，一个满足 $\textrm{BCNF}$  的关系模式有以下性质：
- 所有**非主属性**，对每个键都是**完全函数依赖**，既不**部分依赖于键**，也不**传递依赖于键**（即满足 $\textrm{3NF}$ ）;
- 所有**主属性**，对每个**不包含它的键**，也是**完全函数依赖**，既不部分依赖，也不传递依赖；
- 没有任何属性，完全函数依赖于非键的任何一组属性

由于 $R \in \textrm{BCNF}$ ，按定义**排除了任何属性对键的传递依赖及部分依赖**，所以 $R \in \textrm{3NF}$ 。只是若 $R \in \textrm{3NF}$ ，$R$ 未必属于 $\textrm{BCNF}$  。下面用几个例子说明，属于 $\textrm{3NF}$ 的关系模式有的属于 $\textrm{BCNF}$  ，有的不属于 $\textrm{BCNF}$  。

【例6.5】考察关系模式 $C(Cno, Cname, Pcno)$ ，它只有一个键 $Cno$ ，这里没有任何属性对 $Cno$ 部分或传递依赖，所以 $C \in \textrm{3NF}$ ，同时 $C$ 中 $Cno$ 也是唯一的决定因素，所以 $C \in \textrm{BCNF}$ 。对于关系模式 $SC(Sno, Cno, Grade)$ 可做同样分析。

【例6.6】关系模式 $S(Sno, Sname, Sdept, Sage)$ ，假定 $Sname$ 具有唯一性，那么 $S$ 就有两个键，这两个键都由单个属性组成，彼此不相交，其他属性不存在对键的传递依赖与部分依赖，所以 $S \in \textrm{3NF}$ 。同时 $S$ 中除 $Sno, Sname$ 外没有其他决定因素，所以 $S$ 也属于 $\textrm{BCNF}$  。

下面再举几个例子。

【例6.7】关系模式 $SJP(S, J, P)$ 中，$S$ 是学生、$J$ 表示课程、$P$ 表示名次。每个学生选修每门课程的成绩有一定的名次，每门课程中每一名次只有一名学生（即没有并列名次）。由语义可得下面的函数依赖：
$$(S, J) \to P;\ (J, P) \to S$$ 所以 $(S, J)$ 和 $(J, P)$ 都可作为候选键，这两个键各由两个属性组成，而且它们是相交的。这一关系模式中，显然没有属性对键传递依赖或部分依赖。所以 $SJP \in \textrm{3NF}$ ，而且除 $(S, J)$ 与 $(J, P)$ 以外没有其他决定因素，所以 $SJP \in \textrm{BCNF}$ 。

【例6.8】关系模式 $STJ(S, T, J)$ 中，$S$ 是学生、$T$ 是教师、$J$ 是课程。每一教师只教一门课，每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。由语义可得到如下的函数依赖。
$$(S, J) \to T; \ (S, T) \to J;\ T \to J$$ 函数依赖关系如下图所示，这里 $(S, J),\ (S, T)$ 都是候选键：
![在这里插入图片描述](https://img-blog.csdnimg.cn/90c34dc8344b4641bf217e9719f223f2.png)

显然，$STJ$ 是 $\textrm{3NF}$ ，因为没有任何非主属性对键传递依赖或部分依赖，但 $STJ$ 不是 $\textrm{BCNF}$ 关系，因为 $T$ 是决定因素，而 $T$ 不包含键。


==对于不是 $\textrm{BCNF}$ 的关系模式，仍然存在不合适的地方==，可自己举例指出 $STJ$ 的不合适之处。非 $\textrm{BCNF}$ 的关系模式，也可以通过分解成为 $\textrm{BCNF}$ 。例如 $STJ$ 可分解为 $ST(S, T)$ 与 $TJ(T,J)$ ，它们都是 $\textrm{BCNF}$ 。

$\textrm{3NF}$ 和 $\textrm{BCNF}$  是在函数依赖的条件下，对模式分解所能达到的分离程度的测度。==一个模式中的关系模式如果都属于 $\textrm{BCNF}$  ，那么在函数依赖范畴内，它已实现了彻底的分离，已消除了插入和删除的异常==。$\textrm{3NF}$ 的不彻底性，表现在「**可能存在主属性对键的部分依赖和传递依赖**」上。
## 6.2.7 多值依赖
以上完全是在函数依赖的范畴内讨论问题。属于 $\textrm{BCNF}$  的关系模式是否就很完美了呢？下面来看一个例子。

【例6.9】学校中某一门课程由多个教师讲授，他们使用相同的**一套**参考书。每个教师可以讲授多门课程，**每种**参考书可以供多门课程使用。可用一个非规范化的关系来表示教师 $T$ 、课程 $C$ 、参考书 $B$ 之间的关系，如表6.3所示。把这张表变成一张规范化的二维表，如表6.4所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/9a028a4ac8924e47831c187519956ba9.png)
关系模型 $Teaching(C, T, B)$ 的键是 $(C, T, B)$ ，即**全键** `all-key` ，因而 $Teaching \in \textrm{BCNF}$ 。但是当某一课程（如物理）增加一名讲课教师（如周英）时，必须插入多个（这里是三个）元组——`(物理, 周英, 普通物理学), (物理, 周英, 光学原理), (物理, 周英, 物理习题集)` 。

同样，某一门课（如数学）要去掉一本参考书（如微分方程），则必须删除多个（这里是两个）元组——`(数学, 李勇, 微分方程), (数学, 张平, 微分方程)` 。

因而，对数据的增删改很不方便，数据的冗余十分明显！！！仔细考察这类关系模式，发现它具有一种称为**多值依赖** `Multi-Valued Dependency, MVD` 的数据依赖。

**定义6.9** 设 $R(U)$ 是属性集 $U$ 上的一个关系模式，$X, Y, Z$ 是 $U$ 的子集，并且 $Z = U - X - Y$ 。关系模式 $R(U)$ 中**多值依赖** $X \to \to Y$ 成立，当且仅当对 $R(U)$ 的任一关系 $r$ ，给定了一对 $(x, z)$ 值，就有一组 $Y$ 的值，这组值仅仅决定于 $x$ 值而与 $z$ 值无关。

例如，在关系模式 $Teaching$ 中，对于一个 `(物理, 光学原理)` 有一组 $T$ 值 `{李勇, 王军}` ，这组值仅仅取决于课程 $C$ 上的值 `(物理)` 。也就是说，对于另一个 `(物理, 普通物理学)` ，它对应的一组 $T$ 值仍是 `{李勇, 王军}` ，尽管这时参考书 $B$ 的值已经改变了。因此 $T$ 多只依赖于 $C$ ，即 $C \to \to T$ 。

对于多值依赖的另一个等价的形式化定义是：==在 $R(U)$ 的任一关系 $r$ 中，如果存在元组 $t, s$ 使得 $t[X] = s[X]$ ，那么就必然存在元组 $w, v \in r$（$w, v$ 可与 $s, t$ 相同），使得 $w[X] = v[X] = t[X]$ ，而 $w[Y] = t[Y],\ w[Z] = s[Z],\ v[Y] = s[Y],\ v[Z] = t[Z]$（即交换 $s, t$ 元组的 $Y$ 值所得的两个新元组，必定在 $r$ 中），则 $Y$ 多值依赖于 $X$== ，记为 $X \to \to Y$ 。这里，$X, Y$ 是 $U$ 的子集，$Z = U - X - Y$ 。（？）

若 $X \to \to Y$ ，而 $Z = \varnothing$ ，则称 $X \to \to Y$ 为**平凡的多值依赖**。即对于 $R(X, Y)$ ，如果有 $X \to \to Y$ 成立，则 $X \to \to Y$ 为平凡的多值依赖。

下面再举一个具有多值依赖的关系模式的例子。
【例6.10】关系模式 $WSC(W, S, C)$ 中，$W$ 表示仓库、$S$ 表示保管员、$C$ 表示商品。假设每个仓库有若干个保管员、有若干种商品。每个保管员保管所在仓库的所有商品，每种商品被所有保管员保管。列出关系如表6.5所示。

按照语义对于 $W$ 的每一个值 $W_i$ ，$S$ 有一个完整的集合与之对应、而不论 $C$ 取何值。所以 $W \to \to S$ 。

如果用图6.7来表示这种对应，则对于 $W$ 的某一个值 $W_i$ 的全部 $S$ 值记作 $\{ S \}_{wi}$（表示在此仓库工作的全部保管员），全部 $C$ 值记作 $\{ C\}_{wi}$（表示在此仓库存放的所有商品）。应当有 $\{ S\}_{wi}$ 的每一个值和 $\{ C\}_{wi}$ 中的每一个 $C$ 值对应。于是

## 6.2.8 4NF
可用**投影分解**的方法，消去**非平凡**且**非函数依赖**的**多值依赖**，例如可把 $WSC$ 分解为 $WS(W, S),\ WC(W, C)$ 。在 $WS$ 中虽然有 $W \to \to S$ ，但这是平凡的多值依赖。$WS$ 中已不存在非平凡、非函数依赖的多值依赖，所以 $WS \in 4NF$ ，同理 $WC \in 4NF$ 。

**函数依赖和多值依赖，是两种最重要的数据依赖**。如果只考虑函数依赖，则属于 $\textrm{BCNF}$  的关系模式规范化程度，已经是最高的了；如果考虑多值依赖，则属于 $4NF$ 的关系模式规范化程度，才是最高的。事实上，数据依赖中除函数依赖和多值依赖之外，还有其他数据依赖。

例如有一种连接依赖，==函数依赖是多值依赖的一种特殊情况，而多值依赖实际上又是连接依赖的一种特殊情况==，但连接依赖不像函数依赖和多值依赖可由语义直接导出，而是在关系的连接运算时才反映出来。存在连接依赖的关系模式，仍可能遇到数据冗余及插入、修改、删除异常等问题。如果消除了属于 $4NF$ 的关系模式中存在的连接依赖，则可进一步达到 $5NF$ 的关系模式。这里不再讨论连接依赖和 $5NF$ ，有兴趣的读者可参阅有关书籍。
## 6.2.9 规范化小结
在关系数据库中，对关系模式的基本要求是满足第一范式，这样的关系模式就是合法的、允许的。但是，人们发现有些关系模式存在插入、删除异常，以及修改复杂、数据冗余等问题，需要寻求解决这些问题的方法，这就是**规范化的目的**。

==规范化的基本思想，是逐步消除数据依赖中不合适的部分==，使模式中的各关系模式达到某种程度的分离，即 ==「一事一地」的模式设计原则==。让一个关系描述一个概念、一个实体或者实体间的一种联系。若多于一个概念，就把它分离出去。因此，所谓==规范化实质上就是概念的**单一化**==。

人们认识这个原则是经历了一个过程的，从认识非主属性的部分函数依赖的危害开始，$2NF,\ 3NF,\ BCNF,\ 4NF$ 的相继提出，是这个认识过程逐步深化的标志。图6.8可以概括这个过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/e1d50dff331b4762a369d8b09ec517b0.png)
==关系模式的规范化过程，就是通过对关系模式的分解来实现的，即把低一级的关系模式分解为若干个高一级的关系模式==。**这种分解不是唯一的**。下面将进一步讨论分解后的关系模式与原关系模式「等价」的问题，以及分解的算法。

---
# 6.3 数据依赖的公理系统
==数据依赖的公理系统，是模式分解算法的理论基础==。下面首先讨论函数依赖的一个有效而完备的公理系统——Armstrong公理系统。

**定义6.11** 对于满足一组函数依赖 $F$ 的关系模式 $R\langle U, F\rangle$ ，==其任何一个关系 $r$ ，若函数依赖 $X \to Y$ 都成立==（即 $r$ 中任意两元组 $t, s$ ，若 $t[X] = s[X]$ ，则 $t[Y] = s[Y]$ ，即两元组在 $X$ 属性上的值相等，就一定有两元组在 $Y$ 属性上的值相等），==则称 $F$ **逻辑蕴涵** $X \to Y$== 。

为了**求得给定关系模式的键**，为了**从一组函数依赖求得蕴涵的函数依赖**，例如已知函数依赖集合 $F$ ，要问 $X \to Y$ 是否为 $F$ 所蕴涵，就需要一套推理规则。下面这组推理规则是1974年首先由 `Armstrong` 提出来的。

**Armstrong公理系统** `Armstrong's axiom` 设 $U$ 为属性集总体，$F$ 是 $U$ 上的一组函数依赖，于是有关系模式 $R\langle U, F\rangle$ ，对 $R\langle U, F\rangle$ 来说有以下的推理规则：
- A1 **自反律**  `reflexivity rule` ：若 $Y \subseteq X\subseteq U$ ，则 $X \to Y$ 为 $F$ 所蕴涵；
- A2 **增广律** `augmentation rule` ：若 $X \to Y$ 为 $F$ 所蕴涵，且 $Z \subseteq U$ ，则 $XZ \to YZ$ 为 $F$ 所蕴涵（此处的 $XZ$ 代表 $X \cup Z$ ，$YZ$ 代表 $Y \cup Z$）
- A3 **传递律** `transitivity rule` ：若 $X \to Y$ 及 $Y \to Z$ 为 $F$ 所蕴涵，则 $X \to Z$ 为 $F$ 所蕴涵。

注意，==由自反律所得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于 $F$== 。

**定理6.1** Armstrong推理规则是正确的。
**证明** 下面从定义出发，证明推理规则的正确性。
（1）
（2）
（3）

根据A1、A2、A3这三条推理规则，可得到下面三条很有用的推理规则：
- **合并规则** `union rule` ：由 $X\to Y,\ X \to Z$ ，则 $X \to YZ$ ；
- **伪传递规则** `pseudo transitivity rule` ：由 $X \to Y,\ WY\to Z,$ ，有 $XW \to Z$ ；
- **分解规则** `decomposition rule` ：由 $X\to Y$ 及 $Z \subseteq Y$ ，有 $X \to Z$ 。

根据合并规则和分解规则，很容易得到这样一个重要事实：
**引理6.1** $X \to A_1 A_2 \dots A_k$ 成立，当且仅当 $X \to A_i$ 成立（$i = 1, 2, \dots, k$）。
**定义6.12** 在关系模式 $R\langle U, F\rangle$ 中为 $F$ 所逻辑蕴涵的函数依赖的全体，叫做 $F$ 的**闭包** `closure` ，记为 $F^+$ 。

人们把**自反律、增广律、传递律**称为**Armstrong**公理系统。==Armstrong公理系统是有效的、完备的==。Armstrong公理的 ==**有效性** 指的是==：由 $F$ 出发，根据Armstrong公理推导出来的每个函数依赖，一定在 $F^+$ 中；==**完备性**指的是==：$F^+$ 中的每个函数依赖，必定可以由 $F$ 出发根据Armstrong公理推导出来。

---
# 6.4 模式的分解**
## 6.4.1 模式分解的三个定义
## 6.4.2 分解的无损连接性和保持函数依赖性
## 6.4.3 模式分解的算法
 
[【数据库基础】学习笔记4 函数依赖、关系模式的规范化](https://editor.csdn.net/md/?articleId=105618098)
