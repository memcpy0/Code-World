 

P类
NP类
NP完全问题
co-NP类
NPI类

# 一、引言
设 $\prod$ 是任意问题，如果对问题 $\prod$ 存在一个算法，它的时间复杂性是 $O(nk)$ ，其中 $n$ 是输入大小，$k$ 是非负整数，我们说存在着求解问题 $n$ 的多项式时间算法。这类算法在可以接受的时间内实现问题求解， $e.g.$ 排序、串匹配、矩阵相乘。

但是，现实世界中的许多有趣问题并不属于这个范畴，因为求解这些问题所需要的时间量要用指数和超指数函数(如 $2^n$ 和 $n!$ ）来测度。随着问题规模的增长而快速增长。

在计算机科学界已达成这样的共识，认为**存在多项式时间算法的问题是易求解的，而对于那些不大可能存在多项式时间算法的问题是难解的**。 把**多项式时间复杂度**作为**易解问题与难解问题的分界线**，主要原因有：
- 多项式函数与指数函数的增长率有本质差别。
<img src="https://img-blog.csdnimg.cn/20200316205656738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
- 计算机性能的提高对易解问题与难解问题算法的影响
    假设求解同一个问题有 $5$ 个算法 $A_1$ ~ $A_5$，时间复杂度 $T(n)$ 如下表，假定计算机 $C_2$ 的速度是计算机 $C_1$ 的 $10$ 倍。下表给出了**在相同时间内**不同算法能处理的问题规模情况： 
<img src="https://img-blog.csdnimg.cn/20200316205721290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
- 多项式时间复杂性，忽略系数，不影响易解问题与难解问题的划分：
<img src="https://img-blog.csdnimg.cn/20200316210130200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">

**难解问题** 
这一类含有许许多多问题，其中还包含了数百个著名的问题，==它们有一个共同的特性，即如果它们中的一个是多项式可解的，那么所有其他的问题也是多项式可解的==。

此外，现存的求解这些问题的算法的运行时间，对于中等大小的输入也要用几百或几千年来测度。

##  判定问题和最优化问题 
- 判定问题：
在研究NP完全性理论时，我们很容易重述一个问题使它的解只有两个结论：yes或no，在这种情况下，称问题为判定问题。
- 最优化问题： 
与此相对照，最优化问题是关心某个量的最大化或最小化的问题。在前面的章节中，已经遇到过大量的最优化问题，像找出一张表中的最大或最小元素的问题，在有向图中寻找最短路径间题和计算一个无向图的最小生成树的问题。

 如果我们有一个**求解判定问题的有效算法**，那么很容易**把它变成求解与它相对应的最优化问题的算法**。 反之亦然。

例子1 
设 $S$ 是一个实数序列， `ELEMENT UNIQUENESS`问题为，是否 $S$ 中的所有的数都是不同的。
判定问题：`ELEMENT UNIQUENESS`；
输入：一个整数序列 $S$
问题：在 $S$ 中存在两个相等的元素吗?
最优问题：`ELEMENT COUNT`
输入：一个整数序列 $S$
输出：一个在 $S$ 中频度最高的元素。


这个问题可以用**显而易见的方法**在最优的时间 $O(nlogn)$ 解决，这意味着它是易解的。

例子2 COLORING问题（图着色问题）

给出一个无向图 `G = (V, E)` ，用 $k$ 种颜色对 $G$ 着色是这样的问题：对于 $V$ 中的每一个顶点用 $k$ 种颜色中的一种对它着色，使图中**没有两个邻接顶点有相同的颜色**。**这个问题是难解的**。

输入:  (着色数)k， (节点数)5，(图的边) (1,2)(1,4)... 

写出长度为n(节点数)的字符串，例如，RGRBG，RGRB，RBYGO，RGRBY，R%*$@等，至少有 $k^n$个不同着色情况。

找到符合要求（任何两个邻接顶点颜色不同）的最小的k值
<img src="https://img-blog.csdnimg.cn/20200316211004333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="20%">

判定问题： COLORING
     输入：一个无向图G = (V, E)和一个正整数k 1。
     问题：G可以k着色吗?即G最少可以用k种颜色着色吗?

这个问题的一个最优形式是，对一个图着色，使图中没有两个邻接的顶点有相同的颜色，所需要的最少颜色数是多少?这个数记为χ(G)，称为G的色数。

最优化问题： CHROMATIC NUMBER
输入：一个无向图G=(V,E)。
输出： G的色数。

四色猜想
  地图四色定理(Four color theorem)最先是由一位叫古德里（Francis Guthrie）的英国大学生提出来的。      四色问题的内容是：“任何一张地图只用四种颜色就能使具有共同边界的国家着上不同的颜色。”
<img src="https://img-blog.csdnimg.cn/20200316211046143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%"> 1852年，刚从伦敦大学毕业的Francis Guthrie提出了四色猜想。
1878年著名的英国数学家Cayley向数学界征求解答。
此后数学家 Heawood 花费了毕生的精力致力于四色研究，于1890年证明了五色定理（每个平面图都是5顶点可着色的）。
直到1976年6月，美国数学家 K. Appel与 W. Haken，在3台不同的电子计算机上，用了1200小时，作了100亿判断，才终于完成了“四色猜想”的计算机证明。 

例子 10.3
	给出一个无向图G=(V,E)，对于某个正整数k, G中大小为k的团集，是指G中有k个顶点的一个完全子图。团集问题是问一个无向图是否包含一个预定大小的团集。
判定问题: CLIQUE.
输入:一个无向图G=(V,E)和一个正整数k。
问题: G有大小为k的团集吗? 
最优化问题: MAX-CLIQUE.
输入：一个无向图G=(V,E).
输出:一个正整数k，它是G中最大团集的大小

如果我们有一个求解判定问题的有效算法，那么很容易把它变成求解与它相对应的最优化问题的算法。

例如，我们有一个求解图着色判定问题的算法A，则可以用二分搜索并且把算法A作为子程序来找出图G的色数。很清楚，1<=x (G)<=n，这里n是G中顶点数，因此仅用O(1og n)次调用算法A就可以找到G的色数。由于我们正处理多项式时间的算法， log n因子是不重要的。

因为这个理由，在NP完全问题的研究中，甚至在一般意义上的计算复杂性或可计算性的研究中，把注意力限制在判定问题上会比较容易一些

如果我们有一个求解判定问题的有效算法，那么很容易把它变成求解与它相对应的最优化问题的算法。

例如，我们有一个求解图着色判定问题的算法A，则可以用二分搜索并且把算法A作为子程序来找出图G的色数。很清楚，1<=x (G)<=n，这里n是G中顶点数，因此仅用O(1og n)次调用算法A就可以找到G的色数。由于我们正处理多项式时间的算法， log n因子是不重要的。

因为这个理由，在NP完全问题的研究中，甚至在一般意义上的计算复杂性或可计算性的研究中，把注意力限制在判定问题上会比较容易一些

 因此，易解问题和难解问题的划分标准可基于对所谓判定问题的求解方式。
   事实上，实际应用中的大部分问题问题可以很容易转化为相应的判定问题，如： 
排序问题  给定一个实数数组，是否可以按非降序排列?
图着色问题：给定无向连通图G=(V,E)，求最小色数k，使得任意相邻顶点具有不同的着色  
      给定无向连通图G=(V,E)和正整数k，是否可以用k种颜色..... ?

---
# 11.2 P类
## 1. 定义
 定义 10.1  确定性算法
设A是求解问题∏的一个算法，如果在展示问题∏的一个实例时，在整个执行过程中，每一步都只有一种选择，则称A是确定性算法。因此如果对于同样的输入，实例一遍又一遍地执行，它的输出从不改变。
特点：对同一输入实例，运行算法A，所得结果是一样的。

定义 10.2  P类问题
判定问题的P类由这样的判定问题组成，它们的yes/no解可以用确定性算法在运行多项式步数内，例如在O(nk)步内得到，其中k是某个非负整数，n是输入大小。
也就是说：如果对于某个判定问题∏，存在一个非负整数k，对于输入规模为n的实例，能够以O(nk)的时间运行一个确定性算法，得到yes或no的答案，则称该判定问题∏是一个P(Polynomial)类问题。（Polynomial多项式）
事实上，所有易解问题都是P类问题。
##  2. P类的问题
排序问题：
给出一个n个整数的表，它们是否按非降序排列? 
不相交集问题：
给出两个整数集合，它们的交集是否为空?
最短路径问题：
给出一个边上有正权的有向图G = (V, E) ，两个特异的顶点s, t ∈ V和一个正整数k，在s到t间是否存在一条路径，它的长度最多是k。

2着色问题:
给出一个无向图G ，它是否是2可着色的?即它的顶点是否可仅用两种颜色着色，使两个邻接顶点不会分配相同的颜色?注意，当且仅当G是二分图，即当且仅当它不包含奇数长的回路时，它是2可着色的。 
<img src="https://img-blog.csdnimg.cn/20200316211718403.png" width = "20%"></img>


2可满足问题: 
给出一个合取范式(CNF)形式的布尔表达式f，这里每个子句恰好由两个文字组成，问f是可满足的吗？

如果对于任意问题C， ∏的补也在C中，我们说问题类∏ ∈ C在补运算下是封闭的。
例如，2着色问题的补可以陈述如下:给出一个图G ，它是不2可着色的吗?我们称这个问题为NOT-2-COLOR问题。它是属于P的。


 定理 10.1 
P类问题在补运算下是封闭的。

# 11.3 NP类
NP类由这样的问题∏组成，对于这些问题存在一个确定性算法A，该算法在对∏的一个实例展示一个断言解时，它能在多项式时间内验证解的正确性。即如果断言解导致答案是yes，就存在一种方法可以在多项式时间内验证这个解。

不确定性算法

对于输入x ，一个不确定性算法由下列两个阶段组成:

猜测阶段

验证阶段

p177
猜测阶段 
在这个阶段产生一个任意字符串y，它可能对应于输入实例的一个解，也可以不对应解。

事实上，它甚至可能不是所求解的合适形式，它可能在不确定性算法的不同次运行中不同。它仅仅要求在多项式步数内产生这个串，即在O(ni)时间内，这里n=|x| ，i是非负整数。对于许多问题，这一阶段可以在线性时间内完成。

在这个阶段，一个不确定性算法验证两件事
首先，它检查产生的解串y是否有合适的形式，
如果不是，则算法停下并回答no; 
另一方面，如果y是合适形式，那么算法继续检查它是否是问题实例x的解，如果它确实是实例x的解，那么它停下并且回答yes，否则它停下并回答no。

我们也要求这个阶段在多项式步数内完成，即在O(nj)时间内，这里j是一个非负整数。

设A是问题∏的一个不确定性算法，我们说A接受问题∏的实例I，当且仅当对于输入I存在一个导致yes回答的猜测。换句话说，A接受I当且仅当可能在算法的某次执行上它的验证阶段将回答yes。

要强调的是，如果算法回答no，那么这并不意味着A不接受它的输人，因为算法可能猜测了一个不正确解。

不确定性算法与NP类问题
定义(不确定性算法):设A是求解问题∏的一个算法，如果算法A以如下猜测+验证的方式工作，称算法A为不确定性(nondeterminism)算法：
猜测阶段：对问题的输入实例产生一个任意字串y，在算法的每次运行，y可能不同，因此猜测是以不确定的形式工作。这个工作一般可以在线性时间内完成。
验证阶段：在这个阶段，用一个确定性算法验证两件事：首先验证猜测的y是否是合适的形式，若不是，则算法停下并回答no；若是合适形式，则继续检查它是否是问题x的解，如果确实是x的解，则停下并回答yes，否则停下并回答no。要求验证阶段在多项式时间内完成。 
注意对不确定性算法输出yes/no的理解：
若输出no，并不意味着不存在一个满足要求的解，因为猜测可能不正确；若输出yes，则意味着对于该判定问题的某一输入实例，至少存在一个满足要求的解。

不确定的算法:伪代码
Void nondetA(String input)
     String s=genCertif();
     boolean checkOK=verifyA(input,s)
     if (checkOK)
         Output “yes“
     return
checOK为false时不作反应.

NP类问题
至于一个(不确定性)算法的运行时间，它仅仅是两个运行时间的和：一个是猜测阶段的时间，另一个是验证阶段的时间。因此它是O(ni)+O(nj)=O(nk)  ， k是某个非负整数。

定义 10.3 

判定问题类NP由这样的判定问题组成:对于它们存在着多项式时间内运行的不确定性算法。

定义(NP类问题): 如果对于判定问题∏，存在一个非负整数k，对于输入规模为n的实例，能够以O(nk)的时间运行一个不确定性算法，得到yes/no的答案，则该判断问题∏是一个NP(nondeterministic polynomial)类问题。

   ※注意：NP类问题是对于判定问题定义的，事实上，可以在多项式时间内应用非确定性算法解决的所有问题都属于NP类问题。  

例子（图着色问题）
Input:  (着色数)k, (节点数)5 ,(图的边) (1,2)(1,4)... 
Guessing 指写出长度为n(节点数)的字符串,例如,RGRBG, RGRB, RBYGO, RGRBY, R%*$@等.至少有kn个“guessings”。
Checking 指检查一guessed字符串是否合法及是否是一个k-着色。
如果写字符串的时间是O(p1(n)),checking时间是O(p2(n));而且p1(n), p2(n)是n的多项式(从而也是输入长度的多项式),则该不确定算法有多项式时间。
如果输入的图能k着色则不确定算法停机并给出yes回答。

考虑问题COLORING，我们用两种方法证明这个问题属于NP类。
方法1:
设I是COLORING问题的一个实例， s被宣称为I的解。
容易建立一个确定性算法来验证，是否确实是I的解。
从NP类的非形式定义可得COLORING问题属于NP类。

方法 2
建立不确定性算法
当图G用编码表示后，一个算法A可以很容易地构建并运作如下
首先通过对顶点集合产生一个任意的颜色指派以“猜测”一个解First。
接着，A验证这个指派是否是有效的指派，如果它是一个有效的指派，那么A停下并且回答yes，否则它停下并回答no。
请注意，根据不确定性算法的定义，仅当对问题的实例回答是yes时，A回答yes。
其次是关于需要的运行时间，A在猜测和验证两个阶段总共花费不多于多项式时间。

关于P与NP关系的初步思考       --从字面含义
1) 若问题∏属于P类，则存在一个多项式时间的确定性算法，对它进行判定或求解；显然，也可以构造一个多项式时间的非确定性算法，来验证解的正确性，因此，问题也属NP类。因此，显然有
    P $\in$ NP
2) 若问题∏属于NP类，则存在一个多项式时间的非确定性算法，来猜测并验证它的解；但不一定能构造一个多项式时间的确定性算法，来对它进行求解或判定。
  因此，人们猜测P ≠ NP，但是否成立，至今未得到证明。
P=NP?是计算机科学中最大的问题之一

世界七大数学难题----NP完全问题
例1：
在一个周六的晚上，你参加了一个盛大的晚会。由于感到局促不安，你想知道这一大厅中是否有你已经认识的人。宴会的主人向你提议说，你一定认识那位正在甜点盘附近角落的女士罗丝。不费一秒钟，你就能向那里扫视，并且发现宴会的主人是正确的。然而，如果没有这样的暗示，你就必须环顾整个大厅，一个个地审视每一个人，看是否有你认识的人。

例2：
如果某人告诉你，数13717421可以写成两个较小的数的乘积，你可能不知道是否应该相信他，但是如果他告诉你它可以分解为3607乘上3803，那么你就可以用一个袖珍计算器容易验证这是对的。


生成问题的一个解通常比验证一个给定的解时间花费要多得多。

NP=P？的猜想
人们发现，所有的完全**多项式非确定性**问题，都可以转换为一类叫做**满足性问题**的逻辑运算问题。既然这类问题的所有可能答案，都可以在多项式时间内计算，人们于是就猜想，是否这类问题，存在一个确定性算法，可以在多项式时间内，直接算出或是搜寻出正确的答案呢？这就是著名的NP=P？的猜想。
不管我们编写程序是否灵巧，判定一个答案是可以很快利用内部知识来验证，还是没有这样的提示，而需要花费大量时间来求解，被看作逻辑和计算机科学中最突出的问题之一。它是斯蒂文·考克于1971年陈述的。

---
# 四、NP完全问题
`NP完全` 表示**NP判定问题**的一个子类，它们在下述意义上是**最难**的，即==如果它们中的一个被证明用多项式时间确定性算法可解，那么NP中的所有问题用多项式时间确定性算法可解==，即NP=P。从这个角度来看，NP完全问题是NP类问题的一个具有特殊性质与特殊意义的子类。 

## 1. 归约(Reduction)
人们普遍认为，`P=NP` 不成立  $\Rightarrow$    多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。

`Reduction` ("归约"或"约化")：一个问题 $A$ 可以归约为问题 $B$ 的含义即是，可以用解决问题 $B$ 的解法来解决问题 $A$ ，或者说，问题 $A$ 可以"变成"问题 $B$ 。 

如：一元一次方程可以归约为一元二次方程。求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以归约为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个规则，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。**这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0**。按照这个规则把前一个问题转换成后一个问题，两个问题就**等价**了。

问题 $A$ 可归约为问题 $B$ 的直观意义：$B$ 的时间复杂度**高于或者等于** $A$ 的时间复杂度。也就是说，问题 $A$ 不比问题 $B$ 难。
 
很显然，归约具有一项重要的性质：**归约具有传递性**。如果问题 $A$ 可约化为问题 $B$ ，问题 $B$ 可约化为问题 $C$ ，则问题 $A$ 一定可约化为问题 $C$ 。 

相关定义如下：
定义(归约)：设 $\prod$ 和 $\prod'$ 是两个**判定问题**，如果存在一个**确定性算法** $A$，它的行为如下：当给 $A$ 展示问题 $\prod$ 的一个实例 $I$ ，算法 $A$ 可以把它变换为问题 $\prod'$ 的实例 $I'$，使得当且仅当对 $I'$ 回答 `yes` 时，对 $I$ 也可以回答 `yes`。而且，这个变换必须在多项式时间内完成。那么我们说 $\prod$ 多项式时间归约到 $\prod'$ ，用符号 $\prod \propto_{poly} \prod'$ 表示。
 

## 2. NP完全问题 
NP完全问题是一类**具备如下特殊性质**的NP类问题：
- $∏$（该问题本身）就是一个NP类问题；
- 每一个NP类问题都可以通过**多项式时间归约**到 $∏$ 。
<img src="https://img-blog.csdnimg.cn/20200316212617323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="28%"> 

定义(NP完全问题)：令 $∏$ 是一个**判定问题**，如果问题 $∏$ 属于NP类问题，并且对NP类问题中的每一个问题 $∏'$，都有 $∏' \propto_{poly} ∏$ ，则称判定问题 $∏$ 是一个NP完全问题(`NP complete problem，NPC`)。

对NP完全问题的评述：NP完全问题是**NP类问题中最难的一类问题**，至今已经发现了几千个，但一个也没有找到多项式时间算法。如果某一个NP完全问题能在多项式时间内解决，则每一个NP完全问题都能在多项式时间内解决。

这些问题也许存在多项式时间算法，因为计算机科学是相对新生的科学，肯定还有新的算法设计技术有待发现；这些问题也许不存在多项式时间算法，但目前缺乏足够的依据来证明这一点。

P类问题、NP类问题、NP完全问题的关系：
<img src="https://img-blog.csdnimg.cn/20200316212745590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="27%">

## 3. NP困难问题
### (1) 定义
难解问题中还有一类问题，虽然也能证明所有的NP类问题**可以在多项式时间内变换到问题** $∏$ ，但并**不能证明 $∏$ 也是NP类问题**，所以不知道 $∏$ 是NP完全的。但问题 $∏$ **至少与任意NP类问题有同样的难度**，这样的问题称为NP困难问题。 

<img src="https://img-blog.csdnimg.cn/20200316212920522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="33%">

定义(NP困难问题)： 如果对于NP中的每一个问题 $\prod'$ ， 存在 $\prod' \propto_{poly} \prod$，则称判定问题 $\prod$ 称为是NP困难的。

`NP-困难` 与 `NP-完全`：
NP完全问题$\prod$和NP困难问题$\prod$’间的差别是：$\prod$必须是NP类的而$\prod$’可能不在NP中。

### (2) 可满足性问题
可满足性问题即合取范式的可满足性问题，来源于许多实际的逻辑推理的应用。合取范式形如 $A1 \wedge A2 \wedge ... \wedge An$，其中子句 $A_i (1 \leq i \leq n)$ 形如：$a_1 \vee a_2 ...\vee a_k$，其中 $a_j$ 称为文字，为**布尔变量**或**它的否定**。一个子句是文字的**析取**。

`SAT` 问题是指：是否**存在**一组对所有布尔变量的赋值，使得整个合取范式为真? 例如
$$f = (x_1 \vee x_2)  \wedge (\overline x_1 \vee x_3 \vee x_4 \vee \overline x_5) \wedge (x_1 \vee \overline x_3 \vee x_4)$$
当 $x_1$ 和 $x_3$ 都为真、其余文字任意赋值时，$f$ 值为真。

判定问题：`SATISFIABILITY`；
输入：一个合取范式的布尔公式 $f$；
问题：$f$ 是可满足的吗？

定理：可满足性问题是NP完全的

实际上，可满足性问题被证明是NP完全的第一个问题。

可满足性(`Satisfiability`)问题又叫布林可满足性问题(`Boolean satisfiability problem`；简写`SAT`)属于**判定问题**，它是历史上第一个被证明的NP完全问题。

1971年，美国的Cook证明了Cook定理：布尔表达式的可满足性(SAT)问题是NP完全的。 
为了证明SATISFIABILITY是NP完全的，必须证明对NP中的任意问题$\prod$，有$\prod$ ∝poly SATISFIABILITY。假设 $\prod$ 的实例I的规模是n，在p(n)的判定时间里最多有cp(n)个动作，因此可以用cp(n)时间时间构造布尔表达式f，也就是说$\prod$ ∝poly SATISFIABILITY
这就是著名的Cook定理。

直观描述

对于一个确定的逻辑电路，是否存在一种输入使得输出为true，是第一个被证明的NPC问题。其它的NPC问题都是由这个问题约化而来的。
我们知道，一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成，如下图： 
<img src="https://img-blog.csdnimg.cn/20200316234806322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。

有输出无论如何都不可能为True的逻辑电路吗？ 
<img src="https://img-blog.csdnimg.cn/20200316234821800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">这个逻辑电路中，无论输入是什么，输出都是False。因此，这个逻辑电路不存在使输出为True的一组输入。

NP完全问题（补充）

逻辑电路问题(可满足性问题)属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它。

约化证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。

第一个NP完全问题（Cook定理   1971）
可满足性问题是NP完全问题
1972年，Karp证明了十几个问题都是NP完全的。
3SAT，3DM，VC，团，HC，划分
更多的NP完全问题
1979年：300多个
1998年：2000多个

这些NP完全问题的证明思想和技巧，以及利用他们证明的几千个NP完全问题，极大地丰富了NP完全理论。

定理 10.3 （归约关系的传递性）
设$\prod$，$\prod$’和$\prod$”是三个判定问题，有$\prod$ ∝poly $\prod$’和$\prod$’ ∝poly $\prod$”，那么$\prod$ ∝poly$\prod$ ”

P179
推论10.1（NP完全性的传递性）
如果$\prod$和$\prod$’是NP中的两个问题，若有$\prod$’ $\propto$ poly $\prod$ ，并且$\prod$’是NP完全的，则$\prod$是NP完全的。

根据上面的推论，为了证明一个问题∏是NP完全的，仅需要证明以下两个条件同时成立

(1) $\prod \in$ NP；
(2)存在着一个NP完全问题$\prod'$，使$\prod' \propto _{poly}\prod$。


例子10.5 p179

NP完全性的传递性举例
已知哈密顿回路问题是一个NP完全问题，证明旅行商问题也是一个NP完全问题
哈密顿回路问题$\prod'$ ：给定无向图G=(V,E)，是否存在一条回路，使得图中每个顶点在回路中出现且只出现一次
旅行商问题$\prod$：给定n个城市和它们的距离矩阵，以及距离L，是否存在从某个城市出发，经过每个城市一次且仅一次，最后回到出发城市且距离小于或等于L的路线
后面是具体说明：

对于哈密顿回路问题 $\prod'$ 中的无向图G=(V,E) ，可以用多项式时间构造新的无向图$G'$=(V',E') ，使得V'=V，E'=E 。对于E'中的每条边(u, v)赋予如下权值：
$$d(u, v) = \left\{
\begin{aligned}
   1& \quad (u, v) \in E\\
   2n& \quad (u, v) \notin E
\end{aligned}
\right.
$$
通过上述转换， $\prod'$ 转换为旅行商问题$\prod$ 
可以证明两个问题等价：
（1）G中包含一条哈密尔顿回路，则这条路径上的边共有n条，每条边长度是1，则G'中存在一条路径经过每个顶点且一次，并且长度不超过n
（2）如果G'中存在一条满足旅行商问题的路径，则这条路径经过G中各个顶点一次，且仅一次，最后回到出发顶点，它肯定是一条哈密尔顿回路。

如何证明一个问题是NP完全的？
根据NP完全问题的定义（满足的两个性质），显然地，证明需要分两个步骤进行：
证明问题∏是NP类问题；即可以在多项式时间内以确定性算法验证一个任意生成的串，以确定它是否为问题的一个解。
证明NP类问题中的每一个问题都能在多项式时间内变换为问题∏。由于多项式问题变换具有传递性，所以，只需证明一个已知的NP完全问题能够在多项式时间内变换为问题∏. 

<img src="https://img-blog.csdnimg.cn/20200317000000403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
## 11.4.2顶点覆盖、独立集和团集问题
顶点覆盖:
给出一个无向图G=(V,E)和一个正整数k，是否存在大小为k的子集C $\in$ V,使E中的每条边至少和C中的一个顶点关联? 
独立集:
独立集:给出一个无向图G=(V,E)和一个正整数k，是否存在k个顶点的子集S  V，使得对于每一对顶点u，w∈S, (u,w) $\notin$ E? 
团集:
团集:给出一个无向图G=(V,E)和一个正整数k， G包含一个大小为k的团集吗?(注意一个G中大小为k的团集是G中k个顶点的一个完全子图。)
容易证明所有这三个问题确实是NP的。

证明最大团集问题是NP完全的

下面证明团问题属于NP完全问题，证明分两步：
1) 团集问题属于NP类问题
显然，验证图G的一个子图是否构成团只需要多项式时间，所以团问题属于NP类问题。
2) 可满足性问题∝poly团集问题

给出一个有m个子句和n个布尔变元x1,x2,..,xn 的可满足性实例$f=C1\wedge C2 \wedge… \wedge Cm$，我们构造一个图G=(V,E)，其中V是2n个文字的所有出现的集合(注意一个文字是一个布尔变元或它的否定)，并且
             E={(xi,xj)|xi和xj位于两个不同的子句，并且xi $\neq$~xj}
 
 $$f = (x \vee \overline y \vee z) \wedge (x \vee y) \wedge (\overline x \vee \overline y \vee z)$$

<img src="https://img-blog.csdnimg.cn/20200317000120227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">
引理 10.1
f是可满足的当且仅当G 有一个大小为m的团集。
	证明:
一个大小为m的团集对应于一个m个不同子句中对m个文字的真指派。在两个文字a和b间的边意味着当a和b同时指派真值时没有矛盾。这就得到f是可满足的当且仅当存在着一个对于m个不同子句中的m个文字的真指派，当且仅当G有一个大小为m的团集。

对于任意一个合取范式，按照如下方式构造相应的图G：
例如  $f = (a \vee \overline b) \wedge (b \vee \overline c) \wedge (c \vee \overline a)$
图G的每个顶点对应于f中的每个文字，多次出现的重复表示；
若图G中两个顶点对应的文字不互补，且不出现在同一子句中，则将其连线。（a-b连线意味着a和b同时为真）

<img src="https://img-blog.csdnimg.cn/20200317000304573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">SAT问题∝poly团问题
设f有n个子句，则：f可满足
$\Leftrightarrow$ n个子句同时为真
$\Leftrightarrow$ 每个子句至少1个文字为真
$\Leftrightarrow$ G中有n个顶点之间彼此相连
$\Leftrightarrow$ G中有n个顶点的团

 显然，上述构造图G的方法可在多项式时间内完成，故有：SAT∝poly团问题。
由以上证明可知，团问题是NP完全问题。

可满足性∝poly顶点覆盖
 给出一个可满足性实例I，我们把它变换为顶点覆盖的一个实例
I’，设I是一个有m个子句和n个布尔变元x1,x2,..,xn的可满足性实例公式f=C1$\wedge$ C2 $\wedge$… $\wedge$ Cm ，构造I’如下。
对于f中的每一个布尔变元xi，G包含一对顶点xi和~xi ，它们有一条边相连; 
对于每个子句Cj包含的nj个文字，G包含一个大小为nj的团集Cj ；
对于在Cj中的每个顶点w，有一条边连接w到(1)中构造的顶点对(xi,~xi)中它相应的文字。这些边称为连通边; 

令$k = n + \sum_{j = 1}^m(n_j - 1)$
引理 10.2
f是可满足的当且仅当构造的图有一个大小为k的顶点覆盖。
证明: P181

顶点覆盖$\propto$poly独立集


引理 10.3
设G=(V,E)是连通无向图，那么S $\in$ V是一个独立集当且仅当V-S是G的一个顶点覆盖。

	证明
设e=(u,v)是G中的任意边，S是一个独立集当且仅当u或v至少有一个在V-S中，即V-S是G中的顶点覆盖。
定理 10.4

顶点覆盖、独立集和团集问题是NP完全的。

# 11.5 co- NP类
co-NP类由它们的补属于NP类的那些问题组成。例如：
旅行商问题的补：给出n个城市和它们之间的距离，不存在长度为k或更少的任何旅程，情况是那样吗?
可满足性问题(SAT)的补：给出一个公式f，不存在使得f为真的布尔变量指派，是吗? 换言之，f是不可满足的吗? 

co-NP类由它们的补属于NP类的那些问题组成。
定义 10.7
问题 $\prod$ 对于co-NP类是完全的，如果
(1)  $\prod$ 在 co-NP中
(2)对于co-NP中的每一个问题 $\prod'$，$\prod' \propto _{poly}\prod$
<img src="https://img-blog.csdnimg.cn/2020031700094899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">定理10.5
问题A是NP完全的，当且仅当它的补 $\overline A$   对于类co-NP是完全的。

定理 10.6
重言式问题:给出一个DNF公式f，它是重言式吗? 这个问题对于co-NP类是完全的
由此得出下列结论:
重言式问题属于P当且仅当co-NP=P,
重言式问题属于NP当且仅当co-NP=NP 。




# 11.6 NPI类
  定理 10.7
如果问题∏和它的补是NP完全的，那么co-NP=NP。

换句话说，如果问题∏和它的补都是NP完全的，那么NP类在补运算下是封闭的。
NP类问题中还有一些问题，人们不知道是属于P类还是属于NP完全问题，还有待于证明其归属。
这些问题是NP完全问题的可能性非常小，也因为不相信他们在P中，我们人为地增加另一问题类来接纳这类问题，这个类称为NPI(NP-Intermediate)类。 
 
 <img src="https://img-blog.csdnimg.cn/20200317001251431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">NPI类是一个人为定义的、动态的概念，随着人们对问题研究的深入，许多NPI类问题逐渐被明白无误地证明他们原本属于P类问题或NP完全问题。

例如：线性规划问题、素数判定问题等，在二者没有被证明他们均属于P类问题之前，人们一直将他们归于NPI类问题。 

线性规划问题
    设A∈Rm×n, x∈Rn, b∈Rm，
    在满足Ax=b，x≥0约束下，
    使目标函数cTx达到最大值，其中c∈Rn.
长期以来，线性规划问题没有多项式时间解法，也无法证明它是NP完全问题。直到20世纪80年代，这个问题得到解决，发现了多项式时间算法。 

素数判定问题
给一个整数，判定其是素数还是合数。
经过一个重要的理论突破，印度M. Agrawal 教授和他的学生N. Kayal 和N. Saxena于2002年宣布发现一个多项式时间算法。(PRIMES is in P, Annals of Mathematics, 160 (2004), 781–793)  

# 11.7 四种类的关系
<img src="https://img-blog.csdnimg.cn/20200317001925548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%"><img src="https://img-blog.csdnimg.cn/20200317001931711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="40%">

