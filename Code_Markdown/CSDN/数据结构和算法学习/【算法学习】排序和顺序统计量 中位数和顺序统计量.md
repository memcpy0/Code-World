> 参考算法导论第9章 中位数和顺序统计量
![在这里插入图片描述](https://img-blog.csdnimg.cn/9d1bc0164f8f4ee8bcbe386f73f9f782.png)

在一个由 $n$ 个元素组成的集合中，第 $i$ 个**顺序统计量** `order statistic` 是该集合中第 $i$ 小的元素。例如，在一个元素集合中，**最小值**是第一个顺序统计量（$i = 1$），**最大值**是第 $n$ 个顺序统计量（$i = n$）。用非形式化的描述来说，==一个**中位数** `median` 是它所属集合的“中点元素”。当 $n$ 为奇数时，中位数是唯一的，位于 $i = (n+1)/2$ 处。当 $n$ 为偶数时，存在两个中位数，分别位于 $i = n / 2$ 和 $i = n / 2 + 1$ 处==。 因此，如果不考虑 $n$ 的奇偶性，中位数总是出现在 $i = \lfloor (n +1) / 2 \rfloor$ 处（**下中位数**）和 $i = \lceil (n + 2) / 2 \rceil$ 处（**上中位数**）。为了简便起见，这里用的“中位数”都是指下中位数。

这里将讨论，从一个由 $n$ 个互异的元素构成的集合中、选择第 $i$ 个顺序统计量的问题。为了简单起见，假设集合中的元素都是互异的，但实际上我们所做的、都可以推广到集合中包含重复元素的情形。我们将这一问题形式化定义为如下的**选择问题**：
- **输入**：一个包含 $n$ 个（互异的）数的集合 $A$ 和一个整数 $i$ ，$1 \le i \le n$ 。
- **输出**：元素 $x \in A$ ，且 $A$ 中恰好有 $i - 1$ 个其他元素小于它。

我们可以在 $O(n\log n)$ 时间内解决这个选择问题，因为我们可以用堆排序或归并排序对输入数据进行排序，然后在输出数组中根据下标、找出第 $i$ 个元素即可。这里将介绍一些更快的算法。
- （算导9.1节）讨论，从一个集合中选择最小元素和最大元素的问题。随后讨论一般化选择问题。
- （算导9.2节）分析一个实用的随机算法，它在元素互异的假设条件下，可以达到 $O(n)$ 的期望运行时间。
- （算导9.3节）给出一个更具有理论意义的算法，它在最坏情况下的运行时间为 $O(n)$ 。

---
# 9.1 最小值和最大值
在一个有 $n$ 个元素的集合中，需要做多少次比较、才能确定其最小元素呢？我们可以很容易地给出 $n - 1$ 次比较这个上界：依次遍历集合中的每个元素，并记录下当前最小元素。在下面的程序中，我们假设该集合元素存放在数组 $A$ 中，且 $A.length = n$ ：
```cpp
MINIMUM(A)
	min = A[1]
	for i = 2 to A.length
		if min > A[i]
			min = A[i]
	return min
```
当然，最大值也可以通过 $n - 1$ 次比较找出来。

这是我们能得到的最好结果吗？是的，对于确定性最小值问题，我们可以得到其下界就是 $n - 1$ 次比较。对于任意一个确定最小值的算法，可以把它看成是在各元素之间进行的一场锦标赛。每次比较都是锦标赛中的一场比赛，两个元素间较小的获胜。需要注意的是，除了最终获胜者以外，每个元素都至少要输掉一场比赛。因此，我们得到结论：为了确定最小值，必须要做 $n - 1$ 次比较。因此，从执行的比较次数来看，算法 `MINIMUM` 是最优的。

## 同时找到最小值和最大值
在某些应用中，我们必须要找出一个包含 $n$ 个元素的集合中的最小值和最大值。例如，一个图形程序需要转换一组 $(x, y)$ 数据，使其能适合一个矩形显示器或其他图形输出装置。为了做到这一点，程序必须首先确定每个坐标中的最小值和最大值。

就这一点来说，用渐近最优的 $\Theta(n)$ 次比较，在 $n$ 个元素中同时找到最小值和最大值的方法是显然的：只要分别独立地找出最小值和最大值，在各需要 $n - 1$ 次比较，共需要 $2n - 2$ 次比较。

事实上，我们只需要最多 $3 \lfloor n / 2 \rfloor$ 次比较，就可以同时找到最小值和最大值。具体的方法是，记录已知的最小值和最大值。但我们并不是将每个输入元素与当前的最小值和最大值进行比较，这样做的代价是每个元素需要两次比较，而是**对输入元素成对地进行处理**。
- 首先，我们将一对输入元素**相互**进行比较，然后把较小的与当前最小值比较，把较大的与当前最大值比较。这样，对每两个元素共需要三次比较。
- 如何设定已知的最小值和最大值的初始值，依赖于 $n$ 是奇数还是偶数。如果 $n$ 是奇数，我们就将最小值与最大值的初值都设为第一个元素的值，然后成对地处理余下的元素。如果 $n$ 是偶数，就对前两个元素做一次比较，以决定最小值和最大值的初值，然后与 $n$ 是奇数的情形一样，成对地处理余下的元素。

下面分析一下总的比较次数。如果 $n$ 是奇数，那么总共进行 $3 \lfloor n / 2 \rfloor$ 次比较（ $1 + 3 (n - 1) / 2$ 次比较）。如果 $n$ 是偶数，则是先进行一次初始比较，然后进行 $3(n - 2)/ 2$ 次比较，共 $3n / 2- 2$ 次比较。因此，不断哪一种情况，总的比较次数至多为 $3 \lfloor n / 2 \rfloor$ 。
 

---
# 2. 期望为线性时间的选择算法
一般选择问题看起来要比找最小值这样的简单问题更难，但令人惊奇的是，这两个问题的渐近运行时间确实相同的：$\Theta(n)$ 。本节介绍一种解决选择问题的分治算法：`RANDOMIZED-SELECT` 算法，它以快速排序算法为模型。与快排一样，我们仍将输入数组进行递归划分；但与快排不同的是，快排会递归处理划分的两边，而 `RANDOMIZED-SELECT` 只处理划分的一边。这一差异会在性能分析中体现出来：快速排序的期望运行时间是 $\Theta(n\log n)$ ，而 `RANDOMIZED-SELECT` 的期望运行时间是 $\Theta(n)$ 。这里假设输入数据都是互异的。
```cpp
RANDOMIZED-SELECT(A, p, r, i)
	if p == r
		return A[p]
	q = RANDOMIZED-PARTITION(A, p, r)
	k = q - p + 1
	if i == k // the pivot value is the answer
		return A[q]
	else if i < k
		return RANDOMIZED-SELECT(A, p, q - 1, i)
	else return RANDOMIZED-SELECT(A, q + 1, r, i - k)
```
`RANDOMIZED-SELECT` 的运行过程如下：第 $1$ 行检查递归的基本情况，即 $A[p\dots r]$ 中只包含一个元素。在这种情况下，$i$ 必然等于 $1$ ，在第 $2$ 行，我们只需将 $A[p]$ 返回作为第 $i$ 小的元素即可。其他情况，就会调用第 $3$ 行的 `RANDOMIZED-PARTITION` ，将数组 $A[p \dots r]$ 划分为两个（可能为空的）子数组 $A[p \dots q - 1]$ 和 $A[q+1 \dots r]$ ，使得 $A[p\dots q - 1]$ 中的每个元素都小于或等于 $A[q]$ ，而 $A[q]$ 小于 $A[q + 1\dots r]$ 中的每个元素。与快速排序中一样，我们称 $A[q]$ 为**主元** `pivot` 。

`RANDOMIZED-SELECT` 的第 $4$ 行计算子数组 $A[p \dots q]$ 内的元素个数 $k$ ，即处于划分的低区的元素的个数加 $1$ ，这个 $1$ 指主元。然后，第 $5$ 行检查 $A[q]$ 是否是第 $i$ 小的元素。如果是，第 $6$ 行就返回 $A[q]$ 。否则，算法要确定第 $i$ 小的元素落在两个子数组 $A[p \dots q - 1]$ 和 $A[q + 1 \dots r]$ 的哪一个。如果 $i < k$ ，则要找的元素落在划分的低区，第 $8$ 行就在低区的子数组中进一步递归查找。如果 $i > k$ ，则要找的元素落在划分的高区中。因为我们已经知道了有 $k$ 个值（即 $A[p \dots q]$ 内的元素）小于 $A[p \dots r]$ 中第 $i$ 小的元素，所以我们所要找的元素必然是 $A[q + 1 \dots r]$ 中的第 $i - k$ 小的元素，它在第 $9$ 行中被递归地查找。上述程序看起来允许递归调用含有 $0$ 个元素的子数组，但（算导练习9.2-1）要求证明这种情况不可能发生。

`RANDOMIZED-SELECT` 的最坏情况运行时间为 $\Theta(n^2)$ ，即使是找最小元素也是如此，因为在每次划分时、可能极不走运地总是按余下的元素中最大的来进行划分，而划分操作需要 $\Theta(n)$ 时间。我们也将看到该算法有线性的期望运行时间，又因为它是随机化的，所以不存在一个特定的、会导致其最坏情况发生的输入数据。

为了分析 `RANDOMIZED-SELECT` 的期望运行时间，我们设该算法在一个含有 $n$ 个元素的输入数组 $A[p \dots r]$ 上的运行时间是一个随机变量，记为 $T(n)$ 。下面可以得到 $E[T(n)]$ 的一个上界：程序 `RANDOMIZED-PARTITION` 能等概率地返回任何元素作为主元。因此，==对每个 $k \ ( 1 \le k \le n)$ ，子数组 $A[p \dots q]$ 有 $k$ 个元素（这些元素全部小于或等于主元）的概率是 $1 / n$== 。对所有 $k = 1,2, \dots , n$ ，定义指示器随机变量 $X_k$ 为：
$$X_k = I (子数组A[p \dots q]正好包含k个元素)$$

然后假设元素是互异的，我们有：$$E[X_k] = 1/n \tag{9.1}$$

当调用 `RANDOMIZED-SELECT` 、并选中 $A[q]$ 作为主元时，事先并不知道是否会立即得到正确答案而结束，或者在子数组 $A[p \dots q - 1]$ 上递归，或者在子数组 $A[q + 1\dots r]$ 上递归。这个决定依赖于第 $i$ 小的元素相对于 $A[q]$ 落在哪个位置。假设 $T(n)$ 是单调递增的，通过评估对「最大可能的输入数据」递归调用所需时间，我们可以给出递归调用所需时间的上界。即，**为了得到上界，我们假定第 $i$ 个元素总是在划分中包含较大元素的一边**。

对一个给定的 `RANDOMIZED-SELECT` ，指示器随机变量 $X_k$ 恰好在给定的 $k$ 值上取值 $1$ ，对其他值都为 $0$ 。当 $X_k = 1$ 时，我们可能要递归处理的两个子数组的大小分别为 $k - 1$ 和 $n - k$ 。因此可以得到递归式：
$$T(n) \le \sum^n_{k=1} X_k \cdot ( T(\max(k - 1, n - k) ) + O(n)) \\ = \sum^n_{k=1} X_k \cdot T(\max(k - 1, n - k)) + O(n)$$

两边取期望值，得到：$$
\begin{aligned}
E[T(n) ] &\le E \bigg [ \sum^n_{k=1} X_k \cdot T(\max (k - 1, n - k)) + O(n) \bigg ]\\
&= \sum^n_{k=1} E[X_k \cdot T(\max (k - 1, n - k)) ] + O(n) \quad &期望的线性性质 \\
&= \sum^n_{k=1} E[X_k] \cdot E[T(\max(k - 1, n - k)) ] + O(n) \quad &利用公式(C.24) \\
&= \sum^n_{k=1} \dfrac{1}{n} \cdot E[T(\max(k - 1, n - k)) ] + O(n) \quad &利用公式(9.1)\end{aligned}$$

公式 $(C.24)$ 的应用依赖于 $X_k$ 和 $T(\max(k - 1, n - k))$ 是独立的随机变量。（算导练习9.2-2）要求证明这个命题。下面来考虑一下表达式 $\max(k - 1, n - k)$ ，我们有：
$$
\max(k - 1, n - k) = \begin{cases}
k - 1 & 若k > \lceil n / 2 \rceil \\
n -k & 若k\le \lceil n / 2 \rceil 
\end{cases}$$ 如果 $n$ 是偶数，则从 $T( \lceil n / 2 \rceil)$ 到 $T(n - 1)$ 的每一项在总和中恰好出现两次。如果 $n$ 是奇数，除了 $T( \lfloor n / 2 \rfloor )$ 出现一次以外，其他这些项也都会出现两次。因此，我们有：$$E[T(n)] \le \dfrac{2}{n} \sum^{n-1}_{k = \lfloor n / 2 \rfloor }E[T(k) ] + O(n)$$

 我们将用**代入法**得到 $E[T(n) ] = O(n)$ 。假设对满足这个递归式初始条件的某个常数 $c$ ，有 $E[T(n)] \le cn$ 。假设对小于某个常数的 $n$ ，有 $T(n) = O(1)$（稍后将用到这个常数）。同时，还要选择一个常数 $a$ ，使得对所有的 $n > 0$ ，上式中 $O(n)$ 项描述的函数（用来表示算法运行时间中的非递归部分）有上界 $an$ 。利用这个归纳假设，可以得到：
 $$\begin{aligned}
 E[T(n)] &\le 
 \dfrac{2}{n} \sum^{n-1}_{k = \lfloor n / 2\rfloor }ck + an \\
 &= \dfrac{2c}{n} \bigg (\sum^{n-1}_{k=1} k - \sum^{ \lfloor n / 2 \rfloor - 1} _{k = 1}k \bigg) + an \\
 &= \dfrac{2c}{n} \bigg( \dfrac{(n-1)n} {2} - \dfrac{ ( \lfloor n / 2 \rfloor -1 ) \lfloor n / 2 \rfloor}{2} \bigg) + an \\
 &\le \dfrac{2c}{n} \bigg ( \dfrac{ (n-1)n } { 2} - \dfrac{ (n / 2 - 2) (n / 2 - 1) } {2} \bigg) + an \\
 &= \dfrac {2c}{n} \bigg( \dfrac{n^2 - n}{2} - \dfrac{n^2 / 4  - 3n / 2 + 2}{2} \bigg) + an \\
 &= \dfrac{c}{n} \bigg( \dfrac{3n^2}{4} + \dfrac{n}{2} - 2\bigg) + an \\
 &= c\bigg( \dfrac{3n}{4} + \dfrac{1}{2} - \dfrac{2}{n} \bigg) + an \\
 &\le  \dfrac{3cn}{4} + \dfrac{c}{2} + an \\
 &= cn - \bigg(\dfrac{cn}{4}- \dfrac{c}{2} - an\bigg)
 \end{aligned}$$

为了完成证明，还需要证明：对于足够大的 $n$ ，最后一个表达式至多是 $cn$ ，等价地，$cn / 4 - c/ 2 - an \ge 0$ 。如果在上式两边加上 $c / 2$ ，并且提取因子 $n$ ，就可以得到 $n( c/4 - a) \ge c / 2$ 。只要我们选择的常数 $c$ 能够满足 $c / 4 - a > 0$ 即 $c > 4a$ ，就可以将两边同除以 $c / 4 - a$ ，得到：$$n \ge \dfrac{c / 2}{ c / 4 -a} = \dfrac{2c}{c - 4a}$$

因此，如果假设对所有 $n < 2c / (c - 4a)$ ，都有 $T(n) = O(1)$ ，那么就有 $E[T(n) ] = O(n)$ 。我们可以得出这样的结论：假设所有元素是互异的，在期望线性时间内，我们可以找到任一顺序统计量，特别是中位数。

---
# 3. 最坏情况为线性时间的选择算法
现在来看一个最坏情况运行时间为 $O(n)$ 的选择算法。像 `RANDOMIZED-SELECT` 一样，`SELECT` 算法通过「对输入数组的递归划分」来找出所需元素，但在该算法中能够**保证**得到对数组的一个好的划分。`SELECT` 使用的也是「来自快速排序的确定性划分算法」`PARTITION`（算导7.1节），但做了修改，把划分的主元也作为输入参数。

通过执行下列步骤，算法 `SELECT` 可确定，一个有 $n > 1$ 个不同元素的输入数组中第 $i$ 小的元素（如果 $n = 1$ ，则 `SELECT` 只返回它的唯一输入数值，作为第 $i$ 小的元素）：
1. 将输入数组的 $n$ 个元素划分为 $\lfloor n / 5 \rfloor$ 组，每组 $5$ 个元素，且至多只有一组由剩下的 $n \bmod 5$ 个元素组成。
2. 寻找这 $\lceil n / 5 \rceil$ 组中每一组的中位数：首先对每组元素进行插入排序，然后确定每组有序元素的中位数。
3. 对第 $2$ 步中找出的 $\lceil n / 5\rceil$ 个中位数，递归调用 `SELECT` 以找出其中位数 $x$（如果有偶数个中位数，为了方便，约定 $x$ 是较小的中位数）。
4. 利用修改过的 `PARTITION` 版本，按中位数的中位数 $x$ 对输入数组进行划分。让 $k$ 比划分的低区中的元素数目多 $1$ ，因此 $x$ 是第 $k$ 小的元素，并且有 $n - k$ 个元素在划分的高区。
5. 如果 $i = k$ ，则返回 $x$ 。如果 $i < k$ ，则在低区递归调用 `SELECT` 来找出第 $i$ 小的元素。如果 $i > k$ ，则在高区递归查找第 $i - k$ 小的元素。
 
为分析 `SELECT` 的运行时间，我们先要确定「大于划分主元 $x$ 的元素」个数的下界。图9-1给出了一些形象的说明。**在第 $2$ 步找出的中位数中，至少有一半大于或等于中位数的中位数 $x$**（因为我们假设这些数是互异的，所以除了 $x$ 以外的所有元素都大于或小于 $x$ ）。因此，在这 $\lceil n / 5 \rceil$ 各组中，除了当 $n$ 不能被 $5$ 整除时产生的、含有元素少于 $5$ 个的那个组，和包含 $x$ 的那个组之外，至少有一半的组中有三个元素大于 $x$ 。不算这两个组，大于 $x$ 的元素个数至少为：
$$3 \bigg ( \bigg\lceil \dfrac{1}{2} \bigg\lceil \dfrac{n}{5}\bigg \rceil \bigg \rceil - 2 \bigg) \ge \dfrac{3n}{10} - 6$$ 类似地，至少有 $3n / 10 - 6$ 个元素小于 $x$ 。因此，在最坏情况下，在第五步中，`SELECT` 的递归调用最多作用于 $7n / 10 + 6$ 个元素。
![在这里插入图片描述](https://img-blog.csdnimg.cn/ef3dcbaf13d04a7bb40ac666c209e883.png)
现在，我们可以设计一个递归式来推导 `SELECT` 算法的最坏情况运行时间 $T(n)$ 了。步骤 $1, 2, 4$ 需要 $O(n)$ 时间（步骤 $2$ 是对大小为 $O(1)$ 的集合调用 $O(n)$ 次插入排序）。步骤 $3$ 所需时间为 $T( \lceil n / 5 \rceil)$ ，步骤 $5$ 所需时间至多为 $T(7n / 10 + 6)$ 。

这里我们假设 $T$ 是单调递增的，此外我们还要做如下假设（这一假设初看起来似乎没有什么动机），即任何少于 $140$ 个元素的输入需要 $O(1)$ 时间。后面我们很快会说明这个魔数 $140$ 的起源。根据上述假设，可以得到如下递归式：
$$T(n) \le \begin{cases}
O(1) \quad & 若n< 140 \\
T( \lceil n / 5 \rceil) +T(7n / 10 + 6) + O(n) \quad &若n\ge 140 \\
\end{cases}$$

我们用替换法来证明这个运行时间是线性的。更明确地说，我们将证明对某个适当大的常数 $c$ 和所有的 $n>0$ 有 $T(n) \le cn$ 。首先，假设对某个适当大的常数 $c$ 和所有 $n < 140$ ，有 $T(n) \le cn$ ；如果 $c$ 足够大，这个假设显然成立。同时，还要挑选一个常数 $a$ ，使得对所有的 $n > 0$ ，上述公式中的 $O(n)$ 项对应的函数（用来描述算法运行时间中的非递归部分）有上界 $an$ 。将这个归纳假设代入上述递归式的右边，得到：
$$\begin{aligned}T(n) 
&\le c \lceil n / 5 \rceil + c(7n / 10+6) + an \\
&\le cn / 5 + c + 7cn / 10 + 6c + an \\
&= 9cn / 10 + 7c + an \\
&= cn + (-cn / 10 + 7c + an)\end{aligned}$$

如果下式成立，上式最多是 $cn$ ：$$-cn / 10 + 7c + an \le 0 \tag{9.2}$$

当 $n > 70$ 时，不等式 $(9.2)$ 等价于不等式 $c \ge 10a\  \dfrac{n}{n - 70}$ 。因为假设 $n > 140$ ，所以有 $n / (n - 70) < 2$（不是 $\le$ 吧）。因此，选择 $c \ge 20a$ 就能够满足不等式 $(9.2)$（注意，这里常数 $140$ 并没有特别之处，我们可以用任何严格大于 $70$ 的整数来替换它，然后再相应地选择 $c$ 即可）。因此，最坏情况下 `SELECT` 的运行时间是线性的。

与比较排序一样（见算导8.1节），`SELECT` 和 `RANDOMIZED-SELECT` 也是通过元素间的比较来确定它们之间的相对次序的。（算导第8章中）我们知道在比较模型中，即使是在平均情况下，排序仍然需要 $\Omega(n \log n)$ 时间（算导思考题8-1）。（算导第8章的）线性时间排序算法在输入上作了一些假设。相反，这里的线性时间选择算法不需要任何关于输入的假设，它们不受限于 $\Omega(n\log n)$ 的下界约束，因为它们没有使用排序就解决了选择问题。因此，最开始部分介绍的「排序再索引方法」不是解决选择问题的渐近高效率方法。


 
