> 算法竞赛：从入门到进阶，罗勇军
> 应用组合数学，Alan Tucker著，冯速译，第11章，提到了相关知识

本节讨论的**公平组合游戏** *Impartial Combinational Game, ICG* 是满足以下特征的一类问题：
1. **有两个玩家**，游戏规则**对两人是公平的**；
2. 游戏的**状态有限**，能走的步数也有限；
3. **两人轮流走步**，当一个玩家不能走步时游戏结束；
4. **游戏的局势无法区分玩家身份**，像围棋这样有黑、白两方的游戏就不属于此类问题。

ICG问题的特征在于：==给定初始局势，并且指定先手玩家，如果双方都采取最优策略，那么获胜者就已经确定了==。也就是说，ICG问题存在**必胜策略**。

下面讲解ICG问题的必胜策略，有关知识点：
1. P-position, N-position
2. Nim Game
3. Sprague-Grundy函数
4. 威佐夫游戏等

ICG很早就得到了研究，例如对于Nim Game，1902年 *C. Bouton* 在一本著作中进行了分析；对于 *Sprague-Grundy* 函数，由数学家 *Grundy* 和 *Sprague* 在1930年分别独立发现，这也是**本节最重要的内容**！
# 1. 巴什游戏、P-position、N-position
给出一个简单的例题。
## 1.1 [HDU 1846 "Brave Game"](https://acm.hdu.edu.cn/showproblem.php?pid=1846)
有 $n$ 颗石头，甲先取，乙后取，每次可以取 $1\sim m$ 颗石子，轮流拿下去，拿到最后一颗的人获胜。
输入：$n$ 和 $m$ ，$1\le n, m \le 1000$ 。
输出：如果先拿的甲赢了，输出"first"，否则输出"second"。

程序非常简单，若 $n \bmod (m + 1) == 0$ ，则先手必败，否则后手必败。
```cpp
cin >> n >> m;
if (n % (m + 1) == 0) printf("second\n");
else printf("first\n");
```
分析如下：
1. 当 $n\le m$ 时，由于一次最少拿一个，最多拿 $m$ 个，甲可以一次性拿完，先手胜。
2. 当 $n = m + 1$ 时，无论甲拿走多少个（$1\sim m$ 个），剩下的都 $\ge 1,\ \le m$ 个，乙都能一次性拿走剩余的石子，后手胜。

上面两种情况可以扩展为以下两种情况：
1. 如果 $n\bmod (m +1) =0$ ，即 $n$ 是 $m +1$ 的整数倍，那么不管甲拿多少，例如 $k$ 个，乙都拿 $m + 1- k$ 个，使得剩下的永远是 $m+1$ 的整数倍，直到最后的 $m+1$ 个，所以后拿的乙一定赢。
2. 如果 $n \bmod (m+1) \ne 0$ ，即 $n$ 不是 $m+1$ 的整数倍，还有余数 $r$ ，那么甲拿走 $r$ 个，剩余的是 $m+1$ 的倍数，这样就转移到了情况1，相当于**甲乙互换**，结果是甲赢。

在这个拿石子的游戏中，对于后拿的乙来说是很不利的，只有在 $n\bmod (m+1) = 0$ 的情况下乙才能赢，其他情况下都是甲赢。
## 1.2 P-position, N-position与动态规划/记忆化搜索
上面对于巴什游戏（只有1堆石子）的解答虽然很好理解，但是如果稍作扩展，就不那么容易了。例如取石子的数量，不是 $1\sim m$ 内的连续数字，而是只能在 $\{ a_1, a_2, \dots, a_k\}$ 中选。对于此类巴什问题，有必要研究一种通用的方法。

定义 *P-position* 为**前一个玩家 *Previous Player* 即刚走过一步的玩家的必胜位置**，*N-position* 为**下一个玩家 *Next Player* 的必胜位置**。当前状态为 *N-position* ，表示马上走下一步的先手必胜；当前状态为 *P-position* ，表示马上走下一步的先手必败。

设只能拿 $\{1, 4\}$ 的石头。下表中 $x$ 是石头的数量，$pos$ 是对应的 $position$ ：

| x | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | ... |
|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|:---|:---|:---|:---|:---|
|pos | P | N |P  | N | N | P | N | P | N | N | P |N |P |N|...|

表中的 $pos$ 是这样算的：
1. $x = 0, 1, 2, 3, 4$ 时，$pos = P, N, P, N, N$ ，特别注意没有石头的情况 $x = 0$ ，可以看成下个玩家（先手玩家）没有石头可以拿，输了，$pos = P$ 。$x = 1$ 时，先手玩家必胜，$pos = N$ 。$x = 2$ 时，先手只能拿 $1$ 个，后手拿剩下的 $1$ 个，后手赢，$pos = P$ 。
2. $x = 5$ 时分两种情况：
    1. 如果先手玩家拿 $1$ 个，退回到 $x = 5 - 1 = 4$ 的情况，此时后手玩家处于 $N$ ，即后手处于赢的位置；
    2. 如果先手玩家拿 $4$ 个，退回到 $x = 5- 4 = 1$ 的情况，此时后手仍然处于 $N$ 。
    3. 在两种情况下后手都赢了。所以 $x = 5$ 时，即先手必输。
3. $x = 6$ 时，分别退回到 $x = 6 - 1 = 5$ 和 $x = 6 - 4 = 2$ 的情况，后手都处于 $P$ 。在两种情况下，后手都输了。所以 $x = 6$ 时 $pos = N$ ，先手必赢。
4. $x = 7$ 时略。
5. $x = 8$ 时，退回到 $x = 8 - 1 = 7$ ，后手处于 $P$ ；退回到 $x = 8 - 4 = 4$ ，后手处于 $N$ 。在后手有输有赢的情况下，先手肯定选让对方必败的方案，所以 $x = 8$ 时 $pos = N$ 。

可以观察到 $pos$ 值是周期性变化的，周期为 $5$ 。

下面再举一个例子，设只能拿数量为 $\{ 1, 3, 4\}$ 的石头，见下表。

| x | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|:---|:---|:---|:---|:---|
|pos | P | N |P  | N | N | N | N | P | N | P | N |N | N |N| P |

$pos$ 仍然是周期性变化的，周期是 $7$ 。

上面的计算过程符合**动态规划/记忆化搜索**的思路。编程时可以用动态规划，也可以直接按周期性变化规律做求余计算。HDU 1846是最简单的情况，用求余编程计算就可以了。

巴什游戏还有一些变形。例如HDU 2147 kiki's game，给出一个 $n \times m$ 的矩阵，从右上角走到左下角，看谁先到终点。画出 $P-N$ 图，找到规律即可。

---
# 2. 尼姆游戏
巴什游戏只有一堆石头，如果扩展到多堆石头，情况将复杂得多，这就是[尼姆游戏 *Nim Game*](https://en.wikipedia.org/wiki/Nim) 。尼姆游戏的规则：有 $n$ 堆石子，数量分别是 $\{ a_1, a_2, a_3, \dots, a_k\}$ ，两个玩家轮流拿石子，每次从任意一堆中拿走任意数量的石子，拿到最后一个石子的玩家获胜。

以 $3$ 堆石头为例，简单情况的胜负如下：
1. `{0,0,0}` 没有石头让先手拿，必败；`{0,1,1}, {0,k,k}` ，先手必败。 
2. `{1,1,1}, {1,1,2}, {1,1,3}` ，先手必胜。
## 2.1 尼姆游戏和证明
对于任意的 $\{a_1,a_2,\dots, a_n\}$ ，尼姆游戏有一个极为简单的判断胜负的方法，即异或运算。
> **定理A**：
> 若 $a_1 \oplus a_2 \oplus a_3 \dots \oplus a_n \ne 0$ ，则先手必胜，此时的状态记为 *N-position* ；
> 若 $a_1 \oplus a_2 \oplus a_3 \dots \oplus a_n = 0$ ，则先手必败，此时的状态记为 *P-position* ；

例如 $3$ 堆石头的数量分别是 $\{ 5, 7, 9\}$ ，转换为二进制数后，做异或运算，结果如下：
```cpp
0 1 0 1
0 1 1 1
1 0 0 1
-------
1 0 1 1
```
异或运算的结果不为 $0$ ，则先手必胜。

在数学中，二进制的异或运算可看成：统计每一位上 $1$ 的总个数的奇偶性：如果这一位上有偶数个 $1$ ，那么这一位的计算结果为 $0$ ；如果有奇数个，计算结果为 $1$ 。所以，尼姆游戏里的异或运算也被称为**Nim-sum运算**。

下面对**定理A**做简单证明：
1. 必定能够从 *N-position* 转换到 *P-position* 。也就是说，先手处于必胜点 *N-position* 时可以拿走一些石头，让后手必败。下面是具体方法：任选一堆例如第 $i$ 堆，石头数量是 $k$ ；对剩下 $n - 1$ 堆做异或运算，设结果为 $H$ ：
    1. 如果 $H$ 比 $k$ 小，则减少第 $i$ 堆石头到 $H$ ，这样操作后，因为 $H\oplus H= 0$ ，所以 $n$ 堆石头的异或等于 $0$ 。
    2. 可以证明：总会存在这样的第 $i$ 堆石头，而且可能有多种转换方案。下面HDU 1850程序中的 `if ((sum ^ a[i]) <= a[i])` 统计了所有方案。
2. 进入 *P-position* 以后，轮到下一个玩家，不论拿多少石子都会转移到 *N-position* ，因为任何一堆的数量变化，都会使这一堆的二进制数至少有一位发生变化，导致异或运算的结果不为 $0$ 。也就是说，这一个玩家不论怎么拿石头都必败。
3. 在游戏过程中，按上述1和2的步骤，在 *N-position* 和 *P-position* 之间交替转换，直到所有堆的石头都是 $0$ ，即终止于 *P-position* 。

上述的证明过程，也说明了玩家该如何进行游戏。

## 2.2 HDU 1850 Being a Good Boy in Spring Festival：统计第一步的选择数
两人小游戏：桌子上有 $n$ 堆扑克牌；每堆牌的数量分别为 $a$ ；两人轮流进行；每走一步可以从任意一堆种取走任意张牌；桌子上的扑克牌全部取光，则游戏结束；最后一次取牌的人为胜者，问先手的人如果想赢，第一步有几种选择？

输入：$n$ 表示扑克牌的堆数；$a_i\ (i = 1\sim n)$ 表示每堆扑克牌的数量。
输出：如果先手能赢，输出他第一步可行的方案数，否则输出 $0$ 。

主要代码如下：


- [877. 石子游戏](https://leetcode.cn/problems/stone-game) 中等
- [1140. 石子游戏 II](https://leetcode.cn/problems/stone-game-ii) 中等
- [1406. 石子游戏 III](https://leetcode.cn/problems/stone-game-iii) 困难
- [1510. 石子游戏 IV](https://leetcode.cn/problems/stone-game-iv) 困难：从 $1$ 堆石头里拿走**任意**非零**平方数**个石子
- [1563. 石子游戏 V](https://leetcode.cn/problems/stone-game-v) 困难
- [1686. 石子游戏 VI](https://leetcode.cn/problems/stone-game-vi) 中等
- [1690. 石子游戏 VII](https://leetcode.cn/problems/stone-game-vii) 中等
- [1872. 石子游戏 VIII](https://leetcode.cn/problems/stone-game-viii) 困难
- [2029. 石子游戏 IX](https://leetcode.cn/problems/stone-game-ix) 中等

- [292. Nim 游戏](https://leetcode.cn/problems/nim-game) 简单：简单巴什游戏
- [HDU 1846 "Brave Game"](https://acm.hdu.edu.cn/showproblem.php?pid=1846) ：简单巴什游戏
- 2012蓝桥杯【初赛试题】取球游戏：通用巴什游戏
- HDU 2147 kiki's game：变形巴什游戏
- HDU 1907 John：尼姆游戏

- HDU 2999 Stone Game, Why are you always there? ：SG函数
- HDU 1524 A Chess Game : SG函数
- HDU 4111 Alice and Bob ：SG函数，记忆化搜索
- HDU 4203 Doubloon Game ：数据规模大，找规律