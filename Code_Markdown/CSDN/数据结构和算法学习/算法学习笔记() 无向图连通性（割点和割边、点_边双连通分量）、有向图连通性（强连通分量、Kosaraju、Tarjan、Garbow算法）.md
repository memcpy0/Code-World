> 本文属于「算法学习」系列文章之一。之前的【数据结构和算法设计】系列着重于基础的数据结构和算法设计课程的学习，与之不同的是，这一系列主要用来记录对大学课程范围之外的高级算法学习、优化与使用的过程，同时也将归纳总结出简洁明了的算法模板，以便记忆和运用。在本系列学习文章中，为了透彻讲解算法和代码，本人参考了诸多博客、教程、文档、书籍等资料，由于精力有限，恕不能一一列出。
> <b></b>
> 为了方便在PC上运行调试、分享代码，我还建立了相关的仓库：[https://github.com/memcpy0/Algorithm-Templates](https://github.com/memcpy0/Algorithm-Templates)。在这一仓库中，你可以看到算法文章、模板代码、应用题目等等。由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[算法学习系列文章目录](https://memcpy0.blog.csdn.net/article/details/117125688)一文以作备忘。

@[toc]

---
# 1. 割点和割边（无向连通图）
无向图中，所有能互通的点组成了一个**连通分量**，一个连通分量中有一些关键点/边，如果删除它，就会把这个连通分量分成两个或更多，这种点/边称为**割点** `cut vertex` /**割边** `cut edge` 。

割点和割边是很有意义的，从割点和割边可以扩展出**双连通**问题，即如何实现一个没有割点和割边的图——在计算机网络中可靠性相当重要，希望能在某些网络节点出现故障的情况下，不影响整个网络的通畅。如何布置网络才能不出现割点、且部署的节点最少？

## 1.1 无向连通图中割点计数或输出
### 1.1.1 算法思路和示例
要计算在一个无向连通图G中有多少个割点，最简单的就是暴力方法：删除每个点，然后用DFS求连通性，如果连通分量变多，那么就是割点。时间复杂度为 $O(V (V+E))$ ，不是一个好算法。

为此，介绍用DFS求割点的算法，即利用**深度优先搜索生成树**求割点——在一个连通分量 $G$ 中对任意一个点 $s$ 做DFS，能访问到所有点，产生一棵**深度优先搜索生成树** $T$ 。显然，**深度优先搜索生成树**的形式并不唯一，但是确定的割点始终相同。原因在于以下两个定理：
- **$T$ 的根节点 $s$ 是割点，当且仅当 $s$ 有两个或更多的子节点**。显然，如果 $s$ 是割点，删除它会把图分成互不相连的几个部分，这几个部分都会生成子树；如果 $s$ 不是割点，它就只应该连接一个子树。
- **$T$ 的非根节点 $u$ 是割点，当且仅当 $u$ 存在一个子节点 $v$ ，$v$ 及其后代都没有回退边连回 $u$ 的祖先**。显然，如果 $u$ 是割点，它会把图分成两部分或更多，因此至少有一个后代节点，肯定没有通过其他边（回退边，即绕过 $u$ 回去的边）连回 $u$ 的祖先，否则图就不会被分开了。

以左图为例，对点 $a$ 进行DFS得到的生成树为右图：
```perl
graph cut_vertex {
    node[shape = circle]

    a -- {b; c; d};
    c -- {d; e};
    d -- f;
    e -- f;
    e -- g;
}

digraph dfs_tree { 
    node[shape = circle]
    node [shape = doublecircle]; a
    size = "8, 5"
    node [shape = circle];
    a -> b;
    a -> c;
    d -> a[style=dotted];
    d -> c[style=dotted];
    c -> e;
    e -> {f, g};
    f -> d;
}
```
右图中节点边红色的数字是递归的顺序，黑色的数字是递归返回的顺序。从图中易知：
- 根节点 $a$ 是割点，因为它有两个子节点；
- $b$ 不是割点，它没有子节点（如果用 $b$ 生成树，它只有一个子节点 $a$）；
- $c$ 不是割点，它的子节点只有 $e$ ，$e$ 有一个后代节点 $d$ ，$d$ 存在回退边连回到根节点 $a$ ；
- $d$ 不是割点，它没有子节点；
- $e$ 是割点，因为它有一个子节点 $g$ ，没有回退边连回 $e$ 的祖先；
- $f$ 也不是割点，原因同 $c$ ；
- $g$ 不是割点，原因同 $d$（如果用 $g$ 生成树，它只有一个子节点 $e$）
<img src="https://img-blog.csdnimg.cn/2decee51f813495a970098646a8cb607.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="60%">
 
### 1.1.2 割点算法实现
如何编程实现这两个定理？具体来说，先定义值 `dfn = 0` 和数组 `num` 和 `low` ，`dfn` 值逐个节点计数、记录递归访问的顺序（即**时间戳**），`num[]` 记录DFS对每个节点的访问顺序（即当时的 `dfn` 值），`low[]` 记录每个节点和该节点的后代能连回的所有祖先节点中、最小的（即按照访问顺序最先访问的）的 `num[]` 值。需要注意的是，**任一节点 `i` 的 `low[i]` 初始值等于 `num[i]` ，即连回到自己**。

设节点 `u` 的一个直接后代是 `v` ，则 `nums[u]` 等于第一次访问到 `u` 时的 `dfn` 值，`low[v]` 表示 `u` 的子节点 `v` 和 `v` 的后代节点能够连回的所有祖先节点中、最小的 `num[]` 值。从而对于求割点，只要 `low[v] >= num[u]` ，就说明**在 `v` 这条支路上， `v` 及其后代都没有回退边连回 `u` 的祖先，最多回退到 `u`**，即 `T` 的非根节点 `u` 是割点（只要存在这样的一条支路即可）。

以下图（有或没有回退边的图）为例，说明算法的实际运行过程，此处主要涉及到**非根节点是割点的判断**：
- 左图没有回退边。`a, b, c, d` 的 `num[]` 值分别为 `1, 2, 3, 4` ，`low[]` 初始值也为 `1, 2, 3, 4` 。由于没有回退边，`low[]` 的值没有被更新，则有 `low[c] >= num[b], low[d] = num[c]` ，即 `b, c` 的支路上都没有回退边连回各自的祖先，所以 `b, c` 都是割点。注意，**即使 `low[b] >= num[a]` ，根节点 `a` 也不是割点，因为它只有一个子节点**；
- 右图存在回退边。`a, b, c, d` 的 `num[]` 值分别为 `1, 2, 3, 4` ，`low[]` 初始值也为 `1, 2, 3, 4` 。由于有一条回退边 `d -> b` ，`low[]` 的值被更新了：
	- 最后访问的 `d` 是递归最深处的点，`num[d] = 4` ，它有回退边到 `b` 。`low[d]` 的初始值为 `4` ，更新为 `low[d] = num[b] = 2` ，表示 `d` 可以回退到 `b` ；
	- 然后 `d` 递归返回到 `c` ，`low[c]` 更新为 `low[c] = low[d] = 2` ，表示 `c` 通过后代节点能回退到 `b` 。
	- 同上，根节点 `a` 不是割点。由于 `low[c] >= num[b]` ，即 `b` 的支路上没有回退边连回到祖先，所以 `b` 是割点。由于 `low[d] = 2 < num[c] = 3` ，说明 `c` 的后代 `d` 有回退边连到了 `c` 的祖先，所以 `c` 不是割点。
<img src="https://img-blog.csdnimg.cn/b92348b0b58048efa2392bf690be950a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="60%">

https://www.zhihu.com/question/65155704

## 1.2 无向连通图中割边计数或输出
### 1.2.1 割点算法简单修改
只要简单修改上述判断割点的条件 `low[v] >= num[u]` 为 `low[v] > num[u]` ，就能用于**判断割边**，这表示 **`u` 的支路 `v` 及 `v` 的后代只能回退到 `v` 、回退不到 `u` 、更别说 `u` 的祖先了**，那么边 `(u, v)` 肯定就是割边。例如下右图中的节点 `b` ，有 `low[c] = 2, num[b] = 2` ，说明 `(b, c)` 不是割边；再看节点 `a` ，有 `low[b] = 2, num[a] = 1, low[b] >= num[a]` ，所以 `(a, b)` 是割边。
<img src="https://img-blog.csdnimg.cn/b92348b0b58048efa2392bf690be950a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="60%">

### 1.2.2 割边算法实现

---
# 2. 双连通分量（无向连通图）
在一个无向连通图中任选两点，如果它们之间至少存在两条**点不重复**的路径，称为**点双连通**。一个图中的**点双连通极大子图**称为**点双连通分量** `block, or 2-connected component` 。类似地，在一个无向连通图中任选两点，如果它们之间至少存在两条**边不重复**的路径，称为**边双连通**。一个图中的**边双连通极大子图**称为**边双连通分量**。

为什么学习完割点/割边后，要顺便学习点/边双连通分量？由它们的定义可知，点双连通分量是一个可靠的图，去掉任何一个点，其他点仍然连通，即**点双连通分量中没有割点**；边双连通分量中，去掉任何一条边，其他点仍然连通，即**边双连通分量中没有割边**。于是，点双连通分量和割点有关，边双连通分量和割边有关。

## 2.1 点双连通分量Tarjan's BCCs algorithm（Tarjan双连通分量算法）
给定一个图 $G$ ，如何计算其中点双连通分量的个数、输出所有点双连通分量？

### 2.1.1 点双连通分量算法思路
有了割点的概念，这一题就很简单了。**不同的点双连通分量最多只有一个公共点，即某个割点**。从而有这一结论：**任意一个割点都是至少两个点双连通分量的公共点**。

于是在用DFS进行割点计算时，可以发现，**在找到一个割点时，就已经完成了一次对某个极大点双连通子图的访问**。因此在DFS过程中，把遍历过的边保存下来就可以得到这个点双连通分量——具体来说，在求解割点时，**用一个栈保存遍历过的边**，每当找到一个割点、即满足关系 `low[v] >= num[u]` 的点 `u` ，就将栈中的边取出。

再三强调，**放入栈中的不是点、而是边**——因为一条边只属于一个点双连通分量，而一个割点属于多个点双连通分量，如果入栈的是点，这个割点弹出后就只能给一个点双连通分量，它连接的其他点双连通分量就会少了这个点。

### 2.1.2 点双连通分量算法实现
## 2.2 边双连通分量Tarjan's BCCs algorithm（Tarjan双连通分量算法）
给定一个图 $G$ ，如何计算其中边双连通分量的个数、输出所有边双连通分量？至少应该添加多少边，才能使任意两个边双连通分量之间都是双连通的，即令 $G$ 是双连通的？

### 2.2.1 边双连通分量算法思路
正如无向连通图中**求点双连通分量**和**求割点**密切相关一样，无向连通图中**求边双连通分量**也和**求割边**密切相关。具体来说，首先找出图 $G$ 中的所有边双连通分量——DFS时图 $G$ 中所有点都生成一个 `low` 值，**`low` 值相同的点必定在同一个边双连通分量中**。DFS结束后，有多少 `low` 值就有多少边双连通分量。如果只是计数和输出，到此为止就可以了。

否则，运用**缩点**技术，把每个边双连通分量都看做一个点，即把那些 `low` 值相同的点合并为一个**缩点**，**这些缩点将形成一棵树**（想想为什么？）。接着问题转换为：至少应在缩点树上增加多少边才能使这棵树变为一个双连通图。容易发现，**至少增加的边数=(总度数为1的缩点数 + 1) / 2**。以下图为例，有两个度为1的缩点 `A, C` ，所以至少应该增加的边数为 `(2 + 1) / 2 = 1` 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/68cee62dca78497091071265cb305c26.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbWVtY3B5MA==,size_20,color_FFFFFF,t_70,g_se,x_16)

---
# 3. 强连通分量（有向连通图）

## 3.1 Kosaraju算法
罗伯特·恩卓·塔扬（英语：Robert Endre Tarjan，1948年4月30日－），生于美国加州波莫纳，计算机科学家，为1986年图灵奖得主。他发现了解决最近公共祖先（LCA）问题、强连通分量问题、双连通分量问题的高效算法，参与了开发斐波那契堆、伸展树，分析并查集的工作。不少他发明的算法都以他的名字命名，以至于有时会让人混淆几种不同的算法。 

## 3.2 Tarjan's SCCs algorithm（Tarjan强连通分量算法）

[Tarjan大佬发明的众多算法](https://dblp.dagstuhl.de/pid/t/RobertEndreTarjan.html)

 

毫无疑问，Tarjan算法也是 $O(V +E)$ ，但是它只做了一次DFS，比Kosaraju算法快。

## 3.3 Garbow算法

## 3.4 强连通分量应用
 最大团（Maximum Clique Problem, MCP）简单题目，强连通分量的一个应用
 2-SAT：拓扑排序和强连通分量

---
# 5. 各大OJ经典题目
| 题目链接  | 题目类型  | 题解链接 |
|:---|:---|:---
| [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)
| [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)
|POJ 1144 network | 割点
| POJ 1523 SPF | 点双连通分量
|POJ 3352 Road Construction | 边双连通分量
|HDU 4587 TWO NODES | 无向图求割点
| HDU 3394 Railway | 点双连通分量
| HDU 3749 Financial Crisis | 点双连通分量
| HDU 2460 Network | 边双连通分量
| HDU 1827 Summer Holiday | Tarjan 缩点
| HDU 3072 Intelligence System | Tarjan+贪心
| HDU 3836 Equivalent Sets | 给定有向图，至少要添加多少边才能成为强连通图
| HDU 3639 Hawk-and-Chicken | 强连通分量+缩点
| HDU 3861 The King's Problem | Tarjan+最小路径覆盖
| HDU 1530 Maximum Clique | 最大团简单题目
| [P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G](https://www.luogu.com.cn/problem/P2341)
| [P2863 [USACO06JAN]The Cow Prom S](https://www.luogu.com.cn/problem/P2863)
| [P1726 上白泽慧音](https://www.luogu.com.cn/problem/P1726)
| [P2746 [USACO5.3]校园网Network of Schools](https://www.luogu.com.cn/problem/P2746)
| [P5022 [NOIP2018 提高组] 旅行](https://www.luogu.com.cn/problem/P5022)
| [P1262 间谍网络](https://www.luogu.com.cn/problem/P1262)


算法学习笔记() 平衡树之AVL树
https://editor.csdn.net/md/?articleId=107943759
算法学习笔记() 平衡树之替罪羊树
https://editor.csdn.net/md/?articleId=107924986
算法学习笔记() 平衡树之FHQ Treap树(无旋Treap)
https://editor.csdn.net/md/?articleId=107924345
算法学习笔记() 平衡树之Treap
https://editor.csdn.net/md/?articleId=107948539
算法学习笔记() 平衡树之Splay（伸展树和自顶向下伸展树）
https://editor.csdn.net/md/?articleId=107919037
算法学习笔记() 平衡树之红黑树
https://editor.csdn.net/md/?articleId=107943780
