@[toc]

---
后缀树和后缀数组理解起来比较困难，但是**可以解决大部分字符串问题**，如字符串匹配类的**查找子串**、**最长重复子串**、**最长公共子串**等，都可以用后缀数组解决。

---
# 1. 概念：后缀、后缀树和后缀数组 
**后缀** `suffix` ：一个字符串，它的后缀是**从某个位置开始到末尾**的一个**子串**。如 `s = "vamamadn"` ，其后缀有 $8$ 个，即 `s[0] = "vamamadn", s[1] = amamadn, s[2] = mamadn, ...` 等等，具体见后面。

**后缀树** `suffix tree` ：我们之前提到过**字典树**或者说**前缀树**，它按照多个字符串的公共前缀来建树。那么顾名思义，后缀树是按照多个字符串的公共后缀建树的吗？非也，这种做法只不过是前缀树的平凡扩展，根本不值得专门提到。我们所说的**后缀树**，是指：借用字典树的方法将一个字符串的**所有后缀子串**建成一棵**前缀树**。

**后缀数组** `suffix array` ：由于直接对后缀树构造和编程不太容易，所以采用后缀数组这种简单的方法来替代它。

为了详细说明这几个概念，用上面的例子 `s = "vamamadn"` 。它的后缀如下表：
| 后缀 `s[i:-1]` | 下标 `i` | 
|:--:|:--:|
| `"vamamadn"` | $0$ |
| `"amamadn"` | $1$ |
| `"mamadn"` | $2$ |
| `"amadn"` | $3$ |
| `"madn"` | $4$ |
| `"adn"` | $5$ |
| `"dn"` | $6$ |
| `"n"` | $7$ |

如下图所示，将这些后缀子串按照字典树的方法建立起一棵树，**根结点为空**，**符号 `$` 表示一个后缀子串的末尾**。**后缀树的优势**在于，如果我们利用后缀树查找某个子串如 `"mam"` ，只需要从根结点出发查 $3$ 次即可：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200901225818154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70 )
为了简化后缀树的构造和使用，我们考虑后缀数组——显然，沿着后缀树进行先序遍历，得到的是**一个字典序升序的后缀子串序列**。我们依次取出这些后缀子串的开始位置下标，组成的序列就是后缀数组——**按照字典序对应的后缀子串首字符下标序列**：
| 后缀 `s[i:-1]` | 后缀子串首字符下标 `i` |  -  | 字典序升序  | 后缀数组 `sa[]` | 后缀数组下标 `j` |
|:--:|:--:|:--:|:--:|:--:|:---:|
| `"vamamadn"` | $0$ |-  |  `"adn"`  | $5$  | $0$
| `"amamadn"` | $1$ |- | `"amadn"` | $3$ |  $1$
| `"mamadn"` | $2$ |  - | `"amamadn"` | $1$ | $2$
| `"amadn"` | $3$ | - | `"dn"` | $6$ |  $3$ 
| `"madn"` | $4$ | - | `"madn"` | $4$ | $4$
| `"adn"` | $5$ |  - | `"mamadn"` | $2$ | $5$
| `"dn"` | $6$ |- | `"n"` | $7$ | $6$
| `"n"` | $7$ | - | `"vamamadn"` | $0$ | $7$

**后缀数组的数字顺序，就是后缀子串的字典顺序**，它记录了子串的有序排列。如 `sa[0] = 5` 表示排名 $0$ 的字典序最小的后缀子串，是原字符串中从第 $5$ 个位置开始的后缀子串 `"adn"` 。

---
# 2. 后缀数组的应用1：单模匹配问题
假设我们得到了一个文本串 `s` 的后缀数组 `sa[]` ，要在文本串 `s` 中查找某个模式子串 `t` 。用KMP算法可以在 $O(n + m)$ 的时间复杂度解决问题。

使用后缀数组则稍慢一些，需要 $O(m\log n)$ 的时间复杂度，$n,m$ 分别是模式串和文本串的长度。如果算上求出后缀数组的时间，总的复杂度也就是 $O(n\log_2n + m\log_2 n)$ ，这很高效了。如果直接使用后缀树，建树的复杂度是 $O(mn)$ ，树上查找一个子串只需要比较 $m$ 次，复杂度是 $O(m)$ ，就更快了。

对比两者可以发现，后缀树用空间换时间，一次建树多次查找，复杂度很好；后缀数组虽然复杂度差一点，但是使用的空间少，编码简短。所以**一般使用后缀数组**。

具体到本题，做法是：**在后缀数组 `sa[]` 上二分搜索**，就能很快找到子串。比如在母串 `"vamamadn"` 中查找子串 `"ad"` ，代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

int find(const string &s, const string &t, int *sa) { //在s中查找t,sa是s的后缀数组 
	int i = 0, j = s.size();
	while (j - i > 1) {
		int k = (i + j) / 2;						  //二分法 
		if (s.compare(sa[k], t.size(), t) < 0) i = k; //匹配一次复杂度O(n)	
		else j = k;
	}
	if (s.compare(sa[j], t.size(), t) == 0) 		  //找到了,返回t在s中的位置
		return sa[j];
	if (s.compare(sa[i], t.size(), t) == 0)
		return sa[i];
	return -1;										  //没找到 
}

int main() { 
	string s = "vamamadn", t = "ad"; 				  //母串和子串
	int sa[] = {5, 3, 1, 6, 4, 2, 7, 0};
	int location = find(s, t, sa);
	cout << location << ":" << &s[location] << endl;  //打印t在s中的位置 
    return 0;
}
```
运行如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200901235002526.png)

现在最关键的问题是：我们**如何高效地计算出后缀数组**，这等同于说：**如何高效地对后缀子串进行排序**，简称**后缀排序**。为此，需要有**倍增**的前导知识。
