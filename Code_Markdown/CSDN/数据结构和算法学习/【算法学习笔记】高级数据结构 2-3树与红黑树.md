> 参考算法导论第13章 红黑树
> 红黑树可视化： https://www.cs.usfca.edu/~galles/visualization/RedBlack.html 
> 左倾红黑树论文： Left-leaning Red-Black Trees
![700](https://img-blog.csdnimg.cn/85139fa29d004bc4aeacda275914eaa8.png)

@[toc]

（算导第12章）我们学习过一棵高度为 $h$ 的二叉搜索树，它可以支持**任何一种基本动态集合操作**，如 `SEARCH, PREDECESSOR, SUCCESSOR, MINIMUM, MAXIMUM, INSERT, DELETE` 等，其时间复杂度均为 $O(h)$ 。因此，如果搜索树的高度较低时，这些集合操作会执行得较快。然而，如果树的高度较高时，这些集合操作可能并不比在链表上执行得快。

**红黑树** `red-black tree` 则是许多平衡搜索树中的一种，可以保证在最坏情况下，基本动态集合操作的时间复杂度为 $O(\log n)$ 。

**数据结构与算法、设计模式，是每一个程序员成长过程中的内功心法修炼**，而你的新技能用的再绚、多线程使的再 6、加锁玩的再牛🐂，也只能说明你这个人身 体好，但身体好是不能抗住子弹的。只有身体+心法都好，都能纵横捭阖。

这一章是结合 HashMap 的延展，在 Jdk1.8 中 **HashMap 是使用桶数组+链表和红黑树**实现，所以顺着上一章节的核心原理和 API 功能讲解后，本来这一章节想直接进入到红黑树，但如果想把红黑树学明白，就需要了解他的来龙去脉，也就是它 的**前身 2-3 树**。

面试中，竟然会听👂到的是：从 HashMap 中文红黑树、 从数据库索引为 B+Tree，但问 2-3 树的情况就不是很多了

从最根本的原因来看，使用树结构就是为了提升整体的效率；插入、删除、查找 (索引)，尤其是索引操作。因为相比于链表，一个平衡树的索引时间复杂度是 O(logn)，而数组的索引时间复杂度是 O(n)。
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030107923.png)
从上图可以看到，使用树结构有效的降低时间复杂度，提升数据索引效率。 另外这个标准的树结构，是二叉搜索树(Binary Search Tree)。除此之外树形结构还 有；AVL 树、红黑树、2-3 树等。

在树的数据结构中，最先的是二叉查找树，也就是英文缩写 BST 树。在使用数 据插入的过程中，理想情况下它是一个平衡的二叉树，但实际上可能会出现二叉 树都一边倒，让二叉树像列表一样的数据结构。从而树形结构的时间复杂度也从 O(logn)升级到 O(n)，

二叉搜索树的数据插入过程是，插入节点与当前树节点做比对，小于在左，大于在 右。 
- 随着数据的插入顺序不同，就会出现完全不同的数据结构。可能是一棵平衡二叉 树，也极有可能退化成链表的树。 
- 当树结构退化成链表以后，整个树索引的性能也跟着退化成链表。
- 综上呢，如果我们希望在插入数据后又保持树的特点，O(logn)的索引性能，那 么就**需要在插入时进行节点的调整**
# 1. 什么是2-3树、2-3 树解决平衡问题
 2-3 树是什么结构，它怎么解决平衡问题的。带着问题我们继续 。

2-3 树是一种非常巧妙的结构，==在保持树结构的基础上，它允许在一个节点中可 以有两个元素，等元素数量等于 3 个时候再进行调整==。通过这种方式呢，来保证 整个二叉搜索树的平衡性。 这样说可能还没有感觉，来看下图；
![500左侧是二叉搜索树，右侧是 2-3 平衡树，分别插入节点 4、5，观察树形结构变 化。  二叉搜索树开始出现偏移，节点一遍倒。  2-3 树通过一个节点中存放 2 到 3 个元素，来调整树形结构，保持平衡。所谓的保 持平衡就是从根节点，到每一个最底部的自己点，链路长度一致。 2-3 树已经可以解决平衡问题那么，数据是怎么存放和调整的呢，接下来我们开 始分析。](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030112466.png)
- 左侧是二叉搜索树，右侧是 2-3 平衡树，分别插入节点 4、5，观察树形结构变 化。 
- 二叉搜索树开始出现偏移，节点一遍倒。 
- 2-3 树通过一个节点中存放 2 到 3 个元素，来调整树形结构，保持平衡。==所谓的保 持平衡就是从根节点，到每一个最底部的自己点，链路长度一致==。

2-3 树已经可以解决平衡问题。**那么，数据是怎么存放和调整的呢**，接下来我们开 始分析。
# 2. 2-3树使用
## 2.1 树结构定义和特点性质（三种形态）
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030116274.png)
综上我们可以总结出，2-3 树的一些性质； 
1. **2-3 树所有子叶节点都在同一层** 
2. ==1 个节点可以有 1 到 2 个数据，如果有三个需要调整树结构== 
3. 1 个节点 1 个数据时，则有两个子节点 
4. 1 个节点 2 个数据时，则有三个子节点，且**中间子节点是介于两个节点间的值**

## 2.2 数据插入
接下来我们就模拟在二叉搜索树中退化成链表的数据，插入到 2-3 树的变化过 程，数据包括；1、2、3、4、5、6、7，插入过程图如下；
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030125159.png)
以上，就是整个数据在插入过程中，2-3 树的演化过程，接下来我们具体讲解每 一步的变化； 
1. α，向节点 1 插入数据 2，此时为了保持平衡，不会新产生分支，只会在一个节点 中存放两个节点。 
2. β，继续插入数据 3，**此时这个节点有三数据，1、2、3，是一个临时区域**。 
3. γ，把三个数据的节点，中间节点拉起来，调整成树形结构。
4. δ，继续插入数据 4，为了保持树平衡，会插在节点 3 的右侧。 
5. ε，继续插入数据 5，插入后 3、4、5 共用 1 个节点，**当一个节点上有三个数据时 候，则需要进行调整**。 
6. ζ，中间节点 4 向上 调整，调整后，1 节点在左、3 节点在中间、5 节点在右。 
7. η ，继续插入数据 6，在保持树平衡的情况下，与节点 5 公用。 
8. θ ，继续插入数据 7，插入后，节点 7 会与当前的节点 5 6 共用。**此时是一个临时存放，需要调整**。初步调整后，抽出 6 节点，向上存放，变为 2 4 6 共用一个 节点，**这是一个临时状态，还需要继续调整**。 
9. ι，因为根节点有三个数据 2、4、6，则继续需要把中间节点上移，1、3 和 5、7 则分别成二叉落到节点 2、节点 6 上。

## 2.3 数据删除
有了上面数据插入的学习，**看数据删除其实就是一个逆向的过程**（下图和上图是相反的），在删除的主要包括这样两种情况； 
1. 删除叶子 3-节点的元素，也就是包含两个数据元素的节点，**直接删除即可**，不会破坏树平 衡。 
2. ==删除叶子 2-节点的元素，此时会破坏树平衡，需要将树高缩短或者元素合并，恢复树平 衡==。

承接上面👆的例子，我们把数据再从 7、6、5、4、3、2、1 顺序删除，观察 2-3 树 的结构变化，如下；
1. α，删除节点 7，因为节点 7 只有一个数据元素，删除节点后 **5、6 合并**，但**此时破 坏了 2-3 树的平衡性**，需要**缩短树高**进行调整。 
2. β，因为删除节点后，整个树结构不平衡，所以需要缩短树高，调整元素。**节点 2、4 合并**，节点 1、3 分别插入左侧和中间。 
3. γ，删除节点 6，这个节点是 3-节点(可以分出 3 个叉的意思)，删除后不会破坏树 平衡，保持不变。 
4. δ，删除节点 5，此时会破坏树平衡，需要**把节点 4 下放，与 3 合并**。
5. ε，删除节点 4，这个节点依旧是 3-节点，所以不需要改变树结构。 
6. ζ，删除节点 3，此时**只有 1、2 节点，需要合并**。 
7. η ，删除节点 2，此时节点依旧是 3-节点，所以不需要改变树结构。
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030220260.png)

再看一个复杂点的2-3树删除：
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030226134.png)
上面👆这张图，就一个稍微复杂点的 2-3 平衡树，树的删除过程主要包括：
1. 删除 4，其实需要将节点 3、5 合并，指向节点 2，保持树平衡。 
2. 删除 7，节点 8、9 合并。 
3. 删除 14，节点 15 上移，恢复成 3-叉树。 

==如果有时候不好理解删除，可以试想下，**这个要删除的节点，在插入的时候是 一个什么效果**==。

## 2.4 数据索引 
相比于插入和删除，索引的过程还是比较简单的，**不需要调整数据结果**。基本原 则就是； 
1. 小于当前节点值，左侧寻找 
2. 大于当前节点值，右侧寻找 
3. 一直到找到索引值，停止。

![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030232529.png)
# 3. 总结
综上讲解了 2-3 树🌲的核心内容，通过本章学习，可以了解 2-3 树是一种怎样 的数据结构、**如何插入数据、删除数据**以及数据的索引，同时要知道**这是一种平衡 树的结构**，包括 **2-叉和 3-叉节点**以及**结构随着数据的添加删除调整**。 

**2-3 树是红黑树的演变前身**，通过这一章节的学习就很容易学习红黑树的相关知 识，**在红黑树中添加数据进行的渲染、旋转等来保持树平衡**。红黑树接近平衡

---
# 0. 面试题 
谢飞机，考你几个红黑树的知识点 
1. 红黑树的数据结构都用在哪些场景，有什么好处？
2. 红黑树的时间复杂度是多少？ 
3. 红黑树中插入新的节点时怎么保持平衡？ 

飞机，2-3 树是不没看，回去等消息吧！

---
# 1. 红黑树的性质-一种高效的自平衡二叉查找树
Rudolf Bayer 于 1978 年发明红黑树，在当时被称为对称二叉 B 树(symmetric binary B-trees)。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修 改为如今的红黑树。 **红黑树具有良好的效率，它可在近似 O(logN) 时间复杂度下完成插入、删除、查 找等操作**，因此红黑树在业界也被广泛应用，比如 Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基于红黑树结构实现的。 

红黑树是一棵二叉搜索树，它在每个结点上增加了一个存储位来表示结点的**颜色**，可以是 `RED` 或 `BLACK` 。==通过对「任何一条从根到叶的简单路径」上各个结点的颜色进行约束，红黑树确保：没有一条路径会比其他路径长出 $2$ 倍，因而是近似于**平衡的**==。
> AVL树的最为强大而流行的变种，就是红黑树，对它的操作即使在最坏的情形下也只花费 $\text{O(logN)}$ 时间。而且相比AVL树来说，红黑树对插入操作的一种非递归实现将更容易完成。

**死记硬背，很难学会** 

**红黑树的结构和设计都非常优秀**，也同样在实现上有着复杂的处理逻辑，包括插 入或者删除节点时；颜色变化、旋转操作等操作。但==如果只把这些知识点硬背下 来，什么时候染色、什么时候旋转，是没有多大意义的，用不了多久也就忘记了。 所以这部分的学习，了解其根本更重要==。 

## 1.1 红黑树性质
树中每个结点包含五个属性：$color,\ key,\ left,\ right,\ p$（**==红黑树结点要有父结点！==**）。如果一个结点没有子节点或**父结点**，则该结点相应指针属性的值为 `NULL` 。**我们可以把这些 `NULL` 视为「指向二叉搜索树的叶结点（外部结点）的指针」，而把带关键字的结点视为树的内部结点**。

一棵红黑树是满足下列**红黑性质** `red-black properties` 的二叉搜索树：
1. 每个结点或是红色的，或是黑色的。
2. 根结点是黑色的。
3. 每个叶结点 `NULL` 是黑色的。
4. 如果一个结点是红色的，则它的两个子结点都是黑色的。
5. **对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑结点**。---这一着色规则的结论使得红黑树的高度最多是 $2\log(N+1)$ 

图13-1(a)显示了一个红黑树的例子。**为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 `NULL`**（参见算导10.2节）。对于一棵红黑树，==哨兵 $T.nil$ 是一个与树中普通结点有相同属性的对象，它的 $color = \textrm{BLACK}$ ，而其他属性 $p,\ left,\ right,\ key$ 可以设置为任意值==。如图13-1(b)所示，所有指向 `NULL` 的指针都用「指向哨兵 $T.nil$ 的指针」替换。
- **使用哨兵后，就可将结点 $x$ 的 `NULL` 孩子视为一个普通结点，其父结点为 $x$** 。
- 尽管可以为树内的每个 `NULL` 新增一个不同的哨兵结点，使得每个 `NULL` 的父结点都有这样的良定义，但这种做法会浪费空间。
- 取而代之的是，**使用一个哨兵 $T.nil$ 来代表所有的 `NULL` ：所有的叶结点和根结点的父结点** `all leaves and the root’s parent` 。
- 哨兵的属性 $p,\ left,\ right,\ key$ 的取值并不重要，尽管为了方便起见，可以在程序中设定它们。

我们通常将注意力放在红黑树的内部结点上，因为它们存储了关键字的值。后面所画的红黑树都忽略了叶结点，如图13-1 c)所示。
![700](https://img-blog.csdnimg.cn/46b12f7920bb4319acc4a1a7b4eb804d.png)
==从某个结点 $x$ 出发（不含该结点）到达一个后代叶结点的、任意一条简单路径上的黑结点个数，称为该结点的**黑高**== `black-height` ，记为 $bh(x)$ ，`NULL` 的黑高为 $0$ 。根据性质 $5$ ，黑高的概念是明确定义的，因为从该结点出发的、所有下降到其叶结点的简单路径的黑结点个数都相同，于是定义**红黑树的黑高为其根结点的黑高**。我们考虑一个有两个子结点的内部结点 $x$ ，可想而知：
- **$x$ 子结点的颜色会影响其黑高**：==子结点为黑色时，则其黑高必为 $bh(x) - 1$（子结点被记入 $x$ 的黑高中）；子结点为红色时，则其黑高必为 $bh(x)$（子结点不计入 $x$ 的黑高中）==。
- 此外，**$x$ 为红色还是黑色，也会影响到子结点的黑高**，==如果 $x$ 为红色，则根据性质 $4$ ，两个子结点都为黑色，子结点的黑高都为 $bh(x) - 1$ ；否则子结点的黑高不一定相等==。

下面的引理说明了，为什么红黑树是一种好的搜索树。
## 1.2 为什么红黑树是一种好的搜索树-引理证明
**引理13.1** 一棵有 $n$ 个内部结点的红黑树的高度至多为 $2 \log (n+1)$ 。
**证明**：先证明 **「以任一结点 $x$ 为根的子树」中至少包含 $2^{bh(x)} - 1$ 个内部结点**。要证明这点，对 $x$ 的高度进行归纳。
- **如果 $x$ 的高度为 $0$ ，则 $x$ 必为叶结点 $T.nil$** ，且以 $x$ 为根结点的子树至少包含 $2^{bh(x) } - 1 = 2^0 - 1 = 0$ 个内部结点。
- 对于**归纳步骤**，考虑一个「高度为正值、且有两个子结点的内部结点 $x$ 」，据前文可知，每个子结点有黑高 $bh(x)$ 或 $bh(x) - 1$ ，其分别取决于自身的颜色是红还是黑。由于 $x$ 子结点的高度比 $x$ 本身的高度要低，可以利用归纳假设得出，**每个子结点至少有 $2^{bh(x) - 1} - 1$ 个内部结点的结论**。
- 于是，以 $x$ 为根的子树至少包含 $(2^{bh(x) - 1} - 1) + (2^{bh(x) - 1} - 1) + 1 = 2^{bh(x) } - 1$ 个内部结点，因此得证。

为完成引理的证明，设 $h$ 为树的高度。根据性质 $4$ ，**从根到叶结点（不包括根结点）的任何一条简单路径上，都至少有一半的结点为黑色**（为什么？仔细想一下，有红结点则必有黑结点，反之则不然，于是黑结点的个数至少等于红结点个数）。因此，**根的黑高至少为 $h/ 2$**（树的黑高不包含黑色的根结点——前文）；于是整棵红黑树至少包含 $2^{h / 2} - 1$ 个内部结点：$$n \ge 2^{h/2} - 1$$ 把 $1$ 移到不等式的左边，再对两边取对数，得到 $\log(n + 1) \ge h / 2$ ，或者 $h \le 2 \log(n+1)$ 。$\blacksquare$

由该引理可知，动态集合操作 `SEARCH, MINIMUM, MAXIMUM, SUCCESSOR, PREDECESSOR` 可在红黑树上以 $O(\log n)$ 时间执行，==因为这些操作在一棵高度为 $h$ 的二叉搜索树上的运行时间为 $O(h)$ ，而任何包含 $n$ 个结点的红黑树又都是高度为 $O(\log n)$ 的二叉搜索树（当然，在算导12章算法中对 `NULL` 的引用必须用 $T.nil$ 来代替）==。

虽然当给定一棵红黑树作为输入时，（算导第12章的算法）`TREE-INSERT, TREE-DELETE` 的运行时间为 $O(\log n)$ ，但这两个算法并不直接支持动态集合操作 `INSERT, DELETE` ，因为==它们并不能保证「被这些操作修改过的二叉搜索树」仍是红黑树==。那么如何在时间 $O(\log n)$ 内支持这两个操作呢（见算导13.3和13.4节）？

---
# 2. 2-3树与红黑树
之前使用了大量图例讲解了 2-3 树，并在标题处写出**它是红黑树的前身**。 阅读后更容易理解红黑树相关知识。 对于红黑树的五条性质：
1. 根节点是黑色 
2. 节点是红色或者黑色 
3. 所有子叶节点都是黑色(叶子是 NIL 节点，默认没有画出来)
4. **每个红色结点必须有两个黑色子结点**（同样说明一条链路上不能有相邻的红色结点）
5. 黑高，从任一节点到每个叶子结点，经过的路径都**包含相同数目的黑色结点**

我们已经知道这些性质有什么用（其一是用于证明时间复杂度；其二是操作中遵循），那**这些规则是怎么总结定义出来的呢**？接下来我们**一步步分析讲解**。我们在旋转和染色时，又是如何操作的（对应2-3树）呢？
## 2.1 为什么既有 2-3 树要有红黑树 
首先 2-3 树就是一个节点有 1 个或者 2 个元素，而==实际上 2-3 树 转红黑树是由概念模型 2-3-4 树转换而来的==。-4 叉就是一个节点里有 3 个元素， **这在 2-3 树中会被调整，但是在概念模型中是会被保留的**。 

虽然 ==2-3-4 树也是具备 2-3 树同样的平衡树的特性，但是如果直接把这样的模型 用代码实现就会很麻烦，且效率不高==，这里的复杂点包括； 
1. 2-叉、3-叉、4-叉，三种结构的节点类型，**互相转换复杂度较高** 
2. 3-叉、4-叉，**节点在数据比较上需要进行多次**，不像 2-叉节点，直接布尔类型比较即可，非左即右 
3. 代码实现上对每种差异，都需要有额外的代码，规则不够标准化 

所以，**希望找到一种平衡关系，既保持 2-3 树平衡和 O(logn)的特性，又能在代码实现上更加方便，那么就诞生了红黑树**。 
## 2.3 等价性：简单 2-3 树转红黑树（乱七八糟） 
2-3 树转红黑树，也可以说==**红黑树是 2-3 树和 2-3-4 树的另外一种表现形式**，也就 是**更利于编码实现的形式**==。
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030240851.png)
从上图可以看出，2-3-4 树与红黑树的转换关系，包括； 
1. **2-叉节点，转换比较简单，只是把原有节点转换为黑色节点** 
2. 3-叉节点，包括了 2 个元素，先用红色线把两个节点相连，之后拆分出来，最后调 整高度，黑色节点在上 
3. 4-叉节点，包括了 3 个元素，分别用红黑线连接，之后拆分出来拉升高度。这个拉 升过程和 2-3 树调整一致，只是添加了颜色 

综上，就是 2-3-4 树的节点转换，总结出来的规则，如下； 
1. **将 2-3-4 树，用二叉树的形式表示** 
2. 3-叉、4-叉节点，使用红色、黑色连线进行连接 
3. 另外，**3-叉节点有两种情况，导致转换成二叉树，就有左倾和右倾**
4. ~~根必须为黑，叶子NULL结点为黑，红结点有两个黑NULL结点~~

## 2.4 等价性：复杂2-3树转红黑树 
在简单 2-3 树转换红黑树的过程中，了解到一个基本的转换规则——**右倾定义**，接下来 我们在一个稍微复杂一点的 2-3 树与红黑树的对应关系，如下图；
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030309345.png)
上图是一个稍微复杂点的 2-3 树，转换为红黑树的过程，是不这样一张图让你对 红黑树更有感觉了，同时它也满足一下条件； 
1. **从任意节点到叶子节点，所经过的黑色节点数目相同** 
2. ==黑色节点保持着整体的平衡性，也就是让整个红黑树接近于 O(logn)时间复杂度== 
3. 其他红黑树的特点也都满足，可以对照红黑树的特性进行比对

---
# 3. 红黑树操作-旋转
通过上一章节 2-3 树的学习，**在插入节点时并不会插到空位置，而是与现有节点融合以及调整，保持整个树的平衡**。 
而红黑树是 2-3-4 树的一种概念模型转换而来，**在插入节点时通过红色链接相连，也就是插入红色节点**（相当于2叉->3叉或3叉-4叉，相当于不会插入到空位置！与现有节点融合！）。**插入完成后进行调整，以保持树接近平衡**。 那么，为了让红黑树达到平衡状态，==主要包括染色、↔左右旋转。**这些做法其实都是从 2-3 树演化过来的**==。接下来我们就分别讲解几种规则的演化过程，以此更好了解红黑树的平衡操作。

在含有 $n$ 个关键字的红黑树上，搜索树操作 `TREE-INSERT, TREE-DELETE` 花费时间为 $O(\log n)$ 。由于这两个操作对树做了修改，结果可能违反（算导13.1节中）列出的红黑性质。**为了维护这些性质，必须要改变树中某些结点的颜色、以及指针结构**——来自2-3树的演化。

指针结构的修改是通过**旋转** `rotation` 来完成的，这是一种**能保持二叉搜索树性质的搜索树局部操作** `a local operation in a search tree that preserves the binary-search-tree property` 。图13-2中给出了两种旋转：左旋和右旋。当在某个结点 $x$ 上做左旋时，假设它的右孩子为 $y$ 、而非 $T.nil$ ；$x$ 可以为「其右孩子不是 $T.nil$ 的树内任意结点」。==左旋以 $x$ 到 $y$ 的链为“支轴”进行，它使 $y$ 成为该子树新的根结点，$x$ 成为 $y$ 的左孩子，$y$ 的左孩子成为 $x$ 的右孩子==。

![700](https://img-blog.csdnimg.cn/088d51819b914860b954c7bc39be730a.png)
在 `LEFT-ROTATE` 的伪代码中，假设 $x.right \ne T.nil$ 、且根结点的父结点为 $T.nil$ 。
```cpp
LEFT-ROTATE(T, x) 			// 对x和x的右孩子y左旋
	y = x.right				// set y
	x.right = y.left 		// turn y's left subtree into x's right subtree
	if y.left != T.nil		// 双向链接
		y.left.p = x		// 设置y.left的父结点为x
		
	y.p = x.p				// link x's parent to y
	if x.p == T.nil			// 如果x的父结点为T.nil,说明x为根
		T.root = y			// 现在y为根
	else if x == x.p.left 	// 如果x有父结点,且x为父结点的左孩子
		x.p.left = y		// 则x父结点的左孩子变为y(双向链接)
	else x.p.right = y		// 否则x父结点的右孩子变为y(双向链接)
	
	y.left = x				// put x on y's left
	x.p = y					// x的父结点变为y(双向链接)
```
图13-3给出了一个 `LEFT-ROTATE` 操作修改二叉搜索树的例子。**`RIGHT-ROTATE` 操作的代码是对称的**。`LEFT-ROTATE` 和 `RIGHT-ROTATE` 都在 $O(1)$ 时间内运行完成。**在旋转操作中只有指针改变，其他所有属性都保持不变**。
![700](https://img-blog.csdnimg.cn/3058176744d441158be1ac0f1832a207.png)


---
# 3. 插入
## 3.1 实现代码
**我们可以在 $O(\log n)$ 时间内，完成向一棵含 $n$ 个结点的红黑树中插入一个新结点**。为了做到这一点，我们使用 `TREE-INSERT` 过程（参见12.3节）的一个略作修改的版本来==将结点 $z$ 插入树 $T$ 内，就好像 $T$ 是一棵普通的二叉搜索树一样，然后我们将 $z$ 着为红色==（算导练习13.3-1要求我们解释，为什么选择将结点 $z$ 着为红色、而非黑色）。==为保证红黑性质能继续保持，我们调用一个辅助程序 `RB-INSERT-FIXUP` 来对结点重新着色并旋转==。调用 `RB-ISNERT(T, z)` 在红黑树 $T$ 内插入结点 $z$ 时，假设 $z$ 的 $key$ 属性已被事先赋值。
```cpp
RB-INSERT(T, z)
	y = T.nil
	x = T.root				// x先为T的根结点
	while x != T.nil		// 终止条件
		y = x				// y始终为x的父结点
		if z.key < x.key 	// 向左子树找z应插入的位置
			x = x.left
		else x = x.right	// 向右子树找z应插入的位置
	z.p = y					// 此时,x=T.nil,y为某个叶子结点
	if y == T.nil			// 为空树
		T.root = z			// z为新根
	else if z.key < y.key 	// z插入为y的左孩子(双向链接)
		y.left = z
	else y.right = z		// z插入为y的右孩子(双向链接)
	z.left = z.right = T.nil
	z.color = RED			// z着为红色
	RB-INSERT-FIXUP(T, z) 	// 恢复红黑性质
```
过程 `TREE-INSERT` 和 `RB-INSERT` 之间有四处不同。
- 第一，**`TREE-INSERT` 内的所有 `NULL` 都被 $T.nil$ 代替**。
- 第二，**`RB-INSERT` 的第 $14\sim 15$ 行置 $z.left,\ z.right$ 为 $T.nil$ ，以保持合理的树结构**。
- 第三，**在第 $16$ 行将 $z$ 着为红色**。
- 第四，因为将 $z$ 着为红色可能违反其中的一条红黑性质 `may cause a violation of one of the red-black properties` ，所以**在 `RB-INSERT` 的第 $17$ 行中调用 `RB-INSERT-FIXUP(T, z)` 来保持红黑性质**。
![700](https://img-blog.csdnimg.cn/b454bafee94e4dd5a4cefa23cfbfc3ba.png)

> 根据当前结点是父结点的左/右结点 $zl, zr$ 、父结点是祖父结点的左/右结点 $zpl, zpr$ ，可以有四种情况，乘以叔结点的红/黑色 $yr, yb$ ，有八种情况。==实际上，受到关注的只有六种情况，着重处理的只有两种（其他都是对称的）==。
> - **父结点是祖父结点的左孩子**：
> 	- $zl /zr, zpl, yr$ 情形1，将两个红结点——父结点 $z.p$ 和叔结点（祖父结点的右孩子）变为黑色，祖父结点则变为红色（原先为黑色，因为父结点 $z.p$ 为红色、叔结点也是红色），**恢复性质 $4$ 、且不会影响性质 $5$** 。==现在 $z,\ z.p,\ z.p.p$ 都遵循性质 $4$ ，继续往上看==。
> 	- $zl, zpl, yb$ ：$LL$ 型。
> 	- $zr, zpl, yb$ ：$LR$ 型。左旋转为 $LL$ 型处理。
> 
> - **父结点是祖父结点的右孩子**：
> 	- $zl/zr, zpr, yr$ ：对称的情形1，将两个红结点——父结点 $z.p$ 和叔结点（祖父结点的右孩子）变为黑色，祖父结点则变为红色（原先为黑色，因为父结点 $z.p$ 为红色、叔结点也是红色），**恢复性质 $4$ 、且不会影响性质 $5$** 。==现在 $z,\ z.p,\ z.p.p$ 都遵循性质 $4$ ，继续往上看==。
> 	- $zl, zpr, yb$ ：$RL$ 型，右旋转为 $RR$ 型处理。
> 	- $zr, zpr, yb$ ：$RR$ 型。
```cpp
RB-INSERT-FIXUP(T, z)
	while z.p.color == RED					// 父结点仍是红色时
		if z.p == z.p.p.left				// 父结点是祖父结点的左孩子,zpl
			y = z.p.p.right					// 叔结点
			if y.color == RED				// 叔结点为红色, (zpl, yr)
				z.p.color = BLACK			// CASE 1,父结点从红变黑
				y.color = BLACK				// CASE 1,叔结点从红变黑
				z.p.p.color = RED			// CASE 1,祖父结点从黑变红
				z = z.p.p					// CASE 1,继续往上看
			else 							// 叔结点为黑色 (zpl, yb)
				if z == z.p.right			// 如果当前结点是父结点的右结点,LR型 (zr, zpl, yb)
					z = z.p					// CASE 2
					LEFT-ROTATE(T, z)		// CASE 2,对原z的父结点左旋,此后z.p变为原来z结点的左孩子
				z.p.color = BLACK			// CASE 3,父结点从红变黑,叔结点本就为黑色
				z.p.p.color = RED			// CASE 3,祖父结点从黑变红
				RIGHT-ROTATE(T, z.p.p)		// CASE 3,右旋,左子树黑高减1,满足性质5
		else 								// z.p = z.p.p.right,父结点是祖父结点的右孩子,zpr
			y = z.p.p.left					// 叔结点 // with "right" and "left" exchanged
			if y.color == RED				// 叔结点为红色 (zpr,yr)
				z.p.color = BLACK			// 对称CASE 1,父结点从红变黑
				y.color = BLACK				// 对称CASE 1,叔结点从红变黑
				z.p.p.color = RED			// 对称CASE 1,祖父结点从黑变红
				z = z.p.p	     			// 对称CASE 1,继续往上看
			else							// 叔结点为黑色 (zpr,yb)
				if z == z.p.left			// 如果当前结点是父结点的左节点,RL型 (zl, zpr, yb)
					z = z.p					// 对称CASE 2
					RIGHT-ROTATE(T, z)		// 对称CASE 2,对原z的父结点右旋,此后z.p变为原来z结点的右孩子
				z.p.color = BLACK			// 对称CASE 3,父结点从红变黑,叔结点本就为黑色
				z.p.p.color = RED			// 对称CASE 3,祖父结点从黑变红
				LEFT-ROTATE(T, z.p.p)		// 对称CASE 3,右子树黑高减1,满足性质5
	// z.p.color为黑时退出循环,如果z.p为根结点,其本身就已经为黑
	T.root.color = BLACK					// 否则可能违反性质2,这里需要恢复
```
为了理解 `RB-INSERT-FIXUP` 过程如何工作，把代码分为三个主要的步骤。首先，**要确定当结点 $z$ 被插入并着为红色后，红黑性质中有哪些不能继续保持**。其次，**应分析第 $1 \sim 15$ 行中 while 循环的总目标**。最后，**要分析while循环体中的三种情况**（情况2可以转换为情况3，于是这两种情况就不是各自独立的了 `Case 2 falls through into case 3, and so these two cases are not mutually exclusive`），**看看它们是如何完成目标的**。图13-4给出一个范例，显示在一棵红黑树上 `RB-INSERT-FIXUP` 如何操作。
![700](https://img-blog.csdnimg.cn/b2e98d71d7574019829e0052fccf29a1.png)

**在调用 `RB-INSERT-FIXUP` 操作时，哪些红黑性质可能会被破坏**？
- 性质一（每个结点或是红色的，或是黑色的）和性质三（每个叶结点 `NULL` 是黑色的）继续成立，==因为「新插入的红结点的两个子结点」都是哨兵 $T.nil$（即叶结点，已经是黑色的）==。
- 性质五（从一个指定结点开始的、到其所有后代结点的、每条简单路径上的黑结点的个数都是相等的）也会成立，因为结点 $z$ 代替了（黑色）哨兵，并且结点 $z$ 本身是「有哨兵孩子的红结点」。==将一个哨兵替换为一个「有两个哨兵孩子的红结点」，不会影响到黑高==。
- 这样来看，**仅可能被破坏的就是性质二（根结点是黑色的）和性质四（如果一个结点是红色的，则它的两个子结点都是黑色的）**，即根结点需要为黑色、以及一个红结点不能有红孩子。==这两个性质可能被破坏是因为 $z$ 被着为红色——如果 $z$ 是根结点，则破坏了性质二；如果 $z$ 的父结点是红结点，则破坏了性质四==。图13-4(a)显示在插入结点 $z$ 之后性质四被破坏的情况。

第 $1 \sim 15$ 行中的 while 循环，在每次迭代的开头，保持下列三个部分的不变式：
1. **结点 $z$ 是红结点**。
2. **如果 $z.p$ 是根结点，则 $z.p$ 是黑结点**（如果 $z$ 是根，则见第三部分，它破坏性质二；否则已有的根一定为黑结点）。
3. ==如果有任何红黑性质被破坏，则至多只有一条被破坏，或是性质二、或是性质四==。如果性质二被破坏，其原因为 **$z$ 是根结点且是红结点**；如果性质四被破坏，其原因为 **$z$ 和 $z.p$ 都是红结点**。
![700](https://img-blog.csdnimg.cn/7e2512aa9925437bb5bbc4e9fcfee8c0.png)

第三部分处理红黑性质的破坏，相比第一部分和第二部分来说，更加集中地展示出 `RB-INSERT-FIXUP` 如何保持红黑性质，我们以此来理解代码中的各种情形。==由于我们将注意力集中在「结点 $z$ 以及树中靠近它的结点」上，所以从第一部分得知 $z$ 为红结点是有帮助的==。当在第 $2, 3, 7, 8, 13, 14$ 行中引用 $z.p.p$ 时，我们使用第2部分来表明 $z.p.p$ 的存在。

## 3.2 不变式证明

需要证明：**在循环的第一次迭代之前，循环不变式为真**，而且**每次迭代都保持这个循环不变式成立**，并且**在循环终止时，这个循环不变式会给出一个有用的性质**。

我们先从初始化和终止的不变式证明开始 `We start with the initialization and termination arguments` 。然后，我们通过细致地考察循环体如何工作、来证明循环在每次迭代中都保持这个循环不变式。同时，还要说明==循环的每次迭代会有两种可能的结果：或者指针 $z$ 沿着树上移，或者执行某些旋转后循环终止==。

### (1) 初始化
在循环的第一次迭代之前，**我们从一棵正常的红黑树开始，并新增一个红结点 $z$** 。我们要证明，**当 `RB-INSERT-FIXUP` 被调用时，不变式的每个部分都成立**。
1. 当调用 `RB-INSERT-FIXUP` 时，**$z$ 是新增的红结点**。
2. **如果 $z.p$ 是根，那么开始时 $z.p$ 是黑色的**，且在调用 `RB-INSERT-FIXUP` 之前保持不变。
3. 注意到，在调用 `RB-INSERT-FIXUP` 时，性质 $1, 3, 5$ 成立。
	==如果违反了性质 $2$ ，则红色根结点一定是新增的结点 $z$ ，它是树中唯一的内部结点==。因为 $z$ 的父结点和两个子结点都是黑色的哨兵，没有违反性质 $4$ 。这样，**对性质 $2$ 的违反是整棵树中唯一违反红黑性质的地方**。
	==如果违反了性质 $4$ ，则由于 $z$ 的子结点是黑色哨兵、且该树在 $z$ 加入之前没有违反其他性质，所以违反必然是因为 $z$ 和 $z.p$ 都是红色的==。而且，没有其他红黑性质被违反。
### (2) 终止
**循环终止是因为 $z.p$ 是黑色的**（如果 $z$ 是根结点，那么 $z.p$ 是黑色哨兵 $T.nil$ ）**、而 $z$ 还是红色的**。这样，**树在循环终止时没有违反性质 $4$** 。根据循环不变式，唯一可能不成立的是性质 $2$ 。第 $16$ 行恢复这个性质，所以当 `RB-INSERT-FIXUP` 终止时，所有的红黑性质都成立。
### (3)  保持
实际上，我们还需要考虑while循环中的 $6$ 种情况，而其中三种与另外三种是对称的。这取决于==第 $2$ 行中「 $z$ 的父结点 $z.p$ 」是「 $z$ 的祖父节点 $z.p.p$ 」的左孩子、还是右孩子==。我们只给出 $z.p$ 是左孩子时的代码。

**根据循环不变式的第二部分**——如果 $z.p$ 是根结点，那么 $z.p$ 是黑色的，**可知结点 $z.p.p$ 存在**。==因为只有在 $z.p$ 是红色时才进入一次循环迭代，所以我们知道 $z.p$ 不可能是根结点。因此，$z.p.p$ 存在==。

==情况 $1$ 和情况 $2, 3$ 的区别在于，**$z$ 父亲的兄弟结点（“叔结点”）的颜色不同**==。第 $3$ 行使 $y$ 指向 $z$ 的叔结点 $z.p.p.right$ ，在第 $4$ 行测试 $y$ 的颜色。如果 $y$ 是红色的，那么执行情况 $1$ 。否则，控制转向情况 $2$ 和情况 $3$ 上。==在所有三种情况中，$z$ 的祖父节点 $z.p.p$ 都是黑色的，因为它的父结点 $z.p$ 是红色的（且原树是红黑树、遵循红黑性质），故性质 $4$ 只在 $z$ 和 $z.p$ 之间被破坏了==。
#### 情况一：$z$ 的叔结点 $y$ 是红色的
图13-5显示了情况 $1$（第 $5 \sim 8$ 行）的情形，**这种情况在 $z.p$ 和 $y$ 都是红色时发生**。因为 $z.p.p$ 是黑色的，所以==将 $z.p$ 和 $y$ 都着为黑色，以此解决 $z$ 和 $z.p$ 都是红色的问题==，我们还==将 $z.p.p$ 着为红色、以保持性质 $5$== 。然后，**把 $z.p.p$ 作为新结点 $z$ 来重复while循环。指针 $z$ 在树中上移两层**。
![700](https://img-blog.csdnimg.cn/fab38f6fe7ae401797bdd302112bc3f4.png)
现在，证明情况 $1$ 在下一个循环迭代的开头、会保持这个循环不变式。用 $z$ 表示当前迭代中的结点 $z$ ，用 $z' = z.p.p$ 表示在下一次迭代第 $1$ 行测试时的结点 $z$ .
1. 因为这次迭代把 $z.p.p$ 着为红色，**结点 $z'$ 在下次迭代的开始是红色的**。
2. 在这次迭代中结点 $z'.p$ 是 $z.p.p.p$ ，且**这个结点的颜色不会改变**。如果它是根结点，则在此次迭代之前它是黑色的，且它在下次迭代的开头仍然是黑色的。
3. 我们已经证明情况 $1$ 保持性质 $5$ ，而且它也不会引起性质 $1, 3$ 的破坏。
	==如果结点 $z'$ 在下一次迭代开始时是根结点==，则在这次迭代中情况 $1$ 修正了「唯一被破坏的性质 $4$ 」。由于 $z'$ 是红色的、而且是根结点，所以==性质 $2$ 成为唯一被违反的性质，这是由 $z'$ 导致的==。
	==如果结点 $z'$ 在下一次迭代开始时不是根结点，则情况 $1$ 不会导致性质 $2$ 的破坏==。情况 $1$ 修正了在这次迭代的开始唯一违反的性质 $4$ 。然后它**把 $z'$ 着为红色、而 $z'.p$ 不变**。如果 $z'.p$ 是黑色的，则没有违反性质 $4$ 。==如果 $z'.p$ 是红色的，则把 $z'$ 着为红色，会在 $z', z'.p$ 之间造成性质 $4$ 的违反==。


#### 情况二：$z$ 的叔结点 $y$ 是黑色的、且 $z$ 是一个右孩子
#### 情况三：$z$ 的叔结点 $y$ 是黑色的、且 $z$ 是一个左孩子
在情况 $2$ 和情况 $3$ 中，**$z$ 的叔结点 $y$ 是黑色的**。通过 $z$ 是 $z.p$ 的右孩子还是左孩子来区别这两种情况。
- 第 $10 \sim 11$ 行构成了情况 $2$ ，它和情况 $3$ 一起显示在图13-6中。在情况 $2$ 中，**结点 $z$ 是它的父结点的右孩子（$LR$ 型）**。==可以立即使用一个左旋、来将此情形转变为情况 $3$==（第 $12 \sim 14$ 行），此时结点 $z$ 为左孩子。==因为 $z, z.p$ 都是红色的，所以该旋转对结点的黑高和性质 $5$ 都无影响==。
- 无论是直接进入情况 $2$ ，还是通过情况 $3$ 进入情况 $2$ ，**$z$ 的叔结点 $y$ 总是黑色的**，因为否则就要执行情况 $1$ 。此外，==结点 $z.p.p$ 存在，因为已经推断**在执行第 $2, 3$ 行时该结点存在**，且在第 $10$ 行将 $z$ 往上移一层，然后在第 $11$ 行将 $z$ 往下移一层后，**$z.p.p$ 的身份保持不变**==。在情况 $3$ 中，改变某些结点的颜色、并**做一次右旋，同样用来保持性质 $5$**、也避免违反性质 $2$ 。这样，==由于在一行中不再有两个红色结点，所有的处理到此完毕。因为此时 $z.p$ 是黑色的，所以无需再执行一次while循环==。

现在来证明，情况 $2$ 和情况 $3$ 保持了循环不变式（正如已经讨论的，$z.p$ 在第 $1$ 行中下次测试会是黑色，循环体不会再次执行）。
1. 情况 $2$ **让原来的 $z$ 指向原来的红色 $z.p$** 。在情况 $2, 3$ 中 $z$ 或 它的颜色都不再改变。
2. 情况 $3$ **把 $z.p$ 着成黑色**，使得**如果 $z.p$ 在下一次迭代开始时是根结点，则它是黑色的**。
3. 如同情况 $1$ ，性质 $1, 3, 5$ 在情况 $2$ 与情况 $3$ 中得以保持。
由于结点 $z$ 在情况 $2, 3$ 中都不是根结点，我们知道性质 $2$ 没有被破坏。**情况 $2$ 和情况 $3$ 不会引起性质 $2$ 的违反**，因为「唯一着为红色的结点（原来的 $z.p.p$ ）」在情况 $3$ 中通过旋转、成为一个黑结点（原来的 $z$ ）的子结点。
情况 $2, 3$ 修正了对性质 $4$ 的违反，也不会引起对其他红黑性质的违反。

上面已经展示了，**循环的每一次迭代都会保持循环不变式**，我们也就证明了 `RB-INSERT-FIXUP` 能够正确地保持红黑性质。

## 3.3 分析
`RB-INSERT` 的运行时间怎样呢？由于一棵有 $n$ 个结点的红黑树的高度为 $O(\log n)$ ，因此 `RB-INSERT` 的第 $1 \sim 16$ 行要花费 $O(\log n)$ 时间。在 `RB-INSERT-FIXUP` 中，**仅当情况 $1$ 发生，然后指针 $z$ 沿着树上升 $2$ 层时，while 循环才会重复执行**。所以 while 循环可能被执行的总次数为 $O(\log n)$ 。因此，`RB-INSERT` 总共花费 $O(\log n)$ 。此外，==**该程序所做的旋转从不超过 $2$ 次**，因为只要执行了情况 $2$ 或情况 $3$ ，while 循环就结束了==。

---
# 4. 删除
与「 $n$ 个结点的红黑树」上的其他基本操作一样，删除一个结点要花费 $O(\log n)$ 时间。与插入操作相比，删除操作要稍微复杂些。   

从一棵红黑树中删除结点的过程，是基于 `TREE-DELETE` 过程（算导12.3节）而来的。首先，需要特别设计一个供 `TREE-DELETE` 调用的子过程 `TRANSPLANT` ，并将其应用到红黑树上：
```cpp
RB-TRANSPLANT(T, u, v)			// 在树中替换结点u的位置为v
	if u.p == T.nil				// u为根结点时
		T.root = v				// v为新的根
	else if u == u.p.left		// 如果u是父结点的左孩子 
		u.p.left = v			// u父结点的左孩子变为v
	else u.p.right = v			// u父结点的右孩子变为v
	v.p = u.p					// v的父结点为u的父结点(双向链接)
```
过程 `RB-TRANSPLANT` 与 `TRANSPLANT` 有两点不同。首先，**第 $1$ 行引用哨兵 $T.nil$ 而不是 `NULL`** 。其次，**第 $6$ 行对 $v.p$ 的赋值是无条件执行：即使 $v$ 指向哨兵，也要对 $v.p$ 赋值**。实际上，当 $v = T.nil$ 时，也能给 $v.p$ 赋值。

过程 `RB-DELETE` 与 `TREE-DELETE` 类似，只是多了几行伪代码。**多出的几行代码追踪 $y$ ，$y$ 有可能导致红黑性质的破坏**。
- 当想要删除结点 $z$ 、且此时 $z$ 的子结点少于 $2$ 个时，$z$ 从树中删除，并让 $y$ 成为 $z$ 。
- 当 $z$ 有两个子结点时，$y$ 应该是 $z$ 的后继，并且 $y$ 将移至树中的 $z$ 位置。

**在结点 $y$ 被移出、或者移入树中前，我们必须记住 $y$ 的颜色** `remember y’s color before it is removed from or moved within the tree` ，并且记录「将要移至树中 $y$ 的原来位置的结点 $x$ 」的踪迹，因为结点 $x$ 也可能引起红黑性质的破坏。删除结点 $z$ 之后，`RB-DELETE` 调用一个辅助过程 `RB-DELETE-FIXUP` ，该过程通过改变颜色和执行旋转来恢复红黑性质。
```cpp

```
![700](https://img-blog.csdnimg.cn/f28d0af0a13b422999c2eaa713a22d6e.png)

虽然 `RB-DELETE` 包含的伪代码行数，几乎是 `TREE-DELETE` 的 $2$ 倍，但这两个过程具有相同的基本结构。在 `RB-DELETE` 中能够找到 `TREE-DELETE` 的每一行语句（其中 `NULL` 被替换成 $T.nil$ ，而调用 `TRANSPLANT` 换成了调用 `RB-TRANSPLANT` ），其执行的条件相同。下面是两个过程之间的其他区别：
- 始终维持结点 $y$ 为从树中删除的结点、或者移至树内的结点。当 $z$ 的子结点少于 $2$ 个时，第 $1$ 行将 $y$ 指向 $z$ ，并因此要移除（？）。当 $z$ 有两个子结点时，第 $9$ 行将 $y$ 指向 $z$ 的后继，这与 `TREE-DELETE` 相同，$y$ 将移至树中 $z$ 的位置。
- 由于结点 $y$ 的颜色可能改变，变量 `y-original-color` 存储了发生改变前的 $y$ 颜色。第 $2$ 行和第 $10$ 行在给 $y$ 赋值后，立即设置该变量。当 $z$ 有两个子结点时，则 $y \ne z$ 且结点 $y$ 移至红黑树中结点 $z$ 的原始位置；第 $20$ 行给 $y$ 赋予和 $z$ 一样的颜色。我们需要保存 $y$ 的原始颜色，以在 `RB-DELETE` 结束时测试它；如果它是黑色的，那么删除或移动 $y$ 会引起红黑性质的破坏。
- 正如前面讨论过的，我们保存结点 $x$ 的踪迹，使它移至结点 $y$ 的原始位置上。第 $4, 7, 11$ 行的赋值语句，令 $x$ 或指向 $y$ 的唯一子结点、或指向哨兵 $T.nil$（如果 $y$ 没有子结点）（回忆算导12.3节 $y$ 没有左孩子的情形）。
- 因为结点 $x$ 移动到结点 $y$ 的原始位置，属性 $x.p$ 总是被设置指向树中 $y$ 父结点的原始位置，甚至当 $x$ 是哨兵 $T.nil$ 时也是这样，除非 $z$ 是 $y$ 的原始父结点（该情况只在 $z$ 有两个孩子、且它的后继 $y$ 是 $z$ 的右孩子时发生），否则对 $x.p$ 的赋值在 `RB-TRANSPLANT` 的第 $6$ 行（注意到，在第 $5, 8$ 或 $14$ 行调用 `RB-TRANSPLANT` 时，传递的第二个参数与 $x$ 相同）。然而，当 $y$ 的原父结点是 $z$ 时，我们并不想让 $x.p$ 指向 $y$ 的原始父结点，因为要在树中删除该结点。由于结点 $y$ 将在树中向上移动、占据 $z$ 的位置，第 $13$ 行将 $x.p$ 设置为 $y$ ，使得 $x.p$ 指向 $y$ 父结点的原始位置，甚至当 $x = T.nil$ 时也是这样。
- 最后，如果结点  $y$ 是黑色，就有可能已经引入了一个或多个红黑性质被破坏的情况，所以在第 $22$ 行调用 `RB-DELETE-FIXUP` 来恢复红黑性质。如果 $y$ 是红色，当 $y$ 被删除或移动时，红黑性质仍然保持，原因如下：
	1. 树中的黑高没有变化。
	2. 不存在两个相邻的红结点。因为 $y$ 在树中占据了 $z$ 的位置，再考虑到 $z$ 的颜色，树中 $y$ 的新位置不可能有两个相邻的红结点。另外，如果 $y$ 不是 $z$ 的右孩子，则 $y$ 的原右孩子 $x$ 代替 $y$ 。如果 $y$ 是红色，则 $x$ 一定是黑色，因此用 $x$ 替代 $y$ 不可能使两个红结点相邻。
	3. 如果 $y$ 是红色，就不能是根结点，所以根结点仍旧是黑色。
![700](https://img-blog.csdnimg.cn/fbbda48dff774af19e6162655fe31ed5.png)
	如果结点 $y$ 是黑色的，则会产生三个问题，可以通过调用 `RB-DELETE-FIXUP` 进行补救。第一，如果 $y$ 是原来的根结点，而 $y$ 的一个红色的孩子成为新的根结点，这就违反了性质 $2$ 。第二，如果 $x$ 和 $x.p$ 是红色的，则违反了性质 $4$ 。第三，在树中移动 $y$ 将导致先前包含 $y$ 的任何简单路径上黑结点个数少 $1$ 。因此，$y$ 的任何祖先都不满足性质 $5$ 。改正这一问题的办法是，将现在占有 $y$ 原来位置的结点 $x$ 视为还有一重额外的黑色。也就是说，如果将任意包含结点 $x$ 的简单路径上黑结点个数加 $1$ ，则在这种假设下，性质 $5$ 成立。当将黑结点 $y$ 删除或移动时，将其黑色“下推”给结点 $x$ 。现在问题变为，结点 $x$ 可能既不是红色、又不是黑色，从而违反了性质 $1$ 。现在的结点 $x$ 是双重黑色或红黑色，这就分别给包含 $x$ 的简单路径上黑结点数贡献了 $2$ 或 $1$ 。$x$ 的 $color$ 属性仍然是 $\textrm{RED}$（如果 $x$ 是红黑色）或者 $\textrm{BLACK}$（如果 $x$ 是双重黑色的）。即，结点额外的黑色是针对 $x$ 结点的，而不是反映在它的 $color$ 属性上的。

现在我们来看看过程 `RB-DELETE-FIXUP` 是如何恢复搜索树的红黑性质的。
![700](https://img-blog.csdnimg.cn/1570353f493a41d382898924ceaa5b75.png)![700](https://img-blog.csdnimg.cn/5e7a2f16ed734c39b071bdcd552f140d.png)
过程 `RB-DELETE-FIXUP` 恢复性质 $1$ 、性质 $2$ 和性质 $4$ （算导练习13.4-1和13.4-2要求说明，这个过程是如何恢复性质 $2, 4$ 的，本节其余部分将专注于性质 $1$ ）。第 $1 \sim 22$ 行中while循环的目标是，将额外的黑色沿树上移，直到：
1. $x$ 指向红黑结点，此时在第 $23$ 行中，将 $x$ 着为（单个）黑色。
2. $x$ 指向根结点，此时可以简单地“移除”额外的黑色。
3. 执行适当的旋转和重新着色，退出循环。

在while循环中，$x$ 总是指向一个具有双重黑色的非根结点。在第 $2$ 行中要判断 $x$ 是其父结点 $x.p$ 的左孩子、还是右孩子（已经给出了 $x$ 为左孩子时的代码；$x$ 为右孩子的第 $22$ 行的代码是对称的）。保持指针 $w$ 指向 $x$ 的兄弟。由于结点 $x$ 是双重黑色的，故 $w$ 不可能是 $T.nil$ ，因为否则，从 $x.p$ 到（单黑色）叶子 $w$ 的简单路径上的、黑结点个数就会小于「从 $x.p$ 到 $x$ 的简单路径上的黑结点数」。

图13-7给出了代码中的 $4$ 种情况（参见过程 `RB-INSERT-FIXUP`, `RB-DELETE-FIXUP` 中的四种情况并不是完全独立的）。在具体研究每一种情况之前，先看看如何证实每种情况中的变换保持性质 $5$ 。关键思想是在每种情况中，从子树的根（包括根）到每棵子树 $\alpha, \beta, \dots, \zeta$ 之间的黑结点个数（包括 $x$ 的额外黑色）并不被变换改变。因此，如果性质 $5$ 在变换之前成立，那么变换之后也仍然成立。举例说明，图13-7(a)说明了情况 $1$ ，在变换前后，根结点至子树 $\alpha$ 或 $\beta$ 之间的黑结点数都是 $3$（再次记住，结点 $x$ 增加了额外一重黑色）。类似地，在变换前后根结点至子树 $\gamma, \delta, \varepsilon, \zeta$ 中的任何一个之间的黑结点数都是 $2$ 。在图13-7(b)中，计数时还要包括所示子树的根结点的 $color$ 属性的值 $c$ ，它或是 $\textrm{RED}$ 或是 $\textrm{BLACK}$ 。如果定义 $count(\textrm{RED}) = 0$ 以及 $count(\textrm{BLACK}) = 1$ ，那么变换前后根结点至 $\alpha$ 的黑结点数都为 $2 +count(c)$ 。在此情况下，变换    
![700](https://img-blog.csdnimg.cn/01c897a3f00a40c49f8cb4d102c1775c.png)
之后新结点 $x$ 具有 $color$ 属性值 $c$ ，但是这个结点的颜色是**红黑**（如果 $c = \textrm{RED}$ ）或者双重黑色的（如果 $c = \textrm{BLACK}$ ）。其他情况可以类似地加以验证（见练习13.4-5）。
![700](https://img-blog.csdnimg.cn/14f9425fc4e54c359aa4d34d6b2dd209.png)
![700](https://img-blog.csdnimg.cn/effa34b5fd17458ca35cae74581ec0b5.png)
**情况1：$x$ 的兄弟结点 $w$ 是红色的**
情况 $1$（见 `RB-DELETE-FIXUP` 的第 $5 \sim 8$ 行和图13-7(a)）发生在结点 $x$ 的兄弟结点 $w$ 为红色时，因为 $w$ 必须有黑色子结点，所以可以改变 $w$ 和 $x.p$ 的颜色，然后对 $x.p$ 做一次左旋、而不违反红黑树的任何性质。现在，$x$ 的新兄弟结点是旋转之前 $w$ 的某个子结点，其颜色为黑色。这样，就将情况 $1$ 转换为情况 $2, 3$ 或 $4$ 处理。

当结点 $w$ 为黑色时，属于情况 $2, 3, 4$ ；这些情况是由 $w$ 的子结点的颜色来区分的。

![700](https://img-blog.csdnimg.cn/90d282f38d30400096fca38a8454cc6c.png)

**情况2：$x$ 的兄弟结点 $w$ 是黑色的，而且 $w$ 的两个子结点都是黑色的**
 在情况 $2$（见 `RB-DELETE-FIXUP` 的第 $10 \sim 11$ 行和图13-7(b)）中，$w$ 的两个子结点都是黑色的。因为 $w$ 也是黑色的，所以从 $x$ 和 $w$ 上去掉一重黑色，使得 $x$ 只有一重黑色、而 $w$ 为红色。为了补偿从 $x$ 和 $w$ 中去掉的一重黑色，在原来是红色或黑色的 $x.p$ 上新增一重额外的黑色。通过将 $x.p$ 作为新结点 $x$ 来重复while循环。注意到，如果通过情况 $1$ 进入到情况 $2$ ，则新结点 $x$ 是红黑色的，因为原来的 $x.p$ 是红色的。因此，新结点 $x$ 的 $color$ 属性值 $c$ 为 $\textrm{RED}$ ，并且在测试循环条件后循环终止。然后，在第 $23$ 行中将新结点 $x$ 着为（单一）黑色。

**情况3：$x$ 的兄弟结点 $w$ 是黑色的，$w$ 的左孩子是红色的，$w$ 的右孩子是黑色的**
情况 $3$（见第 $13\sim 16$ 行和图13-7 c)）发生在 $w$ 为黑色且其左孩子为红色、右孩子为黑色时。可以交换 $w$ 和其左孩子 $w.left$ 的颜色，然后对 $w$ 进行右旋、而不违反红黑树的任何性质。现在，$x$ 的新兄弟结点 $w$ 是一个有红色右孩子的黑结点，这样我们就将情况 $3$ 转换成了情况 $4$ 。 
 
**情况4：$x$ 的兄弟结点 $w$ 是黑色的，且 $w$ 的右孩子是红色的**
 情况 $4$（见第 $17 \sim 21$ 行和图13-7(d)发生在结点 $x$ 的兄弟结点 $w$ 为黑色、且 $w$ 的右孩子为红色时）。通过进行某些颜色修改，并对 $x.p$ 做一次左旋，可以去掉 $x$ 的额外黑色，从而使其变为单重黑色，而且不破坏红黑树的任何性质。将 $x$ 设置为根后，当while循环测试其循环条件时，循环终止。

![700](https://img-blog.csdnimg.cn/abd8f16d6a6a42e29cc5beb577e6fb2e.png)


## 分析
`RB-DELETE` 的运行时间怎样？因为含 $n$ 个结点的红黑树的高度为 $O(\log n)$ ，不调用 `RB-DELETE-FIXUP` 时，该过程的总时间代价为 $O(\log n)$ 。在 `RB-DELETE-FIXUP` 中，情况 $1, 3, 4$ 在各执行常数次数的颜色改变和至多 $3$ 次旋转后便终止。情况 $2$ 是while循环可以重复执行的唯一情况，然后指针 $x$ 沿树上升至多 $O(\log n)$ 次，且不执行任何旋转。所以，过程 `RB-DELETE-FIXUP` 要花费 $O(\log n)$ 时间，做至多 $3$ 次旋转，因此 `RB-DELETE` 运行的总时间为 $O(\log n)$ 。

 
## 3.2 左旋+染色：改变RR——把一个向右倾斜的红节点链接(2-3树4-三元素、3-双元素节点)，转化为左链接
背景：顺序插入元素，1、2、3
2-3 树保持平衡，红黑树暂时处于右倾斜。 接下来我们分别对比两种树结构的平衡操作； 
1. 2-3 树，==所有插入的节点都会保持在一个节点上，之后通过调整节点位置，保持平 衡==。 
2. 红黑树，**则需要通过节点的左侧旋转，将元素 2 拉起来**，元素 1 和元素 3，分别成 为左右子节点。==红黑树的左旋，只会处理与之对应的 2-3 树节点进行操作，不会整体改变==。
![550](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030319825.png)
## 3.3 右旋+染色：改变LL——把一个向左倾斜的红节点连接(2-3 树4-三元素、3-双元素节点)，转换为右连接
背景：顺序插入元素，3,2,1
2-3 树保持平衡，红黑树暂时处于左倾斜。 接下来我们分别对比两种树结构的平衡操作；
1. 2-3 树，所有插入的节点都会保持在一个节点上，之后通过调整节点位置，保持平 衡。 
2. 红黑树，**则需要通过节点的右侧旋转，将元素 2 拉起来**，元素 1 和元素 3，分别成 为左右子节点。 ==**你会发现，左旋与右旋是相互对应的，但在 2-3 树中是保持不变的**==
![600](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030320870.png)
## 3.4 左右旋综合运用 
左旋、右旋，我们已经有了一个基本的概念，那么接下来我们再看一个可以综合 左右旋以及对应 2-3 树的演化案例，如下；
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030325026.png)
以上的例子分别演示了一个元素插入已有的3，1的三种情况，如下；
1. 1、3，插入 0，左侧底部插入，**与 2-3 树相比，需要右旋保持平衡** 
2. 1、3，插入 2，中间位置插入，首先进行左旋调整元素位置，之后进行右旋进行树 平衡 
3. 1、3，插入 5，右侧位置插入，此时正好保持树平衡，不需要调整 

## 3.5 染色 
在 2-3 树中，插入一个节点，**为了保持树平衡、是不插入到空位置上的**，==当插入节点后元素数量有 3 个后、则需要调整中间元素向上、来保持树平衡==。
与之对应的红 黑树则需要**插入红色节点**，还要**调整颜色**，来保证红黑树的平衡规则（黑高、红不相邻），一种情况如下；
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305030330973.png)

如果上图影响了黑高，还需要将7变为红色！
# 4. 旋转+染色运用案例 
接下来我们把上面讲解到的旋转、染色，运用到一个实际案例中，如下图；
1. 首先从左侧开始，是一个按照顺序插入生产出来的红黑树，插入顺序；7、2、 8、1、4、3、5
2. α，向目前红黑树插入元素 6，插入后右下角有三个红色节点；3、5、6。
3. β，因为右下角满足染色条件，变换后；黑色节点(3、5)、红色节点(4、6)。
4. γ，之后看被红色连线链接的节点 7、4、2，**最小节点在中间**？（**发现将4的父亲结点及其兄弟结点染黑色无法满足黑高**！），左旋平衡树结构。
5. δ，左旋完成后，红色链接线的 7、4、2 为左倾顺序节点，因此需要做右旋操 作。 
6. ε，左旋、右旋，调整完成后，又满足了染色操作。到此恢复红黑树平衡。

注意，所有连接红色节点的，都是是红色线。以此与 2-3 树做对应。
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031645394.png)
最后得到的结果与2-3-4树的结果完全等价！！！
# 5. 删除操作
根据 2-3-4 树模型的红黑树，在删除的时候基本是按照 2-3 方式进行删除，只不 过在这个过程中需要染色和旋转操作，以保持树平衡。删除过程主要可以分为如 图四种情况，如下；
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031728765.png)

## 5.1 删除叶子红结点
红色子叶节点的删除并不会破坏树平衡，也不影响树高，所以直接删除即可，如 下；
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031729786.png)
## 5.2 删除左侧结点
### 5.2.1 被删结点的兄弟为黑色 & 兄弟仅含有右子结点
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031735639.png)
### 5.2.2 被删结点的兄弟为黑色 & 兄弟仅含有左子结点
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031743938.png)
### 5.2.3 被删结点的兄弟为黑色 & 兄弟含双红结点
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031747015.png)
### 5.2.4 被删结点的兄弟为黑色 & 兄弟没有子结点
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031749842.png)
### 5.2.4 被删结点的兄弟为黑色 & 兄弟含双黑结点
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031750979.png)

## 5.3 删除右侧结点
### 5.3.1 被删结点的兄弟为黑色 & 兄弟含左子结点
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031751334.png)
### 5.3.2 被删结点的兄弟为黑色 & 兄弟含右子结点
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031752449.png)
### 5.3.3 被删结点的兄弟为黑色 & 兄弟含有双红结点
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031752291.png)

### 5.3.4 被删结点的兄弟为黑色 & 兄弟不含有子结点
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031753697.png)
### 5.3.5 被删结点的兄弟为黑色 & 兄弟含双黑结点
![700](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202305031755180.png)


# 总结 
从 2-3 树到解释 2-3-4 树概念推导出红黑树，从元素的在 2-3 树中的插入删除对 照到红黑树中保持平衡操作，从原理解析到各项情况实际操作等，以及把绝大部分 红黑树内容全部介绍完成。 

红黑树的原理理解要比背概念更重要，这是一种数据结构的学习，更重要的是技术 迁移学习，而不是为了面试背几道题。可能这个学习过程非常烧脑，但适合学习根本。  