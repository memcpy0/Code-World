@[toc]

---
# 1. 概述
我们学过很多排序算法，简单的如冒泡排序、插入排序，麻烦一点的如希尔排序（还不一定写得对）、堆排序，派的上用场的如**归并排序**、**快速排序**。实际上，快速排序和归并排序已经够用了，它们的平均时间复杂度为 $O(n\log n)$ ，任何**基于比较的排序算法**的时间复杂度都不可能比这更优了。

甚至于，我们不需要自己手写排序算法，C++ STL给我们提供了如下函数，足够满足绝大多数情况下的需求：
- `void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);` ：快速排序；
- `void stable_sort (RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp );` ：当排序元素相等时，保留原先的顺序； 
- `void partial_sort (RandomAccessIterator first, RandomAccessIterator middle,
                     RandomAccessIterator last, Compare comp);` ：局部排序，例如有 `10` 个数字求最小的 `5` 个数，用 `sort()` 需要全部排序后再进行输出，而 `partial_sort()` 可以直接输出前 `5` 个元素。 

---
# 2. 计数排序及实现
不过有些时候，我们还需要更快的算法。如果要排序的数据满足一些特殊的性质：比如都是**不太大的自然数** (`<= m`) 时，可以使用**桶排序/计数排序**，将待排序数据作为数组下标。时间复杂度是 $O(n+m)$ ，空间复杂度是 $O(m)$ 。具体代码如下：
```cpp
//计数排序
int cnt[MAXN];
void countingSort(unsigned A[], int len) {
	for (int i = 0; i < len; ++i) ++cnt[A[i]];
	int pos = 0;
	for (int i = 0; pos < len; ++i) 
		if (cnt[i])
			for (int j = 0; j < cnt[i]; ++j)
				A[pos++] = i;
}
```
问题是，当 $m$ 稍微大一点，空间就会爆炸。于是我们在这个基础上进行优化，得到了**基数排序** `Radix Sort` 。

---
# 3. 基数排序
基数排序是针对自然数(以及其他可以转换为自然数的数据)的排序。它的思想很简单：**对数字的每一位分别进行桶/计数排序**。其中的**基数** `radix` 就是**进制**，或者说每一位数字的数据范围。

## (1) 简要介绍
基数排序分为**高位优先**和**低位优先**两种。其中，高位优先是指先按照高位的数字进行计数排序，此时能够直接区分所有数的大小，然后递归对每个桶中的数据的次高位进行基数排序。总的来说，**高位优先基数排序**性能不如**低位优先**，因此不太常用。

下面我们以 `10` 为基数进行低位优先的基数排序。有这么几个数据：`14579, 54929, 41488, 13692, 2048` 。首先按照最低位进行计数排序：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200831212347119.gif)
第一趟计数排序结束后，所有的数已经按照最低一位排好序。然后按照次低位进行排序： 
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200831212539447.gif)
此时，所有数的末两位已经排好序。这个过程进行下去，直至遍历完所有位，完成整个数据的排序。总的来说，**低位优先基数排序**是**从低位到高位，依次进行计数排序(或者其他稳定的排序)**。


## (2) 具体实现：10进制低位优先基数排序
以 $10$ 为基数的，一般的实现会从小到大准备 $10$ 个链队列，然后将所有数据按照最低位**分配**到 $10$ 个链队列中，再依次**收集**起来；然后按照次低位进行分配，再进行收集……直到完成排序。不过这样太麻烦，这里给出**使用数组**的 $10$ 进制低位优先基数排序：
- 要排序的**正整数数组** `arr[]` 大小为 $N$ ，我们需要先创建一个大小为 $10\times N$ 的二维数组 `idx[10][N]` ，用来进行数据的分配和收集；
- 之后，我们找到 `arr[]` 中最大的数，计算出它的位数为 $k$ ，这代表着我们只用进行 $k$ 次计数排序；如果有负整数，就比较绝对值的大小；这一步不是很重要，可以省略；
- 然后我们根据 `arr[]` 中每个数的最低位进行排序，再根据十位进行排序……直到对第 $k$ 位进行排序。此时，排在我们创建的数组 `idx[][]` 中的数据已经完成排序，只需要输出即可。


这样可能还是有点看不懂，现在举个例子，要排序的数组为 `arr[] = {121, 5, 4564, 9320, 6, 2, 1, 1234}` ： 
- 首先创建出一个二维数组 `idx[][]` ，大小为 $10 \times 8$ ；
- 之后，找到数据中的最大数，这里是 $9321$ ，得到它的位数 $4$ 位；
- 然后根据数据的个位进行排序，第 $0$ 个数 $121$ 的个位是 $1$ ，所以放在 `idx[1][0]` 处；第 $1$ 个数 $5$ 的个位是 $5$ ，所以将它放在 `idx[5][1]` 上……依次类推；
- 将数据都根据个位排入数组后，按照顺序用待排数组将它们收集起来，从第 $0$ 行开始读到第 $9$ 行，从左读到右。得到按个位从小到大排好的数组 `arr[] = {9320, 121, 1, 2, 4564, 1234, 5, 6}` ；
- 当我们把数据读出来后，记得要把创建的数组 `idx[10][N]` 清零，供下次使用；
- 接下来对十位进行排序，用刚刚读出来的新数组，第 $0$ 个数是 $9320$ ，它的十位是 $2$ ，就把它放在 `idx[2][0]` 上，这一过程基本一致……要注意第 $2$ 个数是 $1$ ，没有十位，我们把它的十位当成 $0$ ，排到 `idx[0][2]` 就可以了；
- 再按之前的顺序读取数据，得到这样的数组 `{1, 2, 5, 6, 9320, 121, 1234, 4564}` ，清零 `idx[10][N]` ；
- 然后按照这一过程，对百位和千位进行相同的排序，就可以得到最后排序好的数组了。 

为了验证我们代码的效率和准确性，使用[洛谷 P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)进行评判，这道题的数据可以卡死很多写得差的快速排序：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;
int arr[maxn], idx[10][maxn], n, mx = -1; 

int main() { 
	scanf("%d", &n); 
	for (int i = 0; i < n; ++i) {
		scanf("%d", &arr[i]);
		mx = max(mx, arr[i]);
	}
	int digits = 0, ten = 1;
	do { ++digits; mx /= 10; } while (mx); 
	for (int i = 0; i < digits; ++i) { //进行len次计数排序 
		for (int j = 0; j < n; ++j)    //将每个数按照给出的j的顺序,排到创建的数组中
			idx[(arr[j] / ten) % 10][j] = arr[j]; 
		//按照顺序读取排好的数组
		int len = 0;
		for (int j = 0; j <= 9; ++j)
			for (int k = 0; k < n; ++k)
				if (idx[j][k])
					arr[len++] = idx[j][k];
		memset(idx, 0, sizeof(idx));   //清空idx
		ten *= 10;					   //ten*10,下次循环排序更高一位 
	}
	for (int i = 0; i < n; ++i) printf(" %d" + !i, arr[i]);
    return 0;
}
```
运行效果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020083122275134.png)

---
## (3) 优化：65536进制低位优先基数排序
优化之路永无止境。以 $65536$ 为基数，此时对 $32$ 位的整数，只需要进行两次计数排序——先对低 $16$ 位再对高 $16$ 位。具体排序代码如下：
```cpp
inline void radixSort(unsigned A[], int len) {
	unsigned *B = new unsigned[len];
	int r = 65535; //基数为65535
	int L[r + 1] = {0}, H[r + 1] = {0}; //分别对低16位和高16位计数
	for (int i = 0; i < len; ++i) 
		++L[A[i] & r], ++H[(A[i] >> 16) & r); //计数排序
	for (int i = 1; i <= r; ++i) 
		L[i] += L[i - 1], H[i] += H[i - 1]; //求前缀和
	for (int i = len - 1; i >= 0; --i)
		B[--L[A[i] & r]] = A[i];	//对低位进行计数排序
	for (int i = len - 1; i >= 0; --i)
		A[--H[(B[i] >> 16) & r]] = B[i];	//对高位进行计数排序
	delete [] B;
}
```

> 这里解释一下为什么要求前缀和。例如数列 $3, 1, 4, 3$ 进行 $10$ 进制计数后得到的数组 `L` 应该如下：
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200831223530123.png)
> 求前缀和之后，`L` 数组变为：
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200831224230333.png)

所以求前缀和后的 `L[i]` ，表示的是低 $16$ 位 `<= i` 的所有数排序后最后一个数的位置 `+1` ，可以在排序时确定位置。

提交到洛谷上，结果如下，效率几乎翻倍：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200831234737123.png)

---
## (3) 毒瘤实现：256进制低位优先基数排序
对于 $32$ 位整数而言，选择 $65536$ 作为基数几乎是最优的选择：速度快、容易写。但是也有题目如[P4604 [WC2017]挑战](https://www.luogu.com.cn/problem/P4604)一样卡常数，需要以 $256$ 作为基数。代码如下，和 $65536$ 的区别不大：
```cpp
inline void radix_sort(unsigned A[], int len) {
	unsigned *B = new unsigned[len];
	int r = 255;
	int L1[r + 1] = {0}, L2[r + 1] = {0}, H1[r + 1] = {0}, H2[r + 1] = {0}; //H2H1L2L1
	for (int i = 0; i < len; ++i) {
		++L1[A[i] & r];
		++L2[(A[i] >> 8) & r];
		++H1[(A[i] >> 16) & r];
		++H2[(A[i] >> 24) & r];
	}
	for (int i = 1; i <= r; ++i) {
		L1[i] += L1[i - 1];
		L2[i] += L2[i - 1];
		H1[i] += H1[i - 1];
		H2[i] += H2[i - 1];
	}
	for (int i = len - 1; i >= 0; --i) 
		B[--L1[A[i] & r]] = A[i];
	for (int i = len - 1; i >= 0; --i)
		A[--L2[(A[i] >> 8) & r]] = B[i];
	for (int i = len - 1; i >= 0; --i)
		B[--H1[(A[i] >> 16) & r]] = A[i];
	for (int i = len - 1; i >= 0; --i)
		A[--H2[(A[i] >> 24) & r]] = B[i];
	delete [] B;
}
```
利用洛谷的快速排序模板题进行测试，和 $65536$ 没有太大区别：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200901002128252.png)

---
上述代码都是对无符号整数进行的排序。**如果要排序有符号整数，只需要先把所有数加上 `0x80000000` 转换为无符号整数，排序结束后再减去即可**。另外，还可以用基数排序对浮点数排序。
