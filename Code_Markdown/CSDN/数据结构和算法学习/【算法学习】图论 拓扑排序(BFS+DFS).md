@[toc]

BFS和DFS的**直接应用**就是拓扑排序。参与到拓扑排序中的元素之间，**必须存在顺序关系或者依赖关系**——比如，课程学习的先后、穿衣服的先后、事情的缓急程度、进程的优先级等等。

---
# 1. 拓扑排序的基本概念
设有 `a,b,c,d` 四件事情，其中 `a` 的优先级最高，`b,c` 的优先级相同，都小于 `a`，`d` 的优先级最低，那么 `abcd/acbd` 都是可以接受的顺序。

将这些事情作为图的顶点，先后关系、优先级关系作为**有向边**，就抽象出这个问题——在图中进行一个存在先后关系的排序。这就是**拓扑排序**。

显然，一个图**能够拓扑排序**的**充要条件**是：它是一个有向无环图 `Directed Acyclic Graph` 。有环图则不能，因为环的存在说明**图的顶点间不满足偏序关系**。

---
设 $R$ 是集合 $A$ 上的一个二元关系，若 $R$ 满足：
- Ⅰ**自反性**：对 $\forall x \in A$ ，有 $xRx$ ；
- Ⅱ **反对称性**：对 $\forall x,y \in A$ ，如果 $xRy \wedge yRx$ ，则 $x = y$ ；
- Ⅲ **传递性**：对于 $\forall x,y,z \in A$ ，如果 $xRy \wedge yRz$ ，则 $xRz$ 。

则称 $R$ 是 $A$ 上的偏序关系，记作 $\le$ 。注意：$\le$ 不必是指一般意义上的"小于等于"。

全序关系则比偏序更进一步，还需要满足**完全性**：
-  $\forall x,y \in A$ ，必然存在 $a ≤ b \vee b ≤ a$ 。
- 即，**对于集合中的任何一对元素，在这个关系下都是相互可比较的。**

配对了在其上相关的全序关系的集合叫做全序集合（ `totally ordered set` ）、线序集合（ `linearly ordered set` ）或链（ `chain` ）。

全序关系一定是偏序的，但偏序关系不一定是全序的。事实上，在计算机科学中，**普通的排序算法如快排、堆排、归并排序等等，都是建立在全序集合的基础上的**。而找到偏序的线性扩展的算法，就是拓扑排序。

---
# 2. 有向图的入度和出度
拓扑排序需要用到点的入度和出度：
- 出度：以点 $u$ 为**起点**的边的数量称为 $u$ 的出度；
- 入度：以点 $u$ 为**终点**的边的数量称为 $u$ 的出度；

**一个点的入度和出度体现了这个点的先后关系**。如果它的入度是零，说明它是起点；如果它的出度是零，说明它是排在最后面的。下图中，点 $a,c$ 的入度是零，优先级最高；点 $d,e$ 的出度是零，优先级最低：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200727115010690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

另外，拓扑排序的结果可以有多个，上图中的 $a,c$ ，谁排在前面都可以，$d,e$ 也一样。

---
# 3. 基于BFS的拓扑排序
BFS的拓扑排序有两种思路：**无前驱的顶点优先**；**无后继的顶点优先**。

## (1) 基于BFS的无前驱的顶点优先的拓扑排序
先说明无前驱的顶点优先拓扑排序——其方法是：**先输出入度为零、无前驱、优先级最高的顶点**。以下图为例：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200727115647721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
用一个队列 `Q` 作为辅助：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200727121053805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
整个步骤总结如下：
1. 找到所有入度为 `0` 的顶点，放入队列作为起点，这些点的先后关系不重要。**如果找不到入度为** `0` **的顶点**，**说明这个图存在环，不是** `DAG` ，不存在拓扑排序。上图中 `a,c` 入度为 `0` ，进队；
2. 弹出队首 `a` ，`a` 的所有邻接点的入度 `-1` 。把入度减为 `0` 的邻接点 `b` 入队；
3. 继续上述操作，直到队列为空。

队列的输出顺序是 `a,c,b,d` ，包含所有的点，是一个拓扑排序。

## (2) 基于BFS的无后继的顶点优先的拓扑排序
然后是，无后继的顶点优先拓扑排序——其方法是：**先输出出度为零、无后继、优先级最低的顶点**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200727131103707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
整个步骤总结如下：
1. 找到所有出度为 `0` 的顶点，放入队列作为终点，这些点的先后关系不重要。**如果找不到出度为** `0` **的顶点**，**说明这个图存在环，不是** `DAG` ，不存在拓扑排序。上图中 `d` 出度为 `0` ，进队；
2. 弹出队首 `d` ，`d` 的所有邻接点的出度 `-1` 。把出度减为 `0` 的邻接点 `b,c` 入队；
3. 继续上述操作，直到队列为空。

最后，队列输出的是逆序 `d,b,c,a` 。

---
**拓扑排序无解的判断**：如果队列已空，但是还有点未进入队列，那么这些点的入度/出度都不是 `0` ，说明图不是 `DAG` ，不存在拓扑排序。

这种方法可以判断一张有向图中是否有环，另外，还可以用DFS来判断环的存在。

---
**复杂度分析**：初始化时，查找入/出度为 `0` 的点，需要检查每条边，复杂度为 $\text{O(E)}$ ；在队列操作中，每个顶点进队一次，检查它直接连接的所有顶点，复杂度是 $\text{O(V + E)}$ 。总的来说，复杂度是 $\text{O(V + E)}$ 。


---
# 4. 基于DFS的拓扑排序
DFS天然适合拓扑排序。**DFS总是沿着一条路径一直搜索到最底层，然后逐层回退**，这个过程正好体现了**点和点的先后关系**，完美符合拓扑排序的原理。

我们稍微修改一下DFS，就可以完成拓扑排序：
- 一个有向无环图 `DAG` ，如果只有一个点 $u$ 是零入度的，那么从 $u$ 开始DFS，DFS递归**返回**的顺序就是**拓扑排序的逆序**。
- DFS首先**返回**的是最底层的点，它一定是零出度点，没有后续点，是拓扑排序的最后一个点；
- 然后逐步回退，最后输出的是起点 $u$ ；
- 整个顺序是一个**逆序**。

以下图为例，从 $a$ 开始，递归返回的顺序是 `c,d,b,a` 。



---
# 5. 具体实现
## (1) 邻接矩阵版
### ① DFS
### ② BFS

## (2) 邻接表版
### ① DFS
### ② BFS

---

# 6. 习题
输出最小字典序的拓扑排序：
[HDU 1285 确定比赛名次](http://acm.hdu.edu.cn/showproblem.php?pid=1285)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200730001551786.png)

简单拓扑排序：
[HDU 3342 Legal or Not]
[HDU 2647 Reward]
[HDU 5695 Gym Class]


