> 参考算法导论第6章 堆排序
![在这里插入图片描述](https://img-blog.csdnimg.cn/0130d9fad18d42e0b09c6c734b0607c2.png)

@[toc]

这里我们将介绍堆排序算法 `heapsort` 。与归并排序一样、但不同于插入排序的是，堆排序的时间复杂度是 $O(n\log n)$ 。而与插入排序相同、但不同于归并排序的是，堆排序同样具有原地空间性：任何时候都只需要常数个额外的元素空间存储临时数据。因此，堆排序是集合了我们目前已经讨论过的、两种排序算法优点的一种排序算法。

堆排序引入了另一种算法设计技巧：使用一种我们称为“堆”的数据结构来进行信息管理。堆不仅用在堆排序中，而且它也可以构造一种有效的优先队列。后续将多次在算法中引入堆。

虽然“堆”这一词源于堆排序，但目前它已被引申为“垃圾收集存储机制”，例如在Java和Lisp语言中定义的。强调一下，我们使用的堆不是垃圾收集存储，并且在算法学习的部分，只要涉及堆，指的都是堆数据结构，而不是垃圾收集存储。

# 1. 堆
如图6-1所示，（**二叉**）**堆**是一个数组，它可以被看成一个近似的完全二叉树（见算导B.5.3节）。树上的每个结点对应数组中的一个元素。除了最底层外，该树是完全充满的，而且是从左向右填充。表示堆的数组 $A$ 包括两个属性：$A.length$（通常）给出数组元素的个数，$A.heap\_size$ 表示有多少个堆元素存储在该数组中。即，虽然 $A[1\dots A.length]$ 可能都存有数据，但只有 $A[1\dots A.heap\_size]$ 中存放的是堆的有效元素，这里 $0 \le A.heap\_size \le A.length$ 。树的根结点是 $A[1]$ ，这样给定一个结点的下标 $i$ ，我们很容易计算得到它的父结点、左孩子和右孩子的下标：
![在这里插入图片描述](https://img-blog.csdnimg.cn/78da7d934b3746a78d2f0824fd9b53c4.png)
```cpp
PARENT(I)
	return ⌊i/2⌋

LEFT(i)
	return 2i

RIGHT(i)
	return 2i + 1
```

在大多数计算机上，通过将 $i$ 的值左移一位，$\textrm{LEFT}$ 过程可以在一条指令内计算出 $2i$ 。采用类似方法，在 $\textrm{RIGHT}$ 过程中也可以通过将 $i$ 的值左移一位、并在低位加 $1$ ，快速计算 $2i + 1$ 。$\textrm{PARENT}$ 过程则可以通过把 $i$ 的值右移一位计算得到 $\lfloor i / 2 \rfloor$ 。在堆排序的好的实现中，这三个函数通常是以“宏”或“内联函数”的方式实现的。

二叉堆可以分为两种形式：最大堆和最小堆。在这两种堆中，结点的值都要满足**堆性质**，但一些细节定义则有所差异。在**最大堆**中，**最大堆性质**是指：除了根以外的所有结点 $i$ 都要满足：$$A[\mathrm{PARENT}(i) ] \ge A[i]$$

也就是说，某个结点的值至多与其父结点一样大。因此，堆中的最大元素存放在根结点中；并且，在任一子树中，该子树所包含的所有结点的值、都不大于该子树根结点的值。**最小堆**的组织方式正好相反：**最小堆性质**是指：除了根以外的所有结点 $i$ 都要满足：$$A[\mathrm{PARENT}(i) ] \le A[i]$$

最小堆的最小元素存放在根结点中。
 
在堆排序算法中，我们使用的是最大堆。最小堆通常用于构造优先队列，（算导6.5节中）会再具体讨论。对于某个特定的应用来说，我们必须明确需要的是最大堆还是最小堆；而当某一属性既适合于最大堆、也适合于最小堆的时候，我们就只使用“堆”这一名词。

如果把堆看成是一棵树，我们定义一个堆中的结点的**高度**，为「该结点到叶结点的最长简单路径」上边的数目；进而我们可以把堆的高度定义为根结点的高度。既然一个包含 $n$ 个元素的堆，可以看成一棵完全二叉树，那么该堆的高度是 $\Theta(\log n)$（见算导练习6.1-2）。我们会发现，堆结构上的一些基本操作的运行时间，至多与树的高度成正比，即时间复杂度为 $O(\log n)$ 。在剩余部分中，将介绍一些基本过程，并说明如何在排序算法和优先队列中应用它们。
- `MAX-HEAPIFY` 过程：其时间复杂度为 $O(\log n)$ ，它是维护最大堆性质的关键。
- `BUILD-MAX-HEAP` 过程：具有线性时间复杂度，功能是从无序的输入数据数组中，构造一个最大堆。
- `HEAPSORT` 过程：其时间复杂度为 $O(n \log n)$ ，功能是对一个数组进行原地排序。
- `MAX-HEAP-INSERT, HEAP-EXTRACT-MAX, HEAP-INCREASE-KEY, HEAP-MAXIMUM` 过程：时间复杂度为 $O(\log n)$ ，功能是利用堆实现一个优先队列。


---
# 2. 维护堆的性质
`MAX-HEAPIFY` 是用于维护最大堆性质的重要过程。它的输入为一个数组 $A$ 和一个下标 $i$ 。在调用 `MAX-HEAPIFY` 时，我们假定**根结点为 `LEFT(i)` 和 `RIGHT(i)` 的二叉树都是最大堆**，但这时 $A[i]$ 有可能小于其孩子，这样就违背了最大堆的性质。`MAX-HEAPIFY` 通过让 $A[i]$ 的值在最大堆中“逐级下降”，从而使得「以下标 $i$ 为根结点的子树」重新遵循最大堆的性质。
```cpp
MAX-HEAPIFY(A, i)
	l = LEFT(i)
	r = RIGHT(i)
	if l <= A.heap_size and A[l] > A[i]
		largest = l
	else largest = i
	if r <= A.heap_size and A[r] > A[largest]
		largest = r
	if largest != i
		exchange A[i] with A[largest]
		MAX-HEAPIFY(A, largest)
```
图6-2图示了 `MAX-HEAPIFY` 的执行过程。在程序的每一步中，从 $A[i], A[\mathrm{LEFT}(i) ]$ 和 $A[\mathrm{RIGHT}(i) ]$ 中选出最大的，并将其下标存储在 $largest$ 中。
- 如果 $A[i]$ 是最大的，那么「以 $i$ 为根结点的子树」已经是最大堆，程序结束。
- 否则，最大元素是 $i$ 的某个孩子结点，则交换 $A[i]$ 和 $A[largest]$ 的值，从而使 $i$ 及其孩子都满足最大堆的性质。在交换后，下标为 $largest$ 的结点的值是原来的 $A[i]$ ，于是「以该结点为根的子树」又有可能违反最大堆的性质。因此，需要对该子树递归调用 `MAX-HEAPIFY` 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/d71084c10b59431d959fcb1fd73a8b6c.png)

对于一棵「以 $i$ 为根结点、大小为 $n$ 的子树」，`MAX-HEAPIFY` 的时间代价包括：调整 $A[i], A[\mathrm{LEFT}(i) ], A[\mathrm{RIGHT}(i) ]$ 的关系的时间代价 $\Theta(1)$ ，加上在一棵「以 $i$ 的一个孩子为根节点的子树」上运行 `MAX-HEAPIFY` 的时间代价（这里假设递归调用会发生）。因为每个孩子的子树的大小至多为 $2n / 3$（最坏情况发生在树的最底层恰好半满的时候），我们可以用下面这个递归式刻画 `MAX-HEAPIFY` 的运行时间：$$T(n) \le T(2n /3 ) + \Theta(1)$$ 根据主定理（定理4.1）的情况2，上述递归式的解为 $T(n)= O(\log n)$ 。也就是说，对于一个树高为 $h$ 的结点来说，`MAX-HEAPIFY` 的时间复杂度为 $O(h)$ 。


---
# 3. 建堆
我们可以用自底向上的方法，利用过程 `MAX-HEAPIFY` 把一个大小为 $n = A.length$ 的数组 $A[1\dots n]$ 转换为最大堆。（通过算导练习6.1-7可知）==子数组 $A( \lfloor n / 2 \rfloor + 1 \dots n)$ 的元素都是树的叶结点。每个叶结点都可以看成只包含一个元素的堆==。过程 `BUILD-MAX-HEAP` 对树中的其他结点，都调用一次 `MAX-HEAPIFY` 。
```cpp
BUILD-MAX-HEAP(A)
	A.heap_size = A.length
	for i = ⌊A.length / 2⌋ downto 1
		MAX-HEAPIFY(A, i)
```
图6-3给出了 `BUILD-MAX-HEAP` 过程的一个例子。
![在这里插入图片描述](https://img-blog.csdnimg.cn/eaf93b0d7ae245dcacc861953fc619da.png)

为了证明 `BUILD-MAX-HEAP` 的正确性，我们使用如下的循环不变量：
- 在第 $2 \sim 3$ 行中每一次 for 循环的开始，结点 $i +1, i + 2, \dots, n$ 都是一个最大堆的根结点。
 
我们需要证明**这一不变量在第一次循环前为真，并且每次循环迭代都维持不变**。当循环结束时，这一不变量可以用于证明正确性。
1. **初始化**：在第一次循环迭代之前，$i = \lfloor n / 2\rfloor$ ，而 $\lfloor n / 2\rfloor + 1,\ \lfloor n / 2\rfloor + 2,\ \dots,\ n$ 都是叶结点，因而是平凡最大堆的根结点。
2. **保持**：为了看到每次迭代都维护这个循环不变量，注意到结点 $i$ 的孩子结点的下标均比 $i$ 大。所以根据循环不变量，它们都是最大堆的根。这也是调用 `MAX-HEAPIFY(A, i)` 使结点 $i$ 成为一个最大堆的根的先决条件。而且，`MAX-HEAPIFY` 维护了结点 $i + 1, i + 2, \dots, n$ 都是一个最大堆的根结点的性质。在 for 循环中递减 $i$ 的值，为下一次循环重新建立循环不变量。
3. **终止**：过程终止时，$i = 0$ 。根据循环不变量，每个结点 $1, 2, \dots, n$ 都是一个最大堆的根。特别需要指出的是，结点 $1$ 就是最大的那个堆的根结点。

我们可以用下面的方法，简单地估算 `BUILD-MAX-HEAP` 运行时间的上界。每次调用 `MAX-HEAPIFY` 的时间复杂度为 $O(\log n)$ ，`BUILD-MAX-HEAP` 需要 $O(n)$ 次这样的调用。因此总的时间复杂度是 $O(n \log n)$ 。当然，这个上界虽然正确，但不是**渐近紧确**的。

我们还可以进一步得到一个更紧确的界。可以观察到，不**同结点运行 `MAX-HEAPIFY` 的时间与该结点的树高相关，而且大部分结点的高度都很小**。因此，利用如下性质，可以得到更紧确的界：包含 $n$ 个元素的堆的高度为 $\lfloor \log n \rfloor$（见算导练习6.1-2）；高度为 $h$ 的堆最多包含 $\lceil n  / 2^{h + 1} \rceil$ 个结点（见算导练习6.3-3）（？）。

在一个高度为 $h$ 的结点上，运行 `MAX-HEAPIFY` 的代价是 $O(h)$ ，我们可以将 `BUILD-MAX-HEAP` 的总代价表示为：$$\sum^{ \lfloor \log n \rfloor}_{ h = 0} \bigg \lceil \dfrac{n}{ 2^{h+1} }\bigg \rceil O(h) = O\bigg( n \sum^{\lfloor \log n \rfloor}_{h = 0} \dfrac{h }{2^h} \bigg)$$ 最后的一个累积和的计算，可以用 $x = 1/2$ 代入（算导公式 $(A.8)$ ）得到，则有：$$\sum^{\infin}_{ h = 0} \dfrac{h}{2^h} = \dfrac{ 1/ 2} { (1 - 1/2)^2} = 2$$ 

于是，我们可以得到 `BUILD-MAX-HEAP` 的时间复杂度：$$O\bigg( n \sum^{\lfloor \log n \rfloor}_{h = 0} \dfrac{h }{2^h} \bigg) = O\bigg( n \sum^{\infin}_{h = 0}\dfrac{h }{2^h} \bigg) = O(n)$$

因此，我们可以在线性时间内，把一个无序数组构造成为一个最大堆。
 
类似地，我们也可以通过调用 `BUILD-MIN-HEAP` 构成一个最小堆。除了第三行的调用替换为 `MIN-HEAPIFY`（见算导练习6.2-2）以外，`BUILD-MIN-HEAP` 与 `BUILD-MAX-HEAP` 完全相同。`BUILD-MIN-HEAP` 可以在线性时间内，把一个无序数组构造成为一个最小堆。

---
# 4. 堆排序算法
初始时候，堆排序算法利用 `BUILD-MAX-HEAP` 将输入数组 $A[1 \dots n]$ 建成最大堆，其中 $n = A.length$ ，**因为数组中的最大元素总在根结点 $A[1]$ 中，通过把它与 $A[n]$ 进行互换，我们可以让该元素放到正确的位置**。这时，如果我们从堆中去掉结点 $n$（这一操作可以通过减少 $A.heap\_size$ 的值来实现），剩余的结点中，原来根的孩子结点仍然是最大堆，而新的根结点可能会违反最大堆的性质。为了维护最大堆的性质，我们要做的是调用 `MAX-HEAPIFY(A, 1)` ，从而在 $A[1 \dots n - 1]$ 上构造一个新的最大堆。堆排序算法会不断重复这一过程，直到堆的大小从 $n - 1$ 降到 $2$（准确的循环不变量定义见算导练习6.4-2）。
```cpp
HEAPSORT(A)
	BUILD-MAX-HEAP(A)
	for i = A.length downto 2
		exchange A[1] with A[i]
		A.heap_size -= 1
		MAX-HEAPIFY(A, 1)
```
图6-4给出了一个在 `HEAPSORT` 的第一行建立初始最大堆之后，堆排序操作的一个例子。图6-4显示了第 $2 \sim 5$ 行 for 循环第一次迭代开始前最大堆的情况，和每一次迭代之后最大堆的情况。
![在这里插入图片描述](https://img-blog.csdnimg.cn/474ad54d5f08419ba8db006179f3affb.png)
`HEAPSORT` 过程的时间复杂度为 $O(n \log n)$ ，因为每次调用 `BUILD-MAX-HEAP` 的时间复杂度为 $O(n)$ ，而 $n - 1$ 次调用 `MAX-HEAPIFY` ，每次的时间为 $O(\log n)$ 。


---
# 5. 优先队列
堆排序是一个优秀的算法，但在实际应用中，（算导第7章）将介绍的快速排序的性能一般优于堆排序。尽管如此，堆这一数据结构仍然有很多应用。在这一节中，我们要介绍堆的一个常见应用：作为高效的优先队列。和堆一样，优先队列也有两种形式：最大优先队列和最小优先队列。这里，我们关注如何基于最大堆实现最大优先队列（算导练习6.5-3会要求编写最小优先队列过程）。

**优先队列** `priority queue` 是一种数据结构，用来维护由一组元素构成的集合 $S$ ，其中的每一个元素都有一个相关的值，称为**关键字** `key` 。一个**最大优先对列**支持以下操作：
- `INSERT(S, x)` ：把元素 $x$ 插入集合 $S$ 中。这一操作等价于 $S = S \cup \{ x\}$ 。
- `MAXIMUM(S)` ：返回 $S$ 中具有最大关键字的元素。
- `EXTRACT-MAX(S)` ：去掉并返回 $S$ 中的、具有最大关键字的元素。
- `INCREASE-KEY(S, x, k)` ：将元素 $x$ 的关键字值增加到 $k$ ，这里假设 $k$ 的值不小于 $x$ 的原关键字值。


最大优先队列的应用有很多，其中一个就是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业、以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器调用 `EXTRACT-MAX` 从所有的等待作业中，选出具有最高优先级的作业来执行。在任何时候，调度器可以调用 `INSERT` 把一个新作业加入到队列中来。

相应地，**最小优先队列**支持的操作包括 `INSERT, MINIMUM, EXTRACT-MIN, DECREASE-KEY` 。最小优先队列可以用于「基于事件驱动的模拟器」。队列中保存要模拟的事件，每个事件都有一个发生时间作为其关键字。事件必须按照发生的时间顺序进行模拟，因为某一事件的模拟结果可能会触发对其他事件的模拟。在每一步，模拟程序调用 `EXTRACT-MIN` 来选择下一个要模拟的事件。当一个新事件产生时，模拟器通过调用 `INSERT` 将其插入最小优先队列中（算导第23、24章中，将看到最小优先队列的其他用途，特别是对 `DECREASE-KEY` 操作的使用）。显然，**优先队列可以用堆来实现**。

> 对一个像作业调度或事件驱动模拟器这样的应用程序来说，优先队列的元素对应着应用程序中的对象。通常我们需要确定，哪个对象对应一个给定的优先队列元素，反之亦然。因此，在用堆来实现优先队列时，需要在堆中的每个元素里存储对应对象的 `handle`（如一个指针或一个整型数等，其准确含义依赖于具体的应用程序）。同样，在应用程序的对象中，我们也需要存储一个堆中对应元素的 `handle` ，通常这一 `handle` 是数组的下标。由于在堆的操作过程中，元素会改变其在数组中的位置。因此在具体的实现中，在重新确定堆元素位置时，我们也需要更新相应应用程序对象中的数组下标。因为对应用程序对象的访问细节、强烈依赖于应用程序及其实现方式，这里不做详细讨论。需要强调的是，这些 `handle` 也需要被正确地维护。

现在讨论如何实现最大优先队列的操作。过程 `HEAP-MAXIMUM` 可以在 $\Theta(1)$ 时间内实现 `MAXIMUM` 操作。
```cpp
HEAP-MAXIMUM(A)
	return A[1]
```
过程 `HEAP-EXTRACT-MAX` 实现 `EXTRACT-MAX` 操作。它与 `HEAPSORT` 过程中的 for 循环体部分（第三至五行）很相似。`HEAP-EXTRACT-MAX` 的时间复杂度为 $O(\log n)$ ，因为除了时间复杂度为 $O(\log n)$ 的 `MAX-HEAPIFY` 以外，它的其他操作都是常数阶的。
```cpp
HEAP-EXTRACT-MAX(A)
	if A.heap_size < 1 
		error "heap underflow"
	max = A[1]
	A[1] = A[A.heap_size]
	A.heap_size -= 1
	MAX-HEAPIFY(A, 1)
	return max
```
`HEAP-INCREASE-KEY` 能够实现 `INCREASE-KEY` 操作。在优先队列中，我们希望增值关键字的优先队列元素由对应的数组下标 $i$ 来标识。这一操作需要首先将元素 $A[i]$ 的关键字更新为新值。因为增大 $A[i]$ 的关键字可能会违反最大堆的性质，所以上述操作采用了（类似于算导2.1节 `INSERTION-SORT` 中插入循环算法第五至七行）的方式，在从当前结点到根结点的路径上，为新增关键字寻找恰当的插入位置。在 `HEAP-INCREASE-KEY` 的操作过程中，当前元素会不断地与其父结点进行比较，如果当前元素的关键字较大，则当前元素与其父结点进行交换。这一过程会不断地重复，直到当前元素的关键字小于其父结点时终止，因为此时已经重新符合了最大堆的性质（准确的循环不变量表示，见算导练习6.5-5）。
```cpp
HEAP-INCREASE-KEY(A, i, key)
	if key < A[i]
		error "new key is smaller than current key"
	A[i] = key
	while i > 1 and A[PARENT(i)] < A[i]
		exchange A[i] with A[PARENT(i)]
		i = PARENT(i)
```
图6-5显示了 `HEAP-INCREASE-KEY` 的一个操作过程。在包含 $n$ 个元素的堆上，`HEAP-INCREASE-KEY` 的时间复杂度是 $O(\log n)$ 。这是因为在算法第三行，做了关键字更新的结点到根结点的路径长度为 $O(\log n)$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/df597114d0454b80b537f806853b1c68.png)
`MAX-HEAP-INSERT` 能够实现 `INSERT` 操作。它的输入是要被插入到最大堆 $A$ 中的新元素的关键字。`MAX-HEAP-INSERT` 首先通过增加一个关键字为 $-\infin$ 的叶结点来扩展最大堆。然后调用 `HEAP-INCREASE-KEY` 为新结点设置对应的关键字，同时保持最大堆的性质。
```cpp
MAX-HEAP-INSERT(A, key)
	A.heap_size = A.heap_size + 1
	A[A.heap_size] = -inf
	HEAP-INCREASE-KEY(A, A.heap_size, key)
```
在包含 $n$ 个元素的堆中，`MAX-HEAP-INSERT` 的运行时间为 $O(\log n)$ 。

总之，在一个包含 $n$ 个元素的堆中，所有优先队列的操作都可以在 $O(\log n)$ 时间内完成。
