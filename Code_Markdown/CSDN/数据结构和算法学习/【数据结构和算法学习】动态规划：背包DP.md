author: hydingsy, Link-cute, Ir1d, greyqz, LuoshuiTianyi, Odeinjul, xyf007, GoodCoder666, paigeman

前置知识：[动态规划部分简介](./index.md)。

## 引入

在具体讲何为「背包 dp」前，先来看如下的例题：

???+ note "[「USACO07 DEC」Charm Bracelet](https://www.luogu.com.cn/problem/P2871)"
    题意概要：有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。

在上述例题中，由于每个物体只有两种可能的状态（取与不取），对应二进制中的 $0$ 和 $1$，这类问题便被称为「0-1 背包问题」。

## 0-1 背包

### 解释

例题中已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 $W$。

设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。

考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；当其放入背包时，背包的剩余容量会减小 $w_{i}$，背包中物品的总价值会增大 $v_{i}$，故这种情况的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。

由此可以得出状态转移方程：

$$
f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})
$$

这里如果直接采用二维数组对状态进行记录，会出现 MLE。可以考虑改用滚动数组的形式来优化。

由于对 $f_i$ 有影响的只有 $f_{i-1}$，可以去掉第一维，直接用 $f_{i}$ 来表示处理到当前物品时背包容量为 $i$ 的最大价值，得出以下方程：

$$
f_j=\max \left(f_j,f_{j-w_i}+v_i\right)
$$

**务必牢记并理解这个转移方程，因为大部分背包问题的转移方程都是在此基础上推导出来的。**

### 实现

还有一点需要注意的是，很容易写出这样的 **错误核心代码**：

=== "C++"

    ```cpp
    for (int i = 1; i <= n; i++)
      for (int l = 0; l <= W - w[i]; l++)
        f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);
    // 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]], f[i - 1][l] + w[i]),
    // f[i][l + w[i]]); 简化而来
    ```

=== "Python"

    ```python
    for i in range(1, n + 1):
        for l in range(0, W - w[i] + 1):
            f[l + w[i]] = max(f[l] + v[i], f[l + w[i]])
    # 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]], f[i - 1][l] + w[i]),
    # f[i][l + w[i]]) 简化而来
    ```

这段代码哪里错了呢？枚举顺序错了。

仔细观察代码可以发现：对于当前处理的物品 $i$ 和当前状态 $f_{i,j}$，在 $j\geqslant w_{i}$ 时，$f_{i,j}$ 是会被 $f_{i,j-w_{i}}$ 所影响的。这就相当于物品 $i$ 可以多次被放入背包，与题意不符。（事实上，这正是完全背包问题的解法）

为了避免这种情况发生，我们可以改变枚举的顺序，从 $W$ 枚举到 $w_{i}$，这样就不会出现上述的错误，因为 $f_{i,j}$ 总是在 $f_{i,j-w_{i}}$ 前被更新。

因此实际核心代码为

=== "C++"

    ```cpp
    for (int i = 1; i <= n; i++)
      for (int l = W; l >= w[i]; l--)
        f[l] = max(f[l], f[l - w[i]] + v[i]);
    ```

=== "Python"

    ```python
    for i in range(1, n + 1):
        for l in range(W, w[i] - 1, -1):
            f[l] = max(f[l], f[l - w[i]] + v[i])
    ```

??? 例题代码
    ```cpp
    --8<-- "docs/dp/code/knapsack/knapsack_1.cpp"
    ```

## 完全背包

### 解释

完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。

我们可以借鉴 0-1 背包的思路，进行状态定义：设 $f_{i,j}$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。

需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。

### 过程

可以考虑一个朴素的做法：对于第 $i$ 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 $O(n^3)$ 的。

状态转移方程如下：

$$
f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)
$$

考虑做一个简单的优化。可以发现，对于 $f_{i,j}$，只要通过 $f_{i,j-w_i}$ 转移就可以了。因此状态转移方程为：

$$
f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)
$$

理由是当我们这样转移时，$f_{i,j-w_i}$ 已经由 $f_{i,j-2\times w_i}$ 更新过，那么 $f_{i,j-w_i}$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。

与 0-1 背包相同，我们可以将第一维去掉来优化空间复杂度。如果理解了 0-1 背包的优化方式，就不难明白压缩后的循环是正向的（也就是上文中提到的错误优化）。

??? note "[「Luogu P1616」疯狂的采药](https://www.luogu.com.cn/problem/P1616)"
    题意概要：有 $n$ 种物品和一个容量为 $W$ 的背包，每种物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干个物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。

??? 例题代码
    ```cpp
    --8<-- "docs/dp/code/knapsack/knapsack_2.cpp"
    ```

## 多重背包

多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有 $k_i$ 个，而非一个。

一个很朴素的想法就是：把「每种物品选 $k_i$ 次」等价转换为「有 $k_i$ 个相同的物品，每个物品选一次」。这样就转换成了一个 0-1 背包模型，套用上文所述的方法就可已解决。状态转移方程如下：

$$
f_{i,j}=\max_{k=0}^{k_i}(f_{i-1,j-k\times w_i}+v_i\times k)
$$

时间复杂度 $O(W\sum_{i=1}^nk_i)$。

### 二进制分组优化

考虑优化。我们仍考虑把多重背包转化成 0-1 背包模型来求解。

### 解释

显然，复杂度中的 $O(nW)$ 部分无法再优化了，我们只能从 $O(\sum k_i)$ 处入手。为了表述方便，我们用 $A_{i,j}$ 代表第 $i$ 种物品拆分出的第 $j$ 个物品。

在朴素的做法中，$\forall j\le k_i$，$A_{i,j}$ 均表示相同物品。那么我们效率低的原因主要在于我们进行了大量重复性的工作。举例来说，我们考虑了「同时选 $A_{i,1},A_{i,2}$」与「同时选 $A_{i,2},A_{i,3}$」这两个完全等效的情况。这样的重复性工作我们进行了许多次。那么优化拆分方式就成为了解决问题的突破口。

### 过程

我们可以通过「二进制分组」的方式使拆分方式更加优美。

具体地说就是令 $A_{i,j}\left(j\in\left[0,\lfloor \log_2(k_i+1)\rfloor-1\right]\right)$ 分别表示由 $2^{j}$ 个单个物品「捆绑」而成的大物品。特殊地，若 $k_i+1$ 不是 $2$ 的整数次幂，则需要在最后添加一个由 $k_i-2^{\lfloor \log_2(k_i+1)\rfloor-1}$ 个单个物品「捆绑」而成的大物品用于补足。

举几个例子：

-   $6=1+2+3$
-   $8=1+2+4+1$
-   $18=1+2+4+8+3$
-   $31=1+2+4+8+16$

显然，通过上述拆分方式，可以表示任意 $\le k_i$ 个物品的等效选择方式。将每种物品按照上述方式拆分后，使用 0-1 背包的方法解决即可。

时间复杂度 $O(W\sum_{i=1}^n\log_2k_i)$

### 实现

??? 二进制分组代码
    === "C++"
    
        ```cpp
        index = 0;
        for (int i = 1; i <= m; i++) {
          int c = 1, p, h, k;
          cin >> p >> h >> k;
          while (k > c) {
            k -= c;
            list[++index].w = c * p;
            list[index].v = c * h;
            c *= 2;
          }
          list[++index].w = p * k;
          list[index].v = h * k;
        }
        ```
    
    === "Python"
    
        ```python
        index = 0
        for i in range(1, m + 1):
            c = 1
            p, h, k = map(int, input().split())
            while k > c:
                k -= c
                list[index].w = c * p
                index += 1
                list[index].v = c * h
                c *= 2
            list[index].w = p * k
            index += 1
            list[index].v = h * k
        ```

### 单调队列优化

见 [单调队列/单调栈优化](./opt/monotonous-queue-stack.md)。

习题：[「Luogu P1776」宝物筛选\_NOI 导刊 2010 提高（02）](https://www.luogu.com.cn/problem/P1776)

## 混合背包

混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取 $k$ 次。

这种题目看起来很吓人，可是只要领悟了前面几种背包的中心思想，并将其合并在一起就可以了。下面给出伪代码：

### 过程

```plain
for (循环物品种类) {
  if (是 0 - 1 背包)
    套用 0 - 1 背包代码;
  else if (是完全背包)
    套用完全背包代码;
  else if (是多重背包)
    套用多重背包代码;
}
```

??? note "[「Luogu P1833」樱花](https://www.luogu.com.cn/problem/P1833)"
    题意概要：有 $n$ 种樱花树和长度为 $T$ 的时间，有的樱花树只能看一遍，有的樱花树最多看 $A_{i}$ 遍，有的樱花树可以看无数遍。每棵樱花树都有一个美学值 $C_{i}$，求在 $T$ 的时间内看哪些樱花树能使美学值最高。

## 二维费用背包

???+ note "[「Luogu P1855」榨取 kkksc03](https://www.luogu.com.cn/problem/P1855)"
    有 $n$ 个任务需要完成，完成第 $i$ 个任务需要花费 $t_i$ 分钟，产生 $c_i$ 元的开支。
    
    现在有 $T$ 分钟时间，$W$ 元钱来处理这些任务，求最多能完成多少任务。

这道题是很明显的 0-1 背包问题，可是不同的是选一个物品会消耗两种价值（经费、时间），只需在状态中增加一维存放第二种价值即可。

这时候就要注意，再开一维存放物品编号就不合适了，因为容易 MLE。

### 实现

=== "C++"

    ```cpp
    for (int k = 1; k <= n; k++)
      for (int i = m; i >= mi; i--)    // 对经费进行一层枚举
        for (int j = t; j >= ti; j--)  // 对时间进行一层枚举
          dp[i][j] = max(dp[i][j], dp[i - mi][j - ti] + 1);
    ```

=== "Python"

    ```python
    for k in range(1, n + 1):
        for i in range(m, mi - 1, -1): # 对经费进行一层枚举
            for j in range(t, ti - 1, -1): # 对时间进行一层枚举
                dp[i][j] = max(dp[i][j], dp[i - mi][j - ti] + 1)
    ```

## 分组背包

???+ note "[「Luogu P1757」通天之分组背包](https://www.luogu.com.cn/problem/P1757)"
    有 $n$ 件物品和一个大小为 $m$ 的背包，第 $i$ 个物品的价值为 $w_i$，体积为 $v_i$。同时，每个物品属于一个组，同组内最多只能选择一个物品。求背包能装载物品的最大总价值。

这种题怎么想呢？其实是从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。

再说一说如何进行存储。我们可以将 $t_{k,i}$ 表示第 $k$ 组的第 $i$ 件物品的编号是多少，再用 $\mathit{cnt}_k$ 表示第 $k$ 组物品有多少个。

### 实现

=== "C++"

    ```cpp
    for (int k = 1; k <= ts; k++)           // 循环每一组
      for (int i = m; i >= 0; i--) // 循环背包容量
        for (int j = 1; j <= cnt[k]; j++)   // 循环该组的每一个物品
          if (i >= w[t[k][j]])  // 背包容量充足
            dp[i] = max(dp[i], dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移
    ```

=== "Python"

    ```python
    for k in range(1, ts + 1): # 循环每一组
        for i in range(m, -1, -1): # 循环背包容量
            for j in range(1, cnt[k] + 1):     # 循环该组的每一个物品
                if i >= w[t[k][j]]: #背包容量充足
                    dp[i] = max(dp[i], dp[i - w[t[k][j]]] + c[t[k][j]]) # 像0-1背包一样状态转移
    ```

这里要注意：**一定不能搞错循环顺序**，这样才能保证正确性。

## 有依赖的背包

???+ note "[「Luogu P1064」金明的预算方案](https://www.luogu.com.cn/problem/P1064)"
    金明有 $n$ 元钱，想要买 $m$ 个物品，第 $i$ 件物品的价格为 $v_i$，重要度为 $p_i$。有些物品是从属于某个主件物品的附件，要买这个物品，必须购买它的主件。
    
    目标是让所有购买的物品的 $v_i \times p_i$ 之和最大。

考虑分类讨论。对于一个主件和它的若干附件，有以下几种可能：只买主件，买主件 + 某些附件。因为这几种可能性只能选一种，所以可以将这看成分组背包。

如果是多叉树的集合，则要先算子节点的集合，最后算父节点的集合。

## 泛化物品的背包

这种背包，没有固定的费用和价值，它的价值是随着分配给它的费用而定。在背包容量为 $V$ 的背包问题中，当分配给它的费用为 $v_i$ 时，能得到的价值就是 $h\left(v_i\right)$。这时，将固定的价值换成函数的引用即可。

## 杂项

### 小优化

根据贪心原理，当费用相同时，只需保留价值最高的；当价值一定时，只需保留费用最低的；当有两件物品 $i,j$ 且 $i$ 的价值大于 $j$ 的价值并且 $i$ 的费用小于 $j$ 的费用时，只需保留 $i$。

### 背包问题变种

#### 实现

输出方案其实就是记录下来背包中的某一个状态是怎么推出来的。我们可以用 $g_{i,v}$ 表示第 $i$ 件物品占用空间为 $v$ 的时候是否选择了此物品。然后在转移时记录是选用了哪一种策略（选或不选）。输出时的伪代码：

```cpp
int v = V;  // 记录当前的存储空间

// 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环
for (从最后一件循环至第一件) {
  if (g[i][v]) {
    选了第 i 项物品;
    v -= 第 i 项物品的重量;
  } else {
    未选第 i 项物品;
  }
}
```

#### 求方案数

对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。

这种问题就是把求最大值换成求和即可。

例如 0-1 背包问题的转移方程就变成了：

$$
\mathit{dp}_i=\sum(\mathit{dp}_i,\mathit{dp}_{i-c_i})
$$

初始条件：$\mathit{dp}_0=1$

因为当容量为 $0$ 时也有一个方案，即什么都不装。

#### 求最优方案总数

要求最优方案总数，我们要对 0-1 背包里的 $\mathit{dp}$ 数组的定义稍作修改，DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包「正好装满」所能达到的最大总价值。

这样修改之后，每一种 DP 状态都可以用一个 $g_{i,j}$ 来表示方案数。

$f_{i,j}$ 表示只考虑前 $i$ 个物品时背包体积「正好」是 $j$ 时的最大价值。

$g_{i,j}$ 表示只考虑前 $i$ 个物品时背包体积「正好」是 $j$ 时的方案数。

转移方程：

如果 $f_{i,j} = f_{i-1,j}$ 且 $f_{i,j} \neq f_{i-1,j-v}+w$ 说明我们此时不选择把物品放入背包更优，方案数由 $g_{i-1,j}$ 转移过来，

如果 $f_{i,j} \neq f_{i-1,j}$ 且 $f_{i,j} = f_{i-1,j-v}+w$ 说明我们此时选择把物品放入背包更优，方案数由 $g_{i-1,j-v}$ 转移过来，

如果 $f_{i,j} = f_{i-1,j}$ 且 $f_{i,j} = f_{i-1,j-v}+w$ 说明放入或不放入都能取得最优解，方案数由 $g_{i-1,j}$ 和 $g_{i-1,j-v}$ 转移过来。

初始条件：

```cpp
memset(f, 0x3f3f, sizeof(f));  // 避免没有装满而进行了转移
f[0] = 0;
g[0] = 1;  // 什么都不装是一种方案
```

因为背包体积最大值有可能装不满，所以最优解不一定是 $f_{m}$。

最后我们通过找到最优解的价值，把 $g_{j}$ 数组里取到最优解的所有方案数相加即可。

???+ note "实现"
    ```cpp
    for (int i = 0; i < N; i++) {
      for (int j = V; j >= v[i]; j--) {
        int tmp = std::max(dp[j], dp[j - v[i]] + w[i]);
        int c = 0;
        if (tmp == dp[j]) c += cnt[j];                       // 如果从dp[j]转移
        if (tmp == dp[j - v[i]] + w[i]) c += cnt[j - v[i]];  // 如果从dp[j-v[i]]转移
        dp[j] = tmp;
        cnt[j] = c;
      }
    }
    int max = 0;  // 寻找最优解
    for (int i = 0; i <= V; i++) {
      max = std::max(max, dp[i]);
    }
    int res = 0;
    for (int i = 0; i <= V; i++) {
      if (dp[i] == max) {
        res += cnt[i];  // 求和最优解方案数
      }
    }
    ```

#### 背包的第 k 优解

普通的 0-1 背包是要求最优解，在普通的背包 DP 方法上稍作改动，增加一维用于记录当前状态下的前 k 优解，即可得到求 0-1 背包第 $k$ 优解的算法。
具体来讲：$\mathit{dp_{i,j,k}}$ 记录了前 $i$ 个物品中，选择的物品总体积为 $j$ 时，能够得到的第 $k$ 大的价值和。这个状态可以理解为将普通 0-1 背包只用记录一个数据的 $\mathit{dp_{i,j}}$ 扩展为记录一个有序的优解序列。转移时，普通背包最优解的求法是 $\mathit{dp_{i,j}}=\max(\mathit{dp_{i-1,j}},\mathit{dp_{i-1,j-v_{i}}}+w_{i})$，现在我们则是要合并 $\mathit{dp_{i-1,j}}$，$\mathit{dp_{i-1,j-v_{i}}}+w_{i}$ 这两个大小为 $k$ 的递减序列，并保留合并后前 $k$ 大的价值记在 $\mathit{dp_{i,j}}$ 里，这一步利用双指针法，复杂度是 $O(k)$ 的，整体时间复杂度为 $O(nmk)$。空间上，此方法与普通背包一样可以压缩掉第一维，复杂度是 $O(mk)$ 的。

??? note "[例题 hdu 2639 Bone Collector II](https://vjudge.net/problem/HDU-2639)"
    求 0-1 背包的严格第 $k$ 优解。$n \leq 100,v \leq 1000,k \leq 30$

??? note "实现"
    ```cpp
    memset(dp, 0, sizeof(dp));
    int i, j, p, x, y, z;
    scanf("%d%d%d", &n, &m, &K);
    for (i = 0; i < n; i++) scanf("%d", &w[i]);
    for (i = 0; i < n; i++) scanf("%d", &c[i]);
    for (i = 0; i < n; i++) {
      for (j = m; j >= c[i]; j--) {
        for (p = 1; p <= K; p++) {
          a[p] = dp[j - c[i]][p] + w[i];
          b[p] = dp[j][p];
        }
        a[p] = b[p] = -1;
        x = y = z = 1;
        while (z <= K && (a[x] != -1 || b[y] != -1)) {
          if (a[x] > b[y])
            dp[j][z] = a[x++];
          else
            dp[j][z] = b[y++];
          if (dp[j][z] != dp[j][z - 1]) z++;
        }
      }
    }
    printf("%d\n", dp[m][K]);
    ```

## 参考资料与注释

-   [背包问题九讲 - 崔添翼](https://github.com/tianyicui/pack)。



[[动态规划/0x51 线性DP|0x51 线性DP]]

---
@[toc]

背包问题是动态规划的一类基本问题，其种类繁多，用途多样，题型多变，引人生畏，算得上是算法学习过程中的一头拦路猛虎。这篇文章将涵盖 [*dd_engi* 背包九讲](https://github.com/tianyicui/pack)的所有内容，基本框架基本相同，但会加上许多个人的理解领悟、代码实现和诸多OJ题目，同时参考以下算法图书，实现对背包问题的一网打尽。
- 算法竞赛进阶指南，李煜东；
- 算法竞赛入门到进阶，罗勇军；
- 算法竞赛入门经典，刘汝佳
- 挑战程序竞赛……

---
# 1. 01背包问题
## 1.1 题目
有 $N$ 件物品和一个容量为 $V$ 的背包，放入第 $i$ 件物品耗费的费用是 $c_i$[^1] ，得到的价值是 $v_i$ 。求解：将哪些物品装入背包，可使得价值总和最大。
## 1.2 基本思路


---
# 2. 完全背包问题

---
# 3. 多重背包问题


---
# 4. 混合三种背包的问题

---
# 5. 二维费用的背包问题

---
# 6. 分组的背包问题

---
# 7. 有依赖的背包问题

---
# 8. 泛化物品

---
# 9. 背包问题的问法变化


[^1]: 即占用的背包空间容量，后面统一称为“费用” `cost` 。


@[toc]

---
## 1. 什么是背包
面前有一堆物品，每种物品有自己的**价值**和体积（或者说**代价**），我们手中有一个有限容积的背包，问：都装进去些什么东西，这个背包的价值最大。

设背包的体积为 $V$ （我们可以支付的最大代价）；物品的价值为 $c$ ，物品体积为 $w$ 。

---
## 2. 01背包
什么是01背包？我们假设**每种物品的数量只有一个**，因此对每个物品只有**拿**和**不拿**两种选择。于是设二维DP数组 `dp[][]` ， **`dp[i][j]` 为 `1 ~ i` 个物品中，占用当前背包的体积为 `j` 的情况下（不一定要占满），背包中的最大价值。**

二维状态转移方程很好写。对每个物品只有两个选择，装入或者不装。如果装入第 `i` 个物品，则价值为 `dp[i - 1][j - w[i]] + c[i]` ；不装入第 `i` 个物品，则价值为 `dp[i - 1][j]` 。得到方程：`dp[i][j] = max(dp[i - 1][j - w[i]] + c[i], dp[i - 1][j])` 。对应的代码：
```cpp
int dp[SIZE]MAXV];
for (int i = 1; i <= n; ++i) { //n个物品
	for (int j = 0; j <= w[i]; ++j) //写成j<=w[i]也可以
		dp[i][j] = dp[i - 1][j];    //1~i个物品中,占用当前背包的体积为j(j <= w[i])时无法装入第i个物品
	for (int j = w[i]; j <= v; ++j) 
		dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + c[i]);
}
```
仔细观察上述状态转移方程，我们发现 `dp[i][j]` 只和前一行的 `dp[i - 1][j], dp[i - 1][j - w[i]]` 有联系，即**每次决策只与两个阶段有关**。这样 `i - 1` 之前的空间等于是浪费了……为了节省这部分空间，我们可以使用**滚动数组**，或者说两个数组交替变换。

注意到 `i` 和 `i - 1` 奇偶性相反，`i` 是奇数则 `i - 1` 一定是偶数，反之亦然。于是可以这么优化：
```cpp
dp[i % 2][j] = max(dp[(i - 1) % 2][j], dp[(i - 1) % 2][j - w[i]] + c[i]);
```
对应的实际代码如下。需要注意的是，有些状态转移可能牵扯到三个阶段，此时如果用**滚动数组**就不能用 `&` ，而必须用 `%` ：
```cpp
int dp[2][MAXV]; //两倍空间
for (int i = 1; i <= n; ++i) { //n个物品
	for (int j = 0; j <= w[i]; ++j) //无法装入第i个物品时
		dp[i & 1][j] = dp[(i - 1) & 1][j]; //沿袭之前的值
	for (int j = w[i]; j <= v; ++j)
		dp[i & 1][j] = max(dp[(i - 1) & 1][j], dp[(i - 1) & 1][j - w[i]] + c[i]);
```
更进一步的空间优化，使我们只需使用一维数组，就能够完成01背包的状态转换。这种优化是如何进行的？

通过对原始的二维状态转移方程的观察，我们注意到，`dp[i][j]` 从上面 `dp[i - 1][j]` 或者左上位置处 `dp[i - 1][j - w[i]]` 推导过来的：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201120220906549.png#pic_center)
在使用一维数组的情况下，当前的 `dp[]` 数组已经存储了上次决策过程中获取的所有状态值。于是进行状态推导，只需用到 `dp[j]` 之前的一维数组值。为避免**覆盖之前的值**、以至于**多次装入一个物品**，需要从数组末尾逆序向前推导。具体代码如下：
```cpp
int dp[MAXV];
for (int i = 1; i <= n; ++i) //n个物品
	for (int j = v; j >= w[i]; --j) //逆序
		dp[j] = max(dp[j], dp[j - w[i]] + c[i]);
```
上述过程就是从二维数组到二倍一维数组，再到一维的完整推导过程。不过这里还有另一种方法，可以直接得到一维动态转移方程。

---
由于我们发现这里不关注到底选了什么物品，只关心**对应容积下的最大价值是什么**，所以设状态 `dp[j]` 为容积 `j` 下得到的最大价值，有 `dp[j] = max(dp[j - w[i]] + c[j])` 。对应如下代码：
```cpp
for (int j = 0; j <= v; ++j)
	for (int i = 1; i <= n; ++i)
		if (j >= w[i]) //能够容纳物品i
			dp[j] = max(dp[j], dp[j - w[i]] + c[i]);
```
然而这是错的，bug在哪里呢？……**我们很可能一个物品使用多次**，这和之前为什么使用逆序过程有关。改造一下换成逆序：
```cpp
for (int j = v; j >= 0; --j) 
	for (int i = 1; i <= n; ++i)
		if (j >= w[i])
			dp[j] = max(dp[j], dp[j - w[i]] + c[i]);
```
很遗憾，还是错的……因为决策时 `j` 从后往前遍历，`dp[j - w[i]] + c[i]` 中的 `dp[j - w[i]]` 还没有值……所以需要先循环枚举物品，在内部循环枚举体积……和之前的代码一模一样，此时 `dp[j]` 是第 `i` 个物品下容量为 `j` 的背包的最大价值。

> **先物品后体积**的做法，涉及到动态规划的一个特性：**先阶段，后状态，再决策**。很明显，**（选择）物品是阶段、体积是状态**，于是用物品更新体积，得到**第 `i` 个物品时各个容量下背包的最大价值**，而不是用体积更新物品。*这和区间DP有些相似之处，区间DP就是**先区间长度后区间端点**，不同区间长度是阶段，区间端点是状态，因为长度大的区间要用长度小的来更新*。

**01背包的拓展**：如果 `c∈[1,1e2], w∈[1,1e9]` ，这怎么做呢？我们创建 `dp[]` 是按照容积开的，这里总不能开一个 `1e9` 的数组吧？

由于价值区间很小，我们可以修改一下 `dp[]` 的含义。原来的 `dp[j]` 表示**当前容积 `j` 下的最大价值**，现在修改为**当前价值 `j` 下的最小容积**。代码修改为：
```cpp
int dp[MAXM]; 
memset(dp, 0x7f, sizeof(dp)); //语义是最小,需要赋值为无穷大,以便后续更新
dp[0] = 0; //价值为0时,什么都没装
for (int i = 1; i <= n; ++i) //枚举所有物品
	for (int j = m; j >= c[i]; --j) //m等于所有物品的价值之和
		dp[j] = min(dp[j], dp[j - c[i]] + w[i]);
int ans = 0; 
for (int i = 1; i <= m; ++i) //枚举所有的价值
	if (dp[i] <= v)			 //得到可行的最大价值
		ans = i;
```
对应的题目：LUOGU P1048采药

---
## 3. 完全背包
**每个物品的数量有无限个**。我们同样从二维动态规划方程开始，**`dp[i][j]` 为 `1 ~ i` 个物品中，占用当前背包的体积为 `j` 情况下的最大价值**。每个物品还是有两种选择：装入或者不装入。如果不装入，就是 `dp[i - 1][j]` ；如果装入，为 `dp[i][j - w[i]] + c[i]` （不是 `i - 1` ，因为这种物品有无限个）。

接着使用滚动数组优化空间，或者直接优化到一维：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201121004426942.png#pic_center)
注意下面的代码是**顺序遍历**。之前逆序遍历是因为01背包中每种物品只有一个，如果选择物品 `i` 时顺序遍历，就会覆盖之前的值，这个值再被之后的值使用到，就相当于（决定）装入多个当前的物品 `i` 。不过**完全背包就是可以装入多个同种物品**，因此恰好契合：
```cpp
int dp[MAXV];
for (int i = 1; i <= n; ++i)
	for (int j = w[i]; j <= v; ++j) //顺序
		dp[j] = max(dp[j], dp[j - w[i]] + c[i]);
```
---
## 4. 恰好问题
01、完全、依赖、多重、分组……这些背包问题，都会存在的一个特殊点，就是恰好问题——问**恰好装满某个体积能够得到的最大价值**。

下面有一道题（货币系统）：给出 `n` 种面值的货币，问哪些货币是多余的（多余指的是可以被其他货币的组合表示出来，例如 `3元 = 1元 + 2元` ）。问有多少种不多余的货币。

按照背包模型，很明显这道题就是一个完全背包。那么每种物品的**代价**（原来的体积）就是货币的面值，问题是**价值**呢？这里设每种货币能被用几种组合表示出来，被表示的组合数就是价值——3元可以被1元和2元表示出来 `3 = 1 + 2`（3张1元，或者1张1元和1张2元），于是3元可以被表示的组合数等于1的表示组合数加2的表示组合数（**加法原理**）。组合数只有3种情况：组合数为 `0` ，不能被表示；组合数为 `1` ，不多余的货币；组合数 `> 1` ，多余的货币。


抽象一下，就是**面值A+面值B=面值C（面值A=面值C-面值B）**或者说**代价A+面值B=代价C**。很自然地，得到下面的代码：
```cpp
dp[0] = 1; //极其关键的一步,所有恰好问题都需要想一下
//需要把面值wc[]按照升序先排序
for (int i = 1; i <= n; ++i) //阶段
	for (int j = wc[i]; j <= wc[n]; ++j) //状态(不同的面值或者说代价)
		dp[j] += dp[j - wc[i]]; //代价j可以被代价j-wc[i]和面值wc[i]表示,所以加上这个代价能够被表示的组合数
//扫描所有的面值,把所有表示次数!=1的全部删除
```
luogu P1049装箱问题：有一个![在这里插入图片描述](https://img-blog.csdnimg.cn/20201121012134983.png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201121012210575.png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201121012247488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/202011210123120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)
P1049 装箱问题

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201121012345301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)


1. 01背包 : [背包问题 第一讲](https://mp.weixin.qq.com/s/xmgK7SrTnFIM3Owpk-emmg)
    1. 【练习】01背包 : [背包问题 第二讲（416. 分割等和子集）](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/gong-shui-san-xie-bei-bao-wen-ti-shang-r-ln14/)
    2. 【学习&练习】01背包 : [背包问题 第三讲（416. 分割等和子集）](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/gong-shui-san-xie-bei-bao-wen-ti-xia-con-mr8a/)
2. 完全背包 : [背包问题 第四讲](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247486107&idx=1&sn=e5fa523008fc5588737b7ed801caf4c3&chksm=fd9ca184caeb28926959c0987208a3932ed9c965267ed366b5b82a6fc16d42f1ff40c29db5f1&token=990510480&lang=zh_CN#rd)
    1. 【练习】完全背包 : [背包问题 第五讲（279. 完全平方数）](https://leetcode-cn.com/problems/perfect-squares/solution/gong-shui-san-xie-xiang-jie-wan-quan-bei-nqes/)
    2. 【练习】完全背包 : [背包问题 第六讲（322. 零钱兑换）](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-bei-bao-wen-ti-zhan-zai-3265/)
    3. 【练习】完全背包 : [背包问题 第七讲（518. 零钱兑换 II）](https://leetcode-cn.com/problems/coin-change-2/solution/gong-shui-san-xie-xiang-jie-wan-quan-bei-6hxv/)
3. 多重背包 : [背包问题 第八讲](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247486649&idx=1&sn=ba09ee2d78377c2ddbb9e43622880133&chksm=fd9ca7a6caeb2eb0db61b7604a4aaa8d3ca90d6bc05eb6f50aaab415c4bd7f0047c1ca591018&token=1008907671&lang=zh_CN&scene=21#wechat_redirect)
4. 多重背包（优化篇）
    1. 多重背包（优化篇）: [背包问题 第九讲](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247486796&idx=1&sn=a382b38f8aed295410550bb1767437bd&chksm=fd9ca653caeb2f456262bbf70ffe1eeda8758b426a901a6ac15be184e7017870020e456c6fa2&token=1821593597&lang=zh_CN#rd)
    2. 多重背包（优化篇）: [背包问题 第十讲](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247486963&idx=1&sn=51d34f0f841122ed9be2335a402041e8&chksm=fd9ca6eccaeb2ffa1abe413177be376799b427b092bfb73c13e7b77e171b460f4c24b3b7d3bc&token=1821593597&lang=zh_CN#rd)
5. 混合背包
    1. 【练习】混合背包
6. 分组背包
    1. 【练习】分组背包
7. 多维背包
    1. 【练习】多维背包 : [背包问题 第 * 讲（474. 一和零）](https://leetcode-cn.com/problems/ones-and-zeroes/solution/gong-shui-san-xie-xiang-jie-ru-he-zhuan-174wv/)
    2. 【练】多维背包 : [背包问题 第 * 讲（879. 盈利计划）](https://leetcode-cn.com/problems/profitable-schemes/solution/gong-shui-san-xie-te-shu-duo-wei-fei-yon-7su9/)
8. 树形背包
    1. 【练习】树形背包
9. 背包求方案数
    1. 【练习】背包求方案数 : [背包问题 第 * 讲（494. 目标和）](https://leetcode-cn.com/problems/target-sum/solution/gong-shui-san-xie-yi-ti-si-jie-dfs-ji-yi-et5b/)
    2. 【练习】背包求方案数 : [背包问题 第 * 讲（879. 盈利计划）](https://leetcode-cn.com/problems/profitable-schemes/solution/gong-shui-san-xie-te-shu-duo-wei-fei-yon-7su9/)
10. 背包求具体方案
    1. 【练习】背包求具体方案 : [背包问题 第 * 讲（1049. 最后一块石头的重量 II）](https://leetcode-cn.com/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/)
11. 泛化背包
    1. 【练习】泛化背包

常见的背包问题有：
1. $True/False$ 问题，即背包能否装满。
    1. 139. 单词拆分 
    2. 416. 分割等和子集
    3. 1049. 最后一块石头的重量 II
2. 组合问题，即装满背包有几种方法。又分为无序组合和有序组合。
    1. 377. 组合总和 Ⅳ
    2. 494. 目标和
    3. 518. 零钱兑换 II
    4. 983. 最低票价
    5. 70. 爬楼梯
3. 最大最小问题。装满背包的最大价值、最小物品数。
    1. 474. 一和零 
    2. 322. 零钱兑换

求组合数问题公式：$$dp[i] += dp[i-num]$$ $True/False$ 问题公式：$$dp[i] = dp[i] or dp[i-num]$$
最大最小问题公式：$$\begin{aligned}dp[i] = \min(dp[i],\ dp[i-num]+1)\\ 或者 dp[i] = \max(dp[i],\ dp[i-num]+1)\end{aligned}$$
以上三组公式是解决对应问题的**核心公式**。

拿到问题后，做以下几个步骤：
1. **分析是否为背包问题**。 背包问题的判定——背包问题具备的特征：给定一个 $target$ ，$target$ 可以是数字也可以是字符串，再给定一个数组 $nums$ ，$nums$ 中装的可能是数字，也可能是字符串，问：能否使用 $nums$ 中的元素**做各种排列组合**得到 $target$ 。
2. 是以上三种背包问题中的**哪一种**。如果是求组合数问题，**是否需要考虑元素之间的顺序**。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法。
3. **再分为**是0-1背包问题还是完全背包问题。也就是题目给的 $nums$ 数组中的元素**是否可以重复使用**。 

接下来讲一下背包问题技巧：
1. 如果是0-1背包，即数组中的元素不可重复使用，**$nums$ 放在外循环，$target$ 在内循环，且内循环倒序**；
```python
for num in nums:
    for i in range(target, nums - 1, -1):
```
2. 如果是完全背包，即数组中的元素可重复使用，**$nums$ 放在外循环，$target$ 在内循环。且内循环正序**。
```python
for num in nums:
    for i in range(nums, target + 1):
```
3. 如果求组合数问题需考虑元素之间的顺序，**需将 $target$ 放在外循环，将 $nums$ 放在内循环**。
```python
for i in range(1, target + 1):
    for num in nums:
```
背包在里面，如果物品拿了，则一定是加在前面可能的最后面； 背包在外面，**如果物品拿了，则考虑了所有可能的排列**。