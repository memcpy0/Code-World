@[toc]


学完基数排序后，看到了这样的一个问题：给出一个长度为 $n \le 10^5$ 的字符串，将它的所有后缀子串按照字典序排序，要求给出高效的算法。

先考虑其他常见的排序方法，如基于比较的快速排序、归并排序，所有元素间的比较次数是 $O(n\log_2n)$ ，如果是对数值进行排序，这几乎是最优的复杂度了。但由于字符串的比较还需要 $O(n)$ 时间，所以总复杂度是 $O(n^2\log_2n)$ 。这显然不是好的方法。

---
# 1. 倍增法
emmmm……这又怎么和基数排序扯上关系的？还真有！我们假设已经按照每个后缀子串的前 $k$ 位排好序了，这时可以对第 $k + 1$ 位进行基数排序……

**倍增法**的复杂度是 $O(n\log_2n)$ ，它对后缀排序的原理比较复杂，一般很难理解，需要按照步骤学习。

## (1) 求出后缀数组
求字符串 `"vamamadn"` 的后缀数组。
1. 用数字代表字母，如 `a` 最小记为 $0$ ，`v` 最大记为 $4$ ，`d, m, n` 分别记为 `1, 2, 3` 。这个转换对后缀子串间的排序没有任何影响。目的是：**对所有后缀子串的最高位进行大小判定**，不过因为很多子串的最高位相同，对应的数字也相同，所以还不能实际分出大小；
2. 连续两个数字的组合，相当于连续两个字母。如 $40$ 表示 `"va"` ，$02$ 表示 `"am"` 等，最后的一个 `n` 没有后续字母，在尾部加上 $0$ 组成 $30$ 。同样，这不影响字符的比较，因为字符是从头到尾比较大小的。这一步的目的在于：**取后缀子串的最高两位，数字的大小代表子串最高两位的大小。**
3. 连续四个数字的组合，相当于连续四个字符。如 $4020$ 代表 `"vama"` 、$0202$ 代表 `"amam"` 等。最后的 $30$ 没有后续则加上 $00$ 组成 $3000$ 。这一步目的：**用数字代表后缀子串的高 $4$ 位。**
4. 这时产生的 $8$ 个数字已经完全不一样，能够区分大小了。结束，并进行排序，得到 `rk[] = {7, 2, 5, 1, 4, 0, 3, 6}` 名次数组，它是字符串 `"vamamadn"` 的 $8$ 个后缀子串的排序，得到它后可以求后缀数组 `sa[] = {5, 3, 1, 6, 4, 2, 7, 0}` ：
<img src="https://img-blog.csdnimg.cn/2020090214335367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">


在这样的操作过程中，每一步递增两倍，总共只有 $\log(n)$ 步，非常少。当然，这一过程并不实用，如果字符串很长，例如包含 `10000` 个字符，那么最后产生的每个数字都是天文数字，根本无法存储和排序。

为此，我们需要**在每一步中缩小产生的组合数字的大小，同时保持顺序**。方法：每一步操作后，就对组合数字进行排序，用序号产生一个新数字，然后用新数字进行下一步操作。如图：
<img src="https://img-blog.csdnimg.cn/20200902143452782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

每一步排序后产生的新数字，实际上仍然是对后缀子串的高位的排序，最后的结果和原先是一样的。而且产生的新数字很小——假设字符串长度 `n = 10000` ，每一步处理一万个数，产生的新数字就是对它们的排序结果，范围为 `1~10000` 。于是每一步都对一万个大小在 `1~10000` 的数字进行排序，很简单。



----
1. 后缀数组的代码中有 $3$ 个关键的数组：`sa[], rk[], height[]` 。下面先介绍前两个：
- `sa[]` ：后缀数组 `suffix array` 。保存 `0~n-1` 的全排列，含义是：把所有后缀子串按照字典序升序排序后，后缀子串在原串中的位置序列。`sa[]` 记录位置，`sa[i]` 表示排第 `i` 的后缀子串在原串中的 `sa[i]` 这个位置。性质：`suffix(sa[i]) < suffix(sa[i + 1])` 。
- `rk[]` ：名次数组 `rank array` 。最后得到的 `rk[]` 也保存 `0~n-1` 的全排列，保存 `suffix(i)` 在所有后缀中按照字典序排序的名次。`rk[]` 记录排名，原串从头数第 `i` 个后缀子串，排名是 `rk[i]` 。
- 于是 `rk[], sa[]` 互为逆运算，可以互相推导：

```cpp
//用rk[]推导sa[]
for (int i = 0; i < n; ++i) sa[rk[i]] = i;
//用sa[]推导rk[]
for (int i = 0; i < n; ++i) rk[sa[i]] = i;
```
# 3. 用 `sort()` 求后缀数组 `sa[]`
程序的逻辑如下：
1. 用 `sort()` 在每一步根据当前的 `rk[]` 计算出当前的 `sa[]` ；
2. 用 `sa[]` 更新下一步用到的 `rk[]` 。注意每一步的 `sa[]` ，其中任意两个 `sa[i]` 和 `sa[j]` 都不同，但是下一步的 `rk[]` 中有一些是相同的，所以 `sa[]` 和 `rk[]` 还不是一一对应的。此时需要先用 `sa[]` 根据原来的 `rk[]` 中的记录推导新的 `rk[]` ，需要用一个临时 `tmp[]` 存放新值，然后再赋值给 `rk[]` 。
3. 只有到了最后，`sa[], rk[]` 才是一一对应的。


//后缀排序,
//假设已经按照每个后缀的前k位排好序了
//考虑将k扩展到2k,把每个后缀的前2k位用数对(a,b)代表, a是前k位的排名,
//b是第k+1到2k位的排名
//对(a,b)进行基数排序


