@[toc]

本章介绍**分枝限界法** `branch and bound method` 求解问题的一般方法，并讨论一些采用分枝限界法求解的经典示例。


---
# 6.1 分枝限界法概述
## 6.1.1 什么是分枝限界法
**分枝限界法**类似于**回溯法**，也是一种在问题的解空间上搜索问题解的算法，但在一般情况下，分枝限界法和回溯法的**求解目标不同**——回溯法的求解目标是，==找出解空间树中满足约束条件的所有解==；分枝限界法的求解目标则是，==找出满足约束条件的一个解，或是在满足约束条件的解中，找出使得「某一目标函数」的值达到极大或极小的解，即在某种意义上的最优解==。

所谓**分枝**，就是==采用广度优先的策略，依次搜索活结点的所有分枝（即所有相邻结点）==，如下图所示。所谓**限界**，就是==为了有效地选择下一扩展结点，加速搜索的进程，在每一活结点处计算一个函数值（**限界函数**），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分枝推进，以便尽快找到一个最优解==。
<img src="https://img-blog.csdnimg.cn/d3a1f1f4da0440ac8e221290521d8328.png#pic_center" width="31%">


分枝限界法和回溯法的主要区别如下表所示：
| 方法 | 解空间搜索方式 | 存储结点的数据结构 | 结点存储特性 | 常用应用 |
|:--|:--|:--|:--|:--
| 回溯法  | 深度优先  | 栈 | 活结点的所有可行子结点被遍历后，才从栈中出栈 | 找出满足条件的所有解
| 分枝限界法 | 广度优先 | 队列、优先队列 | 每个结点只有一次成为活结点的机会 |  找出满足条件的一个解，或者特定意义的最优解


## 6.1.2 分枝限界法的设计思想
这里介绍**应用分枝限界法时，需解决的几个关键问题**。

### 1. 设计合适的限界函数
在搜索解空间树时，每个活结点可能有很多子结点，其中有些子结点搜索下去是不可能产生问题解或最优解的，==可以设计好的限界函数，在扩展时删除这些不必要的子结点，从而提高搜索效率==。如图所示，假设活结点 $s_i$ 有四个子结点，而满足限界函数的子结点只有两个，可以删除这两个不满足限界函数的子结点，使得从 $s_i$ 出发的搜索效率提高一倍。
<img src="https://img-blog.csdnimg.cn/f1849a8684454152b81442611c3a1516.png#pic_center" width="50%">
好的限界函数不仅**计算简单**，还要保证**最优解在搜索空间中**，最重要的是**能在搜索的早期，对超出目标函数的结点进行丢弃**。

限界函数设计难以找出通用的方法，需根据具体问题来分析。一般地，先要确定问题解的特性：
- **如果目标函数是求最大值**，则设计上界限界函数 $ub$（根结点的 $ub$ 值通常大于或等于最优解的 $ub$ 值），若 $s_i$ 是 $s_j$ 的双亲结点，应满足 $ub(s_i) ≥ ub(s_j)$ ，当找到一个可行解 $ub(s_k)$ 后，将所有小于 $ub(s_k)$ 的结点剪枝。
- **如果目标函数是求最小值**，则设计下界限界函数 $lb$（根结点的 $lb$ 值一定要小于或等于最优解的 $lb$ 值），若 $s_i$ 是 $s_j$ 的双亲结点，应满足 $lb(s_i) ≤ lb(s_j)$ ，当找到一个可行解 $lb(s_k)$ 后，将所有大于  $lb(s_k)$ 的结点剪枝。
<img src="https://img-blog.csdnimg.cn/2f9995701edf453884b638f9e14b751d.png#pic_center" width="3%">

### 2. 组织活结点表
根据**选择下一个扩展结点的方法**来组织活结点表，==不同的活结点表对应不同的分枝搜索方式==，常见的有**队列式分枝限界法**和**优先队列式分枝限界法**两种。

#### 1) 队列式分枝限界法
队列式分枝限界法**将活结点表组织成一个队列** `queue` ，并按照队列先进先出 `First in First Out, FIFO` 的原则，**选取下一个结点为扩展结点**。步骤如下：
（1）将根结点加入活结点队列。
（2）从活结点队中取出队头结点，作为当前扩展结点。
（3）对当前扩展结点，先从左到右地产生它的所有孩子结点，**用约束条件检查**，把所有满足约束条件的孩子结点加入活结点队列。
（4）重复步骤2和3，直到找到一个解或活结点队列为空为止。

#### 2) 优先队列式分枝限界法
优先队列式分枝限界法的主要特点是，**将活结点表组织成一个优先队列**，并**选取优先级最高的活结点成为当前扩展结点**。步骤如下：
（1）计算起始结点（根结点）的优先级，并加入优先队列（「与特定问题相关的信息」的函数值决定优先级）。
（2）从优先队列中取出优先级最高的结点，作为当前扩展结点，使搜索朝着解空间树上、可能有最优解的分枝推进，以便尽快地找出一个最优解。
（3）对当前扩展结点，先从左到右地产生它的所有孩子结点，然后**用约束条件检查**，对所有满足约束条件的孩子结点，**计算优先级并加入优先队列**。
（4）重复步骤2和3，直到找到一个解或优先队列为空为止。

==在一般情况下，结点的优先级用与该结点相关的一个数值 $p$ 来表示，如价值、费用、重量等==。最大优先队列规定 $p$ 值越大优先级越高，常用大根堆来实现；最小优先队列规定 $p$ 值越小优先级越高，常用小根堆来实现。

### 3. 确定最优解的解向量
分枝限界法在采用「广度优先遍历方式」搜索解空间树时，结点的处理是跳跃式的，回溯也不是单纯地沿着双亲结点、一层一层地向上回溯。因此，==当搜索到某个叶子结点、且该结点对应一个可行解时，如何得到对应的解向量呢？==

得到对应的解向量的方法主要有两种：
1. **对每个扩展结点，保存从根结点到该结点的路径**，即**每个结点都带有一个可能的解向量**，当找到一个可行解时，该结点中可能的解向量就是真正的解向量。==这种做法比较浪费空间，但实现起来简单==，后面的示例均采用这种方式。
如下图所示，结点编号为搜索顺序，每个结点带有一个可能的解向量，带阴影的结点为最优解结点，对应的最优解向量为 $[0, 1, 1]$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/3eec25c1b9f54a238b9ac7ce73cf66f3.png)

2. **在搜索过程中，构建搜索经过的树结构**，此时令每个结点带有一个双亲结点指针，在求得最优解时，从叶子结点通过双亲指针不断回溯到根结点，以确定最优解的各个分量。==这种做法需保存搜索经过的树结构，每个结点增加一个指向双亲结点的指针==。
如下图所示，结点编号为搜索顺序，每个结点带有一个双亲结点指针（根结点的双亲结点指针为 $0$ 或 $-1$ ，图中虚箭头连线表示指向双亲结点的指针），带阴影的结点为最优解结点，当找到最优解时通过双亲指针找到对应的最优解向量，为 $[0, 1, 1]$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/7542ab6466f449058cde7ba52cb1a655.png)

所以，采用分枝限界法求解的 $3$ 个关键问题如下：
**（1）如何确定合适的限界函数。
（2）如何组织待处理结点的活结点表。
（3）如何确定解向量的各个分量。**

## 6.1.3 分枝限界法的时间性能
一般情况下，在问题的解向量 $X=( x_1, x_2, \dots, x_n)$ 中，分量 $x_i\ (1≤ i ≤n)$ 的取值范围为某个有限集合 $S_i = (s_{i1}, s_{i2}, \dots, s_{ir})$ ，根结点从 $1$ 开始。因此，==问题的解空间由笛卡尔积 $S_1 × S_2× \dots ×S_n$ 构成==：
- 第一层的根结点有 $|S_1|$ 棵子树；
- 第二层有 $|S_1|$ 个结点，每个结点有 $|S_2|$ 棵子树；
- 第三层有 $|S_1 | \times |S_2|$ 个结点；
- ……
- 依次类推，第 $n + 1$ 层有 $|S_1| \times |S_2| \times \dots \times |S_n|$ 个结点，它们都是叶子结点，代表问题的所有可能解

==分枝限界法和回溯法实际上都属于穷举法，当然不能指望有很好的最坏时间复杂度。在最坏情况下，时间复杂度是指数阶==。**分枝限界法的较高效率是以付出一定代价为基础的**，其工作方式也造成了算法设计的复杂性。另外，算法要维护一个活结点表（队列），并且需要在该表中快速查找取得极值的结点，这都需要较大的存储空间，==在最坏情况下，分枝限界法需要的空间复杂度是指数阶==。

归纳起来，与回溯法相比，分枝限界法的优点是**可以更快地找到一个解或者最优解**，缺点是**要存储结点的限界值等信息，占用的内存空间较多**。另外，求解效率基本上由限界函数决定，若限界估计不好，在极端情况下将与穷举搜索没多大区别。


---
# 6.2 0/1背包问题
【问题描述】有 $n$ 个重量分别为 $\{w_1, w_2, \dots, w_n\}$ 的物品，它们的价值分别为 $\{v_1, v_2, \dots, v_n\}$ ，给定一个容量为 $W$ 的背包。设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且重量和不超过 $W$ ，且具有最大的价值和。

假设一个0/1背包问题是 $n=3$ ，重量为 $w= (16, 15, 15)$ ，价值为 $v=(45, 25, 25)$ ，背包限重为 $W=30$ ，求放入背包总重量小于等于 $W$ 并且价值最大的解。
![在这里插入图片描述](https://img-blog.csdnimg.cn/59bad9d518444778972c78a16d99d273.png)
设其解向量为 $x= (x_1, x_2, x_3)$ ，其解空间树如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/d928193c9e524c3f868de94b8a210d2f.png)
本节通过队列式和优先队列式两种分枝限界法，求解该问题。

## 6.2.1 采用队列式分枝限界法求解
首先不考虑限界问题，但==对左孩子采用“已选物品重量和+当前物品重量” $\le W$ 进行约束==。用 $q$ 表示队列，初始时 $q = []$ ，其求解过程如下：
1. 根结点 $A(0, 0)$ 入队，即 $q= [A]$ ，括号内的两个数分别表示此状态下装入背包的重量和价值，初始时均为 $0$ 。
2. 出队 $A$ ，其孩子 $B(16, 45),\ C(0, 0)$ 入队，$q = [B, C]$ 。
3. 出队 $B$ ，其孩子 $D(31, 70)$ 变为死结点（超重），只有子结点 $E(16, 45)$ 入队，$q = [C, E]$ 。
4. 出队 $C$ ，其孩子 $F(15, 25)$ 和 $G(0, 0)$ 入队，$q = [E, F, G]$ 。
5. 出队 $E$ ，其孩子$J(31, 70)$ 变为死结点（超重），==孩子 $K(16, 45)$ 是叶子结点，总重量 $< W$ ，为一个可行解，总价值为 $45$ ，对应的解向量为 $(1, 0, 0)$== ，$q = [F, G]$ 。
6. 出队 $F$ ，其==孩子 $L(30, 50)$ 为叶子结点，构成一个可行解，总价值为 $50$ ，解向量为 $(0, 1, 1)$== ；其==孩子 $M(15, 25)$ 为叶子结点，构成一个可行解，总价值为 $25$ ，解向量为 $(0, 1, 0)$== 。$q = [G]$ 。
7. 出队 $G$ ，其==孩子 $N(15, 25)$ 为叶子结点，构成一个可行解，总价值为 $25$ ，解向量为 $(0, 0, 1)$== ；其==孩子 $O(0, 0)$ 为叶子结点，构成一个可行解，解向量为 $(0, 0, 0)$== 。$q = []$ 。
8. 因为队列为空，算法结束。对应的搜索空间如下图所示，图中带有 $\times$ 的结点表示死结点，通过所有可行解的总价值比较，得到最优解为 $(0, 1, 1)$ ，总价值为 $50$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/624656c4d02a4730999611251f0f74ef.png)

下面讲解算法的具体实现。这里采用STL的 `queue` 作为队列，队列中的结点类型声明如下：
```cpp
struct NodeType { // 队列中的结点类型
	int no;		  // 结点编号，从1开始
	int i;	  	  // 当前结点在搜索空间中的层次
	int w;		  // 当前结点的总重量
	int v;		  // 当前结点的总价值
	int x[MAXN];  // 当前结点包含的解向量
	double ub;    // 上界
};
```
现在设计限界函数，为了简便，设根结点为第 $0$ 层，然后各层依次递增，显然 $i = n$ 时表示叶子结点层。==由于该问题是求装入背包的最大价值，属于求最大值问题，采用上界限界设计方式==。

对于第 $i$ 层的某个结点 $e$ ，用 $e.w$ 表示结点 $e$ 已装入的总重量，用 $e.v$ 表示已装入的总价值，如果所有剩余的物品都能装入背包，那么价值的上界 $e.ub$ 显然是
$$e.v + \sum^n_{j = i + 1} v[j]$$ 如果所有剩余的物品不能全部装入背包，假设物品 $i + 1 \sim$ 物品 $k$ 能够全部装入，而物品 $k + 1$ 只能装入一部分，那么价值的上界 $e.ub$ 应该是 $$e.v + \sum^k_{j = i + 1} v[j] + (物品k+1装入的部分重量) \times (物品k+1的单位价值)$$ 这样，==每个结点实际装入背包的价值一定小于等于该上界==（需要先对数据预处理）。

例如，在上面的搜索空间图中，根结点 $A$ 的层次 $i = 0, w = 0, v = 0$ ，其 $ub = 0 + 45 + (30 - 16) \times 25 / 15 = 68$ ，为了简单，均采用取整运算；结点 $F$ 中 $w = 15, v = 25, i = 2$ ，其 $ub = 25 + (30 - 15) \times 25 / 15 = 50$ 。
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/0ccd425f3eb54381920e49a75a7a9c4c.png)


对应的==求结点 $e$ 的上界 $e.ub$ 的算法==如下：
```cpp
void bound(NodeType& e) {   					// 计算分枝结点e的(价值)上界
	int i = e.i + 1;							// 考虑结点e的余下物品
	int sumw = e.w;								// 已装入的总重量
	double sumv = e.v;							// 已装入的总价值
	while ((sumw + w[i] <= W) && i <= n) {
		sumw += w[i];							// 计算背包已装入载重
		sumv += v[i]; 							// 计算背包已装入重量
		++i;
	}
	if (i <= n)									// 余下物品只能部分装入
		e.ub = sumv + (W - sumw) * v[i] / w[i];
	else										// 余下物品全部可以装入
		e.ub = sumv;
}
```
限界函数给出「每个可行结点相应的子树」可能获取的最大价值的上界。如果这个上界不比当前最优值更大，则说明相应的子树中不含问题的最优解，因此该结点可以剪去（**剪枝**）。

求解最优解的过程是：
- 先将求出上界的根结点入队，在队非空时循环；
- 出队一个结点 $e$ ，==检查其左子结点，若满足约束条件 $(e.w + w[e.i+ 1] \le W)$ ，则求出其上界、将其进队，否则该左子结点变为死结点==（左子结点选择了物品，此时不用上界来剪枝）；
- ==再检查其右子结点并求出其上界，若它是可行的（即其上界大于当前已找到可行解的最大总价值 $maxv$ ），则将该右子结点入队；否则该右子结点被剪枝，因为沿着该结点搜索下去，不可能找到一个更优的解==（右子结点没有选择物品，此时使用上界来剪枝）。
- 循环这一过程，直到队列为空。算法最后输出是最优解向量、最大总价值。

在结点 $e$ 进队时，先判断是否为叶子结点（当 $e.i = n$ 时为叶子结点），若是叶子结点，表示找到一个可行解，通过比较将最优解向量保存在 $bestx$ 中，将最大总价值保存在 $maxv$ 中，**可行解对应的结点不进队**。否则将非叶子结点进队。

对应的完整程序如下。其中采用的是**在结点进队时判断是否为叶子结点，每个叶子结点对应一个可行解**（叶结点不进队）。也可改为根结点不进队，直接扩展其子结点，然后将这些子结点进队，**出队结点 $e$ 时判断 $e$ 是否为叶子结点，从中找到最优解**。不过由于叶子结点众多，后者的效率会低许多，不建议使用。==在有些情况下，设计的限界函数满足「第一次找到的叶子结点就对应最优解」，此时一旦找到一个解就可以退出循环，不必等到队列为空==。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 20;							// 最多可能物品数

/* 问题表示 */
int n = 3, W = 30;
int w[] = {0, 16, 15, 15};						// 重量，下标为0的元素不用
int v[] = {0, 45, 25, 25};						// 价值，下标为0的元素不用

/* 求解结果表示 */
int maxv = INT_MIN;								// 存放最大价值，初始为最小值
int bestx[MAXN];								// 存放最优解，全局变量
int total = 1;									// 解空间中的结点数累计，全局变量

struct NodeType { 								// 队列中的结点类型
	int no;		  								// 结点编号，从1开始
	int i;	  									// 当前结点在搜索空间中的层次
	int w;		  								// 当前结点的总重量
	int v;		  								// 当前结点的总价值
	int x[MAXN];  								// 当前结点包含的解向量
	double ub;    								// 上界
};

void bound(NodeType& e) {   					// 计算分枝结点e的(价值)上界
	int i = e.i + 1;							// 考虑结点e的余下物品
	int sumw = e.w;								// 已装入的总重量
	double sumv = e.v;							// 已装入的总价值
	while ((sumw + w[i] <= W) && i <= n) {
		sumw += w[i];							// 计算背包已装入载重
		sumv += v[i]; 							// 计算背包已装入价值
		++i;
	}
	if (i <= n)									// 余下物品只能部分装入
		e.ub = sumv + (W - sumw) * v[i] / w[i];
	else										// 余下物品全部可以装入
		e.ub = sumv;
}

void enQueue(NodeType e, queue<NodeType> &q) {  // 结点e进队q
	if (e.i == n) {								// 到达叶子结点
		if (e.v > maxv) {
			maxv = e.v;							// 更新最大价值
			for (int j = 1; j <= n; ++j)		// 更新最优解向量
				bestx[j] = e.x[j];
		}
	} else q.push(e);							// 非叶子结点则进队
}

void bfs() {									// 求解0/1背包的最优解
	queue<NodeType> q;							// 定义一个队列
	NodeType e, e1, e2;
	e.i = 0;									// 根结点置初值,其层次为0
	e.w = e.v = 0;
	e.no = total++;
	for (int j = 1; j <= n; ++j)				// 根结点的解向量
		e.x[j] = 0;
	bound(e);									// 求根结点的上界
	q.push(e);									// 根结点入队
	while (!q.empty()) {						// 队非空时循环
		e = q.front(); q.pop();					// 出队结点e
		if (e.w + w[e.i + 1] <= W) {			// 剪枝:检查左孩子结点
			e1.no = total++;
			e1.i = e.i + 1;
			e1.w = e.w + w[e1.i];
			e1.v = e.v + v[e1.i];
			for (int j = 1; j <= n; ++j)		// 复制解向量
				e1.x[j] = e.x[j];
			e1.x[e1.i] = 1;
			bound(e1);							// 求左孩子结点的上界
			enQueue(e1, q);						// 左孩子结点入队	
		}
		e2.no = total++;
		e2.i = e.i + 1;
		e2.w = e.w, e2.v = e.v;
		for (int j = 1; j <= n; ++j)			// 复制解向量
			e2.x[j] = e.x[j];
		e2.x[e2.i] = 0;
		bound(e2);								// 求右孩子结点的上界
		if (e2.ub > maxv)						// 若右孩子结点可行,则进队,否则被剪枝
			enQueue(e2, q);
	}
}

int main() {
	bfs();										// 调用队列式分枝限界法求0/1背包问题
	printf("分枝限界法求解0/1背包问题:\nX = [");
	for (int i = 1; i <= n; ++i)				// 输出最优解
		printf("%2d", bestx[i]);				// 输出所求X[n]数组		
	printf(" ]，装入总价值为%d\n", maxv);
	return 0;
}
```
本程序的执行结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/828490a549af471ca59fbf98447e1832.png)
注意，上述0/1背包问题的求解过程如下图所示，图中为 $\times$ 的结点表示死结点，带阴影的结点是最优解结点，结点的编号为搜索顺序。从中看到，==由于采用队列，结点的扩展是一层一层顺序展开的，类似于广度优先搜索==。其实际搜索的结点个数为 $13$ ，由于物品个数较少，没有明显体现出限界函数的作用，当物品个数较多时，使用限界函数的效率会得到较大的提高。
![在这里插入图片描述](https://img-blog.csdnimg.cn/fed68531c8244485a78c7c7bdfefa716.png)
由于是一层层扩展的，使用上界的剪枝函数没有发挥太大的作用——因为只有上界小于最大价值 $maxv$ 时才剪枝，然而最大价值只在叶子结点处被更新、得到有意义的 $maxv$ 值……此时已经扩展到最后一层了，剪枝就没什么用处。为此，需要使用优先队列，优化分枝限界法的效率。

https://blog.csdn.net/weixin_42260102/article/details/96008327
https://blog.csdn.net/weixin_42260102/article/details/96004555
## 6.2.2 采用优先队列式分枝限界法求解    
采用优先队列式分枝限界法求解，**就是将一般的队列改为优先队列**，但必须设计限界函数，因为**优先级是以限界函数值为基础**的。此处，限界函数的设计方法与前相同。==这里用大根堆表示活结点表，取优先级为活结点所获得的价值==。

采用STL的 `priority_queue<NodeType>` 容器作为优先队列（大根堆），优先队列结点类型与6.2.1小节的相同，仅仅需要添加**比较重载函数**，即指定按什么条件优先出队，这里是**按结点的 `ub` 成员值越大、越优先出队**。为此，设计 `NodeType` 结构体的比较重载函数如下：
```cpp
bool operator<(const NodeType &s) const {
	return ub < s.ub;
}
```
对应的完整程序如下：
```cpp

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/e94e13aa141446a39db917fcd3945975.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/41573cae015346d69bfe1a0ad280bd15.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/fcd0e9fcbd4448a68b7725ca1550545f.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/4fec8f415bdf485c9972cec6baf9a014.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/bff842b87c0040c9b9d2ac7a2e040407.png)

```cpp
在这里插入代码片
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/a5ea125afd354f20bc970b9fbc99042c.png)

---
# 6.3 图的单源最短路径
【问题描述】给定一个带权有向图 $G=<V, E>$ ，其中每条边的权是一个正整数，另外还给定 $V$ 中的一个顶点 $v$ ，称为源点。计算从源点到其他所有各顶点的最短路径长度，这里的长度是指路上各边权之和。

## 6.3.1 采用队列式分枝限界法求解
带权有向图 $G$ 采用邻接矩阵 $A$ 数组存储，
![在这里插入图片描述](https://img-blog.csdnimg.cn/54df265f35a94ea8b8ab6d58fe8f8531.png)

![图6.9](https://img-blog.csdnimg.cn/1e7c8c0d9fce4b558a1747a0726f0d2c.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/7fbb1fc4af0e43e5b57ee27ebb276894.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/f4d807f548d44fa5863eb2a4c05a15d8.png)


![在这里插入图片描述](https://img-blog.csdnimg.cn/53ae62471a874c6494a5231b38d58fdd.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/72dd5c8fe9114832a17c6ada3c5a7155.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/fb8e9f316c474b7ca1bdd77d3512e1c2.png)


![在这里插入图片描述](https://img-blog.csdnimg.cn/28cdf7a4afe94886b0e6b55c68ecdbfb.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/390972e51a834766a875dfdd9272bd43.png)

## 6.3.2 采用优先队列式分枝限界法求解
![在这里插入图片描述](https://img-blog.csdnimg.cn/f1621d462f564c9d96e28737dad310b6.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/19a525b65f734755a7dc004636864b4d.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/64fa7e75c798463eb19760d07aa93f0b.png)

法求解
![在这里插入图片描述](https://img-blog.csdnimg.cn/9599122d77fd44f0b17d5178e8eaae7b.png)

在后面介绍分枝限界法求解示例时，主要采用优先队列式分枝限界法求解。


---
# 6.4 任务分配问题
![在这里插入图片描述](https://img-blog.csdnimg.cn/a140ee515da24c3d810f2b308af28515.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/9136fbdc1cd9486caf11041ad3891b5c.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/fd2d8b00a0eb4514a078500dca0d38e5.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/109ac80ddbd54f12af921151b0f9dff8.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/52cbdcbaa5a44656ad19cbc6460f6da7.png)


![在这里插入图片描述](https://img-blog.csdnimg.cn/3c4f63a467f44740ac4f07bd454d525b.png)


---
# 6.5 流水线作业调度问题
可用回溯法解决本问题，这里采用优先队列式分枝限界法求解。

【问题求解】作业编号为 $1 \sim n$ ，调度方案的执行步骤为 $1 \sim n$ ，解空间的每一层对应一个步骤的作业分配，根结点对应步骤 $0$（虚结点），依次为步骤 $1, 2, \dots, n$ 分配任务，叶子结点对应步骤 $n$ 。

5.9节介绍过，对于按 $1\sim n$ 顺序执行的调度方案，$f_1$ 数组表示在 $M_1$ 上执行完当前作业 $i$ 的总时间，$f_2$ 数组表示在 $M_2$ 上执行完当前作业 $i$ 的总时间，计算公式如下：
$$f_1 = f_1 + a[i] \\ f_2[i] = \max(f_1, f_2[i - 1]) + b[i]$$
![在这里插入图片描述](https://img-blog.csdnimg.cn/08365773740140408695eccecba5b053.png)

这里由于每个结点都保存了 $f_1$ 和 $f_2$ ，因此可以将 $f_2$ 数组改为单个变量。每个队列结点的类型声明如下：
```cpp

```
其中，各成员的说明如下：
- 成员 `no` 表示结点编号（从 $1$ 开始），没有实际意义，仅用于标识结点，这里仅仅对进队的结点进行顺序编号。
- 成员数组 $x$ 是对应的解向量，例如 $x[] = [1,3,0,0]$ ，表示第 $1$ 步执行作业 $1$ ，第 $2$ 步执行作业 $3$ ，第 $3, 4$ 步还没有分配作业。成员数组 $y$ 表示哪些作业已经分配，例如 $y[] = [1, 0, 1, 0]$ ，表示作业 $1, 3$ 已经分配、而作业 $2, 4$ 没有分配。
- 成员 $i$ 表示当前结点属于解空间的第 $i$ 层，即准备为第 $i$ 步分配作业；成员 $f_1$ 表示该分配方案在 $M_1$ 上执行的时间，成员 $f_2$ 表示该分配方案在 $M_2$ 上执行的时间。
- 成员 $lb$ 为当前结点对应调度方案的时间下界。

例如图6.13，对于出队结点 $e$ ，若有 $e.i = 1,\ e.f_1 = 4,\ e.f_2 = 18,\ e.lb = 19,\ x= [3, 0, 0, 0],\ y = [0, 0, 1, 0]$ ，如果在第 $2$ 步选择作业 $1\ (j = 1)$ ，对应结点为 $e1$ ，则 $e1.i = e.i + 1 = 2,\ e1.f_1 = e.f_1 + a[1] = 9,\ e1.f_2 = \max(e1.f_1, e.f_2) + b[1] = 18 + 6 = 24,\ e1.x = [3, 1, 0, 0],\ e1.y = [1, 0, 1, 0]$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/7099db54f09c4cb58f0ac66a4c0424fa.png)
那么如何计算 $lb$ 呢？对于结点 $e1$ ，后面还有两步，只能选择作业 $2$ 和作业 $4$ ，其最少的执行时间应该为 $e1.f_1 +$ 作业 $2, 4$ 在 $M_2$ 上的时间和（这是考虑作业没有等待的情况），所以 $lb$ 定义为 $lb = e1.f_1 +$ 没有分配的作业在 $M_2$ 上执行的时间和，这里 $e1.lb= e1.f_1 +$ 作业 $2, 4$ 在 $M_2$ 上的时间和 $= 9 + 2 + 7 = 18$ 。

显然，任何一个最终调度方案的执行时间 $f_2$ 都大于等于 $lb$ ，所以优先选择 $lb$ 小的结点进行扩展是合理的。
> 由于作业是按步骤顺序分配的，所以结点中数组 $x$ 的非零值（作业编号）总是依作业的执行顺序排列在前面，以此产生最终的调度方案，因此 $f_1, f_2$ 的计算是正确的。增加数组 $y$ 的原因是，为了方便检测一个作业是否重复分配。
![在这里插入图片描述](https://img-blog.csdnimg.cn/e151634632dd4561b8971c9b369bcac2.png)

对应的求结点 $e$ 的 $lb$ 的算法如下：
```cpp

```
用 $bestf$（初始值为 $\infin$ ）存放最优调度时间，$bestx$ 数组存放当前作业最优调度，采用的剪枝原则是**仅仅扩展 $e.f_2 < bestf$ 的结点**。对应的完整程序如下：
```cpp
在这里插入代码片
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/09eda523290447a1971dc6c7400cfac9.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/f1c05a24b2a34c129062153e34a438e4.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/a19009a72cab4a85b8187ca11d6c24b1.png)

上述程序的执行结果如下：
最优方案：
[3,1,4,2] 33

对于该示例，$n = 4$ ，在完整的解空间中，第 $0$ 层有 $1$ 个结点、第 $1$ 层有 $4$ 个结点，第 $2$ 层有 $4 \times 3$ 个结点，第 $3$ 层有 $4 \times 3 \times 2$ 个结点，第 $4$ 层有 $4\times 3 \times 2 \times 1$ 个结点。但采用优先队列分枝限界法求解时，扩展的结点个数为 $39$ 个，大大提高了解空间的搜索效率。

前面的算法是**对每个出队的结点判断是否为叶子结点**，如果算法改为**在扩展每个子结点后（可以扩展！）判断是否为叶子结点**，若是则生成一个解、并仅仅生成第一个解，否则该子结点进队。这一做法最后得到的解也是最优解，并且仅仅扩展 $11$ 个结点，对应的算法如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/5a43875316df4753ae4ca0a7818a92e7.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/78db41b6879d499c8ec76d9f4178b24c.png)


```cpp


```



![在这里插入图片描述](https://img-blog.csdnimg.cn/6d2369bc17d247328a3e4fb446489b1c.png)

---
# 其他题目
![在这里插入图片描述](https://img-blog.csdnimg.cn/955d3fd4bd2c4871b71887784adb17d9.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/65d3d95243434bb9b0a5a06c8b3a633c.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/35b0bfb76fc247e7a6468e4b8b8b00b8.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/cf970b60f2ca40a88e3c058ae835501a.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/4b409b1767b64937bdbcf4e530f7037d.png)

