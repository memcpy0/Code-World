> 本文属于「算法学习」系列文章之一。之前的【数据结构和算法设计】系列着重于基础的数据结构和算法设计课程的学习，与之不同的是，这一系列主要用来记录对大学课程范围之外的高级算法学习、优化与使用的过程，同时也将归纳总结出简洁明了的算法模板，以便记忆和运用。在本系列学习文章中，为了透彻讲解算法和代码，本人参考了诸多博客、教程、文档、书籍等资料，由于精力有限，恕不能一一列出。
> <b></b>
> 为了方便在PC上运行调试、分享代码，我还建立了相关的仓库：[https://github.com/memcpy0/Algorithm-Templates](https://github.com/memcpy0/Algorithm-Templates)。在这一仓库中，你可以看到算法文章、模板代码、应用题目等等。由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[算法学习系列文章目录](https://memcpy0.blog.csdn.net/article/details/117125688)一文以作备忘。

@[toc]




---
# 1. 数位DP介绍
所谓「数位DP」，是指对数字的「**位**」进行的、与「**计数**」有关的DP。一个数有个位、十位、百位、千位等，数的每一位就是「**数位**」。

数位DP常被用于解决与数字操作有关的问题，例如**数位之和问题**、**特定数字问题**等。问题的共同特征是，**给定的区间特别大，不能用暴力方法逐个检查**，必须用接近 $O(\log n)$ 复杂度的算法。

具体解题思路一般是，用DP对「数位」进行操作，记录已经计算过的区间的状态，并用于后续计算中，进行快速大范围的筛选。

---
# 2. 经典题目“不要62”
下面以[HDU 不要62](http://acm.hdu.edu.cn/showproblem.php?pid=2089)为示例，讲解数位DP的具体实现。
> 一个数字，如果包含'4'或者'62'，它是不吉利的。给定 $m$ 和 $n$ ，$0 \lt m \le n \lt 10^6$ ，统计 $[m, n]$ 范围内吉利数的个数。

暴力方法是检查每个数，复杂度大于 $O(n)$ ，由于 $n$ 太大，肯定会超时。我们需要一个复杂度接近 $O(\log n)$ 的算法。

很容易想到「**排除法**」，基本思路是在 $[0, 10^6]$ 内排除不符合条件的数，具体操作中按照「**从高位到低位**」的顺序进行判断。例如，求 $[1, 999999]$ 内不包含 $4$ 的数（对 $62$ 的处理方法类似），步骤如下：
1. 在六位数中排除最高位是 $4$ 的数，即 $[400000, 499999]$ ，只需要判断最高位，就可以一次性排除十万个数。
2. 在最高位不是 $4$ 的六位数中排除次高位是 $4$ 的数。例如最高位是 $1$ 的数中，可以一次性排除 $[140000, 149999]$ 共一万个数。注意，**首位可以是零**，即 $[000000, 099999]$ 也算六位数。读者可能认为，这样做会“重复排除”某些数，这一疑问将在实现中解答。
3. 继续排除五位数、四位数等等，直到结束。

下面具体用数位DP的方法，实现上述排除法的思路。一种方法是递推公式，另一种是记忆化搜索。

## 2.1 使用递推实现HDU 2089题
定义状态 `dp[i][j]` ，表示 `i` 位数中首位是 `j` 、且符合要求的数的个数。例如 `dp[6][1]` 表示六位数中首位是 `1` ，即 `[100000, 199999]` 中符合要求的数有多少个。如何求 `dp[6][1]` 乃至 `dp[i][j]` 呢？——计算首位数字 `1` 后面的五位数即可，即计算 `[00000, 99999]` 中符合要求的数的个数。所以 `dp[i][j]` 的递推公式如下：
$$dp[i][j] = \sum^9_{k=0} dp[i - 1][k], \quad (j \ne 4)\ \&\& \ (k \ne 2\ \&\& \ j \ne 6)$$

由于不能含有 `4` 和 `62` ，`dp[i][j]` 中的首位不能是 `4` 、首位不能是 `6` 且同时次高位不能是 `2` 。

实际程序如下所示。为突出对数位DP的理解，此处是简化的程序，只排除了 `4` 、没有排除 `62` 。显然，使用递推的计算复杂度极小，`i, j, k` 三重循环大概只需要计算 `1000` 次：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int LEN = 12;			//可以更大
int dp[LEN][10]; 			//dp[i][j]表示i位数、第1个数是j时符合条件的数字的个数
int digit[LEN];				//digit[i]存储第i位数字
void init() {				//预处理生成DP数组
	dp[0][0] = 1;
	for (int i = 1; i <= LEN; ++i) //从低位递推到高位
		for (int j = 0; j < 10; ++j)
			for (int k = 0; k < 10; ++k)
				if (j != 4)	//排除数字4
					dp[i][j] += dp[i - 1][k];
}
int solve(int len) {		//计算[0,n]区间满足条件的数的个数
	int ans = 0;
	for (int i = len; i >= 1; --i) { //从高位到低位处理
		for (int j = 0; j < digit[i]; ++j) 
			if (j != 4) ans += dp[i][j];
		if (digit[i] == 4) {		 //第i位是4,以4开头的数都不行,直接退出
			--ans;					 //原数n不吉利,减一后加一,答案为ans
			break;					 //否则正常结束后答案为ans+1
		}
	}
	return ans;
}
int main() {
	int n, len = 0;
	init(); 				//预处理计算dp[][]
	scanf("%d", &n);
	while (n) {				//len是n的倍数,例如n=324,是3位数,len=3
		digit[++len] = n % 10;
		n /= 10;			//例如n=324,digit[3]=3,digit[2]=2,digit[1]=4
	}
	printf("%d\n", solve(len) + 1); //求[0,n]内不含有4的数字的个数
	return 0;
}
```

## 2.2 使用记忆化搜索实现HDU 2089题


---
# 3. 各大OJ经典题目
HDU 2089：不要62
HDU 3555：求 $[1, N]$ 里面有多少数包含 $49$ ，$1 \le N \le 2^{63} -1$ 。
HDU 3652：B-number是一个非负整数，十进制形式中包含 $13$ 并且可以被 $13$ 整除。给定整数 $n\ (1 \le n \le 10^9)$ ，计算 $[1, n]$ 的B-number数
HDU 6148：计算不大于 $N$ 的Valley Number个数，结果对 $10^9 + 7$ 取模。此题较难。
HDU 4507：计算 $[L, R]$ 中和 $7$ 无关的数字的平方和，结果对 $10^9 + 7$ 取模。$1 \le L \le R\le 10^{18}$ 。此题较难。
