> 参考算法导论第19章 斐波那契堆
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/17aaaf1717ec4c73a04d78946557eb93.png)

@[toc]

斐波那契数据结构有两种用途。第一种，**它支持一系列操作，这些操作构成了所谓的“可合并堆”**；第二种，**斐波那契堆的一些操作可以在常数摊还时间内完成**，这使得这种数据结构非常适合于「需要频繁调用这些操作的应用」。 

# 1. 可合并堆
**可合并堆** `mergeable heap` 是支持以下五种操作的一种数据结构，其中每个元素都有一个关键字：
- `MAKE-HEAP()` ：创建和返回一个新的不含任何元素的堆。
- `INSERT(H, x)` ：将一个「已填入关键字的元素 $x$ 」插入堆 $H$ 中。
- `MINIMUM(H)` ：返回一个指向堆 $H$ 中「具有最小关键字的元素」的指针。
- `EXTRACT-MIN(H)` ：从堆 $H$ 中删除「具有最小关键字的元素」，并返回一个指向该元素的指针。
- <code>UNION(H<sub>1</sub>, H<sub>2</sub>)</code> ：创建并返回一个包含堆 $H_1, H_2$ 中所有元素的新堆。堆 $H_1, H_2$ 由这一操作“销毁”。
![在这里插入图片描述](https://img-blog.csdnimg.cn/4f0171b304fc4bdcbda5764b0ff86b9c.png)

除了以上可合并堆的操作外，斐波那契堆还支持以下两种操作：
- `DECREASE-KEY(H, x, k)` ：将堆 $H$ 中元素 $x$ 的关键字赋予新值 $k$ 。假定新值 $k$ 不大于当前的关键字（这里默认的可合并堆是可合并最小堆，因此，使用操作 `MINIMUM, EXTRACT-MIN, DECREASE-KEY` ；同样可定义一个**可合并最大堆** `mergeable max-heap` ，使用操作 `MAXIMUM, EXTRACT-MAX, INCREASE-KEY` ）。
- `DELETE(H, x)` ：从堆 $H$ 中删除元素 $x$ 。

如图19-1所示，如果没有 `UNION` 操作，如堆排序（算导第6章）中使用的普通二项堆，其操作性能相当好。除了 `UNION` 操作外，二项堆的其他操作均可在最坏情况时间为 $O(\log n)$ 下完成。但是，**如果需要支持 `UNION` 操作，则二项堆的性能就很差**。通过把两个「分别包含要被合并的二项堆的数组」进行链接、然后运行 `BUILD-MIN-HEAP`（算导6.3节）的方式来实现 `UNION` 操作，其最坏情形需要 $\Theta(n)$ 时间。

另一方面，斐波那契堆对于操作 `INSERT, UNION, DECREASE-KEY` ，比起二项堆有更好的渐近时间界，而对于剩下的几种操作，它们有相同的渐近运行时间。然而注意，图19-1中斐波那契堆的运行时间是摊还时间界，而不是每个操作的最坏情形时间界。`UNION` 操作在斐波那契堆中仅需要常数摊还时间，这比二项堆的最坏情形下的线性时间要好得多（当然，假定为一个摊还时间界）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c27c82f71944466f89320ac9d68956d1.png)
## 理论的斐波那契堆和实际中的斐波那契堆
从理论角度来看，当 `EXTRACT-MIN` 和 `DELETE` 数目相比于其他操作小得多的时候，斐波那契堆尤其适用。这种情形出现在许多应用中。例如，一些图问题算法可能每条边调用一次 `DECREASE-KEY` 。对于有很多边的稠密图，每次调用 `DECREASE-KEY` 需要 $\Theta(1)$ 摊还时间，相比起二项堆最坏情况时间 $\Theta(\log n)$ ，其积累起来是个很大的改进。一些问题如计算最小生成树（算导第23章）和寻找单源最短路（算导第24章）的快速算法，必不可少地要用到斐波那契堆。

然而从实际角度来看，除了某些需要管理大量数据的应用外，对于大多数应用，斐波那契堆的常数因子和编程复杂度，使得它比起普通二项（或 $k$ 项）堆并不那么适用。因此，对斐波那契堆的研究主要出于理论兴趣。如果能开发出一个简单得多的数据结构，而且它的摊还时间界与斐波那契堆相同，那么它将非常实用。

二项堆和斐波那契堆对于 `SEARCH` 操作的支持均比较低效；可能需要花费一段时间才能找到具有给定关键字的元素。为此，涉及给定元素的操作（如 `DECREASE-KEY` 和 `DELETE` ）均需要一个指针指向这个元素，并且指针作为输入的一部分。正如（算导6.5节）对优先级队列的讨论中所述，==当在应用中使用一个可合并堆时，通常在可合并堆的每个元素中、存储一个句柄指向相关应用对象，同样在每个应用对象中也存储一个句柄、指向可合并堆中相关元素==。这些句柄的确切作用依赖于应用和它的实现。

如同所看到的一些其他数据结构，**斐波那契堆也是基于有根树的**。我们把每个元素表示成树中的一个结点，每个结点具有一个 $key$ 属性（之后将使用结点来代替元素）。我们也将忽略结点插入之前、删除之后的内存分配和释放问题，而不是假定调用堆操作的代码来处理这些细节问题。

（算导19.1节）将定义斐波那契堆，讨论如何表示它，并给出用于分析摊还时间的势函数。（算导19.2节）展示，怎样实现可合并堆操作、如何得到图19-1中所述的摊还时间界。（算导19.3节）重点解决剩下的两个操作 `DECREASE-KEY, DELETE` 。（算导19.4节）完成理论分析的主要环节，并解释这个数据结构名字的由来。

![在这里插入图片描述](https://img-blog.csdnimg.cn/047e44a1e2954c17b5e70cf4c695b225.png)

---
# 2. 斐波那契堆结构
一个**斐波那契堆**是一系列具有**最小堆序** `min-heap ordered` 的有根树的集合。即，每棵树均遵循**最小堆性质** `min-heap property` ：每个结点的关键字大于等于它的父结点的关键字。图19-2(a)是一个斐波那契堆的例子。
![在这里插入图片描述](https://img-blog.csdnimg.cn/058ab987087f4156b0b5af2faa927064.png)
如图19-2(b)所示，==每个结点 $x$ 包含一个指向它的父结点的指针 $x.p$ 、一个指向它的某个孩子的指针 $x.child$ 。$x$ 的所有孩子被链接成一个环形的双向链表，称为 $x$ 的**孩子链表**== `child list` 。孩子链表中的每个孩子 $y$ 均有指针 $y.left,\ y.right$ ，分别指向 $y$ 的左兄弟和右兄弟。如果 $y$ 是仅有的一个孩子，则 $y.left = y.right = y$ 。孩子链表中各兄弟出现的次序是任意的。 

环形双向链表（算导10.2节）应用在斐波那契堆中有两个优点：第一，可以在 $O(1)$ 时间从一个环形双向链表的任何位置，插入一个结点或删除一个结点。第二，给定两个这种链表，可以在 $O(1)$ 时间把它们链接成一个环形双向链表。在斐波那契堆操作的描述中，我们将非正式地提到这些操作，实现细节日后补充。

每个结点有另外两个属性。==把结点 $x$ 的孩子链表中的孩子数目存储在 $x.degree$ 。布尔值属性 $x.mark$ 指示结点 $x$ 自从上一次成为另一个结点的孩子后、是否失去过孩子==。新产生的结点是未被标记的，并且当结点 $x$ 成为另一个结点的孩子时，它便成为未被标记结点。直到（算导19.3节的）`DECREASE-KEY` 操作，我们才把所有的 $mark$ 属性值设为 `false` 。

==通过指针 $H.min$ 来访问一个给定的斐波那契堆 $H$ ，该指针指向具有最小关键字的树的根结点，我们把这个结点称为**斐波那契堆的最小结点**== `minimum node` 。如果不止一个根结点具有最小关键字，那么这些根结点中的任何一个都有可能成为最小结点。如果一个斐波那契堆 $H$ 是空的，那么 $H.min$ 为 `NULL` 。

==在斐波那契堆中，所有树的根都用其 $left, right$ 指针链成一个环形的双链表，该双链表称为斐波那契堆的**根链表**== `root list` 。因此，指针 $H.min$ 指向根链表中关键字最小的那个结点。根链表中的树次序可以任意。

我们还要用到斐波那契堆 $H$ 的另一个属性：$H.n$ ，表示 $H$ 中当前的结点数目。
![在这里插入图片描述](https://img-blog.csdnimg.cn/66de30acfeac42369b1be7ee4fc5e9d1.png)
## 势函数
正如上面提到的，将使用（算导17.3节中的）势方法来分析斐波那契堆操作的性能。对于一个给定的斐波那契堆 $H$ ，用 $t(H)$ 来表示 $H$ 中根链表中树的数目，用 $m(H)$ 来表示 $H$ 中已标记的结点数目。然后，定义斐波那契堆 $H$ 的势函数 $\Phi(H)$ 如下：$$\Phi(H) = t(H) + 2m(H) \tag{29.1}$$

（算导19.3节会给出这样定义的一些直观解释）例如，图19-3中所示的斐波那契堆的势为 $5+2 \times 3 = 11$ 。一系列斐波那契堆的势等于各个斐波那契堆势的和。假设势的一个单位可以支付常数数目的工作，该常数要足够大，能够支付我们可能遇到的、任何特定的常数时间的工作。

假定斐波那契堆应用开始时，都没有堆。因此，势初始值为 $0$ ，而且根据公式 $(19.1)$ ，势在随后的任何时间内均不为负。依据公式 $(17.3)$ ，对于某一操作序列来说，总的摊还代价的上界就是其总的实际代价的上界。

## 最大度数
剩下几节中，对摊还分析均假定：**在一个 $n$ 个结点的斐波那契堆中，任何结点的最大度数都有上界 $D(n)$** 。在此不证明这一假定，但是如果仅是支持可合并堆的操作，那么 $D(n) \le \lfloor \log n\rfloor$（算导思考题19-2d要求证明这一性质，算导19.3节、19.4节中，当支持 `DECREASE-KEY, DELET` 操作时，也要求 $D(n) = O(\log n)$ ）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/ca8cb953420e4ae08be7f78c99dfbd81.png)

---
# 3. 可合并堆操作
斐波那契堆上的一些可合并堆操作，要尽可能长地延后执行。不同的操作可以进行性能平衡。例如，用将一个结点加入根链表的方式来插入一个结点，这样仅需耗费常数时间。如果从空的斐波那契堆开始，插入 $k$ 个结点，斐波那契堆将由一个正好包含 $k$ 个结点的根链表组成。如果在斐波那契堆 $H$ 上执行一个 `EXTRACT-MIN` 操作，在移除 $H.min$ 指向的结点后，将不得不遍历根链表中剩下的 $k - 1$ 个结点、来找出新的最小结点，这里便存在性能平衡问题。只要我们在执行 `EXTRACT-MIN` 操作中遍历整个根链表，并把结点合并到最小堆序树中、以减少根链表的规模。

下面将看到，不论根链表在执行 `EXTRACT-MIN` 操作之前是什么样子，执行完该操作之后，根链表中的每个结点要求，有一个与根链表中其他结点均不同的度数，这使得根链表的规模最大为 $D(n) + 1$ 。

## 创建一个新的斐波那契堆
创建一个空的斐波那契堆，`MAKE-FIB-HEAP` 过程分配、并返回一个斐波那契堆对象 $H$ ，其中 $H.n = 0,\ H.min = \textrm{NULL}$ ，$H$ 中不存在树。因为 $t(H)= 0, \ m(H)= 0$ ，空斐波那契堆的势为 $\Phi (H) = 0$ 。因此，`MAKE-FIB-HEAP` 的摊还代价等于它的实际代价 $O(1)$ 。

## 插入一个结点
下面的过程将结点 $x$ 插入斐波那契堆 $H$ 中，假定该结点已经被分配，$x.key$ 已经被赋值。
```cpp
FIB-HEAP-INSERT(H, x)
	x.degree = 0
	x.p = NULL
	x.child = NULL
	x.mark = false
	if H.min == NULL
		create a root list for H containing just x
		H.min = x
	else insert x into H's root list
		if x.key < H.min.key
			H.min = x
	H.n = H.n + 1
```
第 $1 \sim 4$ 行初始化结点 $x$ 的一些属性。第 $5$ 行测试斐波那契堆 $H$ 是否为空。如果为空，那么第 $6 \sim 7$ 行使得 $x$ 成为 $H$ 的根链表中唯一的结点，并将 $H.min$ 指向 $x$ ；否则，第 $8 \sim 10$ 行将结点 $x$ 插入 $H$ 的根链表中，如果有必要，就更新 $H.min$ 。最后，第 $11$ 行 $H.n$ 增 $1$ 来反映新结点的加入。图19-3展示了一个具有关键字 $21$ 的结点插入图19-2所示的斐波那契堆中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/79c90434d5cc493b8282af185b5fea47.png)
为了确定 `FIB-HEAP-INSERT` 的摊还代价，设 $H$ 是输入的斐波那契堆，$H'$ 是结果斐波那契堆。那么 $t(H') = t(H) + 1$ 和 $m(H') = m(H)$ ，并且势的增加量为：$$(( t(H)+ 1) + 2m(H) ) - (t(H)+ 2m(H)) = 1$$ 由于实际代价为 $O(1)$ ，因此摊还代价为 $O(1) + 1 = O(1)$ 。

## 寻找最小结点
斐波那契堆的最小结点，可以通过指针 $H.min$ 得到。因此，可以在 $O(1)$ 的实际代价内找到最小结点。由于 $H$的势没有发生变化，因此该操作的摊还代价等于它的实际代价 $O(1)$ 。
## 两个斐波那契堆的合并
下面的过程合并斐波那契堆 $H_1, H_2$ ，并在该过程中销毁 $H_1, H_2$ 。它简单地将 $H_1, H_2$ 的根链表链接，然后确定新的最小结点。之后，表示 $H_1, H_2$ 的对象将不再使用。
```cpp
FIB-HEAP-UNION(H1, H2)
	H = MAKE-FIB-HEAP()
	H.min = H1.min
	concatenate the root list of H2 with the root list of H
	if (H1.min == NULL) or (H2.min != NULL and H2.min.key < H1.min.key)
		H.min = H2.min
	H.n = H1.n + H2.n
	return H
```
第 $1 \sim 3$ 行将 $H_1, H_2$ 的根链表链接成 $H$ 的新根链表。第 $2, 4, 5$ 行设定 $H$ 的最小结点，第 $6$ 行将 $H.n$ 设为所有结点的个数。第 $7$ 行返回作为结果的斐波那契堆 $H$ 。与 `FIB-HEAP-INSERT` 过程相同，所有的根结点仍为根结点。

势函数的变化为：
$$\Phi(H) - ( \Phi(H_1) + \Phi(H_2)) = (t(H) + 2m(H)) - (( t(H_1) + 2m(H_1)) + (t(H_2) + 2m(H_2))) = 0$$ 因为 $t(H) = t(H_1) + t(H_2)$ 和 $m(H) = m(H_1) + m(H_2)$ ，所以 `FIB-HEAP-UNION` 的摊还代价等于它的实际代价 $O(1)$ 。
## 抽取最小结点
抽取最小结点的过程是本节介绍的操作中、最为复杂的一个。这里还要介绍前面提到的、在根链表中合并树的延后工作。下面的伪代码是抽取最小结点的。为了简便改代码，假定当一个结点从链表中移除后，留在链表中的指针要被更新，但是抽取出的结点中的指针并不改变。该代码还调用一个辅助过程 `CONSOLIDATE` ，稍后将介绍。
```cpp
FIB-HEAP-EXTRACT-MIN(H)
	z = H.min
	if z != NULL
		for each child x of z
			add x to the root list of H
			x.p = NULL
		remove z from the root list of H
		if z == z.right
			H.min = NULL
		else H.min = z.right
			CONSOLIDATE(H)
		H.n = H.n - 1
	return z
```
如图19-4所示，`FIB-HEAP-EXTRACT-MIN` 首先将最小结点的每个孩子变为根结点，并从根链表中删除该最小结点。然后，通过把**具有相同度数的根结点合并的方法**来链接成根链表，直到每个度数至多只有一个根在根链表中。
![在这里插入图片描述](https://img-blog.csdnimg.cn/8bbcec1798134c2f929db125fdef056f.png)
首先第 $1$ 行保存一个最小结点的指针 $z$ ，该程序最后返回这个指针。如果 $z$ 为 `NULL` ，那么斐波那契堆为空，可以结束；否则，在第 $3 \sim 5$ 行中让 $z$ 的所有孩子、成为 $H$ 的根结点（把它们插入根链表），并在第 $6$ 行从根链表中移除 $z$ ，这样 $z$ 便从 $H$ 中删除了。执行完第 $6$ 行之后，如果 $z$ 是它自身的右兄弟，那么 $z$ 是根链表中仅有的一个结点、并且它没有孩子结点。这样所有剩下的工作是，在返回 $z$ 之前，第 $8$ 行使斐波那契堆成为空堆。否则，把指针 $H.min$ 指向根链表中除了 $z$ 之外的某个根结点（这里是 $z$ 的右兄弟），该根结点没有必要一定是 `FIB-HEAP-EXTRACT-MIN` 执行完后的、新的最小结点。图19-4(b)所示的是图19-4(a)执行完第 $9$ 行之后的斐波那契堆。
![在这里插入图片描述](https://img-blog.csdnimg.cn/6f6fc4558bfb443d9c2d8e5dfd86e708.png)

下一步是**合并** `consolidating` $H$ 的根链表，通过调用 `CONSOLIDATE(H)` 来减少斐波那契堆中树的数目。合并根链表的过程为**重复执行以下步骤**，直到根链表中的每一个根有不同的度数。
1. 在根链表中找到两个具有相同度数的根 $x, y$ 。不失一般性，假定 $x.key \le y.key$ 。
2. 把 $y$ 链接到 $x$ ：从根链表中移除 $y$ ，调用 `FIB-HEAP-LINK` 过程，使 $y$ 成为 $x$ 的孩子。该过程将 $x.degree$ 属性加 $1$ ，并清除 $y$ 上的标记。

过程 `CONSOLIDATE` 使用一个辅助数组 $A[0 \dots D(H.n)]$ 来记录根结点对应的度数的轨迹。如果 $A[i] = y$ ，那么当前的 $y$ 是一个具有 $y.degree = i$ 的根。当然，为了分配数组，必须知道如何计算最大度数的上界 $D(H.n)$ ，这些将在下下节（算导19.4节）中介绍。
![在这里插入图片描述](https://img-blog.csdnimg.cn/1ac7ebbf2ea64992a7eb6f9784337bb8.png)

```cpp
CONSOLIDATE(H)
	let A[0...D(H.n)] be a new array
	for i = 0 to D(H.n)
		A[i] = NULL
	for each node w in the root list of H
		x = w
		d = x.degree
		while A[d] != NULL
			y = A[d] // another node with the same degree as x
			if x.key > y.key
				exchange x with y
			FIB-HEAP-LINK(H, y, x)
			A[d] = NULL
			d = d + 1
		A[d] = x
	H.min = NULL
	for i = 0 to D(H.n)
		if A[i] != NULL
			if H.min == NULL
				create a root list for H containing just A[i]
				H.min = A[i]
			else insert A[i] into H's root list
				if A[i].key < H.min.key
					H.min = A[i]

FIB-HEAP-LINK(H, y, x)
	remove y from the root list of H
	make y a child of x, incrementing x.degree
	y.mark = false
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/19a72beb9876405d85a82c5989cce401.png)

具体地说，`CONSOLIDATE` 过程工作如下。
- 第 $1 \sim 3$ 行分配数组 $A$ ，并将数组 $A$ 的每个元素初始化为 `NULL` 。
- 第 $4 \sim 14$ 行的 for 循环，处理根链表中的每个根结点 $w$ 。由于要把根链接起来，因此 $w$ 可能被链接到其他的结点上，不再是一个根。然而，$w$ 必然在「以某个结点 $x$ 为根的树」内，$x$ 可能是、也可能不是 $w$ 本身。因为想要每个根都有不同的度数，所以查找数组 $A$ 来确定是否有某个根 $y$ 与 $x$ 有相同度数。
	- 如果有，则把根 $x, y$ 链接起来，并保证链接完后 $x$ 仍然是一个根。也就是说，如果 $y$ 的关键字小于 $x$ 的关键字，则先交换指向这两个根的指针，再把 $y$ 链接到 $x$ 。在 $y$ 链接到 $x$ 以后，$x$ 的度数增加 $1$ ，继续执行这个过程，把 $x$ 和另一个与 $x$ 的新度数相同的根链接，直到处理过的根没有与 $x$ 有相同的度数。然后，把 $A$ 的相应元素指向 $x$ 。这样处理后续根时，已经记录 $x$ 是已处理过的根中具有该度数的唯一根。当这个 for 循环结束时，每个度数下至多只有一个根，数组 $A$ 指向每个剩下的根。
- 第
![在这里插入图片描述](https://img-blog.csdnimg.cn/a5f04958d4374ca8ba9abfd8adf6b3d0.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/e0cebd5281ba4dc09bc971bd42187277.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/b5487bd6c50b47f3b39e407393e88398.png)

---
![在这里插入图片描述](https://img-blog.csdnimg.cn/555ce2a64d9a4c0c9d43f3f7c719ff40.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/d40235278e224f52be12b484571e14bf.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/ad89e17c83e74f0c95e7bc20d63412f2.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/e9db61d336194aed9cb8349924ac3625.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/95b896a1e19f44d5a7520eab5bef881a.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/fa2a8c596d7c4d7ea72b3393f8c2eca8.png)

---
![在这里插入图片描述](https://img-blog.csdnimg.cn/e3bbb7186dea41e8bec694f9a9078a8e.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/a99249e82e8e40dca14b7af0583c93fd.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/0c730a0c1a094a6cb0cb85a8501d0c4b.png)



15页
