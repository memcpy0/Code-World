
> 本文属于「算法学习」系列文章之一。之前的「数据结构和算法设计」系列着重于基础的数据结构和算法设计课程的学习，与之不同的是，这一系列主要用来记录大学课程范围之外的**高级算法学习、优化与应用的全过程**，同时也将归纳总结出简洁明了的算法模板，以便记忆和运用。在本系列学习文章中，为了透彻理解算法和代码，本人参考了诸多博客、教程、文档、书籍等资料，由于精力有限，恕不能一一列出，这里只列示重要资料的不完全参考列表：
> - 算法竞赛进阶指南，李煜东著，河南电子音像出版社，[GitHub Tedukuri社区](https://github.com/lydrainbowcat/tedukuri)以及[个人题解文章汇总目录](https://memcpy0.blog.csdn.net/article/details/121280121)
> - 算法 第四版 *Algorithm Fourth Edition*，[美] `Robert Sedgewick, Kevin Wayne` 著，谢路云译，[配套网站](https://algs4.cs.princeton.edu/)
> 
> <b></b>
> 为了方便在PC上运行调试、分享代码，我还建立了相关的[仓库](https://github.com/memcpy0/Algorithm-Templates)。在这一仓库中，你可以看到算法文章、模板代码、应用题目等等。由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[算法学习系列文章目录](https://memcpy0.blog.csdn.net/article/details/117125688)一文以作备忘。

@[toc]

---
# 1. 模板问题
先把树链剖分的模板题给出来——已知一棵树，每个结点上包含一个数值，需要设法实现以下操作：
- 操作1：格式 `1 x y z` ，表示将树从 `x` 到 `y` 结点的最短路径之上，所有结点的值都加上 `z` ；
- 操作2：格式 `2 x y` ，表示求树中 `x` 到 `y` 结点的最短路径之上，所有结点的值之和；
- 操作3：格式 `3 x z` ，表示将以 `x` 为根结点的子树内，所有结点值都加上 `z` ；
- 操作4：格式 `4 x` ，表示求以 `x` 为根结点的子树内，所有结点值之和

这一模板题的具体要求见[P3384 【模板】轻重链剖分/树链剖分](https://www.luogu.com.cn/problem/P3384)，本人的题解与代码见[这篇文章](https://memcpy0.blog.csdn.net/article/details/121917252)，完整实现了线段树和树链剖分。

---
# 2. DFS序和时间戳
顾名思义，**DFS序就是（此处是先根遍历）DFS的顺序**。先来个例子，DFS遍历下图的子树，得到的DFS序是 `A B D G H I C E J F`：
<img src="https://img-blog.csdnimg.cn/3538d8fb8bd34119aef97e6949f71ac4.png#pic_center" width="35%">
不要把**欧拉序**和DFS搞混了，欧拉序是：`A B D G D H D I D B A C E J E C F C A` ，即**访问到该结点算一次、返回到该结点算一次**。

**时间戳就是（此处是先根遍历）DFS第一次访问到每个结点时的“时间”**，这一时间是一个从 $1$ 开始递增的整数。仍以上图为例，分别标出结点对应的时间戳：
<img src="https://img-blog.csdnimg.cn/ebd371300c6e418d9857611803c321f8.png#pic_center" width="35%">
==DFS序+时间戳的用处在于，它使树具有连续性，使树转变为一个“连续的序列”==——我们把树看作数组，时间戳是下标，结点的值分别存储在其时间戳对应的位置。在上图中，“数组”是 `arr` ，于是 `arr[1] = 'A', arr[2] = 'B', arr[3] = 'D', arr[4] = 'G', arr[5] = 'H', arr[6] = 'I', arr[7] = 'C', arr[8] = 'E', arr[9] = 'J', arr[10] = 'F'` 。

从示例中，我们可以发现两个重要的性质：
- **一个结点的子树上的结点的时间戳，一定大于结点，且按照DFS序连续**。例如，结点 `C` 的子树 `E, J, F` 的时间戳为 `8, 9, 10` 。
- **某些链（或者说路）上的时间戳也是连续的**。例如，`A, B, D, G` 这条链上的时间戳是连续的，`C, E, J` 这条链上的时间戳也是连续的。

这样一来，我们可以套一个线段树，**用线段树的区间修改和区间查询实现操作3和操作4**。只是操作1和操作2呢？并不是所有的链都有连续的时间戳——像 `A -> B -> D -> G` 这条链也可用线段树的区间修改和查询来操作，但像 `A -> C -> E -> J` 就完全不可行了。**这时**，我们就需要**树链剖分**大法了！ 

---
# 3. 树链剖分
顾名思义，**树链剖分就是把树拆成若干条不相交的链**。

## 3.1 树链剖分的分类
一般可分为三类：
- 重链剖分——常用，时间复杂度为 $O(\log n)$ ；
- 长链剖分——不常用，时间复杂度为 $O(\sqrt{n})$ ；
- 实链剖分——用在Link-Cut Tree中

这里先主要介绍重链剖分。

## 3.2 重链剖分
相关术语如下：
- 重儿子结点：一个结点的所有儿子结点中，大小最大的那个结点。由于是最重的，所以**只有一个**。如果有多个儿子大小相等，则随机取一个。
- 轻儿子结点：一个结点除了重儿子结点之外的所有儿子结点，都是轻儿子。特别注意，**根结点也是轻儿子**。
- 重链：从一个轻儿子结点开始，一路只往重儿子方向走，连出的链即重链。
- 轻链：除了重链之外，全是轻链。

树链剖分之后，再DFS一遍并标出DFS序和时间戳，即可实现题目的四种操作！注意，==此处DFS标记时间戳时，我们要优先往重儿子走，轻儿子无所谓==。
<img src="https://img-blog.csdnimg.cn/cace7e5fd758497390036573f6ec8c5f.png#pic_center" width="32%">
给出上图为示例，我们实际动手剖一剖：
1. 先把重儿子标出来。`A` 的重儿子是 `G` ，`G` 的重儿子是 `E` ，`E` 的重儿子随便标个 `J` ，`C` 的重儿子是 `F` ，`F` 的重儿子是 `D` ，`D` 的重儿子是 `X` ：
<img src="https://img-blog.csdnimg.cn/16cef20935154d078e80d7a3b8856b9b.png#pic_center" width="35%">
2. 再把重链标出来。重链从轻儿子开始，一直往重儿子方向走。根结点 `A` 是轻儿子，于是一直往 `G, E, J` 方向走，得到重链 `A -> G -> E -> J` ；结点 `C` 是轻儿子，于是一直往 `F, D, X` 方向走，得到重链 `C -> F -> D -> X` 。
<img src="https://img-blog.csdnimg.cn/b1d1280d2b094e3b9910e3e838666ac3.png#pic_center" width="35%">
3. 剖分好之后，我们按照重儿子优先的原则进行DFS，并标出结点的时间戳，得到下图（虽然现在还看不出有什么用）：
<img src="https://img-blog.csdnimg.cn/bc907b58aed84f4aa29adf255c6b4b12.png#pic_center" width="35%">

树链剖分+DFS后，我们不难发现，**一条重链上的结点的时间戳都是连续的**——这是因为DFS序的性质2：某些链上的时间戳是连续的。我们让重链成为“某些链”，就有了这样的效果。

此外，根据重链剖分的定义，我们可以证明这一引理：==除根结点外，任何一个结点的父亲结点都一定在一条重链上==。证明很简单，==因为父亲结点存在儿子，所以一定存在重儿子，所以一定在一条重链上。==

## 3.3 利用线段树解决问题
现在，我们利用线段树，开始代码的实现，并实际解决问题。
### 3.3.1 事前准备和大概流程（两遍DFS）
剖分时，我们需要一个时间戳计数器 `tim` ，以及一个维护树上结点权值的线段树。接着先进行一遍DFS，标记以下内容：
- 结点的父亲是谁，用 `fa[maxn]` 记录；
- 结点的大小，用 `siz[maxn]` 记录；
- 结点的重儿子是谁，用 `son[maxn]` 记录；
- 结点的深度，用 `dep[maxn]` 记录；

此时没有标记时间戳，原因很简单，**我们事先不知道重儿子是谁，自然无法重儿子优先进行DFS、标记时间戳**。现在有了重儿子的信息，我们再跑一遍DFS，标记以下内容：
- 结点权值的DFS序、时间戳，分别用 `w[maxn]` 和 `dfn[maxn]` 记录，所有结点的权值则被存放在 `v[maxn]` 中；
- 当前结点所在重链的头部结点是谁（最上面的结点），用 `top[maxn]` 记录。注意，**重链头部结点的头部是自身**

以上是我们事先要做的准备工作。
### 3.3.2 代码实现关键片段
#### 1. 图存储（链式前向星，初始化为-1版本）
```cpp
const int maxn = 1e5 + 10;
const int maxm = maxn * 2; // 边数
struct E {
	int to, next;
} Edge[maxm];
int tot, Head[maxn]; // Head数组初始化为-1,而不是0 */

inline void AddEdge(int u, int v) { // 树(无向连通图)
	Edge[tot] = (E){v, Head[u]};
	Head[u] = tot++;
	Edge[tot] = (E){u, Head[v]};
	Head[v] = tot++;
}
```
#### 2. 第一次DFS
```cpp
// 结点从1开始编号
int fa[maxn], dep[maxn], siz[maxn], son[maxn];
void dfs1(int u, int f) { // 当前结点u及其父亲f
	fa[u] = f;
	dep[u] = dep[f] + 1; // 父结点深度+1
	siz[u] = 1; 	// 当前子树的大小初始化为1
	int maxsize = -1;
	for (int i = Head[u]; ~i; i = Edge[i].next) {
		int v = Edge[i].to;
		if (v == f) continue; // 不能遍历到父结点
		dfs1(v, u);
		siz[u] += siz[v]; // 加上儿子子树的大小
		if (siz[v] > maxsize) {
			maxsize = siz[v]; 
			son[u] = v; // 更大的u的儿子,最后找到重儿子是谁
		}
	}
}
```
#### 3. 第二次DFS
```cpp
int tim, dfn[maxn], w[maxn], top[maxn];
void dfs2(int u, int t) {
	dfn[u] = ++tim; // 时间戳从1开始
	w[tim] = v[u]; // v[u]表示结点u的权值,w按照DFS序记录结点权值
	top[u] = t; // 当前结点所在重链的顶端结点
	if (!son[u]) return; // 如果结点u没有重儿子,说明它没有儿子,则返回
	dfs2(son[u], t); // 往重儿子方向走,这一重儿子也属于当前重链,链的顶端不变仍为t
	for (int i = Head[u]; ~i; i = Edge[i].next) {
		int v = Edge[i].to;
		// 如果当前结点是u的父亲或重儿子,则跳过
		if (v == fa[u] || v == son[u])
			continue;
		// DFS其他轻儿子结点v,v肯定不属于当前重链
		// 且重链从轻儿子开始,于是令v为下一条重链的顶端
		dfs2(v, v); 
	}
}
```
#### 4. 线段树实现
下面的代码中，`modify(x, y, z)` 表示令 `[x, y]` 区间内的数值全部加上 `z` ，`query(x, y)` 表示查询 `[x, y]` 区间内的数值之和。具体实现见前文的题解链接。

#### 5. 操作3和操作4
由于这两者很简单，我们实现如下：
```cpp
// 将以x为根结点的子树内所有结点值都加上z
inline void mson(int x, int z) {
	// 子树结点的时间戳是连续的
	modify(dfs[x], dfs[x] + siz[x] - 1, z);
}
// 查询以x为根结点的子树内所有结点值之和
inline int qson(int x) {
	return query(dfn[x], dfn[x] + siz[x] - 1);
}
```
#### 6. 操作1和操作2
利用3.2节中证明的引理，我们可以发现：==在树上，任何两个结点间的一条路径（一定也是两个结点间的最短路径），都是由重链的一部分和叶子结点组成的==。比如下图中，从 `J` 到 `X` 分别由重链 `A -> G -> E -> J` 和 `C -> F -> D -> X` 组成：
<img src="https://img-blog.csdnimg.cn/b3902276c3d7428e9e1a7820ff9ef38d.png#pic_center" width="35%">
如果要修改或查询的两个结点在同一条重链上，问题就变得非常简单，只需要在线段树上修改或查询即可，操作类似上文。

如果不在同一条重链上呢？
- 我们可以维护两个指针，分别指向这两个结点；
- 不断地让「所在重链的顶部结点深度较大」的指针，沿着所在重链往上跳，一边跳、还要一边在线段树上操作（**有点类似LCA**）——这里可能有点疑问：为什么在向上跳的时候，要选所在重链顶部的深度进行比较？而不是选择点的深度？
由于两个结点 $x,y$ 不处于同一条链，首先==一定不能跳到链顶深度更小的点，这样做可能越过两个点的 `LCA` （最近公共祖先结点）==。然后，如果只比较点的深度，选择更深的结点，有可能跳到链顶深度更小的点，因为可能存在 $y$ 的深度大于 $x$ ，但是 $y$ 的链顶深度小于 $x$ 的链顶深度。
- 操作完之后，该指针还要往上跳到当前的父亲结点处。由于==除根结点外，任何一个结点的父亲结点都一定在一条重链上==，所以==可以继续循环，直到两个结点跳到同一结点或同一重链上，就解决了问题==。

例如，指针 `p, q` 分别指向这两个结点 `J, X` 。指针 `p` 指向结点 `J` ，所在重链顶端是 `A` ，要让它跳到 `A` 只需 `p = top[p]` 。

代码如下所示：
```cpp
// 将结点x到y的最短路径上的所有结点的值加上z
void mchain(int x, int y, int z) {
	z %= mod;	// 模板题要取模
	while (top[x] != top[y]) { // 不在同一条重链上
		if (dep[top[x]] < dep[top[y]]) 
			std::swap(x, y);
		modify(dfn[top[x]], dfn[x], z); // 跳的时候进行操作
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) // 在同一条重链上,只是不在同一结点
		std::swap(x, y);
	modify(dfn[x], dfn[y], z);
}
// 查询结点x到y的最短路径上的所有结点的值之和
int qchain(int x, int y) {
	int ret = 0;
	while (top[x] != top[y]) { // 不在同一条重链上
		if (dep[top[x]] < dep[top[y]]) 
			std::swap(x, y);
		ret += query(dfn[top[x]], dfn[x]); // 跳的时候进行操作
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) // 在同一条重链上,只是不在同一结点
		std::swap(x, y);
	ret += query(dfn[x], dfn[y]);
	return ret % mod; // 模板题要取模
}
```
#### 7. 主函数
主函数要做的工作比较多，有读入数据、建图、一次DFS、二次DFS（此时树链剖分已把树变换为连续的序列 `w[]`），其后根据 `w[]` 创建一棵线段树，用在树链剖分中获得的信息，具体维护关于 `w[]` 的线段树，处理对它的查询和修改。

## 3.4 复杂度
关于时间复杂度，由于重链剖分是 $O(\log n)$ 的，线段树的操作是 $O(\log n)$ 的，对于 $m$ 次询问，总的时间复杂度为 $O(m\log^2n)$ 。

---
# 4. 变形的树链剖分
上面的树链剖分基于点权，**如果是边权，则将其转换为儿子的点权即可**，叶子结点的点权是它和它父亲那条边的边权。

---
# 5. 树链剖分求LCA
求LCA的方法太多了，如Tarjan、树上倍增（**树上倍增可以解决的，树链剖分都可以解决，反之则不然**）、欧拉序+ST表……用树链剖分求LCA很简单，也是用两个指针不断跳跃。

---
# 6. 树链剖分题目
洛谷的两份题单：
- [树链剖分练习题](https://www.luogu.com.cn/training/1654)：树链剖分+线段树代码量通常在3K左右，出错的地方非常多，为了好好练手，特建立该题单，建议不要进行复制，每一题都老老实实重打。
- [线段树+树链剖分专题](https://www.luogu.com.cn/training/1125)：适合刚学习线段树的新手、到刚学树链剖分的新手
