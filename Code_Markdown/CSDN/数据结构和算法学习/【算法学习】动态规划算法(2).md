@[toc]

---
# 4. 最长公共子序列
在生物应用中，经常需要比较两个（或多个）不同生物体的DNA。一个DNA由一串称为**碱基** `base` 的分支组成，碱基有腺嘌呤、鸟嘌呤、胞嘧啶、胸腺嘧啶四种类型。我们用英文单词首字母表示四种碱基，这样就可以将一个DNA串表示为有限集 $\{ A, C, G, T\}$ 上的一个字符串（算导附录C中对字符串的定义）。例如，某种生物的DNA可能为 `S1 = ACCGGTCGAGTGCGCGGAAGCCGGCCGAA` ，另一种生物的DNA可能为 `S2 = GTCGTTCGGAATGCCGTTGCTCTGTAAA` 。我们比较两个DNA串的一个原因是，希望确定它们的“相似度”，作为度量两种生物相近程度的指标。

我们可以用很多不同的方式来定义相似度，实际上也确实已经出现了很多相似度的定义。例如，**如果一个串是另一个字符串的子串**，那么可以说它们是相似的（算导第32章求解此问题）。但我们的例子中 `S1, S2` 都不是对方的子串。我们还可以这样定义相似度：**如果将一个串转换为另一个串所需的操作很少**，那么可以说两个串是相似的（算导思考题15-5）。另一种衡量串 `S1, S2` 的相似度的方式是：**寻找第三个串 `S3` ，它的所有碱基也都出现在 `S1, S2` 中，且在三个串中出现的顺序都相同，但在 `S1, S2` 中不要求连续出现，可以找到的 `S3` 越长，就认为 `S1, S2` 的相似度越高**。我们的例子中，最长的 `S3 = GTCGTCGGAAGCCGGCCGAA` 。

我们将最后一种相似度的概念，命名为最长公共子序列问题。一个给定序列的子序列，就是将给定序列中零个或多个元素去掉之后得到的结果。其形式化定义如下：给定一个序列 $X = \langle x_1, x_2, \dots, x_m\rangle$ ，另一个序列 $Z = \langle z_1, z_2, \dots, z_k \rangle$ 满足如下条件时称为 $X$ 的**子序列** `subsequence` ，即==存在一个严格递增的 $X$ 的下标序列 $\langle i_1, i_2, \dots, i_k \rangle$ ，对所有 $j = 1, 2, \dots, k$ 满足 $x_{i_j} = z_j$== 。例如，$Z = \langle B, C, D, B \rangle$ 是 $X = \langle A, B, C, B, D, A, B \rangle$ 的子序列，对应的下标序列为 $\langle 2, 3, 5,7 \rangle$ 。

给定两个序列 $X$ 和 $Y$ ，如果 $Z$ 既是 $X$ 的子序列，也是 $Y$ 的子序列，我们称它是 $X$ 和 $Y$ 的**公共子序列** `common subsequence` 。例如，如果 $X = \langle A, B, C, B, D, A, B \rangle,\ Y = \langle B, D, C, A, B, A \rangle$ ，那么序列 $\langle B, C, A\rangle$ 就是 $X$ 和 $Y$ 的公共子序列，但它不是 $X$ 和 $Y$ 的最长公共子序列 `LCS` ，因为它长度为 $3$ ，而 $\langle B, C, B, A\rangle$ 也是 $X$ 和 $Y$ 的公共子序列，其长度为 $4$ ，而且是最长公共子序列，$\langle B, D, A, B\rangle$ 也是，因为 $X$ 和 $Y$ 不存在长度大于等于 $5$ 的公共子序列。

**最长公共子序列问题** `longest-common-subsequence problem` 给定两个序列 $X = \langle x_1, x_2, \dots, x_m\rangle, Y = \langle y_1, y_2, \dots, y_n \rangle$ ，求 $X$ 和 $Y$ 长度最长的公共子序列。本节将展示如何用动态规划方法高效求解LCS问题。

## 步骤1：刻画最长公共子序列的特征
如果用暴力搜索方法求解LCS问题，就要穷举 $X$ 的所有可能子序列，对每个子序列检查它是否也是 $Y$ 的子序列，记录找到的最长子序列。$X$ 的每个子序列对应 $X$ 的下标集合 $\langle 1, 2, \dots, m\rangle$ 的一个子集，所以 $X$ 有 $2^m$ 个子序列，因此暴力方法的运行时间为指数阶，对较长的序列是不实用的。

但是如下面的定理所示，**LCS问题具有最优子结构性质**。我们将看到，**子问题的自然分类对应两个输入序列的“前缀”对**。前缀的严谨定义如下：给定一个序列 $X = \langle x_1, x_2, \dots, x_m \rangle$ ，对 $i = 0, 1, \dots, m$ 定义 $X$ 的第 $i$ 前缀为 $X_i = \langle x_1, x_2, \dots, x_i \rangle$ 。例如，若 $X = \langle A, B, C, B, D, A, B\rangle$ ，则 $X_4 = \langle A, B, C, B\rangle$ ，$X_0$ 为空串。

**定理15.1**（LCS的最优子结构）令 $X = \langle x_1, x_2, \dots, x_m \rangle$ 和 $Y = \langle y_1, y_2, \dots, y_n\rangle$ 为两个序列，**$Z= \langle z_1, z_2, \dots, z_k \rangle$ 为 $X$ 和 $Y$ 的任意LCS**。
1. 如果 $x_m = y_n$ ，则 $z_k = x_m = y_n$ ，且 $Z_{k-1}$ 是 $X_{m-1}$ 和 $Y_{n-1}$ 的一个LCS。
2. 如果 $x_m \ne y_n$ ，那么 $z_k \ne x_m$ ，就蕴含 $Z$ 是 $X_{m-1}$ 和 $Y$ 的一个LCS。
3. 如果 $x_m \ne y_n$ ，那么 $z_k \ne y_n$ ，就蕴含 $Z$ 是 $X$ 和 $Y_{n-1}$ 的一个LCS。

**证明**：（1）（反证法）如果 $z_k \ne x_m$（也就 $\ne y_n$ ，因为二者相等），那么我们可以将 $x_m = y_n$ 追加到 $Z$ 的末尾，得到 $X$ 和 $Y$ 的一个长度为 $k + 1$ 的公共子序列（此时 $z_{k+1} = x_m = y_n$ ），与 $Z$ 是 $X$ 和 $Y$ 的LCS的假设矛盾。因此，==必然有 $z_k = x_m = y_n$ 。这样，前缀 $Z_{k-1}$ 是 $X_{m-1}$ 和 $Y_{n-1}$ 的一个长度为 $k - 1$ 的公共子序列==。我们希望证明它是一个LCS。再次利用反证法，假设存在 $X_{m-1}$ 和 $Y_{n-1}$ 的一个长度大于 $k - 1$ 的公共子序列 $W$ ，则将 $x_m = y_n$ 追加到 $W$ 的末尾，会得到 $X$ 和 $Y$ 的一个长度大于 $k$ 的公共子序列，矛盾。
（2）如果 $z_k \ne x_m$ ，那么 $Z$ 是 $X_{m-1}$ 和 $Y$ 的一个公共子序列。如果存在 $X_{m-1}$ 和 $Y$ 的一个长度大于 $k$ 的公共子序列 $W$ ，那么 $W$ 也是 $X_m$ 和 $Y$ 的公共子序列，与 $Z$ 是 $X$ 和 $Y$ 的最长公共子序列的假设矛盾。
（3）与情况(2)对称。$\blacksquare$

**定理15.1**告诉我们，==两个序列的LCS包含两个序列的前缀（也是序列）的LCS。因此，LCS问题具有最优子结构性质==。我们马上还会看到，其递归算法也具有重叠子问题性质。
## 步骤2：一个递归解
**定理15.1**意味着，在求 $X = \langle x_1, x_2, \dots, x_m \rangle$ 和 $Y= \langle y_1, y_2, \dots, y_n \rangle$ 的一个LCS时，我们需要求解**一个或两个子问题**。
- 如果 $x_m = y_n$ ，我们应该求解 $X_{m-1}$ 和 $Y_{n-1}$ 的一个LCS。将 $x_m = y_n$ 追加到这个LCS的末尾，就得到 $X$ 和 $Y$ 的一个LCS。
- 如果 $x_m \ne y_n$ ，我们必须求解两个子问题：求 $X_{m-1}$ 和 $Y$ 的一个LCS与 $X$ 和 $Y_{n-1}$ 的一个LCS。两个LCS较长者即为 $X$ 和 $Y$ 的一个LCS。

==由于这些情况覆盖了所有可能性，因此我们知道，必然有一个子问题的最优解出现在 $X$ 和 $Y$ 的LCS中==。

我们可以很容易看出LCS问题的重叠子问题性质。为了求 $X$ 和 $Y$ 的一个LCS，我们可能需要求 $X$ 和 $Y_{n-1}$ 的一个LCS及 $X_{m-1}$ 和 $Y$ 的一个LCS。但是这几个子问题都包含求解 $X_{m-1}$ 和 $Y_{n-1}$ 的LCS的子子问题。很多其他子问题也都共享子子问题。

与矩阵链乘法问题相似，**设计LCS问题的递归算法首先要建立最优解的递归式**。我们定义 $c[i, j]$ 表示 $X_i, Y_j$ 的LCS长度。如果 $i = 0$ 或 $j = 0$ ，则一个序列长度为 $0$ ，那么LCS的长度为 $0$ 。根据LCS问题的最优子结构性质，可得如下公式：$$c[i, j] = \begin{cases}
0 \quad &若i=0或j=0 \\
c[i-1,j-1] + 1 \quad &若i,j > 0且x_i = y_j \\
\max(c[i, j- 1], c[i-1, j]) \quad &若i,j>0且x_i \ne y_j \end{cases} \tag{15.9}$$

观察到==在递归公式中，我们通过限制条件，限定了需要求解哪些子问题==。
- 当 $x_i = y_j$ 时，我们可以而且应该求解子问题：$X_{i-1}$ 和 $Y_{j-1}$ 的一个LCS。
- 否则，应该求解两个子问题：$X_i$ 和 $Y_{j-1}$ 的一个LCS及 $X_{i-1}$ 和 $Y_j$ 的一个LCS。

在之前讨论过的钢条切割问题和矩阵链乘法问题的动态规划算法中，根据问题的条件，我们没有排除任何子问题。不过，LCS问题并非唯一根据条件排除子问题的动态规划算法。例如，编辑距离问题（算导思考题15-5）也具有这种特点。
## 步骤3：计算LCS的长度
根据公式 $(15.9)$ ，我们很容易地写出一个指数时间的递归算法、来计算两个序列的LCS的长度。但由于LCS问题只有 $\Theta(mn)$ 个不同的子问题，我们可以用动态规划自底向上地计算。

过程 `LCS-LENGTH` 接受两个序列 $X = \langle x_1, x_2, \dots, x_m\rangle$ 和 $Y = \langle y_1, y_2, \dots, y_n \rangle$ 为输入，它将 $c[i, j]$ 的值保存在表 $c[0\dots m, 0\dots n]$ 中，并按**行主次序** `row-major order` 计算表项（即首先由左至右计算 $c$ 的第一行，然后计算第二行，依次类推）。过程还维护一个表 $b[1\dots m, 1\dots n]$ ，帮忙构造最优解。$b[i, j]$ 指向的表项对应计算 $c[i, j]$ 时选择的子问题最优解。过程返回表 $b$ 和表 $c$ ，$c[m, n]$ 保存了 $X$ 和 $Y$ 的LCS的长度。
```cpp
LCS-LENGTH(X, Y)
	m = X.length
	n = Y.length
	let b[1...m, 1...n] and c[0...m, 0...n] be new tables
	for i = 1 to n
		c[i, 0] = 0
	for j = 0 to n
		c[0, j] = 0
	for i = 1 to n
		for j = 1 to n
			if xi == yi
				c[i, j] = c[i - 1, j - 1] + 1
				b[i, j] = "↖"
			else if c[i - 1, j] >= c[i, j - 1]
				c[i, j] = c[i - 1, j]
				b[i, j] = "↑"
			else c[i, j] = c[i, j - 1]
				b[i, j] = "←"
	return c and b
```
图15-8显示了 `LCS-LENGTH` 对输入序列 $X =\langle A, B, C, B, D, A, B\rangle$ 和 $Y = \langle B, D, C, A, B, A\rangle$ 生成的结果。过程的运行时间为 $\Theta(mn)$ ，因为每个表项的计算时间为 $\Theta(1)$ 。
![](https://img-blog.csdnimg.cn/556d8a8ab4d8425eafa263901c3646b6.png)

## 步骤4：构造LCS
我们可以用 `LCS-LENGTH` 返回的表 $b$ 、快速构造 $X = \langle x_1, x_2,\dots, x_m\rangle$ 和 $Y = \langle y_1, y_2, \dots, y_n \rangle$ 的LCS，只需简单地从 $b[m, n]$ 开始，并按箭头方向追踪下去即可。当在表项 $b[i, j]$ 遇到一个 $\nwarrow$ 时，意味着 $x_i = y_j$ 是LCS的一个元素。按照这种方法，我们可以按逆序依次构造出LCS的所有元素。下面的递归过程，会按正确的顺序打印出 $X$ 和 $Y$ 的一个LCS。对它的初始调用为 `PRINT-LCS(b, X, X.length, Y.length)` 。
```cpp
PRINT-LCS(b, X, i, j)
	if i == 0 or j == 0
		return
	if b[i, j] == "↖"
		PRINT-LCS(b, X, i - 1, j - 1)
		print xi
	else if b[i, j] == "↑"
		PRINT-LCS(b, X, i - 1, j)
	else PRINT-LCS(b, X, i, j - 1)
```
对图15-8中的表 $b$ ，此过程会打印出 $BCBA$ 。过程的运行时间为 $O(m+n)$ ，因为每次递归调用 $i$ 和 $j$ 至少有一个会减少 $1$ 。
## 算法改进
一旦设计出一个算法，通常情况下都会发现它在时空开销上有改进的余地。一些改进可以简化代码，将性能提高常数倍，但除此之外不会产生性能方面的渐近性提升。而另一些改进可以带来时空上巨大的渐近性提升。

例如，对LCS算法，我们完全可以去掉表 $b$ 。每个 $c[i, j]$ 项只依赖于表 $c$ 中的其他三项：$c[i - 1, j],\ c[i, j - 1],\ c[i - 1, j-1]$ 。==给定 $c[i, j]$ 的值，我们可以在 $O(1)$ 时间内判断出、在计算 $c[i, j]$ 时使用了这三项中的哪一项==。因此，我们可以用一个类似 `PRINT-LCS` 的过程，在 $O(m + n)$ 时间内完成重构LCS的工作，而且不必使用表 $b$ 。但是，虽然这种方法节省了 $\Theta(mn)$ 的空间，但计算LCS所需的辅助空间并未渐近减少，因为无论如何表 $c$ 都需要 $\Theta(mn)$ 的空间。

不过，`LCS-LENGTH` 的空间需求是可以渐近减少的，因为在任何时刻它只需要表 $c$ 中的两行：当前正在计算的一行和前一行（实际上，算导练习15.4-4要求设计一个算法，只使用一行多一点的空间来计算LCS的长度）。如果我们只需LCS的长度，这一改进是有效的。但如果需要重构LCS中的元素，这么小的表空间保存的信息不足以在 $O(m+n)$ 时间内完成重构工作。

---
# 5. 最优二叉搜索树
假定我们正在设计一个程序，实现英语文本到法语的翻译。对英文文本中出现的每个单词，我们需要查找对应的法语单词。为了实现这些查找操作，我们可以创建一棵二叉搜索树，将 $n$ 个英语单词作为关键字，对应的法语单词作为关联数据。由于对文本中的每个单词都要进行搜索，我们希望花费在搜索上的总时间尽量少。通过使用红黑树或其他平衡搜索树结构，我们可以假定每次搜索时间为 $O(\log n)$ 。

但是，单词出现的频率是不同的，像 `the` 这种频繁使用的单词可能位于搜索树中远离根的位置，而像 `machicolation` 这种很少使用的单词可能位于靠近根的位置上，这样的结构会减慢翻译的速度。因为在二叉搜索树中搜索一个关键字需要访问的结点数，等于包含关键字的结点的深度加一。我们希望文本中频繁出现的单词被置于靠近根的位置，而且，文本中的一些单词可能没有对应的法语单词，这些单词根本不应该出现在二叉搜索树中。==在给定单词出现频率的前提下，我们应该如何组织一棵二叉搜索树，使得所有搜索操作访问的结点总数最少呢==？

这个问题称为**最优二叉搜索树** `optimal binary search tree` 问题。其形式化定义如下：给定一个 $n$ 个不同关键字的已排序的序列 $K = \langle k_1, k_2, \dots, k_n \rangle$（因此 $k_1  < k_2 < \dots < k_n$ ），我们希望用这些关键字构造一棵二叉搜索树。对每个关键字 $k_i$ 都有一个概率 $p_i$ 表示其搜索频率，有些要搜索的值可能不在 $K$ 中，因此我们还有 $n+1$ 个“伪关键字” $d_0, d_1, d_2, \dots, d_n$ 表示不在 $K$ 中的值。$d_0$ 表示所有小于 $k_1$ 的值，$d_n$ 表示所有大于 $k_n$ 的值，对 $i = 1, 2, \dots, n - 1$ 伪关键字 $d_i$ 表示所有在 $k_i$ 和 $k_{i+1}$ 之间的值。对每个伪关键字，也都有一个概率 $q_i$ 表示对应的搜索频率。

图15-9显示了对一个 $n = 5$ 个关键字的集合、构造的两棵二叉搜索树。每个关键字 $k_i$ 是一个内部结点，而每个伪关键字 $d_i$ 是一个叶结点。**每次搜索要么成功（找到某个关键字 $k_i$ ），要么失败（找到某个伪关键字 $d_i$ ）**，因此有如下公式：
$$\sum^n_{i=1} p_i + \sum^n_{i=0} q_i = 1 \tag{15.10}$$
![](https://img-blog.csdnimg.cn/eab2f924cb21438c9a4f42606ff3de23.png)

由于我们知道每个关键字和伪关键字的搜索概率，因而可以确定在一棵给定的二叉搜索树 $T$ 中进行一次搜索的期望代价。假定**一次搜索的代价等于访问的结点数**，即「此次搜索找到的结点在 $T$ 中的深度」再加 $1$ 。那么**在 $T$ 中进行一次搜索的期望代价**为：$$
E[T中搜索代价] = \sum^n_{i=1} ( \mathrm{depth_T}(k_i) + 1) \cdot p_i + \sum^n_{i=0} (\mathrm {depth_T}(d_i) + 1) \cdot q_i \\
= 1 + \sum^n_{i=1} \mathrm{ depth_T} (k_i) \cdot p_i + \sum^n_{i=0} \mathrm{ depth_T} (d_i) \cdot q_i \tag{15.11}$$

其中 $\mathrm{ depth_T}$ 表示一个结点在树 $T$ 中的深度。最后一个等式是由公式 $(15.10)$ 推导而来。在图15-9(a)中，我们逐结点计算期望搜索代价。
![](https://img-blog.csdnimg.cn/6c5eb601423a4fc99968d2448795c467.png)

对一个给定的概率集合，我们希望构造一棵期望搜索代价最小的二叉搜索树，我们称之为**最优二叉搜索树**。图15-9(b)所示的二叉搜索树就是给定概率集合的最优二叉搜索树，其期望代价为 $2.75$ 。这个例子显示，==最优二叉搜索树不一定是高度最矮的。而且，概率最高的关键字也不一定出现在二叉搜索树的根结点==。在此例中，关键字 $k_5$ 的搜索概率最高，但最优二叉搜索树的根结点为 $k_2$（在所有以 $k_5$ 为根的二叉搜索树中，期望搜索代价最小者为 $2.85$ ）。

与矩阵链乘法问题相似，对本问题来说，穷举并检查所有可能的二叉搜索树不是一个高效的算法。对任意一棵 $n$ 个结点的二叉树，我们都可以通过对结点标记关键字 $k_1, k_2, \dots, k_n$ 构造出一棵二叉搜索树，然后向其中添加伪关键字作为叶结点。（算导思考题12-4中）我们会看到 $n$ 个结点的二叉树的数量为 $\Omega(4^n / n^{3/2})$ ，因此穷举法需要检查指数棵二叉搜索树。不出意外，我们将使用动态规划求解此问题。
## 步骤1：最优二叉搜索树的结构
为了刻画最优二叉搜索树的结构，我们从观察子树特征开始。==考虑一棵二叉搜索树的任意子树，它必须连续包含关键字 $k_i, \dots, k_j\ ( 1\le i \le j \le n)$ ，而且其叶结点必须是伪关键字 $d_{i-1}, \dots, d_j$== 。

我们现在可以给出==二叉搜索树问题的最优子结构：如果一棵最优二叉搜索树 $T$ 有一棵包含关键字 $k_i , \dots, k_j$ 的子树 $T'$ ，那么 $T'$ 必然是包含关键字 $k_i, \dots, k_j$ 和伪关键字 $d_{i-1}, \dots, d_j$ 的子问题的最优解==。我们依旧用**剪切-粘贴法**来证明这一结论。如果存在子树 $T''$ ，其期望搜索代价比 $T'$ 低，那么我们将 $T'$ 从 $T$ 中删除，将 $T''$ 粘贴到相应位置，从而得到一棵期望搜索代价低于 $T$ 的二叉搜索树，与 $T$ 最优的假设矛盾。

**我们需要利用最优子结构性质证明，我们可以用子问题的最优解构造原问题的最优解**。给定关键字序列 $k_i, \dots, k_j$ ，其中某个关键字比如说 $k_r\ (i \le r \le j)$ ，是这些关键字的最优子树的根结点。那么 $k_r$ 的左子树就包含关键字 $k_i, \dots, k_{r-1}$（和伪关键字 $d_{i-1}, \dots, d_{r-1}$ ），而右子树包含关键字 $k_{r+1}, \dots, k_j$（和伪关键字 $d_r, \dots, d_j$ ）。==只要我们检查所有可能的根结点 $k_r\ (i \le r \le j)$ ，并对每种情况分别求解包含 $k_i, \dots, k_{r-1}$ 及包含 $k_{r+1}, \dots, k_j$ 的最优二叉搜索树，即可保证找到原问题的最优解==。

这里还有一个值得注意的细节——“空子树”。假定对于包含关键字 $k_i, \dots, k_j$ 的子问题，我们选定 $k_i$ 为根结点。根据前文论证，$k_i$ 的左子树包含关键字 $k_i, \dots, k_{i-1}$ ，我们将此序列解释为不包含任何关键字。但请注意，**子树仍然包含伪关键字**。按照惯例，==我们认为包含关键字序列 $k_i, \dots, k_{i-1}$ 的子树不含任何实际关键字，但包含单一伪关键字 $d_{i-1}$== 。对称地，如果选择 $k_j$ 为根结点，那么 $k_j$ 的右子树包含关键字 $k_{j+1}, \dots, k_j$ ——此右子树不包含任何实际关键字，但包含伪关键字 $d_j$ 。
## 步骤2：一个递归算法
我们已经准备好给出最优解值的递归定义。我们选择子问题域为：求解包含关键字 $k_i,\dots, k_j$ 的最优二叉搜索树，其中 $i \ge 1, j \le n$ 且 $j \ge i -1$（当 $j = i - 1$ 时子树不包含实际关键字，只包含伪关键字 $d_{i-1}$ ）。定义 $e[i, j]$ 为**在包含关键字 $k_i, \dots, k_j$ 的最优二叉搜索树中、进行一次搜索的期望代价**。最终，我们希望计算出 $e[1, n]$ 。
- $j = i - 1$ 的情况最为简单，由于子树只包含伪关键字 $d_{i-1}$ ，期望搜索代价为 $e[i, i-1] = q_{i-1}$ 。
- ==当 $j \ge i$ 时，我们需要从 $k_i, \dots, k_j$ 中选择一个根结点 $k$ ，然后构造一棵包含关键字 $k_i, \dots, k_{r-1}$ 的最优二叉搜索树作为其左子树，以及一棵包含关键字 $k_{r+1}, \dots, k_j$ 的二叉搜索树作为其右子树==。当一棵子树成为一个结点的子树时，期望搜索代价有何变化？由于每个结点的深度都增加了 $1$ ，根据公式 $(15.11)$ ，**这棵子树的期望搜索代价的增加值应为所有概率之和**。对于包含关键字 $k_i, \dots, k_j$ 的子树 `the expected search cost of this subtree increases by the sum of all the probabilities in the subtree` ，所有概率之和为：$$w(i, j) = \sum^j_{l = i} p_l + \sum^j_{l = i - 1} q_l \tag{15.12}$$

	因此，若 $k_r$ 为包含关键字 $k_i, \dots, k_j$ 的最优二叉搜索树的根结点，我们有如下公式：$$e[i, j]
= p_r + \Big(e [i, r - 1] + w(i, r - 1)\Big) + \Big( e[r + 1, j] + w(r + 1, j)\Big)$$

	注意：$$w(i, j) = w(i, r - 1) + p_r + w(r+1, j)$$

	因此，$e[i, j]$ 可重写为：$$e[i, j] = e[i, r - 1] + e[r + 1, j] +w(i, j) \tag{15.13}$$

递归公式 $(15.13)$ 假定，我们知道哪个结点 $k$ 应该作为根结点。如果选取期望搜索代价最低者作为根结点，可得最终递归公式：$$e[i, j] = \begin{cases}
q_{i-1} \quad &若j=i-1 \\
\displaystyle \min_{ i\ \le\ r\ \le j} \{\ e[i, r - 1] + e[r + 1, j] + w(i, j)\ \} \quad &若i\le j\end{cases} \tag{15.14}$$

**$e[i, j]$ 的值给出了最优二叉搜索树的期望搜索代价**。为了记录最优二叉搜索树的结构，对于包含关键字 $k_i, \dots, k_j\ (1 \le i \le j \le n)$ 的最优二叉搜索树，我们定义 $root[i, j]$ 保存根结点 $k_r$ 的下标 $r$ 。虽然我们将看到如何计算 $root[i, j]$ 的值，但是利用这些值来构造最优二叉搜索树的问题，见（算导练习15.5-1）。

## 步骤3：计算最优二叉搜索树的期望搜索代价
现在可能已经注意到，我们求解==最优二叉搜索树和矩阵链乘法的一些相似之处。它们的子问题都由连续的下标子域组成==。而公式 $(15.14)$ 的直接递归实现，也会与矩阵链乘法问题的直接递归算法一样低效。因此，我们设计替代的高效算法，我们用一个表 $e[1\dots n + 1,\ 0 \dots n]$ 来保存 $e[i, j]$ 值。
- 第一维下标上界为 $n + 1$ 而不是 $n$ ，原因在于对于只包含伪关键字 $d_n$ 的子树，我们需要计算并保存 $e[n + 1, n]$ 。
- 第二维下标下界为 $0$ ，因为对于只包含伪关键字 $d_0$ 的子树，我们需要计算并保存 $e[1, 0]$ 。

我们只使用此表中满足 $j \ge i - 1$ 的表项 $e[i, j]$ 。

我们还使用一个表 $root$ ，表项 $root[i, j]$ 记录「包含关键字 $k_i, \dots, k_j$ 的子树」的根。我们只使用此表中满足 $1\le i \le j \le n$ 的表项 $root[i, j]$ 。

我们还需要另一个表来提高计算效率。==为了避免每次计算 $e[i, j]$ 时都重新计算 $w(i, j)$ ，我们将这些值保存在表 $w[1\dots n + 1,\ 0\dots n]$ 中，这样每次可节省 $\Theta(j -i)$ 次加法==。对基本情况，令 $w[i, i - 1] = q_{i-1}\ (1\le i \le n + 1)$ 。对 $j \ge i$ 的情况，可如下计算：
$$w[i, j] = w[i, j - 1] + p_j + q_j \tag{15.15}$$

这样，对 $\Theta(n^2)$ 个 $w[i, j]$ ，每个的计算时间为 $\Theta(1)$ 。

下面的伪码接受概率列表 $p_1, \dots, p_n$ 和 $q_0, \dots, q_n$ 及规模 $n$ 作为输入，返回表 $e$ 和 $root$ 。
```cpp
OPTIMAL-BST(p, q, n)
	let e[1...n+1, 0...n], w[1...n+1, 0...n], and root[1...n, 1...n] be new tables
	for i = 1 to n + 1
		e[i, i - 1] = q[i - 1]
		w[i, i - 1] = q[i - 1]
	for l = 1 to n
		for i = 1 to n - l + 1
			j = i + l - 1
			e[i, j] = INF
			w[i, j] = w[i, j - 1] + p[j] + q[j]
			for r = i to j
				t = e[i, r - 1] + e[r + 1, j] + w[i, j]
				if t < e[i, j]
					e[i, j] = t
					root[i, j] = r
	return e and root
```
 
 

根据前文的描述，以及与（算导15.2节的）算法 `MATRIX-CHAIN-ORDER` 的相似性，很容易理解此算法。
1. 第 $2 \sim 4$ 行的 for 循环初始化 $e[i, i - 1]$ 和 $w[i, i  -1]$ 的值。
2. 第 $5 \sim 14$ 行的 for 循环利用递归式 $(15.14)$ 和递归式 $(15.15)$ ，来对所有 $1 \le i \le j \le  n$ 计算 $e[i, j]$ 和 $w[i, j]$ 。在第一个循环步中 $l = 1$ ，循环对所有 $i = 1, 2, \dots, n$ 计算 $e[i, i]$ 和 $w[i, i]$ 。第二个循环步中 $l = 2$ ，对所有 $i = 1, 2, \dots, n - 1$ 计算 $e[i,i + 1]$ 和 $w[i, i + 1]$ ，依次类推。
3. 第 $10 \sim 14$ 行的内层 for 循环，逐个尝试下标 $r$ ，确定哪个关键字 $k_r$ 作为根结点、可以得到包含关键字 $k_i, \dots, k_j$ 的最优二叉搜索树。这个 for 循环在找到更好的关键字作为根结点时，会将其下标 $r$ 保存在 $root[i, j]$ 中。

图15-10给出了 `OPTIMAL-BST` 输入图15-9中的关键字分布后、计算出的表 $e[i, j],\ w[i, j],\ root[i, j]$ 。与图15-5中矩阵链乘法问题的输出结果一样，本图中的表也进行了旋转，对角线旋转到了水平方向。`OPTIMAL-BST` 按自底向上的顺序逐行计算，在每行中由左至右计算每个表项。
![](https://img-blog.csdnimg.cn/c23c8bf8abae46bbb1a9d00f90abeac5.png)

与 `MATRIX-CHAIN-ORDER` 一样，`OPTIMAL-BST` 的时间复杂度也是 $\Theta(n^3)$ 。由于它包含三重 for 循环，而每层循环的下标最多取 $n$ 个值，因此很容易得出其运行时间为 $O(n^3)$ 。`OPTIMAL-BST` 的循环下标的范围与 `MATRIX-CHAIN-ORDER` 不完全一样，但每个方向最多相差 $1$ 。因此，与 `MATRIX-CHAIN-ORDER` 一样，`OPTIMAL-BST` 的运行时间为 $\Omega(n^3)$（从而得出运行时间为 $\Theta(n^3)$ ）。
