> 参考算导第31章 数论算法
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/3930e2d4e8834e0eb9bfbe3e6b202b6e.png)



@[toc]

# 0. 概述
数论曾经作为一种虽然优美、但没什么用处的纯数学学科。如今，数论算法 `number-theoretic algorithms` 却得到了广泛的使用。这很大程度归功于人们发明了「基于大素数的加密方案」。**这些方案是可行的，因为我们能快速计算大素数** `find large primes easily` ；而且，**这些方案是安全的，因为我们不知道如何高效将合数因子分解为大素数乘积**（或求解相关问题，如计算离散对数）`factor the product of large primes (or solve related problems, such as computing discrete logarithms) efficiently` 。这里介绍一些数论知识、以及相关的算法，它们是上文这类应用的基础。
- （算导31.1节）先介绍数论的一些基本概念，如整除性、同余和唯一因数分解 `divisibility, modular equivalence, and unique factorization` 。
- （算导31.2节）再研究世界上最古老算法之一的欧几里得算法，它用于计算两个整数的最大公约数。
- （算导31.3节）回顾模运算的概念。
- （算导31.4节）研究整数 $a$ 的倍数模 $n$ 所得的结果集合 `the set of multiples of a given number a, modulo n` ，并阐述如何用欧几里得算法求等式 $ax \equiv b\ (\bmod\ n)$ 。
- （算导31.5节）再介绍中国余数定理。
- （算导31.6节）考虑整数 $a$ 的幂模 $n$ `powers of a given number a, modulo n` ，描述反复平方算法 `repeated-squaring algorithm` ，用于在已知 $a, b, n$ 的情况下高效计算 $a^b \bmod n$ 。这一运算是高效素数检测和许多现代密码学内容的核心部分。
- （算导31.7节）描述RSA公钥加密系统。
- （算导31.8节）讨论一种随机性素数测试方法，该测试可用于高效地查找大素数，这正是为RSA加密系统创建密钥所必须的。
- （算导31.9节）回顾一个简单而有效的小整数因数分解启发式算法。**有趣的是，由于RSA的安全性依赖于大整数因子分解的难度，人们恐怕更希望因子分解是一个无多项式解法的难题**。
 
## 输入规模和算术计算的代价
由于我们处理的对象是大整数，我们需要调整「对于输入规模大小和基本算术运算代价的理解」。这里，**一个“大输入”通常指一个包含“大整数”的输入**，而不是包含“很多整数”的输入（像排序问题那样）。因此，我们利用输入所需的**位数** `number of bits` 来度量输入的大小，而不仅仅是输入中整数的数目。给定 $k$ 个整数输入 $a_1, a_2, \dots, a_k$ ，如果算法可以在 $\log a_1, \log a_2, \dots, \log a_k$ 的多项式时间内完成，则该算法称为**多项式时间算法**。也就是说，多项式是基于「二进制编码后的输入长度」`polynomial in the lengths of its binary-encoded inputs` 。

其他时候，将基本算术运算（乘法、除法或者计算余数）视为只耗费单位时间的原语操作是非常方便的。通过计算算法中包含的这类算术运算的数目，我们就有一个基准、用来合理评估算法在计算机上的实际运算时间。然而，**当输入很大时，基本运算也会变得耗时**。因此，用数论算法所需的**位运算** `bit operations` 数目作为基准（来衡量算法的时间代价）将更加方便且合适。在此模型中，将两个 $\beta$ 位整数用常规方法相乘需要 $\Theta(\beta^2)$ 次位运算。同样，用最朴素方法计算一个 $\beta$ 位整数除以另一个较短整数的商或余数，也需要耗时 $\Theta(\beta^2)$（见算导练习31.1-12）。如今，更快的计算方法已经出现。例如，一个简单的分治算法，可以在两个 $\beta$ 位整数相乘的问题上达到 $\Theta(\beta^{\log 3})$ 的运行时间，而已知最快的算法则只需要 $\Theta( \beta \log \beta \log \log \beta)$ 的运行时间。然而在实际问题中，$\Theta(\beta^2)$ 的算法往往效果最好，我们也将以该界作为算法分析的基准。

**我们将既使用「算法所需的算术运算的数目」，也使用「其所需位运算的数目」来分析算法**。

---
# 1. 基础数论概念
本节将简单回顾，基础数论中关于整数集 $\Z = \{ \dots, -2, -1, 0, 1, 2, \dots \}$ 和自然数集 $\N = \{ 0, 1, 2, \dots \}$ 的一些概念。

## 1.1 整除性和约数
<font color="red">**一个整数可以被另外一个整数整除 `divisible` ，是数论中的一个关键概念**。</font>

==若存在某个整数 $k$ ，使得 $a = kd$ ，则称 $d$ **整除** $a$==（读作 `d divides a` ），写成 $d \mid a$（也有 $k \mid a$ ）。==如果不存在这样的整数 $k$ ，则称 $d$ 不能整除 $a$ ，写成 $d \not { \mid}\ a$== 。==如果 $d \mid a$ ，则称 $a$ 是 $d$ 的**倍数**== `multiple` 。==如果 $d \mid a$ 且 $d \ge 0$ ，则称 $d$ 是 $a$ 的**约数**== `divisor` 。

注意，$d\mid a$ 当且仅当 $-d \mid a$ ，即 $a$ 的任何约数的负数同样可以整除 $a$ 。因此不失一般性，可定义**约数为非负数**。==非零整数 $a$ 的约数应至少为 $1$ ，且不会大于 $|a|$== 。例如，$24$ 的约数是 $1, 2, 3, 4, 6, 8, 12, 24$ 。任何（正）整数 $a$ 均可被**平凡约数** `trivial divisors` ——$1$ 和其自身 $a$ 所整除。==整数 $a$ 的非平凡约数称为 $a$ 的**因子**== `factors` 。例如，$20$ 的因子是 $2, 4, 5, 10$ 。

我们不难发现（无意义！），任何整数（包括 $0$ 本身）均可整除 $0$（因为对任何整数 $d$ 都有 $0 = 0 \times d$ ）。而且，如果 $a > 0$ 且 $d \mid a$ ，那么 $|d | \le |a|$（实际上 $a <0$ 且 $d \mid a$ 时也成立）。

## 1.2 素数和合数
==如果一个整数 $a > 1$ 、且只能被平凡约数（$1$ 和它自身）所整除，则这个数是**素数**== `prime number` 。<font color="red">**素数有许多特殊的性质，它在数论中也扮演着十分重要的角色**</font>。前 $20$ 个素数按序排列如下（算导31.1-2要求证明**存在无穷多个素数**）：$$2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\\ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71$$
==如果一个整数 $a > 1$ 且不是素数，则称之为**合数**== `composite number` 。例如，$39$ 是一个合数，因为 $3 \mid 39$ 。称整数 $1$ 为**基本单位** `unit` ，并且**它既不是素数也不是合数**。同样，**整数 $0$ 和所有负整数既不是素数也不是合数** `the integer 0 and all negative integers are
neither prime nor composite` 。 
## 1.3 除法定理、余数和等模
给定一个整数 $n$ ，我们可以把**整数集**划分为 $n$ 的倍数和非 $n$ 倍数两部分。==通过计算非 $n$ 倍数除以 $n$ 的余数，可以对非 $n$ 倍数进行有效分类，许多数论理论正是基于改进这种划分==（来改进对 $n$ 的倍数和非 $n$ 倍数的划分？）`Much number theory is based upon refining this partition` 。下面的定理给出该改进的理论基础。这里忽略了其证明（参见算导 *Niven* 和 *Zuckerman* 的证明）。

**定理31.1**（**除法定理** `Division theorem` ）对于任何整数 $a$ 和任何正整数 $n$ ，存在**唯一整数** `unique integers` $q$ 和 $r$ ，满足 $0 \le r < n$ 且 $a = nq + r$ 。

称正整数 $n$ 为**模数** `modulo` ，值 $q = \lfloor a / n \rfloor$ 为除法的**商** `quotient` ，值 $r = a \bmod n$ 为除法的**余数** `remainder or residue`（限定 $n$ 为正整数且 $0 \le r < n$ 时 $q, r$ 是唯一的）。 $n \mid a$ 当且仅当 $a \bmod n = 0$ 。根据整数模 $n$ 的余数（因为是唯一的！），我们可以将所有整数划分为 $n$ 个**等价类** `equivalence class` 。包括整数 $a$ 的**模 $n$ 等价类**为：$$[a]_n = \{ a + k n  \mid k \in \Z\}$$

例如，$[3]_7 = \{ \dots, -11, -4, 3, 10, 17, \dots \}$ ，这个集合同时也可以表示为 $[-4]_7, [10]_7$ 。

==$a \in [b]_n$ 和 $a \equiv b\ (\bmod\ n)$ 是等价的==。所有这类等价类的集合是：
$$\Z_n = \{ [a]_n \mid 0 \le a \le n - 1\} \tag{31.1}$$ 当看到 $$\Z_n = \{ 0, 1, 2, \dots, n - 1\} \tag{31.2}$$ 这个定义时，按照式 $(31.1)$ 理解即可：$0$ 代表 $[0]_n$ ，$1$ 代表 $[1]_n$ 等等，即用每个等价类最小的非负元素来表示等价类。然而，我们应该记住相应的等价类。例如，在说 $-1$ 是 $\Z_n$ 的一个元素时，实际上指的是 $[n - 1]_n$ ，因为 $-1 \equiv n - 1\ (\bmod \ n)$ 。

## 1.4 公约数和最大公约数
**如果 $d$ 是 $a$ 的约数并且 $d$ 也是 $b$ 的约数，则 $d$ 是 $a$ 与 $b$ 的公约数**（为非负整数）。例如，$30$ 的约数包括 $1, 2, 3, 5, 6, 10, 15, 30$ ，因此 $24$ 与 $30$ 的公约数为 $1, 2, 3, 6$ 。需要注意的是，**$1$ 是任意两个整数的公约数**。

**公约数的一条重要性质**是：$$d \mid a 且 d \mid b蕴含着 d \mid (a + b) 且 d \mid (a - b) \tag{31.3}$$

更一般地，对任意整数 $x, y$ 有：$$d \mid a 且 d \mid b 蕴含着 d \mid (ax + by) \tag{31.4}$$

并且，如果 $a \mid b$ ，那么 $|a | \le |b|$ 或者 $b = 0$ ，而这说明：$$a \mid b 且 b \mid a 蕴含着 a = \pm b \tag{31.5}$$

==两个不同时为 $0$ 的整数 $a$ 与 $b$ 的公约数中最大的，称为**最大公约数** `greatest common divisor` ，记为 $gcd(a, b)$== 。例如，$gcd(24, 30) = 6,\ gcd(5, 7) = 1,\ gcd(0, 9) = 9$ 。如果 $a$ 与 $b$ 不同时为 $0$ ，则 $gcd(a, b)$ 是一个在 $1$ 与 $\min (|a| , |b|)$ 之间的整数。==定义 $gcd(0, 0) = 0$ ，该定义是使 $gcd$ 函数的基本性质（如下面的等式 $(31.9)$ ）普遍成立必不可少的==。

下列性质是 $gcd$ 函数的基本性质：$$\begin{aligned} 
&gcd(a, b) = gcd(b, a) \qquad  \qquad\qquad  \qquad     &(31.6) \\
&gcd(a, b) = gcd(-a, b)  \qquad  \qquad\qquad  \qquad     &(31.7) \\
&gcd(a, b) = gcd(|a|, |b|) \qquad  \qquad\qquad  \qquad     &(31.8) \\
&gcd(a, 0) = |a| \qquad  \qquad\qquad  \qquad     &(31.9) \\
&gcd(a, ka) = |a| \ 对任意k \in \Z \qquad  \qquad\qquad  \qquad     &(31.10) \\
\end{aligned}$$

下面的定理给出了 $gcd(a, b)$ 的另外一个有用特征。

**定理31.2** 如果任意整数 $a, b$ 不都为 $0$ ，则 $gcd(a, b)$ 是 $a, b$ 的线性组合集 $\{ ax + by \mid x, y \in \Z\}$ 中的最小正元素。
**证明**：设 $s$ 是 $a, b$ 的线性组合集中的最小正元素，并且对某个 $x, y \in \Z$ ，有 $s = ax+by$ 。设 $q = \lfloor a / s \rfloor$ ，则式 $(3.8)$ 说明：$$a \bmod s = a - qs = a - q(ax + by) = a(1 - qx) + b(-qy)$$  因此，$a\bmod s$ 也是 $a, b$ 的一个线性组合。但由于 $0 \le a \bmod s < s$ ，我们可得 $a \bmod s = 0$ ，因为 $s$ 是这个线性组合中的最小正数。因此有 $s \mid a$ 。类似地，可得到 $s \mid b$ 。因此，$s$ 是 $a, b$ 的公约数，所以 $gcd(a, b) \ge s$ 。

因为 $gcd(a, b)$ 能同时整除 $a$ 和 $b$ ，并且 $s$ 是 $a$ 与 $b$ 的一个线性组合，所以由式 $(31.4)$ 可知 $gcd(a, b) \mid s$ 。但由于 $gcd(a, b) \mid s$ 和 $s > 0$ ，因此 $gcd(a, b) \le s$ 。

将上面已证明的 $gcd(a, b) \ge s$ 与 $gcd(a, b) \le s$ 结合起来，得到 $gcd(a, b) = s$ ，因此证明了 $s$ 是 $a$ 与 $b$ 的最大公约数。 $\blacksquare$

**推论31.3** 对任意整数 $a, b$ ，如果 $d \mid a$ 且 $d\mid b$ ，则 $d \mid gcd(a, b)$ 。
**证明**：根据定理31.2，$gcd(a, b)$ 是 $a$ 与 $b$ 的一个线性组合（考虑长为 $a$ 、宽为 $b$ 的一块木板？），所以由式 $(31.4)$ 可知，该推论成立。$\blacksquare$

**推论31.4** 对所有整数 $a, b$ 以及任意非负整数 $n$ ，有：$$gcd(an, bn) = n\times gcd(a, b)$$
**证明**：如果 $n = 0$ ，该推论显然成立。如果 $n > 0$ ，则 $gcd(an, bn)$ 是集合 $\{ anx +bny \mid x , y \in \Z\}$ 的最小正元素，即集合 $\{ ax + by\mid x, y\in \Z \}$ 中最小正元素（即 $gcd(a, b)$ ）的 $n$ 倍 。 $\blacksquare$

**推论31.5** 对于任意正整数 $n, a, b$ ，如果 $n \mid ab$ 且 $gcd(a, n) = 1$ ，则 $n \mid b$ 。
**证明**：证明过程见练习31.1-5。$\blacksquare$ 


## 1.5 互质数
==如果两个整数 $a, b$ 只有公约数 $1$ ，即 $gcd(a, b) = 1$ ，则 $a, b$ 称为**互质数**== `relatively prime` 。例如，$8, 15$ 是互质数，因为 $8$ 的约数为 $1, 2, 4, 8$ 、而 $15$ 的约数为 $1, 3, 5, 15$ 。下面的定理说明，**如果两个整数分别与一个整数 $p$ 为互质数，则其积与 $p$ 互质**。

**定理31.6** 对任意整数 $a, b, p$ ，如果 $gcd(a, p) = 1$ 且 $gcd(b, p) = 1$ ，则 $gcd(ab, p) = 1$ 。
**证明**：由**定理31.2**可知，存在整数 $x, y, x', y'$ 满足：$$ax + py = 1 \\ bx' + py' = 1$$ 把上面两个等式两边分别相乘，经过整理得 $$ab(xx') + p( ybx' + y'ax + pyy') = 1$$ 因为 $1$ 是 $ab$ 与 $p$ 的一个正线性组合，所以应用**定理31.2**就可以证明结论。$\blacksquare$ 

==对于整数 $n_1, n_2, \dots, n_k$ ，如果对任何 $i \ne j$ 都有 $gcd(n_i, n_j ) = 1$ ，则称整数 $n_1, n_2, \dots, n_k$ **两两互质**== `pairwise relatively prime` 。

## 1.6 唯一因子分解定理
下面的结论说明了，关于素数整除性 `divisibility by primes` 的一个基本而重要的事实。

**定理31.7** 对所有素数 $p$ 和所有整数 $a, b$ ，如果 $p \mid ab$ ，则 $p \mid a$ 或 $p \mid b$（或两者都成立）。
**证明** 采用反证法，假设 $p \mid ab$ ，但 $p\not { \mid }\ a$ 并且 $p \not{\mid}\ \ b$ 。因此 $gcd(a, p) = 1$ 且 $gcd(b, p)= 1$ 。这是因为 $p$ 的约数只有 $1, p$ ，又因为假设 $a, b$ 都不能被 $p$ 整除（即 $p$ 不是 $a, b$ 的约数）。由**定理31.6**可知，$gcd(ab, p) =1$ ；由假设 $p \mid ab$（且 $p$ 为素数）可知 $gcd(ab, p) = p$ ，于是产生矛盾，从而证明定理成立。

==从**定理31.7**可知，任意一个合数的**素因数分解式是唯一的**==。例如，数 $6000$ 可以唯一分解为 $2^4 \cdot 3 \cdot 5^3$ 。

**定理31.8**（**唯一因子分解定理** `Unique factorization` ）合数 $a$ 仅能以一种方式写成如下乘积形式：$$a = p_1^{e_1} p_2^{e_2} \dots p_r^{e_r}$$ 其中 $p_i$ 为**素数**，$p_1 < p_2 < \dots < p_r$ ，且 $e_i$ 为正整数。
**证明**：过程见（算导练习31.1-11）。

---
# 2. 最大公约数
在本节中，我们将描述高效计算「两个整数最大公约数」的欧几里得算法。在对其运行时间进行分析的过程中，我们将发现它与斐波那契数存在着惊人联系，由此产生欧几里得算法最坏情况下的输入。==本节中，我们仅对非负整数进行讨论。由式 $(31.8)\ \ gcd(a, b) = gcd(|a| , |b|)$ 可知， 这一限制是有道理的==。

原则上讲，可以根据 $a, b$ 的素因子分解，求出正整数 $a$ 和 $b$ 的最大公约数 $gcd(a, b)$ 。的确，如果 $$a = p_1^{e_1} p_2 ^{e_2} \dots p_r ^{e_r} \tag{31.11}$$ $$b = p_1^{f_2} p_2^{f_2} \dots p_r^{f_r} \tag{31.12}$$ **其中使用了零指数，从而使得素数集合 $p_1, p_2, \dots, p_r$ 对于 $a, b$ 相同**。正如（算导练习31.2-1要求）证明的，$$gcd(a, b) = p_1^{\min(e_1, f_1) }  p_2 ^{\min(e_2, f_2) } \cdots p_r^{\min(e_r, f_r)} \tag{31.13}$$ 在（算导31.9节）说明，目前已知的最好的因子分解算法，也不能达到多项式运行时间（存在量子计算机的因子分解算法 `Shor's Algorithm` ）。因此，利用这种方法来计算最大公约数，不大可能获得高效率。

计算最大公约数的欧几里得算法，基于如下定理。

**定理31.9**（**GCD递归定理** `GCD recursion theorem` ）对任意非负整数 $a$ 和任意正整数 $b$ ：$$gcd(a, b) = gcd(b, a \bmod b)$$
**证明**：下面将证明 $gcd(a, b)$ 与 $gcd(b, a\bmod b)$ 可以互相整除，这样由等式 $(31.5)$ 可知，它们一定相等（因为它们都是非负整数）。
- 首先证明 $gcd(a, b) \mid gcd(b, a\bmod b)$ 。如果设 $d = gcd(a, b)$ ，那么 $d \mid a$ 且 $d \mid b$ 。由等式 $(3.8)$ 可知，==$(a \bmod b) = a - qb$ ，其中 $q = \lfloor a / b \rfloor$ 。因为 $a\bmod b$ 是 $a$ 与 $b$ 的线性组合，所以由等式 $(31.4)$ 可得 $d \mid (a \bmod b)$== 。因此，==由于 $d \mid b$ 且 $d \mid (a \bmod b)$ ，由**推论31.3**可知 $d \mid gcd(b, a\bmod b)$== ，或者有等价结论：$$gcd(a, b) \mid gcd(b, a\bmod b) \tag{31.14}$$
- 证明 $gcd(b, a\bmod b) \mid gcd(a, b)$ 的过程几乎与上述过程相同。如果设 $d = gcd(b, a\bmod b)$ ，则 $d \mid b$ 且 $d \mid (a \bmod b)$ 。==由于 $a = qb + (a \bmod b)$ ，其中 $q = \lfloor a / b \rfloor$ ，所以 $a$ 是 $b$ 和 $(a \bmod b)$ 的一个线性组合，所以由等式 $(31.4)$ 可得 $d \mid a$== 。因此，==由于 $d \mid b$ 且 $d \mid a$ ， 由**推论31.3**可知 $d \mid gcd(a, b)$== ，或者有等价结论：$$gcd(b, a \bmod b) \mid gcd(a, b) \tag{31.15}$$ 
- 运用式 $(31.5)$ ，再根据式 $(31.14)$ 与式 $(31.15)$ ，就可以完成对本定理的证明。$\blacksquare$ 

## 2.1 欧几里得算法
欧几里得（公元前300年）的几何原本描述了下列 $gcd$ 算法，实际上这一算法出现的时间可能还要早些。我们将其描述为一个由**定理31.9**直接得到的递归程序，其输入 $a, b$ 都是任意非负整数。
```cpp
EUCLID(A, B)
	if b == 0
		return a
	else return EUCLID(b, a mod b)
```
下面举例说明 `EUCLID` 的运行过程。考虑 $gcd(30, 21)$ 的计算过程：`EUCLID(30, 21) = EUCLID(21, 9) = EUCLID(9, 3)= EUCLID(3, 0) = 3` 。该计算过程三次递归调用了 `EUCLID` 。

过程 `EUCLID` 的正确性，可以从**定理31.9**以及下列性质推出：如果算法在第二行返回 $a$ ，则 $b = 0$ 。因此由式 $(31.9)$ 可知，$gcd(a, b) = gcd(a, 0) = a$ 。因为在递归调用的过程中，第二个参数的值单调递减且始终非负，所以算法不可能无限递归下去。因此，`EUCLID` 总能终止、并求出正确答案。

## 2.2 欧几里得算法的运行时间
下面分析 `EUCLID` 算法在最坏情况下的运行时间，我们把它看成是「输入 $a, b$ 的大小的函数」。不失一般性，设 $a > b \ge 0$ 。为了**确定这个假设的合理性**，注意如果 $b > a \ge 0$ ，则 `EUCLID(a, b)` 会立即递归调用 `EUCLID(b, a)` ，即如果第一个自变量小于第二个自变量，则 `EUCLID` 进行一次递归调用以交换两个自变量、然后继续执行。类似地，如果 $b = a > 0$ ，则过程在进行一次递归调用后就终止执行，因为 $a \bmod b = 0$ 。

过程 `EUCLID`  的运行时间与其递归调用的次数成正比。在我们的分析过程中，利用了由递归式 $(3.22)$ 定义的斐波那契数 $F_k$ 。

**引理31.10** 如果 $a > b \ge 1$ 并且 `EUCLID(a, b)` 执行了 $k \ge 1$ 次递归调用，则 $a \ge F_{k+2}, b \ge F_{k+1}$ 。
**证明**：通过对 $k$ 进行归纳来证明引理。作为归纳的基础，设 $k = 1$ ，则 $b \ge 1 = F_2$ 。又由于 $a > b$ ，必有 $a \ge 2 = F_3$ 。因为 $b > (a \bmod b)$ ，即在每次调用中，第一个变量严格大于第二个变量，因此对每次递归调用，假设 $a > b$ 成立。

假设执行 $k - 1$ 次递归调用时引理成立。下面将证明若执行 $k$ 次递归调用，引理同样成立。因为 $k > 0$ ，且我们有 $b > 0$ ，并且 `EUCLID(a, b)` 递归调用 `EUCLID(b, a mod b)` ，该函数（指 `EUCLID(b, a mod b)`）依次进行了 $k - 1$ 次递归调用。归纳假设蕴含 $b \ge F_{k+1}$（因此也就证明了引理的一部分），且 $a \bmod b \ge F_k$ 。我们有：$$b + (a \bmod b)= b+(a - b\lfloor a / b \rfloor) \le a$$ 因为 $a > b > 0$ 蕴含 $\lfloor a / b\rfloor \ge 1$ 。所以 $a \ge b + (a \bmod b) \ge F_{k+1} +F_k = F_{k+2}$ 。$\blacksquare$ 

下面的定理是这个引理的一个直接推论（逆否命题？）。

**定理31.11**（**$Lam\acute{e}$ 定理**）对任意整数 $k \ge 1$ ，如果 $a > b \ge 1$ 且 $b < F_{k +1}$ ，则 `EUCLID(a, b)` 的递归调用次数少于 $k$ 次。
**证明**：欲证明定理31.11中的上界是最优的，通过证明当 $k \ge 2$ 时，<code>EUCLID(F<sub>k+1</sub>, F<sub>k</sub>)</code> 恰好进行了 $k - 1$ 次递归调用（？）。我们在 $k$ 上使用归纳法。
- 对于 $k = 2$ 的基本情况，<code>EUCLID(F<sub>3</sub>, F<sub>2</sub>)</code> 恰好进行 $1$ 次调用，变为 `EUCLID(1, 0)`（我们必须从 $k = 2$ 开始，因为 $k = 1$ 时没有 $b = F_1 < F_2$ ）。
- 对于归纳步骤，假设 <code>EUCLID(F<sub>k</sub>, F<sub>k-1</sub>)</code> 恰好进行 $k - 2$ 次调用。因为 $k > 2$ ，我们有 $F_k > F_{k - 1} > 0$ 且 $F_{k+1} = F_k + F_{k-1}$ ，又由（算导练习31.1-1）有 $F_{k+1} \bmod F_k = F_{k - 1}$ 。于是有：$$gcd(F_{k+1}, F_k) = gcd(F_k, F_{k+1} \bmod F_k) = gcd(F_k, F_{k-1})$$
因此，<code>EUCLID(F<sub>k+1</sub>, F<sub>k</sub>)</code> 的调用次数恰好比 <code>EUCLID(F<sub>k</sub>, F<sub>k-1</sub>)</code> 多一次，即恰好 $k - 1$ 次，从而达到定理31.11中的上界。

由于 $F_k$ 约为 $\phi^k / \sqrt{5}$ ，其中 $\phi$ 是由式 $(3.24)$ 定义的黄金分割率 $\dfrac{1 +\sqrt{5}} {2}$ ，所以 `EUCLID` 执行中递归调用的次数为 $O(\log b)$（更紧的界见练习31.2-5）。因此，如果过程 `EUCLID` 作用于两个 $\beta$ 位数，则它将执行 $O(\beta)$ 次算术运算和 $O(\beta^3)$ 次位操作（假设 $\beta$ 位数的乘法和除法运算要执行 $O(\beta^2)$ 次位操作）。（算导思考题31-2要求证明位操作次数的界为 $O(\beta^2)$ ）。

## 欧几里得算法的扩展形式
现在重写欧几里得算法、以计算出额外的有用信息。特别地，我们推广该算法用于计算出满足下列条件的**整系数** $x, y$ ：$$d = gcd(a, b) = ax+by \tag{31.16}$$

注意：$x, y$ 可能为 $0$ 或负数。我们将会发现这些系数对计算**模乘法的逆** `modular multiplicative inverses` 是非常有用的。过程 `EXTENDED-EUCLID` 的输入为一对非负整数，其返回一个满足式 $(31.16)$ 的三元组 $(d, x, y)$ 。
```cpp
EXTENDED-EUCLID(a, b)
	if b == 0
		return (a, 1, 0)
	else (d', x', y') = EXTENDED-EUCLID(b, a mod b)
		(d, x, y) = (d', y', x' - ⌊a / b⌋ * y')
		return (d, x, y)
```
图31.1演示了用 `EXTENDED-EUCLID` 计算 `gcd(99, 78)` 的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/02d15eca9cf342c8a10b354030456dbf.png)
过程 `EXTENDED-EUCLID` 是过程 `EUCLID` 的一个变形。第一行等价于 `EUCLID` 第一行中的测试 `b == 0` 。如果 $b = 0$ ，则 `EXTENDED-EUCLID` 不仅==返回第二行中的 $d = a$ ，而且返回系数 $x = 1, y = 0$ ，使得 $a = ax + by$== 。如果 $b \ne 0$ ，则 `EXTENDED-EUCLID` 首先计算出满足 $d' = gcd(b, a\bmod b)$ 和满足 $$d' = bx' + (a \bmod b) y' \tag{31.17}$$ 的 $(d', x', y')$ 。对过程 `EUCLID` 来说，==在这种情况下，有 $d = gcd(a, b) = d' = gcd(b, a\bmod d)$== 。为了得到满足 $d = ax + by$ 的 $x, y$ ，==利用等式 $d = d'$ 和式 $(3.8)$ 来改写式 $(31.17)$== ：$$d = bx' + (a - b \lfloor a / b \rfloor ) y' = ay' + b(x' - \lfloor a / b\rfloor y')$$ 因此，==当选择 $x = y'$ 和 $y = x' - \lfloor a / b\rfloor y'$ 时，就可满足等式 $d = ax + by$== ，从而证明了过程 `EXTENDED-EUCLID` 的正确性。

由于在 `EUCLID` 中所执行的递归调用次数，与 `EXTENDED-EUCLID` 中所执行的递归调用次数相等，因此 `EUCLID` 与 `EXTENDED-EUCLID` 的运行时间相同，两者相差不超过一个常数因子，即对 $a > b > 0$ ，递归调用的次数为 $O(\log b)$ 。

---
# 3. 模运算
非正式地，我们可以把模运算 `modular arithmetic` 与通常的整数算术运算一样看待，如果执行模 $n$ 运算，则每个结果值 $x$ 都由集合 $\{ 0, 1, \dots, n - 1\}$ 中的某个元素 $a$ 所取代，该元素在模 $n$ 的意义下与 $x$ 等价（即用 $a = x \bmod n$ 取代 $x$ ，即 $a \in [x]_n$ 或写成 $a \equiv x\ (\bmod\ n)$ ） 。如果仅限于运用加法、减法和乘法运算，则用这样的非正式模型就足够了。**一个更为形式化的模运算模型，最适合于用群论结构来进行描述**。

## 3.1 有限群
==**群** `group` $(S, \oplus)$ 是一个集合 $S$ 和定义在 $S$ 上的二元运算 $\oplus$== ，该运算满足下列性质：
1. **封闭性** `Closure` ：对所有 $a, b \in S$ ，有 $a \oplus b \in S$ 。
2. **单位元** `Identity` ：存在一个元素 $e \in S$ ，称为群的**单位元** `identity` ，满足对所有 $a \in S$ ，有 $e \oplus a = a \oplus e = a$ 。
3. **结合律** `Associativity` ：对所有 $a, b,c \in S$ ，有 $(a \oplus b) \oplus c = a \oplus (b \oplus c)$ 。
4. **逆元** `Inverses` ：对每个 $a \in S$ ，存在唯一的元素 $b \in S$ ，称为 $a$ 的**逆元** `inverse` ，满足 $a \oplus b = b \oplus a = e$ 。

例如，考察一个熟知的、在加法运算下整数 $\Z$ 所构成的群 $(\Z, +)$ ：$0$ 是单位元，$a$ 的逆元为 $-a$ 。==如果群 $(S, \oplus)$ 满足**交换律** `commutative law` ，即对所有 $a, b \in S$ 、有 $a \oplus b = b \oplus a$ ，则它是一个**交换群/阿贝尔群**== `abelian group` 。显然，$(\Z, +)$ 是一个交换群。==如果群 $(S, \oplus )$ 满足 $|S| < \infin$ ，则它是一个**有限群**== `finite group` 。

## 3.2 由模加法和模乘法所定义的群
通过使用模 $n$ 加法和模 $n$ 乘法运算，可以形成两个有限交换群，其中 $n$ 是正整数。这些群基于（算导31.1节中定义的）整数模 $n$ 所形成的等价类。

为了定义一个在 $\Z_n = \{ [a]_n \mid 0 \le a \le n - 1\}$ 上的群，我们需要有合适的二元运算，该运算可以通过重新定义普通的加法和乘法运算得到。==我们能轻松地定义 $\Z_n$ 上的加法和乘法运算，因为两个整数的等价类唯一地决定了它们和或积的等价类== `the equivalence class of two integers uniquely determines the equivalence class of their sum or product` 。也就是说，如果 $a \equiv a'\ (\bmod\ n)$ 且 $b \equiv b'\ (\bmod\ n)$ ，那么：$$a + b \equiv a' + b'\ (\bmod\ n) \\ ab \equiv a'b'\ (\bmod\ n)$$ 因此，定义模 $n$ 加法和模 $n$ 乘法如下（分别用 $+_n, \cdot_n$ 表示）：$$[a]_n +_n [b]_n = [a+b]_n  \\ [a]_n \cdot_n [b]_n = [ab]_n \tag{31.18}$$ 我们能类似定义 $\Z_n$ 上的减法为 $[a]_n -_{n} [b]_n = [a-b]_n$ ，但下面将会看到，除法的定义更加复杂。

这些事实说明，==当在 $\Z_n$ 中进行计算时，「使用每个等价类的最小非负元素」作为其代表，这种方法具有一般性和便捷性==。我们对这些代表元素像平常那样执行加法、减法与乘法，但每个结果 $x$ 都由其所对应类的代表元素代替（即用 $x \bmod n$ 来代替）。

### 3.2.1 模 $n$ 加法群

运用该模 $n$ 加法的定义，定义**模 $n$ 加法群** `additive group modulo n` $(\Z_n, +_n)$ ，它的大小规模为 $|\Z_n| = n$ 。图31-2(a)给出了群 $(\Z_6, +_6)$ 的运算表。
![在这里插入图片描述](https://img-blog.csdnimg.cn/0d714dc76d4c40199386574b94754f7c.png)
**定理31.12** 系统 $(\Z_n, +_n)$ 是一个有限交换群。
**证明**：式 $(31.18)$ 表明 $(\Z_n, +_n)$ 是封闭的。由 $+$ 满足交换律和结合律，可以推出 $+_n$ 满足交换律和结合律：
$$\begin{aligned}( [a]_n +_n [b]_n) +_n [c]_n &= [a + b]_n +_n [c]_n \quad& 式(31.18) \\
 &= [(a + b) + c]_n  \quad& 式(31.18) \\
 &= [a + (b+c)]_n \quad& 加法结合律 \\
 &= [a]_n +_n [b + c]_n  \quad& 式(31.18) \\
 &= [a]_n +_n ( [b]_n +_n [c]_n)  \quad& 式(31.18)  \\
 [a]_n +_n [b]_n &= [a + b]_n \quad& 式(31.18) \\
 &= [b+a]_n \quad& 加法交换律 \\
 &= [b]_n +_n [a]_n  \quad& 式(31.18)
 \end{aligned}$$ $(\Z_n, +_n)$ 的单位元是 $0$（即 $[0]_n$ ）。元素 $a$（即 $[a]_n$ ）的（加法）逆元是元素 $-a$（即 $[-a]_n$ 或 $[n - a]_n$ ），因为 $[a]_n +_n [-a]_n = [a - a]_n = [0]_n$ 。$\blacksquare$

### 3.2.2 模 $n$ 乘法群
运用模 $n$ 乘法的定义，我们定义**模 $n$ 乘法群** `multiplicative group modulo n` $(\Z^*_n, \cdot_n)$ 。==该群中的元素是「 $\Z_n$ 中与 $n$ 互质的元素」组成的集合 $\Z^*_n$== ：$$\Z^*_n = \{ [a]_n \in \Z_n \mid gcd(a, n)= 1\}$$ 为了表明 $\Z^*_n$ 是良定义的，注意到，对 $0 \le a < n$ 以及所有整数 $k$ ，有 $a \equiv (a + kn) \pmod n$（即 $a \in [a]_n$ ）。因此根据（算导练习31.2-3），$gcd(a, n) = 1$ 蕴含着对所有整数 $k$ 、$gcd(a+kn, n)= 1$ 。因为 $[a]_n = \{a + kn \mid k \in \Z\}$ ，所以集合 $\Z_n^*$ 是良定义的（？），下面是这种群的一个例子：
$$\Z^*_{15} = \{ 1, 2,4 , 7, 8, 11, 13, 14\}$$

其中定义在群上的运算是模 $15$ 乘法运算（这里把元素 $[a]_{15}$ 表示为 $a$ ，例如把 $[7]_{15}$ 表示为 $7$ ）。图31-2(b)显示了群 $(\Z^*_{15}, \cdot_{15})$ 。例如，在 $\Z^*_{15}$ 中，$8 \cdot 11 \equiv 13 \pmod {15}$ 。该群的单位元为 $1$ 。 

**定理31.13** 系统 $(\Z_n^*, \cdot_n)$ 是一个有限交换群。
**证明** **定理31.6**说明 $(\Z^*_n, \cdot_n)$ 是封闭的。和**定理31.12**证明过程中对 $+_n$ 证明类似，可以证明 $\cdot_n$ 也满足交换律和结合律。其单位元是 $[1]_n$ 。为了证明逆元的存在，设 $a$ 是 $\Z^*_n$ 中的一个元素（ $a$ 与 $n$ 互质），并设 $(d, x, y)$ 为 `EXTENDED-EUCLID(a, n)` 的输出结果，则 $d = 1$ ，因为 $a \in \Z^*_n$ ，而且：$$ax+ny = 1 \tag{31.19}$$ 或者等价地，$$ax \equiv 1 \pmod n$$ 即 $$[a]_n \cdot_n [x]_n = [ax]_n = [1]_n$$

因此 ==$[x]_n$ 是 $[a]_n$ 对模 $n$ 乘法的逆元==。进一步，我们==断言 $[x]_n \in \Z^*_n$ ，因为等式 $(31.19)$ 说明了 $x$ 和 $n$ 的最小正线性组合必然是 $1$ 。因此，由**定理31.2**推出 $gcd(x, n)= 1$== 。关于逆元的唯一性证明留作（推论31.26）。$\blacksquare$

作为计算乘法逆元的一个例子，假设 $a = 5, n = 11$ ，则 `EXTENDED-EUCLID(a, n)` 返回 $(d, x, y) = (1, -2, 1)$ —— `EXTENDED-EUCLID(5, 11) -> EXTENDED-EUCLID(11, 5) -> EXTENDED-EUCLID(5, 1) -> EXTENDED-EUCLID(1, 0) -> (1, 1, 0) -> (1, 0, 1) -> (1, 1, -2) -> (1, -2, 1)` 。于是 $1 = 5 \cdot (-2) + 11 \cdot 1$ 。因此 $[-2]_{11}$（即 $[9]_{11}$ ）是 $[5]_{11}$ 的乘法逆元。

当遇到群 $(\Z_n, +_n)$ 和 $(\Z^*_n, \cdot_n)$ 时，我们遵循这一便利的实践——使用代表元素来表示它们的等价类，并分别用通常的运算记号 $+$ 和 $\cdot$（或 `juxtaposition` ，故 $ab = a\cdot b$ ）来表示运算 $+_n$ 和 $\cdot_n$ 。此外，模 $n$ 等价也可以用 $\Z_n$ 中的等式说明，例如下面两种表示等价：$$ax \equiv b \pmod n \\ [a]_n \cdot_n [x]_n = [b]_n$$  为了方便表示，当从上下文能看出所采用的运算时，有时仅用 $S$ 来表示群 $(S, \oplus)$ 。因此可以用 $\Z_n, \Z_n^*$ 来分别表示群 $(\Z_n, +_n)$ 和 $(\Z_n^*, \cdot_n)$ 。

==一个元素 $a$ 的（乘法）逆元表示为 $(a^{-1} \bmod n)$== 。==$\Z_n^*$ 中的除法由等式 $a / b \equiv a b^{-1} \pmod n$ 定义==。例如，在 $\Z^*_{15}$ 中，有 $7^{-1} \equiv 13 \pmod {15}$ ，因为 $7 \cdot 13 = 91 \equiv 1 \pmod {15}$ 。这样就有 $4 / 7  \equiv 4 \cdot 13 \equiv 7 \pmod {15}$ 。

$\Z^*_n$ 的规模表示为 $\phi(n)$ ，这个函数称为**欧拉 $phi$ 函数** `Euler's phi function` ，满足下式：$$\phi(n) = n \prod_{\mathrm{p\ : \  p\ is\ prime\ and\ p \mid n} } \bigg(1 - \dfrac{1}{p} \bigg) \tag{31.20}$$ 其中 $p$ 遍历 `runs over` 所有的能整除 $n$ 的素数（如果 $n$ 为素数，则也包括 $n$ 本身）。在此不对此公式做出证明。==从直观上看，开始时有一张 $n$ 个余数组成的表 $\{ 0, 1, \dots, n - 1\}$ ，然后对于每个能整除 $n$ 的素数 $p$ ，在表中划掉所有 $p$ 的倍数==。例如，由于 $45$ 的素约数为 $3, 5$ ，所以：
$$\phi(45) = 45\bigg( 1- \dfrac{1}{3} \bigg) \bigg( 1 - \dfrac{1}{5} \bigg) = 45 \cdot \dfrac{2}{3} \cdot \dfrac{4}{5} = 24$$ 如果 $p$ 是素数，则 $\Z^*_p = \{ 1, 2, \dots, p - 1\}$ ，并且：$$\phi(p) = p( 1- \dfrac{1}{p}) = p - 1 \tag{31.21}$$

如果 $n$ 是合数，则 $\phi(n) < n - 1$ ，尽管它可以表示为：$$\phi(n) > \dfrac{n}{ e^{\gamma} \ln \ln n +\dfrac{3}{\ln \ln n}} \tag{31.22}$$ 其中 $n \ge 3$ ，此时 $\gamma = 0.577 215 664 9 \dots$ 是**欧拉常数** `Euler's constant` 。当 $n> 5$ 时，一个更简单（也更松弛）的下界是：$$\phi(n) > \dfrac{n}{ 6 \ln \ln n } \tag{31.23}$$ 式 $(31.22)$ 中的下界事实上是最好的，因为：$$\lim_{n \to \infin} \mathrm{ inf} \dfrac{ \phi(n)}{ n / \ln \ln n} = e^{ - \gamma} \tag{31.24}$$
## 3.3 子群
==如果 $(S, \oplus)$ 是一个群，$S' \subseteq S$ ，并且 $(S', \oplus)$ 也是一个群，则 $(S', \oplus)$ 是 $(S, \oplus)$ 的一个**子群**== `subgroup` 。例如，在加法运算下，偶数形成一个整数的子群。下列定理提供了**识别子群的一个有用工具**。

**定理31.14**（**一个有限群的非空封闭子集是一个子群** `A nonempty closed subset of a finite group is a subgroup` ）如果 $(S, \oplus)$ 是一个有限群，$S'$ 是 $S$ 的任意一个非空子集，并满足对所有 $a, b \in S'$ 有 $a \oplus b \in S'$ ，则 $(S', \oplus)$ 是 $(S, \oplus)$ 的一个子群。
**证明**：证明过程见（算导练习31.3-3）。$\blacksquare$ 

例如，集合 $\{ 0, 2, 4, 6\}$ 形成 $\Z_8$ 的一个子群，因为它是非空的，而且在 $+$ 运算下具有封闭性（即在 $+_8$ 下它是封闭的）。

下列定理对子群的规模，作出了一个非常有用的限制，证明在此略去。

**定理31.5**（**拉格朗日定理** `Lagrange’s theorem` ）如果 $(S, \oplus)$ 是一个有限群，$(S', \oplus)$ 是 $(S, \oplus)$ 的一个子群，则 $|S'|$ 是 $|S|$ 的一个约数。$\blacksquare$

对一个群 $S$ 的子群 $S'$ ，如果 $S' \ne S$ ，则子群 $S'$ 称为群 $S$ 的**真子群** `proper subgroup` 。（算导31.8节中）对 *Miller-Rabin* 素数测试过程的分析，将用到下面的推论。

**推论31.16** 如果 $S'$ 是有限群 $S$ 的真子群，则 $|S'| \le |S| / 2$ 。$\blacksquare$ 

## 3.4 由一个元素生成的子群
**定理31.14**给出了一种用于生成**有限群 $(S, \oplus)$ 的子群**的简单方法：选择一个元素 $a$ ，取出由 $a$ 根据群上的运算能生成的所有元素。具体地，对 $k \ge 1$ 定义 $a^{(k)}$（这是一个元素！）如下：
$$a^{(k)} = \bigoplus^k_{i=1}a  = \underbrace{ a \oplus a \oplus \dots \oplus a }_{k个}$$ 例如，如果取群 $\Z_6$ 中的元素 $a = 2$ ，序列 $a^{(1)}, a^{(2)}, a^{(3)}, \dots$ 为：$$2, 4, 0, 2, 4, 0, 2, 4, 0, \dots$$ 

在群 $\Z_n$ 中，有 $a^{(k)} = ka \bmod n$ 。在群 $\Z^*_n$ 中，有 $a^{(k)} = a^k \bmod n$ 。**由 $a$ 生成的子群**用 $\langle a \rangle$ 或 $( \langle a \rangle, \oplus )$ 来表示，其定义如下：$$\langle a \rangle = \{ a^{(k) } \mid k \ge 1\}$$ ==我们称 $a$ **生成** `generates` 子群 $\langle a \rangle$ ，或者 $a$ 是 $\langle a \rangle$ 的**生成元**== `generator` 。因为 $S$ 是有限集，所以 $\langle a \rangle$ 是 $S$ 的**有限子集**，它可能包含 $S$ 中的所有元素。由 $\oplus$ 满足结合律可知：$$a^{(i) } \oplus a^{(j)} = a^{ (i+j)}$$ 故 $\langle a\rangle$ 具有**封闭性**。根据**定理31.14**，$\langle a \rangle$ 是 $S$ 的一个子群。例如，在 $\Z_6$ 中，有：$$\begin{aligned} &\langle 0 \rangle = \{ 0 \} \\ 
&\langle 1\rangle = \{ 0, 1, 2, 3, 4, 5 \} \\ 
&\langle 2\rangle = \{ 0, 2, 4 \} 
\end{aligned}$$ 类似地，在 $\Z^*_7$ 中，有：
$$\begin{aligned} &\langle 1 \rangle = \{ 1 \} \\
&\langle 2 \rangle  = \{ 1, 2, 4 \} \\
&\langle 3 \rangle = \{ 1,2,3,4,5,6\} \end{aligned}$$

==在群 $S$ 中 $a$ 的**阶** `order` 定义为满足 $a^{(t) } = e$ 的最小正整数 $t$ ，用 $ord(a)$ 来表示==。

**定理31.17** 对任意有限群 $(S, \oplus)$ 和任意 $a \in S$ ，一个元素的阶等于它所生成子群的规模，即 $ord(a) = | \langle a \rangle |$ 。
**证明**：设 $t = ord(a)$ 。因为 $a^{(t)} = e$ 并且对 $k \ge 1$ 有 $a^{ (t+k) } = a^{(t)} \oplus a^{(k)} = a^{(k)}$ ，如果 $i > t$ ，则对某个 $j < i$ ，有 $a^{(i)} = a^{(j)}$ 。因此，当我们通过 $a$ 生成元素时，在 $a^{(t)}$ 后面不会看到新元素。于是 $\langle a \rangle = \{ a^{ (1) }, a^{ (2) } , \dots, a^{ (t)} \}$ ，而且 $| \langle a \rangle | \le t$ 。

为了证明 $| \langle a \rangle| \ge t$ ，我们证明序列 $a^{(1)}, a^{(2)}, \dots, a^{(t)}$ 中的元素各不相同。假设这一结论不成立，即对某个满足 $1 \le i < j \le t$ 的 $i$ 和 $j$ 有 $a^{(i)} = a^{(j)}$ 。那么对 $k \ge 0$ ，有 $a^{(i+k)} = a^{(j+k)}$ 。但这说明 $a^{ ( i + (t - j)) } = a^{ (j + (t - j)) } = e$ ，因为 $i + (t - j) < t$ 、而 $t$ 是满足 $a^{(t)} = e$ 的最小正值，这样就出现了矛盾。因此，序列 $a^{(1)}, a^{(2)}, \dots, a^{(t)}$ 中的每个元素都是不同的，$| \langle a \rangle | \ge t$ 。于是得出结论 $ord(a) = | \langle a \rangle |$ 。$\blacksquare$

**推论31.18** 序列 $a^{ (1)} , a^{ \langle 2 \rangle }, \dots$ 是周期序列，其周期为 $t = ord(a)$ ，即 $a^{(i)} = a^{(j)}$ 当且仅当 $i \equiv j \pmod t$ 。$\blacksquare$

与上述推论一致的是，==我们对所有整数 $i$ ，定义 $a^{(0)} = a^{(t)}$ 为 $e$ 、且定义 $a^{(i)}$ 为 $a^{(i \bmod t)}$ ，其中 $t = ord(a)$== 。

**推论31.19** 如果 $(S, \oplus)$ 是具有单位元 $e$ 的有限群，则对所有 $a \in S$ ，$a^{ ( | S| ) } = e$ 。
**证明**：由**拉格朗日定理**可知，$ord(a) \mid |S|$（即存在整除关系），因此 $|S| \equiv 0 \pmod t$ ，其中 $t = ord(a)$ ，所以$$a^{ (|S|)} = a^{ (0) } = e\qquad \blacksquare$$  

---
# 4. 求解模线性方程
# 5. 中国余数定理
# 6. 元素的幂
# 7. RSA公钥加密系统
# 8. 素数测试
# 9. 整数的因子分解




