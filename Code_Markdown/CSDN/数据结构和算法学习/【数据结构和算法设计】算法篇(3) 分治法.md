@[toc]

分治法是使用最广泛的算法设计方法之一，其基本策略是采用递归思想、把大问题分解成一些小问题，然后由小问题的解、方便地构造大问题的解。这里介绍分治法求解问题的一般方法，并给出一些用分治法求解的经典示例。

---
# 3.1 分治法概述
## 3.1.1 分治法的设计思想
对于一个规模为 $n$ 的问题，若该问题可以容易地解决（例如规模 $n$ 较小）则直接解决，否则将其分解为 $k$ 个规模较小的子问题，这些子问题互相独立、且与原问题形式相同，递归地解这些子问题，然后将各子问题的解、合并得到原问题的解，这种算法设计策略叫**分治法**。

**如果原问题可分解成 $k\ (1 < k \le n)$ 个子问题，且这些子问题都可解、并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的**。由分治法产生的子问题，往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致、而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解，这自然导致递归过程的产生。**分治和递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法**。

分治法所能解决的问题，一般具有以下几个特征：
1. 该问题的规模，缩小到一定的程度就可以容易地解决。
2. 该问题可以分解为若干个规模较小的相似问题。
3. 利用该问题分解出的子问题的解，可以合并为该问题的解。
4. 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

上述特征(1)是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；特征(2)是应用分治法的前提，它也是大多数问题可以满足的，此特征反映了递归思想的应用；特征(3)是关键，能否利用分治法完全取决于问题是否具有该特征，**如果具备了特征(1)、(2)，而不具备特征(3)，则可以考虑用贪心法或动态规划法**；特征(4)涉及分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作、重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。

从上看到，分治法是一种解题的策略，它的基本思想是“如果整个问题比较复杂，可以将问题分化，各个击破”。**分治包含“分”和“治”两层含义，如何分、分后如何治成为解决问题的关键所在**。不是所有的问题都可以采用分治，只有那些能将问题分成与原问题类似的子问题、并且归并后符合原问题的性质的问题，才能进行分治。分治可进行二分、三分等，具体怎么分，需看问题的性质和分治后的效果。只有深刻地领会分治的思想，认真分析分治后可能产生的预期效率，才能灵活地运用分治思想、解决实际问题。

## 3.1.2 分治法的求解过程
递归特别适合解决结构自相似的问题，所谓结构自相似，是指构成原问题的子问题与原问题在结构上相似，可以采用类似的方法解决。所以，自治法通常采用递归算法设计技术，在每一层递归上都有三个步骤。
1. **分解成若干个子问题**：将原问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题。
2. **求解子问题**：若子问题规模较小，容易被解决，则直接求解，否则递归地求解各个子问题。
3. **合并子问题**：将各个子问题的解，合并为原问题的解。

分治法的一般算法设计模式如下：
```cpp
divide-and-conquer(P) {
	if (|P| <= n0) return adhoc(P);
	将P分解为较小的子问题P1,P2,...Pk;
	for (i = 1; i <= k; ++i) 			// 循环处理k次
		yi = divide-and-conquer(Pi);	// 递归解决Pi
	return merge(y1, y2, ..., yk);	    // 合并子问题
}
```
其中，$|P|$ 表示问题 $P$ 的规模；$n_0$ 为一阈值，表示当问题 $P$ 的规模不超过 $n_0$ 时（即 $P$ 问题规模足够小时）已容易直接解出，不必再继续分解。$adhoc(P)$ 是该分治法中的基本子算法，用于直接解小规模的问题 $P$ 。算法 $merge(y_1, y_2, \dots, y_k)$ 是该分治法中的合并子算法，用于将 $P$ 的子问题 $P_1, P_2, \dots, P_k$ 的相应解 $y_1, y_2, \dots, y_k$ 合并为 $P$ 的解。

根据分治法的分解原则，原问题应该分解为多少个子问题才适合？各个子问题的规模应该怎样才适当？这些问题很难给予肯定的回答。但人们从大量的实践中发现，**在用分治法设计算法时，最好使子问题的规模大致相同**。换句话说，将一个问题分成大小相等的 $k$ 个子问题的处理方法是行之有效的。当 $k = 1$ 时称为**减治法**。许多问题可以取 $k = 2$ ，称为**二分法**，如图3.1所示，这种使子问题规模大致相等的做法，出自一种**平衡子问题**的思想，**它几乎总是比子问题规模不等的做法要好**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/9cede2ced3894065bc057d74753bd8b0.png)
分治法的合并步骤，是算法的关键所在。有些问题的合并方法比较明显，有些问题的合并方法比较复杂，或者是有多种合并方案；或者是合并方案不明显。**究竟应该怎样合并，没有统一的模式，需要具体问题具体分析**。

尽管许多分治算法都是采用递归实现的，但要注意**分治法和递归是有区别的**，分治法是一种求解问题的策略，而递归是一种实现求解算法的技术。分治算法也可以采用非递归方法实现。就像二分查找，作为一种典型的分治算法，既可以采用递归实现，也可以采用非递归实现。

---
# 3.2 求解排序问题
对于给定的含有 $n$ 个元素的数组 $a$ ，对其按元素值递增排序。快速排序和归并排序是典型的、采用分治法进行排序的方法。
## 3.2.1 快速排序
快速排序的基本思想是，==在待排序的 $n$ 个元素中，任取一个元素（通常取第一个元素）作为基准 `pivot` ，把该元素放入最终位置后，整个数据序列被基准分割成两个子序列，所有小于基准的元素放置在前子序列中，任何大于基准的元素放置在后子序列中，并把基准排在这两个子序列的中间==，这个过程称为**划分**，如图3.2所示。然后对两个子序列分别重复上述过程，直到每个子序列内只有一个元素或空为止。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/38ed702dbce54a03bc9a6a271a9c56a3.png)
这是一种二分法思想，每次将整个无序序列一分为二，归位一个元素，对两个子序列采用同样的方式进行排序，直到子序列的长度为 $1$ 或 $0$ 为止。快速排序的分治策略如下：
1. **分解**：将原序列 $a[s...t]$ 分解成两个子序列 $a[s...i-1]$ 和 $a[i + 1...t]$ ，其中 $i$ 为划分的基准位置，即将整个问题分解为两个子问题。
2. **求解子问题**：若子序列的长度为 $0$ 或 $1$ ，则它是有序的，直接返回；否则递归地求解各个子问题。
3. **合并**：由于整个序列存放在数组 $a$ 中，排序过程是就地进行的，合并步骤不需要执行任何操作。
 
例如，对于 $(2, 5, 1, 7,10, 6, 9, 4, 3, 8)$ 序列，其快速排序过程如图3.3所示，图中虚线表示一次划分，虚线旁的数字表示执行次序，圆圈表示归位的基准。
![在这里插入图片描述](https://img-blog.csdnimg.cn/5fc44a80e0874a99aed39598ada549ae.png)
实现快速排序的完整性程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

void disp(int a[], int n) {				// 输出a中的所有元素
	for (int i = 0; i < n; ++i)
		printf("%d ", a[i]);
	printf("\n");
}
int Partition(int a[], int s, int t) {	// 划分算法
	int i = s, j = t;
	int tmp = a[s];						// 用序列的第1个记录作为基准
	while (i != j) {					// 用序列两端交替向中间扫描,直到i=j为止
		while (j > i && a[j] >= tmp)
			--j;						// 从右向左扫描,找第1个关键字小于tmp的a[i]
		a[i] = a[j];					// 将a[j]前移到a[i]的位置
		while (i < j && a[i] <= tmp)
			++i;						// 从左向右扫描,找第1个关键字大于tmp的a[i]
		a[j] = a[i];					// 将a[i]后移到a[j]的位置
	}
	a[i] = tmp;
	return i;
}
void QuickSort(int a[], int s, int t) {	// 对a[s...t]元素序列进行递增排序
	if (s < t) {						// 序列内至少存在两个元素的情况
		int i = Partition(a, s, t);
		QuickSort(a, s, i - 1);			// 对左子序列递归排序
		QuickSort(a, i + 1, t);			// 对右子序列递归排序
	}
}
int main() {
	int n = 10;
	int a[] = {2, 5, 1, 7, 10, 6, 9, 4, 3, 8};
	printf("排序前: "); disp(a, n);
	QuickSort(a, 0, n - 1);
	printf("排序后: "); disp(a, n);
	return 0;
}	
```
【算法分析】快速排序的时间主要耗费在划分操作上，对长度为 $n$ 的区间进行划分，共需 $n - 1$ 次关键字的比较，时间复杂度为 $O(n)$ 。对 $n$ 个元素进行快速排序的过程，构成一棵递归树。在这样的递归树中，每一层最多对 $n$ 个元素进行划分，所花的时间为 $O(n)$ 。
- 当初始排序数据正序或反序时，递归树高度为 $n$ ，快速排序呈现最坏情况，即最坏情况下的时间复杂度为 $O(n^2)$ ；
- 当初始排序数据随机分布，使每次分成的两个子区间中的元素个数大致相等时，递归树高度为 $\log_2 n$ ，快速排序呈现最好情况，即最好情况下的时间复杂度为 $O(n\log_2 n)$ 。
- 快速排序算法的平均时间复杂度也是 $O(n\log_2 n)$ 。所以快速排序是一种高效的算法，STL中的 `sort()` 算法，就是采用快速排序方法实现的。

## 3.2.2 归并排序
归并排序的基本思想是，==首先将 $a[0...n-1]$ 看成 $n$ 个长度为 $1$ 的有序表，将相邻的 $k\ (k \ge 2)$ 个有序子表成对归并，得到 $n / k$ 个长度为 $k$ 的有序子表；然后再将这些有序子表继续归并，得到 $n / k ^2$ 个长度为 $k^2$ 的有序子表，如此反复进行下去，最后得到一个长度为 $n$ 的有序表==。由于整个排序结果放在一个数组中，所以不需要特别地进行合并操作。

若 $k = 2$ ，即归并是在相邻的两个有序子表中进行的，称为**二路归并排序**。若 $k > 2$ ，即归并是在相邻的多个有序子表中进行，称为**多路归并排序**。这里仅讨论二路归并排序算法。
### 1. 自底向上的二路归并排序
自底向上的二路归并算法采用归并排序的基本原理，第 $1$ 趟归并排序时将待排序的表 $a[0...n-1]$ 看作是 $n$ 个长度为 $1$ 的有序子表，将这些子表两两归并，若 $n$ 为偶数，则得到 $\lceil n / 2\rceil$ 个长度为 $2$ 的有序子表；若 $n$ 为奇数，则最后一个子表轮空（不参与归并），故本趟归并完成后，前 $\lceil n / 2 \rceil - 1$ 个有序子表长度为 $2$ ，但最后一个子表长度仍为 $1$ ；第 $2$ 趟归并则是将第 $1$ 趟归并所得到的 $\lceil n / 2\rceil$ 个有序子表两两归并，如此反复，直到最后得到一个长度为 $n$ 的有序表为止。

首先设计算法 `Merge()` ，用于将两个有序子表归并为一个有序子表。设两个有序子表存放在同一个表中相邻的位置上，即 $a[low...mid]$（有 $mid - low + 1$ 个元素）、$a[mid + 1...high]$（有 $high - mid$ 个元素），先将它们合并到一个临时表 $tmpa[0...high-low]$ 中，在合并完成后将 $tmpa$ 复制到 $a$ 中。其归并过程是：==循环从两个子表中、顺序取出一个元素进行比较，并将较小者放到 $tmpa$ 中，当一个子表元素取完时、将另一个子表中余下的部分直接复制到 $tmpa$ 中。这样 $tmpa$ 是一个有序表，再将其复制到 $a$ 中==。

其次，设计算法 `MergePass()` 通过调用 `Merge()` 算法，解决一趟归并问题。在某趟归并中，设各子表长度为 $length$（最后一个子表的长度可能小于 $length$ ），则归并前 $a[0...n-1]$ 中共 $\lceil \dfrac{n}{length} \rceil$ 个有序子表，即 $a[0...length-1],\ a[length...2length-1],\ \dots,\ a\bigg[\bigg( \bigg\lfloor \dfrac{n}{length} \bigg\rfloor \bigg) length ... n - 1\bigg]$ 。调用 `Merge()` 一次，将相邻的一对子表进行归并，另外**需要对表的个数可能是奇数、以及最后一个子表的长度小于 $length$**（总长度不是 $2^k$ 就一定会出现这种情况）**这两种特殊情况进行处理**：==若子表的个数为奇数，则最后一个子表无须和其他子表归并（即本趟轮空）；若子表的个数为偶数，则要注意到最后一个子表中后一个子表的区间上界是 $n - 1$== 。

最后，对于含有 $n$ 个元素的序列 $a$ ，设计算法 `MergeSort` 调用 `MergePass` 算法 $\lceil \log_2 n\rceil$ 次、以实现二路归并排序（自底向上）。二路归并排序的分治策略如下——循环 $\lceil \log_2 n\rceil$ 次，$length$ 依次取 $1, 2, \dots, \log_2 n$ ，每次执行以下步骤：
1. **分解**：将原序列分解成 $length$ 长度的若干个子序列。
2. **求解子问题**：对相邻的两个子序列，调用 `Merge` 算法合并成一个有序子序列。
3. **合并**：由于整个序列存放在数组 $a$ 中，排序过程是就地进行的，合并步骤不需要执行任何操作。


例如，对于 $(2, 5, 1, 7, 10, 6, 9, 4, 3, 8)$ 序列，其排序过程如图3.4所示，图中方括号内是一个有序子序列。
![在这里插入图片描述](https://img-blog.csdnimg.cn/08de5971df06406c89bdf9079c94118f.png)实现二路归并排序的完整程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100;
int tmpa[MAXN];

void disp(int a[], int n) {						// 输出a中的所有元素
	for (int i = 0; i < n; ++i)
		printf("%d ", a[i]);
	printf("\n");
} 
void Merge(int a[], int low, int mid, int high) {
	// 将a[low...mid]和a[mid+1...high]两个相邻的有序子序列
	// 归并为一个有序子序列a[low...high]
	int i = low, j = mid + 1;					// i,j分别为两个子表的下标
	int k = low;								// k是tmpa的下标
	while (i <= mid && j <= high) {				// 在第1个子表和第2个子表均未扫描完时循环
		if (a[i] <= a[j])						// 将第1个子表中的元素放入
			tmpa[k++] = a[i++];
		else									// 将第2个子表中的元素放入
			tmpa[k++] = a[j++];
	}
	while (i <= mid) 							// 将第1个子表余下的部分复制到tmpa
		tmpa[k++] = a[i++];
	while (j <= high) 							// 将第2个子表余下的部分复制到tmpa
		tmpa[k++] = a[j++];
	for (k = low; k <= high; ++k)				// 将tmpa复制回a中
		a[k] = tmpa[k];
}
void MergePass(int a[], int length, int n) {	// 一趟二路归并排序
	int i;
	for (i = 0; i + 2 * length - 1 < n; i = i + 2 * length) 
		Merge(a, i, i + length - 1, i + 2 * length - 1); // 归并length长的两个相邻子表
	if (i + length < n)							// 余下两个子表,后者的长度小于length,即子表的个数为偶数
		Merge(a, i, i + length - 1, n - 1);		// 归并这两个子表
	// else if (i + length >= n)				// 余下一个子表,即子表的个数为奇数
}
void MergeSort(int a[], int n) {				// 二路归并算法
	int length;
	for (length = 1; length < n; length *= 2) {
		MergePass(a, length, n);
		disp(a, n);								// 输出这一趟的情况
	}
}
int main() {
	int n = 11;
	int a[] = {2, 5, 1, 7, 10, 6, 9, 4, 8, 11, 3};
	printf("排序前: "); disp(a, n);
	MergeSort(a, n);
	printf("排序后: "); disp(a, n);
	return 0;
}
```
上述程序运行结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/905eef889a794ed0a358b72f792ff8df.png)
【算法分析】对于上述二路归并排序算法，当有 $n$ 个元素时需要 $\lceil \log_2 n\rceil$ 趟归并，每一趟归并，其元素比较次数不超过 $n - 1$ ，元素移动次数都是 $n$ ，因此二路归并排序的时间复杂度为 $O(n\log_2 n)$ 。
### 2. 自顶向下的二路归并排序
上述自底向上的二路归并算法虽然效率较高，但可读性较差。另一种是采用自顶向下的方法设计，算法更为简洁，属于典型的二分法算法。

设归并排序的当前区间是 $a[low...high]$ ，则递归归并的步骤如下：
1. **分解**：将当前序列 $a[low...high]$ 一分为二，即求 $mid = (low + high) / 2$ ，分解为两个子序列 $a[low...mid]$ 和 $a[mid + 1...high]$ 。
2. **子问题求解**：递归地对两个子序列 $a[low...mid]$ 和 $a[mid + 1...high]$ 二路归并排序。其终结条件是子序列的长度为 $1$ 或者 $0$（因为一个元素的子表或空表可以看成有序表）。
3. **合并**：与分解过程相反，将已排序的两个子序列 $a[low...mid]$ 和 $a[mid + 1...high]$ 归并为一个有序序列 $a[low...high]$ 。

例如，对于 $(2, 5, 1, 7, 10, 6, 9, 4, 3, 8)$ 序列，其排序过程如图3.5所示，图中圆括号内的数字指出操作顺序。
![在这里插入图片描述](https://img-blog.csdnimg.cn/7c198b9c628848288a97f98b3d38b82b.png)
对应的二路归并排序算法如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100;
int tmpa[MAXN];

void disp(int a[], int n) {						// 输出a中的所有元素
	for (int i = 0; i < n; ++i)
		printf("%d ", a[i]);
	printf("\n");
} 
void Merge(int a[], int low, int mid, int high) {
	// 将a[low...mid]和a[mid+1...high]两个相邻的有序子序列
	// 归并为一个有序子序列a[low...high]
	int i = low, j = mid + 1;					// i,j分别为两个子表的下标
	int k = low;								// k是tmpa的下标
	while (i <= mid && j <= high) {				// 在第1个子表和第2个子表均未扫描完时循环
		if (a[i] <= a[j])						// 将第1个子表中的元素放入
			tmpa[k++] = a[i++];
		else									// 将第2个子表中的元素放入
			tmpa[k++] = a[j++];
	}
	while (i <= mid) 							// 将第1个子表余下的部分复制到tmpa
		tmpa[k++] = a[i++];
	while (j <= high) 							// 将第2个子表余下的部分复制到tmpa
		tmpa[k++] = a[j++];
	for (k = low; k <= high; ++k)				// 将tmpa复制回a中
		a[k] = tmpa[k];
}
void MergeSort(int a[], int low, int high) {	// 二路归并算法
	if (low < high) {							// 子序列有两个或以上元素
		int mid = (low + high) / 2;
		MergeSort(a, low, mid);					// 对a[low...mid]子序列排序
		MergeSort(a, mid + 1, high);			// 对a[mid+1...high]子序列排序
		Merge(a, low, mid, high);				// 将两个子序列合并
	}
}
int main() {
	int n = 11;
	int a[] = {2, 5, 1, 7, 10, 6, 9, 4, 8, 11, 3};
	printf("排序前: "); disp(a, n);
	MergeSort(a, 0, n - 1);
	printf("排序后: "); disp(a, n);
	return 0;
}
```
【算法分析】设 `MergeSort(a, 0, n - 1)` 算法的执行时间为 $T(n)$ ，显然 `Merge(a, 0, n / 2, n - 1)` 合并操作的执行时间为 $O(n)$，所以得到以下递推式：
```cpp
T(n) = 1				当n=1时
T(n) = 2T(n/2) + O(n)	当n>1时
```
容易推出 $T(n) = O(n\log_2 n)$ 。

---
# 3.3 求解查找问题
## 3.3.1 查找最大和次大元素
【问题描述】对于给定的含有 $n$ 个元素的无序序列，求这个序列中最大和次大的两个不同元素。

【问题求解】对于无序序列 $a[low...high]$ ，采用分治法求最大元素 $max1$ 和次大元素 $max2$ 的过程如下：
1. 若 $a[low...high]$ 中只有一个元素，则 $max1 = a[low], max2 = -\infin$ 。
2. 若 $a[low...high]$ 中只有两个元素，则 $max1 = \max( a[low], a[high]),\ max2 = \min( a[low], a[high])$ 。
3. 若 $a[low...high]$ 中有两个以上元素，按中间位置 $mid = (low + high) / 2$ 划分为 $a[low...mid]$ 和 $a[mid + 1...high]$ 两个区间（注意左区间包含 $a[mid]$ 元素）。求出左区间的最大元素 $lmax1$ 和次大元素 $lmax2$ ，求出右区间的最大元素 $rmax1$ 和次大元素 $rmax2$ 。
若 $lmax1 > rmax1$ ，则 $max1 = lmax1,\ max2 = \max(lmax2, rmax1)$ ；否则 $max1 = rmax1,\ max2 = \max(lmax1, rmax2)$ 。
4. 例如，对于 $a[0...4] = \{ 5, 2, 1, 4, 3\}$ ，$mid = (0 + 4) / 2 = 2$ ，划分为左区间 $a[0...2] = \{ 5, 2, 1\}$ ，右区间 $a[3...4] = \{ 4, 3\}$ 。 在左区间中求出 $lmax1 = 5, lmax2 = 2$ ，在右区间中求出 $rmax1 = 4, rmax2 = 3$ 。所以 $max1 = \max(lmax1, rmax1) = 5,\ max2 = \max(lmax2, rmax1) = 4$ 。
 

对应的算法如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
void solve(int a[], int low, int high, int &max1, int &max2) {
	if (low == high) 						// 区间中只有一个元素
		max1 = a[low], max2 = -INF;
	else if (low == high - 1)				// 区间中只有两个元素
		max1 = max(a[low], a[high]), max2 = min(a[low], a[high]);
	else {									// 区间中有两个以上元素
		int mid = (low + high) / 2;
		int lmax1, lmax2;					// 左区间求lmax1,lmax2
		solve(a, low, mid, lmax1, lmax2);	
		int rmax1, rmax2;					// 右区间求rmax1,rmax2
		solve(a, mid + 1, high, rmax1, rmax2);
		if (lmax1 > rmax1) {
			max1 = lmax1;
			max2 = max(lmax2, rmax1);		// lmax2,rmax1中求次大元素
		} else {
			max1 = rmax1;
			max2 = max(lmax1, rmax2);		// lmax1,rmax2中求次大元素
		}
	}
}
int main() {
	int a[] = {5, 2, 1, 4, 3};
	int max1, max2;
	solve(a, 0, 4, max1, max2);
	printf("%d %d", max1, max2);
	return 0;	
}
```
【算法分析】对于 `solve(a, 0, n - 1, max1, max2)` 调用，其比较次数的递推书如下：
```cpp
T(1) = T(2) = 1
T(n) = 2T(n/2) + 1		// 合并的时间为O(1)
```
可以推导出 $T(n) = O(n)$（由于 $a = 2, b = 2, d = 0 < \log_a^b = 1$ ，所以 $T(n) = n^{\log_a^b} = n$ ）。
## 3.3.2 折半查找
**折半查找**又称二分查找，它是一种效率较高的查找方法。但是折半查找要求序列中的元素是有序的，为了简单假设是递增有序的。

折半查找的基本思路：设 $a[low...high]$ 是当前的查找区间，首先确定该区间的中点位置 $mid = \lfloor (low + high) / 2\rfloor$ ，然后将待查找的 $k$ 值与 $a[mid].key$ 比较。
1. 设 $k == a[mid].key$ ，则查找成功并返回该元素的物理下标。
2. 若 $k < a[mid]$ ，则由表的有序性可知，$a[mid...high]$ 均大于 $k$ ，因此若表中存在关键字等于 $k$ 的元素，则该元素必存在于左子表 $a[low...mid -1]$ 中，故新的查找区间是左子表 $a[low...mid-1]$ 。
3. 若 $k > a[mid]$ ，则要查找的 $k$ 必定位于右子表 $a[mid +1...high]$ 中，即新的查找区间是右子表 $a[mid +1...high]$ 。
4. 下一次查找是针对新的查找区间进行的。

因此，可以从初始的查找区间 $a[0...n-1]$ 开始，每与「当前查找区间的中点位置上的关键字」比较一次，就可以确定查找是否成功，不成功则当前的查找区间缩小一半。重复这一过程，直到找到关键字为 $k$ 的元素，或者直到当前的查找区间为空（即查找失败）为止。
```cpp
#include <bits/stdc++.h>
using namespace std;
int binSearch(int a[], int lo, int hi, int k) { // 折半查找算法
	if (lo <= hi) {								// 当前区间存在元素时
		int mid = (lo + hi) / 2;				// 求查找区间的中间位置
		if (a[mid] == k) 						// 找到后返回其物理下标mid
			return mid;
		if (a[mid] > k)							// 当a[mid]>k时在a[lo...mid-1]中递归查找
			return binSearch(a, lo, mid - 1, k);
		else									// 当a[mid]<k时在a[mid+1...hi]中递归查找
			return binSearch(a, mid + 1, hi, k);
	} else return -1;							// 当查找区间没有元素时返回-1
}
int main() {
	int n = 10, i;
	int k = 6;
	int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	i = binSearch(a, 0, n - 1, k);
	if (i >= 0) printf("a[%d]=%d\n", i, k);
	else printf("未找到%d元素\n", k);
	return 0; 	
}
```
可以将折半查找递归算法，等价地转换成以下非递归算法：
```cpp
int binSearch2(int a[], int n, int k) {	 		// 非递归折半查找算法
	int lo = 0, hi = n - 1;
	while (lo <= hi) {							// 当前区间存在元素时循环
		int mid = (lo + hi) / 2;				// 求查找区间的中间位置
		if (a[mid] == k) return mid;			// 找到后返回其物理下标mid
		if (a[mid] > k)	hi = mid - 1;			// 当a[mid]>k时在a[lo...mid-1]中递归查找
		else lo = mid + 1;						// 当a[mid]<k时在a[mid+1...hi]中递归查找
	}
	return -1;									// 当查找区间没有元素时返回-1
}
```
【算法分析】折半查找算法的主要时间花费在元素的比较上，对于含有 $n$ 个元素的有序表，采用折半查找时最坏情况下的元素比较次数为 $C(n)$ ，则有：
$$C(n) = \begin{cases} 
1  &\quad 当n=1时 \\
\le 1 + C(\lfloor \dfrac{n}{2} \rfloor ) &\quad 当n\ge 2时
\end{cases}$$

设对于某个整数 $k \ge 2$ ，满足 $2^{k-1} \le n < 2^k$ 。展开上述递推式，可得到：
$$\begin{aligned}C(n) &\le 1 + C(\lfloor \dfrac{n}{2} \rfloor) \\
&\le   2 + C(\lfloor \dfrac{n}{4} \rfloor) \\
&\le \dots \\
&\le (k-1) + C(\lfloor \dfrac{n}{2^{k-1}} \rfloor) \\
&= (k-1) + 1 = k\end{aligned}$$

而 $2^{k-1} \le n < 2^k$ ，即 $k \le \log_2 n+ 1< k + 1,\ k = \lfloor \log_2 n\rfloor + 1$ 。由此得到 $C(n) \le \lfloor \log_2 n \rfloor + 1$ 。也就是说，在含有 $n$ 个元素的有序序列中，==采用折半查找算法查找指定的元素、所需的元素比较次数不超过 $\lfloor \log_2 n \rfloor + 1$（或者 $\lceil \log_2(n+1) \rceil$ ）==。实际上，$n$ 个元素的折半查找对应判定树的高度恰好是 $\lfloor \log_2 n\rfloor +1$ 。折半查找的主要时间花在元素的比较上，所以算法的时间复杂度为 $O(\log_2 n)$ 。

折半查找的思路很容易推广到三分查找，显然三分查找对应判断树的高度恰好是 $\lfloor \log_3 n\rfloor + 1$ ，推出查找时间复杂度为 $O(\log_3 n)$ 。==由于 $\log_3 n = \dfrac{\log_2 n }{ \log_2 3}$ ，所以三分查找和二分查找的时间是同一数量级的==。

【例3.1】**求解假币问题**。有 $100$ 个硬币，其中有一个假币（与真币一模一样，**只是比真币的重量轻**），采用天平称重方法找出这个假币，最少用天平称重多少次保证**找出假币**。
解：已知假币比真币的重量轻，可以将 $100$ 个硬币分为两组，每组 $50$ 个硬币，称重一次可以确定假币所在的组，即二分法。==更好的方法是采用三分法，将 $100$ 个硬币分为 $33, 33, 34$ 三组，用天平一次称重（即两个 $33$ 称重，如果相等则在 $34$ 这一组；否则在轻的 $33$ 那一组）、可以找出假币所在的组==，依次进行，对应一棵三分判定树，树高度恰好是称重次数，结果为 $\lceil \log_3(100+1) \rceil = 5$ 。
> 称重问题由很多变形，比如：[商汤] $101$ 枚硬币中有一枚假币，有一个无砝码的天平，在最坏情况下最少称 **多少** 次，可以判断假币比真币重还是轻。即**求假币的轻重情况**。
> 答：做法之一是：先拿出 $1$ 枚硬币，将 $100$ 枚对半称重。
> - 如果平衡，那拿出来的那枚就是假的，再称一次就可以分清轻重。
> -  如果不平衡，那就将轻的 $50$ 枚对半分：假如两边平衡，说明轻的都是真的，假币重；假如不平衡，说明假币就在这里，假币轻。这样就可以 $2$ 次判断出来。
> 
> 另一个做法是： 把 $101$ 个硬币分成三份，分别是 $33, 33, 35$ ，把两堆 $33$ 个放在天平上称：
> - 如果平衡，说明这 $66$ 个都是真的。然后从这两堆共 $66$ 个中取出 $35$ 个，与第三堆的 $35$ 个分别放在天平的左右盘中称，这样，「第三堆所在的天平那一端的轻重」就是假币的轻重情况。 
> - 如果两个 $33$ 放在天平上不平衡，说明第三堆的 $35$ 个是真的。取走轻的一端的 $33$ 个，再从第三堆中取 $33$ 个放在上面，如果平衡，说明取走的一堆中有假币，假币比真的轻。如果不平衡，则只有一种结果，第三堆与取走的一堆一样，都比剩下一堆轻，说明假的比真的重。

## 3.3.3 寻找一个序列中第 $k$ 小的元素 
【问题描述】对于给定的含有 $n$ 个元素的无序序列，求这个序列中第 $k\ (1 \le k \le n)$ 小的元素。

【问题求解】假设无序序列存放在 $a[0\dots n - 1]$ 中，若将 $a$ 递增排序，则第 $k$ 小的元素为 $a[k-1]$ 。采用类似快速排序的思想，对于无序序列 $a[s...t]$ ，在其中查找第 $k$ 小的元素的过程如下：
1. 若 $s \ge t$ ，即其中只有一个元素或没有任何元素，如果 $s =t$ 且 $s = k - 1$ ，表示只有一个元素、且 $a[k-1]$ 就是要求的结果，返回 $a[k - 1]$ 。
2.  若 $s < t$ ，表示该序列中有两个或两个以上的元素，以基准为中心将其划分为 $a[s...i-1]$ 和 $a[i+1...t]$ 两个子序列，基准 $a[i]$ 已归位，$a[s...i-1]$ 中的所有元素均小于 $a[i]$ ，$a[i+1...t]$ 中的所有元素均大于 $a[i]$ ，也就是说 $a[i]$ 是第 $i + 1$ 小的元素，有三种情况：
	1. 若 $k - 1= i$ ，$a[i]$ 即为所求，返回 $a[i]$ 。
	2. 若 $k - 1< i$ ，第 $k$ 小的元素应在 $a[s...i-1]$ 子序列中，递归在该子序列中求解并返回其结果。
	3. 若 $k - 1>i$ ，第 $k$ 小的元素应在 $a[i+1...t]$ 子序列中，递归在该子序列中求解并返回其结果。

对应的完整程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

int QuickSelect(int a[], int s, int t, int k) { // 在a[s...t]序列中找第k小的元素
	int i = s, j = t;
	if (s < t) {								// 区间中至少存在两个元素的情况
		int tmp = a[s];							// 用区间的第1个记录作为基准
		while (i != j) {						// 从区间两端交替向中间扫描,直到i=j为止
			while (j > i && a[j] >= tmp) --j;	// 从右向左扫描,找第一个关键字小于tmp的a[j]
			a[i] = a[j];						// 将a[j]前移到a[i]的位置
			while (i < j && a[i] <= tmp) ++i;	// 从左向右扫描,找第1个关键字大于tmp的a[i]
			a[j] = a[i];						// 将a[i]后移到a[j]的位置
		}
		a[i] = tmp;
		if (k - 1 == i) return a[i];
		else if (k - 1 < i) return QuickSelect(a, s, i - 1, k); // 在左区间递归查找
		else return QuickSelect(a, i + 1, t, k);				// 在右区间递归查找
	} else if (s == t && s == k - 1)			// 区间内只有一个元素且为a[k-1]
		return a[k - 1];
}
int main() {
	int n = 10;
	int a[] = {2, 5, 1, 7, 10, 6, 9, 4, 3, 8};
	for (int k = 1; k <= n; ++k) {
		int e = QuickSelect(a, 0, n - 1, k);
		printf("第%d小的元素:%d\n", k, e);
	}
	return 0;
}
```
本程序的执行结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/31aa2418cc23404a967df62e7f5545d4.png)
【算法分析】对于 `QuickSelect(a, s, t, k)` 算法，设序列 $a$ 中含有 $n$ 个元素，其比较次数的递推式为：$$T(n) =T(n/2) + O(n)$$  可以推导出 $T(n)=O(n)$ ，这是最好的情况，即每次划分的基准恰好是中位数，将一个序列划分为长度大致相等的两个子序列。在最坏情况下，每次划分的基准恰好是序列中的最小值或最大值，则处理区间只比上一次减少 $1$ 个元素，此时比较次数为 $O(n^2)$ 。在平均情况下，该算法的时间复杂度为 $O(n)$ .

## 3.3.4 寻找两个等长有序序列的中位数
【问题描述】对于一个长度为 $n$ 的有序序列（假设均为升序序列）$a[0\dots n -1]$ ，处于中间位置的元素称为 $a$ 的中位数。例如，若序列 $a = (11, 13, 15, 17, 19)$ ，其中位数是 $15$ ，若 $b = (2, 4, 6, 8, 10$ ，其总位数是 $6$ 。两个等长有序序列的中位数，是含它们所有元素的有序序列的中位数，例如 $a, b$ 两个有序序列的中位数为 $11$ 。设计一个算法，求给定的两个有序序列的中位数（[LeetCode 4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)是其困难版）。

【问题求解】对于含有 $n$ 个元素的有序序列 $a[s...t]$ ，当 $n$ 为奇数时，中位数出现在 $m = \lfloor (s + t) / 2\rfloor$ 处；当 $n$ 为偶数时，中位数下标有 $m = \lfloor (s+t)/2 \rfloor$（下中位）和 $m = \lfloor (s +t)/2\rfloor + 1$（上中位）两个。为了简单，这里仅考虑中位数下标为 $m = \lfloor (s +t) / 2\rfloor$ 。

采用二分法，求含有 $n$ 个有序元素的序列 $a, b$ 的中位数的过程如下：
1. 分别求出 $a, b$ 的中位数 $a[m_1],\ b[m_2]$ 。
2. 若 $a[m_1] = b[m_2]$ ，则 $a[m_1]$ 或 $b[m_2]$ 即为所求中位数，如图3.6(a)所示，算法结束。
3. 若 $a[m_1] < b[m_2]$ ，则舍弃序列 $a$ 中的前半部分（较小的一半），同时舍弃序列 $b$ 中的后半部分（较大的一半），要求舍弃的长度相等，如图3.6(b)所示。
4. 若 $a[m_1] > b[m_2]$ ，则舍弃序列 $a$ 中的后半部分（较大的一半），同时舍弃序列 $b$ 中的前半部分（较小的一半），要求舍弃的长度相等，如图3.6 c)所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/62101876711c4abea8c04082b1dc8a81.png)
在保留的两个升序序列中，重复上述过程、直到两个序列中只含有一个元素时为止，较小者即为所求的中位数。

为了**保证每次取的两个子有序序列等长**，对于 $a[s...t], m = (s +t)/2$ ，若取前半部分，则为 $a[s...m]$ 。==在取后半部分时要区分：$a$ 中的元素个数为奇数还是偶数==，若为奇数（满足 $(s + t) \bmod 2 == 0$ 的条件），则后半部分为 $a[m\dots t]$ ，若为偶数（满足 $(s + t) \bmod 2 == 1$ 的条件），则后半部分为 $a[m + 1\dots, t]$ 。例如，求 $a = (11, 13, 15, 17, 19), b= (2, 4, 6, 8, 20)$ 两个有序序列的中位数，其过程如下图3.7所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/02afe610f1764a5d93b252819c08151c.png)
对应的完整程序如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/bff8c3334f404a4a8d221ebf4287de49.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/8fbadd16f8f94274b699eef10f889df6.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/80c63a509b4d4000a54a966609a9abce.png)
其中求 $a, b$ 两个有序序列的中位数的算法，也可以用循环语句来替换，等价的非递归算法如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/d5b6f462930d44d3886811a2181692c0.png)
【算法分析】对于含有 $n$ 个元素的有序序列 $a$ 和 $b$ ，设调用 `midnum(a, 0, n - 1, b, 0, n - 1` 求中位数的执行时间为 $T(n)$ ，显然有以下递推式：
```cpp
T(n) = 1				// 当n=1时
T(n) = 2T(n/2) + 1 		//当n>1时
```
容易推出 $T(n) = O(\log_2 n)$ 。


## 3.3.5 寻找两个有序序列的第 $k$ 个元素
【问题求解】给出已排序数组 $a, b$ ，长度分别为 $n, m$（**$n$ 与 $m$ 不必相等**），找出一个时间复杂度为 $O(\log_2(n+m))$ 的算法，求出排在第 $k\ (1\le k \le n+m)$ 位置的元素。

【问题求解】假设是递增排序，先考虑 $a$ 和 $b$ 的元素个数都大于 $k / 2$ 的情况。将 $a$ 的第 $k /2$ 个元素（即 $a[k / 2 - 1]$ ）和 $b$ 的第 $k/2$ 个元素（即 $b[k / 2 - 1]$ ）进行比较，有以下三种情况（为了简化，==这里先假设 $k$ 为偶数，所得到的结论对于 $k$ 是奇数也是成立的==，合并后第 $k$ 小的元素用 $topk$ 表示）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d754547e181b4dbbab43d8fdb2f3a62e.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/6c5cdca931fa4f33950c5070cc7f70ac.png)
上述过程每次递归调用时 $k$ 减半，所以执行时间为 $\log_2 k$ ，最多 $k = n +m$ ，所以时间复杂度为 $O(\log_2 (n+m))$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/3301cbf4159945c7a3a9eacd3fb11687.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/aad4f7e79c784924a0bc0b82d3a2791a.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/aa6739e1b8074bbc868121d7fb19b8d2.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/1c26ae217c98436eb81a6c87c96a8bb5.png)

---
# 3.4 求解组合问题
## 3.4.1 求解最大连续子序列和（最大子数组）问题
【问题描述】给定一个有 $n\ (n \ge 1)$ 个整数的序列，求出其中最大连续子序列的和。例如序列 $(-2, 11, -4, 13, -5, -2)$ 的最大子序列和为 $20$ ，序列 $(-6, 2, 4, -7, 5, 3, 2, -1, 6, -9, 10, -2)$ 的最大子序列和为 $16$ 。规定一个序列的最大连续子序列和至少是 $0$ ，如果小于 $0$ ，其结果为 $0$ 。  

【问题求解】对于含有 $n$ 个整数的序列 $a[0...n-1]$ ，若 $n = 1$ ，表示该序列仅含一个元素，如果该元素大于 $0$ ，则返回该元素，否则返回 $0$ 。若 $n > 1$ ，采用分治法求解最大连续子序列和时，取其中间位置 $mid = \lfloor (n - 1) / 2\rfloor$ ，该子序列只可能出现在三个地方，各种情况及求解方法如图3.9所示：
1. 该子序列完全落在左半部分，即 $a[0\dots mid]$ 中，采用递归求出其最大连续子序列和 $maxLeftSum$ ，如图3.9(a)所示。
2. 该子序列完全落在右半部分，即 $a[mid+1\dots n-1]$ 中，采用递归求出其最大连续子序列和 $maxRightSum$ ，如图3.9(a)所示。
3. 该子序列跨越序列 $a$ 的中部、而占据左右两部分。也就是说，这种情况下最大和的连续子序列含有 $a_{mid}$ ，则从左半部分（含 $a_{mid}$ 元素）求出 $\displaystyle maxLeftBorderSum = \max \sum^{mid}_{k=i} a_k \ ( 0 \le i \le mid)$ ，从右半部分（不含 $a_{mid}$ 元素）求出 $\displaystyle maxRightBorderSum = \max  \sum_{k=mid+1}^j a_k \ ( mid + 1\le j \le n - 1)$ ，这种情况下的最大连续子序列和为 $maxMidSum = maxLeftBorderSum + maxRightBorderSum$ ，如图3.9(b)所示。
4. 最后整个序列 $a$ 的最大连续子序列和为 $maxLeftSum, maxRightSum, maxMidSum$ 中的最大值，如图3.9 c)所示。 
![在这里插入图片描述](https://img-blog.csdnimg.cn/3a167e6126a444e5afa592f07f4894e3.png)


例如 $a[0...5] = \{ -2, 11, -4, 13, -5, -2\}, n = 6, mid = (0 + 5) / 2 = 2$ ，划分为 $a[0...2]$ 和 $a[3...5]$ 左、右两个部分。递归求出左部分 $(-2, 11, -4)$ 的最大连续子序列和为 $11$ ，递归求出右部分 $(13, -5, -2)$ 的最大连续子序列和为 $13$ ，再求出以 $a[mid] = -4$ 为中心的最大连续子序列和为 $20$（对应序列为 $(11, -4, 13)$ ），最终结果为 $\max \{ 11, 13, 20\} = 20$ 。

求最大连续子序列和的完整程序如下：
```cpp

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/91745b78a7574a6db9ba73aac6811437.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/57de46ad288049dbbccec146b880bd99.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/152bfe647dcb4d4292088514308c2620.png)
【算法分析】设求解序列 $a[0...n-1]$ 最大连续子序列和的执行时间为 $T(n)$ ，第(1)、(2)两种情况的执行时间为 $T(n/2)$ ，第(3)种情况的执行时间为 $O(n)$ ，所以得到以下递推式：
```cpp
T(n) = 1				// 当n=1时
T(n) = 2T(n/2) + n		// 当n>1时
```
容易推出 $T(n)= O(n\log_2 n)$ 。

> 思考：给定一个有 $n\ (n \ge 1)$ 个整数的序列，可能含有负整数，求出其中最大连续子序列的积，是否采用上述求最大连续子序列和（即最大子数组和）的方法？
> <b></b>
> 答：结论是不可以！例如 $a[0...5] = \{ -2, 3, 2, 4, 1, -5\}$ 。显然最大连续子序列的积 $=(-2) \times 3 \times 2 \times 4 \times (-5) = 240$ 。如果采用上述分治法，$mid = (0 + 5) / 2 = 2$ ，划分为 $a[0...2]$ 和 $a[3...5]$ 左、右两个部分。递归求出左部分 $(-2, 3, 2)$ 的最大连续子序列积为 $3 \times 2= 6$ ，递归求出右部分 $(4, 1, -5)$ 的最大连续子序列积为 $4 \times 1 = 4$ ，再求出以 $a[mid] = 2$ 为中心的、最大连续子序列积为 $3 \times 2 \times 4 \times 1 = 24$ ，最终结果为 $\max \{ 6, 4, 24\} = 24$ 。
> <b></b>
> 为什么求最大连续子序列积不能采用上述分治法求解、而求最大连续子序列和可以呢？这是因为这两个问题都是求最优解，采用分治法求最优解需要满足**最优性原理**，即**整个问题的最优解由各个子问题的最优解构成**。显然，求最大连续子序列和问题满足最优性原理，而求最大连续子序列积并不满足最优性原理——例如，当 $x > 0, y < 0$ 时有 $x + y \le x, x \times y \le x$ ，当 $x < 0, y <0$ 时有 $x + y \le x, x\times y \ge x$ 。  

## 3.4.2 求解棋盘覆盖问题
【问题描述】有一个 $2^k \times 2^k\ (k > 0)$ 的棋盘，恰好有一个方格与其他方格不同，称之为特殊方格。现在要用如图3.10所示的 $L$ 形骨牌覆盖除了特殊方格以外的其他全部方格，骨牌可以任意旋转，并且任何两个骨牌不能重叠。请给出一种覆盖方法。 
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/b33303c4a4db4c20bf571dbd5eef4ca6.png)

【问题求解】棋盘中的方格数 $=2^k \times 2^k = 4^k$ ，覆盖使用的 $L$ 形骨牌个数 $= (4^k - 1)/3$ 。采用的方法是，将棋盘划分为大小相同的四个象限，根据特殊方格的位置 $(dr, dc)$ ，在中间位置放置一个合适的 $L$ 形骨牌。例如，如图3.11(a)所示，特殊方格在左上角象限中，在中间放置一个覆盖其他三个象限中各一个方格的 $L$ 形骨牌。图3.11(b)到图3.11(d)是特殊方格在其他象限中时放置 $L$ 形骨牌的情况。
![在这里插入图片描述](https://img-blog.csdnimg.cn/5eb309b04c0a454eb17e17101840caf4.png)
这样每个象限和包含特殊方格的象限类似，都需要少覆盖一个方格，也与整个问题类似，所以采用分治法求解，将原问题分解为四个子问题。

==用 $(tr, tc)$ 表示一个象限左上角方格的坐标，$(dr, dc)$ 是特殊方格所在的坐标，$size$ 是棋盘的行数和列数==。用二维数组 $board$ 存放覆盖方案，用全局变量 $tile$ 表示 $L$ 形骨牌的编号（从整数 $1$ 开始），$board$ 中三个相同的整数表示一个 $L$ 形骨牌。

对应的完整程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1025;
// 问题表示
int k;										 					// 棋盘大小
int x, y;														// 特殊方格的位置
// 求解问题表示
int board[MAXN][MAXN];
int tile  = 1;													// L形骨牌的编号,从1开始
void chessBoard(int tr, int tc, int dr, int dc, int size) {
	if (size == 1) return;										// 递归出口
	int t = tile++;												// 取出一个L形骨牌,其牌号为tile
	int half = size / 2;										// 分割棋盘
	// 考虑左上角象限
	if (dr < tr + half && dc < tc + half) 						// 特殊方格在此象限中
		chessBoard(tr, tc, dr, dc, half);	
	else {														// 此象限中无特殊方格
		board[tr + half - 1][tc + half - 1] = t;				// 用t号L形骨牌覆盖左上角的右下角
		chessBoard(tr, tc, tr + half - 1, tc + half - 1, half); // 将右下角作为特殊方格,继续处理该象限
	}
	// 考虑右上角象限
	if (dr < tr + half && dc >= tc + half) 						// 特殊方格在此象限中
		chessBoard(tr, tc + half, dr, dc, half);	
	else {														// 此象限中无特殊方格
		board[tr + half - 1][tc + half] = t;				 	// 用t号L形骨牌覆盖右上角的左下角
		chessBoard(tr, tc + half, tr + half - 1, tc + half, half); 	// 将右下角作为特殊方格,继续处理该象限
	}
	// 处理左下角象限
	if (dr >= tr + half && dc < tc + half)						// 特殊方格在此象限中
		chessBoard(tr + half, tc, dr, dc, half);
	else {														// 此象限中无特殊方格
		board[tr + half][tc + half - 1] = t;					// 用t号L形骨牌覆盖左下角的右上角
		chessBoard(tr + half, tc, tr + half, tc + half - 1, half); // 将右上角作为特殊方格,继续处理该象限	
	}
	// 处理右下角象限
	if (dr >= tr + half && dc >= tc + half) 					// 特殊方格在此象限中
		chessBoard(tr + half, tc + half, dr, dc, half);
	else {														// 此象限中无特殊方格
		board[tr + half][tc + half] = t;						// 用t号L形骨牌覆盖右下角的左上角
		chessBoard(tr + half, tc + half, tr + half, tc + half, half); // 将左上角作为特殊方格,继续处理该象限
	}
}

int main() {
	k = 3;
	x = 1, y = 2;
	int size = 1 << k;
	chessBoard(0, 0, x, y, size);
	for (int i = 0; i < size; ++i) {							// 输出覆盖方案
		for (int j = 0; j < size; ++j) 
			printf(" %4d", board[i][j]);
		printf("\n");
	}
	return 0;
}
```
上述程序的执行结果如图3.12所示，这里 $k = 3$ ，其中值相同的 $3$ 个方格为一个 $L$ 形骨牌，值为 $0$ 的方格是特殊方格。
![在这里插入图片描述](https://img-blog.csdnimg.cn/d52c9fd6e3ff4e9f96142839cf83b5b5.png)

【算法分析】用 $T(k)$ 表示 $2^k \times 2^k\ (k \ge 0)$ 的棋盘问题的求解时间，有：
```cpp
T(k) = 1				// 当k=0
T(k) = 4T(k-1)			// 当k>0 
```
求出 $T(k)= O(4^k)$ 。
## 3.4.3 求解循环日程安排问题
【问题描述】设有 $n = 2^k$ 个选手要进行网球循环赛，设计一个满足以下要求的比赛日程表：
1. 每个选手必须与其他 $n - 1$ 个选手各赛一次。
2. 每个选手一天只能赛一次。
3. 循环赛在 $n - 1$ 天之内结束。

【问题求解】按问题要求，可将比赛日程表设计成一个 $n$ 行 $n - 1$ 列的二维表，其中第 $i$ 行、第 $j$ 列表示「和第 $i$ 个选手在第 $j$ 天比赛的选手」。假设 $n$ 位选手被顺序编号为 $1, 2, \dots, n=2^k$ 。当 $k = 1, 2, 3$ 时比赛日程表如图3.13所示，其中第 $1$ 列是现在增加的，取值为 $1 \sim n$ 对应各位选手，这样比赛日程表变成一个 $n$ 行 $n$ 列的二维表。
![在这里插入图片描述](https://img-blog.csdnimg.cn/07eafd2bebca42d79d8ec218166935ee.png)
从中可以看出规律，$k=1$ 即只有两个选手时比赛安排十分简单，而 $k=2$ 可以基于 $k=1$ 的结果进行安排，$k=3$ 时可以基于 $k=2$ 的结果进行安排。看一看 $k=3$（即 $8$ 个选手）的比赛日程表，==右下角（ $4$ 行 $4$ 列）的值等于左上角的值（等于 $k = 2$ 即 $4$ 个选手的比赛日程表），左下角的值（ $4$ 行 $4$ 列）的值等于右上角的值（等于 $k=3$ 的左上角对应元素加上数字 $4$ ）==。

因此，采用分治策略，可以将所有的选手分为两半，$2^k$ 个选手的比赛日程表就可以通过为 $2^{k-1}$ 个选手设计的比赛日程来决定。将 $n = 2^k$ 问题划分为四个部分：
1. **左上角**：左上角为 $2^{k-1}$ 个选手在前半程的比赛日程。在 $k = 1$ 时直接给出，否则上一轮求出的就是 $2^{k-1}$ 个选手的比赛日程。
2. **左下角**：左下角为另 $2^{k-1}$ 个选手在前半程的比赛日程，由左上角加 $2^{k-1}$ 得到。例如 $2^2$ 个选手比赛，左下角由左上角直接加 $2^{k-1} = 2$ 得到；$2^3$ 个选手比赛，左下角由左上角直接加 $2^{k-1} = 4$ 得到。
3. **右上角**：将左下角直接复制到右上角，得到 $2^{k-1}$ 个选手在后半程的比赛日程。
4. **右下角**：将左上角直接复制到右下角，得到另 $2^{k-1}$ 个选手在后半程的比赛日程。

对应的完整程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 101;
// 问题表示
int k;
// 求解结果表示
int a[MAXN][MAXN];					// 存放比赛日程表(行、列下标为0的元素不用）
void Plan(int k) {
	int n = 2;						// n从2^1=2开始
	a[1][1] = 1; a[1][2] = 2; 		// 求解两个选手的比赛日程,得到左上角元素
	a[2][1] = 2; a[2][2] = 1;
	for (int t = 1; t < k; ++t) { 	// 迭代处理,依次处理2^2(t=1),...,2^k(t=k-1)个选手
		int tmp = n;				// tmp=2^t
		n = n * 2;					// n=2^(t+1)
		for (int i = tmp + 1; i <= n; ++i)
			for (int j = 1; j <= tmp; ++j)
				a[i][j] = a[i - tmp][j] + tmp;	// 左下角元素和左上角元素的对应关系
		for (int i = 1; i <= tmp; ++i)			// 填右上角元素
			for (int j = tmp + 1; j <= n; ++j)
				a[i][j] = a[i + tmp][(j + tmp) % n];
		for (int i = tmp + 1; i <= n; ++i)		// 填右下角元素
			for (int j = tmp + 1; j <= n; ++j) 
				a[i][j] = a[i - tmp][j - tmp];
	}
}

int main() {
	k = 3;
	int n = 1 << k;					// n为2的k次方,即n=2^k
	Plan(k);						// 产生n个选手的比赛日程表
	for (int i = 1; i <= n; ++i) {	// 输出比赛日程表
		for (int j = 1; j <= n; ++j)
			printf("%4d", a[i][j]);
		printf("\n");
	}
	return 0;
}
```
这里 $k = 3$ ，执行程序的输出结果如图3.13 c)所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/64b7edc339fc44959a642923b44a1f5b.png)

【算法分析】用 $T(k)$ 表示 $2^k$ 个选手网球循环赛问题的求解时间，有：
```cpp
T(k) = 1			// 当k=1
T(k)= 4T(k-1)		// 当k>1
```
求出 $T(k)= O(4^k)$ 。

---
# 3.5 求解大整数乘法和矩阵乘法问题
## 3.5.1 求解大整数乘法问题
【问题描述】设 $X, Y$ 都是 $n$（为了简单，假设 $n$ 为 $2$ 的幂，且 $X, Y$ 均为正数）位的二进制整数， 现在要计算它们的乘积 $X \times Y$ 。当位数 $n$ 很大时，可以用传统方法设计一个计算乘积 $X \times Y$ 的算法，但是这样做计算步骤太多，显得效率很低，此时可以用分治法来设计已给更有效的大整数乘积算法。 

【问题求解】先将 $n$ 位的二进制整数 $X, Y$ 各分为两段，每段的长为 $n / 2$ 位，如图3.14所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c9a5d77eb78a4e3d90e49f63109c3d4f.png)
由此，$X = A\times 2^{n/2} + B,\ Y= C \times 2^{n/2} +D$ 。这样 $X, Y$ 的乘积如：
$$X \times Y = (A\times 2^{n/2} + B) \times (C\times 2^{n/2} + D) \\
= A\times C \times 2^n + (A \times D + C\times B) \times 2^{n/2} + B\times D$$ 如果这样计算 $X \times Y$ ，则必须进行 $4$ 次 $n/ 2$ 位整数的乘法（ $A \times C, A \times D, B\times C, B\times D$ ）、以及 $3$ 次不超过 $n$ 位的整数加法，此外还要做两次移位（分别对应乘 $2^n, 2^{n/2}$ ）。这些加法和移位共用 $O(n)$ 步运算。设 $T(n)$ 是两个 $n$ 位整数相乘所需的运算总数，则有以下递推式：
```cpp
T(n) = O(1)					当n=1时
T(n) = 4T(n/2) + O(n)		当n>1时
```
由此可得 $T(n) = O(n^2)$ 。这种分治法求解 $X \times Y$ 对应的完整程序如下（注意：当 $n$ 很大时必须用整型数组来存放 $X, Y$ 的各位）：
![在这里插入图片描述](https://img-blog.csdnimg.cn/931c206d4cdb4fe298de06004bf0920c.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/678b5356419f4511b976a3e867445158.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/13f2a957bb114762bd0da9af7f07f1fe.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/3d31707905fc43028715ca91567aff9a.png)
本程序的执行结果如下：

## 3.5.2 求解矩阵乘法问题
【问题描述】对于两个 $n\times n$ 的矩阵 $A$ 和 $B$ ，计算 $C = A\times B$ 。

【问题求解】常用的计算公式是 $C_{ij} = \sum^n_{k=1} A_{ik}B_{kj}$ ，对应算法的时间复杂度为 $O(n^3)$ 。那么是否存在更有效的算法呢？假设 $n = 2^k$ ，考虑采用分治法思路，当 $n \ge 2$ 时将 $A, B$ 分成 $4$ 个 $n/ 2\times n / 2$ 的矩阵：
$$A = \begin{bmatrix}
A_{11} & A_{12} \\
A_{21} & A_{22} \\
\end{bmatrix} , 
B = \begin{bmatrix}
B_{11} & B_{12} \\
B_{21} & B_{22} \\
\end{bmatrix},
C = \begin{bmatrix}
C_{11} & C_{12} \\
C_{21} & C_{22} \end{bmatrix}$$ 根据块矩阵的乘法，矩阵 $C$ 可表示为：
$$C = \begin{bmatrix}
A_{11}B_{11} + A_{12}B_{21} & A_{11}B_{12} + A_{12}B_{22} \\
A_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22} B_{22} \end{bmatrix}$$ 因此，原问题可以划分成计算八个子问题的乘积问题，两个 $n \times n$ 矩阵乘积的计算量，将是两个 $n / 2 \times n / 2$ 矩阵乘积计算量的 $8$ 倍、再加上 $n / 2 \times n / 2$ 阶矩阵相加的 $4$ 倍，后者最多需要 $O(n^2)$ ，因此有：
$$T(n) = \begin{cases}
O(1) \quad& 当n=1时 \\
8T(n/2) + O(n^2) \quad& 当n>1时 \end{cases}$$

 可以推导出 $T(n) = O(n^3)$ 。也就是说，它跟前面介绍的、两个矩阵直接相乘的计算量，没有什么差别。那么是否可以算得更快呢？*Strassen* 通过研究分析，提出了 *Strassen* 算法，其思路为——要计算矩阵乘积：$$C =  \begin{bmatrix}
A_{11} & A_{12} \\
A_{21} & A_{22} \\
\end{bmatrix}  \begin{bmatrix}
B_{11} & B_{12} \\
B_{21} & B_{22} \\
\end{bmatrix}$$  只需要计算：$$C = \begin{bmatrix} d_1 + d_4 - d_5 + d_7 & d_3 + d_5 \\ d_2 + d_4 & d_1 + d_3 - d_2 + d_6\end{bmatrix}$$

其中：$$\begin{aligned}
&d_1 = (A_{11} + A_{22}) (B_{11} + B_{22}) \\
&d_2 = (A_{21} + A_{22}) B_{11} \\
&d_3 = A_{11} (B_{12} - B_{22}) \\
&d_4 = A_{22} (B_{21} - B_{11})  \\
&d_5 = (A_{11} + A_{12}) B_{22} \\
&d_6 = (A_{21} - A_{11}) ( B_{11} + B_{12}) \\
&d_7 = (A_{12} - A_{22}) (B_{21} + B_{22}) \end{aligned}$$ 

【算法分析】由上面可知，两个 $n \times n$ 矩阵乘积的计算量，是两个 $n / 2 \times n / 2$ 矩阵乘积计算量的 $7$ 倍，再加上它们进行加或减运算的 $18$ 倍，加减计算量共需要 $O(n^2)$ 。因此有：
$$T(n) = \begin{cases}
O(1) \quad& 当n=1时 \\
7T(n/2) + O(n^2) \quad& 当n>1时 \end{cases}$$ 可以推导出 $T(n) = O(n^{\log_2 7}) = O(n^{2.81})$（使用主定理），因此 *Strassen* 算法的效率更高。

---
# 3.6 并行计算简介
## 3.6.1 并行计算概述
传统计算机是串行结构，每一时刻只能按一条指令、对一个数据进行操作，在传统计算机上设计的算法称为**串行算法**。并行算法是「用多台处理器联合求解问题」的方法和步骤，其执行过程是**将给定的问题首先分解成若干个尽量相互独立的子问题，然后使用多台计算机同时求解它，从而最终求得原问题的解**。

为了利用并行计算，通常计算问题表现出以下特征：
1. **将工作分离成离散部分，有助于同时解决**。例如，对于分治法设计的串行算法，可以将各个独立的子问题并行求解，最后合并成整个问题的解，从而转化为并行算法。
2. **随时并及时地执行多个程序指令**。
3. **多计算资源下，解决问题的耗时要少于单个计算资源下的耗时**。

## 3.6.2 并行计算模型
并行计算模型通常指**从并行算法的设计和分析出发，将各种并行计算机（至少某一类并行计算机）的基本特征抽象出来，形成一个抽象的计算模型**。从更广的意义上来说，并行计算模型为并行计算提供了硬件和软件界面，在该界面的约定下，并行系统硬件设计者和软件设计者、可以开发对并行性的支持机制，从而提高系统的性能。

并行算计设计是基于并行计算模型的，下面简要介绍目前常见的两种并行计算模型。
### 1. `PRAM` 模型
**随机存取并行机器** `Parallel Random Access Machine` 模型，也称为共享存储的 `SIMD`（单指令流多数据流）模型，是一种抽象的并行计算模型，它是从串行的 `RAM` 模型直接发展起来的。在这种模型中，假定有一个无限大容器的共享存储器，并且有多个功能相同的处理器，且它们都具有简单的算术运算和逻辑判断功能，在任意时刻各个处理器可以访问共享存储单元。

### 2. `BSP` 模型
**整体同步并行** `Bulk Synchronous Parallel, BSP` 模型是分布存储的 `MIMD`（多指令流多数据流）计算模型，由哈佛大学的 *Viliant* 和牛津大学的 *Bill McColl* 提出。一台 `BSP` 计算机由 $n$ 个处理器/存储器（结点）组成，通过互联网络进行通信，如图3.15所示。

一个 `BSP` 程序有 $n$ 个进程，每个进程驻留在一个结点上，程序按严格的**超步**（可以理解为并行计算中子问题的求解）顺序执行，如图3.16所示。超步间采用路障同步，每个超步分成以下有序的三个部分：
1. **计算**：一个或多个处理器执行若干个局部计算操作，操作的所有数据只能是局部存储器中的数据。一个进程的计算与其他进程无关。
2. **通信**：处理器之间相互交换数据，通信总是以点对点的方式进行；
3. **同步**：确保「通信过程中交换的数据」被传送到目的处理器上，并使一个超步中的计算和通信操作全部完成后，才能开始下一个超步中的任何动作。
![在这里插入图片描述](https://img-blog.csdnimg.cn/91bb9166bc4748b88e283300c25a9a72.png)

`BSP` 模型总的执行时间，等于各超步执行时间之和。
## 3.6.3 快速排序的并行算法
基于 `BSP` 模型，快速排序算法并行化的一个简单思想是，**对每次划分后所得到的两个序列、分别使用两个处理器完成递归排序**。例如，对一个长为 $n$ 的序列，首先划分得到两个长为 $n / 2$ 的序列，将其交给两个处理器分别处理；然后进一步划分得到四个长为 $n / 4$ 的序列，再分别交给四个处理器处理；如此递归下去，最终得到排好序的序列。当然，这里说的是理想的划分情况，如果划分步骤不能达到平均分配的目的，那么排序的效率会相对较差。

以下算法描述了使用 $2^m$ 个处理器，完成对 $n$ 个输入数据（即 $a[0...n - 1]$ ）排序的并行算法：
```cpp
void ParaQuickSort(int a[], int i, int j, int m, int id) {
	if (j - i <= k || m == 0) 			// 若排序数据个数足够少或m=0(只有一个处理器)
		Pid执行QuickSort(a, i, j);		// 在Pid处理器上直接执行传统快速排序算法
	else {
		Pid执行r = Partition(a, i, j);	// 在Pid处理器上执行一趟划分
		Pid发送a[r+1, m-1]数据到Pid+2^(m-1)
		ParaQuickSort(a, i, r - 1, m - 1, id);
		ParaQuickSort(a, r + 1, j, m - 1, id + 2^(m-1));
		Pid+2^(m-1)发送a[r+1, m-1]到Pid;
}
int main() {
	ParaQuickSort(data, 0, n - 1, m, 0);
	return 0;
}
```
在最好情况下，该并行算法形成一个高度为 $\lceil \log_2 n \rceil$ 的排序树，其计算时间复杂度为 $O(n)$ 。和串行算法一样，在最坏情况下时间复杂度降为 $O(n^2)$ 。正常情况下该算法的平均时间复杂度为 $O(n)$ 。
 

---
![在这里插入图片描述](https://img-blog.csdnimg.cn/99683cf462534659b8d0cdb8b4af9e24.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/d66b21911d76407e966c2ddfbd1bf812.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/b6629840626645748e4238d92002db46.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/865efa4cdc094c31a747e9ed5b7d7908.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/43000af47d2f487f95e6e1460a3d9b94.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/525e5bf3838249eebc3d61fb5b7b172d.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/6227fc47904b46259ee8a5d93dce1e52.png)

