@[toc]

---
# 1. MD5算法概述
## 1.1 MD5简介、相关文件和术语
所谓的MD4（1990 RFC 1186）和MD5 `Message-Digest Algorithm 5`（信息摘要算法5，1992 RFC 1321）均由 `Ron Rivest` 发明，MD5算法是MD4算法的一个扩展，稍微慢一些，在设计上更“保守”，以此换取更大的最终安全性。由于MD5算法不需要任何大型替换表 `large substitution table` ，它的编码相当简洁。

> `RFC(Request For Comments)` 是一系列以编号指定的文件（征求评议文件），包含了关于互联网的几乎所有重要的文字资料，享有网络知识圣经之美誉。RFC文件只有新增，不会有取消或中途停止发行的情形。
> <b></b>
> 以MD5算法为例，可以在[官网](https://www.rfc-editor.org/)搜索到，本文参考的资料主要来源于此：![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062207384032.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

MD5算法接受**任意长度的消息**作为输入，并将输入信息的**128位指纹或信息摘要 `fingerprint/message digest`** 作为输出。在计算上，产生具有**相同信息摘要**的两个**不同消息**，或者产生具有**预先给定的目标信息摘要**的任何消息（信息摘要过程不可逆），是不可行的。MD5算法被广泛使用于 `Digital signature application` 数字签名应用程序中，在DSA中，一个大文件在某个公钥加密系统中使用一个私钥加密前，需要以一种安全的方式“压缩”。

相关的术语如下所示：
- 一个字 $word$ 是一个 $32$ 位的二进制数，一个字节 $byte$ 是一个 $8$ 位的二进制数；位序列可以以一种自然的方式解释为一个字节序列，其中每连续 $8$ 位比特被解释为一个字节，每个字节的最高位在前面；字节序列类似地可被解释为一个字序列，其中每连续 $4$ 个字节被解释为一个字，每个字的最低位先被给出，即**遵循小端序**。
- $+$ 被视为字在模 $2^{32}$ 意义下的加法，即将每个字视作无符号数，C++中两个无符号整型数的加法，在越界时会自然溢出，相当于对 $2^{32}$ 取模。
- $X <<< s$ 表示 $X$ 左循环（旋转） $s$ 位得到的32位值，此时 $X$ 最高位在左，最低位在右部；
- $not(X)$ 表示对 $X$ 按位取反，$or(X, Y)$ 表示 $X$ 和 $Y$ 的按位或，$xor(X,Y)$ 表示按 $X$ 和 $Y$ 按位异或，$and(X, Y)$ 表示 $X$ 和 $Y$ 按位与； 
 
## 1.2 MD5算法流程
首先假设有一个 $b\ (b \in \N )$ 位的消息作为输入，我们希望得到它的信息摘要，注意 $b$ 不必是 $8$ 的倍数，可以为任意非负整数。整个消息的位序列记为 $m_0\ m_1 \dots m_{b-1}$ ，使用 `little-endian` 小端模式。然后依次执行下面的五个步骤，来计算消息的摘要：
1. 填充比特 `Append Padding Bits` 
2. 附加长度 `Append Length`
3. 初始化MD缓冲区 `Initialize MD Buffer` 
4. 以16字为块处理消息 `Process Message in 16-word Blocks` 
5. 输出 `Output` 

### 1.2.1 填充比特 `Append Padding Bits`
首先需要通过填充 `padding` 扩展消息，使得消息的长度模 $512$ 为 $448$ 。 **填充总是被执行 `Padding is always performed` ，即使消息的长度已经模 $512$ 后等于 $448$** 。总之，要让整个消息在扩展后距离512位的倍数只差 $64$ 位。

填充的方法很简单，先在消息后面加一个 $1$ 位，然后不断添加 $0$ 位，使得填充后消息的位长度 $\bmod\ 512 == 418$  。总体上而言，**至少要添加 $1$ 位，最多添加 $512$ 位。**

### 1.2.2 附加长度 `Append Length`
完成位填充后的消息 $b$ ，表示为 $64$ 进制形式。

b的64位表示（添加填充位之前的消息长度）附加到上一步的结果中。如果b大于2^64，则只使用b的低位64位(根据先前的约定，这些位被附加为两个32位字，并首先附加低阶字。）

此时，生成的消息（在用位和b填充之后）的长度是512位的精确倍数。等价地，此消息的长度是16（32位）字的精确倍数。让M[0。。。N-1]表示结果消息的字，其中N是16的倍数。

### 1.2.3 初始化MD缓冲区 `Initialize MD Buffer` 
由于最终结果是一个 $128$ 位的信息摘要，这里我们使用一个长度为 $4$ 个字的缓冲区 $(A, B, C, D)$ 来计算结果，此处 $A, B, C, D$ 全部为 $32$ 位的寄存器，初始化为下面的 $16$ 进制值，小端优先。
```cpp
word A: 01 23 45 67
word B: 89 ab cd ef
word C: fe dc ba 98
word D: 76 54 32 10
```

### 1.2.4 以16字为块处理消息 `Process Message in 16-word Blocks` 
我们首先需要定义四个负债函数，每个函数都接受三个字，每个字长度为 $32$ 位，返回一个 $32$ 位的字作为结果。
```cpp
F(X, Y, Z) = or(and(X, Y), and(not(X), Z))  
G(X, Y, Z) = or(and(X, Z), and(Y, not(Z))) 
H(X, Y, Z) = xor(xor(X, Y), Z)
I(X, Y, Z) = xor(Y, or(X, not(Z)))
```

### 1.2.5 输出 `Output` 
最后的输出 $(A, B, C, D)$ 就是信息摘要，我们从 $A$ 的低位开始，一直输出到 $D$ 的高位。

## 1.3 算法总结
MD5消息摘要算法易于实现，并且能为任意长度的消息，提供一个指纹或信息摘要。要想得到两条具有相同消息摘要的不同消息，难度大约为 $2^{64}$ 次操作；要想得到任何具有给定消息摘要的消息，难度大约为 $2^{128}$ 次操作。 


---
# 2.
