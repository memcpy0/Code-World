**具有线性阶段划分的动态规划算法，统称为线性DP**（是一个广义概念，不局限于线性时间复杂度的一维动态规划。与数学中的线性空间类似，如果一个动态规划算法的“状态”包含多个维度，但在每个维度上都具有“线性”变化的“阶段”，那么该动态规划算法同样称为“线性DP”。

对于最长上升子序列LIS、最长公共子序列LCS和数字三角形IOI1994等DP的经典入门题目不会陌生。入门书籍和网络上容易找到这些问题的描述和解答。这里不会花费时间再详细解释这些问题，但可以简单回顾它们，并尝试分析一下DP要素在其中的体现。

| 问题 | 说明 | 其他|
|:---|:---|:---|
| LIS问题 | 问题描述 | 最长上升子序列。给定一个长度 $N$ 的数列 $A$ ，求数值单调递增的子序列的长度最长是？ | 
| | 状态表示| $F[i]$ 表示以 $A[i]$ 结尾的「最长上升子序列」的长度
|  |阶段划分| **子序列的结尾位置**（数列 $A$ 中的位置，从前往后）
|  | 转移方程 | $F[i] =\displaystyle \max_{0 \le j < i,\ A[j] < A[i]} { F[j] + 1}$ 
|  | 边界 | $F[0] = 0$
| | 目标 | $\displaystyle \max_{1 \le i \le N} {F[i]}$ 
| LCS问题| 问题描述 | 最长公共子序列。给定两个长度分别为 $N, M$ 的数列 $A, B$ ，求既是 $A$ 的子序列又是 $B$ 的子序列的字符串长度最长是？ | 
| | 状态表示| $F[i, j]$ 表示前缀子串 $A[1,i]$ 与 $B[1, j]$ 的「最长公共子序列」的长度
|  |阶段划分| **已经处理的前缀长度**（两个字符串中的位置，即一个二维坐标）
|  | 转移方程 | $F[i,j] =\displaystyle \max \begin{cases} F[i - 1, j] \\ F[i, j-1] \\ F[i-1,j-1]+1\quad \texttt{if}\ A[i] = B[j] \end{cases}$ 
|  | 边界 | $F[i,0] =F[0,j] = 0$
| | 目标 | $F[N,M]$
| 数字三角形 | 问题描述 | 给定一个共有 $N$ 行的三角矩阵 $A$ ，其中第 $i$ 行有 $i$ 列，从左上角出发每次可以向下方或右下方走出一步，最终到达底部。求把经过的所有位置上的数加起来，和最大是多少？
| | 状态表示 | $F[i,j]$ 表示从左上角走到第 $i$ 行第 $j$ 列，和最大是多少
| | 阶段划分 | **路径的结尾位置**（矩阵中的行、列位置，即一个二维坐标）
 || 转移方程| $F[i,j] = A[i, j] + \max \begin{cases} F[i - 1, j] \\ F[i - 1, j - 1] \quad \texttt{if}\ j > 1 \end{cases}$ 
 | | 边界| $F[1, 1] = A[1, 1]$ 
 | | 目标 | $\displaystyle \max_{1\le j \le N}\{  { F[N, j] }\}$ 

容易发现，无论状态表示是一维还是多维，DP算法在这些问题上都体现为“作用在线性空间上的递推”——DP的阶段沿着各个维度线性增长，从一个或多个“边界点”开始有方向地向整个状态空间转移、扩展，最后**每个状态上都保留了以自身为“目标”的子问题的最优解**。

这几个问题也是线性DP中最简单的一类，在这类问题中，需要计算的对象表现出明显的维度以及有序性，**每个状态的求解直接构成一个阶段**，这使得DP的状态表示就是阶段的表示。因此，我们只需要在每个维度上各取一个坐标值作为DP的状态，自然就可以描述出“已求解部分”在状态空间中的轮廓特征，该轮廓的进展就是阶段的推移。另外，每个状态的求解显然只与之前阶段的最优解有关，最优子结构性质也得以验证。接下来，我们按顺序依次循环每个维度，根据问题要求来递推求解的具体实现过程也就顺理成章了。

### 【例题】Mr. Young's Picture Permutations POJ2279
有 $N$ 个学生合影，站在左端对齐的 $k$ 排，每排分别有 $N_1, N_2, \dots, N_k$ 个人，第 $1$ 排站在最后边，第 $k$ 排站在最前边。学生的身高互不相同，把他们从高到低依次标记为 $1, 2, \dots, N$ 。在合影时要求每一排从左到右身高递减，每一列从后到前身高也递减，问一共有多少种安排合影位置的方案？$N \le 30, k \le 5$ 。

下面一排三角矩阵给出了当 $N = 6, k = 3, N_1 = 3, N_2 = 2, N_3 = 1$ 时的全部 $16$ 种合影方案。注意身高最高的是 $1$ ，最低的是 $6$ 。
```
123 123 124 124 125 125 126 126 134 134 135 135 136 136 145 146
45  46  35 
```
TODO！

因为在合法的合影方案中每行、每列的身高都是单调的，所以我们可以从高到低、依次考虑标记为 $1, 2, \dots N$ 的学生站的位置。这样一来，在任意时刻，已经安排好位置的学生，在每一行中占据的一定是从左端开始的、连续若干个位置，用一个 $k$ 元组 $(a_1, a_2, \dots, a_k)$ 表示每一行已安排的学生人数，即可描绘出“已经处理的部分”的轮廓。

当安排一名新的学生时，我们考虑所有满足如下条件的行号 $i$ ：
1. $a_i < N_i$ 
2. $i = 1$ 或 $a_{i-1} > a_i$ 

只要该学生站在这样一行中，每列学生的身高单调性也就得以满足。即我们不需要关心已经站好的 $(a_1 + a_2 + \dots a_k)$ 名学生的具体方案。$k$ 元组 $(a_1, a_2, \dots, a_k)$ 描绘的轮廓内的合影方案总数就足以构成一个子问题。因此，我们可以把 $a_1, a_2, \dots, a_k$ 作为阶段，当安排一名新的学生时 $a_1, a_2, \dots, a_k$ 其中之一会增加 $1$ ，从而转移到后续的阶段，符合各维度线性增长的形式。

简便起见，我们假设 $k = 5$ 。当 $k < 5$ 时，我们可以增加人数为 $0$ 的排，使其等于 $k = 5$ 的问题。动态规划算法如下：
- $F[a_1, a_2, a_3, a_4, a_5]$ 表示各排从左端起，分别站了 $a_1, a_2, a_3, a_4, a_5$ 个人时，合影方案的数量。
- 边界：$F[0, 0, 0, 0, 0] = 1$ ，其余均为 $0$ .
- 目标：$F[N_1, N_2, N_3, N_4, N_5]$ 
- 转移：若 $a_1 < N_1$ ，则令 $F[a_1 + 1, a_2, a_3, a_4, a_5] += F[a_1, a_2, a_3, a_4, a_5]$ 。若 $a_2 < N_2$ 且 $a_1> a_2$ ，则令 $F[a_1, a_2 + 1, a_3 , a_4, a_5] += F[a_1, a_2, a_3, a_4, a_5]$ 。第 $3$ 到 $5$ 排同理。

本题还有一种数学解法：直接用“杨氏矩阵”和“勾长公式”进行计算。这里不再赘述。

从该题给出的解法中发现，设计动态规划的转移方程，不一定要以「如何计算出一个状态的形式」给出，也可以考虑「一个已知状态应更新哪些后续阶段的未知状态」。当然，对于本题来说，两种方式没有什么差别。在有的题目中，其中一种可能比另一种思考起来更加自然简便。

### 【例题】LCIS（最长公共上升子序列）CH5101
熊大妈的奶牛在小沐沐的熏陶下开始研究信息题。小沐沐先让奶牛研究了最长上升子序列，再让它们研究了最长公共子序列，现在又让它们研究最长公共上升子序列。

小沐沐说，对于两个数列 $A, B$ ，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。

奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。不过，只要告诉奶牛它的长度就可以了。数列 $A, B$ 的长度均不超过 $3000$ 。

这道题目是LIS与LCS的结合。回顾本节开头列举的LIS和LCS的动态规划状态表示，把二者相结合，容易想到如下解法：
- $F[i, j]$ 表示 $A[1, i]$ 与 $B[1, j]$ 可以构成的、以 $B_j$ 为结尾的LCIS的长度。不妨假设 $A_0 = B_0 = -\infty$ 。
- 当 $A_i \ne B_j$ 时，有 $F[i, j] = F[i - 1, j]$ 
- 当 $A_i = B_j$ 时，有 $$F[i, j] = \displaystyle \max_{0\le k< j,\ B_k < B_j} \{ F[i - 1, k] \} + 1 = \max_{0\le k < j,\ B_k < A_i}\{ F[i - 1, k] \} + 1$$
显然，上面的状态转移方程可以直接用三重循环计算（初始化部分省略）。
```cpp
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
        if (a[i] == b[j]) {
            for (int k = 0; k < j; ++k) 
                if (b[k] < a[i])
                    f[i][j] = max(f[i][j], f[i - 1][k] + 1);
        } else f[i][j] = f[i - 1][j];
    }
}
```
在转移过程中，我们把满足 $0 \le k < j,\ B_k < A_i$ 的 $k$ 构成的集合称为 $F[i, j]$ 进行状态转移时的决策集合，记为 $S(i, j)$ 。注意到，在第二层循环 $j$ 从 $1$ 增加到 $m$ 时，第一层循环 $i$ 是一个定值，这使得条件 $B_k < A_i$ 是固定的。因此，当变量 $j$ 增加 $1$ 时，$k$ 的取值范围从 $0 \le k < j$ 变为 $0 \le k < j+1$ ，即整数 $j$ 可能会进入新的决策集合。也就是说，我们只需要 $O(1)$ 地检查条件 $B_j < A_i$ 是否满足，已经在决策集合中的数则一定不会被去除：
$$S(i, j+1) = \begin{cases} S(i, j) \quad B_j \ge A_i \\
S(i, j)\cup \{ j\} \quad B_j < A_i\end{cases}$$
所以上面的状态转移方程只需要两重循环即可求解。最终的目标是 $\displaystyle \max_{1\le j\le m} F[n, j]$ 。
```cpp
for (int i = 1; i <= n; ++i) {
    // val是决策集合S(i,j)中f[i-1][k]的最大值
    int val = 0;
    // j=1时,0可以作为k的取值
    if (b[0] < a[i]) val = f[i - 1][0];
    for (int j = 1; j <= m; ++j) {
        if (a[i] == b[j]) f[i][j] = val + 1;
        else f[i][j] = f[i - 1][j];
        // j即将增大为j+1,检查j能否进入新的决策集合
        if (b[j] < a[i]) val = max(val, f[i - 1][j]);
    }
}
```
这道题转移部分的优化告诉我们，在实现状态转移方程时，要注意观察决策集合的范围随着状态的变化情况。==对于“决策集合中的元素只增加不减少”的情景，就可以像本题一样维护一个变量来记录决策集合的当前信息，避免重复扫描，把转移的复杂度降低一个量级==。

### 【例题】Making the Grade POJ3666
给定长度为 $N$ 的序列 $A$ ，构造一个长度为 $N$ 的序列 $B$ ，满足：
1. $B$ 非严格单调，即 $B_1 \le B_2 \le \dots \le B_N$ 或 $B_1 \ge B_2 \ge \dots \ge B_N$ 。
2. 最小化 $S = \sum_{i=1}^{N} | A_i - B_i |$ 。

只需要求出这个最小值 $S$ 。$1 \le N \le 2000, 1\le |A_i | \le 10^9$ 。

序列 $B$ 可能有“非严格单调递增“和”非严格单调递减“两种情况。我们分别进行一次求解，二者中较小的结果就是本题答案。下面以递增为例进行讲解，递减同理。
> 引理：在满足 $S$ 最小化的前提下，一定存在一种构造序列 $B$ 的方案，使得 $B$ 中的数值都在 $A$ 中出现过。
> 证明：数学归纳法。命题对 $N= 1$ 显然成立。
> 设引理对 $N= k - 1$ 成立。此时构造出的序列为 $B_1 , \dots, B_{k-1}$  
> 当 $N = k$ 时，若 $B_{k-1} \le A_k$ ，则令 $B_k = A_k$ ，满足单调性且命题仍成立。
> 否则，要么令 $B_k = B_k - 1$ ，命题仍成立。要么存在一个 $j$ ，令 $B_j, B_{j+1}, \dots, B_k$ 为同一个值 $v$ 。根据0x05节提到的「货仓选址」问题，设 $A_j, A_{j+1}, \dots, A_K$ 的中位数是 $mid$ ，若 $mid \ge B_{j-1}$ ，则有 $v=  mid$ ，否则应该有 $v=B_{j-1}$ 。无论哪种情况，$B_1, \dots, B_k$ 中的数都在 $A$ 中出现过。
> 证毕。

回到本题，我们依次考虑：完成前 $i\ (1 \le i\le N)$ 个数的构造时，$\sum_{j=1}^i |A_j - B_j|$ 的最小值。也就是**把DP的“阶段”设为已经处理完的前缀序列的长度**。在转移时，为了确定 $B_i$ 定为多少才能保证单调，我们还需要知道 $B_{i-1}$ 的大小。有两种常见的解决方案。

#### 方法1
仿照LIS问题，设 $F[i]$ 表示完成前 $i$ 个数的构造，**并且 $B_i = A_i$ 时** $S$ 的最小值。$$F[i] = \min_{0\le j < i,\ A[j] \le A[i] } \{ F[j] + cost(j + 1, i - 1)\}$$
其中 $cost(j + 1, i - 1)$ 表示构造 $B_{j+1}, \dots, B_{i-1}$ 、同时满足 $A_j \le B_{j+1} \dots \le B_{i-1} \le A_i$ 时，$\sum^{i-1}_{k=j+1} |A_k - B_k |$ 的最小值。

该解法的思路是，根据引理可知，最终 $B$ 序列由一段段 $A$ 中的数构成。上面DP中的 $i$ 就是当前最新一段数中与 $A$ 相同的位置，$j$ 是上一段数中这样的位置。因此，$cost(j+1, i-1)$ 就是把区间 $[j+1, i-1]$ 中前面的一部分变为 $A_j$ ，后面的一部分变为 $A_i$ ，所需要的最小代价。

注意，我们不需要考虑存在一个 $k \in [j+1, i - 1],\ [j + 1, i - 1]$ 中的一部分数变为 $A_k$ 的情况，因为该情况已经在 $j = k$ 时被上述DP方程涵盖。

采用朴素算法计算 $cost$ 值，总的时间复杂度为 $O(N^3)$ 。

#### 方法2
既然仅把DP的“阶段”要素（即已经处理的序列长度）放在DP状态中，不足以执行转移，一个直接的想法就是把 $B$ 序列的最后一个值也记录在DP状态里。设 $F[i, j]$ 表示完成前 $i$ 个数的构造，其中 $B_i = j$ 时，$S$ 的最小值。$$F[i, j]=\min_{0 \le k \le j} \{ F[i - 1, k] + |A_i - j|\}$$ 根据引理，我们可把 $A$ 序列中出现的数**离散化**，把DP状态中第二维 $j$ 的范围降低到 $O(N)$ 。另外，本题中的转移与上一道例题LCIS非常相似，决策集合只增多而不减少，$O(1)$ **即可实现转移**。故该算法的时间复杂度为 $O(N^2)$ 。

### 【思考题】
把一个序列 $A$ 变为非严格单调递增（单调不下降的），至少需要修改多少个数？
提示：序列 $A$ 的总长度减去 $A$ 的最长不下降子序列长度。

把一个序列 $A$ 变成严格单调递增的，至少需要修改多少个数？
提示：构造序列 $B[i] = A[i] - i$ ，答案为序列总长度减去 $B$ 的最长不下降子序列长度。
思考：为什么这样是正确的？为什么用序列总长度减去 $A$ 的LIS长度不对？

### 【例题】Mobile Service CH5102
一个公司有三个移动服务员，最初分别在位置 $1, 2,3$ 处。如果某个位置（用一个整数表示）有一个请求，那么公司必须指派某名员工赶到那个地方去。某一时刻只有一个员工能移动，且不允许在同样的位置出现两名员工。从 $p$ 到 $q$ 移动一名员工，需要花费 $c(p, q)$ 。这个函数不一定对称，但保证 $c(p, p) = 0$ 。

给出 $N$ 个请求，请求发生的位置分别为 $p_1 \sim p_N$ 。公司必须按顺序依次满足所有请求，目标是最小化公司花费，帮忙计算这个最小花费。$N\le 1000$ ，位置是 $1$ 到 $200$ 的整数。

使用动态规划解决本题，容易发现DP的“阶段”就是“已经完成的请求数量”。通过指派一名服务员，可以把一个“完成 $i -1$ 个请求”的状态，转移到“完成 $i$ 个请求”的状态。

为了计算指派服务员的花费，就必须要知道状态转移时每个服务员的位置。最直接的想法就是把三个服务员的位置也放在DP的“状态”中。设 $F[i, x, y, z]$ 表示：完成了前 $i$ 个请求，三个员工分别位于 $x, y, z$ 时公司当前最小花费。

考虑 $F[i, x, y, z]$ 能更新 $i+1$ 阶段的哪些状态。转移显然有三种，就是派三个员工之一去第 $i+1$个请求处。
$$\begin{aligned}
F[i + 1,\ p_{i+1},\ y,\ z] = \min(F[i + 1, p_{i+1}, y, z],\ F[i,x, y, z] + c(x, p_{i+1})) \\
F[i + 1,\ x,\ p_{i+1},\ z] = \min( F[i + 1, x, p_{i+1}, z],\ F[i, x, y, z] + c(y, p_{i+1} )) \\
F[i + 1,\ x,\ y,\ p_{i+1} ] = \min(F[i+1,\ x , y, p_{i+1}],\ F[i, x, y, z] + c(z, p_{i+1}))\end{aligned}
$$

题目要求同一位置不能出现两个员工，注意加上 $if$ 语句判断状态转移的合法性。

该算法的规模大约在 $1000 \times 200^3$ ，承受。观察可以发现，在第 $i$ 个请求完成时，一定有某个员工位于位置 $p_i$ ，只需要知道阶段 $i$ 和另外两个员工的位置即可描述一个状态，处于 $p_i$ 的员工位置对DP来说是冗余信息。

因此，可用 $F[i, x, y]$ 表示完成了前 $i$ 个请求，其中一个员工位于 $p_i$ ，另外两个员工处于 $x, y$ 时，公司当前最小花费。三种转移则分别是让位于 $p_i, x, y$ 的员工前往 $p_{i+1}$ 处理请求。
$$\begin{aligned}
F[i + 1,\ x,\ y] = \min(F[i + 1,\ x,\ y],\ F[i,x, y] + c(p_i,\ p_{i+1})) \\
F[i + 1,\ p_i,\ y] = \min( F[i + 1,\ p_i,\ y] ,\ F[i, x, y] + c(x, p_{i+1} )) \\
F[i + 1,\ x,\ p_i] = \min(F[i + 1,\ x,\ p_i] ,\ F[i, x, y] + c(y, p_{i+1}))\end{aligned}
$$

不妨设 $p_0 = 3$ ，于是初值可设为 $F[0, 1,2 ] = 0$ ，目标为 $F[N, ?, ?]$ 。与优化之前一样，也要根据题意判断状态转移的合法性，例如第一个转移应满足 $x, y, p_{i+1}$ 不相等。

这道题给我们两点启发：
1. 求解线性DP问题，一般先确定阶段。若阶段不足以表示一个状态，则可以把所需的附加信息也作为状态的维度。
    在转移时，若总是从一个阶段转移到下一个阶段（本题 $i$ 到 $i+1$ ），则没有必要关系附加信息维度的大小变化情况（本题 $x, y, z$ 在转移前后大小不定），因为无后效性已经由“阶段”保证。
2. 在确定DP状态时，要选择最小的、能覆盖整个状态空间的“维度集合”。
    若DP状态由多个维度构成，则应检查这些维度之间能否相互导出，用尽量少的维度覆盖整个状态空间，排除冗余维度。可以类比0x36节提到的“线性无关组”，例如本题，阶段 $i$ 和两个员工位置就可表明状态，另一个员工的位置可直接得出。

### 【例题】传纸条 CH5103
给定一个 $N\times M$ 的矩阵 $A$ ，每个格子中有一个整数。现在需要找到两条从左上角 $(1, 1)$ 到右下角 $(N, M)$ 的路径，路径上的每一步只能向右或向下走。路径经过的格子中的数会被取走，若两条路径同时经过一个格子，只能算一次。求取得的数之和最大是多少。$N, M\le 50$ 。

首先尝试寻找一个线性的“阶段”。考虑路径形成的过程，我们需要从左上角开始依次确定两条路径上的每一步如何走，直至到达右下角。把路径与前面问题中的序列类比，自然想到可以把“路径长度”，即当前走过的步数，作为DP的阶段。在每个阶段中，我们把两条路径同时扩展一步，路径长度增加 $1$ ，从而转移到下一个阶段。

除了路径长度外，还需要确定两条路径当前的末尾位置。设路径长度为 $i$ ，第一条路径末尾位于 $(x_1, y_1)$ ，第二条路径末尾位于 $(x_2, y_2)$ 。根据上一道例题的启发，为了找到能覆盖整个状态空间的最小的“维度集合”，我们检查上面五个值有何种关系，能否相互导出。容易发现有以下等式成立：
$$x_1 + y_1 = x_2 + y_2 = i + 2$$
故 $i, x_1, x_2$ 三个维度即可描述一个状态，其中 $1\le x_1, x_2\le \min(N, i+1)$ 。

设 $F[i, x_1, x_2]$ 表示两条路径长度均为 $i$ ，第一条路径末尾在第 $x_1$ 行，第二条路径末尾在第 $x_2$ 行时，已经取得的数之和的最大值。此时可推出 $y_1 = i+2-x_1, y_2=i+2-x_2$ 。

每条路径有向右、向下两种扩展方法，故共有 $2 \times 2= 4$ 种转移。以两条路径均往右扩展为例，其余三种情况同理。

如果 $x_1 = x_2$ 并且 $y_1+1=y_2+1$ ，那么两条路径进入同一个格子，只累加一次：
$$F[i+1, x_1, x_2] = \max(F[i+1,\ x_1,\ x_2],\ F[i,\ x_1,\ x_2] + A[x_1,\ y_1+1])$$
否则两条路径分别扩展到不同的格子，两个格子中的数都进行累加：
$$F[i+1,\ x_1,\ x_2] = \max(F[i+1,\ x_1,\ x_2],\ F[i,\ x_1,\ x_2] + A[x_1,\ y_1 + 1] + A[x_2,\ y_2 + 1])$$
初值为 $F[0, 1, 1] = A[1, 1]$ 。
目标为 $F[N + M - 2, N, N]$ 。
