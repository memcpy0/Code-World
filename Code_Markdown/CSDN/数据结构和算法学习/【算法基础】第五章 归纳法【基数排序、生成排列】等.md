@[toc]
 
# 一、引言
考虑一个带有参数 $n$ 的问题，在问题中 $n$ 通常表示事物的数目。当我们寻找这类问题的解时，有时候从求解一个小一点参数的相同问题开始，$e.g.$ $n-1, n/2$ ，然后再把解**推广**到包含所有的 $n$ 个物体。这样，问题的解决会比较容易些。这种方法**基于众所周知的数学归纳法证明技术**——如果我们知道如何求解 $\lt n$ 的相同问题(归纳假设)，我们的任务就转化为如何将解法扩展到带有 $n$ 的实例上。

事实上，归纳证明、递归算法、递推关系这几者之间存在着千丝万缕的联系。可以说，==归纳设计技术一般包括所有的递归算法设计，如分治和动态规划==。不过，我们先把注意力放在那些与数学归纳法非常相似的方法上。
 
归纳法设计的优点在于(一般地，对于所有的递归算法来说都是如此)，**所设计出的算法的正确性证明已自然地嵌入了算法的描述中了**。
 
下面，先用两个简单的例子来展示归纳法技术的本质。

---
# 二、Selection sort（选择排序）
## 1. 基本思想
令 $A[1..n,]$ 作为算法的输入，由归纳法**假设我们知道如何对后 $n-1$ 个元素排序，即对 $A[2..n]$ 排序**。

首先，存在某个 $j$， $1≤j ≤n$，$A[j]$ 是**最小值**，如果 $j≠1$，我们交换 $A[1]$ 和 $A[j]$；

然后由归纳法假设，我们已知如何对 $A[2..n]$ 排序，因此可对在 $A[2..n]$ 中的元素**递归地排序**。

这个由归纳法导出的算法可以很容易地转换为迭代形式。不过下面给出的是递归版本的。
## 2. 递归伪代码
<img src="https://img-blog.csdnimg.cn/20200419100420879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="60%">

## 3. 算法分析
计算上述的算法的元素比较总次数：令 $C(n)$ 表示元素比较的次数，显然，$C(1) = 0$。

过程 `sort` 第一次被调用时 $i = 1$ ，数组中有 $n$ 个元素，因此在这次调用中，元素比较的总次数由**两部分元素比较次数之和**组成，即 $n-1$ 次元素比较次数 $+$ 对 $A[2..n]$ 排序比较次数，后一比较次数是所有对 $sort ( i + 1)$ 的递归调用的**总和**。而从递归调用得到的**元素比较次数**是 $C(n-1)$ 。

因此有：
$$C(n) = \left\{
\begin{aligned}
0 \quad if\ n = 1\\
C(n-1) + (n - 1)\quad if\ n \ge 2
\end{aligned}
\right.
$$
这个递推式的解是：$$C(n) = \sum_{j = 1}^{n-1} j={ {n(n-1)} \over 2}$$
 
由于**运行时间**和**元素的比较次数**成线性关系，所以说它是 $\Theta(n^2)$ 的。

---
# 三、Insertion sort（插入排序）
## 1. 基本思想
这里阐述如何用归纳技术设计出这个算法。令算法的输入是 $A[1...n]$ ，假设我们知道如何对前 $n-1$ 个元素，也就是数组 $A[1..n-1]$ 排序。

那么在对 $A[1..n-1]$ 排序后，我们只要把 $A[n]$ 插人它的适当位置，假设是位置 $j,1≤j ≤n$ ，这个插人可能导致 $A[j+1], A[j+2] ,… ,A[n-1]$ 移到位置 $j+2，j+3，…，n$ ，即向后移动一个位置。 

由这个归纳原理引出的算法如下，同样，把这个算法转换成迭代形式也是很简单的。

## 2. 递归伪代码
<img src="https://img-blog.csdnimg.cn/2020041914530464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="65%">

## 3. 算法分析
易知，只有一个元素时，比较次数 $C(1) = 0$；

有 $n$ 个元素时：
- 最好的情况如下，每个元素比较一次就找到了位置，因此元素比较次数为递归调用 `sort(i-1)` 的比较次数之和 $+1$ ：
 $$C(n) = \left\{
 	\begin{aligned}
 	0 \quad if\ n = 1\\
 	C(n-1) + 1\quad if\ n \ge 2
 	\end{aligned}
 	\right.
 	$$
 	递推式的结果 $C(n) = n - 1$.
- 最坏的情况，$n-1$ 次元素比较 $+$ 递归调用 `sort(i-1)` 的元素比较次数之和。因此：
	 $$C(n) = \left\{
 	\begin{aligned}
 	0 \quad if\ n = 1\\
 	C(n-1) + n-1\quad if\ n \ge 2
 	\end{aligned}
 	\right.
 	$$
这个递推式的解是：$$C(n) = \sum_{j = 1}^{n-1} j={ {n(n-1)} \over 2}$$


---
# 四、Radix sort（基数排序）
基数排序，是一个性能比较稳定的算法，它几乎在所有的实际应用中都以线性时间运行。

>一般来说，如果能用 `STL` 的 $sort$ 就用；如果不能用，要手写的话，一般选择归并排序或者是基数排序。如果手写快速排序，很可能被特殊情况卡到怀疑人生。

虽然基数排序的实现有许多版本，但是这里不讨论基数排序的具体实现。
## 1. 基本思想   
令 $L=\{a1,a2,…,an\}$ 是一个有 $n$ 个数的集合，其中每个数**恰好**有 $k$ 位数字，就是说每个数具有 $d_kd_{k-1}…d_1$ 形式，这里 $di$ 是 $0$ 到 $9$ 中的一个数字。

在这个问题中，**我们对整数的大小 $k$ 施行归纳**，而不是对集合大小—— $n$ 这个对象来用归纳法。

一种方法是，**根据它们的最高位**把它们分类到 $10$ 个表 $L_0,L_1,...,L_9$ 中去，因此 $d_k = 0$ 的那些数就分到表 $L_0$ 中， $d_k = 1$ 的那些数就分到表 $L_1$ 中，等等。这一步完成后，对于每个 $i,  0≤i≤9$ ，$L_i$ 必然包含最高位是 $i$ 的那些数。

下面是我们的两种选择，
- 第一种选择，用另一种排序算法对每一个表排序，然后把排序得到的这些表连接成一个排序表。
在最坏的情况下，**所有的数字可能有相同的最高位**，这就意味着它们都在 $1$ 个表中，而其余的 $9$ 个表是空的。
因此如果表内排序用的算法需要 $\Theta(nlog n)$ 时间，则这种方法的运行时间将是 $\Theta(nlog n)$ 的。

- 另一种可能性是**对 $d_{k-1}$ 位上每张表递归排序**(因为按照高位分配，已经区分出了各个表的大小；如果继续按照低位进行分配，可能会改变前面的排序，造成错误)。
但这种方法将导致越来越多的附加表，这是很不方便的。

以上是我们不会使用的选择。

另一种方法是，我们**一开始就根据数的最低位把它们分配到那些表中**，这种方法被称为基数排序，能够得到一个非常优秀的算法结果。

对 $k$ 使用归纳法如下：
- 假设这些数关于它们的低 $k-1$ 位数 (即 $d_{k-1}, d_{k-2}, ...d_1$) 已经按照字典序排序，那么，在按照第 $k$ 位数排序后，整个排序就完成了。

算法工作如下：
- 首先根据 $d_1$ 位，把数分到 $10$ 个表 $L_0 ,L_1,..,L_9$ 中，这样，那些 $d_1=0$ 的数分到表 $L_0$ 中，那些 $d_1=1$ 的数分到表 $L_1$ 中，等等。

- 接下来，表被用 $L_0 ,L_1,..,L_9$ 的顺序接起来。
- 再后来，把它们按照 $d_2$ 分到 $10$ 张表中，按顺序接起来。
- 再把它们按 $d_k$ 分到表中并按顺序接起来后，所有的数就排好了序。 
	<img src="https://img-blog.csdnimg.cn/20200419085934295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="60%">

下面是一个例子，每一列显示的是按照第 $1$ 位、第 $2$ 位、第 $3$ 位、第 $4$ 位数字排序后的结果。
<img src="https://img-blog.csdnimg.cn/20200419154629423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="50%">

## 2. 伪代码
<img src="https://img-blog.csdnimg.cn/20200419154816176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="65%">

## 3. 算法分析
根据某一位数字把数分到表中去的过程做了 $k$ 遍，每一遍的代价是 $Θ(n)$ 时间，这样算法的时间是 $Θ(kn)$ 。如果 $k$ 是常数，运行时间就是 $Θ(n)$。

算法用了 $Θ(n)$ 空间，因为需要 $10$ 个表，这些表全部的大小是 $Θ(n)$ 。

## 4. 基数排序拓展(重要)
应该注意到，对任何基数都可以归纳出算法，而不是仅仅以 $10$ 为基数。
- 以二进制的每 $4$ 为作为一个数字，就是以 $16$ 作为基数，**表的数目总是与基数相等**。

更一般的，可以用基数排序按照每个域来对整个记录排序，比如对日期记录，可以对日期记录先按照日进行排序，再按照月排序，最后按照年进行排序。

---
# 五、Integer exponentiation(整数幂)
> 整数幂，或者说是快速幂，同时也体现了二分的思想。

一种基本的求整数幂的方法是对 $x$ 迭代自乘 $n$ 次，这太慢了，需要 $\Theta(n)$ 次乘法。
## 1. 基本思路
令 $m= \lfloor n/2\rfloor$，假设已经知道如何计算 $x^m$ ，那么有两种情况：
- 如果n是偶数，那么
	$$X^n = (x^m)^2$$
- 否则,
$$X^n = x \cdot (x^m)^2$$ 

## 2. 递归伪代码
<img src="https://img-blog.csdnimg.cn/2020041909014134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="65%">

 ## 3. 算法分析
假定每次乘法的时间是常数，那么这两个版本的算法的运行时间是 $\Theta(logn)$ ，它对于输入的大小来说是线性的。

---
# 六、Evaluating polynomials(多项式求值)(Horner’s规则)
## 1. 基本思想
假设有 $n+2$ 个实数 $a_0, a_1,…,a_n$ 和 $x$ 的序列，要对如下多项式求值。
$$P_n(x) = a_nX^n + a_{n-1} X^{n-1} + ... + a_1x + a_0$$

直接的方法是对每一项分别求值。这种方法是十分低效的，因为它需要 $n+n-1+…+1=n(n+1)/2$ 次乘法。

通过归纳法，可以得到一个快得多的方法：
- 首先观察和归并同类项，可得：(秦九韶)
$$P_n(x) = a_nx^n + a_{n-1}x^{n-1} + ... + a_1x + a_0\\
= ((...(((a_n x + a_{n-1})x + a_{n-2})x + a_{n-3})x... + a_1) x + a_0$$
 
- 假设已经知道如何对 $P_{n-1}(x) = a_{n} x^{n-1} + a_{n-1}x^{n-2} ... + a_2x + a_1$
- 则再用一次乘法和加法，就可得：
	$$P_n(x) = xP_{n-1}(x) + a_0, \quad P_j(x) = xP_{j-1}(x) + a_{n-j}$$
  
## 2. 伪代码
<img src="https://img-blog.csdnimg.cn/20200419090736389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="65%"> 

## 3. 算法分析

这种求值的安排称为Horner规则。它只使用了 $n$ 次乘法和 $n$ 次加法。这是利用归纳假设的优点得到的令人瞩目的成绩。


---
# 七、Generating permutations(生成排列)
## 1. 问题描述

研究对于数 $1，2…n$ 生成所有的排列问题，我们用 $P[1...n]$ 存放每一个排列。用归纳法导出几个算法是很容易的。这一节中只列出两种。它们都基于一个假设：我们可以生成 $n-1$ 个数的所有排列。


要构造一个简单生成集合{1,2,3,…,n}的所有排列的算法。观察发现：
 如果整数n从{1,2,3,…,n}的一个排列中删除，那么结果则是{1,2,3,…,n-1}的一个排列。

### 第一种算法(添加法)
假定可以生成 $n-1$ 个数的所有排列；那么可以扩展来生成 $1,2,...,n$ 个数的排列。方法如下：

- 生成数 $2,3,…,n$ 的所有排列，并且在每个排列的前面加上数 $1$；
- 接下来，生成数 $1,3,4,..,n$ 的所有排列，并且在每个排列的前面加上数 $2$ ；
- 重复这个过程直到最后生成 $1,2,..,n-1$ 的所有排列，并且在每个排列的前面加上数 $n$。
<img src="https://img-blog.csdnimg.cn/2020041909083341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70" width="68%"> 
这个算法中 $P[j]$ 和 $P[m]$ 在调用时进行了交换，因此必须在递归调用后交换回来。

### 第一种算法分析
由于存在有 $n!$ 个排列，过程 `perm1` 的第1步共有 $nn!$ 次来输出所有的排列。 

现在计算 `for`循环的循环次数。
- 在第一次调用过程 `perm1` 时， $m = 1$ ，因此 `for` 循环执行 $n$ 次加上递归调用 `perm1(2)` 的执行次数。
- 由于当 $n=1$ 时循环次数是 $0$，因此循环次数 $f( n)$ 能够用以下递推式表示：
$$f(n) = \left\{
\begin{aligned}
0 \quad if\ n = 1\\
nf(n-1) + n \quad if\ n \ge 2
\end{aligned}
\right.
$$
 
令 $n!h(n)=f(n)$ (注意 $h(1)=0$)：
$$n!h(n) = n(n-1)! h(n-1) + n$$
或者：
$$h(n) = h(n-1) + {n \over n!} = h(n-1) + {1\over (n-1)}!$$ 
那么

这个递推式的解是


这里e=2.7182818…. 因此, 


所以，算法的运行时间由输出语句来决定，也就是 $\Theta(nn!)$ 。
 
### 第二种算法
基本思想 
首先把n放入P[1]，并且在P[2..n] 子数组中生成前n-1个数的所有排列。
接下来把n放人P[2] ，并且在子数组P[1]和P[3..n]中生成前n-1个数的所有排列。
然后把n放入P[3]，并且在子数组P[1,2]和P[4..n-1]中生成前n-1个数的所有排列。
这样继续下去，直到最后把n放到P[n]中，并且在子数组P[1..n-1]中生成n-1个数的所有排列。
初始的时候， P[1..n]的n个项为0。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200419091130595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
### 2.2 算法分析
由于存在有n!个排列，过程perm2的第1步总共有nn!个排列输出。

现在计算for循环的迭代次数
for循环在每一个调用perm2(m)中被执行n次，再加上递归调用perm2(m-1)中执行的次数。

当过程perm2以调用perm2 (m)(m>0)形式调用时，数组P恰好包含m个0，并且由于递归调用perm2 ( m-1)将被执行恰好m次。因为在m=0时，迭代次数是0，所以迭代的次数可以用递推式表示如下:
算法分析(Continue)
令m!h(m)=f(m) (注意h(0)=0). 那么,

这个递推式的解是


这里e=2.7182818…
因此


用n代入，迭代的次数就变成


因此，算法的运行时间是(nn!).


# Finding the majority element(寻找多数元素)
     问题描述

令A[1..n]是一个整数序列，A中的整数a如果在A中出现的次数多于n/2 ，那么a称为多数元素。

例如，在序列1,3,2,3,3,4,3中，3是多数元素，因为7个元素中它出现4次。
方法1(brute-force method ) 
基本思想

蛮力方法是把每个元素和其他每个元素比较，并且对每个元素计数。

如果某个元素的计数大于n/2 ，就可以断言它是多数元素;否则，在序列中就没有多数元素。

但是这样的比较次数是
$$n(n-1)/2 = \Theta(n^2)$$
方法2 
基本思想

比较有效的算法是对这些元素排序，并且计算每个元素在序列中出现多少次。

这在最坏情况下的代价是(n log n) 。因为在最坏情况下，排序这一步需要(nlogn)次比较(定理12.2)。
方法 3 			
基本思想

寻找中间元素，就是第n/2元素。因为多数元素，在排序的序列中一定是中间元素，可以扫描这个序列来测试中间元素是否确实是多数元素。由于中间元素可以在(n)时间内找到，这个方法要花费(n)时间。

看到在中项寻找算法的时间复杂性中隐藏的常数太大，并且算法是相当复杂的。
Is there much more efficient method?
更有效算法
     观察结论 5.1
       
在原序列中去除两个不同的元素后，那么在原序列中的多数元素在新序列中还是多数元素。

这个观察结论支持下述寻找多数元素候选者的过程。
基本思想
将计数器置1，并令c=A[1]
从A[2]开始，逐个地扫描元素，如果被扫描的元素和c相等，则计数器加1；如果元素不等于c，则计数器减1；

如果所有的元素都已经扫描完毕并且计数器大于0，那么返回。作为多数元素的候选者。

如果在c和A[j](1<j<n)比较时计数器为0，那么对于A[j+1..n]上的元素递归调用candidate过程。

注意减少计数器就是观察结论5.1中所述去除两个不同元素的思想的实现。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200419091400263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
# 练习
## 题一 5.7 基数排序
对于下列给出的 $8$ 个数的序列，说明算法 $RADIXSORT$ 的运算。
(1) $4567, 2463, 6523, 7461, 4251, 3241, 6492, 7563$
(2) $16543, 25895, 18674, 98256, 91428, 73234, 16597, 73195$

## 题二 5.12 桶排序
一种称为 `bucket` 桶排序的方法如下方式工作：令 $A[1...n]$ 是一个在合理的范围内的 $n$ 个数的序列，例如 $1...m$ 中所有的数，这里的 $m$ 是一个与 $n$ 相比不太大的数，这些数被分到 $k$ 个桶中，第 $1$ 个桶放 $1$ 到 $\lfloor m/k\rfloor$ 间的数，第 $2$ 个桶中放 $\lfloor m/k\rfloor + 1$ 到 $\lfloor 2m/k\rfloor$ 间的数，如此等等。现在将每个桶里的数用其他的排序算法排序，如算法 `INSERTIONSORT` ，试分析算法的运行时间。

## 题三 5.29 摩尔计数法
说明算法 `MAJORITY` 对下列数组的运算。
(1) $5,7,5,4,5$
(2) $5,7,5,4,8$
(3) $2,4,1,4,4,4,6,4$
## 题四 5.31 
对于下面的说法，证明其为正确或错误：如果 `MAJORITY` 里过程 `condidate` 的第 $7$ 步中 $j=n$ 但是 $count = 0$，那么 $c$ 是多数元素。

--
# 其他参考书
 算法引论：一种创造性方法——国外计算机科学教材系列 (美)曼博(Manber,U.),黄林鹏 电子工业出版社 9787121016653 


