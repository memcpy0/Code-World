> 参考算导第22章 基本的图算法
![](https://img-blog.csdnimg.cn/7659f169773a4205b92c5a4e0e1978b1.png)
@[toc]


# 1. 广度优先搜索
**广度优先搜索**是最简单的图搜索算法之一，也是许多重要的图算法的原型。*Prim* 的最小生成树算法（算导23.2节）和 *Dijkstra* 的单源最短路径算法（算导24.3节）都使用了类似广度优先搜索的思想。

给定图 $G = (V, E)$ 和一个可以识别的**源**结点 $s$ ，广搜对图 $G$ 中的边进行系统性地搜索、来发现可以从源结点 $s$ 到达的所有结点。该算法能计算从源结点 $s$ 到每个可达结点的距离（最少的边数），同时生成一棵“广度优先搜索树”——该树以源结点 $s$ 为根结点，包含所有可以从 $s$ 到达的结点。==对于每个从源结点 $s$ 可达的结点 $v$ ，在广度优先搜索树中从结点 $s$ 到结点 $v$ 的简单路径、所对应的就是图 $G$ 中从结点 $s$ 到结点 $v$ 的“最短路径”，即包含最少边数的路径==。该算法即可用于有向图，也可用于无向图。

广搜之所以如此得名，是因为该算法始终是将「已发现结点和未发现结点之间的边界」沿其广度方向向外扩展。也就是说，算法需要在发现「与源点 $s$ 距离为 $k$ 的所有结点」之后，才会发现「与源点 $s$ 距离为 $k + 1$ 的其他结点」。

为了跟踪算法的进展，广搜在概念上将每个结点涂上白色、灰色和黑色。所有结点一开始时均涂上白色。在算法推进过程中，这些结点可能会变成灰色或者黑色。在搜索过程中，第一次遇到一个结点就称该结点被“**发现**”，此时该结点的颜色将发生改变。因此，**凡是灰色和黑色的结点都是已被发现的结点**。但广搜对灰色和黑色结点加以区分（目的是帮助理解广搜如何运行，实际上如算导练习22.2-3所示，即使不对这两种颜色的结点加以区分，获得的结果仍然是相同的）、以确保搜索按照广度优先模式进行推进——如果边 $(u, v) \in E$ 且结点 $u$ 是黑色，则结点 $v$ 既可能是灰色也可能是黑色。也就是说，**所有与黑色邻接的结点都已经被发现**。对于灰色结点来说，其邻接结点中可能存在未被发现的白色结点，**灰色结点所代表的就是已知和未知两个集合之间的边界**。

在执行广搜的过程中，将构造出一棵广度优先搜索树。==一开始，该树仅含有根结点，就是源结点 $s$ 。在扫描已发现结点 $u$ 的邻接链表时，每当发现一个白色结点 $v$ ，就将结点 $v$ 和边 $(u, v)$ 同时加入该棵树中==。在广度优先树中，称结点 $u$ 是结点 $v$ 的**前驱**或**父结点**。由于每个结点最多被发现一次，它最多只有一个父结点。**广度优先树中的祖先和后代关系，皆以相对于根结点 $s$ 的位置来进行定义**：如果结点 $u$ 是根结点 $s$ 到结点 $v$ 的简单路径上的一个结点，则结点 $u$ 是结点 $v$ 的祖先，结点 $v$ 是结点 $u$ 的后代。

在下面给出的广搜过程 `BFS` 中，假定输入图 $G = (V, E)$ 是以邻接链表所示的。该算法为图中每个结点赋予了一些额外的属性：我们将每个结点 $u$ 的颜色存放在属性 $u.color$ 中，将 $u$ 的前驱结点存放在属性 $u.\pi$ 中。如果 $u$ 没有前驱结点（例如，如果 $u = s$ 或者结点 $u$ 尚未被发现），则 `u.π = NULL` 。属性 $u.d$ 记录的是广搜算法计算出的、从源点 $s$ 到结点 $u$ 之间的距离。该算法使用一个先进先出的队列（算导10.1节）来管理灰色结点集。
```cpp
BFS(G, s)
	for each vertex u in G.v - {s}
		u.color = WHITE
		u.d = INF
		u.π = NULL
	s.color = GRAY
	s.d = 0
	s.π = NULL
	Q = ∅
	ENQUEUE(Q, s)
	while Q != ∅
		u = DEQUEUE(Q)
		for each v in G.Adj[u]
			if v.color == WHITE
				v.color = GRAY
				v.d = u.d + 1
				v.π = u
				ENQUEUE(Q, v)
		u.color = BLACK
```
图22-3描述的是BFS在一个样本图上的推进过程。
![](https://img-blog.csdnimg.cn/6df72dbeca624a449c1c097169bc2126.png)

过程 `BFS` 的工作过程如下。除了源结点以外，算法的第 $1 \sim 4$ 行将所有结点涂上白色，将每个结点 $u$ 的 $u.d$ 属性设置为无穷，将每个结点的父结点设置为 `NULL` 。**第 $5$ 行将源结点 $s$ 涂上灰色，因为该结点在算法开始时已被发现**。第 $6$ 行将 $s.d$ 初始化为 $0$ ，第 $7$ 行将源结点 $s$ 的前驱设置为 `NULL` ，第 $8 \sim 9$ 行对队列 $Q$ 进行初始化，该队列的初始状态仅包含源结点 $s$ 。

算法第 $10 \sim 18$ 行的 while 循环，一直执行到图中不再有灰色结点时结束。如前所示，**灰色结点指的是已被发现的结点，但其邻接链表尚未被完全检查**。该 while 循环的不变式如下：==在算法第 $10$ 行的测试中，队列 $Q$ 里面包含的是灰色结点集合==。

虽然我们不打算使用循环不变式来证明算法的正确性，但容易看出，该不变式在第 $1$ 次循环前成立，且每次循环过程都维持该不变式的成立。
- 在第 $1$ 次循环开始之前，唯一的灰色结点、也是队列 $Q$ 里面的唯一结点，是源结点 $s$ 。
- 算法第 $11$ 行取出队列 $Q$ 的队头结点 $u$ ，将其从队列中删除。第 $12 \sim 17$ 行的 for 循环，对结点 $u$ 的邻接链表中的每个结点 $v$ 进行考察。如果结点 $v$ 是白色的，则该结点尚未被发现，算法执行第 $14 \sim 17$ 行的程序来发现该结点：算法将结点 $v$ 涂上灰色，将其距离 $v.d$ 设置为 $u.d + 1$ ，并将结点 $u$ 记录为结点 $v$ 的父结点 $v.\pi$ ，将其插入队列 $Q$ 的末尾。
- 算法在检查完结点 $u$ 的邻接链表里的所有结点后，将 $u$ 涂上黑色（第 $18$ 行）。==由于一个结点在涂上灰色（第 $14$ 行）的同时、被加入队列 $Q$ 中（第 $17$ 行），而结点在从队列里删除（第 $11$ 行）的同时、被涂上黑色（第 $18$ 行），所以我们前面给出的循环不变式一直得到保持==。
![](https://img-blog.csdnimg.cn/f0f759451f7f47ffa7c727e752c3df21.png)


广搜的结果，可能依赖于对每个结点的邻接结点的访问顺序（第 $12$ 行）：广度优先树可能会不一样，但本算法计算出来的距离 $d$ 都是一样的（算导练习22.2-5）。

## 1.1 分析
在证明广搜算法的各种性质前，我们先来分析该算法的运行时间。在这里，我们将使用（算导17.1节介绍的）聚合分析。**在初始化操作结束后，广搜不会再给任何结点涂上白色**，因此，第 $13$ 行的测试可以确保，**每个结点的入队次数最多为一次，因而出队最多一次**。入队和出队的时间均为 $O(1)$ ，因此，对队列进行操作的总时间为 $O(V)$ 。

**因为算法只在一个结点出队的时候，才对该结点的邻接链表进行扫描，所以每个邻接链表最多只扫描一次**。由于所有邻接链表的长度之和是 $\Theta(E)$ ，用于扫描邻接链表的总时间为 $O(E)$ 。初始化操作的成本是 $O(V)$ ，因此广搜的总运行时间为 $O(V+E)$ 。因此，广搜的运行时间是图 $G$ 的邻接链表大小的一个线性函数。

## 1.2 最短路径
在开始时曾说过，广搜能够找出从给定源结点 $s \in V$ 到所有可达结点之间的距离。我们定义==从源结点 $s$ 到结点 $v$ 的**最短路径距离** $\delta(s, v)$ 为：从结点 $s$ 到结点 $v$ 之间所有路径里面最少的边数==（权重图里每条边都有一个实数权重，一条路径的权重是组成该路径的所有边的权重之和，这里的图为无权重图，即所有边的权重为单位权重，边数就等于边权重之和）。如果从结点 $s$ 到结点 $v$ 之间没有路径，则 $\delta(s, v)= \infin$ 。我们称 ==「从结点 $s$ 到结点 $v$ 的长度为 $\delta(s, v)$ 的路径」为 $s$ 到 $v$ 的**最短路径**==。在证明广搜可以正确计算出最短路径距离之前，我们先来讨论**最短路径距离的一个重要性质**。

**引理22.1** 给定 $G = (V, E)$ ，$G$ 为一个有向图或无向图，设 $s \in V$ 为任意结点，则对于任意边 $(u, v) \in E$ ，$\delta(s, v) \le \delta(s, u) + 1$ 。
**证明**：如果结点 $u$ 是可以从源结点 $s$ 到达的结点，则 $v$ 也是从 $s$ 可以到达的结点（因为边 $(u, v) \in E$ ）。在这种情况下，从源结点 $s$ 到结点 $v$ 的最短路径距离，不可能比从 $s$ 到 $u$ 的最短路径距离加上边 $(u, v)$ 更长，因此上述不等式成立。如果结点 $u$ 不能从 $s$ 到达，则 $\delta(s, u) = \infin$ ，不等式显然成立。$\blacksquare$ 

现在我们来证明，**`BFS` 能够正确计算出每个结点 $v \in V$ 的 $v.d = \delta(s, v)$** 。首先证明 $v.d$ 是 $\delta(s, v)$ 的一个上界。

**引理22.2** 设 $G = (V, E)$ 为一个有向图或无向图，假定 `BFS` 以给定结点 $s \in V$ 作为源结点在图 $G$ 上运行。那么在 `BFS` 终结时，对于每个结点 $v \in V$ ，`BFS` 计算出的 $v.d$ 满足 $v.d \ge \delta(s, v)$ 。
**证明**：我们通过对算法里面 `ENQUEUE` 操作的次数进行归纳、来证明本引理。我们的归纳假设是：对于所有的结点 $v \in V$ ，$v.d \ge \delta(s, v)$ 。
- 归纳的基础是 `BFS` 在第 $9$ 行将源结点 $s$ 加入队列 $Q$ 后的场景。此时，因为 $s.d = 0 = \delta(s, s)$ ，并且对于所有的结点 $v \in V- \{ s \}$ ，$v.d = \infin \ge \delta(s, v)$ ，所以归纳假设成立。
- 对于归纳步，考虑从结点 $u$ 进行邻接链表搜索时、所发现的白色结点 $v$ 。根据归纳假设，有 $u.d \ge \delta(s, u)$ 。从算法第 $15$ 行的赋值操作和**引理22.1**可知，$$v.d = u.d + 1 \ge \delta(s, u) + 1 \ge \delta(s, v)$$ 结点 $v$ 在这之后被加入到队列 $Q$ 里，并且因为 $v$ 在入队时涂上灰色、而不会再次入队。因此，第 $14 \sim 17$ 行的子句仅在白色结点上执行。所以，$v.d$ 的值不会再发生变化，我们的归纳假设成立。$\blacksquare$

要证明 $v.d = \delta(s, v)$ ，首先需要更加精确地研究、队列 $Q$ 在 `BFS` 过程中是如何操作的。下面的引理将证明，**在任意时刻，队列里面最多包含两个不同的 $d$ 值**。

**引理22.3** 假定 `BFS` 在图 $G = (V, E)$ 上运行的过程中，队列 $Q$ 包含的结点为 $\langle v_1, v_2,\dots, v_r \}$ ，这里 $v_1$ 是队列 $Q$ 的头、$v_r$ 是队列的尾。那么 $v_r.d \le v_1.d + 1$ ，并且对于 $i = 1, 2, \dots, r - 1$ ，$v_i.d \le v_{i+1} .d$ 。
**证明**：我们仍然通过对算法里面入队操作的次数进行归纳、来证明本引理。
- 在初始情况下，队列 $Q$ 里仅包含源结点 $s$ ，引理直接成立。
- 对于归纳步，我必须证明在入队和出队操作时，引理都成立。
	- 如果头结点 $v_1$ 被删除，$v_2$ 将变为队列里新的头结点（如果队列在删除头结点后为空，则引理直接成立）。根据归纳假设，我们有 $v_1.d \le v_2.d$ 。但是我们有 $v_r.d \le v_1.d + 1 \le v_2.d + 1$ ，且余下的不等式不受影响。因此，在 $v_2$ 为头结点时引理依然成立。
	- 为了理解在将一个结点加入队列时、发生了什么事情，我们需要对算法进行更加细致的检查。算法第 $17$ 行将结点 $v$ 加入队列 $Q$ 时，该结点成为结点 $v_{r+1}$ 。在这时，我们已经删除了结点 $u$ ，并正在对该结点的邻接链表进行检查。根据归纳假设，新的头结点 $v_1$ 满足 $v_1.d \ge u.d$ 。因此，$v_{r+1}.d = v.d = u.d + 1 \le v_1.d + 1$ 。根据归纳假设，我们还有 $v_r.d \le u.d + 1$ ，因此 $v_r.d \le u.d + 1 = v.d = v_{r+1}.d$ ，余下的不等式不受影响。因此，当结点 $v$ 加入队列时、引理仍然成立。$\blacksquare$

下面的推论表明，在结点加入到队列时，（队列中结点的）$d$ 值随时间推移单调增长。

**推论22.4** 假定在执行 `BFS` 时，结点 $v_i$ 和结点 $v_j$ 都加入到队列 $Q$ 里，并且 $v_i$ 在 $v_j$ 前面入队，则在 $v_j$ 入队时，我们有 $v_i.d \le v_j.d$ 。
**证明**：根据**引理22.3**，以及在 `BFS` 过程中每个顶点最多一次获得一个有限的 $d$ 值 `each vertex receives a finite d value at most once during the course of BFS` 这一性质 ，可以立即得到**推论22.4**。$\blacksquare$

现在的我们，可以来证明**广搜算法能够正确计算出最短路径距离**。

**定理22.5**（**广度优先搜索的正确性** `Correctness of breadth-first search` ）设 $G = (V, E)$ 为一个有向图或无向图，又假设 `BFS` 以 $s$ 为源结点在图 $G$ 上运行。那么在算法执行过程中，==`BFS` 将发现从源结点 $s$ 可达的所有结点 $v \in V$ ，并在算法终止时，对于所有的 $v \in V$ ，$v.d = \delta(s, v)$== 。而且，==对于任意从 $s$ 可达的结点 $v \ne s$ ，从源结点 $s$ 到结点 $v$ 的其中一条最短路径、为从结点 $s$ 到结点 $v.\pi$ 的最短路径再加上边 $(v.\pi, v)$== 。
**证明**：我们使用反证法来证明本定理，**假设某些结点获得的 $d$ 值并不等于其最短路径距离**。设 $v$ 为这样一个结点，则其最短路径距离为 $\delta(s, v)$ ，而其取得的 $d$ 值不等于该数值，显然 $v \ne s$ 。根据**引理22.2**，$v.d \ge \delta(s, v)$ ，因此有 $v.d > \delta(s, v)$ 。另外，结点 $v$ 必定是从 $s$ 可达的，因为如果不是这样，则将出现 $\delta(s, v) = \infin \ge v.d$ 。

==设 $u$ 为从源结点 $s$ 到结点 $v$ 的最短路径上 $v$ 的直接前驱结点，则 $\delta(s, v) = \delta(s, u) + 1$== 。因为 $\delta(s, u) < \delta(s, v)$ ，并且因为我们对结点 $v$ 的选择，所以有 $u.d = \delta(s, u)$ 。将这些分析合并起来有： $$v.d > \delta(s, v) = \delta(s, u) + 1 = u.d + 1 \tag{22.1}$$

现在，我们考虑 `BFS` 选择将结点 $u$ 从队列 $Q$ 里取出的时刻（第 $11$ 行）。这时，结点 $v$ 可以是任何颜色，白色、灰色或黑色。而我们将证明，在每种情况下（即不管 $v$ 是何种颜色的结点），我们都将导出与不等式 $(22.1)$ 矛盾的情形。
- 如果 $v$ 是白色结点，则算法的第 $15$ 行将设置 $v.d = u.d + 1$ ，这与不等式 $(22.1)$ 矛盾。
- 如果 $v$ 是黑色结点，则该结点已经从队列里删除，根据**推论22.4**，我们有 $v.d \le u.d$ ，再次与不等式 $(22.1)$ 矛盾。
- 如果 $v$ 是灰色结点，则 $v$ 是在某个结点 $w$ 出队时被涂上灰色的，而结点 $w$ 在结点 $u$ 之前出队，并且 $v.d = w.d + 1$ 。根据**推论22.4**，$w.d \le u.d$ ，因此有 $v.d = w.d + 1 \le u.d + 1$ ，这再次与不等式 $(22.1)$ 相矛盾。

因此，我们得出结论，对于所有的 $v \in V$ ，$v.d = \delta(s, v)$ 。==所有从 $s$ 可达的结点 $v$ 都必定被发现，否则将有 $\infin = v.d > \delta(s, v)$== 。而要获得最终的结论，只要注意到如果 $v.\pi = u$ ，则 $v.d = u.d + 1$ ，因此通过将「从源结点 $s$ 到结点 $v.\pi$ 的最短路径」加上边 $(v.\pi, v)$ ，我们即可获得从源结点 $s$ 到结点 $v$ 的最短路径。$\blacksquare$

## 1.3 广度优先树
过程 `BFS` 在对图进行搜索的过程中，将创建一棵广度优先树，如图22-3所示。该棵树对应的是 $\pi$ 属性。更形式化地说，对于图 $G = (V, E)$ 和源结点 $s$ ，我们定义图 $G$ 的**前驱子图** `predecessor subgraph` 为 $G_{ \pi } = (V_{\pi} , E_{\pi})$ ，其中 $$V_{ \pi } = \{ v \in V \mid v.\pi \ne \textrm{NULL} \} \cup \{ s \},\ E_{\pi} = \{ (v.\pi, v) \mid v \in V_{ \pi } - \{ s \} \}$$ 

如果 ==$V_{ \pi}$ 由「从源结点 $s$ 可达的结点」组成==，并且==对于所有的 $v \in V_{ \pi }$ ，子图 $G_{ \pi }$ 包含一条从源结点 $s$ 到结点 $v$ 的唯一简单路径==，且==该路径也是图 $G$ 中从源结点 $s$ 到结点 $v$ 之间的一条最短路径==，则前驱子图 $G_{ \pi}$ 是一棵**广度优先树**。广度优先树实际上就是一棵树，因为它是连通的、并且 $| E_{ \pi} | = | V_{ \pi } | - 1$（算导定理B.2）。我们称 $E_{ \pi }$ 中的边为**树边** `tree edges` 。

下面的引理，表明 `BFS` 过程生成的前驱子图是一棵广度优先树。

**引理22.6** 当运行在一个有向或无向图 $G = (V, E)$ 上时，`BFS` 过程构造的 $\pi$ 属性、使得前驱子图 $G_{ \pi } = (V_{\pi}, E_{\pi })$ 成为一棵广度优先树。
**证明**：`BFS` 在第 $16$ 行设置 $v.\pi = u$ 当且仅当 $(u, v) \in E$ 并且 $\delta(s, v) < \infin$ ——这就是说，如果结点 $v$ 由源结点 $s$ 可达——并且因此，$V_{ \pi}$ 由源结点 $s$ 可达的 $V$ 集合中的结点所组成。由于 $G_{\pi}$ 形成一棵树（连通的、并且 $| E_{ \pi} | = | V_{ \pi } | - 1$），根据定理B.2，该树包含从源结点 $s$ 到「 $V_{\pi}$ 集合中每个结点」的一条唯一简单路径。通过递归应用**定理22.5**，我们可下结论：每条这样的路径也是图 $G$ 中的一条最短路径 `every such path is a shortest path in G` 。$\blacksquare$
![](https://img-blog.csdnimg.cn/771d5fe30bbb4eb68bf248e32c9818b3.png)
下面的伪代码，将打印出「从源结点 $s$ 到结点 $v$ 的一条最短路径」上的所有结点，这里假定 `BFS` 已经计算出一棵广度优先树。
```cpp
PRINT-PATH(G, s, v)
	if v == s
		print s
	else if v.π == NULL
		print "no path from " s " to " v " exists"
	else PRINT-PATH(G, s, v.π)
		print v 
```
因为每次递归调用时的路径、都比前一次调用中的路径少一个结点，所以该过程的运行时间是关于「所输出路径上顶点数」的一个线性函数。

---
# 2. 深度优先搜索
深搜所使用的策略正如其名：只要可能，就在图中尽量“深入”。
- 深搜总是对「最近才发现的结点 $v$ 的出发边」进行探索，直到该结点的所有出发边都被发现为止。
- 一旦结点 $v$ 的所有出发边都被发现，搜索则“回溯”到 $v$ 的前驱结点（ $v$ 是经过该结点才被发现的），来搜索该前驱结点的出发边。
- 该过程一直持续到「从源结点可达的所有结点」都被发现为止。
- 如果还存在尚未发现的结点，则深搜将从这些未被发现的结点中任选一个、作为新的源结点，并重复同样的搜索过程。

该算法重复整个过程，直到图中的所有结点都被发现为止。
> 也许有点随意：在讨论广搜算法时，我们将源结点的数量限制为一个，而深搜则可以有多个源结点。虽然从概念上看，广搜可以从多个源结点开始搜索，而深搜也可以限制为从一个源结点开始，但算导采取的方法反映的是**这些搜索结果是如何被使用的**——广搜通常用来寻找从特定源结点出发的最短路径距离（及其相关的前驱子图），而深搜则常常作为另一个算法里的一个子程序，后面将看到这点。

像广搜一样，==在对「已被发现的结点 $u$ 的邻接链表」进行扫描时，每当发现一个结点 $v$ 时，深搜算法将对这个事件进行记录，将 $v$ 的前驱属性 $v.\pi$ 设置为 $u$== 。不过与广搜不同的是，广搜的前驱子图形成一棵树，而深搜的前驱子图可能由多棵树组成，因为搜索可能从多个源结点重复进行。因此，我们给深搜的**前驱子图**所下的定义、与对广搜的前驱子图所下的定义略有不同：==设图 $G_{ \pi } = (V, E_{ \pi })$ ，其中 $E_{ \pi} = \{ (v.\pi, v) \mid v \in V且v.\pi \ne \textrm{NULL} \}$== 。深搜的前驱子图，形成一个由多棵**深度优先树** `depth-first trees` 构成的**深度优先森林** `depth-first forest` 。森林 $E_{ \pi }$ 中的边仍然称为**树边**。

像广搜算法一样，深搜算法在搜索过程中，也是对结点进行涂色来指明结点的状态。==每个结点的初始颜色都是白色，在结点被**发现**后变为灰色，在其邻接链表被扫描**完成**后变为黑色==。该方法可以保证，每个结点仅在一棵深度优先树中出现。因此，**所有的深度优先树是不相交的** `disjoint` 。

除了创建一个深度优先搜索森林外，深搜算法还在每个结点盖上一个**时间戳**。每个结点 $v$ 有两个时间戳：==第一个时间戳 $v.d$ 记录「结点 $v$ 第一次被发现的时间」（涂上灰色的时候），第二个时间戳 $v.f$ 记录的是「搜索完成对 $v$ 的邻接链表扫描的时间」（涂上黑色的时候）==。这些时间戳提供了图结构的重要信息，通常能够帮助推断深搜算法的行为。

下面的深搜算法的伪代码，将其发现结点 $u$ 的时刻记录在属性 $u.d$ 中，将其完成对结点 $u$ 处理的时刻记录在属性 $u.f$ 中。**因为 $|V|$ 个结点中、每个结点只能有一个发现事件和一个完成事件，所以这些时间戳都是处于 $1$ 和 $2|V|$ 之间的整数**。很显然，对于每个结点 $u$ ，我们有：$$u.d < u.f \tag{22.2}$$

结点 $u$ 在时刻 $u.d$ 之前为白色，在时刻 $u.d$ 和 $u.f$ 之间为灰色，在时刻 $u.f$ 之后为黑色。

下面的伪码给出的是基本的深搜算法。输入图 $G$ 可以是无向图或有向图。变量 $time$ 是一个全局变量，用来计算时间戳。
```cpp
DFS(G)
	for each vertex u in G.V
		u.color = WHITE
		u.π = NULL
	time = 0
	for each vertex u in G.V
		if u.color == WHITE
			DFS-VISIT(G, u)

DFS-VISIT(G, u)
	time = time + 1			// white vertex u has just been discovered
	u.d = time
	u.color = GRAY
	for each v in G.Adj[u]	// explore edge (u, v)
		if v.color == WHITE
			v.π = u
			DFS-VISIT(G, v)
	u.color = BLACK			// blacken u; it is finished
	time = time + 1
	u.f = time
```
图22-4描述的是深搜算法在图22-2上运行的过程。
![](https://img-blog.csdnimg.cn/98665e8e6e874ebaa2d4a115ed6ec2f1.png)
`DFS` 的运行过程如下。
1. 第 $1 \sim 3$ 行将所有的结点涂成白色，将所有结点的 $\pi$ 属性设置为 `NULL` 。
2. 第 $4$ 行将全局时间计数器复位。
3. 第 $5 \sim 7$ 行依次对每个结点进行检查。当一个白色结点被发现时，则使用 `DFS-VISIT` 对结点进行访问。每次在算法第 $7$ 行调用 `DFS-VISIT(G, u)` 时，结点 $u$ 就成为深度优先森林中一棵新的深度优先树的根结点。
4. 当 `DFS` 算法返回时，每个结点 $u$ 都已被赋予一个**发现时间** $u.d$ 和一个**完成时间** $u.f$ 。

在每次对 `DFS-VISIT(G, u)` 的调用中，结点 $u$ 的初始颜色都是白色。
1. 算法的第 $1$ 行将全局变量 $time$ 的值进行递增，第 $2$ 行将 $time$ 的新值记录为发现时间 $u.d$ ，第 $3$ 行将结点 $u$ 涂上灰色。
2. 第 $4 \sim 7$ 行对结点 $u$ 的每个邻接结点 $v$ 进行检查，并在 $v$ 是白色的情况下递归访问结点 $v$ 。
3. 随着每个结点 $v \in Adj[u]$ 在第 $4$ 行被考虑，我们说深度优先搜索算法已经**探索**了边 $(u, v)$ 。
8. 最后，在探索完「从结点 $u$ 发出的每条边」后，算法的第 $8 \sim 10$ 行将结点 $u$ 涂上黑色，对变量 $time$ 的值进行递增，并将完成时间记录在属性 $u.f$ 中。

注意，深搜的结果可能依赖于算法 `DFS` 中第 $5$ 行对结点进行检查的次序，以及算法 `DFS-VISIT` 中第 $4$ 行对一个结点的邻接结点进行访问的次序。不过，这些不同的访问次序在实际中并不会导致问题，因为**我们通常可以对任意的深搜结果加以有效利用，并获得等价的结果**。

`DFS` 的运行时间是多少？如果排除调用 `DFS-VISIT` 的时间，第 $1 \sim 3$ 行的循环和第 $5 \sim 7$ 行的循环所需的时间为 $\Theta(V)$ 。就像对待广搜算法一样，我们在这里也使用聚合分析。对每个结点 $v \in V$ 来说，`DFS-VISIT` 被调用的次数刚好为一次，这是因为在对一个结点 $u$ 调用 `DFS-VISIT` 时，该结点 $u$ 必须是白色，而 `DFS-VISIT` 所做的第一件事情就是将结点 $u$ 涂上灰色。在执行 `DFS-VISIT(G, v)` 的过程中，算法第 $4 \sim 7$ 行的循环所执行的次数为 $| Adj[v] \mid$ 。由于 $\displaystyle \sum_{v \in V} | Adj[v] \mid  = \Theta(E)$ ，执行 `DFS-VISIT` 第 $4 \sim 7$ 行操作的总成本是 $\Theta(E)$ 。因此，深搜算法的运行时间为 $\Theta(V+E)$ 。

## 2.1 深度优先搜索的性质
**深搜提供的是关于图结构的价值很高的信息**。也许深搜最基本的性质是，==其生成的前驱子图 $G_{\pi}$ 形成一个由多棵树所构成的森林==，这是因为深度优先树的结构与 `DFS-VISIT` 的递归调用结构完全对应。也就是说，**$u = v.\pi$ 当且仅当 `DFS-VISIT(G, v)` 在算法对结点 $u$ 的邻接链表进行搜索时被调用**。此外，**结点 $v$ 是深度优先森林里结点 $u$ 的后代，当且仅当结点 $v$ 在结点 $u$ 为灰色的时间段里被发现**。

深搜的另一个重要性质是，==结点的发现时间和完成时间具有所谓的**括号化结构**== `parenthesis structure` 。如果以左括号 $(u$ 来表述结点 $u$ 的发现，以右括号 $u)$ 来表述结点 $u$ 的完成，则发现和完成的历史记载形成了一个规整 `well-formed` 的表达式，这里的“规整”意为所有的括号都适当地嵌套在一起。例如，对图22-5(a)进行深搜所对应的括号化结构，如图22-5(b)所示。
![](https://img-blog.csdnimg.cn/97445512e18d458290054e8bbdf6cfe9.png)
下面的定理，则提供了另一种对括号化结构进行描述的方法。

**定理22.7**（**括号化定理** `Parenthesis theorem` ）在对有向或无向图 $G = (V, E)$ 进行的任意深搜中，对于任意两个结点 $u, v$ 来说，下面三种情况只有一种成立：
- 区间 $[u.d, u.f]$ 和区间 $[v.d, v.f]$ 完全分离，在深度优先森林中，结点 $u$ 不是结点 $v$ 的后代，结点 $v$ 也不是结点 $u$ 的后代。
- 区间 $[u.d, u.f]$ 完全包含在区间 $[v.d, v.f]$ 内，在深度优先树中，结点 $u$ 是结点 $v$ 的后代。
- 区间 $[v.d, v.f]$ 完全包含在区间 $[u.d, u.f]$ 内，在深度优先树中，结点 $v$ 是结点 $u$ 的后代。

**证明**：我们从 $u.d < v.d$ 的情况开始。在该情况下，根据不等式 $v.d < u.f$ 是否成立，又可以分为两种子情况。第一种子情况是在 $v.d < u.f$ 成立时，结点 $v$ 在结点 $u$ 仍然是灰色的时候被发现，这意味着结点 $v$ 是结点 $u$ 的后代。而且，因为结点 $v$ 在结点 $u$ 的后面被发现，其所有的出发边都已经被探索完，在搜索算法返回来继续处理结点 $u$ 时，结点 $v$ 的处理已经完成。在这种情况下，区间 $[v.d, v.f]$ 完全包含在区间 $[u.d, u.f]$ 内。在第二种子情况下，$u.f < v.d$ ，根据不等式 $(22.2)$ ，我们有 $u.d < u.f < v.d < v.f$ ，因此，没有一个结点是另一个结点的后代。

对于 $v.d < u.d$ 的情况，证明过程类似，只不过将上述证明中的 $u$ 和 $v$ 进行对调即可。$\blacksquare$

**推论22.8**（**后代区间的嵌套** `Nesting of descendants’ intervals` ）在有向或无向图 $G$ 的深度优先森林中，结点 $v$ 是结点 $u$ 的真后代当且仅当 $u.d < v.d < v.f < u.f$ 成立。
**证明**：从**定理22.7**立即可得。$\blacksquare$


下面的定理给出的是，在深度优先森林中，当「一个结点是另一个结点的后代」时的另一个重要特征。

**定理22.9**（**白色路径定理** `White-path theorem` ）在有向或无向图 $G = (V, E)$ 的深度优先森林中，结点 $v$ 是结点 $u$ 的后代、当且仅当在发现结点 $u$ 的时间 $u.d$ ，存在一条从结点 $u$ 到结点 $v$ 的、全部由白色结点构成的路径。
**证明**：$\rArr$ ：如果 $v = u$ ，则从结点 $u$ 到结点 $v$ 的路径仅包含结点 $u$ ，而该结点在算法设置 $u.d$ 的值时仍然是白色的（虽然下一行就是灰色了）。现在，假定在深度优先森林中，结点  $v$ 是结点 $u$ 的真后代。==根据**推论22.8**，我们有 $u.d < v.d$ ，因此结点 $v$ 在时刻 $u.d$ 时为白色==。由于结点 $v$ 可以是 $u$ 的任意后代，在深度优先森林中，从结点 $u$ 到结点 $v$ 的唯一简单路径上的所有结点、在时刻 $u.d$ 时都是白色的。

$\lArr$ ：假定在时刻 $u.d$ 时，存在一条从结点 $u$ 到结点 $v$ 的、全部由白色结点组成的路径，但结点 $v$ 在深度优先树中却不是结点 $u$ 的后代。不失一般性，假定从结点 $u$ 到结点 $v$ 的路径上，除了结点 $v$ 以外的每个结点都成为结点 $u$ 的后代（否则，可设 $v$ 为路径上离结点 $u$ 最近的、没有成为结点 $u$ 的后代的结点）。设结点 $w$ 为路径上结点 $v$ 的前驱，使得 $w$ 是 $u$ 的一个后代（事实上，$w$ 和 $u$ 可能是同一个结点）。根据**推论22.8**，我们有 $w.f \le u.f$ 。因为结点 $v$ 必须在结点 $u$ 被发现之后、但在结点 $w$ 处理完成之前被发现，所以 $u.d < v.d < w.f \le u.f$ 。根据**定理22.7**，区间 $[v.d, v.f]$ 完全包含在区间 $[u.d, u.f]$ 中。根据**推论22.8**，结点 $v$ 最后必然成为结点 $u$ 的后代。$\blacksquare$ 

## 2.2 边的分类
深搜的另一个有趣的性质是，**可以通过搜索来对输入图 $G= (V, E)$ 的边进行分类**。每条边的类型可以提供关于图的重要信息。例如，在下一节的讨论中，我们将看到**有向图是无环图、当且仅当深搜不产生“后向”边** `back edge`（引理22.11）。

对于在图 $G$ 上运行深搜算法所生成的深度优先森林 $G_{ \pi}$ ，我们可以定义 $4$ 种边的类型：
1. **树边** `tree edges` ：为深度优先森林 $G_{\pi}$ 中的边。如果结点 $v$ 是因算法对边 $(u, v)$ 的探索而首先被发现，则 $(u, v)$ 是一条树边。
2. **后向边** `back edges` ：后向边 $(u, v)$ 是将结点 $u$ 连接到其在深度优先树中（一个）祖先结点 $v$ 的边。由于有向图中可以有自环，自环也被认为是后向边 `We consider self-loops, which may occur in directed graphs, to be back edges` 。
3. **前向边** `forward edges` ：是将结点 $u$ 连接到其在深度优先树中一个后代结点 $v$ 的**非树边** $(u, v)$ 。
4. **横向边**：指其他所有的边。这些边可以连接同一棵深度优先树中的结点，只要其中一个不是另外一个的祖先，也可以连接不同深度优先树中的两个结点。

在图22-4和图22-5中，每条边上的标签标明了该条边的类型。图22-5 c)同时还描述了如何对图22-5(a)进行重画，以便让所有的树边和前向边都朝下指，而所有的后向边都超上指。事实上，我们可以将任何图都重画成这种模式。

在遇到某些边时，`DFS` 有足够的信息来对这些边进行分类。这里的关键是，当第一次探索边 $(u, v)$ 时，结点 $v$ 的颜色能够告诉我们关于该条边的一些信息。
1. 结点 $v$ 为白色表明，该条边 $(u, v)$ 是一条树边。
2. 结点 $v$ 为灰色表明，该条边 $(u, v)$ 是一条后向边。
3. 结点 $v$ 为黑色表明，该条边 $(u, v)$ 是一条前向边或横向边。

第一种情况可以从算法的规范中立即推知。对于第二种情况，只要注意到，==灰色结点总是形成一条线性的后代链，这条链对应当前活跃的 `DFS-VISIT` 调用栈；灰色结点的数量总是比深度优先森林中最近被发现的结点的深度多 $1$== ` the number of gray vertices is one more than the depth in the depth-first forest of the vertex most recently discovered` 。而算法对图的探索，总是从深度最深的灰色结点往前推进，因此，（从当前灰色结点）通向另一个灰色结点的边、所达的是当前灰色结点的祖先。第三种情况处理的是剩下的可能性，（算导练习22.3-5要求）证明**这种情况下的边 $(u,v )$ 在 $u.d < v.d$ 时为前向边，在 $u.d > v.d$ 时为横向边**。

==在对边进行分类时，无向图可能给我们带来一些模糊性，因为边 $(u, v)$ 和 $(v, u)$ 实际上是同一条边==。在这种情况下，我们将边 $(u, v)$ 划分为分类列表中第一种适合该边的类型。等价地（算导练习22.3-6），我们也可以根据搜索时算法是先探索到边 $(u, v)$ 还是边 $(v, u)$ 来进行分类。

现在来证明，在对无向图的深搜中，从来不会出现前向边和横向边。

**定理22.10** 在对无向图 $G$ 进行深度优先搜索时，每条边要么是树边，要么是后向边。
**证明**：设 $(u, v)$ 是 $G$ 的任意一条边，不失一般性，假定 $u.d < v.d$ 。那么因为结点 $v$ 在结点 $u$ 的邻接链表中，搜索算法将在完成结点 $u$ 的处理之前（即在结点 $u$ 是灰色的时间段里）、必定发现和完成对结点 $v$ 的处理。
- 如果在搜索算法第一次探索边 $(u, v)$ 时，其方向是从结点 $u$ 到结点 $v$ ，则结点 $v$ 在该时刻之前没有被发现（颜色为白色），不然搜索算法将已经从反方向探索了这条边。因此，在这种情况下，$(u, v)$ 成为一条树边。
- 如果搜索算法第一次探索边 $(u, v)$ 时是从结点 $v$ 到结点 $u$ 的方向，则 $(u, v)$ 是一条后向边，因为在边 $(u, v)$ 被第一次探索时，结点 $u$ 仍然是灰色的。$\blacksquare$

在后面的小节中，将看到这些定理的几种应用。

---
# 3. 拓扑排序
本节阐述，如何使用深搜来对有向无环图进行拓扑排序。对于一个有向无环图 $G = (V, E)$ 来说，其的 ==**拓扑排序** 是 $G$ 中所有结点的一种线性次序，该次序满足如下条件：如果图 $G$ 包含边 $(u, v)$ ，则结点 $u$ 在拓扑排序中处于结点 $v$ 的前面==（如果图 $G$ 包含环路，则不可能得到一个线性次序）。可以将图的拓扑排序，看作是将图的所有结点在一条水平线上排开，图的所有有向边都从左指向右。因此，拓扑排序与通常意义上的“排序”是不同的。

许多实际应用都需要使用有向无环图来指明事件的优先次序。图22-7描述了教授每天早上起床穿衣发生的事件的次序图，他必须先穿某些衣服，才能穿其他衣服，有些服饰则可以以任意顺序穿上。图22-7(a)所示的有向无环图中，有向边 $(u, v)$ 表明服装 $u$ 必须在服装 $v$ 之前穿上。图22-7(b)将拓扑排序后的有向无环图、在一条水平线上展示出来，在该水平线上 所有的有向边都从左指向右。
![](https://img-blog.csdnimg.cn/9feb8065d32142d3933b5c49f45a3490.png)
下面的简单算法，可以对一个有向无环图进行拓扑排序。
```cpp
TOPOLOGICAL-SORT(G)
	call DFS(G) to compute finishing times v.f to each vertex v
	as each vertex is finished, insert it onto the front of a linked list
	return the linked list of vertices
```
图22-7(b)描述的是**经过拓扑排序后的结点次序，这个次序与结点的完成时间恰好相反**。

我们可以在 $\Theta(V+E)$ 的时间内完成拓扑排序，因为深搜算法的运行时间为 $\Theta(V+E)$ ，将结点插入到链表最前端所需的时间为 $O(1)$ ，而一共只有 $|V|$ 个结点需要插入。

我们将使用下面的引理、来证明拓扑排序算法的正确性，该引理描述的是有向无环图的特征。

**引理22.11** 一个有向图 $G = (V, E)$ 是无环的，当且仅当对其进行的深搜不产生后向边。
**证明**：$\rArr$ ：假定对图 $G$ 进行的深搜产生了一条后向边 $(u, v)$ ，则在深度优先森林中，结点 $v$ 是结点 $u$ 的祖先。因此，图 $G$ 包含了一条从 $v$ 到 $u$ 的路径，该路径将与后向边 $(u, v)$ 一起形成一个环路，与题设矛盾。

$\lArr$ ：假定 $G$ 包含一个环路 $c$ 。我们下面来证明，深搜将产生一条后向边。设结点 $v$ 是环路 $c$ 上第一个被发现的结点，设 $(u, v)$ 是环路 $c$ 中结点 $v$ 前面的一条边。在时刻 $v.d$ ，环路 $c$ 中的结点形成一条从结点 $v$ 到结点 $u$ 的全白色结点路径。**根据白色路径定理，结点 $u$ 将在深度优先森林中成为结点 $v$ 的后代**。因此，$(u, v)$ 是一条后向边。$\blacksquare$

**定理22.12** 拓扑排序算法 `TOPOLOGICAL-SORT` 生成的是有向无环图的拓扑排序。
**证明**：假定在有向无环图 $G= (V, E)$ 上运行 `DFS` 来计算结点的完成时间。我们只需要证明，==对于任意一对不同的结点 $u, v \in V$  ，如果图 $G$ 包含一条从结点 $u$ 到结点 $v$ 的边，则 $v.f < u.f$==（从而在最终的拓扑排序中，$u$ 在 $v$ 前面）。

考虑算法 `DFS(G)` 所探索的任意一条边 $(u, v)$ ，当这条边被探索时，结点 $v$ 不可能是灰色，因为那样的话，结点 $v$ 将是结点 $u$ 的祖先，这样 $(u, v)$ 将是一条后向边，与**引理22.11**矛盾。因此，结点 $v$ 要么是白色，要么是黑色。
- 如果结点 $v$ 是白色，它将成为结点 $u$ 的后代，因此 $v.f < u.f$ 。
- 如果结点 $v$ 是黑色，则对其全部的处理都已经完成，因此 $v.f$ 已经被设置。因为我们还需对结点 $u$ 进行探索，$u.f$ 尚需要设定。但一旦我们对 $u.f$ 进行设定，则其数值必定比 $v.f$ 大，即 $v.f < u.f$ 。因此，对于任意一条边 $(u, v)$ ，我们有 $v.f < u.f$ 。$\blacksquare$

---
# 4. 强连通分量
现在来考虑深搜的一个经典应用：将有向图分解为强连通分量。本节将阐述如何使用深搜来做到这一点。**许多针对有向图的算法，都以此种分解操作开始**。在将图分解为强连通分量后，这些算法将分别运行在每个连通分量上，然后根据连通分量之间的连接结构、将各个结果组合起来，从而获得最终所需的结果。

从（算导附录B的讨论）可知，==有向图 $G = (V, E)$ 的强连通分量是一个最大结点集合 $C \subseteq V$ ，对于该集合中的任意一对结点 $u$ 和 $v$ 来说，路径 $u \leadsto v$ 和路径 $v \leadsto u$ 同时存在；也就是说，结点 $u$ 和结点 $v$ 互相可达==。图22-9描述的是强连通分量的一个例子。
![](https://img-blog.csdnimg.cn/677daf7d875649d295d1bfa18adceca1.png)

我们用于寻找强连通分量的算法，需要用到图 $G= (V, E)$ 的转置，在（算导练习22.1-3中）将其定义为 $G^T = (V, E^T)$ ，这里 $E^T = \{ (u, v) \mid (v, u) \in E\}$ 。也就是说，$E^T$ 由对图 $G$ 中的边进行反向而获得。**给定图 $G$ 的邻接链表，创建 $G^T$ 的时间为 $O(V+E)$** 。有趣的是，==图 $G$ 和图 $G^T$ 的强连通分量完全相同：$u$ 和 $v$ 在图 $G$ 中可以相互到达、当且仅当它们在图 $G^T$ 中可以相互到达==。图22-9(b)描述的就是图22-9(a)的转置，我们在其强连通分量上加了阴影。

下面的线性时间（即 $\Theta(V+E)$ 时间）算法，使用两次深搜来计算有向图 $G = (V, E)$ 的强连通分量。**这两次深度优先搜索一次运行在图 $G$ 上，一次运行在转置图 $G^T$ 上**。
```cpp
STRONGLY-CONNECTED-COMPONENTS(G)
	call DFS(G) to compute finishing times u.f for each vertex u
	compute GT
	call DFS(GT), but in the main loop of DFS, consider the vertices
		in order of decreasing u.f (as computed in line 1)
	output the vertices of each tree in the depth-first forest formed in line 3 as a
		separate strongly connected component
```
上述算法背后的思想来自于**分量图** `component graph` $G^{SCC} = (V^{SCC}, E^{SCC})$ 的一个关键性质，分量图的定义如下：==假定图 $G$ 有强连通分量 $C_1, C_2, \dots, C_k$ ，分量图 $G^{SCC}$ 的顶点集 $V^{SCC}$ 为 $\{ v_1, v_2, \dots, v_k\}$ ，对于图 $G$ 的每个强连通分量 $C_i$ 来说，该集合 $V^{SCC}$ 包含代表该分量的结点 $v_i$ 。如果对于某个 $x \in C_i$ 和 $y \in C_j$ ，图 $G$ 包含一条有向边 $(x, y)$ ，则边 $(v_i, v_j) \in E^{SCC}$== 。从另一个角度看，通过收缩所有「相邻结点都在同一个强连通分量中」的边，剩下的图就是 $G^{SCC}$ <code>by contracting all edges whose incident vertices are within the same strongly connected component of G, the resulting graph is G<sup>SCC</sup></code>。图22-9 c)描述的就是图22-9(a)的分量图。

**分量图的关键性质就是：分量图是一个有向无环图** `the component graph is a dag` 。该事实可由下面的引理所推出。

**引理22.13** 设 $C$ 和 $C'$ 为有向图 $G = (V, E)$ 的两个不同的强连通分量，设结点 $u, v \in C$ ，结点 $u', v' \in C'$ ，假定图 $G$ 包含一条从结点 $u$ 到结点 $u'$ 的路径 $u \leadsto u'$ 。那么图 $G$ 不可能包含一条从结点 $v'$ 到结点 $v$ 的路径 $v' \leadsto v$ 。
**证明**：如果图 $G$ 包含一条从结点 $v'$ 到结点 $v$ 的路径 $v' \leadsto v$ ，则 $G$ 也将包含路径 $u \leadsto u' \leadsto v'$ 和 $v' \leadsto v \leadsto u$ 。因此，$u$ 和 $v'$ 可以互相到达，从而与 $C$ 和 $C'$ 是不同的强连通分量的假设矛盾。$\blacksquare$

在后面我们将看到，在进行第二次深搜时，以「第一次深搜所计算出的结点完成时间的递减顺序」来对结点进行考察，我们实际上是在以拓扑排序的次序来访问分量图中的结点（每个结点对应图 $G$ 的一个强连通分量）。

因为算法 `STRONGLY-CONNECTED-COMPONENTS(G)` 执行两次深搜，在讨论 $u.d$ 或 $u.f$ 时可能存在潜在的模糊性。本节中，这些值指的都是第一次深搜（算法第 $1$ 行）计算出的发现时间和完成时间。

下面将结点的发现时间和完成时间的概念、推广到结点集合上：如果结点集合 $U \subseteq V$ ，则定义 $d(U) = \min_{u \in U} \{ u.d \}$ 和 $f(U) = \max_{u \in U} \{ u.f \}$ 。也就是说，$d(U)$ 和 $f(U)$ 分别是结点集合 $U$ 中所有结点里最早的发现时间和最晚的完成时间。

**下面的引理及其推论给出的是一个关键性质**，该性质将图 $G$ 的强连通分量与第一次深搜计算出的完成时间关联起来。

**引理22.14** 设 $C$ 和 $C'$ 为有向图 $G = (V, E)$ 的两个不同的强连通分量。假如存在一条边 $(u, v) \in E$ ，这里 $u \in C, v \in C'$ ，则 $f(C) > f(C')$ 。
**证明**：根据深搜算法中最早发现的结点在哪个强连通分量里，而分为两种情况进行考虑：
- 第一种情况：如果 $d(C) < d(C')$ ，设 **$x$ 为连通分量 $C$ 中最早被发现的结点**，那么在时刻 $x.d$ ，所有 $C$ 和 $C'$ 中的结点都是白色的。在该时刻，图 $G$ 包含一条从结点 $x$ 到 $C$ 中每个结点的、仅包含白色结点的路径。因为 $(u, v) \in E$ ，对于任意结点 $w \in C'$ ，在时刻 $x.d$ 时，$G$ 中也存在一条从结点 $x$ 到结点 $w$ 的、仅包含白色结点的路径 $x \leadsto u \leadsto v \leadsto w$ 。根据白色路径定理，**连通分量 $C$ 和 $C'$ 中的所有结点都成为深度优先树中结点 $x$ 的后代**。根据**推论22.8**，结点 $x$ 的完成时间比起所有的后代都晚，因此 $x.f = f(C) > f(C')$ 。
- 第二种情况：如果 $d(C) > d(C')$ ，设 **$y$ 为连通分量 $C'$ 中最早被发现的结点**，那么在时刻 $y.d$ ，所有 $C'$ 中的结点都是白色的，且图 $G$ 包含一条从结点 $y$ 到 $C'$ 中每个结点的、仅包含白色结点的路径。根据白色路径定理，连通分量 $C'$ 中的所有结点都成为深度优先树里结点 $y$ 的后代。根据**推论22.8**，$y.f = f(C')$ 。在时刻 $y.d$ 时，连通分量 $C$ 中的所有结点都是白色的。由于存在边 $(u, v)$ 将 $C$ 连接到 $C'$ ，**引理22.13**告诉我们，**不可能存在一条从 $C'$ 到 $C$ 的路径**。因此，$C$ 中的结点不可能从 $y$ 到达。在时刻 $y.f$ 时，所有 $C$ 中的结点仍然是白色。因此，对于任意结点 $w \in C$ 来说，我们有 $w.f > y.f$ ，这就意味着 $f(C) > f(C')$ 。$\blacksquare$

下面的推论告诉我们，==转置图 $G^T$ 中连接不同强连通分量的每条边，都是从完成时间较早（第一次深搜计算出的完成时间）的分量、指向完成时间较晚的分量==。

**推论22.15** 设 $C$ 和 $C'$ 为有向图 $G = (V, E)$ 的两个不同的强连通分量，假如存在一条边 $(u, v) \in E^T$ ，这里 $u\in C, v \in C'$ ，则 $f(C)<f(C')$ 。
**证明**：由于边 $(u, v) \in E^T$ ，我们有 $(v, u) \in E$ 。图 $G$ 和图 $G^T$ 的强连通分量相同，**引理22.14**告诉我们，$f(C) < f(C')$ 。$\blacksquare$

==**推论22.15**是我们理解「为什么强连通分量算法能够正确工作」的关键==。我们来看一下，在进行第二次深搜时到底发生了什么。第二次深搜运行在图 $G$ 的转置图 $G^T$ 上。
- 我们从完成时间最晚的强连通分量 $C$ 开始。搜索算法从 $C$ 中的某个结点 $x$ 开始，访问 $C$ 中的所有结点。==根据**推论22.15**，$G^T$ 不可能包含从 $C$ 到任何其他强连通分量的边，因此，从结点 $x$ 开始的搜索不会访问任何其他分量中的结点==。因此，以 $x$ 为根结点的树仅包含 $C$ 的所有结点。
- 在完成对 $C$ 中所有结点的访问后，算法第 $3$ 行从另一个强连通分量 $C'$ 选择一个结点、作为根结点来继续进行深搜，这里 **$f(C')$ 的取值在除 $C$ 以外的所有强连通分量中为最大**。再一次，搜索算法将访问 $C'$ 中的所有结点，但是==根据**推论22.15**，图 $G^T$ 中从 $C'$ 到任何其他强连通分量的边，必定是从 $C'$ 到 $C$ 的边，而这些边我们已经访问过==。
- 一般来说，<font color="red">**当算法第 $3$ 行对 $G^T$ 的深搜访问任意一个强连通分量时，从该强连通分量发出的所有边、只能是通向已经被访问过的强连通分量**</font>。因此，每棵深度优先树恰恰是一个强连通分量。下面的定理，对该论点进行了正式表述。

**定理22.16** 算法 `STRONGLY-CONNECTED-COMPONENTS` 能够正确计算出有向图 $G$ 的强连通分量。
**证明**：我们以算法第 $3$ 行对图 $G^T$ 进行深搜时、发现的深度优先树的棵数来进行归纳。我们的归纳假设是，算法第 $3$ 行生成的前面 $k$ 棵树都是强连通分量。
- 归纳证明的初始情况是 $k = 0$ 时，归纳假设显然成立。
- 在归纳步，假定算法第 $3$ 行生成的前 $k$ 棵树都是强连通分量，现在需要考虑第 $(k+1)$ 棵树。
- 设**该树的根结点为 $u$ ，结点 $u$ 处于强连通分量 $C$ 中**。根据我们在算法第 $3$ 行选择深搜根结点的方式，对于任意「除了 $C$ 以外且尚未被访问的强连通分量 $C'$ 」来说，有 $u.f = f(C) > f(C')$ 。根据归纳假设，在搜索算法访问结点 $u$ 的时刻，$C$ 中的所有结点都是白色的。根据白色路径定理，$C$ 中的其他所有结点都是结点 $u$ 在深度优先树中的后代。
- 而且，根据归纳假设和**推论22.15**，转置图 $G^T$ 中所有从 $C$ 发出的边，只能是指向已经访问过的强连通分量。因此，==除了 $C$ 以外的强连通分量中的结点，不可能在对 $G^T$ 进行深搜时成为结点 $u$ 的后代==。因此，转置图 $G^T$ 中「根结点为结点 $u$ 的深度优先树」中的所有结点、恰好形成一个强连通分量。$\blacksquare$

我们也可以从另一个角度来看第二次深搜的运行过程。考虑转置图 $G^T$ 的分量图 $(G^T)^{SCC}$ 。==如果将第二次深搜访问的每个强连通分量，映射到 $(G^T)^{SCC}$ 的一个结点上，则第二次深搜将以拓扑排序次序的逆序、来访问 $(G^T)^{SCC}$ 中的结点==。如果将 $(G^T)^{SCC}$ 中的边翻转过来，我们将获得图 $(( G^T) ^{SCC})^T$ 。因为 $(( G^T)^{SCC})^T = G^{SCC}$（算导练习22.5-4），所以==第二次深搜是以拓扑排序次序访问 $G^{SCC}$ 中的结点==。 

