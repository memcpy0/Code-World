@[toc]

---
# 1. 什么是递归
## 1.1 递归的定义
**在定义一个过程或函数时出现调用本过程或本函数的成分，称之为递归。** 若调用自身，称之为直接递归。若过程或函数 `p` 调用过程或函数 `q` ，而 `q` 又调用 `p` ，称之为间接递归。**任何间接递归都可以等价地转换为直接递归**。如果一个递归过程或递归函数中递归调用语句是最后一条执行语句，则称这种递归调用为**尾递归**。
>【例】设计求 `n!`（ `n` 为正整数）的递归算法。对应的递归算法如下：
> ```cpp
> int fun(int n) {  
>	if (n == 1)				//语句1
>		return 1;			//语句2
>　 	else					//语句3
>　　	return fun(n - 1) * n;	//语句4
>}
>```
> 在该函数 `fun(n)` 求解过程中，直接调用 `fun(n-1)`（语句4）自身，所以它是一个**直接递归函数**。又由于递归调用是最后一条语句，所以它又属于**尾递归**。

一般来说，能够用递归解决的问题应该满足以下三个条件：
- **需要解决的问题，可以转化为一个或多个子问题来求解**，而这些子问题的求解方法与原问题完全相同，只是在数量规模上不同。
- 递归调用的次数必须是**有限的**。
- 必须有**结束递归的条件**来终止递归。


---
## 1.2 何时使用递归
在以下三种情况下，常常要用到递归的方法。
### (1) 定义是递归的
有许多数学公式、数列等的定义是递归的。例如，求 `n!` 和 `Fibonacci` 数列等。这些问题的求解过程，可以将**递归定义**直接转化为对应的递归算法。 

### (2) 数据结构是递归的
有些数据结构是递归的。例如单链表就是一种递归数据结构，其结点类型声明如下：
```cpp
typedef struct LNode {   
	ElemType data;
    struct LNode *next;	  
} LinkList;      
```
结构体 `LNode` 的定义中用到了它自身，即指针域 `next` 是一种指向自身类型的指针，所以它是一种**递归数据结构**。 不带头结点单链表示意图如下，体现出了数据结构的递归性：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200912112933456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)
对于递归数据结构，采用递归的方法编写算法既方便又有效。例如，求一个不带头结点的单链表 `L` 的所有 `data` 域（假设为 `int` 型）之和的递归算法如下：

```cpp
int Sum(LinkList *L) {   
	if (L == NULL)
　　　　return 0;
　　else 
　　　　return L->data + Sum(L->next); 
} 
```
此外，二叉树也是一种递归数据结构，我们用一个例子分析二叉树的二叉链存储结构的递归性。
>【例】设计求非空二叉链 `bt` 中所有结点值之和的递归算法，假设二叉链的 `data` 域为 `int` 型。
> ```cpp
> typedef struct BNode {   
>	int data;
>   struct BNode *lchild，*rchild;
> } BTNode;		//二叉链结点类型
> ```
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200912113553184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)
> 解答如下：
>  ```cpp
> int Sumbt(BTNode *bt) {	//求二叉树bt中所有结点值之和
>   if (bt->lchild == NULL && bt->rchild == NULL)
>     return bt->data;	    //只有一个结点时返回该结点值
>   else					//否则返回左、右子树结点值之和加上根结点值
>      return Sumbt(bt->lchild) + Sumbt(bt->rchild) > + bt->data;
> }
> ```
> 很简单的递归算法。

### (3) 问题的求解方法是递归的
有些问题的解法是递归的，典型的有 `Hanoi` 问题求解。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200912114036367.png#pic_center)

盘片移动时必须遵守以下规则：每次只能移动一个盘片；盘片可以插在 `X` 、`Y` 和 `Z` 中任一塔座；任何时候都不能将一个较大的盘片放在较小的盘片上。设计递归求解算法。

设 `Hanoi(n, x, y, z)` 表示将 `n` 个盘片从 `x` 通过 `y` 移动到 `z` 上，递归分解的过程是：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200912152038600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70#pic_center)

---
## 1.3 递归模型
**递归模型是递归算法的抽象**，它反映一个递归问题的递归结构。例如前面的递归阶乘算法对应的递归模型如下：
$$\begin{cases}
fun(1)=1                    &(1)\ n = 1\\
fun(n)=n*fun(n-1)        &(2)\ n>1     
\end{cases}
$$

其中，第一个式子给出了递归的终止条件，第二个式子给出了 `fun(n)` 的值与 `fun(n-1)` 的值之间的关系，我们把第一个式子称为**递归出口**，把第二个式子称为**递归体**。

 **一般地，一个递归模型是由递归出口和递归体两部分组成**，前者确定递归到何时结束，后者确定递归求解时的递推关系：
 - 递归出口的一般格式如下：
$$f(s_1) = m_1$$
这里的 $s_1$ 与 $m_1$ 均为常量，有些递归问题可能有几个**递归出口**。
- 递归体的一般格式如下：
$$f(s_{n + 1}) = g(f(s_i),\ f(s_{i+1}),\ \dots, f(s_n),\ c_j,\ c_{j+1},\ \dots,\ c_m)$$
其中，$n, m, i, j$ 均为正整数。这里的 $s_{n+1}$ 是一个**递归大问题**，$s_i,\ s_{i+1},\ \dots,\ s_n$ 为**递归小问题**，$c_j,\ c_{j+1},\ \dots, c_m$ 是**若干个可以直接（用非递归方法）解决的问题**，$g$ 是一个**非递归函数**，可以直接求值。

	所以，递归思路是把一个不能或不好直接解决的大问题转换为一个或几个小问题来解决，再把这些小问题进一步分解成更小的问题来解决，如此直到每个小问题都可以直接解决（此时分解到递归出口）。但是，**递归分解不是随意分解，递归分解必须保证大问题和小问题的求解过程与环境都相似**。
- 为了讨论，上述递归模型简化为：$$\begin{cases}f(s_1) = m_1 \\f(s_{n}) = g(f(s_{n-1}),\ c_{n-1})\end{cases}$$
	求 $f(s_n)$ 的分解过程如下：
	$$f(s_n) \Rightarrow f(s_{n-1}) \Rightarrow \dots \Rightarrow f(s_2) \Rightarrow f(s_1)$$
	一旦遇到递归出口，分解过程结束，开始求值过程。**分解过程是量变，即大问题逐渐变小，但尚未解决；求值过程是质变，原递归问题转换为直接问题**。上述过程的求值过程如下：
	$$f(s_1) = m_1 \Rightarrow f(s_2) = g(f(s_1), c_1) \Rightarrow f(s_3) = g(f(s_2), c_2) \Rightarrow \dots \Rightarrow f(s_n) = g(f(s_{n-1}), c_{n-1})$$

所以，**递归的执行过程由分解和求值两部分构成**。

---
## 1.4 递归算法的执行过程
为了避免陷入到死循环，一个正确的递归程序虽然每次调用的是相同的子程序，但它的参数、输入数据等均有变化。在正常的情况下，随着调用的不断深入，必定会出现调用到某一层的函数时，不再执行递归调用而终止函数的执行，遇到递归出口便是这种情况。

**递归调用是函数嵌套调用的一种特殊情况**，每次递归调用都是调用自身代码的一个复制过程。系统为每次调用开辟一组存储单元，用来存放本次调用的返回地址以及被中断的函数的参数值。**这些单元以系统栈的形式存放，每调用一次进栈一次，当返回时执行出栈操作**，把当前栈顶保留的值送回相应的参量中进行恢复，并按栈顶中的返回地址，从断点继续执行。

对于阶乘递归算法，求 `5!` 即执行 `fun(5)` 时内部栈的变化及求解过程如下：


--- 
# 2. 递推式的计算
## 2.1 用特征方程求解递归方程
### (1) 线性齐次递推式的求解
常系数的线性齐次递推式，一般格式如下：
$$\begin{cases}f(n) = a_1(n-1) + a_2f(n-2) + \dots + a_kf(n-k)\\f(i) = b_i\ \ \ 0\le i \lt k \end{cases}$$

---
# 3. 递归算法设计
## 3.1 递归与数学归纳法
第一数学归纳法原理：若 $\{P(1), P(2), P(3), P(4), \dots \}$ 是命题序列且满足以下两个性质，则所有命题均为真：
- $P(1)$ 为真。
- 任何命题均可以从它的前一个命题推导得出。


---
# 4. 递归算法设计示例

---
# 5. 递归算法转化非递归算法
---




