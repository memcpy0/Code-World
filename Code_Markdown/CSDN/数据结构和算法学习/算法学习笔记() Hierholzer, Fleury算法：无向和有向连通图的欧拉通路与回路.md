O> 本文属于「算法学习」系列文章之一。之前的【数据结构和算法设计】系列着重于基础的数据结构和算法设计课程的学习，与之不同的是，这一系列主要用来记录对大学课程范围之外的高级算法学习、优化与使用的过程，同时也将归纳总结出简洁明了的算法模板，以便记忆和运用。在本系列学习文章中，为了透彻讲解算法和代码，本人参考了诸多博客、教程、文档、书籍等资料，由于精力有限，恕不能一一列出。
> <b></b>
> 为了方便在PC上运行调试、分享代码，我还建立了相关的仓库：[https://github.com/memcpy0/Algorithm-Templates](https://github.com/memcpy0/Algorithm-Templates)。在这一仓库中，你可以看到算法文章、模板代码、应用题目等等。由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[算法学习系列文章目录](https://memcpy0.blog.csdn.net/article/details/117125688)一文以作备忘。

@[toc]

----
# 1. 欧拉路概念
欧拉路是简单的图论问题，和拓扑排序一样，**可以使用DFS直接实现。** 它的最初起源是中世纪数学家欧拉的七桥问题。
- 如果**从图中某个点出发**，能够一笔连续画出整张图，**经过图中每条边一次且仅一次**（点可以重复经过），**就说明图中存在欧拉路**。
- 如果要求起点和终点相同，则称为**欧拉回路**。

欧拉路问题主要有两种：无向图/有向图中是否存在欧拉路径/回路、无向图/有向图中打印出欧拉路径/回路。问题的解决主要通过**处理度 `degree`**。无向图中，一个点上连接的边的数量称为这个点的**度数**，如果度数是奇数，则这个点称为**奇点**、否则称为**偶点**；有向图中则有**出度**和**入度**之分，把点的出度记为 `1` 、入度记为 `-1` ，出度和入度相加就是它的**度数**。

---
# 2. 图中是否存在欧拉路径/回路
## 2.1 算法思路
最简单的问题就是判断欧拉路径/回路是否存在。存在的首要条件是，**图必须是连通图**，编程时可以**用DFS/并查集**等判断连通性。接着根据不同的图类型，判断是否存在欧拉路径/回路：
1. 无向连通图：
	- 如果**图中的点全部都是偶点**（其度数都是偶数），那么存在欧拉回路，图中任何一点都可以作为起点和终点；
	- 如果**图中只有两个奇点**，则存在欧拉路径，其中一个奇点是起点，另一个是终点。**不可能出现有奇数个奇点的无向图**！
2. 有向连通图（是一个强连通分量）：
	- 当且仅当**图中所有点的度数为0**（入度等于出度），有向图中才存在欧拉回路；
	- 如果**图中只有一个度数为1的点、一个度数为-1的点**，**其他所有点的度数为0**，那么存在欧拉路径，其中度数为 `1` 的是起点，度数为 `-1` 的是终点。

- 无向图为（半）欧拉图时，只需用1笔画成；无向图为非（半）欧拉图时，即奇点（度为奇数的点）数k>2，需用k/2笔画成。
- 可以用加边的方式把一个非欧拉图变成欧拉图。对于无向图来说，每个奇点都需加一个度，加的边为 奇点数/2 ；对于有向图来说，每个点都需加上入度与出度之差，加的边数为每个点入度与出度之差的绝对值之和再除以2。

$Hierholzer$ 算法用于在连通图中寻找欧拉路径，其流程如下：
1. 从起点出发，进行深度优先搜索。
2. 每次沿着某条边从某个顶点移动到另外一个顶点时，都需要删除这条边。
3. 如果没有可移动的路径，则将所在节点加入到栈中，并返回。
## 2.2 简单例题和算法实现
以[UVA10054 The Necklace](https://www.luogu.com.cn/problem/UVA10054)为例：
> 题目大意：有一种由彩色珠子连接而成的项链。每个珠子的两半由不同颜色组成。如图所示，相邻两个珠子在接触的地方颜色相同。现在有一些零碎的珠子，需要确认它们是否可以复原成完整的项链。
> <b></b>
输入格式：输入第一行为测试数据组数 $T$ 。每组数据的第一行是一个整数 $N (5 ≤ N ≤ 1000 )$ ，表示珠子的个数。接下来的 $N$ 行每行包含两个整数，即珠子两半的颜色。颜色用 $[1,50]$ 的整数来表示。
> <b></b>
输出格式：对于每组数据，输出测试数据编号和方案。如果无解，输出 `some beads may be lost` 。方案的格式和输入相同，也是一共 $N$ 行，每行用两个整数描述一个珠子（从左到右的顺序），其中第一个整数表示左半的颜色，第二个整数表示右半的颜色。根据题目规定，对于 $1≤i≤ N-1$ ，第 $i$ 行的第二个数必须等于第 $i+1$ 行上的第一个数，且第 $N$ 行的第二个数必须等于第一行的第一个数（因为项链是环形的）。如果有多解，输出任意一组即可。在相邻两组输出之间应有一个空行。

这一题是经典的无向图求欧拉回路。首先判断图是否连通，不连通自然没有欧拉回路；然后判断所有点是否为偶点，如果存在奇点则没有欧拉回路。

下面的代码只判断了点的奇偶性，连通性可以用DFS或并查集实现。本题需要注意的是**可能有重边**，即领接点 $u, v$ 之间可能有多条边。
```cpp
for (int i = 1; i <= n; ++i) { //输入图,用邻接矩阵G[][]存图
	scanf("%d %d", &u, &v);
	++degree[u], ++degree[v];  //记录点的度
	++G[u][v], ++G[v][u];	   //0:不连接,1:连接,>1:有重边
}
for (int i = 1; i <= n; ++i)
	if (d[i] % 2) break;	   //如果存在奇点,退出,无欧拉回路
```

---
# 3. 图中打印出欧拉路径/回路（DFS）
如果要输出无向连通图中的欧拉回路，用DFS是最方便的。
```cpp
void eulerCircle(int u) { //从u开始DFS
	for (int v = 1; v <= 50; ++v) { //深搜u的所有邻居
		if (G[u][v]) {
			--G[u][v], --G[v][u]; //可能有重边
			eulerCircle(v);
			printf("%d %d\n", v, u); //为什么在euler(v)后面打印 // 求边序列
		}
	}
	// 在这里写顶点加入栈中就是求点序列
}
```
为了理解这一程序，可以看下面几幅图：

- [Hierholzer’s Algorithm for directed graph](https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/)
- - [Fleury’s Algorithm for printing Eulerian Path or Circuit](https://www.geeksforgeeks.org/fleurys-algorithm-for-printing-eulerian-path/)
Hierholzer算法的精髓是当每次访问一条边的时候，删除这条边，当遍历完一个节点所连的所有节点后，才将该节点入栈，最后将栈中的节点反转，即可得到欧拉路径
```java
    public void printCircuit(List<List<Integer>> adj) {
        //edgeCount记录记录有向图的边的条数，从当前节点v出发
        Map<Integer, Integer> edgeCount = new HashMap<>();
        for (int i = 0; i < adj.size(); i++) {
            edgeCount.put(i, adj.get(i).size());
        }
        if (edgeCount.isEmpty()) return;
        //栈用来记录节点
        Stack<Integer> currPath = new Stack<>();
        //存储欧拉回路
        List<Integer> circuit = new ArrayList<>();
        //可以从任何点出发
        currPath.push(0);
        int currV = 0; //当前的节点
        while (!currPath.isEmpty()) {
            //当前还有没有走完的边
            if (edgeCount.containsKey(currV) && edgeCount.get(currV) > 0) {
                currPath.push(currV);//存储当前节点
                int nextV = adj.get(currV).get(adj.get(currV).size() - 1);//找下个节点  也可以remove 掉第一个 0
                //删边与删除节点
                edgeCount.put(currV, edgeCount.get(currV) - 1);
                adj.get(currV).remove(adj.get(currV).size() - 1);
                //移动到下一个节点
                currV = nextV;
            } else {//回溯找circuit
                circuit.add(currV);
                currV = currPath.get(currPath.size() - 1);
                currPath.pop();
            }
        }
        for (int i = circuit.size() - 1; i >= 0; i--) {
            System.out.print(circuit.get(i));
            if (i != 0) System.out.print(" -> ");
        }
//        System.out.print("\n");
    } 
```
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202309171421169.png)
步骤
1.如果要找欧拉回路，可以从任意点开始，如果要找欧拉路径，需要从有着奇数度的两个及顶点中的一个开始，如果有奇数度顶点的话

2.选择当前点相连的边，确保删除该边，不会将欧拉图分成两个不同的联通分量

3.将该边加入到路径中，并将该边从欧拉图中删除，如果当前的选择有一个桥与非桥的边时候，优先选非桥的边，不到万不得已，不选桥

4.持续该过程直到路径收集完成

分析
上面的步骤中，选桥边与非桥边的时候，如何判断当前的边是否是桥，这个过程很关键，大体的思路是？？？：
- 从当前节点u出发，计数，哪些顶点可以通过u可达，直接可达和间接可达均可以，记为count1
- 移除掉u-v这条边
- 从当前节点v出发，，哪些顶点可以通过v可达，直接可达和间接可达均可以，记为count2
- 恢复u-v这条边
- 返回count1与count2的大小，如果count2要比count1小，说明移除u-v这条边，从v可达的顶点数量减少，产生了额外的联通分量，此时返回falase,说明这条边是桥，反之返回true
![800](https://img-blog.csdnimg.cn/20210209091318361.gif)
算法在运行过程中删除了所有已走的路径，也就是说途中残留了所有没有行走的边。根据割边的定义，如果在搜索过程中遇到割边意味着当前的搜索路径需要改进，即提前输出某一个联通子集的访问序列，这样就能够保证访问完其中联通子图中后再通过割边访问后一个联通子图，最后再沿原路输出一开始到达该点的路径。如果只有割边可以扩展的话，只需要考虑先输出割边的另一部分联通子集访问序列。


下面的实现是？？？？
```cpp
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
/*
弗罗莱算法 xxx 这是 hierhozler算法
*/
/*
9 12
1 5
1 9
5 3
5 4
5 8
2 3
2 4
4 6
6 7
6 8
7 8
8 9
path:
4 5 8 7 6 8 9 1 5 3 2 4 6
*/
int stk[1005];
int top;
int N, M, ss, tt;
int mp[1005][1005];

void dfs(int x) {
    stk[top++] = x;
    for (int i = 1; i <= N; ++i) {
        if (mp[x][i]) {
            mp[x][i] = mp[i][x] = 0; // 删除此边
            dfs(i);
            break;
        }    
    }
}
void fleury(int ss) {
    int brige;
    top = 0;
    stk[top++] = ss; // 将起点放入Euler路径中
    while (top > 0) {
        brige = 1;
        for (int i = 1; i <= N; ++i) { // 试图搜索一条边不是割边（桥） 
            if (mp[stk[top-1]][i]) {
                brige = 0;
                break;
            }
        }
        if (brige) { // 如果没有点可以扩展，输出并出栈
            printf("%d ", stk[--top]);
        } else { // 否则继续搜索欧拉路径
            dfs(stk[--top]);
        }
    }
}
int main() {
    int x, y, deg, num;
    while (scanf("%d %d", &N, &M) != EOF) {
        memset(mp, 0, sizeof (mp));
        for (int i = 0; i < M; ++i) {
            scanf("%d %d", &x, &y);
            mp[x][y] = mp[y][x] = 1;
        }
        for (int i = 1; i <= N; ++i) {
            deg = num = 0;
            for (int j = 1; j <= N; ++j) {
                deg += mp[i][j];    
            }
            if (deg % 2 == 1) {
                ss = i, ++num;
                printf("%d\n", i);
            }
        }
        if (num == 0 || num == 2) {
            fleury(ss);
        } else {
            puts("No Euler path");
        }
    }
    return 0;    
}
```
图2为连通图G，现利用Fleury算法求它的欧拉通路。（注意区分：欧拉通路、欧拉回路）
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202309171423568.png)
其中一种欧拉通路如下：4 5 8 7 6 8 9 1 5 3 2 4 6，其搜索路径如下图所示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202309171423315.png)
现在让我们来分析算法实现过程：


假设我们这样走：4，6，8，5，此时在5处有三种选择（3，4，1），那么哪种能走通哪种走不通呢？答案是（3，4）通，1不通。为什么呢？来看下图…
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202309171423465.png)


分析：

         因为（5~1）之间的边是除去已走过边（E（G）-｛E1（4~6），E2（6~8），E3（8~5）｝）图G的一个桥，所谓桥即去掉该边后，剩下的所有顶点将不能够连通，即无法构成连通图。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202309171424668.png)
而选择（5~3）和（5~4）则满足定义中第二条（b）中的要求。当然当（5~3）和（5~4）都不存在，即定义中所说“除非无别的边可供选择时”，此时就就可以选择（5~1），其他情况下一定要优先选择非桥的边，否则就可能出现无法走通的情况。也就是说该搜索方法无法构成欧拉通路。如下图是选择（5~1）的后果：

而（5~3）和（5~4）则可以顺利完成欧拉图通路的搜索，具体算法实现网上很多，不是本文讨论重点。相信有了算法思想，算法的实现应该不难，有时间我会完善代码。

另外：譬如洒水车问题也是利用欧拉通路解决的经典问题。

---
输出无向连通图中的欧拉路径

输出有向连通图中的欧拉回路

输出有向连通图中的欧拉路径

上述代码中，图是用邻接矩阵表示的，可以用邻接表或十字前向星重写程序。

---
给定一个 $O(n)$ 个点 $O(m)$ 条边的图，要求==从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小==。这种「一笔画」问题与欧拉图或者半欧拉图有着紧密的联系，下面给出定义：
- 通过**图中所有边恰好一次**且行遍所有顶点的通路称为欧拉通路；
- 通过**图中所有边恰好一次**且行遍所有顶点的回路称为欧拉回路；
- 具有欧拉回路的无向图称为欧拉图；
- 具有欧拉通路但不具有欧拉回路的无向图称为**半欧拉图**。

因为本题保证**至少存在一种合理的路径**，也就告诉了我们，**这张图是一个欧拉图或者半欧拉图**。我们只需要输出这条欧拉通路的路径即可。如果没有保证至少存在一种合理的路径，我们需要**判别这张图是否是欧拉图或者半欧拉图**，具体地：
- 对于无向图 $G$ ，$G$ 是欧拉图当且仅当 **$G$ 是连通的且没有奇度顶点**。
- 对于无向图 $G$ ，$G$ 是半欧拉图当且仅当 **$G$ 是连通的且 $G$ 中恰有 $0$ 个或 $2$ 个奇度顶点**。
- 对于有向图 $G$ ，$G$ 是欧拉图当且仅当 **$G$ 的所有顶点属于同一个强连通分量**且**每个顶点的入度和出度相同**。
- 对于有向图 $G$ ，$G$ 是半欧拉图当且仅当：
    - 如果将 $G$ 中的所有有向边退化为无向边时，那么 $G$ 的所有顶点属于同一个强连通分量；
    - 最多只有一个顶点的出度与入度差为 $1$ ；
    - 最多只有一个顶点的入度与出度差为 $1$ ；
    - **所有其他顶点的入度和出度相同**。

让我们考虑下面的这张图：
![500](https://assets.leetcode-cn.com/solution-static/332/332_fig1.png)
我们从起点 $JFK$ 出发，合法路径有两条：
- $JFK→AAA→JFK→BBB→JFK$
- $JFK→BBB→JFK→AAA→JFK$ 

既然要求字典序最小，那么我们==每次应该贪心地选择当前节点所连的节点中字典序最小的那一个，并将其入栈==。最后栈中就保存了我们遍历的顺序。

为了保证我们能够快速找到当前节点所连的节点中字典序最小的那一个，我们可以使用优先队列存储当前节点所连到的点，每次我们 $O(1)$ 地找到最小字典序的节点，并 $O(\log m)$ 地删除它。

然后我们考虑一种特殊情况：
![500](https://assets.leetcode-cn.com/solution-static/332/332_fig2.png)
当我们先访问 $AAA$ 时，我们无法回到 $JFK$，这样我们就无法访问剩余的边了。也就是说，==当我们贪心地选择字典序最小的节点前进时，我们可能先走入「死胡同」，从而导致无法遍历到其他还未访问的边==。于是我们希望**能够遍历完当前节点所连接的其他节点后再进入「死胡同」**。

注意==对于每一个节点，它只有最多一个「死胡同」分支==。依据前言中**对于半欧拉图的描述，只有那个入度与出度差为 $1$ 的节点会导致死胡同**。

---
# 4. 图中打印出欧拉路径/回路（非递归DFS）
递归常见的问题是爆栈，如果数据很大就不能直接用递归，需要自己手写栈模拟递归。我们在第6节中会遇到这种题目。


---
# 5. 混合图欧拉路径/回路问题
有些图不是单纯的有向图或无向图，而是二者的混合图，同时存在有向边和无向边。这种问题比较困难，需要用最大流求解，具体见Dinic算法和ISAP算法。

---
# 6. 各大OJ的欧拉路径/回路问题
如果套模板判断欧拉路径/回路，似乎很简单。不过，实际的欧拉路问题可不会这么明显：
| 题目链接 | 题解链接 |
|:--|:--
| [UVA10054 The Necklace](https://www.luogu.com.cn/problem/UVA10054) | 

POJ 1780 Code。输入数字位数 $n$ ，输出一串数字，其中包含所有可能的 $n$ 位数字序列，而且只包含一次；用字典序输出。
欧拉回路问题，$n = 10^6$ ，会爆栈。

HDU 4850 Wow! Such String! 用26个小写字母构造一个长度为 $n$ 的串，其中任意长度为 $4$ 的子串都不相同；$n \le 500000$
本题可能有 $4^{26}$ 个子串，这一题有不同解法，如果用DFS，也容易爆栈。

HDU 1878 欧拉回路。判断是否存在回路，无向图
HDU 1116 Play on Words。首尾连单词，有向图，可以分别用DFS和并查集判断连通性。
HDU 5883 The Best Path。无向图欧拉路。

 [UVA10735 混合图的欧拉回路 Euler Circuit](https://www.luogu.com.cn/problem/UVA10735)

[CF1334D Minimum Euler Cycle](https://www.luogu.com.cn/problem/CF1334D)

LeetCode 332. Reconstruct Itinerary【欧拉回路,通路;DFS】困难
LeetCode 753. 破解保险箱【欧拉通路】困难


欧拉路径/回路（Euler）与汉密尔顿路径/回路（Hamilton）

如果给定无孤立结点图G，若存在一条路，经过图中每边一次且仅一次，这条路称为欧拉路径

如果给定无孤立结点图G，若存在一条回路（起点和终点相同），经过图中每边一次且仅一次，那么该回路称为欧拉回路

给定图G，若存在一条路，经过图中每个结点恰好一次，这条路称作汉密尔顿路径

给定图G，若存在一条回路（起点和终点相同），经过图中每个结点恰好一次，这条回路称作汉密尔顿回路



欧拉回路与哈密尔顿回路的区别

「哈密尔顿回路问题」与「欧拉回路问题」看上去十分相似，然而却是完全不同的两个问题。「哈密尔顿回路问题」是访问除原出发节点以外的每个结点一次且仅一次，而「欧拉回路问题」是访问每条边一次且仅一次；对任一给定的图是否存在「欧拉回路」欧拉已给出了充分必要条件，而对任一给定的图是否存在「哈密尔顿回路」至今仍未找到满足该问题的充分必要条件。

在欧拉路径中，可能会多次访问一个顶点，在哈密尔顿路径中，可能无法穿过所有的边