
> 本文属于「算法学习」系列文章之一。之前的「数据结构和算法设计」系列着重于基础的数据结构和算法设计课程的学习，与之不同的是，这一系列主要用来记录大学课程范围之外的**高级算法学习、优化与应用的全过程**，同时也将归纳总结出简洁明了的算法模板，以便记忆和运用。在本系列学习文章中，为了透彻理解算法和代码，本人参考了诸多博客、教程、文档、书籍等资料，由于精力有限，恕不能一一列出，这里只列示重要资料的不完全参考列表：
> - 算法竞赛进阶指南，李煜东著，河南电子音像出版社，[GitHub Tedukuri社区](https://github.com/lydrainbowcat/tedukuri)以及[个人题解文章汇总目录](https://memcpy0.blog.csdn.net/article/details/121280121)
> - 算法 第四版 *Algorithm Fourth Edition*，[美] `Robert Sedgewick, Kevin Wayne` 著，谢路云译，[配套网站](https://algs4.cs.princeton.edu/)
> 
> <b></b>
> 为了方便在PC上运行调试、分享代码，我还建立了相关的[仓库](https://github.com/memcpy0/Algorithm-Templates)。在这一仓库中，你可以看到算法文章、模板代码、应用题目等等。由于本系列文章的内容随时可能发生更新变动，欢迎关注和收藏[算法学习系列文章目录](https://memcpy0.blog.csdn.net/article/details/117125688)一文以作备忘。

@[toc]

---
==目前为止，我们学过的数据结构，维护的都是“数据集的最新状态”==。若想知道数据集合在任意时间的历史状态（即 $\forall i \in [1, M]$ ，执行完操作序列中第 $i$ 项操作后，数据集的状态），一种朴素的做法是 $\forall i \in [1, M]$ ，在第 $i$ 项操作结束后，把整个数据结构拷贝一遍，存储到 `history[i]` 中，多浪费了 $M$ 倍的空间！

==「**可持久化**」则提供了一种思想，在每项操作结束后，仅创建数据结构中、发生改变的部分的副本，不拷贝其他部分==。这样一来，维护数据结构的时间复杂度没有增加，空间复杂度仅增长为与时间同级的规模。换言之，**可持久化数据结构能够高效记录一个数据结构的所有历史状态，从而支持回退和访问之前版本的数据集。**

常用的可持久化数据结构，有可持久化数组、可持久化并查集、可持久化Trie、可持久化线段树等。学习并编写完成这类数据结构，那种成就感非常爽！

---
# 1. 可持久化数组
==可持久化数组是一种支持回退和访问之前版本的数组，也是其他一些可持久化数据结构的基础==，例如可持久化并查集，就要利用到可持久化数组来编写。

## 1.1 模板题目
如题，需要维护这样的一个长度为 $N$ 的数组，支持如下几种操作：
1. 在某个历史版本上，修改某个位置上的值；
2. 访问某个历史版本上的某个位置的值

此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）。

模板题目的具体要求见[P3919【模板】可持久化数组（可持久化线段树/平衡树）](https://www.luogu.com.cn/problem/P3919)。

## 1.2 朴素方法和 `rope`
考虑朴素方法，开一个二维数组 `arr[i][j]` 记录第 `i` 个版本的第 `j` 个数是什么。不过一看数据规模，emmm……朴素算法稳定TLE、MLE：
![在这里插入图片描述](https://img-blog.csdnimg.cn/1796eb812a294d61bc289ee4b404b40e.png)
不过说实在的，这种方法也不是不行——在C++的头文件 `<ext/rope>`（命名空间为 `__gnu_cxx`），有一个神奇的**块状链表**，支持很多有意思的操作，例如支持 $O(1)$ 复制。因此，我们可以每进行一个操作，就复制一个 `rope` 当新版本了，而且不会MLE，缺点在于常数太大、容易超时。一个教程是[【可持久化线段树？！】rope史上最全详解](https://www.cnblogs.com/scx2015noip-as-php/p/rope.html)。

## 1.3 正解
用主席树，不是维护权值线段树，而是维护一棵普通线段树即可：
1. 用原数组建立一个普通线段树；
2. 每次要对数组的某一版本的某一位置进行修改时，相当于以主席树的相应版本的相应位置为模板，新建执行一次单点修改的新版本；访问同理。

有了之前的基础，可持久化数组非常好写。直接结合代码讲解。

问题在于：
- 对于可持久化数组，是否需要建树操作？为什么？
当然需要，权值线段树因为初始状态时，树中都是 $0$ ，所以可以省略建树，但是普通线段树的初始版本是有数值的，所以要先用原数组建立一棵普通线段树，然后再进行操作。
- 一次询问也算作一次操作，那么怎么新建一个与之前版本一样的版本呢？整体复制一遍吗？
不用。由于 `root[]` 记录了主席树每个版本的根结点，所以只需要让 `root[当前版本编号] = root[历史版本编号]` 即可，这样访问当前版本，就会访问到历史版本上去，就相当于复制了一遍。
- 主席树每个版本的线段树维护什么信息？是区间和还是区间最大值？
根据不同的题目维护不同的信息，对于当前的模板题来说，线段树里什么都不用维护，只需要让所有叶子结点里保存数值即可，非叶子结点的 `val` 不用管。



---
# 2. 可持久化并查集


---
# 1. 可持久化Trie
与Trie的节点一样，可持久化Trie的每个节点也有若干字符指针，指向子节点，可用 `trie[x][c]` 保存节点 `x` 的字符指针 `c` 指向的子节点的编号（`0` 代表指向空）。可持久化Trie按照以下步骤，插入一个新的字符串 `s` ：
1. 设当前可持久化Trie的根节点为 `root` ，令 `p = root, i = 0` ；
2. 建立一个新的节点 `q` ，令 `root' = q` ；
3. 若 `p != 0` ，则对于每种字符 `c` ，令 `trie[q, c] = trie[p, c]` ；
4. 建立一个新的节点 `q'` ，令

---

# 1. 可持久化线段树（主席树）
**可持久化线段树**，又因其具有函数的性质，也称为**函数式线段树**。发明人据说是HJT，所以也称为**主席树**。

主席树的思想是——充分利用前后两个版本之间重复的部分，使得空间复杂度下降。这里先学习**单点修改的主席树**。

先考虑朴素做法：由于是可持久化数据结构，我们可以在每次线段树的版本变动时，都新建一个线段树，把每个版本的线段树都保存起来，只是空间复杂度绝对爆炸。如下所示 ，要
![在这里插入图片描述](https://img-blog.csdnimg.cn/563a3ce0143e49ae90a8317c5257776a.png)https://www.bilibili.com/video/BV1C4411u7rK/?spm_id_from=333.788.videocard.12

但是可以发现，两个版本之间有很多相同之处，如果能利用上这些相同的部分，那么就可以节省很大一部分空间。
