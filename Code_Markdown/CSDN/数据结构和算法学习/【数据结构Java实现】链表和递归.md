@[toc]

**递归是极其重要的组建程序逻辑的一种方式**，是作为程序员，编写计算机程序，学习计算机科学绕不过的一个话题。后面的【数据结构Java实现】都和递归脱不开关系。

我不会将递归作为算法的一个专栏，因为递归实际上是编写程序的一种结构，和循环是等价的。**递归真正难的地方，在于与算法思想相结合——如排序，分治，搜索，图论算法，动态规划等；在于与数据结构相结合——如数组，链表，二叉树，红黑树，图等；在于与递归定义的问题相结合——如汉诺塔，斐波拉契数列等。**

## 一、递归思想介绍
递归本质上，是将原来的问题，转换为更小的同一个问题。如数组求和：

$e.g.$ 
- $Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1])$；更小的同一问题。
- $Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1])$；更小的同一问题......
- ......
- $Sum(arr[n-1...n-1]) = arr[n-1] + Sum(arr[\ ]) = arr[n - 1]$；最小的基本问题。

或许这是个很简单的问题，但是它对于理解递归很重要。

```java
public class Sum {
	public static int sum(int[] arr) {
		return sum(arr, 0);
	}
	//计算arr[l...n)这个区间的所有数字的和
	public static int sum(int[] arr, int l) {
		if (l == arr.length) //<----求解基本问题，但基本问题不能自动求解
			return 0;
		return arr[l] + sum(arr, l + 1);
	}
}
```
寻找基本问题是很简单的，但是难的是**如何把原问题转换为更小的问题，以及从更小的问题构建出原问题的答案**。我们需要注意递归函数的宏观语义，递归函数就是一个函数，完成一个功能。

最重要的，就是多练，熟能生巧。

## 二、链表的天然递归结构性质
一个链表：
```
0->1->2->3->4->NULL
可以看做：
0->一个更短的链表(少了一个结点) 长链表可以看做头结点0连接一个短链表
0->[1->2->3->4->NULL]
...
最后有：
0->[1->[2->[3->[4->[NULL]]]]]
```
最后，$NULL$本身也是一个链表，而且**是最平凡最基本的链表，可以当做链表递归的边界**。

我们在处理`0->[1->2->3->4->NULL]`这个长链表时，可以先处理`[1->2->3->4->NULL]`这个短链表，递归解决这个更小的链表中的问题……对于`4->[NULL]`，我们先处理短链表`[NULL]`，然后处理4这个头结点……最后处理0这个头结点。**将得到的短链表和0组合起来，就是原问题的答案。**

理解了上面的一段话，就明白了链表的天然结构性质，可以做一做题，[203.remove linkedlist elements](https://leetcode-cn.com/problems/remove-linked-list-elements/)，解答在[LeetCode C++ 203. Remove Linked List Elements【LinkedList】【递归】](https://blog.csdn.net/myRealization/article/details/104818139)。当然，如果做不出来，也没什么，下面还会有更多的用递归解决的问题。

## 三、推而广之
其实，我们也可以看出，数组也是一个递归数据结构，当然由于数组是连续的空间，用递归处理有些问题时会很麻烦。但是也因此有它的优点，比如**可以很方便的分而治之**，像堆排序、快速排序都是这种策略的典型使用。

像这样的一维线性结构，都是递归数据结构。

但是由于线性结构太简单了，一般用循环就可以很容易的做出答案，而用递归可能还需要想一想。难道递归这么没用吗？绝对不是！等我们后面介绍到了非线性结构，介绍到了算法思想的时候，就会发现，**很多时候用递归比用循环简单太多了**。

## 四、总结
如果可以的话，我可能会把前面的单链表的操作全部补上递归的版本。 

此外，还可能要实现的有双链表，循环双链表、数组链表等。
