@[toc]

# 一、定义
**离散化**，似乎很麻烦的样子，其实就是在我们只需要数据的大小关系时，用排名来代替源数据的一种预处理方法。

本质是一种哈希，在保持原序列大小关系（从大到小或相反）的前提下，**将源数据映射成正整数**。

比如说，当源数据很大、含有负数、小数时，难以表示成数组下标，一些算法或数据结构无法使用，这时我们可以考虑将其离散化。离散化的结果保证了**数据为非负整数且尽可能小，数据之间的大小关系保持不变**。

离散化的一个小坑，就是如何将序列中相同的数映射为相同的排名。用STL做离散处理，很简单。

# 二、举例
现在有$A = \{10, 23, 35, 3, -40, 3\}$这个序列。我们该如何将它离散化呢？

先复制一个同样的序列：
```cpp
int idx[MAXN];
memcpy(idx, A, sizeof(A));
```
排序和去重：
```cpp
sort(idx, idx + n); //从小到大 //从大到小加一个greater<int>()
int len = unique(idx, idx + n) - idx; //得到不重复元素数组的长度/数量
```
$std::unique$的返回值是一个迭代器/数组指针，**表示去重后容器中不重复序列的最后一个元素的下一个元素**，用这个迭代器/指针-`begin()`迭代器/数组头指针，可以得到不重复元素的数量，或者说不重复元素数组的长度。现在我们有$idx = \{-40, 3, 10, 23, 35\}$。

再用一个数组，存储$A$中每个元素在$idx$中的排名。
```cpp
int L[MAXN];
for (int i = 0  i < n; ++i)
	L[i] = lower_bound(idx, idx + len, A[i]) - idx + 1; //二分查找, +1是为了让排名从1开始
```
$lower\_bound( begin,end,num)$：从数组的$begin$位置到$end-1$位置**二分查找第一个大于或等于num的数字**，找到返回该数字的地址，不存在则返回$end$。**通过返回的地址减去起始地址**$begin$，**得到该数字在数组中的下标**。

这样我们有了三个数组：
- $A = \{10, 23, 35, 3, -40, 3\}$；
- $idx = \{-40, 3, 10, 23, 35\}$；
- $L = {3, 4, 5, 2, 1, 2}$ .

总体时间复杂度为排序加上 $n$ 次二分查找，为 $O(n\log n)$。
# 三、模板代码 
算法的过程：

-    复制原序列$A$；
-    去掉序列中重复的元素，按升序进行排序；
-    二分查找原序列$A$数值在新序列$idx$中对应的位置，作为原序列的排名存入对应的新序列$L$位置，**原序列$A$和新序列$L$形成离散化后的映射关系**。
```cpp
int idx[MAXN], L[MAXN];
memcpy(idx, A, sizeof(A)); //复制
sort(idx, idx + n); //从小到大排序 //从大到小加一个greater<int>()
int len = unique(idx, idx + n) - idx; //去重 //得到不重复元素数组的长度/数量 
for (int i = 0  i < n; ++i)
	L[i] = lower_bound(idx, idx + len, A[i]) - idx + 1; //二分查找, +1是为了让排名从1开始
```

