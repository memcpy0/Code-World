> 参考算法导论第8章 线性时间排序
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/a303debb214340f88c6089a8d21224b8.png)


@[toc]

到目前为止，我们已经介绍了几种能在 $O(n\log n)$ 时间内排序 $n$ 个数的算法。归并排序和堆排序达到了最坏情况下的上界；快速排序在平均情况下达到该上界。而且，对于这些算法中的每一个，我们都能给出 $n$ 个输入数值，使得该算法能在 $\Omega(n\log n)$ 时间内完成。这些算法都有一个有趣的性质：**在排序的最终结果中，各元素的次序依赖于它们之间的比较**。我们把这类算法称为**比较排序**，包括归并排序、堆排序、快速排序、以及冒泡/插入/选择排序。
- （算导8.1节）证明，对包含 $n$ 个元素的输入序列来说，任何比较排序在最坏情况下，都要经过 $\Omega(n\log n)$ 次比较。因此，归并排序和堆排序是渐近最优的，并且任何已知的比较排序最多就是在常数因子上优于它们。
- （算导8.2、8.3、8.4节）讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序。当然，这些算法是用运算、而非比较来确定排序顺序的。因此，下界 $\Omega(n\log n)$ 不适用于它们。

# 1. 排序算法的下界
在一个比较排序算法中，我们只使用**元素间的比较**来获得输入序列 $\langle a_1, a_2, \dots, a_n\rangle$ 中的元素间次序的信息。也就是说，给定两个元素 $a_i, a_j$ ，可以执行 $a_i < a_j, a_i \le a_j, a_i  = a_j, a_i \ge a_j, a_i > a_j$ 中的一个比较操作、来确定它们之间的相对次序。我们不能用其他方法观察元素的值或者它们之间的次序信息。

不失一般性，在本节中，我们不妨假设所有的输入元素都是互异的。给定了这个假设后，$a_i = a_j$ 的比较就没有意义了。因此，我们可以假设不需要这种比较。同时，注意到 $a_i \le a_j, a_i \ge a_j, a_i > a_j$ 和 $a_i < a_j$ 都是等价的，因为通过它们所得到的、关于 $a_i$ 和 $a_j$ 的相对次序的信息是相同的，这样，又可以进一步假设所有比较采用的都是 $a_i \le a_j$ 形式。 

## 1.1 决策树模型
比较排序可以被抽象为一棵决策树。**决策树**是一棵完全二叉树，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其他操作都被忽略了。图8-1显示了（算导2.1节中）插入排序算法作用于「包含三个元素的输入序列」的决策树情况。
![](https://img-blog.csdnimg.cn/e10824253e864b92bf946b88fe0fe5e1.png)

在决策树中，每个内部结点都以 $i : j$ 标记，其中 $i, j$ 满足 $1 \le i, j \le n$ ，$n$ 是输入序列中的元素个数。每个叶结点上都标注一个序列 $\langle \pi(1),\ \pi(2),\ \dots,\ \pi(n) \rangle$ ，表示得到的顺序 $a_{\pi(1)}\le a_{\pi(2)}\le \dots \le a_{ \pi(n)}$ 。**排序算法的执行对应于一条从树的根结点到叶结点的路径**——每个内部结点表示一次比较 $a_i \le a_j$ ，左子树表示一旦我们确定 $a_i \le a_j$ 之后的后续比较，右子树则表示在确定了 $a_i > a_j$ 后的后续比较。==当到达一个叶结点时，表示排序算法已经确定了一个顺序 $a_{\pi(1)} \le a_{\pi(2)} \le \dots a_{\pi(n)}$== 。

因为任何正确的排序算法都能够生成输入的每个排列，所以**对一个正确的比较排序算法来说，$n$ 个元素的 $n!$ 种可能的排列，都应该出现在决策树的叶结点上**。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程（称这种叶结点为“可达的”）。因此在后续，我们将只考虑「每种排列都是一个可达的叶结点」的决策树。 
 
## 1.2 最坏情况的下界
在决策树中，从根结点到任意一个可达叶结点之间、最长简单路径的长度，表示的是对应排序算法中最坏情况下的比较次数。因此，**一个比较排序算法中的最坏情况比较次数，就等于其决策树的高度**。同时，当决策树中每种排列都是以可达的叶结点的形式出现时，该决策树高度的下界、也就是比较排序算法运行时间的下界。下面的定理给出这样的一个下界。

**定理8.1** 在最坏情况下，任何比较排序算法都需要做 $\Omega(n\log n)$ 次比较。 
**证明**：根据前面的讨论，对于「一棵每个排列都是一个可达叶结点的决策树」来说，树的高度完全可以被确定。考虑一棵高度为 $h$ 、具有 $l$ 个可达叶结点的决策树，它对应一个对 $n$ 个元素所做的比较排序。因为输入数据的 $n!$ 种可能的排列都是叶结点，所以有 $n! \le l$ 。由于在一棵高为 $h$ 的二叉树中，叶结点的数目不多于 $2^h$ ，我们得到：$$n! \le l \le 2^h$$

对该式两边取对数，有：$$\begin{aligned}
h &\ge \log (n!) \quad &因为\log函数是单调递增的 \\ &= \Omega(n\log n) \quad &由公式(3.19)\end{aligned}$$ 

可证。$\blacksquare$ 

**推论8.2** 堆排序和归并排序都是渐近最优的比较排序算法。
**证明**：堆排序和归并排序的运行时间上界为 $O(n\log n)$ ，这与**定理8.1**给出的最坏情况的下界 $\Omega(n\log n)$ 是一致的。$\blacksquare$

---
# 2. 计数排序
**计数排序**假设 $n$ 个输入元素中的每一个都是在 $0 \sim k$ 区间内的一个整数，其中 $k$ 为某个整数。==当 $k = O(n)$ 时，排序的运行时间为 $\Theta(n)$== 。

计数排序的基本思想是：**对每个输入元素 $x$ ，确定小于 $x$ 的元素个数。利用这一信息，就可以直接把 $x$ 放到「它在输出数组中的位置上」了**。例如，如果有 $17$ 个元素小于 $x$ ，则 $x$ 就应该在第 $18$ 个输出位置上。当有几个元素相同时，这一方案要略作修改，因为不能把它们放在同一个输出位置上。

在计数排序算法的代码中，假设输入是一个数组 $A[1\dots n]$ ，$A.length = n$ 。我们还需要两个数组：$B[1\dots n]$ 存放排序的输出，$C[0\dots k]$ 提供临时存储空间。
```cpp
COUNTING-SORT(A, B, k)
	let C[0...k] be a new array
	for i = 0 to k
		C[i] = 0
	for j = 1 to A.length
		C[A[j]] = C[A[j]] + 1
	// C[i] now contains the number of elements equal to i
	for i = 1 to k
		C[i] = C[i] + C[i - 1]
	// C[i] now contains the number of elements less than or equal to i
	for j = A.length downto 1 // 相等元素中原先在后面的,现在也在后面,稳定!
		B[C[A[j]]] = A[j]
		C[A[j]] = C[A[j]] - 1
```
图8-2展示了计数排序的运行过程。在第 $2 \sim 3$ 行 for 循环的初始化操作后，数组 $C$ 的值全被置为零；第 $4 \sim 5$ 行的 for 循环遍历每个输入元素，如果一个输入元素的值为 $i$ ，就将 $C[i]$ 值加 $1$ 。于是在第 $5$ 行执行完后，**$C[i]$ 中保存的就是等于 $i$ 的元素的个数**，其中 $i = 0, 1, \dots, k$ 。第 $7 \sim 8$ 行通过加总计算，确定对每一个 $i = 0, 1, \dots, k$ **有多少个输入元素是小于或等于 $i$ 的**。

最后，在第 $10 \sim 12$ 行的 for 循环部分，把每个元素 $A[j]$ 放到它在输出数组 $B$ 中的正确位置上。如果所有 $n$ 个元素都是互异的，那么当第一次执行第 $10$ 行时，对每个 $A[j]$ 值来说，$C[A[j]]$ 就是 $A[j]$ 在输出数组中的最终正确位置——这是因为共有 $C[A[j]]$ 个元素小于或等于 $A[j]$ 。==因为所有的元素可能并不都是互异的，所以，我们每将一个值 $A[j]$ 放入数组 $B$ 中以后，都要将 $C[A[j]]$ 的值减 $1$== 。这样，当遇到下一个值等于 $A[j]$ 的输入元素（如果存在）时，该元素可以直接被放到输出数组 $B$ 中 $A[j]$ 的前一个位置上。
![](https://img-blog.csdnimg.cn/46357425960147b09767869e245d9ed5.png)
计数排序的时间代价是多少呢？第 $2 \sim 3$ 行的 for 循环所花时间为 $\Theta(k)$ ，第 $4 \sim 5$ 行的 for 循环所花时间为 $\Theta(n)$ ，第 $7 \sim 8$ 行的 for 循环所花时间为 $\Theta(k)$ ，第 $10 \sim 12$ 行的 for 循环所花时间为 $\Theta(n)$ 。这样，总的时间代价就是 $\Theta(k + n)$ 。==在实际工作中，当 $k = O(n)$ 时，我们一般会采用计数排序，这时的运行时间为 $\Theta(n)$== 。
 
计数排序的下界优于我们（在算导8.1节中）证明的 $\Omega(n\log n)$ ，因为它并不是一个比较排序算法。事实上，它的代码中完全没有输入元素之间的比较操作。相反，计数排序是使用「输入元素的实际值」来确定其在数组中的位置。当我们脱离了比较排序模型时，$\Omega(n\log n)$ 这一下界就不再适用了。

计数排序的一个重要性质就是它是**稳定的**：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。即，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。通常，这种稳定性只有当进行排序的数据还附带卫星数据时，才比较重要。==计数排序的稳定性很重要的另一个原因是：计数排序经常会被用作是基数排序算法的一个子过程==。下一节将看到，**为了使基数排序正确运行，计数排序必须是稳定的**。

---
# 3. 基数排序
**基数排序** `radix sort` 是一种用在卡片排序机上的算法，现在只能在博物馆找到这种卡片排序机了。一张卡片有 $80$ 列，在每一列上机器可以选择在 $12$ 个位置上的任一处穿孔。通过机器操作，我们可以对排序机“编程”来检查每个卡片中的给定列，然后根据穿孔的位置，将它们分别放入 $12$ 个容器中。操作员就可以逐个容器地收集卡片，其中第一个位置穿孔的卡片在最上面，其次是第二个位置穿孔的卡片，依次类推（相当于每张卡片是一个长度为 $80$ 位的 $12$ 进制数）。

对十进制数字来说，每列只会用到 $10$ 个位置（另两个位置用于编码非数值字符）。一个 $d$ 位数将占用  $d$ 列。因为卡片排序机一次只能查看一列，所以要对 $n$ 张卡片上的 $d$ 位数进行排序，就需要设计一个排序算法。

从直观上来看，我们可能会觉得应该按**最高有效位**进行排序，然后对得到的每个容器递归地进行排序。遗憾的是，为了排序一个容器中的卡片，$10$ 个容器中的 $9$ 个都必须先放在一边。这一过程产生了许多要保存的临时卡片（算导练习8.3-5）。

与人们直观感受相悖的是，基数排序是先按**最低有效位**进行排序来解决卡片排序问题的。然后算法将所有卡片合并成一叠，其中 $0$ 号容器中的卡片都在 $1$ 号容器中的卡片之前，而 $1$ 号容器中的卡片又在 $2$ 号容器中的卡片前面，依次类推。之后，用同样的方法按次低有效位、对所有的卡片进行排序，并把排好的卡片再次合并成一叠。重复这一过程，直到对所有的 $d$ 位数字都进行了排序。此时，所有卡片已按 $d$ 位数完全排好序。所以，对这一叠卡片的排序仅需要进行 $d$ 轮。图8-3说明了“一叠”七张 $3$ 位数卡片的基数排序过程。
![在这里插入图片描述](https://img-blog.csdnimg.cn/4aa77b6855444353a734532826b9dd1e.png)

**为了确保基数排序的正确性，一位数排序算法必须是稳定的**。卡片排序机所执行的排序是稳定的，但操作员必须确保卡片从容器中被取出时、不改变顺序，即使一个容器中的所有卡片在该位都是相同的数字，也要确保这一点。

在一台典型的串行随机存取计算机上，我们有时会用基数排序来对具有多关键字域的记录进行排序。例如，我们希望用三个关键字（年、月和日）来对日期进行排序。对这个问题，我们可以使用基于特殊比较函数的排序算法：给定两个日期，先比较年，如果相同，再比较月，如果还是相同，就比较日。我们也可以采用另一种方法，用一种稳定排序算法对这些信息进行三次排序：先日、再月、最后是年。

基数排序的代码是非常直观的。在下面的代码中，我们假设 $n$ 个 $d$ 位的元素存放在数组 $A$ 中，其中第 $1$ 位是最低位，第 $d$ 位是最高位。
```cpp
RADIX-SORT(A, d)
	for i = 1 to d
		use a stable sort to sort array A on digit i
```
**引理8.3** 给定 $n$ 个 $d$ 位数，其中每一个数位有 $k$ 个可能的取值。如果 `RADIX-SORT` 使用的稳定排序方法耗时 $\Theta(n+k)$ ，那么它就可以在 $\Theta(d(n+k))$ 时间内将这些数排好序。
**证明**：基数排序的正确性，可以通过**对被排序的列进行归纳**而加以证明（算导练习8.3-3）。对算法时间代价的分析，依赖于所使用的稳定的排序算法。当每位数字都在 $0$ 到 $k - 1$ 区间内（这样它就有 $k$ 个可能的取值），且 $k$ 的值不太大的时候，计数排序是一个好的选择。对 $n$ 个 $d$ 位数来算，每一轮排序耗时 $\Theta(n + k)$ 。共有 $d$ 轮，因此基数排序的总时间为 $\Theta(d(n+k))$ 。$\blacksquare$

**当 $d$ 为常数且 $k = O(n)$ 时，基数排序具有线性的时间代价**。在更一般的情况中，我们可以灵活地决定，如何将每个关键字分解成若干位（比如说 $65536$ 进制的基数排序）。

**引理8.4** 给定一个 $b$ 位数和任何正整数 $r \le b$ ，如果 `RADIX-SORT` 使用的稳定排序算法、对数据取值区间是 $0 \sim k$ 的输入进行排序耗时 $\Theta(n+k)$ ，那么它就可以在 $\Theta( (b / r) (n + 2^r))$ 时间内将这些数排好序。
**证明**：对一个值 $r \le b$ ，每个关键字可以看成 $d = \lceil b / r \rceil$ 个 $r$ 位数。每个数都是在 $0 \sim 2^r - 1$ 区间内的一个整数，这样就可以采用计数排序，其中 $k = 2^r - 1$（例如，我们可以将一个 $32$ 位的数字，看作是 $2$ 个 $16$ 位的数，于是有 $b = 32, r = 16, d = b / r = 2$ 和 $k = 2^r - 1 = 65535$ ）。每一轮计数排序花费时间为 $\Theta(n+k) = \Theta(n + 2^r)$ ，基数排序花费的总时间代价为 $\Theta(d (n + 2^r)) = \Theta((b / r) (n + 2^r))$ 。$\blacksquare$
 
> 对于**给定的 $n, b$**（$n$ 个 $b$ 位数），我们希望所选择的 $r\ (r \le b)$ 值能够最小化表达式 $(b / r)(n + 2^r)$ 。
> - 如果 $b< \lfloor \log n \rfloor$ ，则对于任何满足 $r \le b$ 的 $r$ ，都有 $(n + 2^r) = \Theta(n)$ 。显然，选择 $r = b$ 得到的时间代价为 $(b / b) (n + 2^b) = \Theta(n)$ ，这一结果是渐近意义上最优的。
> - 如果 $b \ge \lfloor \log n\rfloor$ ，选择 $r = \lfloor \log n\rfloor$ 可以得到偏差不超过常数系数范围内的最优时间代价。下面我们详细说明这一点。
>	- 选择 $r = \lfloor \log n \rfloor$ ，得到的运行时间为 $\Theta(bn / \log n)$ 。
>	- 随着将 $r$ 的值逐步增大到大于 $\lfloor \log n \rfloor$ 后，分子中的 $2^r$ 项比分母中的 $r$ 项增加得快。因此，将 $r$ 增大到大于 $\lfloor \log n \rfloor$ 后，得到的时间代价为 $\Omega(bn / \log n)$ 。
>	- 反之，如果将 $r$ 减小到 $\lfloor \log n \rfloor$ 之下，则 $b / r$ 项会变大，而 $n + 2^r$ 项仍保持为 $\Theta(n)$ 。

基数排序是否比基于比较的排序算法（如快速排序）更好呢？通常情况，如果 $b = O(\log n)$ ，而且我们选择 $r \approx \log n$ ，则基数排序的运行时间为 $\Theta(n)$ 。这一结果看上去要比快速排序的期望运行时间代价 $\Theta(n \log n)$ 更好一些。但是，在这两个表达式中，隐含在 $\Theta$ 符号背后的常数项因子是不同的。在处理 $n$ 个关键字时，尽管基数排序执行的循环次数会比快速排序要少，但每一轮它耗费的时间要长得多。

哪一个排序算法更合适，依赖于具体实现和底层硬件的特性（例如，快速排序通常可以比基数排序更有效地使用硬件的缓存）、以及输入数据的特征。此外，利用计数排序作为中间稳定排序的基数排序不是原地排序，而许多 $\Theta(n\log n)$ 时间的比较排序是原地排序。因此，**当主存的容量比较宝贵时，我们可能会更倾向于像快速排序这样的原址排序算法**。

---
# 4. 桶排序
**桶排序** `bucket sort`  假设输入数据服从均匀分布，平均情况下它的时间代价为 $O(n)$ 。与计数排序类似，因为对输入数据做了某种假设，桶排序的速度也很快。具体来说，==计数排序假设输入数据都属于一个小区间内的整数，而桶排序则假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在 $[0, 1)$ 区间上==（算导C.2节均匀分布的定义）。

桶排序将 $[0, 1)$ 区间划分为 $n$ 个相同大小的子区间，或称为**桶**。然后，将 $n$ 个输入数分布放到各个桶中。**因为输入数据是均匀、独立地分布在 $[0, 1)$ 区间上，所以一般不会出现很多数落在同一个桶中的情况**。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。

在桶排序的代码中，我们假设输入是一个包含 $n$ 个元素的数组 $A$ ，且每个元素 $A[i]$ 满足 $0 \le A[i] < 1$ 。此外，算法还需要一个临时数组 $B[0 \dots n - 1]$ 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。
```cpp
BUCKET-SORT(A)
	n = A.length
	let B[0...n-1] be a new array
	for i = 0 to n - 1
		make B[i] an empty list
	for i = 1 to n
		insert A[i] into list B[ ⌊n A[i]⌋ ]
	for i = 0 to n - 1
		sort list B[i] with insertion sort
	concatenate the lists B[0], B[1], ..., B[n - 1] together in order
```
图8-4显示了在一个「包含 $10$ 个元素的输入数组」上的桶排序过程。
![在这里插入图片描述](https://img-blog.csdnimg.cn/a6adc6a3b03d453d9f04c4e451670cf7.png)

为验证算法的正确性，我们先来看看两个元素 $A[i], A[j]$ 。不失一般性，不妨假设 $A[i] \le A[j]$ 。由于 $\lfloor n A[i] \rfloor \le \lfloor nA[j] \rfloor$ ，元素 $A[i]$ 或者与 $A[j]$ 被放入同一个桶中、或者被放入一个下标更小的桶中。如果 $A[i], A[j]$ 在同一个桶中，则第 $7 \sim 8$ 行的 for 循环会将它们按适当的顺序排列。如果 $A[i], A[j]$ 落入了不同的桶中，则第 $9$ 行会将它们按适当的顺序排列。因此，桶排序算法是正确的。
 
现在来分析桶排序的运行时间。我们注意到，在最坏情况下，除第 $8$ 行外，所有其他各行时间代价都是 $O(n)$ 。我们还需要分析第 $8$ 行中 $n$ 次插入排序调用所花费的总时间。

现在来分析调用插入排序的时间代价。假设 $n_i$ 是表示桶 $B[i]$ 中元素个数的随机变量，因为插入排序的时间代价是平方阶的（算导2.2节），所以桶排序的时间代价为：
$$T(n)= \Theta(n) + \sum^{n-1}_{i=0} O(n^2_i)$$

我们分析桶排序在平均情况下的运行时间。通过对输入数据取期望，我们可以计算出期望的运行时间。对上式两边取期望，并利用期望的线性性质，我们有：
$$\begin{aligned}
E[T(n)] &= E \bigg[ \Theta(n) + \sum^{n-1}_{i=0} O(n_i^2) \bigg ] \\
&= \Theta(n) + \sum^{n-1}_{i=0} E[ O(n_i^2) ] \quad &利用期望的线性性质 \\
&= \Theta(n) + \sum^{n-1}_{i=0} O( E[n_i^2] ) \quad &利用公式(C.22) \end{aligned} \tag{8.1}$$

我们断言：$$E[n_i^2] = 2 - \dfrac{1}{n} \tag{8.2}$$ 对所有 $i = 0, 1, \dots, n - 1$ 成立。这一点不足为奇：因为输入数组 $A$ 的每个元素是等概率地落入任意一个桶中，所以每个桶 $i$ 具有相同的期望值 $E[n_i^2]$ 。为证明公式 $(8.2)$ ，我们定义指示器随机变量：对所有 $i = 0, 1, \dots, n - 1$ 和 $j = 1, 2, \dots, n$ ，$$X_{ij} = I ( A[j]落入桶i)$$

因此，$$n_i = \sum^n_{j=1} X_{ij}$$ 

为了计算 $E[n_i^2]$ ，我们展开平方项，并重新组合各项：
$$\begin{aligned}
E[n_i^2] &= E \bigg[ \bigg( \sum^n_{j=1} X_{ij} \bigg)^2 \bigg] = E \bigg [ \sum^n_{j=1} \sum^n_{k=1} X_{ij} X_{ik} \bigg]  \\
&= E \bigg [ \sum^n_{j=1} X_{ij}^2 + \sum_{1 \le j \le n }\ \sum_{1 \le k \le n,\ k \ne j} X_{ij} X_{ik} \bigg] \\
&= \sum^n_{j=1} E[ X^2_{ij}  ] + \sum_{1 \le j \le n}\ \sum_{1 \le k \le n,\ k \ne j} E[ X_{ij} X_{ik} ] 
\end{aligned} \tag{8.3}$$ 其中，最后一行是根据数学期望的线性性质得出的。我们分别计算这两项累加和，指示器随机变量 $X_{ij}$ 为 $1$ 的概率是 $\dfrac{1}{n}$ 、其他情况下是 $0$ 。于是有：
$$E[X^2_{ij}] = 1^2 \cdot \dfrac{1}{n} + 0^2 \cdot (1 - \dfrac{1}{n}) = \dfrac{1}{n}$$

当 $k \ne j$ 时，随机变量 $X_{ij}$ 和 $X_{ik}$ 是独立的，因此有：$$E[X_{ij} X_{ik} ] = E[X_{ij} ] E[ X_{ik} ] = \dfrac{1}{n} \cdot \dfrac{1}{n} = \dfrac{1}{n^2}$$

将这两个期望值代入公式 $(8.3)$ ，我们有：
$$E[n_i^2] = \sum^n_{j=1} \dfrac{1}{n} + \sum_{1 \le j \le n } \ \sum_{1 \le k \le n,\ k \ne j} \dfrac{1}{n^2} = n \cdot \dfrac{1}{n} + n(n-1) \cdot \dfrac{1}{n^2} = 1 + \dfrac{n -1}{n} = 2 - \dfrac{1}{n}$$
到此，公式 $(8.2)$ 得证。利用公式 $(8.1)$ 中的期望值，我们可以得出结论：桶排序的期望运行时间为 $$\Theta(n) + n \cdot O(2 - \dfrac{1}{n})= \Theta(n)$$

即使输入数据不服从均匀分布，桶排序也仍然可以线性时间内完成。只要输入数据满足下列性质：所有桶的大小的平方和总的元素数呈线性关系，那么通过公式 $(8.1)$ ，我们就可以知道：桶排序仍然能在线性时间完成。

