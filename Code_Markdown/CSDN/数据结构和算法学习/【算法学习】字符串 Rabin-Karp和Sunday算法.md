@[toc]

很多题目都有高效匹配字符串的需求，暴力算法 `brute force` 的复杂度为 $\text{O(mn)}$ ，在十万量级的字符串匹配问题中就已经难以为继。

但是 `KMP` 算法又实在太难理解，如果有一种简单易懂、简洁好写、能够达到 $\text{O(m + n)}$ 的字符串匹配算法该有多好——这就是 `Rabin Karp` 算法。

---
# 1. 字符串匹配Substring Pattern Matching
假设有两个字符串 `source, pattern` ，要求：如果 `source` 中含有 `pattern` ，返回 `pattern` 第一次出现的位置；否则返回 `-1` 。简单来说，就是看 `pattern` 是不是 `source` 的子串。

> 在LeetCode中，我们经常遇到 `子字符串/子数组` 或者 `子序列/子集` 的问题。这些问题常常需要进行算法的优化。


# 2. Brute Force暴力算法
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200728151916670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)

# 3. Rabin Karl算法
如何hashing字符串

比较笼统和宽泛的来说，哈希其实就是把一个定义域较宽的集合映射到一个值域较小的集合。一般来说，我们映射的结果是一个整数，也就是俗称的地址。比如说现在有一个数为x，我们希望进行哈希运算之后的H(x)是一个整数，然后我们把x放到哈希表中地址为H(x)的地方。

如果x是一个数字，这个理解起来比较直观，我们可以定义哈希函数为对这个数字的四则运算，得到一个新的数字，作为x的哈希值。

那么如果x是一个字符串S呢？如果通过一个哈希函数，把字符串S转换为一个整数呢？Hashing字符串一般用的是如下公式：

$$H(S) = \sum_{i=0}^{|S| - 1} \alpha^{|S| - (i+1)} \times char(s_i)$$                                

 

其中，$\alpha$ 代表的是S的定义域大小，比如说如果S全是英文字母，那么的值为26，因为英文字母就只有26个。然后这个函数是一个映射函数，映射S的定义域中的每一个字符到数字的函数。

根据上面的这个公式，就能把任意一个字符串S映射为一个整数。

 
Brute Force算法（暴力解法）

暴力破解Substring Pattern Matching的方法十分直观，过程如下：

假设字符串t的长度为n，字符串p的长度为m。

在字符串t上，放一个长度为m窗口window。

从头开始慢慢的滑动这个窗口window，每滑动一次，就把窗口里的内容和p对比一下。

如果一样，就返回yes。如果不一样，那么继续往右滑动一格窗口window。 

从上述算法可知，in worst case，一共会有(n-m+1)个窗口滑动。->这一步的复杂度是O(n)

然后每次窗口滑动，都涉及到两个长度为m的字符串的比较。->这一步的复杂度是O(m)

由于这两部是一个nested loop，所以最终的算法复杂度是O(m*n)。

 
Rabin-Karp算法

基本思想和暴力破解算法是一样的。也需要一个大小为m的窗口，但是不一样的是，不是直接比较两个长度为m的字符串，而是比较他们的哈希值。

同样的，现在我们做他们的复杂度分析，in worst case，一共会有(n-m+1)个窗口滑动。->这一步的复杂度是O(n)

这个是不变的，但是由于哈希值都是数字，所以两个数字的比较，只需要O(1)。

但是计算哈希值的时间呢？

在一开始的时候，我们需要计算p的哈希值，由于p的长度为m，所以计算p的哈希值的时间为O(m).

然后每一次移动窗口，都需要对窗口内的字符串计算哈希值，此时这个字符串的长度为m，所以计算它哈希值的时间也为O(m).如果照这样看，算法复杂度还是O(m*n)，和上面的暴力破解算法没有任何区别。

但是实际上，计算移动窗口内的哈希值并不需要O(m)，在已知前一个窗口的哈希值的情况下，计算当前窗口的哈希值，只需要O(1)的时间复杂度。

现在再来看上面提到的计算字符串哈希值的函数，假设现在窗口的起点在j这个位置，此时窗口内的字符串哈希值为：
$$H(S, j) = \sum_{i=0}^{m-1} \alpha^{m-(i+1)} \times char(s_i)$$
                            

那么，当计算下一个窗口的哈希值时，也就是当窗口的起点为j+1时，哈希函数值可由如下方法计算：
$$H(S, j + 1) = \alpha(H(S,j) - \alpha^{m-1}char(s_j)) + char(s_j+m)$$
                          

所以，这样看来，在计算出第一个窗口的函数值之后，后面的每一个窗口哈希值都可以根据上述公式计算，只需要做一次减法，一次乘法，一次加法。所以之后的每一次哈希值计算都是O(1)的复杂度。

那么重头来算一次复杂度：

一共有(n-m+1)个窗口，复杂度为O(n).

计算p的哈希值O(m)，计算第一个窗口的复杂度，O(m).

此后计算每一个窗口的复杂度O(1).

所以最终的复杂度是O(m+n)。 

# 4. Sunday算法
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200728151427835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
# 5. HorsPool算法
----
## 题解5：HorsPool算法
`HorsePool` 算法是 `Boyer-Moore` 算法的简单版本，以空间换时间。算法把模式 `P` 和文本 `T` 的开头字符对齐，从模式 `P` 的最后一个字符开始尝试从右往左比较，如果错配，就把模式 `P` 向后移：

一般来说，总结了如下四种情况：
① `A, O` 错配，模式字符串 `t` 中不存在字符 `A` ，于是模式 `t` 向后移动：
```swift
s:	B H E L L A B H A L L O B H E L L O
t:  B H E L L O
```
**移动长度就是它的全部长度**，移到如下位置：
```swift
s:	B H E L L A B H A L L O B H E L L O
t:  			B H E L L O
```
② 这时从后往前比较，发现 `A, E` 错配，模式 `t` 的最后一个字符是 `O` ，而且模式中的其他 `m - 1` 个字符也不包含 `O` 。移动的情况类似情况 ① ，**移动的幅度等于模式的全部长度**，移到如下位置：
```swift
s:	B H E L L A B H A L L O B H E L L O
t:  						B H E L L O
```
---
③ 模式字符串 `t` 中存在字符 `L` ，但 `L`  不是模式的最后一个字符：
```swift
s:	T B H A L L O B H A L L O H E L L O
t:  O H E L L O
```
移动时把模式最右边的 `L` 和文本中的 `L` 对齐，移到第二行的位置：
```swift
s:	T B H A L L O B H A L L O H E L L O
t:    O H E L L O
```
④ 上面中，从后往前比较，发现 `A, E` 错配，模式的最后一个字符是 `O` ，而模式中的其他 `m - 1` 个字符包含 `O` 。移动情况类似情况③，移动时应该将前 `m - 1` 个字符中最右边的 `O` 和文本中的 `O` 对齐，移动到下面的位置：
```swift
s:	T B H A L L O B H A L L O H E L L O
t:    			O H E L L O
```

这说明，比起蛮力算法每次总是移动一个位置，从右到左的字符比较使模式模式移动得更远。然而，如果在每次尝试时都必须检查模式中的每个字符，它的优势也会丧失殆尽。我们可以预先算出遇到某个字符要移动的距离，并把它存在一个表中。具体来说，对于每一个字符c，可以通过以下公式算出移动距离：

t(c)={模式的长度m模式前m−1个字符中最右边的c到模式最后一个字符的距离（如果c不包含在模式的前m-1个字符中）（其他情况下）

如对于模式BARBER，移动距离如下表所示：
字符c 	A 	B 	E 	R 	其它字符（包括空格，标点符号，下划线和其它一些特殊字符）
移动距离t(c) 	4 	2 	1 	3 	6
 

```clike
int Horspool(vector<char> & T,vector<char> & P)
{
    int n = T.size();
    int m = P.size();   
    vector<int> table(96,m);//以字母表中可打印字符为索引的数组

    for(int i = 0;i < m - 1;i++)
    {
        table[P[i] - 32] = m - 1 - i;//模式串中每个字符的移动距离，从左至右扫描模式，相同字符的最后一次改写恰好是该字符在模式串的最右边
    }

    int i = m - 1;
    while(i <= n - 1)
    {
        int k = 0;
        while(k <= m - 1 && P[m - 1 - k] == T[i - k])
            k++;

        if(k == m)
            return i - m + 1;//匹配成功，返回索引
        else
            i += table[T[i] - 32];//模式串向右移动
    }

    return -1;//匹配失败
}
```

 
# 6. Boyer-Moore算法

# 7. Knuth-Morris-Pratt算法
