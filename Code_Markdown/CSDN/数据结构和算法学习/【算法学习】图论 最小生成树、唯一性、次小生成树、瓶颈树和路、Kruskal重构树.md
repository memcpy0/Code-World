
@[toc]

---
# 9.1 求图的最小生成树
## 9.1.1 最小生成树的概念
一个连通图的生成树 `spanning tree` 是一个极小连通子图，它含有图中的全部顶点。

**命题** 设 $G$ 是一个含 $n$ 个顶点的连通图，$T$ 是 $G$ 的生成树（？）：
（1）当且仅当 $T$ 有 $n - 1$ 条边。
（2）若 $e$ 是 $G$ 的一条边，$e$ 不属于 $T$ ，那么 $T \cup \{ e\}$ 含有一个回路。

对于一个带权（假定每条边上的权均为大于零的数）连通无向图 $G$ 中的不同生成树，其每棵树的所有边上的权值之和也可能不同；图的所有生成树中「边上的权值之和最小」的树，称为图的最小生成树 `minimal spanning tree` 。

求图的最小生成树有很多实际应用，例如城市之间交通工程造价最优问题，就是一个最小生成树问题。求图的最小生成树，主要有 `Prim` 算法和 `Kruskal` 算法。

## 9.1.2 用 `Prim` 算法构造最小生成树
### 1. `Prim` 算法构造最小生成树的过程
这种算法是一种构造性算法。假设 $G = (V, E)$ 是一个具有 $n$ 个顶点的带权连通无向图，$T = (U, TE)$ 是 $G$ 的最小生成树，其中 $U$ 是 $T$ 的顶点集，$TE$ 是 $T$ 的边集，则由 $G$ 构造从起始顶点 $v$ 出发的最小生成树 $T$ 的步骤如下：
（1）初始化 $U = \{ v\}$ ，以 $v$ 到其他顶点的所有边为候选边。
（2）重复以下步骤 $n - 1$ 次，使得其他 $n - 1$ 个顶点被加入到 $U$ 中。
- 以顶点集 $U$ 和顶点集 $V - U$ 之间的所有边（称为割集 $(U, V-U)$ ）作为候选边，从中挑选权值最小的边（称为**轻边**）加入 $TE$ ，设该边在 $V - U$ 中的顶点是 $k$ ，将 $k$ 加入 $U$ 中。
- 考察当前 $V - U$ 中的所有顶点 $j$（其实只有与 $k$ 邻接的顶点 $j$  ），修改候选边，若 $(k, j)$ 的权值小于原来和顶点 $j$ 关联的侯选边，则用 $(k, j)$ 取代后者作为侯选边。

对于图9.1所示的带权连通图 $G$ ，采用 `Prim` 算法从顶点 $0$ 出发、构造的最小生成树为 $(0, 5),\ (0, 1),\ (1, 6),\ (1, 2),\ (2, 3),\ (3, 4)$ ，如图9.2所示，图中各边上圆圈内的数字表示 `Prim` 算法输出边的顺序。
![在这里插入图片描述](https://img-blog.csdnimg.cn/b1379848dee1471393fa505a9784c685.png)

### 2. `Prim` 算法设计
`Prim` 算法是基于图的邻接矩阵 $g$ 和初始顶点 $v$ 实现的，其设计的关键是**在两个顶点集合 $U$ 和 $V - U$ 之间选择权最小的边**。为此，建立两个一维数组 `closest` 和 `lowcost` ，前者用于记录最小生成树中每个顶点的父节点，后者用于记录这两个顶点集之间具有最小权值的边（这里的说明好繁琐！）。
1. **通过 `lowcost` 数组标识一个顶点属于 $U$ 还是 $V - U$ 集合**，属于 $U$ 集合的顶点 $i$ 满足 `lowcost[i] = 0` ，属于 $V - U$ 集合的顶点 $j$ 满足 `lowcost[j] != 0` 。
2. 对于$U$ 集合，它到 $V- U$ 集合的某个顶点 $j$ 可能有多条边，其中最小的边为 $(k, j)$ ，那么**用 `lowcost[j]` 记录这条最小边的权值，用 `closest[j]` 记录 $U$ 中的这个顶点 $k$** ，如图9.3所示。若 `lowcost[j] = INF` ，则表示从 $U$ 到顶点 $j$ 没有边。
![在这里插入图片描述](https://img-blog.csdnimg.cn/0c28f5cbb6fb4ae596614d9b691bce46.png)
3. `Prim` 算法首先假设 $U$ 仅仅包含一个起始顶点 $v$ ，并初始化 `lowcost` 和 `closest` 数组—— `lowcost[i] = g.edges[v][i], closest[i] = v` ，即将 $(v, i)$ 作为最小边。
4. 循环 $n - 1$ 次，将 $V - U$ 中的所有顶点添加到 $U$ 中：在 $V- U$ 中找 `lowcost` 值最小的点 $k$（即到 $U$ 集合最近的顶点），输出边 `(closest[k], k)` 作为最小生成树的一条边，将顶点 $k$ 添加到 $U$ 中，此时 $V - U$ 中减少了一个顶点。因为 $U$ 发生改变，我们需要修改 $V - U$ 中每个（与 $k$ 邻接的）顶点 $j$ 的 `lowcost[j]` 和 `closest[j]` 值，实际上只需要将 `lowcost[j]`（$U$ 中没有添加 $k$ 之前的最小边权值）与 `g.edges[k][j]` 比较，若前者较小，不做修改；若后者较小，将 $(k, j)$ 作为顶点 $j$ 的最小边，即置 `lowcost[j] = g.edges[k][j], closest[j] = k` 。

对应的 `Prim` 算法如下：
```cpp
void Prim(int v) { 								// 产生最小生成树tree
	int lowcost[MAXV];
	int closest[MAXV];
	for (int i = 0; i < g.n; ++i) { 			// 初始化lowcost和closest数组
		lowcost[i] = g.edges[v][i];
		closest[i] = v;
	}
	for (int i = 1; i < g.n; ++i) { 			// 找出(n-1)个顶点
		int mincost = INF, k;
		for (int j = 0; j < g.n; ++j) { 		// 在(V-U)中找出离U最近的顶点
			if (lowcost[j] != 0 && lowcost[j] < mincost) { // lowcost[j]为0或INF都不会算
				mincost = lowcost[j];
				k = j;							// k记录最近顶点的编号
			}
		}
		printf("边(%d,%d)权为:%d\n", closest[k], k, mincost);
		lowcost[k] = 0;							// 标记k已经加入U
		for (int j = 0; j < g.n; ++j) { 		// 修改数组lowcost和closest
			if (g.edges[k][j] != 0 && g.edges[k][j] < lowcost[j]) {
				lowcost[j] = g.edges[k][j];
				closest[j] = k;					// j与k是MST中的邻接点
			}
		}
	}
} 
```
【算法分析】`Prim()` 算法中有两重循环，所以时间复杂度为 $O(n^2)$ ，其中 $n$ 为图的顶点个数，从中看出执行时间与图边数 $e$ 无关，所以适合稠密图构造最小生成树。

### 3. `Prim` 算法的正确性证明
`Prim` 是一种贪心算法。对于带权连通无向图 $G = (V, E)$ ，通过对算法步骤的归纳来证明 `Prim` 算法的正确性。

**定理9.1** 对于任意正整数 $k < n$ ，存在一棵最小生成树 $T$ 包含 `Prim` 算法前 $k$ 步选择的边。
**证明**：
（1）$k = 1$ 时，用反证法证明，存在一棵最小生成树 $T$ 包含 $e = (0, i)$ ，其中 $(0, i)$ 是所有关联顶点 $0$ 的边中最小的。具体来说，令 $T$ 为一棵最小生成树，假如 $T$ 不包含 $(0, i)$ ，那么根据命题9.1，$T \cup \{\ (0, i)\ \}$ 含有一个回路，设这个回路中关联顶点 $0$ 的边是 $(0, j)$（？），令：$$T' = (T - \{\ (0, j)\ \} ) \cup \{\ (0, i)\ \}$$ 则 $T'$ 也是一棵生成树，并且所有边的权值和更小（除非 $(0, i)$ 与 $(0, j)$ 的权相同），与 $T$ 为一棵最小生成树矛盾。
（2）假设算法进行了 $k - 1$ 步，生成树的边为 $e_1, e_2, \dots, e_{k - 1}$ ，这些边的 $k$ 个端点构成集合 $U$ ，并且存在 $G$ 的一棵生成树 $T$ 包含这些边。
（3）算法的第 $k$ 步选择了顶点 $i_k$ ，则 $i_k$ 到 $U$ 中顶点的边的权值最小，设这条边为 $e_k = (i_k, i_l)$ 。假设最小生成树 $T$ 不含有边 $e_k$ ，根据命题9.1，将 $e_k$ 添加到 $T$ 中形成一个回路，如图9.4所示，这个回路一定有连接 $U$ 与 $V - U$ 中顶点的边 $e'$ ，用 $e_k$ 替换 $e'$ 得到树 $T'$ ，即：$$T' = (T - \{ e' \}) \cup \{ e_k \}$$ 则 $T'$ 也是一棵生成树，包含边 $e_1, e_2, \dots, e_{k - 1}, e_k$ ，并且 $T'$ 所有边的权值和更小（除非 $e'$ 与 $e_k$ 的权相同），与 $T$ 为一棵最小生成树矛盾。定理即证。
当 $k = n - 1$ 时，$U$ 包含 $G$ 中所有顶点，由 `Prim` 算法构造的 $T= (U, TE)$ 就是 $G$ 的最小生成树。
![在这里插入图片描述](https://img-blog.csdnimg.cn/898a8322a6cd4525bfcd5754af106e7e.png)


---
## 9.1.2 `Kruskal` 算法
`Kruskal` 算法是一种「按权值的递增次序选择合适的边」 来构造最小生成树的方法。假设 $G= (V, E)$ 是一个具有 $n$ 个顶点、$e$ 条边的带权连通无向图，$T = (U, TE)$ 是 $G$ 的最小生成树，则构造最小生成树的步骤如下：
1. 置 $U$ 的初值等于 $V$（即包含有 $G$ 中的全部顶点），$TE$ 的初值为 $\varnothing$（即 $T$ 中的每个顶点都构成一个分量）。
2. 将图 $G$ 中的边按权值从小到大的顺序依次选取，若选取的边未使生成树 $T$ 形成回路，则加入 $TE$ ；否则舍弃，直到 $TE$ 中包含 $n - 1$ 条边为止。

对于图9.1所示的带权连通图 $G$ ，采用 `Kruskal` 算法构造的最小生成树为 $(5, 0),\ (3, 2),\ (6, 1),\ (2, 1),\ (1, 0),\ (4, 3)$ ，如图9.5所示，图中各边上圆圈内的数字表示 `Kruskal` 算法输出边的顺序。
![在这里插入图片描述](https://img-blog.csdnimg.cn/448f30f9de124a268e16c0aa1f97a2e9.png)

### 2. `Kruskal` 算法设计
实现这一算法的关键是，如何判断**选取的边是否与生成树中已有的边形成回路**，这可通过并查集来解决。

对于一个数据序列和一个等价关系，**并查集** `disjoint set` 支持查找一个元素所属的集合、以及合并两个元素各自所属的集合等运算。在这种数据结构中，$n$ 个不同的元素被分为若干组，每组是一个集合，同一集合中的元素满足等价关系，因此也称为**不相交集**。当给出的两个元素满足等价关系、构成一个无序对 $(a, b)$ 时，需要快速合并 $a$ 和 $b$ 分别所在的集合，这期间需要反复查找某元素所在的集合，"并"、"查"、"集"三字由此而来。

可用有根树来表示集合，树中的每个结点包含集合的一个元素，每棵树表示一个集合。多个集合形成一个森林，以每棵树的根结点编号来唯一标识该集合，且根结点的父结点指向其自身，树上的其他结点都用一个父指针来表示它的附属关系。

为了方便，采用顺序存储方法（即采用一个数组 $t$ ）来存储森林，其中结点的类型声明如下：
```cpp

```
给每个结点增加一个**秩** `rank` 域，当该结点作为树根结点时，它是一个与树的高度接近的正整数。并查集的基本运算算法如下：

```cpp

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/6beeab724b824ebf84bd09ecb7038000.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/54370c6f0dbf4fd9a4da9dad3102ee5d.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/8763babbcf604036b062ca06655dbc11.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/f059100ac0574b9ba1af6f550df52244.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/4f212d7339274808a234d7f6ca2db0a9.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/7a02b56fe79946a68b3bf79d64c927b1.png)

### 3. `Kruskal` 算法的正确性证明
`Kruskal` 算法也是一种贪心的构造算法。对于带权连通无向图 $G = (V, E)$ ，通过对算法产生 $T = (U, TE)$ 的边数 $k$ 的归纳步骤来证明 `Kruskal` 算法的正确性。

**定理9.2** `Kruskal` 算法可以找到一棵最小生成树。
**证明**：
（1）$k = 1$ 时，$T$ 中没有任何边，设 $e_1$ 是 $G$ 中权最小的边，加入 $e_1$ 不会产生任何回路。显然是正确的。
（2）假设算法进行了 $k - 1$ 步，产生了 $k -1$ 条边，即 $e_1, e_2, \dots, e_{k - 1}$ ，对应的边集合为 $TE_1$ ，产生的 $T_1 = (U_1, TE_1)$ 是最小生成树的子树（$U_1$ 为 $TE_1$ 中的顶点集）。
 （3）算法第 $k$ 步选择了边 $e = (v, u)$ ，设 $TE_2 = TE_1 \cup \{ e\}$ ，$TE_2$ 中的边把 $G$ 中的顶点分成两个或两个以上的连通分量，设 $S_1$ 是添加边 $e$ 后包含顶点 $v$ 的连通分量的顶点集，$S_2$ 是添加边 $e$ 后包含顶点 $u$ 的连通分量的顶点集。显然，$e$ 是离开 $S$ 的最短边之一（因为之前所有较短边都已经被考察过，它们或者添加到 $T$ 中，或者因为在同一个连通分量中而被丢弃）。现在要证明 $T_2 = (U_2, TE_2)$ 也是最小生成树的子树（$U_2$ 为 $TE_2$ 中的顶点集）。
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/e19132a0ad204785bdc6efc50ee498de.png)
 若最终的最小生成树 $T$ 包含 $e = (v, u)$ ，那么就不需要再进一步证明了，否则在 $T$ 中 $S_1$ 和 $S_2$ 之间一定存在一条边 $e' = (x, y)$（在后面添加的），现在再在 $S_1$ 和 $S_2$ 之间添加边 $e$ ，必构成一个回路，如图9.7所示。显然 $e'$ 的权值大于等于 $e$ 的权值，即 $cost(e') \ge cost(e)$![在这里插入图片描述](https://img-blog.csdnimg.cn/195a239704954afb8f4cda65b3d19f4a.png)
否则边 $e'$ 应该在前面添加，这样由 $S_1$ 和 $S_2$ 加上 $e_1$ 构成的生成树的权值和大于等于 $T_2$ 的权值和，说明 $T$ 不是最小生成树，与 $T$ 是最小生成树的假设矛盾，从而证明 $T_2$ 是最小生成树的子树。
当 $k = n - 1$ 时，由 `Kruskal` 算法构造的 $T=(V, TE)$ 就是 $G$ 的最小生成树。

【例9.1】有 $n$ 个人（人的编号为 $1 \sim n$ ），$m$ 对好友关系，如果两个人或者多个人是直接或间接的好友，则认为是一个朋友圈。例如，$n = 8, m = 3$ ，好友关系为 $\{ (1, 2), (2, 3), (4, 8)\}$ ，则有 $\{ 1, 2, 3\}, \{ 4, 8\}$ 两个朋友圈。设计一个算法求朋友圈的个数。
解：采用并查集实现。首先初始化并查集 $t$ ，对于每个朋友关系 $(x, y)$ ，调用 `Union()` 将它们合并。最后累计非空有根树的棵数（满足 `Find_Set(t, i) == i && t[i].rank != 0` 条件）
![在这里插入图片描述](https://img-blog.csdnimg.cn/7e1f0da6b2a7416887188c272fcce330.png)



---
程小玉：
校园网是为学校师生提供资源共享、信息交流和协同工作的计算机网络。如果一所学校包括多个专业学科及部门，则也可以形成多个局域网络，并通过有线或无线方式连接起来。原来的网络系统只局限于以学院、图书馆为单位的局域网，不能完成集中管理及对各种资源的共享，个别院校还远离大学本部，这些情况都严重阻碍了该校的网络化进程。现在需要设计网络电缆布线，将各个单位连通起来，如何设计才能使布线费用最少呢？可以用无向连通图G=(V,E)表示通信网络，V表示节点集，E表示边集。把各个单位都抽象为图中的节点，把单位之间的通信网络抽象为节点与节点之间的边，边的权值表示布线费用。如果两个节点没有连线，则代表在这两个单位之间不能布线，费用为无穷大，如下图所示。[插图]那么如何设计网络电缆布线，将各个单位连通起来，使布线费用最少呢？对于有n个节点的连通图，只需n-1条边就可以使这个图连通，在n-1条边中要想保证图连通，就必须不包含回路，所以只需找出n-1条权值最小且无回路的边即可。需要说明以下几个概念。• 子图：从原图中选中一些由节点和边组成的图，称之为原图的子图。• 生成子图：选中一些由边和所有节点组成的图，称之为原图的生成子图



• 生成树：如果生成的子图恰好是一棵树，则称之为生成树。• 最小生成树：权值之和最小的生成树，称之为最小生成树。本题求解最小生成树。求解算法有两种：Prim算法和Kruskal算法。7.2.1　Prim算法找出n-1条权值最小的边很容易，那么怎么保证无回路呢？如果在一个图中通过深度搜索或广度搜索判断有没有回路，则工作繁重。有一种很好的办法——集合避圈法。在生成树的过程中，我们把已经在生成树中的节点看作一个集合，把剩下的节点看作另一个集合，从连接两个集合的边中选择一条权值最小的边即可。首先任选一个节点，例如节点1，把它放在集合U中，U={1}，那么剩下的节点即V-U={2,3,4,5,6,7}，集合V是图的所有节点集合，如下图所示。[插图]现在只需看看在连接两个集合（V和V-U）的边中，哪一条边的权值最小，把权值最小的边关联的节点加入集合U中。从上图可以看出，在连接两个集合的3条边中，1-2的边的权值最小，选中它，把节点2加入集合U中，U={1,2}，V-U={3,4,5,6,7}，如下图所示。[插图]再从连接两个集合（V和V−U）的边中选择一条权值最小的边。从上图可以看出，在连接两个集合的4条边中

，节点2到节点7的边的权值最小，选中这条边，把节点7加入集合U={1,2,7}中，V−U={3,4,5,6}。如此下去，直到U=V结束，选中的边和所有的节点组成的图就是最小生成树。这就是Prim算法，1957年由Robert C.Prim发现。那么如何用算法来实现呢？直观地看图，很容易找出集合U到集合V−U的边中哪条边的权值是最小的，但是在程序中如果穷举这些边，再找最小值，则时间复杂度太高，该怎么办呢？可以通过设置两个数组巧妙地解决这个问题，closest[j]表示集合V−U中的节点j到集合U中的最邻近点，lowcost[j]表示集合V−U中的节点j到集合U中的最邻近点的边值，即边(j,closest[j])的权值。例如在上图中，节点7到集合U中的最邻近点是2，closest[7]=2。节点7到最邻近点2的边值为1，即边(2,7)的权值，记为lowcost[7]=1，如下图所示。[插图]所以只需在集合V−U中找到lowcost[]值最小的节点即可。1. 算法步骤（1）初始化。令集合U={u0}，u0∈V，并初始化数组closest[]、

lowcost[]和s[]。（2）在集合V−U中找lowcost值最小的节点t，即lowcost[t]=min{lowcost[j]|j∈V−U}，满足该公式的节点t就是集合V−U中连接集合U的最邻近点。（3）将节点t加入集合U中。（4）如果集合V−U为空，则算法结束，否则转向步骤5。（5）对集合V−U中的所有节点j都更新其lowcost[]和closest[]。更新if(C[t][j]<lowcost [j]){ lowcost[j]=C[t] [j]; closest[j]=t;}，转向步骤2。按照上述步骤，最终可以得到一棵权值之和最小的生成树。2. 完美图解图G（G=(V, E)）是一个无向连通带权图，如下图所示。[插图]（1）初始化。假设u0=1，令集合U={1}，集合V−U={2,3,4,5,6,7}，TE={}，s[1]=true，初始化数组closest[]：除了节点1，其余节点均为1，表示集合V−U中的节点到集合U的最邻近点均为1。lowcost[]：节点1到集合V−U中节点的边值。closest[]和lowcost[]如下图所示。[插图]初始化后如下图所示。[插图]（2）找lowcost

最小的节点。在集合V−U={2,3,4,5,6,7}中，依照贪心策略寻找集合V−U中lowcost最小的节点t。找到的最小值为23，对应的节点t=2，如下图所示。[插图]选中的边和节点如下图所示。[插图]（3）加入集合U中。将节点t加入集合U中，U={1,2}，同时更新V−U={3,4,5,6,7}。（4）更新。对t在集合V−U中的每一个邻接点j，都可以借助t更新。节点2的邻接点是节点3和节点7：• C[2][3]=20<lowcost[3]=∞，更新最邻近距离lowcost[3]=20，最邻近点closest[3]=2；• C[2][7]=1<lowcost[7]=36，更新最邻近距离lowcost[7]=1，最邻近点closest[7]=2。更新后的closest[]和lowcost[]数组如下图所示。[插图]更新后的集合如下图所示。[插图]closest[j]和lowcost[j]分别表示集合V−U中节点j到集合U的最邻近节点和最邻近距离。节点3到集合U的最邻近点为2，最邻近距离为20；节点4、5到集合U的最邻近点仍为初始化状态1，最邻近距离为∞；节点6到集合U的最邻近点为1，最邻近距离为28；节点7到


集合U的最邻近点为2，最邻近距离为1。（5）找lowcost最小的节点。在集合V−U={3,4,5,6,7}中，依照贪心策略寻找集合V−U中lowcost最小的节点t，找到的最小值为1，对应的节点t=7，如下图所示。[插图]选中的边和节点如下图所示。[插图]（6）加入集合U中。将节点t加入集合U中，U={1,2,7}，同时更新V−U={3,4,5,6}。（7）更新。对t在集合V−U中的每一个邻接点j，都可以借t更新。节点7在集合V−U中的邻接点是节点3、4、5、6：• C[7][3]=4<lowcost[3]=20，更新最邻近距离lowcost[3]=4，最邻近点closest[3]=7；• C[7][4]=9<lowcost[4]=∞，更新最邻近距离lowcost[4]=9，最邻近点closest[4]=7；• C[7][5]=16<lowcost[5]=∞，更新最邻近距离lowcost[5]=16，最邻近点closest[5]=7；• C[7][6]=25<lowcost[6]=28，更新最邻近距离lowcost[6]=25，最邻近点closest[6]=7。更新后的closest[]和low

cost[]数组如下图所示。[插图]更新后的集合如下图所示。[插图]节点3到集合U的最邻近点为7，最邻近距离为4；节点4到集合U的最邻近点为7，最邻近距离为9；节点5到集合U的最邻近点为7，最邻近距离为16；节点6到集合U的最邻近点为7，最邻近距离为25。（8）找lowcost最小的节点。在集合V−U={3,4,5,6}中，依照贪心策略寻找集合V−U中lowcost最小的节点t，找到的最小值为4，对应的节点t=3，如下图所示。[插图]选中的边和节点如下图所示。[插图]（9）加入集合U中。将节点t加入集合U中，U ={1,2,3,7}，同时更新V−U={4,5,6}。（10）更新。对t在集合V−U中的每一个邻接点j，都可以借助t更新。节点3在集合V−U中的邻接点是节点4：C[3][4]=15>lowcost[4]=9，不更新；closest[j]和lowcost[j]数组不改变。更新后的集合如下图所示。[插图]节点4到集合U的最邻近点为7，最邻近距离为9；节点5到集合U的最邻近点为7，最邻近距离为16；节点6到集合U的最邻近点为7，最邻近距离为25。（11）找lowcost最小的节点。在集合V−U={4,5,6}中，

依照贪心策略寻找集合V−U中lowcost最小的节点t，找到的最小值为9，对应的节点t=4，如下图所示。[插图]选中的边和节点如下图所示。[插图]（12）加入集合U中。将节点t加入集合U中，U ={1,2,3,4,7}，同时更新V−U={5,6}。（13）更新。对t在集合V−U中的每一个邻接点j，都可以借助t更新。节点4在集合V−U中的邻接点是节点5：C[4][5]=3<lowcost[5]=16，更新最邻近距离lowcost[5]=3，最邻近点closest[5]=4；更新后的closest[]和lowcost[]数组如下图所示。[插图]更新后的集合如下图所示。[插图]

节点5到集合U的最邻近点为4，最邻近距离为3；节点6到集合U的最邻近点为7，最邻近距离为25。（14）找最小。在集合V−U={5,6}中，依照贪心策略寻找集合V−U中lowcost最小的节点t，找到的最小值为3，对应的节点t=5，如下图所示。[插图]选中的边和节点如下图所示。[插图]（15）加入集合U中。将节点t加入集合U中，U={1,2,3,4,5,7}，同时更新V−U={6}。（16）更新。对节点t在集合V−U中的每一个邻接点j，都可以借助t更新。节点5在集合V−U中的邻接点是节点6：C[5][6]=17<lowcost[6]=25，更新最邻近距离lowcost[6]=17，最邻近点closest[6]=5；更新后的closest[]和lowcost[]数组如下图所示。[插图]更新后的集合如下图所示。[插图]节点6到集合U的最邻近点为5，最邻近距离为17。（17）找lowcost最小的节点。在集合V−U={6}中，依照贪心策略寻找集合V−U中lowcost最小的节点t，找到的最小值为17，对应的节点t=6。[插图]选中的边和节点如下图所示。[插图]（18）加入集合U中。将节点t加入集合U中，U ={1,2,3,4,5

,6,7}，同时更新V−U={}。（19）更新。对t在集合V−U中的每一个邻接点j，都可以借t更新。节点6在集合V−U中无邻接点，因为V−U={}。更新后的closest[]和lowcost[]数组如下图所示。[插图]（20）得到的最小生成树如下图所示。最小生成树的权值之和为57，即把lowcost[]数组中的值加起来。[插图]3. 算法实现[插图]4. 算法分析时间复杂度：在Prim(int n, int u0, int c[N][N])算法中，共有4个for语句，①for语句的执行次数为n；②在for语句里面嵌套了两个for语句③、④，它们的执行次数均为n，对算法的运行时间贡献最大，当外层循环标号为1时，③、④for语句在内层循环的控制下均执行n次，外层循环②从1～n，因此，该语句的执行次数为n2，时间复杂度为O(n2)。空间复杂度：算法所需要的辅助空间包含lowcost[]、closest[]和s[]，空间复杂度为O(n)。7.2.2　Kruskal算法构造最小生成树还有一种算法，即Kruskal算法：设图G（G=(V,E)）是无向连通带权图，V={1,2,…,n}；设最小生成树T=(V,TE)，

该树的初始状态为只有n个节点而无边的非连通图T=(V,{})，Kruskal算法将这n个节点看成n个孤立的连通分支。它首先将所有的边都按权值从小到大排序，然后只要在T中选的边数不到n−1，就做这样的贪心选择：在边集E中选取权值最小的边(i,j)，如果将边(i,j)加入集合TE中不产生回路（圈），则将边(i,j)加入边集TE中，即用边(i,j)将这两个连通分支合并连接成一个连通分支；否则继续选择下一条最短边。把边(i,j)从集合E中删去，继续上面的贪心选择，直到T中的所有节点都在同一个连通分支上为止。此时，选取的n−1条边恰好构成图G的一棵最小生成树T。那么，怎样判断加入某条边后图T会不会出现回路呢？该算法对于手工计算十分方便，因为肉眼可以很容易看出挑选哪些边能够避免回路（避圈法），但计算机程序需要一种机制进行判断。Kruskal算法用了一种非常聪明的方法，就是运用集合避圈：如果所选择加入的边的起点和终点都在T的集合中，就可以断定会形成回路（圈）。这其实就是前面提到的“避圈法”：边的两个节点不能属于同一个集合。1. 算法步骤（1）初始化。将所有边都按权值从小到大排序，将每个节点的集合号都

初始化为自身编号。（2）按排序后的顺序选择权值最小的边(u,v)。（3）如果节点u和v属于两个不同的连通分支，则将边(u,v)加入边集TE中，并将两个连通分支合并。（4）如果选取的边数小于n−1，则转向步骤2，否则算法结束。2. 完美图解设图G（G =(V, E)）是无向连通带权图，如下图所示。[插图]（1）初始化。将所有边都按权值从小到大排序，如下图所示。将每个节点都初始化为一个孤立的分支，即一个节点对应一个集合，集合号为该节点的序号，如下图所示。[插图]（2）找最小。在E中寻找权值最小的边e1(2,

7)，边值为1。（3）合并。节点2和节点7的集合号不同，即属于两个不同的连通分支，将边(2,7)加入边集TE中，执行合并操作，将两个连通分支的所有节点都合并为一个集合；假设把小的集合号赋值给大的集合号，以下均做如此处理，那么将节点7的集合号也改为2，如下图所示。[插图]（4）找最小。在E中寻找权值最小的边e2(4,5)，边值为3。（5）合并。节点4和节点5的集合号不同，即属于两个不同的连通分支，将边(4,5)加入边集TE中，执行合并操作，将两个连通分支的所有节点都合并为一个集合，将节点5的集合号也改为4，如下图所示。[插图]（6）找最小。在E中寻找权值最小的边e3(3,7)，边值为4。（7）合并。节点3和节点7的集合号不同，即属于两个不同的连通分支，将边(3,7)加入边集TE中，执行合并操作，将两个连通分支的所有节点都合并为一个集合，将节点3的集合号也改为2，如下图所示。[插图]（8）找最小。在E中寻找权值最小的边e4(4,7)，边值为9。（9）合并。节点4和节点7的集合号不同，即属于两个不同的连通分支，将边(4,7)加入边集TE中，执行合并操作，将两个连通分支的所有节点都合并为一个集合，将节点4、5的

集合号都改为2，如下图所示。[插图]（10）找最小。在E中寻找权值最小的边e5(3,4)，边值为15。（11）合并。节点3和节点4的集合号相同，属于同一连通分支，不能选择，否则会形成回路。（12）找最小。在E中寻找权值最小的边e6(5,7)，边值为16。（13）合并。节点5和节点7的集合号相同，属于同一连通分支，不能选择，否则会形成回路。（14）找最小。在E中寻找权值最小的边e7(5,6)，边值为17。（15）合并。节点5和节点6集合号不同，即属于两个不同的连通分支，将边(5,6)加入边集TE中，执行合并操作，将两个连通分支的所有节点都合并为一个集合，将节点6的集合号改为2，如下图所示。[插图]（16）找最小。在E中寻找权值最小的边e8(2,3)，边值为20。（17）合并。节点2和节点3的集合号相同，属于同一连通分支，不能选择，否则会形成回路。（18）找最小。在E中寻找权值最小的边e9(1,2)，边值为23。（19）合并。节点1和节点2的集合号不同，即属于两个不同的连通分支，将边(1,2)加入边集TE中，执行合并操作，将两个连通分支的所有节点都合并为一个集合，将节点2、3、4、5、6、7的集合号都

改为1，如下图所示。[插图]（20）选中的各边和所有的节点就是最小生成树，各边权值之和就是最小生成树的代价。3. 算法代码[插图][插图]4. 算法分析时间复杂度：在该算法中需要对边进行排序，若使用快速排序，则算法的时间复杂度为O(mlogm)。而合并集合需要n−1次合并，每次合并的时间复杂度都为O(n)，合并集合的时间复杂度为O(n2)。总的时间复杂度为O(mlogm)。如果使用并查集优化合并操作，则每次合并的时间复杂度都为O(logn)。[插图]空间复杂度：辅助空间包括一些变量和集合号数组fa[]，空间复杂度为O(n)。训练1　丛林之路题目描述（POJ1251）：丛林道路网络的维护费用太高，理事会必须选择停止维护一些道路。如下图所示，在下面的地图中，村庄被标记为A～I。左边的地图显示了现在所有道路及每月的维护费用，每月可以用最少的费用维护一些道路，保证所有村庄都是连通的。右边的地图显示了最便宜的道路维护方案，每月的维护总费用为216元。[插图]

输入：输入由1～100个数据集组成，最后一行只包含0。每个数据集的第1行都为数字n（1<n<27），表示村庄的数量，对村庄使用字母表的前n个大写字母标记。每个数据集都有n-1行描述，这些行的村庄标签按字母顺序排序。最后一个村庄没有道路。村庄的每条道路都以村庄标签开头，后面跟着一个从这个村庄到后面村庄的道路数k。如果k>0，则该行后面包含k条道路的数据。每条道路的数据都是道路另一端的村庄标签，后面是道路的每月维护成本。维护费用是小于100的正整数，道路数量不会超过75条，每个村庄通往其他村庄的道路都不超过15条。输出：对于每个数据集，都单行输出每月维护连接所有村庄的道路的最低费用。[插图]题解：这是非常简单的最小生成树问题，只需计算最小生成树的和值即可。使用Prim或Kruskal算法均可求解。注意：在数据的输入格式方面，A 2 B 12 I 25表示A关联两条边，包括A-B的边（边权为12）及A-I的边（边权为25）。算法代码：[插图]训练2　联网题目描述（POJ1287）：已知该区域中的一组点，以及两点之间每条路线所需的电缆长度。请注意，在两个给定点之间可能存在许多路线。假设给定的可能路线（直接
或间接）连接该区域中的每两个点，请设计网络，使每两个点之间都存在连接（直接或间接），并且使用的电缆总长度最小。输入：输入由多个数据集组成，每个数据集都描述一个网络。数据集的第1行包含两个整数：第1个整数表示点数P（P≤50），节点标号为1～P；第2个整数表示点之间的路线数R。以下R行为点之间的路线，每条路线都包括3个整数：前两个整数为点标号，第3个整数为路线长度L（L≤100）。数据集之间以空行分隔，输入仅有一个数字P（P=0）的数据集，表示输入结束。输出：对于每个数据集，都单行输出所设计网络的电缆的最小总长度。[插图]题解：本题是简单的最小生成树问题，可以采用Prim或Kruskal算法求解。在此使用并查集优化的Kruskal算法。1. 算法设计（1）初始化。将所有边都按权值从小到大排序，将每个节点的集合号都初始化为自身编号。（2）按排序后的顺序选择权值最小的边(u,v)。（3）如果节点u和v属于两个不同的连通分支，则采用并查集对两个连通分支进行合并，累加边(v,v)的权值。（4）如果选取的边数小于n−1，则转向步骤2；否则算法结束，返回和值。2. 算法实现[插图]训练3　空间站题目描述（POJ

2031）：空间站由许多单元组成，所有单元都是球形的。在该站成功进入其轨道后不久，每个单元都固定在其预定的位置。两个单元可能彼此接触，甚至重叠。在极端情况下，一个单元可能完全包围另一个单元。所有单元都必须连接，因为机组成员应该能够从任何单元走到任何其他单元。如果存在下面三种情况，则可以从单元A走到另一个单元B：（1）A和B相互接触或重叠；（2）A和B通过“走廊”连接；（3）有一个单元C，从A到C，且从B到C是可能的（传递）。需要设计一种配置，看看用走廊连接哪些单元可以使整个空间站连通。建造走廊的成本与其长度成正比。因此，应该选择走廊总长度最短的计划。输入：输入由多个数据集组成。每个数据集的第1行都包含一个整数n（0<n≤100），表示单元的数量。以下n行是对单元的描述，其中每一行都包含4个值，表示球体的中心坐标x、y和z，以及球体的半径r，每个值都为小数（小数点后3位）。x、y、z和r均为正数且小于100.0。输入的结尾由包含0的行表示。输出：对于每个数据集，都单行输出建造走廊的最短总长度（小数点后3位）。注意：如果不需要建造走廊，则走廊的最短总长度为0.000。[插图]题解：本题属于最小生


成树问题，可以采用Prim或Kruskal算法求解。1. 算法设计（1）计算任意两个单元之间的距离，如果两个单元有接触或重叠，则距离为0.000。（2）采用Prim算法求解最小生成树。（3）输出最小生成树的权值之和。2. 算法实现[插图][插图]训练4　道路建设题目描述（POJ2421）：有N个村庄，编号为1～N，需要建造一些道路，使每两个村庄之间都可以相互连接。两个村庄A和B是相连的，当且仅当A和B之间有一条道路，或者存在一个村庄C，A和C相连且C和B相连。已知一些村庄之间已经有一些道路，你的工作是修建一些道路，使所有村庄都连通起来，所有道路的长度之和最小。输入：第1行是整数N（3≤N≤100），表示村庄的数量；然后是N行，其中第i行包含N个整数，第j个整数表示村庄i和村庄j之间的距离（距离为[1,1000]内的整数）；接着是整数Q（0≤Q≤N×(N+1)/ 2），表示已建成道路的数量；最后是Q行，每行都包含两个整数a和b（1≤a<b≤N），表示村庄a和村庄b之间的道路已经建成。输出：单行输出需要构建的所有道路的最小长度。[插图]题解：本题属于最小生成树问题，不同的是本题有一些道路已经建成，将这些道路


的边权设置为0，然后采用Prim或Kruskal算法求解最小生成树即可。算法代码：[插图][插图]

---
> 参考算导第三版第23章 最小生成树
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/3ba48edce1724fb582a82b63ffa9c137.png)

@[toc]



在电子电路设计中，我们常常需要将多个组件的针脚连接在一起。要连接 $n$ 个针脚，我们可以使用 $n - 1$ 根连线，每根连线连接两个针脚。显然，我们希望使用的连线长度最短。

可以将上述的布线问题，用一个连通无向图 $G =(V, E)$ 来表示，这里的 $V$ 是针脚的集合，$E$ 是针脚之间的可能连接，并且对于每条边 $(u, v) \in E$ ，我们为其赋予权重 $w(u, v)$ 作为连接针脚 $u$ 和针脚 $v$ 的代价（也就是连线的长度）。**我们希望找到一个无环子集 $T\subseteq E$ ，既能够将所有的结点（针脚）连接起来，又具有最小的权重，即 $w(T) = \displaystyle \sum_{ (u, v) \in T} w(u, v)$ 的值最小**。由于 $T$ 是无环的，并且连通所有的结点，因此 $T$ 必然是一棵树（自由树性质）。我们称这样的树为（图 $G$ 的）**生成树**，因为它是由图 $G$ 所生成的。我们称求取该生成树的问题为**最小生成树问题**（这是“最小权重生成树”的简称；例如，我们并不打算将 $T$ 中的边的条数减到最少，因为根据自由树性质，生成树必须恰好有 $|V| -1$ 条边）。图23-1描述的是一个连通图及其最小生成树的例子。
![在这里插入图片描述](https://img-blog.csdnimg.cn/1e09efc8bf094a5fa1f68fcc02472709.png)
在这节，我们详细讨论解决最小生成树问题的两种算法：*Kruskal* 算法和 *Prim* 算法。如果使用普通的二叉堆，那么可以很容易地将这两个算法的时间复杂度限制在 $O(E \log V)$ 的数量级内。但如果使用斐波那契堆，*Prim* 算法的运行时间将改善为 $O(E + V\log V)$ ，此运行时间在 $|V|$ 远远小于 $|E|$ 的情况下、较二叉堆有很大改进。

这里讨论的两种最小生成树算法都是贪心算法。（如算导第16章讨论的）贪心算法的每一步必须在多个可能的选择中选择一种。贪心算法推荐选择在当前看来是最好的选择。这种策略一般并不能保证找到一个全局最优的解决方案。但是，对于最小生成树问题来说，我们可以证明，某些贪心策略确实能找到一棵权重最小的生成树（即算导第16章介绍的理论思想的一种经典应用）。

因为树是图的一种，为了精确起见，在定义树时不仅要用到边，还必须用到结点。虽然这里在讨论树时关注的是它的边，但我们必须留意的是，**树 $T$ 中的结点是指由 $T$ 中的边所连接的结点**。


# 1. 最小生成树的形成
假定有一个连通无向图 $G= (V, E)$ 和权重函数 $w : E\to \R$ ，我们希望找出图 $G$ 的一棵最小生成树，这里讨论的两种算法、都使用贪心策略来解决这个问题，但它们使用贪心策略的方式却有所不同。

这个贪心策略可以用下面的通用方法来表述。==该通用方法在每个时刻生长最小生成树的一条边，并在整个策略的实施过程中，管理一个遵守下述循环不变式的边集合 $A$ ：**在每遍循环之前，$A$ 是某棵最小生成树的一个子集**==。

在每一步我们要做的事情是，==选择一条边 $(u, v)$ 、将其加入到集合 $A$ 中，使得 $A$ 不违反循环不变式，即 $A \cup \{ (u, v) \}$ 也是某棵最小生成树的子集==。由于我们可以安全地将这种边加入到集合 $A$ 、而不会破坏 $A$ 的循环不变式，因此称这样的边为集合 $A$ 的**安全边** `safe edge` 。
```cpp
GENERIC-MST(G, w)
	A = ∅
	while A does not form a spanning tree
		find an edge(u, v) that is safe for A
		A = A ∪ {(u, v)}
	return A
```
我们使用循环不变式的方式如下：
1. **初始化**：在算法第 $1$ 行之后，集合 $A$ 直接满足循环不变式（空集是任何集合的子集）。
2. **保持**：算法第 $2 \sim 4$ 行的循环，通过只加入安全边来维持循环不变式。
3. **终止**：所有加入到集合 $A$ 中的边都属于某棵最小生成树，因此，算法第 $5$ 行返回的集合 $A$ 必然是一棵最小生成树。

当然，这里的奥妙是算法的第 $3$ 行：找到一条安全边。**这条安全边必然存在**，因为在执行算法第 $3$ 行时，循环不变式告诉我们存在一棵生成树 $T$ ，满足 $A \subseteq T$ 。在第 $2 \sim 4$ 行的 while 循环体内，集合 $A$ 一定是 $T$ 的真子集。因此，必然存在一条边 $(u, v) \in T$ ，使得 $(u, v) \notin A$ ，并且 $(u, v)$ 对于集合 $A$ 是安全的。

在剩下的篇幅里，我们将介绍辨认安全边的规则（**定理31.1**）。下一节则讨论、使用这条规则来快速找到安全边的两个算法。

我们首先需要一些定义。无向图 $G = (V, E)$ 的一个**切割** `cut` $(S, V - S)$ 是集合 $V$ 的一个划分，如图23-2所示。如果一条边 $(u, v) \in E$ 的一个端点位于集合 $S$ ，另一个端点位于集合 $V - S$ ，则称该条边**横跨** `cross` 切割 $(S, V - S)$ 。==如果集合 $A$ 中不存在横跨该切割的边，则称该切割**尊重** `respects` 集合 $A$== 。在横跨一个切割的所有边中，权重最小的边称为**轻量级边** `light edge` 。注意，轻量级边可能不是唯一的。一般，如果一条边是满足某个性质的所有边中权重最小的，则称该条边是满足给定性质的一条**轻量级边**。
![](https://img-blog.csdnimg.cn/9d6efa7cbb504aadacaf2b6a58724a8e.png)
用来辨认安全边的规则，由下面的定理给出。

**定理23.1** 设 $G = (V, E)$ 是一个在边 $E$ 上定义了实数值权重函数 $w$ 的连通无向图。设集合 $A$ 为 $E$ 的一个子集，且 $A$ 包括在图 $G$ 的某棵最小生成树中，设 $(S, V-S)$ 是图 $G$ 中**尊重**集合 $A$ 的任意一个切割，又设 $(u, v)$ 是横跨切割 $(S, V-S)$ 的一条轻量级边。那么边 $(u, v)$ 对于集合 $A$ 是安全的。
**证明**：设 $T$ 是一棵包括 $A$ 的最小生成树，并假定 $T$ 不包含轻量级边 $(u, v)$ ；否则，我们已经证明完毕。现在来构建另一棵最小生成树 $T'$ ，我们通过剪切和粘贴 `a cut-and-paste technique` 来将 $A \cup \{ (u, v) \}$ 包括在树 $T'$ 中，从而证明 $(u, v)$ 对于集合 $A$ 来说是安全的。

边 $(u, v)$ 与「 $T$ 中从结点 $u$ 到结点 $v$ 的简单路径 $p$ 」形成一个环路，如图23-3所示。由于结点 $u$ 和结点 $v$ 分别在切割 $(S, V-S)$ 的两端，$T$ 中至少有一条边属于简单路径 $p$ 、并且横跨该切割。设 $(x, y)$ 为这样的一条边，因为切割 $(S, V-S)$ 尊重集合 $A$ ，所以边 $(x, y)$ 不在集合 $A$ 中。由于边 $(x, y)$ 位于 $T$ 中从 $u$ 到 $v$ 的唯一简单路径上，将该条边删除会导致 $T$ 被分解为两个连通向量。将 $(u, v)$ 加上去可将这两个连通分量连接起来、形成一棵新的生成树 $T' = T - \{ (x, y) \} \cup \{ (u, v) \}$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/bc6c1dd2f30c4a95b29aa6b07ecba9b3.png)
下面证明 $T'$ 是一棵最小生成树。由于边 $(u, v)$ 是横跨切割 $(S, V - S)$ 的一条轻量级边、并且边 $(x, y)$ 也横跨该切割，我们有 $w (u, v) \le w(x, y)$ 。因此，$$w(T') = w(T) - w(x, y) + w(u, v) \le w(T)$$

但是，$T$ 是一棵最小生成树，所以有 $w(T) \le w(T')$ ；因此，$T'$ 一定也是一棵最小生成树。

下面还需要证明，**边 $(u, v)$ 对于集合 $A$ 来说是一条安全边**。因为 $A \subseteq T$ 并且 $(x, y) \notin A$ ，所以有 $A \subseteq T'$ ；因此 $A \cup \{ (u, v) \} \subseteq T'$ 。==由于 $T'$ 是最小生成树，$(u, v)$ 对于集合 $A$ 是安全的==。$\blacksquare$ 

**定理23.1**能够帮助我们更好地理解、连通图 $G = (V, E)$ 上算法 `GENERIC-MST` 的工作原理。随着该算法的推进，集合 $A$ 总是保持在无环状态；否则，包含 $A$ 的最小生成树将包含一个环路，这将与树的定义相矛盾。==在算法执行的任意时刻，图 $G_A = (V, A)$ 是一个森林，$G_A$ 中的每个连通分量则是一棵树==（某些树可能仅包含一个结点，如在算法开始时，集合 $A$ 为空，而森林中包含 $|V|$ 棵树，每棵树中只有一个结点）。而且，==由于 $A \cup \{ (u, v) \}$ 必须是无环的，所有对于集合 $A$ 为安全的边 $(u,v)$ 所连接的是 $G_A$ 中不同的连通分量==。

`GENERIC-MST` 算法的第 $2 \sim 4$ 行的 while 循环，执行的总次数为 $|V| - 1$ 次，因为该循环的每次迭代，都找出最小生成树所需 $|V| - 1$ 条边中的一条。在初始时，当 $A = \varnothing$ 时，$G_A$ 中有 $|V|$ 棵树，每次循环将树的数量减少 $1$ 棵。当整个森林仅包含一棵树时，该算法就终止。

（算导23.2节的）下面两个算法将使用**定理23.1**的下列推论。

**推论23.2** 设 $G= (V, E)$ 是一个连通无向图，并有定义在边集合 $E$ 上的实数值权重函数 $w$ 。设边集合 $A$ 为 $E$ 的一个子集，且该子集包括在 $G$ 的某棵最小生成树里，并设 $C = (V_C, E_C)$ 为森林 $G_A=(V, A)$ 中的一个连通分量（树）。如果边 $(u, v)$ 是连接 $C$ 和 $G_A$ 中某个其他连通分量的一条轻量级边，则边 $(u, v)$ 对于集合 $A$ 是安全的。
**证明**：切割 $(V_C, V - V_C)$ 尊重集合 $A$ ，边 $(u, v)$ 是横跨该切割的一条轻量级边，因此边 $(u, v)$ 对于集合 $A$ 是安全的。$\blacksquare$


---
# 2. *Kruskal* 算法和 *Prim* 算法
这里讨论最小生成树问题的两个经典算法，这两种算法都是前一节讨论的通用算法的细化，每种算法都使用一条具体的规则来确定 `GENERIC_MST` 算法第三行描述的安全边。
- 在 *Kruskal* 算法中，**边集合 $A$ 是一个森林，其结点就是给定图的结点**（即 $G_A = (V, A)$ ）。每次加入到集合 $A$ 中的安全边，永远是权重最小的、连接两个不同分量的边。
- 在 *Prim* 算法中，**边集合 $A$ 则是一棵树**（同样也有 $G_A = (V, A)$ ），每次加入到 $A$ 中的安全边，永远是连接 $A$ 和 $A$ 之外某个结点（可看作是 $G_A$ 中的另一个连通分量）的边中权重最小的边。

## 2.1 *Kruskal* 算法
*Kruskal* 算法找到安全边的办法是，在所有连接森林的两棵不同树的边中，找到权重最小的边 $(u, v)$ 。设 $C_1, C_2$ 为边 $(u, v)$ 连接的两棵树。由于边 $(u, v)$ 一定是连接 $C_1$ 和其他某棵树的一条轻量级边，**推论23.2**蕴含：边 $(u, v)$ 是 $C_1$ 的一条安全边。很显然，*Kruskal* 算法属于贪心算法，因为它每次都选择一条权重最小的边加入到森林。

*Kruskal* 算法的实现，与（算导21.1节讨论的）计算连通分量的算法类似。我们使用一个不相交集合数据结构来维护几个互不相交的元素集合，每个集合代表当前森林中的一棵树。操作 `FIND-SET(u)` 用来返回「包含元素 $u$ 的集合」的代表元素。我们可以通过测试 `FIND-SET(u)` 是否等于 `FIND-SET(v)` 来判断结点 $u$ 和结点 $v$ 是否属于同一棵树。*Kruskal* 算法使用 `UNION` 过程来对两棵树进行合并。
```cpp
MST-KRUSKAL(G, w)
	A = ∅
	for each vertex v in G.V
		MAKE-SET(v)
	sort the edges of G.E into nondecreasing order by weight w
	for each edge(u, v) in G.E, taken in nondecreasing order by weight
		if FIND-SET(v) != FIND-SET(v)
			A = A ∪ {(u, v)}
			UNION(u, v)
	return A
```
图23-4描述的是 *Kruskal* 算法的工作过程。算法第 $1 \sim 3$ 行将集合 $A$ 初始化为一个空集合，并创建 $|V|$ 棵树，每棵树仅包含一个结点。算法第 $5 \sim 8$ 行的 for 循环，按照权重从低到高的次序，对每条边逐一进行检查。对于每条边 $(u,v)$ 来说，该循环将检查端点 $u$ 和端点 $v$ 是否属于同一棵树。如果是，该条边不能加入到森林中（否则将形成环路）。如果不是，则两个端点分别属于不同的树，算法第 $7$ 步将把这条边加入到集合 $A$ 中，第 $8$ 行则将两棵树中的结点进行合并。
![ ](https://img-blog.csdnimg.cn/de0f3d5174a34f4a84ba98e95092c379.png)
![ ](https://img-blog.csdnimg.cn/acdb90fc598e44f292b95c1b15c036c7.png)

**对于图 $G = (V, E)$ ，*Kruskal* 算法的运行时间依赖于不相交集合数据结构的实现方式**。假定使用（算导21.3节讨论的）不相交集合森林实现，并增加按秩合并和路径压缩的功能，因为这是目前已知的渐近时间最快的实现方式。在这种实现模式下，
- 算法第 $1$ 行对集合 $A$ 的初始化时间为 $O(1)$ ，第 $4$ 行对边进行排序的时间为 $O(E \log E)$（稍后讨论算法第 $2 \sim 3$ 行 for 循环中的 $|V|$ 个 `MAKE-SET` 操作的代价）。
- 算法第 $5 \sim 8$ 行的 for 循环执行 $O(E)$ 个 `FIND-SET` 和 `UNION` 操作。与 $|V|$ 个 `MAKE-SET` 操作一起，这些操作的总运行时间为 $O(( V+E) \alpha(V))$ ，这里 $\alpha$ 是（算导21.4节定义的）一个增长非常缓慢的函数。
- 由于假定图 $G$ 是连通的，因此有 $|E| \ge |V| - 1$ ，所以不相交集合操作的时间代价为 $O(E \alpha(V))$ 。而且，由于 $\alpha( |V| ) = O(\log V) =O(\log E)$ ，*Kruskal* 算法的总运行时间为 $O(E \log E)$ 。如果再注意到 $|E| < |V|^2$ ，则有 $\log |E| = O(\log V)$ ，因此，我们可以将 *Kruskal* 算法的时间重新表述为 $O(E \log V)$ 。  

## 2.2 *Prim* 算法
与 *Kruskal* 算法类似，*Prim* 算法也是（算导23.1节讨论的）通用最小生成树算法的一个特例。*Prim* 算法的工作原理与 *Dijkstra* 最短路径算法（算导24.3节）相似。==*Prim* 算法具有的一个性质是，集合 $A$ 中的边总是构成一棵树==。如图23-5所示，这棵树从一个任意的根结点 $r$ 开始，一直长大到覆盖 $V$ 中的所有结点时为止。
![在这里插入图片描述](https://img-blog.csdnimg.cn/0e4214b0cd044c8c9404027b12f01cb5.png)

算法每一步在「连接集合 $A$ 和 $A$ 之外的结点的所有边」中，选择一条轻量级边加入到 $A$ 中。根据**推论23.2**，这条规则加入的边都是对 $A$ 安全的边。因此，当算法终止时，$A$ 中的边形成一棵最小生成树。本策略也属于贪心策略，因为每一步加入的边都必须是使树的总权重增加量最小的边。

为了有效地实现 *Prim* 算法，需要一种快速的方法来选择一条新的边，以便加入到由集合 $A$ 中的边构成的树中。在下面的伪码中，连通图 $G$ 和最小生成树的根结点 $r$ 、将作为算法的输入。==在算法的执行过程中，所有不在树 $A$ 中的结点，都存放在一个基于 $key$ 属性的最小优先队列 $Q$ 中。对于每个结点 $v$ ，属性 $v.key$ 保存的是「连接 $v$ 和树中结点的所有边」中最小边的权重==。我们约定，如果不存在这样的边，则 $v.key = \infin$ 。属性 $v.\pi$ 给出的是结点 $v$ 在树中的父结点。*Prim* 算法将 `GENERIC-MST` 中的集合 $A$ 维持在$A = \{ (v, v.\pi) \mid v \in V - \{ r \} - Q\}$ 的状态下。

当 *Prim* 算法终止时，最小优先队列 $Q$ 将为空，而 $G$ 的最小生成树 $A$ 则是：
$$A = \{ ( v, v.\pi) \mid v \in V - \{ r \} \}$$

```cpp
MST-PRIM(G, w, r)
	for each u in G.V
		u.key = INF
		u.π = NULL
	r.key = 0
	Q = G.V
	while Q != ∅
		u = EXTRACT-MIN(Q)
		for each v in G.Adj[u]
			if v in Q and w(u, v) < v.key // visited[v]==false
				v.π = u
				v.key = w(u, v)
```
图23-5描述的是 *Prim* 算法的工作过程。算法第 $1 \sim 5$ 行将每个结点的 $key$ 值设置为 $\infin$（除根结点 $r$ 以外，根结点 $r$ 的 $key$ 值设置为 $0$ ，以便使该结点成为第一个被处理的结点），将每个结点的父结点设置为 `NULL` ，并对最小优先队列 $Q$ 进行初始化，使其包含图中所有的结点。该算法维持的循环不变式由三个部分组成，具体阐述如下。

在算法第 $6 \sim 11$ 行的 while 循环的每次迭代之前，我们有：
1. $A = \{ (v, v.\pi) \mid v \in V - \{ r \} - Q\}$ 
2. 已经加入到最小生成树的结点为集合 $V - Q$ 。
3. 对于所有的结点 $v \in Q$ ，如果 $v.\pi \ne \textrm{NULL}$ ，则 $v.key < \infin$ 并且 $v.key$ 是连接结点 $v$ 和最小生成树中某个结点的轻量级边 $(v, v.\pi)$ 的权重。

==算法第 $7$ 行将找出结点 $u \in Q$ ，该结点是某条「横跨切割 $(V - Q, Q)$ 的轻量级边」的一个端点==（第 $1$ 次循环时例外，此时因为算法的第 $4$ 行，所以有 $u = r$ ）。接着将结点 $u$ 从队列 $Q$ 中删除，并将其加入到集合 $V- Q$ 中，也就是将边 $(u, u.\pi)$ 加入到集合 $A$ 中。==算法第 $8 \sim 11$ 行的 for 循环，将每个与 $u$ 邻接、但却不在树中的结点 $v$ 的 $key$ 和 $\pi$ 属性进行更新，从而维持循环不变式的第 $3$ 部分成立==。

*Prim* 算法的运行时间取决于最小优先队列 $Q$ 的实现方式。如果将 $Q$ 实现为一个二叉最小优先队列（参考算导第 $6$ 章）：
- 我们可以用 `BUILD-MIN-HEAP` 来执行算法第 $1 \sim 5$ 行，时间成本为 $O(V)$ 。
- while 循环中的语句一共要执行 $|V|$ 次，由于每个 `EXTRACT-MIN` 操作需要的时间成本为 $O(\log V)$ ，`EXTRACT-MIN` 操作的总时间为 $O(V\log V)$ 。
- 由于所有邻接链表的长度之和为 $2|E|$ ，算法第 $8 \sim 11$ 行的 for 循环的总执行次数为 $O(E)$ 。在 for 循环里面，我们可以在常数时间内、完成对一个结点是否属于队列 $Q$ 的判断，方法就是对每个结点维护一个标志位、来指明该结点是否属于 $Q$ ，并在将结点从 $Q$ 中删除时、对该标志位进行更新。算法第 $11$ 行的赋值操作，涉及一个隐含的 `DECREASE-KEY` 操作，该操作在二叉最小堆上执行的时间成本为 $O(\log V)$ 。
- 因此，*Prim* 算法的总时间代价为 $O(V \log V+ E\log V) = O(E \log V)$ 。从渐近意义上说，它与 *Kruskal* 算法的运行时间相同。

如果使用斐波那契堆来实现最小优先队列 $Q$ ，*Prim* 算法的渐近运行时间可得到进一步改善。（算导第19章告诉我们）如果斐波那契堆中有 $|V|$ 个元素，则 `EXTRACT-MIN` 操作的时间摊还代价为 $O(\log V)$ ，而 `DECREASE-KEY` 操作（实现算法第 $11$ 行的操作）的摊还时间代价为 $O(1)$ 。因此，==如果使用斐波那契堆来实现最小优先队列 $Q$ ，则 *Prim* 算法的运行时间将改进到 $O(E + V\log V)$== 。



---
## 定义
在阅读下列内容之前，请务必阅读 [图论相关概念](./concept.md) 与 [树基础](./tree-basic.md) 部分，并了解以下定义：
1.  生成子图
2.  生成树

我们定义无向连通图的 **最小生成树**（Minimum Spanning Tree，MST）为边权和最小的生成树。注意：==只有连通图才有生成树，而对于非连通图，只存在生成森林==。

## Kruskal 算法

Kruskal 算法是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。
### 前置知识
[并查集](../ds/dsu.md)、[贪心](../basic/greedy.md)、[图的存储](./save.md)。
### 实现
图示：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202308191634636.png)
伪代码：
$$
\begin{array}{ll}
1 &  \textbf{Input. } \text{The edges of the graph } e , \text{ where each element in } e \text{ is } (u, v, w) \\
  &  \text{ denoting that there is an edge between } u \text{ and } v \text{ weighted } w . \\
2 &  \textbf{Output. } \text{The edges of the MST of the input graph}.\\
3 &  \textbf{Method. } \\ 
4 &  result \gets \varnothing \\
5 &  \text{sort } e \text{ into nondecreasing order by weight } w \\ 
6 &  \textbf{for} \text{ each } (u, v, w) \text{ in the sorted } e \\ 
7 &  \qquad \textbf{if } u \text{ and } v \text{ are not connected in the union-find set } \\
8 &  \qquad\qquad \text{connect } u \text{ and } v \text{ in the union-find set} \\
9 &  \qquad\qquad  result \gets result\;\bigcup\ \{(u, v, w)\} \\
10 &  \textbf{return }  result
\end{array}
$$
算法虽简单，但需要相应的数据结构来支持……具体来说，维护一个森林，查询两个结点是否在同一棵树中，连接两棵树。

抽象一点地说，维护一堆 **集合**，查询两个元素是否属于同一集合，合并两个集合。

其中，查询两点是否连通和连接两点可以使用并查集维护。

如果使用 $O(m\log m)$ 的排序算法，并且使用 $O(m\alpha(m, n))$ 或 $O(m\log n)$ 的并查集，就可以得到时间复杂度为 $O(m\log m)$ 的 Kruskal 算法。
### 证明
思路很简单，为了造出一棵最小生成树，我们从最小边权的边开始，按边权从小到大依次加入，如果某次加边产生了环，就扔掉这条边，直到加入了 $n-1$ 条边，即形成了一棵树。

证明：使用**归纳法**，证明**任何时候 K 算法选择的边集都被某棵 MST 所包含**。
- 基础：对于算法刚开始时，显然成立（最小生成树存在）。
- 归纳：假设某时刻成立，当前边集为 $F$，令 $T$ 为这棵 MST，考虑下一条加入的边 $e$。
   如果 $e$ 属于 $T$，那么成立。
   否则，$T+e$ 一定存在一个环，考虑这个环上不属于 $F$ 的另一条边 $f$（一定只有一条）。
   - 首先，$f$ 的权值一定不会比 $e$ 小，不然 $f$ 会在 $e$ 之前被选取。
   - 然后，$f$ 的权值一定不会比 $e$ 大，不然 $T+e-f$ 就是一棵比 $T$ 还优的生成树了。
   - 所以，$T+e-f$ 包含了 $F$，并且也是一棵最小生成树，归纳成立。

## Prim 算法
Prim 算法是另一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。
### 实现
具体来说，每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离。

其实跟 Dijkstra 算法一样，每次找到距离最小的一个点，可以暴力找也可以用堆维护。

堆优化的方式类似 Dijkstra 的堆优化，但如果使用二叉堆等不支持 $O(1)$ decrease-key 的堆，复杂度就不优于 Kruskal，常数也比 Kruskal 大。所以，**一般情况下都使用 Kruskal 算法**，在稠密图尤其是完全图上，暴力 Prim 的复杂度比 Kruskal 优，但 **不一定** 实际跑得更快。

暴力：$O(n^2+m)$。
二叉堆：$O((n+m) \log n)$。
Fib 堆：$O(n \log n + m)$。

伪代码：
$$
\begin{array}{ll}
1 &  \textbf{Input. } \text{The nodes of the graph }V\text{ ; the function }g(u, v)\text{ which}\\
  &  \text{means the weight of the edge }(u, v)\text{; the function }adj(v)\text{ which}\\
  &  \text{means the nodes adjacent to }v.\\
2 &  \textbf{Output. } \text{The sum of weights of the MST of the input graph.} \\
3 &  \textbf{Method.} \\
4 &  result \gets 0 \\
5 & \text{choose an arbitrary node in }V\text{ to be the }root \\
6 &  dis(root)\gets 0 \\
7 &  \textbf{for } \text{each node }v\in(V-\{root\}) \\
8 &  \qquad  dis(v)\gets\infty \\
9 &  rest\gets V \\
10 &  \textbf{while }  rest\ne\varnothing \\
11 &  \qquad cur\gets \text{the node with the minimum }dis\text{ in }rest \\
12 &  \qquad  result\gets result+dis(cur) \\
13 &  \qquad  rest\gets rest-\{cur\} \\
14 &  \qquad  \textbf{for}\text{ each node }v\in adj(cur) \\
15 &  \qquad\qquad  dis(v)\gets\min(dis(v), g(cur, v)) \\
16 &  \textbf{return }  result 
\end{array}
$$

注意：上述代码只是求出了最小生成树的权值，如果要输出方案还需要记录每个点的 $dis$ 代表的是哪条边。
### 证明
从任意一个结点开始，将结点分成两类：已加入的，未加入的。

每次从未加入的结点中，找一个与已加入的结点之间边权最小值最小的结点。然后将这个结点加入，并连上那条边权最小的边。重复 $n-1$ 次即可。

证明：还是说明在每一步，都存在一棵最小生成树包含已选边集。

基础：只有一个结点的时候，显然成立。
归纳：如果某一步成立，当前边集为 $F$，属于 $T$ 这棵 MST，接下来要加入边 $e$。

如果 $e$ 属于 $T$，那么成立。
否则考虑 $T+e$ 中环上另一条可以加入当前边集的边 $f$。
- 首先，$f$ 的权值一定不小于 $e$ 的权值，否则就会选择 $f$ 而不是 $e$ 了。
- 然后，$f$ 的权值一定不大于 $e$ 的权值，否则 $T+e-f$ 就是一棵更小的生成树了。
- 因此，$e$ 和 $f$ 的权值相等，$T+e-f$ 也是一棵最小生成树，且包含了 $F$。
---
## Boruvka 算法
https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm
接下来介绍另一种求解最小生成树的算法——Boruvka 算法。该算法的思想是前两种算法的结合。它可以用于求解 **边权互不相同** 的无向图的**最小生成森林**（在**无向连通图**中，就是**最小生成树**。）

为了描述该算法，我们需要引入一些定义：
1.  定义 $E'$ 为我们当前找到的**最小生成森林的边**。在算法执行过程中，我们逐步向 $E'$ 加边。
2. 定义 **连通块** 表示一个点集 $V'\subseteq V$，且这个点集中的任意两个点 $u$，$v$ 在 **$E'$ 中的边构成的子图上**是连通的（互相可达）。
3.  定义一个连通块的 **最小边** 为**它连向其它连通块的边中**权值最小的那一条。

初始时，$E'=\varnothing$，每个点各自是一个连通块：
1.  计算每个点分别属于哪个连通块。将每个连通块都设为「没有最小边」。
2.  遍历每条边 $(u, v)$，如果 $u$ 和 $v$ 不在同一个连通块，就用这条边的边权**分别更新 $u$ 和 $v$ 所在连通块的最小边**。
3.  ==如果所有连通块都没有最小边，退出程序，此时的 $E'$ 就是原图最小生成森林的边集==。否则，将**每个有最小边的连通块的最小边加入 $E'$，返回第一步**。

下面通过一张动态图来举一个例子（图源自 [维基百科](https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm)）：
![](https://oi-wiki.org/graph/images/mst-1.apng)
当原图连通时，每次迭代连通块数量至少减半，算法只会迭代不超过 $O(\log V)$ 次，而原图不连通时相当于多个子问题，因此算法复杂度是 $O(E\log V)$ 的。给出算法的伪代码：（修改自 [维基百科](https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm)）
$$
\begin{array}{ll}
1 &  \textbf{Input. } \text{A graph }G\text{ whose edges have distinct weights. } \\
2 &  \textbf{Output. } \text{The minimum spanning forest of }G .  \\
3 &  \textbf{Method. }  \\
4 & \text{Initialize a forest }F\text{ to be a set of one-vertex trees} \\
5 &  \textbf{while } \text{True} \\
6 &  \qquad \text{Find the components of }F\text{ and label each vertex of }G\text{ by its component } \\
7 &  \qquad \text{Initialize the cheapest edge for each component to "None"} \\
8 &  \qquad  \textbf{for } \text{each edge }(u, v)\text{ of }G  \\
9 &  \qquad\qquad  \textbf{if }  u\text{ and }v\text{ have different component labels} \\
10 &  \qquad\qquad\qquad  \textbf{if }  (u, v)\text{ is cheaper than the cheapest edge for the component of }u  \\
11 &  \qquad\qquad\qquad\qquad\text{ Set }(u, v)\text{ as the cheapest edge for the component of }u \\
12 &  \qquad\qquad\qquad  \textbf{if }  (u, v)\text{ is cheaper than the cheapest edge for the component of }v  \\
13 &  \qquad\qquad\qquad\qquad\text{ Set }(u, v)\text{ as the cheapest edge for the component of }v  \\
14 &  \qquad  \textbf{if }\text{ all components'cheapest edges are "None"} \\
15 &  \qquad\qquad  \textbf{return }  F \\
16 &  \qquad  \textbf{for }\text{ each component whose cheapest edge is not "None"} \\
17 &  \qquad\qquad\text{ Add its cheapest edge to }F \\
\end{array}
$$
## 习题
-   [「HAOI2006」聪明的猴子](https://www.luogu.com.cn/problem/P2504)
-   [「SCOI2005」繁忙的都市](https://loj.ac/problem/2149)
---
## 最小生成树的唯一性
考虑最小生成树的唯一性。如果一条边 **不在最小生成树的边集中**，并且可以替换与其 **权值相同、并且在最小生成树边集** 的另一条边。那么，这个最小生成树就是==不唯一的==。

对于 Kruskal 算法，只要计算**为当前权值的边**可以放几条，实际放了几条，如果这两个值不一样，那么就说明这几条边与之前的边产生了一个环（这个环中至少有两条当前权值的边，否则根据并查集，这条边是不能放的），即最小生成树不唯一。

寻找权值与当前边相同的边，我们只需要记录头尾指针，**用单调队列即可在 $O(\alpha(m))$（m 为边数）的时间复杂度**，优秀解决这个问题（基本与原算法时间相同）。

例题：[POJ 1679](http://poj.org/problem?id=1679)"
```cpp
#include <algorithm>
#include <cstdio>

struct Edge {
  int x, y, z;
};

int f[100001];
Edge a[100001];

int cmp(const Edge& a, const Edge& b) { return a.z < b.z; }

int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }

int main() {
  int t;
  scanf("%d", &t);
  while (t--) {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) f[i] = i;
    for (int i = 1; i <= m; i++) scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].z);
    std::sort(a + 1, a + m + 1, cmp);  // 先排序
    int num = 0, ans = 0, tail = 0, sum1 = 0, sum2 = 0;
    bool flag = 1;
    for (int i = 1; i <= m + 1; i++) {  // 再并查集加边
      if (i > tail) {
        if (sum1 != sum2) {
          flag = 0;
          break;
        }
        sum1 = 0;
        for (int j = i; j <= m + 1; j++) {
          if (a[j].z != a[i].z) {
            tail = j - 1;
            break;
          }
          if (find(a[j].x) != find(a[j].y)) ++sum1;
        }
        sum2 = 0;
      }
      if (i > m) break;
      int x = find(a[i].x);
      int y = find(a[i].y);
      if (x != y && num != n - 1) {
        sum2++;
        num++;
        f[x] = f[y];
        ans += a[i].z;
      }
    }
    if (flag)
      printf("%d\n", ans);
    else
      printf("Not Unique!\n");
  }
  return 0;
}
```
## 次小生成树
### 非严格次小生成树
#### 定义
在无向图中，边权和最小的、满足边权和 **大于等于** 最小生成树边权和的生成树
#### 求解方法
-   求出无向图的最小生成树 $T$，设其权值和为 $M$
-   遍历每条**未被选中的边** $e = (u,v,w)$，找到 $T$ 中 $u$ 到 $v$ 路径上边权最大的一条边 $e' = (s,t,w')$，则在 $T$ 中以 $e$ 替换 $e'$，可得一棵权值和为 $M' = M + w - w'$ 的生成树 $T'$.
-   **对所有替换得到的答案 $M'$ 取最小值**即可

如何求 $u,v$ 路径上的边权最大值呢？

我们可以使用**倍增**来维护，预处理出每个节点的 $2^i$ 级祖先及到达其 $2^i$ 级祖先路径上最大的边权，这样**在倍增求 LCA 的过程中可以直接求得**。
### 严格次小生成树
#### 定义
在无向图中，边权和最小的满足边权和 **严格大于** 最小生成树边权和的生成树。
#### 求解方法
考虑刚才的非严格次小生成树求解过程，为什么求得的解是非严格的？

因为最小生成树，保证生成树中 $u$ 到 $v$ 路径上的边权最大值一定 **不大于** 其他从 $u$ 到 $v$ 路径的边权最大值？？？。换言之，当我们用于替换的边的权值与原生成树中被替换边的权值相等时，得到的次小生成树是非严格的。

解决的办法很自然：我们维护到 **$2^i$ 级祖先路径上的最大边权**的同时维护 **严格次大边权**，当**用于替换的边的权值与原生成树中路径最大边权相等**时，我们用**严格次大值**来替换即可。

这个过程可以用倍增求解，复杂度 $O(m \log m)$。
#### 代码
```cpp
#include <algorithm>
#include <iostream>

const int INF = 0x3fffffff;
const long long INF64 = 0x3fffffffffffffffLL;

struct Edge {
  int u, v, val;
  bool operator<(const Edge &other) const { 
      return val < other.val; 
  }
};
Edge e[300010];
bool used[300010];

int n, m;
long long sum;

class Tr {
 private:
  struct Edge {
    int to, nxt, val;
  } e[600010];

  int cnt, head[100010];
  int pnt[100010][22];
  int dpth[100010];
  // 到祖先的路径上边权最大的边
  int maxx[100010][22];
  // 到祖先的路径上边权次大的边，若不存在则为 -INF
  int minn[100010][22];

 public:
  void addedge(int u, int v, int val) {
    e[++cnt] = (Edge){v, head[u], val};
    head[u] = cnt;
  }

  void insedge(int u, int v, int val) {
    addedge(u, v, val);
    addedge(v, u, val);
  }

  void dfs(int now, int fa) {
    dpth[now] = dpth[fa] + 1; // 在DFS过程中记录深度
    pnt[now][0] = fa; // 记录第几级祖先
    minn[now][0] = -INF; // 记录边权次大的边
    for (int i = 1; (1 << i) <= dpth[now]; i++) {
      pnt[now][i] = pnt[pnt[now][i - 1]][i - 1];
      int kk[4] = {maxx[now][i - 1], maxx[pnt[now][i - 1]][i - 1],
                   minn[now][i - 1], minn[pnt[now][i - 1]][i - 1]};
      // 从四个值中取得最大值
      std::sort(kk, kk + 4);
      maxx[now][i] = kk[3];
      // 取得严格次大值
      int ptr = 2;
      while (ptr >= 0 && kk[ptr] == kk[3]) ptr--;
      minn[now][i] = (ptr == -1 ? -INF : kk[ptr]);
    }
    // 递归子结点
    for (int i = head[now]; i; i = e[i].nxt) {
      if (e[i].to != fa) {
        maxx[e[i].to][0] = e[i].val;
        dfs(e[i].to, now);
      }
    }
  }

  // lca
  int lca(int a, int b) {
      if (depth[a] < depth[b]) swap(a, b);
      for (int i = 21; i >= 0; --i)
          if (depth[fth[a][i]] >= depth[b]) a = fth[a][i];
    if (a == b) return a;
    for (int i = 21; i >= 0; --i) {
        if (fth[a][i] != fth[b][i]) { // 找到最大的那个满足两个的第2^i级父结点不等的
            a = fth[a][i];
            b = fth[b][i];
        }
    }
    return pnt[a][0];
  }
  int lca(int a, int b) {
    if (dpth[a] < dpth[b]) std::swap(a, b);

    for (int i = 21; i >= 0; i--)
      if (dpth[pnt[a][i]] >= dpth[b]) a = pnt[a][i];

    if (a == b) return a;

    for (int i = 21; i >= 0; i--) {
      if (pnt[a][i] != pnt[b][i]) {
        a = pnt[a][i];
        b = pnt[b][i];
      }
    }
    return pnt[a][0];
  }
  // lca查询
  int query(int a, int b, int val) {
    int res = -INF;
    for (int i = 21; i >= 0; i--) {
      if (dpth[pnt[a][i]] >= dpth[b]) {
        if (val != maxx[a][i]) // a的第2^i级祖先的最大边权
          res = std::max(res, maxx[a][i]);
        else // ? 当用于替换的边的权值与原生成树中路径最大边权相等时，我们用严格次大值来替换即可
          res = std::max(res, minn[a][i]);
        a = pnt[a][i];
      }
    }
    return res;
  }
} tr;

int fa[100010];

int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

void Kruskal() {
  int tot = 0;
  std::sort(e + 1, e + m + 1);
  for (int i = 1; i <= n; i++) fa[i] = i;

  for (int i = 1; i <= m; i++) {
    int a = find(e[i].u);
    int b = find(e[i].v);
    if (a != b) {
      fa[a] = b;
      tot++;
      tr.insedge(e[i].u, e[i].v, e[i].val); // 找到最小生成树
      sum += e[i].val; // 最小权重和
      used[i] = 1;
    }
    if (tot == n - 1) break;
  }
}

int main() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0);
  std::cout.tie(0);

  std::cin >> n >> m;
  for (int i = 1; i <= m; i++) {
    int u, v, val;
    std::cin >> u >> v >> val;
    e[i] = (Edge){u, v, val};
  }

  Kruskal();
  long long ans = INF64;
  tr.dfs(1, 0);

  for (int i = 1; i <= m; i++) {
    if (!used[i]) { // 遍历每条边，如果没被MST使用
      int _lca = tr.lca(e[i].u, e[i].v); // lca
      // 找到路径上不等于 e[i].val 的最大边权
      long long tmpa = tr.query(e[i].u, _lca, e[i].val);
      long long tmpb = tr.query(e[i].v, _lca, e[i].val);
      // 找到u->v路径上边权最大的边
      // 这样的边可能不存在，只在这样的边存在时更新答案
      if (std::max(tmpa, tmpb) > -INF)
        ans = std::min(ans, sum - std::max(tmpa, tmpb) + e[i].val);
    }
  }
  // 次小生成树不存在时输出 -1
  std::cout << (ans == INF64 ? -1 : ans) << '\n';
  return 0;
}
```
---
## 瓶颈生成树
### 定义
无向图 $G$ 的（最小）瓶颈生成树是这样的一个生成树，它的最大的边权值在 $G$ 的所有生成树中最小。
还有最大瓶颈生成树。
### 性质
**最小生成树是瓶颈生成树的充分不必要条件。** 即==最小生成树一定是瓶颈生成树，而瓶颈生成树不一定是最小生成树==。

关于最小生成树一定是瓶颈生成树这一命题，可以运用反证法证明：我们设**最小生成树中的最大边权为 $w$** ，如果最小生成树不是瓶颈生成树的话，则瓶颈生成树的所有边权都小于 $w$，我们只需删去原最小生成树中的最长边，用瓶颈生成树中的一条边来连接删去边后形成的两棵树，得到的新生成树一定比原最小生成树的权值和还要小，这样就产生了矛盾。
### 例题
"POJ 2395 Out of Hay"
给出 n 个农场和 m 条边，农场按 1 到 n 编号，现在有一人要从编号为 1 的农场出发到**其他的农场**去，求在这途中他**最多需要携带的水的重量**，注意他每到达一个农场，可以对水进行补给，且要**使总共的路径长度最小**。

题目要求的就是瓶颈树的最大边，可以通过求最小生成树来解决。
## 最小瓶颈路
### 定义
无向图 $G$ 中 **$x$ 到 $y$ 的最小瓶颈路**是这样的一类简单路径，满足这条路径上的最大的边权在所有 x 到 y 的简单路径中是**最小的**。
### 性质
根据最小生成树定义，==$x$ 到 $y$ 的最小瓶颈路上的最大边权等于最小生成树上 $x$ 到 $y$ 路径上的最大边权==。虽然最小生成树不唯一，但是每种最小生成树 $x$ 到 $y$ 路径的最大边权相同且为最小值。也就是说，**每种最小生成树上的 $x$ 到 $y$ 的路径均为最小瓶颈路**。

但是，并不是所有**最小瓶颈路**都存在一棵**最小生成树**，满足其为树上 $x$ 到 $y$ 的简单路径（满足该最小瓶颈路在该最小生成树上）。

例如下图：
![](https://oi-wiki.org/graph/images/mst5.png)
1 到 4 的最小瓶颈路显然有以下两条：1-2-3-4。1-3-4。

但是，1-2 不会出现在任意一种最小生成树上。
### 应用
由于最小瓶颈路不唯一，一般情况下会询问**最小瓶颈路上的最大边权**。也就是说，我们需要求**最小生成树链上的 $max$** 。

倍增、树剖都可以解决，这里不再展开。
[[../刷题日志与精进之路/LeetCode 778. Swim in Rising Water【最小瓶颈路;二分+BFS或DFS;计数排序+并查集;最小生成树】2096|LeetCode 778. Swim in Rising Water【最小瓶颈路;二分+BFS或DFS;计数排序+并查集;最小生成树】2096]]]
[[../刷题日志与精进之路/LeetCode 1631. Path With Minimum Effort【最小瓶颈路;二分+BFS或DFS;计数排序+并查集;最小生成树】1947|LeetCode 1631. Path With Minimum Effort【最小瓶颈路;二分+BFS或DFS;计数排序+并查集;最小生成树】1947]]
[[../刷题日志与精进之路/LeetCode 2812. Find the Safest Path in a Grid【最大瓶颈树;多源BFS+二分;最大生成树Kruskal或Prim;并查集】困难|LeetCode 2812. Find the Safest Path in a Grid【最大瓶颈树;多源BFS+二分;最大生成树Kruskal或Prim;并查集】困难]]

---
## Kruskal 重构树
### 定义
在跑 Kruskal 的过程中我们会从小到大加入若干条边。现在我们**仍然按照这个顺序**。

首先新建 $n$ 个集合，**每个集合恰有一个节点**，点权为 $0$。

每一次加边会合并两个集合，我们可以==新建一个点，点权为加入边的边权，同时将两个集合的根节点分别设为新建点的左儿子和右儿子==。然后我们将两个集合和新建点合并成一个集合。将新建点设为根。

不难发现，在进行 $n-1$ 轮之后我们得到了一棵恰有 $n$ 个叶子的二叉树，同时每个非叶子节点恰好有两个儿子。这棵树就叫 Kruskal 重构树。

举个例子：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202308192215566.png)
这张图的 Kruskal 重构树如下：
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202308192216686.png)
### 性质
不难发现，原图中**两个点之间的所有简单路径上最大边权的最小值** = 最小生成树上**两个点之间的简单路径上的最大值** = Kruskal 重构树上**两点之间的 LCA 的权值**。

也就是说，到点 $x$ 的简单路径上**最大边权的最小值** $\leq val$ 的所有点 $y$ 均在 Kruskal 重构树上的某一棵子树内，且恰好为该子树的所有叶子节点。？？？

我们在 Kruskal 重构树上，找到 $x$ 到根的路径上权值 $\leq val$ 的最浅的节点。显然这就是所有满足条件的节点所在的子树的根节点。？？

如果需要求原图中**两个点之间的所有简单路径上最小边权的最大值**，则在跑 Kruskal 的过程中**按边权大到小的顺序加边**。最大生成树！！！

[「LOJ 137」最小瓶颈路 加强版](https://loj.ac/problem/137)"
```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_VAL_RANGE = 280010;

int n, m, log2Values[MAX_VAL_RANGE + 1];

namespace TR {
struct Edge {
  int to, nxt, val;
} e[400010];

int cnt, head[140010];

void addedge(int u, int v, int val = 0) {
  e[++cnt] = (Edge){v, head[u], val};
  head[u] = cnt;
}

int val[140010];

namespace LCA {
int sec[280010], cnt;
int pos[140010];
int dpth[140010];

void dfs(int now, int fa) {
  dpth[now] = dpth[fa] + 1;
  sec[++cnt] = now;
  pos[now] = cnt;

  for (int i = head[now]; i; i = e[i].nxt) {
    if (fa != e[i].to) {
      dfs(e[i].to, now);
      sec[++cnt] = now;
    }
  }
}

int dp[280010][20];

void init() {
  dfs(2 * n - 1, 0);
  for (int i = 1; i <= 4 * n; i++) {
    dp[i][0] = sec[i];
  }
  for (int j = 1; j <= 19; j++) {
    for (int i = 1; i + (1 << j) - 1 <= 4 * n; i++) {
      dp[i][j] = dpth[dp[i][j - 1]] < dpth[dp[i + (1 << (j - 1))][j - 1]]
                     ? dp[i][j - 1]
                     : dp[i + (1 << (j - 1))][j - 1];
    }
  }
}

int lca(int x, int y) {
  int l = pos[x], r = pos[y];
  if (l > r) {
    swap(l, r);
  }
  int k = log2Values[r - l + 1];
  return dpth[dp[l][k]] < dpth[dp[r - (1 << k) + 1][k]]
             ? dp[l][k]
             : dp[r - (1 << k) + 1][k];
}
}  // namespace LCA
}  // namespace TR

using TR::addedge;

namespace GR {
struct Edge {
  int u, v, val;

  bool operator<(const Edge &other) const { return val < other.val; }
} e[100010];

int fa[140010];

int find(int x) { return fa[x] == 0 ? x : fa[x] = find(fa[x]); }

void kruskal() {  // 最小生成树
  int tot = 0, cnt = n;
  sort(e + 1, e + m + 1);
  for (int i = 1; i <= m; i++) {
    int fau = find(e[i].u), fav = find(e[i].v);
    if (fau != fav) {
      cnt++;
      fa[fau] = fa[fav] = cnt;
      addedge(fau, cnt);
      addedge(cnt, fau);
      addedge(fav, cnt);
      addedge(cnt, fav);
      TR::val[cnt] = e[i].val;
      tot++;
    }
    if (tot == n - 1) {
      break;
    }
  }
}
}  // namespace GR

int ans;
int A, B, C, P;

int rnd() { return A = (A * B + C) % P; }

void initLog2() {
  for (int i = 2; i <= MAX_VAL_RANGE; i++) {
    log2Values[i] = log2Values[i >> 1] + 1;
  }
}

int main() {
  initLog2();  // 预处理
  cin >> n >> m;
  for (int i = 1; i <= m; i++) {
    int u, v, val;
    cin >> u >> v >> val;
    GR::e[i] = (GR::Edge){u, v, val};
  }
  GR::kruskal();
  TR::LCA::init();
  int Q;
  cin >> Q;
  cin >> A >> B >> C >> P;

  while (Q--) {
    int u = rnd() % n + 1, v = rnd() % n + 1;
    ans += TR::val[TR::LCA::lca(u, v)];
    ans %= 1000000007;
  }
  cout << ans;
  return 0;
}
```
[NOI 2018 归程](https://uoj.ac/problem/393)"
首先预处理出来每一个点到根节点的最短路。
    
我们构造出来根据海拔的最大生成树。显然每次询问可以到达的节点是在最小生成树和询问点的最小边权 $\geq p$ 的节点。
    
根据 Kruskal 重构树的性质，**这些节点满足均在一棵子树内同时为其所有叶子节点**。
    
也就是说，我们只需要求出 Kruskal 重构树上每一棵子树叶子的权值 min 就可以支持子树询问。
    
询问的根节点可以使用 **Kruskal 重构树上倍增**的方式求出。 时间复杂度 $O((n+m+Q) \log n)$。
