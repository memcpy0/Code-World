@[toc]


**动态规划** `Dynamic Programming, DP` 是将多阶段决策问题进行公式化的一种技术，由 *R. Bellman* 于1957年提出，被成功应用于许多领域，也是算法设计方法之一。这里介绍动态规划求解问题的一般方法，并讨论一些用动态规划求解的经典示例。

---
# 8.1 动态规划概述
动态规划并非是"动态编程"或"动态查询设计"。动态规划法通常基于一个递推公式、以及一个或多个初始状态，当前子问题的解将由上一次子问题的解推出。许多看起来复杂的问题采用动态规划求解十分方便，而且只需要多项式时间复杂度，比回溯法、暴力法等效率高，但并非任何问题都适合采用动态规划求解，本节介绍其相关概念。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c57e0b5d485348d0b8a0503c256d877a.png)

---
## 8.1.1 动态规划的原理
动态规划是一种解决多阶段决策问题的优化方法，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系逐个求解。
### 1. 动态规划的相关概念
看一个具体示例，如图8.4所示。在 $A$ 处有一水库，现需要从 $A$ 点铺设一条管道到 $E$ 点，边上的数字表示与其相连的两个地点之间所需修建的管道长度，用 $c$ 数组表示，例如 $c(A, B_1)=2$ 。现要找出一条从 $A$ 到 $E$ 的修建线路，使得所需修建的管道长度最短。

该图是一个**多段图** `multistage graph` 。==一个图 $G = (V, E)$ 是多段图，是指顶点集 $V$ 可划分成 $k$ 个互不相交的子集 $V_i\ (1 \le i \le k)$ ，使得 $E$ 中的任何一条边 $(u, v)$ 必有 $u, v$ 属于两个不同的子集 $V_i, V_j$== 。在该图中，$A$ 是源点、$E$ 是终点。这类问题适合采用动态规划来求解，下面结合该问题，介绍动态规划中的几个基本概念。
#### (1) 阶段和阶段变量
**一个多段图分成若干个阶段，每个阶段用阶段变量 $k$ 标识**。在图8.4中，在 $A \sim E$ 的过程中，依据按位置所做的决策的次数、及所做决策的先后次序，将问题分成 $5$ 个阶段，阶段变量用于表示各阶段，这里阶段变量 $k$ 为 $1 \sim 5$ ，图中第 $5$ 阶段是虚拟的一个边界阶段。
![在这里插入图片描述](https://img-blog.csdnimg.cn/a7679d83f8ff46cea7937d6554797266.png)
#### (2) 状态和状态变量
描述决策过程当前特征的量称为**状态**，它可以是数量，也可以是字符。每一状态可以取不同值，状态变量记为 $s_k$ ，各阶段所有状态组成的集合称为**状态集**，用 $S_k$ 表示，有 $s_k \in S_k$ 。==在决策过程中，每一阶段只选取一个状态，$s_k$ 表示第 $k$ 阶段所取的状态==。各阶段的状态为上一阶段的结束点，或该阶段的起点组成的集合。

在图8.4中，第一阶段的状态为 $A$ ，第二阶段的状态有 $B_1, B_2, B_3$ ，第三阶段的状态有 $C_1, C_2, C_3$ ，第四阶段的状态有 $D_1, D_2$ ，第五阶段的状态为 $E$ ，所以有 $S_1 = \{A\}, S_2 = \{B_1, B_2, B_3\}, S_3 = \{C_1, C_2, C_3\}, S_4 = \{D_1, D_2\}, S_5 = \{E\}$ 。简单地说，若图中的每个顶点唯一，则各个状态就是图中的每个顶点。
#### (3) 决策和策略
**决策**就是决策者在过程处于某一阶段的某个状态时，面对下一阶段的状态做出的选择或决定。在图8.4中，若 $s_2 = B_2$ ，且决策者所做的决策为 $B_2C_1$ ，则下一阶段的状态为 $C_1$ ，也可以做 $B_2C_2, B_2 C_3$ 的决策。==用 $D_k(s_k)$ 表示 $k$ 阶段 $s_k$ 状态可以到达的状态集合==，如 $D_2(B_2) = \{ C_1, C_2, C_3\}$ 。

**策略**就是决策者从第一阶段到最后阶段的、全过程的决策构成的决策序列。第 $k$ 阶段到最后阶段的决策序列称为**子策略**。在图8.4中，粗线表示的 $A\to B_2 \to C_3 \to D_1 \to E$ 就是从起点状态 $A$ 开始的一个策略，而 $C_2 \to D_1 \to E$ 是从第三阶段的 $C_2$ 状态开始的一个子策略。
#### (4) 状态转移方程
某一状态以及该状态下的决策与下一状态之间的指标函数之间的关系（？不说人话是吧？），称为**状态转移方程**。其中，指标函数是衡量「对决策过程进行控制的效果」的数量指标，可以是收益、成本、距离等。在求最优解时，指标函数一般对应的是最优指标函数。

例如，在图8.4中，设最优指标函数 $f(s)$ 表示从状态 $s$ 到终点 $E$ 的最短路径长度，用 $k$ 表示阶段，则对应的状态转移方程如下：
$$\begin{aligned}
&f_5(E) = 0 \\
&f_k(s_k) = \min_{x \in D_k(s_k) } \{ c(s_k, x) + f_{k + 1}(s_{k+1} =x) \}
\end{aligned}$$ 或者简写为：
$$\begin{aligned}
&f(E) = 0 \\
&f(s) = \min_{存在 <s,t>的有向边} \{ c(s, t) + f(t) \} \\
\end{aligned}
$$

注意：在有些情况下需要用 `max` 替代 `min` ，表示决策是求最大值、而非最小值，或者采用其他求值函数。所以，==动态规划算法通过基于一个递推公式、及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出，这里是由子问题 $f(t)$ 的解推出 $f(s)$ 的解==。

### 2. 动态规划问题的解法
对于有 $k$ 个阶段的动态规划问题，从第 $k$ 阶段到第 $1$ 阶段的求解过程称为逆序解法，从第 $1$ 阶段到第 $k$ 阶段的求解过程称为顺序解法。

#### (1) 动态规划问题的逆序解法
前面给出图8.4的状态转移方程 $f(s)$ 的递推顺序是从后向前，即 $E \to A$ ，对应逆序解法。用 $next$ 表示路径上一个顶点的后继顶点，其求解 $A$ 到 $E$ 最短路径的过程如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/be3783d6a1fd4313b7c830bbac54a2f0.png)

由 $f(A) = 12$ 求出的最短路径长度为 $12$ ，由 $next(A) = B_3,\ next(B_3) = C_2, next(C_2) = D_2, next(D_2)= E$ ，推出最短路径为 $A \to B_3 \to C_2 \to D_2 \to E$ 。设计一维数组 $dp$ ，$dp[s]$ 存放 $f(s)$ 的结果，采用逆序算法求 $A$ 到 $E$ 的最短路径和最短路径长度的完整程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 21;
const int INF = 0x3f3f3f3f;

// 问题表示
int n;											// 顶点个数
int Start, End;									// 起点和终点编号
int c[MAXN][MAXN];								// 存放边长度
int Next[MAXN];									// 存放最短路径上当前顶点的后继顶点
map<int, char*> vname;							// 存放编号对应的顶点名称
int dp[MAXN];									// dp[i]存放从当前状态出发到达终点的最短路径值
int Count = 1;									// 计算步骤

void init() {									// 初始化图
	n = 10;
	Start = 0;
	End = 9;
	memset(c, 0x3f, sizeof(c));
	for (int i = 0; i < n; ++i) 				// 初始化dp都为-1
		dp[i] = -1;
	for (int j = 0; j < n; ++j)
		c[j][j] = 0;
	c[0][1] = 2, c[0][2] = 4, c[0][3] = 3;		// 图8.4的邻接矩阵
	c[1][4] = 7, c[1][5] = 4;	
	c[2][4] = 3, c[2][5] = 2, c[2][6] = 4;
	c[3][4] = 6, c[3][5] = 2, c[3][6] = 5;
	c[4][7] = 3, c[4][8] = 4;
	c[5][7] = 6, c[5][8] = 3;
	c[6][7] = 3, c[6][8] = 3;
	c[7][9] = 3;
	c[8][9] = 4;
	vname[0] = "A";								// 图中顶点A对应的编号为0
	vname[1] = "B1", vname[2] = "B2", vname[3] = "B3";
	vname[4] = "C1", vname[5] = "C2", vname[6] = "C3";
	vname[7] = "D1", vname[8] = "D2";
	vname[9] = "E";
}
int f(int s) {									// 动态规划问题的逆序解法
	if (dp[s] != -1) return dp[s];				// 若dp[s]已求出,直接返回
	if (s == End) {								// 找到终点
		dp[s] = 0;
		printf("(%d) f(%s)=0\n", Count++, vname[s]);
		return dp[s];
	} else {
		int cost, mincost = INF, minj;
		for (int j = 0; j < n; ++j) {			// 查找顶点s的后继顶点
			if (c[s][j] != 0 && c[s][j] != INF) {
				cost = c[s][j] + f(j);			// 先求出后继顶点j的f值
				if (cost < mincost) {			// 比较求最短路径
					mincost = cost;
					minj = j;
				}
			}
		}
		dp[s] = mincost;
		Next[s] = minj;							// 当前顶点s的后继顶点为minj
		printf("(%d) f(%s)=c(%s,%s)+f(%s)=%d, ", Count++,
			vname[s], vname[s], vname[minj], vname[minj], dp[s]);
		printf("next(%s)=%s\n", vname[s], vname[minj]);
		return dp[s];
	}
}

int main() {
	init();
	printf("%s->%s求解过程\n", vname[End], vname[Start]);
	f(Start);
	return 0;	
}
```
上述程序运行结果如下所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/8c1bce6dafb340efae1c820bbe5b29bd.png)

#### (2) 动态规划问题的顺序解法
对于图8.4，顺序解法是**从源点出发，求出到达当前状态的最短路径**，再考虑下一个阶段，直到终点 $E$ 。对应的状态转移方程如下：
$$\begin{aligned}
&f(A) = 0 \\
&f(s) = \min_{存在<t,s>的有向边} \{ f(t) + c(t, s) \}
\end{aligned}
$$  用 $pre$ 表示路径上一个顶点的前驱顶点，其求解 $A$ 到 $E$ 最短路径的过程如下。
![在这里插入图片描述](https://img-blog.csdnimg.cn/75bd931fc30740fcb3d2d5eeb76d8719.png)

由 $f(E) = 12$ 求出的最短路径长度为 $12$ ，由 $pre(E) = D_2,\ pre(D_2) = C_2,\ pre(C_2) = B_3,\ pre(B_3) =A$ 推出最短路径为 $A \to B_3 \to C_2 \to D_2 \to E$ 。设计一维数组 $dp$ ，$dp[s]$ 存放 $f(s)$ 的结果，采用顺序解法求 $A \to E$ 的最短路径和最短路径长度的完整程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 21;
const int INF = 0x3f3f3f3f;

// 问题表示
int n;											// 顶点个数
int Start, End;									// 起点和终点编号
int c[MAXN][MAXN];								// 存放边长度
int Pre[MAXN];									// 存放最短路径上当前顶点的前驱顶点
map<int, char*> vname;							// 存放编号对应的顶点名称
int dp[MAXN];									// dp[i]存放从源点出发到达当前状态的最短路径值
int Count = 1;									// 计算步骤

void init() {									// 初始化图
	n = 10;
	Start = 0;
	End = 9;
	memset(c, 0x3f, sizeof(c));
	for (int i = 0; i < n; ++i) 				// 初始化dp都为-1
		dp[i] = -1;
	for (int j = 0; j < n; ++j)
		c[j][j] = 0;
	c[0][1] = 2, c[0][2] = 4, c[0][3] = 3;		// 图8.4的邻接矩阵
	c[1][4] = 7, c[1][5] = 4;	
	c[2][4] = 3, c[2][5] = 2, c[2][6] = 4;
	c[3][4] = 6, c[3][5] = 2, c[3][6] = 5;
	c[4][7] = 3, c[4][8] = 4;
	c[5][7] = 6, c[5][8] = 3;
	c[6][7] = 3, c[6][8] = 3;
	c[7][9] = 3;
	c[8][9] = 4;
	vname[0] = "A";								// 图中顶点A对应的编号为0
	vname[1] = "B1", vname[2] = "B2", vname[3] = "B3";
	vname[4] = "C1", vname[5] = "C2", vname[6] = "C3";
	vname[7] = "D1", vname[8] = "D2";
	vname[9] = "E";
}
int f(int s) {									// 动态规划问题的顺序解法
	if (dp[s] != -1) return dp[s];				// 若dp[s]已求出,直接返回
	if (s == Start) {							// 找到起点
		dp[s] = 0;
		printf("(%d) f(%s)=0\n", Count++, vname[s]);
		return dp[s];
	} else {
		int cost, mincost = INF, mini;
		for (int i = 0; i < n; ++i) {			// 查找顶点s的前驱顶点
			if (c[i][s] != 0 && c[i][s] != INF) {
				cost = f(i) + c[i][s];			// 先求出前驱顶点i的f值
				if (cost < mincost) {			// 比较求最短路径
					mincost = cost;
					mini = i;
				}
			}
		}
		dp[s] = mincost;
		Pre[s] = mini;							// 当前顶点s的前驱顶点为mini
		printf("(%d) f(%s)=f(%s)+c(%s,%s)=%d, ", Count++,
			vname[s], vname[mini], vname[mini], vname[s], dp[s]);
		printf("pre(%s)=%s\n", vname[s], vname[mini]);
		return dp[s];
	}
}

int main() {
	init();
	printf("%s->%s求解过程\n", vname[Start], vname[End]);
	f(End);
	return 0;	
}
```
上述程序的执行结果如下所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/6ad6f7b60d4b478198c53cff34fa4edc.png)

## 8.1.3 动态规划求解的基本步骤
采用动态规划求解的问题，一般要具有以下三个性质：
（1）**最优性原理**（最优子结构）：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优性原理；
（2）**无后效性**：即某阶段的状态一旦确定，就不受这个状态以后决策的影响。也就是说，「某状态以后的过程」不会影响以前的状态，只与当前状态有关。
（3）**重叠子问题**：即子问题之间是不独立的，一个子问题在下一阶段决策中、可能被多次使用到。例如，求斐波那契数列 $Fib(5)$ 时、需要多次求 $Fib(3)$ 。==该性质并不是动态规划适用的必要条件，但是如果没有这个性质，动态规划和其他算法相比就不具备优势==。

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线，如图8.5所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/5d6a04f2192f4119bfbc5c76a5f31118.png)
动态规划的设计都有着一定的模式，一般要经历以下几个步骤：
1. **划分阶段**：按照问题的时间或空间特征，把问题分为若干阶段。在划分阶段时注意，划分后的阶段一定是有序的、或者是可排序的，否则问题无法求解。
2. **确定状态和状态变量**：将「问题发展到各个阶段时所处的各种客观情况」用不同的状态表示出来。当然，状态的选择要满足无后效性。
3. **确定决策并写出状态转移方程**：因为决策和状态转移有着天然的联系，**状态转移就是根据上一阶段的状态和决策来导出本阶段的状态**。所以，如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
4. **寻找边界条件**：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般情况下，只要「解决问题的阶段、状态和状态转移决策」确定了，就可以写出状态转移方程（包括边界条件）。

在实际应用中，可以按以下几个简化的步骤进行设计：
1. 分析最优解的性质，并刻画其结构特征；
2. 递归地定义最优解；
3. 以自底向上或自顶向下的记忆化方式，计算出最优值；
4. 根据计算最优值时得到的信息，构造问题的最优解。
 
注意：动态规划是一种求解思路，注重决策过程，不同的问题得到的模型可能不一样，关键是掌握其原理，利用递推关系求最优解。
## 8.1.4 动态规划与其他方法的比较
**动态规划的基本思想与分治法类似**，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子问题，前一子问题的解为后一子问题的求解提供了有用的信息，但分治法中各个子问题是独立的（不重叠的），动态规划则适用于子问题重叠的情况。

**动态规划方法又和贪心法有些相似**，在动态规划中，可将一个问题的解决方案视为一系列决策的结果。不同的是，在贪心法中每采用一次贪心准则、就做出一个不可回溯的决策，还要考察每个最优决策序列中是否包含一个最优子序列（？）。

一般采用动态规划求解问题，只需要多项式时间复杂度，因此它比回溯法、暴力法等要快许多。

---
# 8.2 求解最大连续子序列和问题
最大连续子序列和（就是最大子数组和）问题的描述，参见4.2.4小节，这里采用动态规划法求解。

【问题求解】对于含有 $n$ 个整数的序列 $a[1...n]$ ，设 $b_j$ 为 $a[1...j]$ 中以 $a[j]$ 结尾的最大连续子序列和，则 $b_{j - 1}$ 表示 $a[1...j-1]$ 中以 $a[j - 1]$ 结尾的最大连续子序列和，如图8.7所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/a4b41b02820141578fb81bddf4741ce3.png)
显然，当 $b_{j - 1} > 0$ 时 $b_j = b_{j - 1} + a_j$ ，当 $b_{j - 1} \le 0$ 时放弃前面选取的元素，从 $a_j$ 开始重新选取，即 $b_j = a_j$（**即使 $a_j \le 0$ 也不影响**）。用一维动态规划数组 $dp$ 存放 $b$ ，对应的状态转移方程如下：
- $dp[0] = 0$ ，是边界条件；
- $dp[j] = \max \{ dp[j - 1] + a_j,\ a_j\}\ (1 \le j \le n)$ 

则序列 $a$ 的最大连续子序列和等于 $dp[j]\ (1 \le j \le n)$ 中的最大者。

从中看到，若序列 $a$ 的最大连续子序列和等于 $dp[maxj]$ ，==在 $dp$ 中从该位置向前找，找到第一个值小于或等于 $0$ 的元素 $dp[k]$ ，则 $a$ 序列中从 $k + 1$ 开始到 $maxj$ 位置的所有元素，恰好构成最大连续子序列==。

例如，若 $a$ 序列为 $(-2, 11, -4, 13, -5, -2)$ ，$dp[0] = 0$ ，求其他元素如下：
![ ](https://img-blog.csdnimg.cn/3f977c825c1e466682304c448860a68e.png)
其中 $dp[4] = 20$ 为最大值，向前找到 $dp[1]$ 小于等于 $0$ ，所以由 $a_2 \sim a_4$ 的元素即 $(11, -4, 13)$ 构成最大连续子序列，其和为 $20$ 。

对应的完整程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 25;

// 问题表示
int n = 6;
int a[] = {0, -2, 11, -4, 13, -5, -2};		// a数组不用下标0的元素
// 求解结果表示
int dp[MAXN];
void maxSubSum() {
	dp[0] = 0;
	for (int j = 1; j <= n; ++j)
		dp[j] = max(dp[j - 1] + a[j], a[j]);
}
void dispMaxSum() {
	int maxj = 1, k;
	for (int j = 2; j <= n; ++j) 			// 求dp中的最大元素dp[maxj]
		if (dp[j] > dp[maxj]) maxj = j;
	for (k = maxj; k >= 1; --k)			// 找前一个值小于等于0者
		if (dp[k] <= 0) break;
	printf("  最大连续子序列和: %d\n", dp[maxj]);
	printf("  所选子序列: ");
	for (int i = k + 1; i <= maxj; ++i)
		printf("%d ", a[i]);
	printf("\n");
}
int main() {
	maxSubSum();
	printf("求解结果\n");
	dispMaxSum();
	return 0;	
}
```
本程序的执行结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/4f3b0f8a9221468b8e48dae354f7e541.png)
算法分析：`maxSubSum()` 函数含一重循环，对应的时间复杂度均为 $O(n)$ 。

【例8.1】读入一个字符串 `str` ，求出字符串 `str` 中连续最长的数字串的长度。
输入描述：包含一个测试用例，一个字符串，长度不超过 $255$ 。
输出描述：在一行内输出 `str` 中连续最长的数字串的长度。
输入样例：
```cpp
abcd12345ed125ss123456789
```
输出样例：
```cpp
9	// 对应最长的数字串为123456789
```
解：（应该可用滑动窗口解决）设置一维动态规划数组 $dp$ ，$dp[i]$ 表示 $str[0...i]$ 中以 $str[i]$ 结尾的连续数字串的长度，首先初始化 $dp$ 的所有元素为 $0$ 。当 $str[0]$ 为数字字符时置 $dp[0]= 1$ ；若 $str[i]$ 为数字字符，则 $dp[i] = dp[i - 1] + 1$ ，否则置 $dp[i] = 0$ ，所以 $dp[i]\ (0 \le i \le n - 1)$ 的最大值即为所求。对应的完整程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 258;

string str;
int solve() {
	int dp[MAXN];
	int ans = 0;
	memset(dp, 0, sizeof(dp));
	if (isdigit(str[0])) dp[0] = 1;			// str[0]为数字字符
	for (int i = 1; i < str.size(); ++i) {
		dp[i] = (isdigit(str[i])) ? dp[i - 1] + 1 : 0;	
		ans = max(ans, dp[i]);
	}
	return ans;
}
int main() {
	cin >> str;
	printf("%d\n", solve());
	return 0;
}
```
实际上，前面的 `solve()` 算法可以进一步优化，用 `curlength` 单个变量代替 $dp$ 数组：
```cpp
int solve1() {
	int curlength = 0, ans = 0;
	for (int i = 0; i < str.size(); ++i) {
		if (isdigit(str[i])) ++curlength;
		else curlength = 0;	
		ans = max(ans, curlength);
	}
	return ans;
}
```

---
# 8.3 求解三角形最小路径问题
【问题描述】给定高度为 $n$ 的一个整数三角形，找出从顶部到底部的最小路径和，注意：从每个整数出发，只能向下移动到相邻的整数。首先输入 $n$ ，接下来的 $1\sim n$ 行、第 $i$ 行输入 $i$ 个整数，输出分为两行，第 $1$ 行为最小路径、第 $2$行为最小路径和。例如，图8.8所示为一个 $n = 4$ 的三角形，输出的路径是 $2\ 3\ 5\ 3$ ，最小路径和是 $13$ 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/5f3078716aab46acbbc8569e543f286e.png)
【问题求解】将三角形采用二维数组 $a[0... n - 1][0...n - 1]$ 存放，图8.8所示的三角形对应的二维数组如图8.9所示，从顶部到底部查找最小路径，那么结点 $(i, j)$ 的前驱结点只有 $(i - 1, j - 1)$ 和 $(i - 1, j)$ 两个，如图8.10所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/153401f265c6456cb5fadba19e2e456b.png)
用二维数组 $dp$ 作为动态规划数组，$dp[i][j]$ 表示从顶部 $a[0][0]$ 查找到 $(i, j)$ 结点时的最小路径和。显然，这里有两个边界，即第 $1$ 列和对角线，到达它们中的结点的路径只有一条、而不是常规的两条。所以，状态转移方程如下：
- $dp[0][0] = a[0][0]$ ，这是顶部边界；
- $dp[i][0] = dp[i - 1][0] + a[i][0]\ (1\le i \le n - 1)$ ，考虑第一列的边界；
- $dp[i][i] = dp[i - 1][i - 1] + a[i][i]\ (1\le i \le n - 1)$ ，考虑对角线的边界；
- $dp[i][j] = \min(dp[i-1][j-1], dp[i-1][j]) + a[i][j]$ ，$i > 1$ 的其他有两条达到路径的结点

最后求出最小路径和 $ans = \min \{ dp[n - 1][j] \}$ 以及对应的列号 $k$ 。这里还需要求出最小和路径，为此设计一个二维数组 $pre$ ，==$pre[i][j]$ 表示查找到 $(i, j)$ 结点时最小路径上的前驱结点，由于前驱结点只有两个为 $(i-1,j-1)$ 和 $(i-1,j)$ ，用 $pre[i][j]$ 记录前驱结点的列号即可==。在求出 $ans$ 后，通过 $pre[n - 1][k]$ 反推出反向路径，最后正向输出该路径。**除此以外，还可以从二维数组 $dp$ 中推导出最小路径**。

对应的完整程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100;

// 问题表示
int a[MAXN][MAXN];	
int n;
// 求解结果表示
int ans = 0;
int dp[MAXN][MAXN];
int pre[MAXN][MAXN];
int Search() {							// 求最小路径和ans
	dp[0][0] = a[0][0];
	for (int i = 1; i < n; ++i) {		// 考虑第1列的边界
		dp[i][0] = dp[i - 1][0] + a[i][0];
		pre[i][0] = 0;
	}
	for (int i = 1; i < n; ++i) {		// 考虑对角线的边界
		dp[i][i] = a[i][i] + dp[i - 1][i - 1];
		pre[i][i] = i - 1;	
	}
	for (int i = 2; i < n; ++i) {
		for (int j = 1; j < i; ++j) {
			if (dp[i - 1][j - 1] < dp[i - 1][j]) {
				dp[i][j] = a[i][j] + dp[i - 1][j - 1];
				pre[i][j] = j - 1;	
			} else {
				dp[i][j] = a[i][j] + dp[i - 1][j];
				pre[i][j] = j;
			}
		}
	}
	ans = dp[n - 1][0];
	int k = 0;
	for (int j = 1; j < n; ++j) {		// 求出最小ans和对应的列号k
		if (ans > dp[n - 1][j]) {
			ans = dp[n - 1][j];
			k = j;
		}
	}
	return k;
}
void DispPath(int k) {					// 输出最小和路径
	int i = n - 1;
	vector<int> path;					// 存放逆路径向量path
	while (i >= 0) {					// 从(n-1,k)结点反推求出反向路径
		path.push_back(a[i][k]);
		k = pre[i][k];					// 最小路径在前一行中的列号
		--i;							// 在前一行中查找
	}
	for (int i = path.size() - 1; i >= 0; --i)
		printf("%d ", path[i]);
	printf("\n");
}

int main() {
	memset(pre, 0, sizeof(pre));
	memset(dp, 0, sizeof(dp));
	scanf("%d", &n);					// 输入三角形的高度
	for (int i = 0; i < n; ++i)			// 输入三角形
		for (int j = 0; j <= i; ++j)
			scanf("%d", &a[i][j]);
	int k = Search();					// 求最小路径和
	DispPath(k);						// 输出正向路径
	printf("%d\n", ans);				// 输出最小路径和
	return 0;
}
```
上述程序的执行结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/59fa9be03fe4472daeb41c9a91636c81.png)
算法分析：`Search()` 算法中有 $i$ 从 $2$ 到 $n - 1$ 、$j$ 从 $1$ 到 $i-1$ 的两重循环，容易求出时间复杂度为 $O(n^2)$ 。

---
# 8.4 求解整数拆分问题
【问题描述】求将正整数 $n$ 无序拆分成最大数为 $k$ 的拆分方案个数，要求所有的拆分方案不重复。

【问题求解】设 $n = 5, k = 5$ ，对应的拆分方案如下：
```cpp
(1) 5 = 5
(2) 5 = 4 + 1
(3) 5 = 3 + 2
(4) 5 = 3 + 1 + 1
(5) 5 = 2 + 2 + 1
(6) 5 = 2 + 1 + 1 + 1
(7) 5 = 1 + 1 + 1 + 1 + 1
```
为了防止重复计数，让拆分方案中的各拆分数从大到小排列。这里正整数 $5$ 的拆分方案个数为 $7$ 。

采用动态规划求解整数拆分问题（可参考[整数拆分问题](http://blog.chinaunix.net/uid-26548237-id-3503956.html)）。设 $f(n, k)$ 为将数 $n$ 无序拆分成「最大不超过 $k$ 的数」之和（称为 $n$ 的 $k$ 拆分）的方案个数：
1. 当 $n = 1$ 时，不论 $k$ 的值为多少（$k > 0$），只有一种划分，即 $\{ 1\}$ ，显然 $f(n, k) = 1$ 。
2. 当 $k = 1$ 时，不论 $n$ 的值为多少（$n > 0$），只有一种划分，即 $\{ 1, 1, \dots, 1, 1\}$ ，显然 $f(n, k) = 1$ 。
3. 当 $n < k$ 时，有 $f(n, k) = f(n, n)$ 。
4. 当 $n = k$ 时，根据拆分方案中是否含有 $n$ ，可分为两种情况：
	① 拆分中包含 $n$ 的情况，只有一个，即 $\{n\}$ 。
	② 拆分中不包含 $n$ 的情况，这时拆分中最大的数字也一定比 $n$ 小，即 $n$ 的所有 $n - 1$ 拆分。
	因此，$f(n, n) = f(n, n -1) + 1$ 。
5. 当 $n > k$ 时，根据拆分方案中是否含有 $k$ ，可以分为两种情况：
	① 拆分中包含 $k$ 的情况，即一部分为单个 $k$ ，另一部分为 $\{ x_1, x_2, \dots, x_i\}$ ，后者的和为 $n - k$ ，后者中可能再次出现 $k$ ，因此是 $n - k$ 的 $k$ 拆分，所以这种拆分方案个数为 $f(n - k, k)$ 。
	② 拆分中不包含 $k$ 的情况，即拆分中的所有拆分数都比 $k$ 小，即 $n$ 的 $k - 1$ 拆分，拆分方案个数为 $f(n, k - 1)$ 。
因此，$f(n, k) = f(n - k, k) + f(n, k - 1)$ 。

归纳起来可看出，上面的结论具有递归定义的特征。其中1和2属于边界条件，3和4属于特殊情况，5属于通用情况。其本质主要是通过减少 $n$ 或 $k$ 以达到边界条件、从而解决问题：
$$f(n, k) = \begin{cases}
1 &\quad 当n=1或者k=1时 \\
f(n, n) &\quad 当n<k时 \\
f(n, n - 1) + 1 &\quad 当 n = k时\\
f(n - k, k) + f(n, k - 1) &\quad 其他情况 
\end{cases}$$

显然，求 $f(n, k)$ 满足动态规划问题的最优性原理、无后效性和重叠子问题性质，所以特别适合采用动态规划法求解。设置动态规划数组 $dp$ ，用 $dp[n][k]$ 存放 $f(n, k)$ 。对应的完整程序如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 500;

int dp[MAXN][MAXN];						// 动态规划数组
void Split(int n, int k) {
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= k; ++j) {
			if (i == 1 || j == 1) dp[i][j] = 1;
			else if (i < j) dp[i][j] = dp[i][i];
			else if (i == j) dp[i][j] = dp[i][j - 1] + 1;
			else dp[i][j] = dp[i][j - 1] + dp[i - j][j];			
		}
	}        
}
int main() {
	int n = 5, k = 5;
	memset(dp, 0, sizeof(dp));
	Split(n, k);
	printf("(%d, %d)=%d\n", n, k, dp[n][k]);	
}
```
上述程序运行结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/06d855ff0c0c4e90acbe2c99883b9c84.png)在 `Split()` 算法中，按行 $i$ 优先计算 $dp[i][j]$ ，其中 $dp[1][*]$ 和 $dp[*][1]$ 为边界（结果均为 $1$ ）。例如计算 $dp[5][5]$ 的过程如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/e0b0fc5322b046f2a483cdacd20807a0.png)
计算结果如图8.6所示，从中看出计算过程是自底向上的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/e1b97b6f72464ae3b17f69b097468f29.png)

实际上该问题本身是递归的，可以直接采用递归算法实现，但由于子问题重叠，存在重复的计算，可采用如下方法避免重复计算：==设置数组 $dp$ ，用 $dp[n][k]$ 存放 $f(n,k)$ ，首先初始化 $dp$ 中的所有元素为特殊值 $0$ ，当 $dp[n][k]$ 不为 $0$ 时表示对应的子问题已经求解，直接返回结果==。对应的完整程序如下所示：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 500;

int dp[MAXN][MAXN];						// 动态规划数组
int dpf(int n, int k) {
	if (dp[n][k] != 0) return dp[n][k];
	if (n == 1 || k == 1) return dp[n][k] = 1;
	else if (n < k) return dp[n][k] = dpf(n, n);
	else if (n == k) return dp[n][k] = dpf(n, k - 1) + 1;
	else return dp[n][k] = dpf(n, k - 1) + dpf(n - k, k);
}
int main() {
	int n = 5, k = 5;
	memset(dp, 0, sizeof(dp));
	printf("(%d, %d)=%d\n", n, k, dpf(n, k));	
}
```
==这种方法是一种递归算法，其执行过程也是自顶向下的，但当某个子问题的解求出后将其结果存放在一张表 $dp$ 中，而且相同的子问题只计算一次，在后面需要时只要简单查一下即可，从而避免了大量的重复计算==。这种方法称为**备忘录方法** `memorization method` ，是动态规划方法的变形，不同在于备忘录方法的递归方式是自顶向下的，而动态规划法是自底向上的。8.1.2节中求 $A$ 到 $E$ 的最短路径的逆序解法和顺序解法两个算法，就是采用备忘录方法求解的。

---
# 其他内容 
[【数据结构和算法设计】算法篇(8) 动态规划(2)](https://memcpy0.blog.csdn.net/article/details/124068460)


---
# 其他题目
![在这里插入图片描述](https://img-blog.csdnimg.cn/b6796e49bea544a099062d93bc2033f1.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/ac3d7ee7fedd47c2881f84d91a6e4c68.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/642863a643434597884e6b63f786d8b8.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/8421a3f22f32413fb1c6d265f9c02880.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/b4fd70313aa040b9a3b14c41013fce37.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/380228023dcf44b496ab35a1f115de89.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/5e3bb4f557de484f8efd81996df6c5fb.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/f59b3227f6864927a72de04714983464.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/70e2f04b303245278821034f3bf40183.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/30bfab9514234e3ebfae9a0ece2075be.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/4c2e7c4526c74878a1878421033487ae.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/d19b6530be9f46c6a1eb7a285b29781f.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/74e9dfbebcd74ef2b5f034702223b8b8.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/94e4c892637d41bdab6cf739ac116636.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/e292a009f84b4d2a978462ca5babf479.png)

