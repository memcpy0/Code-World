@[toc]

# NOIP2010——数字统计
请统计某个给定范围[L, R]的所有整数中，数字2出现的次数。比如给定范围[2, 22]，数字2在数2中出现了1次，在数12中出现1 次，在数20中出现1 次，在数21中出现1 次，在数22 中出现2次，所以数字2在该范围内一共出现了6次。
1≤ L ≤ R≤10000。

做法一：
从L到R枚举每一个数i,对i进行分离数字，直接统计有多少个2......
分离数字的过程
void count(int n)
{while (n>0)
   {if (n%10==2) ans++;
    n/=10;
   }
}

# NOIP2010——接水问题
学校里有一个水房，水房里一共装有m 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为1。
现在有n 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从1到n 编号，i 号同学的接水量为wi。接水开始时，1 到m 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学j 完成其接水量要求wj 后，下一名排队等候接水的同学k马上接替j 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即j 同学第x 秒结束时完成接水，则k 同学第x+1 秒立刻开始接水。若当前接水人数n’不足m，则只有n’个龙头供水，其它m−n’个龙头关闭。
现在给出n 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。
1 ≤ n ≤ 10000，1 ≤m≤ 100 且m≤ n；1 ≤ wi ≤ 100。
样例输入					     	
8 4							 
23 71 87 32 70 93 80 76
样例输出
163

纯模拟+贪心
每次找最短的队伍排，模拟一下。。。

# NOIP2010——导弹拦截
某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为0 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。
某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。
第一行包含4 个整数x1、y1、x2、y2，每两个整数之间用一个空格隔开，表示这两套导弹拦截系统的坐标分别为(x1, y1)、(x2, y2)。
第二行包含1 个整数N，表示有N 颗导弹。接下来N 行，每行两个整数x、y，中间用一个空格隔开，表示一颗导弹的坐标(x, y)。不同导弹的坐标可能相同。
对于100%的数据，1 ≤ N ≤ 100000，且所有坐标分量的绝对值都不超过1000。

样例输入			
0 0 6 0			
5
-4 -2
-2 3
4 0
6 -2
9 1
样例输出
30
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630164924659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
按照到第一个点的距离排序，确定了第一个点拦截的范围，剩下来的一定是第二个点拦截，用类似后缀和统计一下，枚举断点，统计和的最小值就行了。

# NOIP2010——三国
输入样例					
8							
42 24 10 29 27 12 58			
31 8 16 26 80 6
25 3 36 11 5
33 20 17 13
15 77 9
4 50
19
输出样例
1
77
显然每个武将对应的最大默契值都无法选到，但是可以保证能选到次大的。所以就在次大的中选一个最大的作为答案咯。这样计算机肯定也得不到更大的值所以一定是可以获胜的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630165048517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
# NOIP2011——数字反转
给定一个整数，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例2）
-1,000,000,000 ≤ N≤ 1,000,000,000。
样例输入			
	-380				
样例输出
-83
模拟，涉及数字分离和组合，以及负数判断
程序     
    cin>>n;
	if(n<0)//判断负数
	   {flag=true;
	    n=-n;
	  }
	while(n>0)//反转 
	   {ans=(ans*10)+n%10;
	    n/=10;
	   }
	if(flag)ans=-ans;
	cout<<ans<<endl;

# NOIP2011——统计单词数
一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例2）。
1 ≤ 单词长度≤ 10。1 ≤ 文章长度≤ 1,000,000。

样例输入				
To						
to be or not to be is a question
样例输出
2  0
样例输入				
To						
Did the Ottoman Empire lose its power at that time
样例输出
-1

从测试数据的数据量来分析。文章长度为1000000，而单词长度为10。即便一位一位的匹配。运算测试也就是在10000000左右。而实际每一个单词只有匹配一次。所以，如果控制的好的话，完全可以把运算量控制在百万级别。但即便是千万的运算次数对于我们的测评来说，还是绰绰有余的。所以，在这道题目中，不用考虑 KMP 等字符串匹配算法。  
当然，这道题目在测试数据中也增加了很多陷阱。如多空格分隔。前空格分隔和后空格分隔、大小写不区分、完整匹配等等。但是，最最朴素的匹配算法，倒是很简单的能够将这些问题排除掉。可以说，出题人还是主要考虑考场选手的基本功底的思路。 

# NOIP2011——瑞士轮
2*N 名编号为1~2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。
每轮比赛的对阵安排与该轮比赛开始前的排名有关：第 1 名和第2 名、第3 名和第4名、……、第2K – 1 名和第2K 名、…… 、第 2N – 1 名和第2N 名，各进行一场比赛。每场比赛胜者得1 分，负者得0 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。
现给定每个选手的初始分数及其实力值，试计算在 R 轮比赛过后，排名第Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。
`1 ≤ N≤ 100,000，1 ≤ R≤ 50，1 ≤ Q≤ 2N，0 ≤ s1, s2, …, s2N ≤ 10^8，1 ≤ w1,w2, …, w2N ≤ 10^8`。
样例输入				
   2 4 2				
   7 6 6 7
   10 5 20 15
样例输出
1
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630165418126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
首先说，这道题目的题目类型，应该划归为模拟。按理说，只要按照题目的要求一步一步来做，就可以解决问题。但是，这道题目，在数据量上开始做了很大文章。在第一次读题时，我也武断的判断这道题的难度为中等。即在考核点上，只是考核一个快排即可。但是，很快，在我写完这道题目之后，发现，竟然只能通过 4 个点。这时才开始思考，nlogn 的效率，是否可以完成这个任务数量最大为200000，log2n 大概在 17 左右，然后乘 200000 。再去乘50 。的确是 1 亿 7 千万次左右。这的确超过了，我们能够承受的速度几倍。
将结构定义为两个有序序列的合并。也就是归并法排序上来。这就提高了很大的难度。相信不少同学在这道题目丢分也是因为忽略了这个排序方法也就是说归并两个有序序列就成为了我们在这道题目里面的重点。题目设计为奇数项和偶数项进行比，结果将必有一个增加，另外一个保持不变。那么其实在这道题里面我们就可以保证增加项的序列仍然保持有序，而未增加项的序列也保持有序。那么就需要我们在每一次做完比较后，将胜者保持在奇数项和败者保留在偶数项。这样就可以把一个序列的奇数项和偶数项分别当成两个序列。将他们合并到另外一个序列中去。
然后再将那么序列覆盖会原有序列中。这样就能够最大效果的减少计算量。所以，本道题目，需要先进行一次快排（而且不能单纯使用左侧数值当成标准值，否则有数据将快排降速到 n^2 效率）。每轮结束后，都进行一次归并排序，再覆盖回原来序列（当然，也可以使用滚动数组，让两个数组来回使用，提高效率。）

# NOIP2012——质因数分解 
已知正整数n是两个不同的质数的乘积，试求出较大的那个质数。 
6 ≤n ≤2*10^9。 
样例输入				
     21					
样例输出
7

不妨设n = x * y，那么min(x，y) <= n^0.5，所以直接枚举1到n^0.5之间的数字i，如果i | n，那么min(x，y) = i， max(x，y) = n / i。
复杂度O(n^0.5) 

# NOIP2012——寻宝 
藏宝楼共有N+1层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼另有N层，每层M个房间，这M个房间围成一圈并按逆时针方向依次编号为0，…，M-1。其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字x，表示从这个房间开始按逆时针方向选择第x个有楼梯的房间（假定该房间的编号为k），从该房间上楼，上楼后到达上一层的k号房间。比如当前房间的指示牌上写着2，则按逆时针方向开始尝试，找到第2个有楼梯的房间，从该房间上楼。如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。 
第一行2个整数N和M，之间用一个空格隔开。N表示除了顶层外藏宝楼共N层楼，M表示除顶层外每层楼有M个房间。
接下来N*M行，每行两个整数，之间用一个空格隔开，每行描述一个房间内的情况，其中第(i-1)*M+j行表示第i层j-1号房间的情况（i=1,2,…, N,j=1,2,…,M）。第一个整数表示该房间是否有楼梯通往上一层（0表示没有，1表示有），第二个整数表示指示牌上的数字。注意，从j号房间的楼梯爬到上一层到达的房间一定也是j号房间。
最后一行，一个整数，表示小明从藏宝楼底层的几号房间进入开始寻宝（注：房间编号从0开始）。 

虑按照题意模拟，每次不停的找有楼梯的房间，不难发现这样最坏情况是每层只有一个房间，这样要找1e5*1e2*1e6显然承受不了。
一个简单的想法，每次先把有楼梯的找出来，但是这样复杂度还是过高。
注意到一个事实，一层的房间并不多，当x很大的时候，大部分我们做的操作是在这层不停的转，假设这层有cnt个有楼梯的房间，那么显然每走过cnt个房间，又会回到刚开始的房间，所以我们可以将x mod cnt, 这样x就小于m了。

# NOIP2012——摆花 
小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共m盆。通过调查顾客的喜好，小明列出了顾客最喜欢的n种花，从1到n标号。为了在门口展出更多种花，规定第i种花不能超过ai盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。
试编程计算，一共有多少种不同的摆花方案。
`0<n≤100，0<m≤100，0≤ai≤100  `

样例输入			
 2 4				
 3 2 
 样例输出
 2
有2种摆花的方案，分别是(1，1，1，2)，(1，1，2，2)。括号里的1和2表示两种花，比如第一个方案是前三个位置摆第一种花，第四个位置摆第二种花。
状态
f[i][j]表示前i个盆摆前j种花的方案数
状态转移
F[i][j]+=f[i-k][j-1]  (0≤k≤a[j],i≥k)
初始化
f[0][j]=1（ 0≤j≤n）
f[i][j]=0 （其他的i,j）
目标状态
F[m][n]

# NOIP2012——文化之旅 
有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。
现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。 
第一行为五个整数N，K，M，S，T，每两个整数之间用一个空格隔开，依次代表国家个数（国家编号为1到N），文化种数（文化编号为1到K），道路的条数，以及起点和终点的编号（保证S不等于T）；
第二行为N个整数，每两个整数之间用一个空格隔开，其中第i个数Ci，表示国家i的文化为Ci。
接下来的K行，每行K个整数，每两个整数之间用一个空格隔开，记第i行的第j个数为aij，aij= 1表示文化i排斥外来文化j（i等于j时表示排斥相同文化的外来人），aij= 0表示不排斥（注意i排斥j并不保证j一定也排斥i）。
接下来的M行，每行三个整数u，v，d，每两个整数之间用一个空格隔开，表示国家u与国家v有一条距离为d的可双向通行的道路（保证u不等于v，两个国家之间可能有多条道路）。 
输出只有一行，一个整数，表示使者从起点国家到达终点国家最少需要走的距离数（如果无解则输出-1）。
2≤N≤100，1≤K≤100，1≤M≤N^2，1≤Ci≤K，1≤u,v≤N，1≤d≤1000，S≠T，1 ≤S, T≤N。 
这题考察的是搜索和剪枝的技巧。
首先我们先利用floyd算法计算出任意两点的可能距离dist[i][j]，更新时要注意i -> j ->k 时 j不能排斥(把相同文化之间也认为排斥)i，k不能排斥j和i，为什么说是可能的距离呢，因为这样并不能准确的求出答案，比如i->x->k->y->j， 但是 y排斥x，这样判断的时候并不能够判断出来，还是会用i->k->j来更新i->j。但是由于这题官方数据极弱，如果直接输出这个错误的答案能得到90分。 
剪枝1（可行性剪枝）：每次经过一个点x，就把这个所有排斥这个点x的点y标记一下，因为之后肯定不可以经过那个点y。
剪枝2（最优性剪枝）：考虑当前在点x，已经走过距离len，x-y有一条边，接下来我们要从x->y，那么如果len + g[x][y](边x-y的长度)+dist[y][t] >= ans， 那么这个解一定不会比答案更优，为什么呢？因为之前我们说dist是一个不准确的值，这个值是不大于真正的值的，也就是len+g[x][y]+真实值 >= len + g[x][y] + dist[y][t] >= ans，
即len+g[x][y]+真实值 >= ans， 所以这个方案不可能比ans更小，所以剪去。

# NOIP2013——计数问题 
试计算在区间1到n的所有整数中，数字x（0≤x≤9）共出现了多少次？例如，在1到11中，即在1、2、3、4、5、6、7、8、9、10、11中，数字1出现了4次。
【输入】
输入共1行，包含2个整数n、x，之间用一个空格隔开。
【输出】
输出共1行，包含一个整数，表示x出现的次数。
直接暴力枚举每个数，看看有多少个x就行了。 

# NOIP2013——表达式求值 
给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。
输入仅有一行，为需要你计算的表达式，表达式中只包含数字、加法运算符“+”和乘法运算符“*”，且没有括号，所有参与运算的数字均为0到2^31-1之间的整数。输入数据保证这一行只有0~ 9、+、*这12种字符。
输出只有一行，包含一个整数，表示这个表达式的值。注意：当答案长度多于4位时，请只输出最后4位，前导0不输出。

一般的方法是用栈模拟，但是本题只有+和*，于是以每个+为分隔符算出所有数*起来的结果就行了。 

# NOIP2013——小朋友的数字 
有n个小朋友排成一列。每个小朋友手上都有一个数字，这个数字可正可负。规定每个小朋友的特征值等于排在他前面（包括他本人）的小朋友中连续若干个（最少有一个）小朋友手上的数字之和的最大值。
作为这些小朋友的老师，你需要给每个小朋友一个分数，分数是这样规定的：第一个小朋友的分数是他的特征值，其它小朋友的分数为排在他前面的所有小朋友中（不包括他本人），小朋友分数加上其特征值的最大值。
请计算所有小朋友分数的最大值，输出时保持最大值的符号，将其绝对值对p取模后输出。
输入
第一行包含两个正整数n、p，之间用一个空格隔开。
第二行包含n个数，每两个整数之间用一个空格隔开，表示每个小朋友手上的数字。
输出
输出只有一行，包含一个整数，表示最大分数对p取模的结果。
100%的数据，1≤n≤1,000,000，1≤p≤10^9，其他数字的绝对值均不超过10^9。
样例输入			
5 997				
1 2 3 4 5
小朋友的特征值分别为1、3、6、10、15，分数分别为1、2、5、11、21，最大值21对997的模是21。输出21
样例输出
21

特征值其实是最大子序列，用g[i]表示以第i个数结尾的最大子序列的值，那么g[i]=max(a[i],g[i-1]+a[i])，其中a数组表示手上的数字。那么特征值f[i]=max(g[i],f[i-1])
对于分数，除了第一个人显然是不下降的，于是只要用第1个和第n个比较就好。第i个的分数如果是x，显然i+1是max(x,x+f[i])也就是x+max(0,f[i])，那么第n个人的分数就是2*f[1]+∑max(f[i],0)其中i是从2到n-1，注意别爆long long就可以了

# NOIP2013——车站分级 
一条单向的铁路线上，依次有编号为1, 2, …, n的n个火车站。每个火车站都有一个级别，最低为1级。现有若干趟车次在这条线路上行驶，每一趟都满足如下要求：如果这趟车次停靠了火车站x，则始发站、终点站之间所有级别大于等于火车站x的都必须停靠。（注意：起始站和终点站自然也算作事先已知需要停靠的站点）
例如，下表是5趟车次的运行情况。其中，前4趟车次均满足要求，而第5趟车次由于停靠了3号火车站（2级）却未停靠途经的6号火车站（亦为2级）而不满足要求。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020063016590427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
第一行包含2个正整数n, m，用一个空格隔开。
第i+ 1行（1 ≤ i≤ m）中，首先是一个正整数si（2 ≤ si≤ n），表示第i趟车次有si个停靠站；接下来有si个正整数，表示所有停靠站的编号，从小到大排列。每两个数之间用一个空格隔开。输入保证所有的车次都满足要求。
输出只有一行，包含一个正整数，即n个火车站最少划分的级别数。
对于100%的数据，1 ≤ n, m ≤ 1000。
样例输入				
9 2					
4 1 3 5 6
3 3 5 6	
样例输出
2
样例输入				
9 3					
4 1 3 5 6
3 3 5 6
3 1 5 9	
样例输出
3

对于一班车，如果从l到r没有经过x，那么所有经过的车站（比如y）等级都会大于x，连一条y到x的边，那么暴力连边是O(n^3)，用bitset压位就能建出来图，这是个有向无环图，因为y>x，就不可能x>y。然后很显然的贪心思想就是最外层没有入边的点是最大值，删掉那些边，剩下的没有入边的点是次大，然后一层一层消，直到消玩为止，这个复杂度是O(n^2)。

# NOIP2014——珠心算测试
珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。 某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另 外两个（不同的）数之和？
最近老师出了一些测验题，请你帮忙求出答案。 
输入共两行，第一行包含一个整数 n，表示测试题中给出的正整数个数。第二行有 n 个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。
输出共一行，包含一个整数，表示测验题答案。  
送分题，直接枚举每个数a[i]，再枚举其他两个数a[j]和a[k]，若存在j≠k且a[i]=a[j]+a[k]满足则说明能表示a[i]能写成其他不同的两个数之和。
注意：是两个不同数之和。
时间复杂度O(n^3)，期望100分。

# NOIP2014——比例简化
在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有 1498  人，反对的有 902  人，那么赞同与反对的比例可以简单的记为1498:902。
不过，如果把调查结果就以这种方式呈现出来，大多数人肯定不会满意。因为这个比例 的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为 5:3，虽然与 真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。
现给出支持人数 A，反对人数 B，以及一个上限 L，请你将 A 比 B 化简为 A’比 B’，要 求在 A’和 B’均不大于 L 且 A’和 B’互质（两个整数的最大公约数是 1）的前提下，A’/B’ ≥ A/B 且 A’/B’ - A/B 的值尽可能小。
对于 100%的数据，1  ≤ A  ≤ 1,000,000，1  ≤ B  ≤ 1,000,000，1  ≤ L  ≤ 100，A/B  ≤ L。 
枚举题，我们发现L很小(只有100)，于是我们可以枚举所有的i和j，从中选择最优的一对，发现最优的一对其实就是在满足的           前提下，让    最小，这个很好统计。至于必须互质的条件， 枚举时判断i,j是否互质（最大公约数为1）。
时间复杂度，期望100分。 

# NOIP2014——螺旋矩阵 
一个 n 行 n 列的螺旋矩阵可由如下方法生成：
从矩阵的左上角（第 1 行第 1 列）出发，初始时向右移动；如果前方是未曾经过的格子， 则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中 依次填入 1, 2, 3, ... , n^2，便构成了一个螺旋矩阵。

下图是一个 n = 4  时的螺旋矩阵。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630170108364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)
现给出矩阵大小 n 以及 i 和 j，请你求出该矩阵中第 i 行第 j 列的数是多少。  
100%的数据，1  ≤ n  ≤ 30,000，1  ≤ i  ≤ n，1  ≤ j  ≤ n。

信心题，拿到这个问题直接处理或许有些困难，我们可以考虑一个简化的情况，如果在边界上，那么可以讨论一下，格子里的数很好计算。比如第k行第m列，那么就是m+k-1，为了让处理变得跟简单，我们考虑每次删掉一条边界上的数字，轮流删掉上右下左的边界，删掉前判断询问格子是否在这一条边界内，若在，输出答案，不在，则删掉边界变成子问题，并把最终答案加上删掉的元素个数，变成子问题的时候可以整体将棋盘平移，例如删掉上边界就可以把i减去1，相当于上移一格。具体可以看我的程序。
时间复杂度O(N)，期望100分。

# NOIP2014——子矩阵 

给出如下定义：
1.  子矩阵：从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵（保持行与列的相对顺序）被称为原矩阵的一个子矩阵。
例如，下面左图中选取第 2、4 行和第 2、4、5 列交叉位置的元素得到一个 2*3 的子矩阵如右图所示。 
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630170149330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70)2、相邻的元素：矩阵中的某个元素与其上下左右四个元素（如果存在的话）是相邻的。
3、矩阵的分值：矩阵中每一对相邻元素之差的绝对值之和。
本题任务：给定一个 n 行 m 列的正整数矩阵，请你从这个矩阵中选出一个 r 行 c 列的 子矩阵，使得这个子矩阵的分值最小，并输出这个分值。 
第一行包含用空格隔开的四个整数 n，m，r，c，意义如问题描述中所述，每两个整数 之间用一个空格隔开。接下来的 n 行，每行包含 m 个用空格隔开的整数，用来表示问题描述中那个 n （n≤16）行 m （m≤16）列的矩阵。
输出共 1 行，包含 1 个整数，表示满足题目描述的子矩阵的最小分值。 
样例输入				
5 5 2 3				
9 3 3 3 9
9 4 8 7 4
1 7 4 6 6
6 8 5 6 9
7 4 5 6 1
该矩阵中分值最小的 2 行 3 列的子矩阵由原矩阵的第 4 行、第 5 行与第 1 列、第 3 列、 第4列交叉元素组成，
样例输出
6

发现n,m很小，行的选取最多只有    $C^8_{16}=12870$            种方案，我们可以考虑枚举这些方案，再对列DP求出最大值。
我们可以把相邻格子对分为在同一列或者不在同一列的情况。由于行的选取情况已经确定，在同一列的格子对的贡献可以直接记录到每一列上，记为v[i]。如果将第i列和第j列放在一起，则可以计算出不在同一列的相邻格子对的贡献，将第i列和第j列放在一起的贡献记为w[i][j]。 

下面是DP，我们设f[i][j]表示已经选取了i+1列，当前选的最后一列是j的最小分值，则转移方程可以写成： 
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630170253639.png)
最后枚举j，用f[c-1][j]更新答案。
时间复杂度   $O(C^r_n \cdot m^2 c)$                ，期望100分。 

