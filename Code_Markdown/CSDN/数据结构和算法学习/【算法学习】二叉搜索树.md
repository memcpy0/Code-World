> 参考算法导论第12章 二叉搜索树
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/35c1a279b16d426fa67494d63f3ae817.png)
@[toc]


搜索树数据结构支持许多动态集合操作，包括 `SEARCH, MINIMUM, MAXIMUM, PREDECESSOR, SUCCESSOR, INSERT, DELETE` 等。因此，我们使用一棵搜索树，既可以作为一个字典，也可以作为一个优先队列。

二叉搜索树上的基本操作所花费的时间，与这棵树的高度成正比。对于有 $n$ 个结点的一棵完全二叉树来说，这些操作的最坏运行时间为 $\Theta(\log n)$ 。然而如果这棵树是一条 $n$ 个结点组成的线性链，那么同样的操作就要花费 $\Theta(n)$ 的最坏运行时间。（算导12.4节中）我们会看到，一棵随机构造的二叉搜索树的期望高度为 $O(\log n)$ ，因此这样一棵树上的动态集合的基本操作的平均运行时间是 $\Theta(\log n)$ 。

实际上，我们并不能总是保证随机地构造二叉搜索树，然而可以设计出二叉搜索树的变体，来保证基本操作具有很好的最坏情况性能。（算导第13章给出了）一个这样的变形是红黑树，它的树高为 $O(\log n)$ 。（算导第18章给出了）$B$ 树，它特别适用于二级（磁盘）存储器上的数据库维护。

在给出二叉搜索树的基本性质（算导附录B）之后，随后几节介绍如何遍历一棵二叉搜索树来按序输出各个值，如何在一棵二叉搜索树上查找一个值，如何查找最小或最大元素，如何查找一个元素的前驱和后继，如何对一棵二叉搜索树插入和删除等。

# 1. 什么是二叉搜索树
一棵二叉搜索树是以一棵二叉树组织的，如图12-1所示，这样一棵树可以使用一个链表数据结构来表述，其中每个结点就是一个对象。除了 $key$ 和卫星数据以外，每个结点还包含属性 $left, right, p$ 、分别指向结点的左孩子、右孩子和双亲。如果某个孩子结点和父结点不存在，则相应属性的值为 `NULL` 。根结点是树中唯一父指针为 `NULL` 的结点。
![在这里插入图片描述](https://img-blog.csdnimg.cn/a20ede41ee01432783951300d14fedc9.png)

二叉搜索树中的关键字，总是以满足**二叉搜索树性质**的方式来存储：设 $x$ 是二叉搜索树中的一个结点，如果 $y$ 是 $x$ 左子树中的一个结点，那么 $y.key \le x.key$ 。如果 $y$ 是 $x$ 右子树中的一个结点，那么 $y.key \ge x.key$ 。因此，在图12-1(a)中，树根的关键字为 $6$ ，在其左子树中有关键字 $2, 5, 5$ ，它们均不大于 $6$ ；在其右子树中有关键字 $7, 8$ ，它们均不小于 $6$ 。这个性质对树中的每个结点都成立。例如树根的左孩子为关键字 $5$ ，不小于其左子树中的关键字 $2$ 、并且不大于其右子树中的关键字 $5$ 。

二叉搜索树性质允许我们通过一个简单的递归算法、来按序输出二叉搜索树中的所有关键字，这种算法称为**中序遍历** `inorder tree walk` 算法。这样命名的原因是，输出的子树根的关键字、位于其左子树的关键字值和右子树的关键字值之间（类似地，**先序遍历** `preorder tree walk` 中输出的根的关键字、在其左右子树的关键字值之前，而**后序遍历** `postorder tree walk` 输出的根的关键字、在其左右子树的关键字值之后）。调用下面的过程 `INORDER-TREE-WALK(T.root)` ，就可以输出一棵二叉搜索树 $T$ 中的所有元素。
```cpp
INORDER-TREE-WALK(x)
	if x != NULL
		INORDER-TREE-WALK(x.left)
		print(x.key)
		INORDER-TREE-WALK(x.right)
```
作为一个例子，对于图12-1中的两棵二叉搜索树，中序遍历输出的关键字次序均为 $2, 5, 5, 6, 7, 8$ 。根据二叉搜索树性质，可以直接应用归纳法证明该算法的正确性。

遍历一棵有 $n$ 个结点的二叉搜索树需要耗费 $\Theta(n)$ 的时间，因为初次调用之后，对于树中的每个结点，这个过程恰好要自己调用两次：一次是它的左孩子，另一次是它的右孩子。下面的定理，给出了**执行一次中序遍历耗费线性时间**的一个证明。

**定理12.1** 如果 $x$ 是一棵有 $n$ 个结点子树的根，那么调用 `INORDER-TREE-WALK(x)` 需要 $\Theta(n)$ 时间。
**证明**：当 `INORDER-TREE-WALK` 作用于一棵有 $n$ 个结点子树的根时，用 $T(n)$ 表示需要的时间。由于 `INORDER-TREE-WALK` 要访问这棵子树的全部 $n$ 个结点，所以有 $T(n) = \Omega(n)$ 。下面要证明 $T(n) = O(n)$ 。

由于对一棵空树，`INORDER-TREE-WALK` 需要耗费一个小的常数时间（因为测试 `x != NULL` ），因此对某个常数 $c > 0$ ，有 $T(0) = c$ 。对 $n > 0$ ，假设调用 `INORDER-TREE-WALK` 作用在一个结点 $x$ 上，$x$ 结点的左子树有 $k$ 个结点、且其右子树有 $n - k - 1$ 个结点，则执行 `INORDER-TREE-WALK(x)` 的时间由 $T(n) \le T(k) + T(n - k - 1) + d$ 限界，其中常数 $d > 0$ 。此式反映了执行 `INORDER-TREE-WALK(x)` 的一个时间上界，其中不包括递归调用所花费的时间。

使用替换法（代入法），通过证明 $T(n) \le (c + d)n + c$ ，可以证得 $T(n) = O(n)$ 。对于 $n = 0$ ，有 $(c + d) \cdot 0 + c = T(0)$ 。对于 $n>0$ ，有：$$\begin{aligned}
T(n) &\le T(k) + T(n - k - 1) +d \\
&= ((c + d) k + c) + ((c + d) (n - k - 1) + c) + d \\
& = (c + d)n + c - (c + d) + c + d \\
&= (c + d)n + c \end{aligned}$$

于是，就完成了定理的证明。$\blacksquare$ 

---
# 2. 查询二叉搜索树
我们经常需要查找一个存储在二叉搜索树上的关键字。除了 `SEARCH` 操作之外，二叉搜索树还能支持诸如 `MINIMUM, MAXIMUM, SUCCESSOR, PREDECESSOR` 的查询操作。本节讨论这些操作，并且说明**在任何高度为 $h$ 的二叉搜索树上，如何在 $O(h)$ 时间内执行完各个操作**。

## 2.1 查找
我们使用下面的过程，在一棵二叉搜索树中查找一个具有给定关键字的结点。输入一个指向树根的指针和一个关键字 $k$ ，如果这个结点存在，`TREE-SEARCH` 返回一个指向关键字为 $k$ 的结点的指针；否则返回 `NULL` 。
```cpp
TREE-SEARCH(x, k)
	if x == NULL or k == x.key
		return x
	if k < x.key
		return TREE-SEARCH(x.left, k)
	else
		return TREE-SEARCH(x.right, k)
```
这个过程从树根开始查找，并沿着这棵树的一条简单路径向下进行，如图12-2所示。对于遇到的每个结点 $x$ ，比较关键字 $k$ 与 $x.key$ 。如果两个关键字相等，查找就终止。如果 $k$ 小于 $x.key$ ，查找在 $x$ 的左子树中继续，因为二叉搜索树性质蕴含了 $k$ 不可能被存储在右子树中。对称地，如果 $k$ 大于 $x.key$ ，查找在右子树中继续。从树根开始递归期间遇到的结点、就形成了一条向下的简单路径，所以 `TREE-SEARCH` 的运行时间为 $O(h)$ ，其中 $h$ 是这棵树的高度。
![在这里插入图片描述](https://img-blog.csdnimg.cn/bb3c537d8a6a45e285d89677e87ad494.png)
我们可以采用 while 循环来展开递归，用一种迭代方式重写这个过程。对于大多数计算机，迭代版本的效率要高得多。
```cpp
ITERATIVE-TREE-SEARCH(x, k)
	while x != NULL and k != x.key
		if k < x.key
			x = x.left
		else x = x.right
	return x
```
## 2.2 最大关键字元素和最小关键字元素
通过从树根开始、沿着 $left$ 孩子指针、直到遇到一个 `NULL` ，我们总能在一棵二叉搜索树中找到一个元素，如图12-2所示。下面的过程返回了一个指向「在以给定结点 $x$ 为根的子树中」最小元素的指针，这里假设不为 `NULL` ：
```cpp
TREE-MINIMUM(x)
	while x.left != NULL
		x = x.left
	return x
```
二叉搜索树性质保证了 `TREE-MINIMUM` 是正确的。如果结点 $x$ 没有左子树，那么由于 $x$ 右子树中的每个关键字都至少大于等于 $x.key$ ，则以 $x$ 为根的子树中的最小关键字是 $x.key$ 。如果结点 $x$ 有左子树，那么由于其右子树中没有关键字小于 $x.key$ ，且在左子树中的每个关键字不大于 $x.key$ ，则以 $x$ 为根的子树中的最小关键字一定在以 $x.left$ 为根的子树中。

`TREE-MAXIMUM` 的伪码是对称的，如下：
```cpp
while x.right != NULL
	x = x.right
return x
```
这两个过程在一棵高度为 $h$ 的树上均能在 $O(h)$ 时间内执行完，因为与 `TREE-SEARCH` 一样，它们所遇到的结点均形成了一条从树根向下的简单路径。

## 2.3 后继和前驱
给定一棵二叉搜索树中的一个结点，有时候需要按中序遍历的次序查找它的后继。如果所有的关键字互不相同，则一个结点 $x$ 的后继是大于 $x.key$ 的最小关键字的结点。一棵二叉搜索树的结构，允许我们通过没有任何关键字的比较来确定一个结点的后继。如果后继存在，下面的过程将返回一棵二叉搜索树中的结点 $x$ 的后继；如果 $x$ 是这棵树中的最大关键字，则返回 `NULL` 。
```cpp
TREE-SUCCESSOR(x)
	if x.right != NULL
		return TREE-MINIMUM(x.right)
	y = x.p
	while y != NULL and x == y.right
		x = y
		y = y.p
	return y
```
把 `TREE-SUCCESSOR` 的伪代码分为两种情况。如果结点 $x$ 的右子树非空，那么 $x$ 的后继恰好是 $x$ 右子树中的最左结点，通过第二行的 `TREE-MINIMUM(x.right)` 调用可以找到。例如，在图12-2中，关键字为 $15$ 的结点的后继是关键字为 $17$ 的结点。

另一方面（如算导练习12.2-6所做的），==如果结点 $x$ 的右子树为空，并且 $x$ 有一个后继 $y$ ，那么 $y$ 是 $x$ 的最低层祖先，满足 $y$ 的左孩子也是 $x$ 的一个祖先== `y is the lowest ancestor of x whose left child is also an ancestor of x` ，在图12-2中，关键字为 $13$ 的结点的后继是关键字为 $15$ 的结点。==为了找到 $y$ ，只需简单地从 $x$ 开始沿树而上、直到遇到一个「是其父结点的左孩子的结点」==。`TREE-SUCCESSOR` 中的第三至七行正是处理这种情况。

在一棵高度为 $h$ 的树上，`TREE-SUCCESSOR` 的运行时间为 $O(h)$ ，因为该过程或者遵从一条简单路径沿树向上、或者遵从简单路径沿树向下。过程 `TREE-PREDECESSOR` 与 `TREE-SUCCESSOR` 是对称的，其运行时间也为 $O(h)$ 。

即使关键字非全不相同，我们仍然定义：任何结点 $x$ 的后继和前驱为分别调用 `TREE-SUCCESSOR(x)` 和 `TREE-PREDECESSOR(x)` 所返回的结点。

总之，我们已经证明了下面的定理。

**定理12.2** 在一棵高度为 $h$ 的二叉搜索树上，动态集合上的操作 `SEARCH, MINIMUM, MAXIMUM, SUCCESSOR, PREDECESSOR` 可以在 $O(h)$ 时间内完成。$\blacksquare$


---
# 3. 插入和删除
插入和删除操作会引起「由二叉搜索树表示的动态集合」的变化。一定要修改数据结构来反映这个变化，但修改要保持二叉搜索树性质的成立。正如下面将看到的，插入一个新结点带来的树修改要相对简单些，而删除的处理有些复杂。
## 3.1 插入
要将一个新值 $v$ 插入到一棵二叉搜索树 $T$ 中，需要调用过程 `TREE-INSERT` 。该过程以结点 $z$ 作为输入，其中 `z.key = v, z.left = z.right = NULL` 。这个过程要修改 $T$ 和 $z$ 的某些属性、来把 $z$ 插入到树中相应位置上。
```cpp
TREE-INSERT(T, z)
	y = NULL
	x = T.root
	while x != NULL
		y = x
		if z.key < x.key
			x = x.left
		else x = x.right
	z.p = y
	if y == NULL
		T.root = z // tree T was empty
	else if z.key < y.key
		y.left = z
	else y.right = z
```
图12-3显示了 `TREE-INSERT` 是如何工作的。正如过程 `TREE-SEARCH, ITERATIVE-TREE-SEARCH` 一样，`TREE-INSERT` 从树根开始，指针 $x$ 寻找一条向下的简单路径，并查找要用输入项 $z$ 加以替换的一个 `NULL` 。该过程保持**尾随指针** `trailing pointer` $y$ 作为 $x$ 的双亲。初始化后，第 $3 \sim 7$ 行的 while 循环使得这两个指针沿树向下移动，向左或向右移动取决于 $z.key$ 和 $x.key$ 的比较，直到 $x$ 变为 `NULL` ，这个 `NULL` 占据的位置就是输入项 $z$ 要放置的地方。我们需要尾随指针 $y$ ，这是因为找到 `NULL` 时要知道 $z$ 属于哪个结点的孩子。第 $8 \sim 13$ 行设置相应的指针，将 $z$ 插入树中。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f46d9ab5e0664ab79464890ff2457551.png)
与其他搜索树上的 `primitive operations` 一样，过程 `TREE-INSERT` 在一棵高度为 $h$ 的树上的运行时间为 $O(h)$ 。

---
## 3.2 删除
从一棵二叉搜索树 $T$ 中删除一个结点 $z$ 的整个策略分为三种基本情况（如下所示），但只有一种情况有点棘手：
- 如果 $z$ 没有孩子结点，那么只是简单地将它删除，并修改它的父结点，用 `NULL` 作为孩子来替换 $z$ 。
- 如果 $z$ 只有一个孩子，那么将这个孩子提升到树中 $z$ 的位置上，并修改 $z$ 的父结点，用 $z$ 的孩子来替换 $z$ 。
- 如果 $z$ 有两个孩子，那么找 $z$ 的后继 $y$（一定在 $z$ 的右子树中），并让 $y$ 占据树中 $z$ 的位置，$z$ 的原右子树部分成为 $y$ 的新的右子树，并且 $z$ 的左子树成为 $y$ 的新的左子树。这种情况稍显麻烦（如下所述），因为**还与 $y$ 是否为 $z$ 的右孩子相关**。

从一棵二叉搜索树 $T$ 中删除一个给定的结点 $z$ ，这个过程取指向 $T$ 和 $z$ 的指针作为输入参数。考虑在图12-4中显示的四种情况，它与前面概括出的三种情况有些不同：
- 如果 $z$ 没有左孩子（图12-4(a)），那么用其右孩子来替换 $z$ ，这个右孩子可以是 `NULL` ，也可以不是。当 $z$ 的右孩子是 `NULL` 时，此时这种情况归为 $z$ 没有孩子结点的情形。当 $z$ 的右孩子非 `NULL` 时，这种情况归为 $z$ 仅有一个孩子结点的情形，该孩子是其右孩子。
- 如果 $z$ 仅有一个孩子、且为其左孩子（图12-4(b)），那么用其左孩子替换 $z$ 。
- 否则，$z$ 既有一个左孩子又有一个右孩子。我们要查找 $z$ 的后继 $y$ ，这个后继位于 $z$ 的右子树中并且没有左孩子（见算导练习12.2-5）。现在需要将 $y$ 移出原来的位置进行拼接，并替换树中的 $z$ 。
	- 如果 $y$ 是 $z$ 的右孩子（图12-4 c)），那么**用 $y$ 替换 $z$ ，并仅留下 $y$ 的右孩子**。
	- 否则，$y$ 位于 $z$ 的右子树中、但并不是 $z$ 的右孩子（图12-4(d)）。在这种情况下，**先用 $y$ 的右孩子替换 $y$ ，然后再用 $y$ 替换 $z$** 。
![在这里插入图片描述](https://img-blog.csdnimg.cn/4596cbcc14d74c2cbf4d895af7ce3f22.png)

为了在二叉搜索树中移动子树，我们定义一个子过程 `TRANSPLANT` ，它是用另一棵子树来替换一棵子树、并成为其父结点的孩子结点。当 `TRANSPLANT` 用一棵以 $v$ 为根的子树来替换一棵以 $u$ 为根的子树时，结点 $u$ 的父结点就成为结点 $v$ 的父结点，并且最后 $v$ 成为 $u$ 的父结点的相应孩子。
```cpp
TRANSPLANT(T, u, v)
	if u.p == NULL
		T.root = v
	else if u == u.p.left
		u.p.left = v
	else u.p.right = v
	if v != NULL
		v.p = u.p
```
第 $1 \sim 2$ 行处理 $u$ 是 $T$ 的树根的情况。否则，$u$ 是其双亲的左孩子或右孩子。如果 $u$ 是一个左孩子，则第 $3 \sim 4$ 行负责 $u.p.left$ 的更新；如果 $u$ 是一个右孩子，第 $5$ 行更新 $u.p.right$ 。我们允许 $v$ 为 `NULL` ，如果 $v$ 为非 `NULL` 时，第 $6 \sim 7$ 行更新 $v.p$ 。注意到，**`TRANSPLANT` 并没有处理 $v.left, v.right$ 的更新，这些更新都由 `TRANSPLANT` 的调用者来负责**。

利用现有的 `TRANSPLANT` 过程，下面是从二叉搜索树 $T$ 中删除结点 $z$ 的删除过程：
```cpp
TREE-DELETE(T, z)
	if z.left == NULL
		TRANSPLANT(T, z, z.right)
	else if z.right == NULL
		TRANSPLANT(T, z, z.left)
	else y = TREE-MINIMUM(z.right)
		if y.p != z
			TRANSPLANT(T, y, y.right)
			y.right = z.right
			y.right.p = y
		TRANSPLANT(T, z, y)
		y.left = z.left
		y.left.p = y
```
`TREE-DELETE` 过程处理四种情况如下。
- 第 $1 \sim 2$ 行处理结点 $z$ 没有左孩子的情况。
- 第 $3 \sim 4$ 行处理结点 $z$ 有一个左孩子、但没有右孩子的情况。
- 第 $5 \sim 12$ 行处理剩下的两种情况，也就是 $z$ 有两个孩子的情形。第 $5$ 行查找结点 $y$ ，它是 $z$ 的后继。因为 $z$ 的右子树非空，这样后继一定是这个子树中具有最小关键字的结点，因此就调用 `TREE-MINIMUM(z.right)` 。如前所述，$y$ 没有左孩子。将 $y$ 移出它原来的位置进行拼接，并替换树中的 $z$ 。
	- 如果 $y$ 是 $z$ 的右孩子，则第 $10 \sim 12$ 行用 $y$ 替换 $z$ 、并成为 $z$ 的双亲的一个孩子，$y$ 的左指针（原为空）指向 $z$ 的左孩子。
	- 如果 $y$ 不是 $z$ 的右孩子，则第 $7 \sim 9$ 行用 $y$ 的右孩子替换 $y$ 、并成为 $y$ 的双亲的一个孩子，然后将 $z$ 的右孩子转变为 $y$ 的右孩子，最后第 $10 \sim 12$ 行用 $y$ 替换 $z$ 、并成为 $z$ 的双亲的一个孩子，$y$ 的左指针（原为空）指向 $z$ 的左孩子。

除了第 $5$ 行调用 `TREE-MINIMUM` 之外，`TREE-DELETE` 的每一行，包括调用 `TRANSPLANT` ，都只花费常数时间。因此，在一棵高度为 $h$ 的二叉搜索树上，`TREE-DELETE` 的运行时间为 $O(h)$ 。

总之，我们证明了下面的定理。

**定理12.3** 在一棵高度为 $h$ 的二叉搜索树上，实现动态集合操作 `INSERT` 和 `DELETE` 的运行时间均为 $O(h)$ 。$\blacksquare$ 

---
# 4. 随机构建二叉搜索树
我们已经证明了，二叉搜索树的每个基本操作都能在 $O(h)$ 时间内完成，其中 $h$ 为这棵树的高度。然而，随着元素的插入和删除，二叉搜索树的高度是变化的。例如，如果 $n$ 个关键字按严格递增的次序被插入，则这棵树一定是高度为 $n - 1$ 的一条链（另外，算导练习B.5-4说明了 $h \ge \lfloor \log n \rfloor$ ）。和快速排序一样，我们可以证明**其平均情形性能更接近于最好情形、而不是最坏情形时的性能**。

遗憾的是，当一棵二叉搜索树同时由插入和删除操作生成时，我们对这棵树的平均高度了解甚少。当树是由插入操作单独生成时，分析就会变得容易得多。因此，我们定义 $n$ 个关键字的一棵**随机构建二叉搜索树** `randomly built binary search tree` 为「按随机次序插入这些关键字到一棵初始的空树中而生成的树」，这里**输入关键字的 $n!$ 个排列中的每个都是等可能地出现**（算导练习12.4-3要求证明，这个概念与假定**每棵含有 $n$ 个关键字的二叉搜索树为等可能**的概念不同）。接下来，这里要证明下面的定理。

**定理12.4** 一棵有 $n$ 个不同关键字的随机构建二叉搜索树的期望高度为 $O(\log n)$ 。
**证明**：从定义三个随机变量开始，这些随机变量有助于度量一棵随机构建二叉搜索树。
- 用 $X_n$ 表示一棵有 $n$ 个不同关键字的随机构建二叉搜索树的高度，并定义**指数高度** `exponential height` $Y_n = 2^{X_n}$ 。
- 当构造一棵有 $n$ 个关键字的二叉搜索树时，选择一个关键字作为树根，并设 $R_n$ 为一个随机变量，表示这个关键字在 $n$ 个关键字集合中的**秩** `rank` ，即 $R_n$ 代表的是这些关键字排好序后、这个关键字应占据的位置。**$R_n$ 的值等可能地为集合 $\{ 1, 2, \dots, n\}$ 中的任一元素**。如果 $R_n = i$ ，那么根的左子树是一棵有 $i - 1$ 个关键字的随机构建二叉搜索树，并且右子树是一棵有 $n - i$ 个关键字的随机构建二叉搜索树。
- 因为二叉树的高度比根的两棵子树较高的那棵子树大 $1$ ，因此二叉树的指数高度是根的两棵子树较高的那棵子树的 $2$ 倍。如果 $R_n = i$ ，则有：$$Y_n = 2\cdot \max (Y_{i - 1}, Y_{n - i})$$ 作为基础情况，设 $Y_1 = 1$ ，因为一个结点的树的指数高度为 $2^0 = 1$ ，为了方便起见，我们定义 $Y_0  =0$ 。

接下来，定义指示器随机变量 $Z_{n, 1}, Z_{n,2}, \dots, Z_{n, n}$ ，其中 $Z_{n, i}  = I(R_n = i)$ 。因为 $R_n$ 取集合 $\{ 1, 2, \dots , n \}$ 中的任何元素都是等可能的，即有 $Pr( R_n = i) = 1/n\ (i = 1, 2, \dots, n)$ ，所以由**引理5.1**，有：$$E[Z_{n , i } ] = 1/ n\tag{12.1}\ (i = 1, 2, \dots, n)$$ 由于 $Z_{n , i}$ 恰有一个值为 $1$ 、其余所有的值为 $0$ ，因此有：$$Y_n = \sum^n_{i=1} Z_{n, i} (2 \cdot \max(Y_{i-1}, Y_{n-i}))$$ 下面将证明 $E[Y_n]$ 是 $n$ 的一个多项式，由此最终推出 $E[X_n] = O(\log n)$ 。

指示器随机变量 $Z_{n, i} = I( R_n = i)$ 独立于 $Y_{i-1}$ 和 $Y_{n-i}$ 的值。已经选择了 $R_n = i$ ，左子树（其指数高度为 $Y_{i-1}$ ）是由 $i - 1$ 个关键字随机构建的，**其每个元素的秩都小于 $i$** 。这棵子树就像任何其他由 $i - 1$ 个关键字随机构建的二叉搜索树一样。除了所包含的关键字数目之外，这棵子树的结构完全不受 $R_n = i$ 选择的影响，因此随机变量 $Y_{i-1}$ 和 $Z_{n, i}$ 是独立的。同样，右子树（其指数高度是 $Y_{n-i}$ ）是由 $n - i$ 个关键字随机构建的，**其每个元素的秩都大于 $i$** 。它的结构独立于 $R_n$ 的值，因此随机变量 $Y_{n-i}$ 和 $Z_{n, i}$ 是独立的。所以，有：
$$\begin{aligned}
E[Y_n] &= E \bigg [ \sum^n_{i =1} Z_{n, i} (2 \cdot \max(Y_{i-1}, Y_{n-i})) \bigg ] \\
&= \sum^n_{i=1} E[ Z_{n,i} ( 2 \cdot \max (Y_{i-1}, Y_{n-i})) ] \quad &由期望的线性性质 \\
&= \sum^n_{i=1} E [ Z_{n,i} ]\ E[2 \cdot \max (Y_{i-1}, Y_{n - i} ) ] \quad &由独立性 \\
&= \sum^n_{i=1} \dfrac{1}{n} \cdot E [2 \cdot \max (Y_{i-1}, Y_{n-i}) ] \quad &由式(12.1) \\
&= \dfrac{2}{n} \sum^n_{i=1} E [ \max (Y_{i-1}, Y_{n - i}) ]  \quad &由式(\textrm{C.22}) \\
&\le \dfrac{2}{n} \sum^n_{i=1} (E[Y_{i-1} ] + E[Y_{n-i} ]) \quad &由算导练习\textrm{C.3-4}
\end{aligned}$$

在上面最后一个和式中，因为 $E[Y_0], E[Y_1], \dots, E[Y_{n-1}]$ 中每一项都出现两次，一次作为 $E[Y_{i-1}]$ ，另一次作为 $E[Y_{n - i}]$ 。所以有下面的递归式：$$E[Y_n] \le \dfrac{4}{n} \sum^{n-1}_{i=0} E[Y_i] \tag{12.2}$$ 使用替换法（代入法），下面证明对于所有的正整数 $n$ ，递归式 $(12.2)$ 有解：$$E[Y_n] \le \dfrac{1}{4} \begin{pmatrix}
n + 3 \\
3 \end{pmatrix}$$ 

在求解过程中，将使用下面的等式（算导练习12.4-1要求证明这个等式）：$$\sum^{n-1}_{i=0} 
\begin{pmatrix} i+3 \\ 
3 \end{pmatrix} = 
\begin{pmatrix} n + 3 \\
4 \end{pmatrix} \tag{12.3}$$

对于基础情况，注意到两个界 $0 = Y_0 = E[Y_0] \le \dfrac{1}{4} \begin{pmatrix} 3 \\ 3 \end{pmatrix} = \dfrac{1}{4}$ 和 $1 = Y_1 = E[Y_1] \le \dfrac{1}{4} \begin{pmatrix} 1 +3 \\ 3 \end{pmatrix} = 1$ 成立。对于归纳情况，有：$$\begin{aligned}
E[Y_n]\ &\le \ \dfrac{4}{n} \sum^{n-1}_{i=0} E[Y_i]\ \le \ \dfrac{4}{n} \sum^{n-1}_{i=0} \dfrac{1}{4} \begin{pmatrix} i + 3 \\ 3 \end{pmatrix} \quad &由归纳假设 \\ 
&= \dfrac{1}{n} \sum^{n-1}_{i=0} \begin{pmatrix} i + 3 \\ 3 \end{pmatrix} = \dfrac{1}{n} \begin{pmatrix} n + 3 \\ 4 \end{pmatrix} \quad &由式(12.3) \\
&= \dfrac{1}{n} \cdot \dfrac { (n + 3) !} { 4 !\ (n - 1)! } = \dfrac{1}{4} \cdot \dfrac { (n + 3) !} { 3!\ n!} = \dfrac{1}{4} \begin{pmatrix} n + 3 \\ 3 \end{pmatrix}
\end{aligned}$$

虽然我们有了 $E[Y_n]$ 界，但最终的目标是要得到 $E[X_n]$ 的界。（正如算导练习12.4-4要求证明函数 $f(x) = 2^x$ 是凸的）。因此，应用 *Jensen* 不等式 $(\textrm{C.26})$ ，也就有：
$$2^{ E[X_n] } \le E[2^{X_n }]  = E[Y_n]$$ 如下可得：$$2^{ E[X_n] } \le \dfrac{1}{4} \begin{pmatrix} n + 3 \\ 3 \end{pmatrix} = \dfrac{1}{4} \cdot \dfrac{ (n + 3) (n+2) (n + 1) } { 6} = \dfrac{ n^3 + 6n^2 + 11n+6}{24} $$

两边取对数，得到 $E[X_n] = O(\log n)$ 。$\blacksquare$ 


