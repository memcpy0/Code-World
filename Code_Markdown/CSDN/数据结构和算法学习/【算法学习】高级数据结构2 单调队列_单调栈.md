@[toc]

今天讲一个应用起来很复杂但是概念很简单的算法——单调队列/栈。这两个算法虽然出现的频率不高，但是在某些问题上面，往往可以起到出其不意的作用——**单调性优化**经常会在动态规划的题目中出现。因此，我们需要掌握单调队列/栈的使用。

----
# 1. 引言
下面有几个关于队列和栈的概念：
- 队列 `Queue` ：先进先出的数据结构；
- 优先队列 `Priority Queue` ：每个元素都有一个优先级，优先级高的元素进队时可以插队，可以优先出队；
- 栈 `Stack` ：后进先出的数据结构。

---
# 2. 单调队列
## (1) 基本性质
 单调队列 `Monotone Priority Queue` ：队列始终满足从队首开始，**优先级递减**（和优先队列一样）；**进队时间越晚越靠后，越早越靠前**（和普通队列一样）。比如说：
```
8 6 4 3 2   //单调队列, 之后来了一个5, 如何继续满足上述两条规则？
//直接插到队尾吗？就不满足优先级递减的规则;
//移动到适当的位置吗？不满足越靠后越晚的规则
```
真正的做法是，新元素进队时，**将前面优先级低于自己的直接踢出队**。
 ```
8 6 5  //两条规则都满足了：越靠后的元素来的越晚，优先级越低
```
这样做一定正确吗？事实上，**只有前面剔除的元素不存在正确答案时**，才能够使用单调队列。比如说多重背包时就可以使用单调队列，优化复杂度到 $\text{O(nv)}$ 。

总的来说，<b><font size="3" color="red">单调队列是普通队列和优先队列的结合体，是优先队列的改良。</font></b> 
- 基本思想：同样维护队首元素作为答案；去掉多余的元素(维护单调性)；
- 队列中的每个元素用一个二元组 `(id, val)` 表示，每次从队尾入队，删除队尾的无用元素，**保证随着编号递增，优先级递减**；即下表满足 $A_{i-1} < A_i < A_{i+1}$ 并且 $B_{i-1} > B_i > B_{i+1}$ ：

	|   | L | L + 1 | ... | R - 1 | R
	|:--:|:--:|:--:|:--:|:--:|:--
	| `id` | $A_L$| $A_{L+1}$| ... | $A_{R-1}$ | ${A_R}$ 
	| `val` | $B_L$ | $B_{L+1}$ |...| $B_{R-1}$ | $B_R$

在实际代码中，单调队列可以用数组模拟，或者用STL的 `deque` 。


## (2) 单调队列模板题
给出 `N` 个数，求每连续 `K` 个数的最小值。此处 `K= 3` 。相当于用一个固定长度的窗口在数组中从左到右移动，找到窗口在每个覆盖区间中的最小值(最大值也可以)。
#样例输入：
```
1 4 7 5 3 6 9 8 2
```
#样例输出：
```
1 4 3 3 3 6 2
```

每一个区间分别去找最值，是暴力求解 $\text{O(nk)}$，但是用单调队列可以达到 $\text{O(n)}$。为什么可以这样优化呢？可以看到，上面的示例中，$3$ 出现了多次，因此，对涉及到 $3$ 的多个区间反复求解，是一种时间的浪费。甚至可以说，**移动窗口纳入新的元素时，又要和前面 `K-1` 个数重复比较，太浪费时间了。**

使用优先队列，可以初步优化，达到 $\text{O(nlogn)}$ 。窗口往右移，就把一个数放进优先队列，每次取队首元素——如果队首元素超出窗口，出队，继续看队首元素；否则直接使用队首元素。

继续优化，使用单调队列，==核心思想：高效排除不可能成为答案的数字；或者说，高效保留可能成为答案的数字==。注意，**此处的优先级是数字的大小**，越小优先级越高，所以，后来的数字小于前面的数字，则前面的数字不可能再成为答案。
- **每个数字进队时，踢出前面比自己大(优先级低)的数字**，就能够满足优先级往后递减、越晚越靠后的规则。然后**始终取队首的数字作为答案**，此时队首的数字优先级最高，数字最小。
- 但是，我们需要注意到一个问题，举一个例子，一个数组递增排序 `1,2,3,4,5` ，$1$ 会一直保留，因此输出全是 $1$ ，不符合题意。
- 我们需要**另外开一个数组记录队中数字在原数组的下标，队首数字太老就出队**。

以 `1 4 7 5 3 6 9 8 2` 为例，算法执行过程如下：
```
[1,1] :      (1,1)
[1,2] :      (1,1) (2,4)
[1,3] :	  	 (1,1) (2,4) (3,7) //输出1
[2.4] :		 (2,4) (4,5)       //踢出(3,7), (1,1)出队, 输出4
[3,5] :      (5,3)             //踢出(2,4) (4,5), 输出3
[4,6] :      (5,3) (6,6)       //输出3
[5,7] :      (5,3) (6,6) (7,9) //输出3
[6,8] :      (6,6) (8,8) 	   //踢出(7,9), (5,3)出队, 输出6
[7,9] : 	 (9,2)             //踢出(6,6) (8,8), 输出2
```
代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

int N, K, data[10001], que[10001], idx[10001];
int front = 1, rear = 0; //队首队尾, 队尾为0, 队首为1

int main() {
	cin >> N >> K;
	for (int i = 1; i <= N; ++i) cin >> data[i];
	for (int i = 1; i <= N; ++i) {
		//i=1~N的过程中, 下面的while循环总共最多运行n次, 为O(n), 因为一个元素只能进一次队, 进队后不可能出队多次
		while (front <= rear && data[i] < que[rear]) --rear; //非空时, 新元素<队尾元素, 剔除队尾元素
		que[++rear] = data[i]; //新元素进入合适位置
		idx[rear] = i; 		   //队列中rear位置的元素在原数组的下标
		if（idx[front] + k <= i) ++front; //队首元素超出区间, 出队
		if (i >= K) cout << que[front] << ' '; //i>=K时每到下一步就输出一个答案
	}
	return 0;
}
```
---
## (3) DP中的优化作用——单调队列优化多重背包
> 可以被优化的DP，形如：
$$\text{f[i] = min(f[i]\ |\ low[i] <= j <=  up[i]) + a[i]}$$
其中，`low[i]` 和 `up[i]` 是关于 `i` 的单调不下降函数。

多重北方问题：给定 $n$ 种物品和一个背包，第 $i$ 种物品的价值为 $w_i$ ，其体积为 $V_i$ ，数量是 $K_i$ 件，背包的容量是 $C$ 。可以任意选择装入背包中的物品，求装入背包中物品的最大总价值。

### a. 当做0-1背包
$O(C * \sum K_i)$。$K_i$ 物品，$K_i$ 个背包。

### b. 二进制拆分
$O(n * C * logC)$
### c. 单调队列优化
$O(n*C)$


---

# 3. 单调栈
单调栈也是一个栈，不过**栈内元素保证单调性**。即，栈内元素要么从小到大，要么从大到小。而单调栈维护的就是一个数前/后第一个大于/小于它的数(的下标)。

## (1) 基本性质
## (2) 简单应用

---
# 4. 应用题目
[洛谷 P5788 【模板】单调栈](https://www.luogu.com.cn/problem/P5788)
[洛谷 P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)
视野总和
直方图中最大的矩形
      lucky52529的博客，自查第一题。
https://blog.csdn.net/lucky52529/article/details/89155694 
 我们很容易想到构造一个单调递增栈，如果遇到大于栈顶的元素，开始更新之前不高于当前人所能看到的值即可。

 但是我们发现我们 WA 了，因为遗留在栈里面的人还没有计算贡献。我们于是用结束标识符，这里是极大值，想象一个无限高的人站在最右边，那么我们所有人都能出栈，不会漏掉。
代码

```cpp
#include<cstdio>
#include<stack>
#include<algorithm>
#define mp make_pair
using namespace std;
stack<long long> S;
long long a[5000005],ans;
int main(){
	long long n;
	scanf("%lld",&n);
	for(long long i=1;i<=n;++i)	scanf("%lld",&a[i]);
	a[n+1]=10086001100860011ll;//结束标识符
	for(long long i=1;i<=n+1;++i)
	{
		if(S.empty() || a[S.top()]>=a[i])	S.push(i);
		else
		{
			while(S.size() && a[S.top()]<a[i])
			{
				long long Top=S.top();
				ans+=(i-Top-1);
				S.pop();
			}
			S.push(i);
		}
	}
	printf("%lld",ans);
	return 0;
}
```

直方图中最大的矩形

 lucky52529的博客，自查第二题。

 上面都是用的单调递增栈，这次我们用单调递减栈。我们每次将元素从栈里面弹出的时候，因为我们的答案可能会出现在里面，所以我们弹出元素就计算一遍答案。
代码

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<stack>
#include<queue>
using namespace std;
long long a[100005],n;
stack<long long> S;
void debug()
{
	stack<long long> tmp=S;
	while(tmp.size())	printf("%lld ",tmp.top()),tmp.pop();
	puts("");
}
void Clear()
{
	stack<long long> tmp;
	S=tmp;
}
int main(){
	while(scanf("%lld",&n) && n)
	{
		Clear();
		long long ans=0;
		for(long long i=1;i<=n;++i)	scanf("%lld",&a[i]);
		a[n+1]=-2147483647;
		for(long long i=1;i<=n+1;++i)
		{
			if(S.empty() || a[S.top()]<=a[i])	S.push(i);
			else
			{
				long long Top=0;
				while(S.size() && a[S.top()]>a[i])
				{
//					debug();
					Top=S.top();
					ans=max(ans,(i-Top)*a[Top]);
					S.pop();
				}
				a[Top]=a[i];//why?
				S.push(Top);
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

 发现我在 a[Top]=a[i]; 这个语句后打了个 //why?。这是为什么呢？

 我们弹出元素计算答案，相信大家都能够理解。但是为什么要更改我们的 aaa 数组呢？

 举个例子：2,3,12,3,12,3,1。

  思考一下，我们要维持它单调，假设加入 333 这个元素的时候栈只有它一个元素。我们的 toptoptop 会从 111 变成 333。但是 1,21,21,2 两个元素对应的值都比它大。但是我们为了保持栈中的递增属性，并且可以让向左拓展，我们索性修改了 iii 的下标，将他修改为最左边的 toptoptop 下标，所以当我们下次需要以他为基准获取矩形面积。
