@[toc]

计算机的各种运算归根到底就是一个个 `bit` 的变化。熟练使用位运算，能够**提高程序运行的时空效率，降低编程复杂度**。

---
# 1. 位运算
下面的位运算是几乎所有编程语言都会提供的：

| 与 | 或 | 非 | 异或 |
|:--|:--|:---|:----
| `and, &` | `or, |` | `not, ~` | `xor, ^` |

另外，在 $m$ 位二进制数中，为方便起见，常称最低位为第 $0$ 位，从右到左依此类推，最高位为第 $m - 1$ 位。

# 2. 补码
这里以C++的 `int, unsigned int` 类型为例，介绍计算机中的整数存储和计算。
- 32位无符号整数 `unsigned int` ：直接把32位编码 $C$ 看做32位二进制数 $N$ 。
- 32位有符号整数 `int` ：以最高位为符号位，$0$ 表示非负数，$1$ 表示负数。对于最高位为 $0$ 的每个编码 $C$ ，直接看做二进制数 $S$ ，同时定义该编码按位取反后得到的编码 $\sim C$ 表示的数值为 $-1 - S$ ，于是 $-S = C + 1$（补码或者二补数）。
	| 32位补码表示 | `unsigned int` | `int` |
	|:---|:---|:---|
	| $000000\dots000000$ | $0$ | $0$ |
	| $011111\dots111111$ | $2147483647$ | $2147483647$ |
	| $100000\dots000000$ | $2147483648$ | $-2147483648$ |
	| $111111\dots111111$ | $4294967295$ | $-1$ |
 	易知，补码下每个数值表示方式唯一，且任意两个数值做加减法运算，都等价于在32位补码下做**最高位不进位**的二进制加减运算。如果溢出则32位无符号整数相当于自动对 $2^{32}$ 取模，有符号整数算术上溢时出现负数也归结于此。

此外，还有一种编码是反码（一补数），直接把 $C$ 的每一位取反表示 $-C = \sim C$ 。补码和反码在负数表示时，绝对值相差一。补码之所以能够**作为整数编码、存储和运算的普遍方式**，优势在于：**自然溢出取模**；**解决了零的编码唯一性问题**；比反码多表示一个数；减少特殊判断，方便电路设计。
| 形式 | 加数 | 加数 | 和 |
|:---|:---|:---|:---
| 32位补码 | $111\dots111$ | $000\dots001$ | $\sout{(1)}000\dots000$ |
| `int` |$-1$ | $1$ | $0$ |
| `unsigned int` | $4294967295$ | $1$ | $0 (\bmod\ 2^{32})$ |
| 32位补码 | $011\dots111$ | $000\dots001$ | $100\dots000$ |
| `int` |  $2147483647$ | $1$ | $-2147483648$ |
| `unsigned int` | $2147483647$ | $1$ | $2147483648$ |


因为二进制表示太长了，所以常用十六进制表示一个常数，这样也能**体现出补码的每一位**。C++的十六进制常数以 `0x` 开头，`0x` 本身只是声明进制，后面的部分才对应具体的十六进制数值：
| 32位补码表示 | 十进制`int` | 十六进制 |
|:---|:---|:---|
| $000000\dots000000$ | $0$ | $0x0$ |
| $011111\dots111111$ | $2147483647$ | $0x7\text{FFFFFFF}$ |
| $00111111$ 重复八次 | $1061109567$ | $0x3\text{F3F3F3F}$ |
| $100000\dots000000$ | $-2147483648$ | $0x80000000$ |
| $111111\dots111111$ | $-1$ | $0x\text{FFFFFFFF}$ |

其中的 $0x\text{3F3F3F3F}$ 是一个很有用的数：
- 整数的两倍不超过 `INT_MAX` 即 $\text{0x7FFFFFFF}$ ；
- 整数的每 $8$ 位（每个字节）都是相同的。
- 使用 `memset(a, val, sizeof(a))` 初始化一个整型数组 `a` 时，会把数值 `val (0x00 ~ 0xFF)` 填充到数组 `a` 的每个字节上，而一个 `int` 占四个字节，所以 `memset` 只能赋值出每八位都相同的 `int` 。这样 $0x\text{7F7F7F7F}$ 就成了 `memset` 语句能够初始化出的最大数值。
- 经常碰到需要将一个数组中的数值初始化为正无穷的时候，这时为了避免加法算术上溢或者繁琐的判断，会使用 `memset(a, 0x3f, sizeof(a))` 给数组赋 $0x\text{3F3F3F3F}$ 的值来代替。

---
# 3. 移位运算
有几种移位运算：
- 左移：在二进制表示下把数字同时向左移动，低位以 $0$ 填充，高位越界后舍弃：$$1\ \text{<<}\ n = 2^n,\ n\ \text{<<}\ 1= 2n$$
- 算术右移：在二进制补码表示下，把数字同时向右移动，高位以符号位填充，低位越界后舍弃：$$n\ \text{>>}\ 1 = \lfloor \frac{n}{2.0} \rfloor$$
算术右移的表现相当于**除以 $2$ 向下取整**，$-3\ \text{>>}\ 1 = -2,\ 3\ \text{>>}\ 1 = 1$ 。需要注意的是：`整数 / 2` 在C++中则实现为**除以 $2$ 向零取整**（截断法），因此 $(-3)\ /\ 2 = -1,\ 3\ /\ 2 = 1$ 。留心这一点不同，可以自己试一下（**向下取整和向零取整也带来了取模和取余的区别**）。

- 逻辑右移：在二进制补码表示下，把数字同时向右移动，高位以 $0$ 填充，低位越界后舍弃。

另外，C++没有规定右移的具体实现方式，不过一般的编译器均使用算术右移。除非特殊情况，**以后默认右移操作为算术右移。**

---
# 4. 快速幂和整数乘法
两个使用位运算的例子是[**快速幂**](https://blog.csdn.net/myRealization/article/details/108410952)和**64位整数乘法**。后者即为：求 $a * b \bmod p$ 的值，其中 $1\le a,b,p \le 10^{18}$ ，用于解决快速幂问题中的乘法和取模 (`res = res * base % mod, base = base * base % mod`) ，其变量 `res, base, mod` 都处于 $10^{18}$ 级别可能发生的错误。

## (1) 方法一
方法一类似于快速幂的做法，将整数 $b$ 表示为二进制，即：$$b = c_{k-1}2^{k-1}+c_{k-2}2^{k-2}+\dots+c_02^0$$ 则有 $$a * b = c_{k-1}2^{k-1} * a + c_{k-2}2^{k-2} * a + \dots + c_02^0 * a$$ 举例如：$3 * 7 = 3 * {111_2} = 3 * (4 + 2 + 1) = 3 * 4 + 3 * 2 + 3 * 1$ 。

之后，因为 $a * 2^i = (a * 2^{i - 1}) * 2$ ，如果求出了 $(a * 2^{i - 1}) \bmod p$ ，则计算 $(a * 2^{i - 1}) * 2 \bmod p$ 时，**运算过程中的每一步结果都不会超过 $2*10^{18}$** ，仍处于64位整数 `long long` 的表示范围内（大约为 $10^{19}$）。所以可以通过 $k$ 次**递推倍增**求出每个乘积项，当 $c_i = 1$ 时把该乘积项**累加到答案中**即可，时间复杂度为 $\Theta(\log_2 b)$ 。
```cpp
long long mul(long long a, long long b, long long p) { //快速乘
	long long ans = 0;
	while (b) {
		if (b & 1) ans = (ans + a) % p;
		a = a * 2 % p;
		b >>= 1;
	}
	return ans;
}
```

## (2) 方法二
利用 $a * b \bmod p = a * b - \lfloor a * b\ /\ p\rfloor * p$ ：
- 当 $a, b \lt p$ 时，$a * b\ /\ p$ 下取整以后一定也小于 $p$ 。用浮点数类型 `long double` 执行 $a * b\ /\ p$ 这一运算，然后赋值给 `long long` 变量，截断小数部分取整。注意，浮点类型 `long double` 在十进制下的有效数字为18~19位，足够胜任这一目标。
- 此时 $a*b,\ \lfloor a * b\ /\ p\rfloor * p$ 也可能很大，但它们的差一定处于 $0 \sim p - 1$ 之间，因此只需要关注它们较低的若干位即可。这时使用 `long long` 来保存 $a*b,\ \lfloor a * b\ /\ p\rfloor * p$ 各自的结果，确实可能造成整数溢出，但是这相当于舍弃高位，正好符合我们的需求。
- $a, b \ge p$ 时，$(a * b) \bmod p = ((a \bmod p) * (b \bmod p)) \bmod\ p$ ，转换为上述情况。

代码如下：
```cpp
long long mul(long long a, long long b, long long p) { //a * b % p
	a %= p, b %= p; //a,b一定属于0~p之间时,此行无必要
	long long c = (long double)a * b / p;
	long long ans = a * b - c * p;
	if (ans < 0) ans += p;
	else if (ans >= p) ans -= p;
	return ans;
}
```

---
# 5. 二进制状态压缩
所谓的二进制状态压缩，就是**将一个长度为 $m$ 的 `bool` 数组用一个 $m$ 位二进制整数表示并存储的方法**。下面给出以下位运算，可以实现原 `bool` 数组中对应下标元素的存取：
| 操作 | 运算 |
|:---|:---|
| 取出整数 $n$ 在二进制表示下的第 $k$ 位 | `(n >> k) & 1` 
| 取出整数 $n$ 在二进制表示下的第 $k$ 位代表的值 | `n & (1 << k)` 
| 取出整数 $n$ 在二进制表示下的第 $0 \sim k - 1$ 位 | `n & ((1 << k) - 1)` 
| 把整数 $n$ 在二进制表示下的第 $k$ 位取反 | `n = n xor (1 << k)` 
| 把整数 $n$ 在二进制表示下的第 $k$ 位赋值为 $1$ | `n = n | (1 << k)`
| 把整数 $n$ 在二进制表示下的第 $k$ 位赋值为 $0$  | `n = n & (~(1 << k))`


> 不太相关的，取出整数 $n$ 在二进制表示下最右边的置位比特的值：`n & ~(n - 1) = n & -n` ，这是树状数组中的 `lowbit` 操作 。


当 $m$ 不太大时，可以直接使用一个整数类型存储；当 $m$ 较大时，可以使用若干个整数类型（`int` 数组）；或者直接利用C++ STL提供的 `bitset` 实现。

一个实际的例子是最短Hamilton路径：给定一张 $n (n \le 20)$ 个点的带权无向图，点从 $0 \sim n - 1$ 标号，求起点 $0$ 到终点 $n - 1$ 的最短Hamilton路径（Hamilton路径定义是：从 $0$ 到 $n -1$ 不重不漏地经过每个点恰好一次）。

朴素的做法是枚举 $n$ 个点的全排列，计算路径长度取最小值，时间复杂度为 $O(n * n!)$ 。如果使用二进制状态压缩DP，可以优化到 $O(n^2 * 2^n)$ 。做法如下：
- 任意时刻判断点是否经过：使用一个 $n$ 位二进制数，若第 $i (0\le i \lt n)$ 位为 $1$ ，则表示第 $i$ 个点已被经过，反之则未被经过。
- 任意时刻想要知道当前所在的位置：使用 $F[i, j]\ (0\le i \lt 2^n,\ 0\le j \lt n)$ 表示**点被经过的状态**对应的二进制数为 $i$ ，且目前处于点 $j$ 时的最短路径。
- 在起点时，有 $F[1, 0] = 0$ ，即只经过了点 $0$（ $i$ 只有第 $0$ 位为 $1$ ）

https://leetcode-cn.com/problems/sort-list/

 Weekly Contest 83
https://leetcode-cn.com/contest/weekly-contest-83/

Weekly Contest 84
https://leetcode-cn.com/contest/weekly-contest-84/

第 208 场周赛
https://leetcode-cn.com/contest/weekly-contest-208

https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations/

https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix/

拼题A
https://pintia.cn/problem-sets/994805046380707840/problems/type/7?page=0
