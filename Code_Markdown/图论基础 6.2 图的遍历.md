与树的遍历类似，图的遍历指从图的某一节点出发，按照某种搜索方式对图中的所有节点都仅访问一次。图的遍历可以解决很多搜索问题，实际应用非常广泛。图的遍历根据搜索方式的不同，分为广度优先遍历和深度优先遍历。
## 6.2.1　广度优先遍历
广度优先搜索（Breadth First Search，BFS）又被称为宽度优先搜索，是最常见的图搜索方法之一。广度优先搜索指从某个节点（源点）出发，一次性访问所有未被访问的邻接点，再依次从这些已访问过的邻接点出发，一层一层地访问。如下图所示，广度优先遍历是按照广度优先搜索的方式对图进行遍历的。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112138029.png)

假设源点为1，从1出发访问1的邻接点2、3，从2出发访问4，从3出发访问5，从4出发访问6，访问完毕。访问路径如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112138930.png)

广度优先遍历的秘籍：**先被访问的节点，其邻接点先被访问**。根据广度优先遍历的秘籍，**先来先服务**，这可以借助于队列实现。因为对每个节点只访问一次，所以可以设置一个辅助数组visited[i]=false，表示第i个节点未被访问；$visited[i]=true$ ，表示第i个节点已被访问。
### 1. 算法步骤
（1）初始化所有节点均未被访问，并初始化一个空队列。
（2）从图中的某个节点v出发，访问v并标记其已被访问，将v入队。
（3）如果队列非空，则继续执行，否则算法结束。
（4）将队头元素v出队，依次访问v的所有未被访问的邻接点，标记已被访问并入队。转向步骤3。

### 2. 完美图解
例如，一个有向图如下图所示，其广度优先遍历的过程如下所述。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112139315.png)
（1）初始化所有节点均未被访问，visited[i]=false，i=1,2,…,6。并初始化一个空队列Q。
（2）从节点1出发，标记其已被访问，visited[1]=true，将节点1入队。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112139173.png)

（3）将队头元素1出队，依次访问1的所有未被访问的邻接点2、3，标记其已被访问并将其入队。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112139256.png)

（4）将队头元素2出队，将2的未被访问的邻接点4标记为已被访问，并将其入队。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112140877.png)
（5）将队头元素3出队，3的邻接点2已被访问，将未被访问的邻接点5标记为已被访问，并将其入队。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112140642.png)

（6）将队头元素4出队，4的邻接点3已被访问，将未被访问的邻接点6标记为已被访问，并将其入队。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112140419.png)
（7）将队头元素5出队，5的邻接点4、6均已被访问，没有未被访问的邻接点。（8）将队头元素6出队，6没有邻接点。
（9）队列为空，算法结束。广度优先遍历序列为1 2 3 4 56。
广度优先遍历经过的节点及边，被称为广度优先生成树。如果广度优先遍历非连通图，则每一个连通分量都会产生一棵广度优先生成树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112141085.png)
### 3. 算法实现
（1）基于邻接矩阵的广度优先遍历。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112150318.png)

（2）基于邻接表的广度优先遍历。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112150873.png)

（3）基于非连通图的广度优先遍历。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112151310.png)

### 4. 算法分析
广度优先遍历的过程实质上是对每个节点都搜索其邻接点的过程，图的存储方式不同，其算法复杂度也不同。
（1）基于邻接矩阵的广度优先遍历算法。查找每个节点的邻接点需要O(n)时间，共n个节点，总的时间复杂度为 $O(n^2)$ 。这里使用了一个辅助队列，每个节点只入队一次，空间复杂度为O(n)。
（2）基于邻接表的广度优先遍历算法。查找节点vi的邻接点需要O(d(vi))时间，d(vi)为vi的出度，对有向图而言，所有节点的出度之和等于边数e；对无向图而言，所有节点的度之和等于2e，因此查找邻接点的时间复杂度为O(e)，加上初始化时间O(n)，总的时间复杂度为O(n+e)。这里使用了一个辅助队列，每个节点只入队一次，空间复杂度为O(n)。
# 6.2.2 深度优先遍历
深度优先搜索（Depth First Search，DFS）是最常见的图搜索方法之一。深度优先搜索沿着一条路径一直搜索下去，在无法搜索时，回退到刚刚访问过的节点。深度优先遍历是按照深度优先搜索的方式对图进行遍历的。

深度优先遍历的秘籍：**后被访问的节点，其邻接点先被访问**。根据深度优先遍历的秘籍，后来者先服务，这可以借助于栈实现。递归本身就是使用栈实现的，因此使用递归的方法更方便。
### 1. 算法步骤
（1）初始化图中的所有节点均未被访问。
（2）从图中的某个节点v出发，访问v并标记其已被访问。
（3）依次检查v的所有邻接点w，如果w未被访问，则从w出发进行深度优先遍历（递归调用，重复步骤2～3）。
### 2. 完美图解
例如，一个无向图如下图所示，其深度优先遍历的过程如下所述。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112152539.png)
（1）初始化所有节点均未被访问，visited[i]=false，i=1,2,…,8。
（2）从节点1出发，标记其已被访问，visited[1]=true
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112153627.png)

（3）从节点1出发访问邻接点2，然后从节点2出发访问节点4，从节点4出发访问节点5，从节点5出发访问未被访问的邻接点。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112153972.png)

（4）回退到刚刚访问过的节点4，节点4也没有未被访问的邻接点，回退到最近访问过的节点2，从节点2出发访问下一个未被访问的邻接点6。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112153311.png)

（5）从节点6出发访问未被访问的邻接点，回退到刚刚访问过的节点2，节点2没有未被访问的邻接点，回退到最近访问过的节点1。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112153474.png)

（6）从节点1出发访问下一个未被访问的邻接点3，从节点3出发访问节点7，从节点7出发访问节点8，从节点8出发访问未被访问的邻接点。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112153241.png)

（7）回退到刚刚访问过的节点7，节点7也没有未被访问的邻接点，回退到最近访问过的节点3，节点3也没有未被访问的邻接点，回退到最近访问过的节点1，节点1也没有未被访问的邻接点，遍历结束。访问路径如下图所示。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112154135.png)
深度优先遍历序列为1 2 4 5 6 3 7 8。

深度优先遍历经过的节点及边被称为**深度优先生成树**，如下图所示。如果深度优先遍历非连通图，则每一个连通分量都会产生一棵深度优先生成树。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112154254.png)
### 3. 算法实现
（1）基于邻接矩阵的深度优先遍历。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112155287.png)
（2）基于邻接表的深度优先遍历。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112155154.png)
（3）基于非连通图的深度优先遍历。
![](https://image-1307616428.cos.ap-beijing.myqcloud.com/Obsidian/202306112155329.png)
### 4. 算法分析
深度优先遍历的过程实质上是对每个节点都搜索其邻接点的过程，图的存储方式不同，其算法复杂度也不同。
（1）基于邻接矩阵的深度优先遍历算法。查找每个节点的邻接点需要O(n)时间，共n个节点，总的时间复杂度为 $O(n^2)$ 。这里使用了一个递归工作栈，空间复杂度为O(n)。
（2）基于邻接表的深度优先遍历算法。查找节点vi的邻接点需要O(d(vi))时间，d(vi)为vi的出度，对有向图而言，所有节点的出度之和等于边数e；对无向图而言，所有节点的度之和等于2e，因此查找邻接点的时间复杂度为O(e)，加上初始化时间O(n)，总的时间复杂度为O(n+e)。这里使用了一个递归工作栈，空间复杂度为O(n)。

需要注意的是，==一个图的邻接矩阵是唯一的，因此基于邻接矩阵的广度优先级遍历或深度优先遍历的序列也是唯一的==，而图的邻接表不是唯一的，边的输入顺序不同，正序或逆序建表都会影响邻接表中的邻接点顺序，因此==基于邻接表的广度优先遍历或深度优先遍历的序列不是唯一的==。

## 训练1　油田
题目描述（UVA572）：某石油勘探公司正在按计划勘探地下油田资源，在一片长方形地域中工作。他们首先将该地域划分为许多

小正方形区域，然后使用探测设备分别探测在每一小正方形区域内是否有油。含有油的区域被称为油田。如果两个油田相邻（在水平、垂直或对角线相邻），则它们是相同油藏的一部分。油藏可能非常大并可能包含许多油田（油田的个数不超过100）。你的工作是确定在这个长方形地域中包含多少不同的油藏。输入：输入文件包含一个或多个长方形地域。每个地域的第1行都有两个正整数m和n（1≤m,n≤100），表示地域的行数和列数。如果m=0，则表示输入结束；否则此后有m行，每行都有n个字符。每个字符都对应一个正方形区域，字符*表示没有油，字符@表示有油。输出：对于每个长方形地域，都单行输出油藏的个数。[插图]题解：对这样的油田进行遍历，从每个“@”格子出发，寻找它周围所有的“@”格子，同时将这些格子标记一个连通分量号，最后输出连通分量数。使用图的深度优先搜索即可。例如，输入样例4，其油藏的个数就是连通分量的个数，如下图所示。[插图]根据题意，水平、垂直或对角线都认为是相邻，因此搜索时，可以从8个方向进行深度优先搜索，如下图所示，如何控制8个方向呢？[插图][插图]1. 算法设计（1）对字符矩阵中的每个位置都进行判断，如果未标记连通分量号且为'@'，则从该位置出发进行深度优先搜索。（2）搜索时需要判断是否出界，是否已有连通分量号或不是'@'；否则将该位置标记连通分量号为id，从该位置出发，沿8个方向继续进行深度优先搜索。2. 算法实现[插图]特别注意：因为有可能包含多个连通分支，因此需要从每个未标记的'@'进行深度优先搜索。训练2　理想路径题目描述（UVA1599）：给定一个有n个节点、m条边的无向图，每条边都涂有1种颜色。求节点1到n的一条路径，使得经过的边数最少，在此前提下，经过边的颜色序列最小。可能有自环与重边。输入保证至少存在一条连接节点1和n的路径。输入：输入共m+1行。第1行包含两个整数：n和m。之后的m行，每行都包含3个整数ai、bi、ci，表示在ai、bi之间有一条颜色为ci的路径。输出：输出共两行，第1行包含正整数k，表示节点1到n至少需要经过k条边。第2行包含k个由空格隔开的正整数，表示节点1到n依次经过的边的颜色。[插图]输出样例解释：节点1到4至少经过两条边：1→3，颜色为1（最后输入的那条）；3→4，颜色为3。数据范围：2≤n≤105，1≤m≤105，1≤ci≤109，对于任意i∈[1,m]，都有1≤ai,bi≤
n。对于两个长度为k的序列a和b，若存在i∈[1,k]使ai<bi，且对于任意j∈[1,i)都有aj=bj，则a<b。题解：本题求解节点1到n的最短距离，在此前提下，色号序列最小。可以先求解最短距离，然后考察色号。因为在从节点1出发的多条边中，并不知道哪条边是最短路径上的边，所以无法确定最小色号。1. 算法设计（1）从节点n反向广度优先遍历标高，节点1的高度正好为从节点1到n的最短距离。（2）从节点1正向广度优先遍历，沿着高度减1的方向遍历，找色号小的点，如果多个点的色号都最小，则考察下一个色号哪个最小，直到节点n结束。2. 完美图解输入样例的求解过程如下。（1）根据输入样例创建图，然后节点n反向广度优先遍历标高，节点1的高度为2，即节点1到n的最短距离为2，输出2。[插图]（2）从节点1正向广度优先遍历，沿着高度减1的方向遍历，找边上色号小的邻接点，节点1到2的色号为1，节点1到3的色号也为1，节点1到3的另一条道路色号为2，最小色号为1，输出1。目前无法确定选择哪条边，因此将都有可能走的两个邻接点2和3入队并暂存。[插图]（3）从节点2和3出发，沿着高度减1的方向遍历，找边上色号小的邻接点，节点2到4的色号为4，节点3到4的色号为3，最小色号为3，输出3。[插图]3. 算法实现（1）逆向求最短距离。[插图][插图]（2）正向求最小色号序列。• 队列q1：保存节点号。• 队列q2：保存色号。• 队列q3：保存色号最小的边关联的邻接点号。例如，如下图所示，按邻接表顺序遍历边时，节点1到2、节点1到3的边色号均最小（色号为3），那么队列q3暂存2、3两个节点，后来发现有比它们更小的色号（色号为2），将q3立即清空，保存节点5。[插图][插图][插图]特别注意的是，正向求解时：①沿着高度减1的方向扩展；②从色号最小的边关联的节点继续扩展；③一旦发现有更小的色号，则队列q3立即清空，保存当前色号最小的边关联的节点。训练3　骑士的旅程题目描述（POJ2488）：骑士决定环游世界，其移动方式如下图所示。骑士的世界是他生活的棋盘，棋盘面积比普通的8×8棋盘小，但它仍然是长方形的。你能帮助这个骑士做出旅行计划吗？找到一条道路。骑士每次都进入一个方格，可以在棋盘的任意方格上开始和结束。[插图]输入：输入的第1行包含一个正整数T，表示测试用例的数量。每个测试用例的第1行都包含两个正整数m和n（1≤m×n≤26），表示m×n的棋盘，对行用数字标识（1～m），对列用大写字母标识（A～Z）。输出：每个测试用例的输出都以一个包含“Scenario #i：”的行开头，其中i是从1开始的测试用例编号。然后单行输出按字典顺序排列的第1条路径，该路径访问棋盘的所有方块。应通过连接访问方块的名称输出路径，每个方块的名称都由一个大写字母后跟一个数字组成。如果不存在这样的路径，则应该在一行上输出“impossible”。在测试用例之间有一个空行。[插图]题解：骑士移动的8个位置，其偏移量如下图所示。如果骑士的当前位置为(x, y)，则移动时将当前位置的坐标加上偏移量即可，例如骑士从当前位置移动到右上角的位置(x-2, y+1)。[插图]可以定义方向数组：int dir[8][2]={-2,-1,-2,1,-1,-2,-1,2,1,-2,1,2,2,-1,2,1}。1. 算法设计棋盘是m行、n列的，对行用数字标识，对列用大写字母标识，但输出时先输出大写字母，然后输出数字。因此写程序时，可以把棋盘翻转一下，将其看作n行、m列的，这样就可以先行后列地进行输出了。（1）从(1,1)开始，沿8个方向进行深度优先搜索，判断是否可行，如果可行，则记录搜索步数，从当前节点出发继续进行深度优先搜索。（2）当步数达到n×m时，说明找到一条路径，输出该路径。2. 算法实现[插图]输出路径：[插图]训练4　抓住那头牛题目描述（POJ3278）：约翰希望立即抓住逃亡的牛。当前约翰在节点N，牛在节点K（0≤N, K≤100 000）时，他们在同一条线上。约翰有两种交通方式：步行和乘车。如果牛不知道有人在追赶自己，原地不动，那么约翰需要多长时间才能抓住牛？• 步行：约翰可以在一分钟内从任意节点X移动到节点X-1或X+1。• 乘车：约翰可以在一分钟内从任意节点X移动到节点2×X。输入：两个整数N和K。输出：单行输出约翰抓住牛所需的最短时间（以分钟为单位）。[插图]提示：在输入样例中抓
住牛的最快方法是沿着路径5-10-9-18-17前进，需要4分钟。题解：可以采用深度优先搜索和广度优先搜索两种方法解决。1. 算法设计1）深度优先搜索方法根据输入样例，约翰在5的位置，牛在17的位置。约翰可以先乘车到10，步行退回到9，然后乘车到18，步行退回到17，抓到牛，一共4步。[插图]假设约翰和牛的位置分别为n和k，则求解步骤如下。（1）如果n=0，则先走1步到1，n=1，否则无法乘车，因为0的两倍还是0。（2）进行深度优先搜索，dfs(t)表示求解约翰从初始位置n到达位置t的最小步数。• 如果t≤n，因为不可以向后乘车，只能一步一步地后退，则需要n-t步。• 如果t为偶数，则比较从t/2向前乘车到t、从n一步一步向前走到t，采用哪种方案使得步数最少，取最小值。第1种方案的步数为从初始位置到达t/2的步数dfs(t/2)加上1次乘车所需步数，第2种方案的步数为t-n。• 如果t为奇数，则比较从t-1向前1步到t（步数为dfs(t-1)+1）、从t+1向后1步到t（步数为dfs(t+1)+1），采用哪种方案使得步数最少，取最小值。[插图]2）广度优先搜索算法（1）如果k≤n，因为不可以向后乘

车，只能一步一步地后退，则需要n-k步，否则执行步骤2。（2）从当前节点出发进行广度优先搜索，每个节点都可以扩展3个位置，判断该位置是否为牛的位置，如果是，则返回走过的步数；否则，判断位置是否有效（未超界且未访问），如果是，则将步数加1，并将位置入队。（3）如果队列不空，则一直进行广度优先搜索，直到找到牛的位置。2. 完美图解从约翰的位置5出发进行广度优先搜索，节点5先扩展3个位置，然后节点6、4、10扩展，如下图所示。继续进行广度优先搜索，直到找到牛的位置，返回走过的距离。[插图]从以上扩展可以看出，有很多无效搜索，效率比采用深度优先搜索要低。因为在一条直线上，所以采用深度优先搜索效果更好；如果在二维地图上，则采用广度优先搜索效果更好。3. 算法实现[插图][插图]

