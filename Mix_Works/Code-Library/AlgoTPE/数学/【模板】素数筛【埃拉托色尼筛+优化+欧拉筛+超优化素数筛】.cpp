//素数筛法，是一种快速“筛”出2~n之间所有素数的方法。朴素的筛法叫埃氏筛（the Sieve ofEratosthenes，
//埃拉托色尼筛），它的过程是这样的：

//我们把2~n的数按顺序写出来：
//
//[公式]
//
//从前往后看，找到第一个未被划掉的数，2，这说明它是质数。然后把2的倍数（不包括2）划掉：
//
//[公式]
//
//下一个未被划掉的数是3，它是质数，把3的倍数划掉：
//
//[公式]
//
//接下来应该是5，但是5已经超过 [公式] 了，所以遍历结束，剩下未被划掉的都是素数：
//
//[公式]
//
//如何？是不是比一个一个判断快多了？这个过程写成代码就是：
#include <iostream>
using namespace std;
#define MAXN 100000
bool isnp[MAXN] = {1, 1, 0}; //is not a prime不是素数 
void Eratosthenes(int n) {
	for (int i = 2; i <= n; ++i) 
		if (!isnp[i]) 
			for (int j = i + i; j <= n; j += i)
				isnp[j] = 1; //不是素数 
}
//i <= sqrt(n); //i * i <= n
//j = i * i

int main() {
	return 0; 
}
bool isnp[MAXN]; // is not prime: 不是素数
void init(int n)
{
    for (int i = 2; i * i <= n; i++) //不用收集质数表时可以这么写 
        if (!isnp[i])
            for (long long j = (long long)i * i; j <= n; j += i)
                isnp[j] = 1;
}

//代码也很简洁。这个算法的复杂度是 [公式] ，还是非常优秀了。但是我们可能会发现，在筛的过程中我们会重复筛到同一个数，例如12同时被2和3筛到，30同时被2、3和5筛到。所以我们引入欧拉筛，也叫线性筛，可以在 [公式] 时间内完成对2~n的筛选。它的核心思想是：让每一个合数被其最小质因数筛到。

//我们这次除了把2~n列出来，还维护一个质数表：
//
//[公式]
//
//还是从头到尾遍历，第一个数是2，未被划掉，把它放进质数表：
//
//[公式]
//
//然后我们用2去乘质数表里的每个数，划掉它们：
//
//[公式]
//
//下一个是3，加入质数表，划掉6、9：
//
//[公式]


//下一个是4（注意这里划掉的数也要遍历，只是不加入质数表），先划掉8，但我们不划掉12，因为12 [公式] 应该由它的最小质因数2筛掉，而不是3。
//
//[公式]
//
//实际上，对于 [公式] ，我们遍历到质数表中的 [公式] ，且发现 [公式] 时，就应当停止遍历质数表。因为：设 [公式] （ [公式] 本身是 [公式] 的最小质因数），那么对于任意 [公式] ，有 [公式] ，说明 [公式] 的最小质因数不是 [公式] ，我们不应该在此划掉它。
//
//这么说有点抽象，具体地说，如这里的2能整除4，则 [公式] ，那么对于任何大于2的质数 [公式] ，都有 [公式] ，其中2是一个比 [公式] 更小的质数，所以 [公式] 应该被2筛掉而不是被 [公式] 筛掉。
//
//下一个是5，加入质数表，划掉10，15：
//
//[公式]
//
//下一个是6，划掉12，6被2整除，跳过。

//……

//按这样的步骤进行下去，可以筛掉所有的合数，并得到一张质数表。
//
//[公式]
//
//我们可以保证每个合数都被筛过，设任意合数 [公式] ，其中 [公式] 是 [公式] 的最小质因数，又设 [公式] ， [公式] 是 [公式] 的最小质因数。在处理 [公式] 时，要遍历质数表，直到遇到 [公式] 时才结束，所以任意小于等于 [公式] 的质数与 [公式] 的乘积，都会在此时被筛掉。
//
//而由于一定有 [公式] （因为 [公式] 的最小质因数是 [公式] ，而不是 [公式] ），所以在处理到 [公式] 时， [公式] 一定会被筛到。
//
//代码如下（C++11风格）：

bool isnp[MAXN];
vector<int> primes; //要求质数表
void init(int n)
{   //日后再看一下博文好了 
    for (int i = 2; i <= n; i++) //不求质数表时i*i<=n,但是这样似乎收集不到所有的质数 
    {
        if (!isnp[i])
            primes.push_back(i);
        for (int p : primes)
        {
            if (p * i > n)
                break;
            isnp[p * i] = 1;
            if (i % p == 0) //是i 
                break;
        } //if(i % prime[j] == 0) break; 使数据不会被提前的筛去,这保证了数据不会被多次筛去 
    }
}
//https://www.luogu.com.cn/problem/solution/P3383
//i×Prime[j] 是尝试筛掉的某个合数，我们期望 Prime[j] 是这个合数的最小质因数
//j 循环到 i \mod Prime[j] == 0 就恰好需要停止的理由是：

//    下面用 s(smaller) 表示小于 j 的数，L(larger) 表示大于 j 的数。
//
//    ① i 的最小质因数肯定是 Prime[j]。
//
//    （如果 i 的最小质因数是 Prime[s] ，那么 Prime[s] 更早被枚举到（因为我们从小到大枚举质数），当时就要break）
//
//    既然 i 的最小质因数是 Prime[j]，那么 i × Prime[j] 的最小质因数也是 Prime[j]。所以，j 本身是符合“筛条件”的。
//
//    ② i × Prime[s]  的最小质因数确实是 Prime[s]。
//
//    （如果是它的最小质因数是更小的质数 Prime[t]，那么当然 Prime[t] 更早被枚举到，当时就要break）
//
//    这说明 j 之前（用 i × Prime[s] 的方式去筛合数，使用的是最小质因数）都符合“筛条件”。
//
//    ③i × Prime[L] 的最小质因数一定也是 Prime[j]。
//
//    （因为 i 的最小质因数是 Prime[j]，所以 i × Prime[L] 也含有 Prime[j] 这个因数（这是 i 的功劳），所以其最小质因数也是 Prime[j]（新的质因数 Prime[L]Prime[L]Prime[L] 太大了））
//
//    这说明，如果 j 继续递增（将以 i × Prime[L] 的方式去筛合数，没有使用最小质因数），是不符合“筛条件”的。
//
//小提示：
//
//当 i 还不大的时候，可能会一层内就筛去大量合数，看上去耗时比较大，但是由于保证了筛去的合数日后将不会再被筛
//（总共只筛一次），复杂度是线性的。到 i 接近 n 时，每层几乎都不用做什么事。 
//正确性（所有合数都会被标记）证明
//
//设一合数 C（要筛掉）的最小质因数是p_1，令 B = C / p_1（C = B × p_1），则 B 的最小质因数不小于
// p_1（否则 C 也有这个更小因子）。那么当外层枚举到 i = B 时，我们将会从小到大枚举各个质数；
//因为 i = B的最小质因数不小于 p_1，所以 i 在质数枚举至 p_1 之前一定不会break，这回，C 一定会被 B × p_i 删去。
//
//核心：亲爱的 B 的最小质因数必不小于 p_1。
//
//例：315 = 3 × 3 × 5 × 7，其最小质因数是 3。考虑 i = 315 / 3 = 105时，
//我们从小到大逐个枚举质数，正是因为 i 的最小质因数也不会小于 3（本例中就是 3），所以当枚举 
//j = 1 (Prime[j] = 2)时，i 不包含 2 这个因子，也就不会break，
//直到 Prime[j] = 3 之后才退出。
//
//当然质数不能表示成“大于1的某数×质数”，所以整个流程中不会标记。
//线性复杂度证明
//
//注意这个算法一直使用“某数×质数”去筛合数，又已经证明一个合数一定会被它的最小质因数 p_1 筛掉，所以我们
//唯一要担心的就是同一个合数是否会被“另外某数 × p_1 以外的质数”再筛一次导致浪费时间。设要筛的合数是 C，设
//这么一个作孽的质数为 p_x，再令 A = C / p_x，则 A 中一定有 p_1 这个因子。
//当外层枚举到 i = A，它想要再筛一次 C，却在枚举 Prime[j] = p_1时，
//因为i \mod Prime[j] == 0 就退出了。因而 C 除了 p_1 以外的质因数都不能筛它。
//
//核心：罪恶的 AAA 中必有 p_1 这个因子。
//
//例：315 = 3 × 3 × 5 × 7。首先，虽然看上去有两个 3，但我们筛数的唯一一句话就是
//
//			isPrime[i*Prime[j]] = 0;
//
//所以，315 只可能用 105 × 3或 63×5 或 45×7 这三次筛而非四次。然后
//非常抱歉，后两个 i = 63, i = 45 都因为贪婪地要求对应的质数 Prime[j]
// 为 5 、7，而自己被迫拥有 3 这个因数，因此他们内部根本枚举不到 5 、7，而是枚举到 3 就break了。
//
//以上两个一证，也就无可多说了。



//注意判断越界那里最好使用乘法而不是除法，一般不会溢出，计算机算除法比乘法要慢得多。
//
//欧拉筛除了解决一些卡埃氏筛的毒瘤题（比如洛谷P3383，线性筛模板）外，在后续一些数论算法中还有更多的应用。


#include <bits/stdc++.h>
using namespace std;
vector<int> prime;
int MAXPR = 1e8; //n
void calcPrimes() {
//    auto sum = 2LL; //从2开始 
//    int cnt = 1;
    const int S = round(sqrt(MAXPR)); //sqrt(n)四舍五入
	cout << "S = " << S << endl;
    vector<char> sieve(S + 1, true); //sqrt(n)筛素数 sieve[i]=true表示i是素数 对于9,16等+1 
    vector<array<int, 2>> cp; //记录
	 
    for (int i = 3; i < S; i += 2) { //从3,5,7,9 到 小于sqrt(n)四舍五入 
        if (!sieve[i]) //不是素数 
            continue;
        cp.push_back({i, (i * i - 1) / 2}); //i是素数的话, 记录i和 (i*i-1)/2
		printf("对每个奇数 %d : %d\n", i, (i * i - 1) / 2);
		//i*i是奇数 (2k+1)(2k+1)=4k^2+4k+1 + 2k+1 = 偶数 k>=0 
        for (int j = i * i; j <= S; j += 2 * i) { //然后从 i*i 到  <=sqrt(n)四舍五入 筛，每次加上 2*i 
            sieve[j] = false; //不是素数  //+2i是因为偶数没有意义,不会遍历和收集到 
        	printf("%d 被筛去\n", j);
        }
    }
    vector<char> block(S); //分块？ 
    int high = (MAXPR - 1) / 2; //上界为 (n - 1) / 2
	 
    for (int low = 0; low <= high; low += S) { //下界到上界，每次 \sqrt(n) 跨越一个块
	 	printf("块[%d, %d] 内：\n", low, low + S); 
        fill(block.begin(), block.end(), true); //块内
		
        for (auto &i : cp) { //对每个  
            int p = i[0], idx = i[1]; //p为素数, idx为? 
            printf("对每个素数 %d 及 %d , 筛去: \n", p, idx);
            
            for (; idx < S; idx += p) { //对每块； 每次加上素数i , 筛 
                block[idx] = false; //不是素数
				cout << idx << " "; 
			}  
            i[1] = idx - S; //新的轮回 到下一块了 取模 
            cout << "新的i[1] = " << i[1] <<endl; 
			for (int i = 0; i < S; ++i) cout << (bool)block[i] <<" ";
			cout <<endl;
        }
        if (low == 0) block[0] = false; //0不是素数
		
		printf("得到的素数有：");
        for (int i = 0; i < S && low + i <= high; i++)
            if (block[i]) {
            	cout << (low + i) * 2 + 1 << " "; //奇数 抛弃偶数 
                prime.push_back( ( low + i) * 2 + 1); //加入素数 
            }
            cout << endl;
            cout <<"______________________________"<<endl;
    };
} //https://zhuanlan.zhihu.com/p/60378354
int main() {
    prime.push_back(2); //开始就有2 
    int T,p;
    scanf("%d%d",&MAXPR,&T); 
    calcPrimes();
    while (T--) scanf("%d",&p),printf("%d\n",prime[p-1]);
    return 0;
}
