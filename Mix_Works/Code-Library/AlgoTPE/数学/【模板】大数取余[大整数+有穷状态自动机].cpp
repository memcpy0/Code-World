#include <bits/stdc++.h>
using namespace std;
/*
大数求余怎样计算？
一种做法是：自己实现一个大整数类（以及带取余的除法运算）
真正的做法：有穷状态自动机

一个例题：大整数对3取模的余数是多少？取巧的做法是：各数位相加对3的余数。
但是这种做法不具有可延展性。

状态机：既然是模3，那就只有余0、余1、余2这三种状态；输入只有10种可能
只要看在当前的状态下，输入下一个字符，会跳转到什么状态就行了。

DFA : (Q状态集合, S开始状态, T映射集合, E终止状态集合)
 
16进制的大数取模？ 
*/ 
//2323232323232323232323232323232323232323232324 
//一个特别大的数除以23 
int main() {
    int table[10][23]; //10种输入, 23种当前状态 
    for (int i = 0; i < 10; ++i) {
		table[i][0] = i; //对应的i如果
		for (int j = 1; j < 23; ++j)
			table[i][j] = (table[i][j - 1] + 10) % 23; 
	}
	
	int c, mod = 0;
	while ((c = getchar()) != EOF) {
		if (c == '\n') {
			printf("%d\n", mod);
			mod = 0;
		} else {
			//c in '0', ..., '9'
			c -= '0';
			mod = table[c][mod];
		}
	}
    return 0;
}
/*
时间复杂度为O(n), 和输入的大数的字符长度成线性, 把字符串扫描一遍就能得到结果
空间复杂度为O(1), 连大数本身都不用存储, 只需要存储三个内容：
1. 当前状态（变量mod), 描述截止到当前输入下，模数是多少
2. 输入的下一个字符（即变量c）
3. 状态转换表（table数组）。描述在当前状态下，输入下一个字符后，跳转到什么状态 
*/

