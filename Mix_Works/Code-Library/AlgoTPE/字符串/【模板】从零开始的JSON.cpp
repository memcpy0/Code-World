/*
本教程以一个 简单的项目开发形式，
让同学**逐步**理解
如何**从无到有**去开发软件。

为什么选JSON： 
JSON足够简单，不需大量技术和背景知识
JSON 有标准，可按照标准逐步实现
JSON 应用广泛，开源库众多

对象：学习过基本 C/C++ 编程的人 
目的： 从零开始写一个 JSON 库，特性：
- 符合标准的 JSON 解析器和生成器
- 手写的递归下降解析器 （recursive descent parser）

- 仅支持UTF-8 JSON文本
- 仅支持 以double存储 的JSON number类型 
- 标准C89语言

- 跨平台和编译器（win/linux/Os X, vc/gcc/clang) 
- 解析器和生成器的代码合计 < 500

课题：
- 测试驱动开发（test driven development, TDD）
- 断言
- C语言编程风格
- API设计
- Unicode
- 浮点数
- Github/CMake/ valgrind / doxygen工具 
- 数据结构 
 
教程大纲：
本教程预计分为 9 个单元，第 1-8 个单元附带练习和解答
启程：
	JSON 简介、JSON语法子集、
	搭建编译环境、
	宏的编写技巧、 
		为什么使用宏而不用函数或内联函数？
		因为这个测试框架使用了 `__LINE__` 这个编译器提供的宏，代表编译时该行的行号。
		如果用函数或内联函数，每次的行号便都会相同。
		另外，内联函数是 C99 的新增功能，本教程使用 C89。
	头文件和API设计、 
	单元测试、测试驱动开发、关于断言
		 //在做练习题时，都是以 `printf`／`cout` 打印结果，再用肉眼对比结果是否合乎预期
		 //当软件项目越来越复杂，这个做法会越来越低效。一般我们会采用自动的测试方式，例如单元测试（unit testing）
		 //单元测试 也能确保其他人修改代码后，原来的功能维持正确（这称为回归测试／regression testing）
		 //常用的单元测试框架有 xUnit 系列，如 C++ 的 [Google Test](https://github.com/google/googletest)、C# 的 [NUnit](
		 //为了简单起见，会编写一个极简单的单元测试方式
		 
		 //一般来说，软件开发是以周期进行的。例如，加入一个功能，再写关于该功能的单元测试
		 //有另一种软件开发方法论，称为测试驱动开发（test-driven development, TDD）,主要循环步骤是
		 1. 加入一个测试。
		 2. 运行所有测试，新的测试应该会失败。
		 3. 编写实现代码。
		 4. 运行所有测试，若有测试失败回到3。
		 5. 重构代码。
		 6. 回到 1。
		 TDD 是先写测试，再实现功能。好处是实现只会刚好满足测试，而不会写了一些不需要的代码，或是没有被测试的代码
		 无论我们是采用 TDD，或是先实现后测试，都应尽量加入足够覆盖率的单元测试
		 //回到 leptjson 项目，`test.c` 包含了一个极简的单元测试框架
		 
		 断言（assertion）是 C 语言中常用的防御式编程方式，减少编程错误。
		 最常用的是在函数开始的地方，检测所有参数。
		 有时候也可以在调用函数后，检查上下文是否正确
		 
		 C 语言的标准库含有 [`assert()`](https://en.cppreference.com/w/c/error/assert) 
		 这个宏（需 `#include <assert.h>`），提供断言功能。
		 当程序以 release 配置编译时（定义了 `NDEBUG` 宏），`assert()` 不会做检测；
		 而当在 debug 配置时（没定义 `NDEBUG` 宏），则会在运行时检测 `assert(cond)` 
		 中的条件是否为真（非 0），
		 断言失败会直接令程序崩溃。
		 
		 初使用断言的同学，可能会错误地把含[副作用](https://en.wikipedia.org/wiki/Side_effect_(computer_science))的代码放在 `assert()` 中：
		 
		 初学者可能会难于分辨何时使用断言，何时处理运行时错误（如返回错误值或在 C++ 中抛出异常）
	实现解析器（解析器主要函数及各数据结构）
	总结与练习： JSON 布尔类型、多个JSON值的解析和测试。
	启程解答篇：（2016/9/17 完成）。
解析数字（2016/9/18 完成）：
	重构：TDD 中的一个步骤──重构（refactoring）
	 	在不改变代码外在行为的情况下，对代码作出修改，以改进程序的内部结构
		在 TDD 的过程中，我们的目标是编写代码去通过测试。
		但由于这个目标的引导性太强，我们可能会忽略正确性以外的软件品质
		 
		通过测试之后，代码的正确性得以保证，我们就应该审视现时的代码，
		看看有没有地方可以改进，而同时能维持测试顺利通过
		
		我们可以安心地做各种修改，因为我们有单元测试，
		可以判断代码在修改后是否影响原来的行为。
		
		重构与单元测试是互相依赖的软件开发技术，适当地运用可提升软件的品质
		
		第一个练习题，就是尝试合并这 3 个函数：lept_parse_true/false/null
		
		单元测试代码也有很重复的代码
		
		
		
	JSON number 的语法
	数字表示方式
	单元测试
	十进制转换至二进制
	练习： JSON number 类型的校验。
	解析数字解答篇
解析字符串（2016/9/22 完成）：
	使用 union 存储 variant、
	自动扩展的堆栈、JSON string 的语法、valgrind。
	练习：最基本的 JSON string 类型的解析、内存释放。
	解析字符串解答篇 （2016/9/27 完成）
Unicode（2016/10/2 完成）：
	Unicode 和 UTF-8 的基本知识、
	JSON string 的 unicode 处理。
	练习：完成 JSON string 类型的解析。
	Unicode 解答篇（2016/10/6 完成）
解析数组（2016/10/8 完成）：
	JSON array 的语法。
	练习：完成 JSON array 类型的解析、相关内存释放。
	解析数组解答篇（2016/10/13 完成）
解析对象（2016/10/29 完成）：
	JSON object 的语法、
	重构 string 解析函数。
	练习：完成 JSON object 的解析、相关内存释放。
	解析对象解答篇（2016/11/15 完成）
	
生成器（2016/12/20 完成）：
	JSON 生成过程、注意事项。
	练习完成 JSON 生成器。生成器解答篇（2017/1/6 完成）
	访问：JSON array／object 的访问及修改。
	练习完成相关功能。
终点及新开始：
	加入 nativejson-benchmark 测试，
	与 RapidJSON 对比及展望。

*/ 
