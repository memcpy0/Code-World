#include <bits/stdc++.h>
using namespace std;

//int main() { //运算符“/”的“取整”是朝零方向（towards zero）的取整，而不是向下取整
//	cout << (5/2) << ", " << (-5/2) << endl; //2, -2 //取余(/向零取整),取模(/向下取整)
//	return 0;
//}
//给出一个长度为n的序列A1, A2,…, An，求最大连续和。换句话说，要
//求找到1≤i≤j≤n，使得尽量大
/*程序8-1 最大连续和（1）
枚举法
注意best的初值是A[1]，这是最保险的做法——不要写best=0
T(n) = \sum^n_{i=1}\sum^n_{j=i}j-i+1=\sum^n_{i=1}\frac{(n-i+1)(n-i+2)}{2}
=\frac{n(n+1)(n+2)}{6}
*/
best = A[1]; //初始最大值
for (int i = 1; i <= n; ++i) {
	for (int j = i; j <= n; ++j) { //检查连续子序列A[i],..., A[j]
		int sum = 0;
		for (int k = i; k <= j; ++k) sum += A[k]; //累加元素和
		if (sum > best) best = sum; //更新最大值
	}
}

/*程序8-2 最大连续和（2）
设S_i=A_1+A_2+\dots+A_i, 则A_i+A_{i+1}+\dots+A_j = S_j-S_{i-1}该式子的用途相
当广泛，其直观含义是“连续子序列之和等于两个前缀和之差”。
最内层的循环就可以省略了
T(n) = \sum_{i=1}^nn-i+1 = \frac{n(n+1)}{2}
*/
S[0] = 0;
best = A[1]; //初始最大值
//用到了递推的思想
//从小到大依次计算S[1],S[2],S[3],…，每个只需要在前一个的基础上加上一个元素
for (int i = 1; i <= n; ++i) S[i] = S[i - 1] + A[i]; //递推前缀和S
for (int i = 1; i <= n; ++i) { //遍历每个[i,j]区间
	for (int j = i; j <= n; ++j)
		best = max(best, S[j] - S[i - 1]); //更新最大值
}

/*程序8-4 最大连续和（4）
把O(n^2)算法稍作修改，便可以得到一个O(n)算法：
当j确定时,“S[j]-S[i-1]最大”相当于“S[i-1]最小”，
因此只需要扫描一次数组，维护“目前遇到过的最小S”即可
*/
S[0] = 0;
best = A[1]; //初始最大值
curmin = S[0]; //当前最小S
for (int i = 1; i <= n; ++i) S[i] = S[i - 1] + A[i];
for (int j = 1; j <= n; ++j) {
	best = max(best, S[j] - curminS); //精妙！！！
	curminS = min(S[j], curminS);
}

/*程序8-3 最大连续和（3）
分治算法一般分为如下3个步骤。
- 划分问题：把问题的实例划分成子问题。
- 递归求解：递归解决子问题。
- 合并问题：合并子问题的解得到原问题的解。

“划分”就是把序列分成元素个数尽量相等的两半；“递归求解”就是分别求出
完全位于左半或者完全位于右半的最佳序列；“合并”就是求出起点位于左半、终点位于右半
的最大连续和序列，并和子问题的最优解比较。

关键在于“合并”步骤。既然起点位于左半，终点位于右
半，则可以人为地把这样的序列分成两部分，然后独立求解：先寻找最佳起点，然后再寻找
最佳终点。

如何像前面那样,得到tot的数学表达式呢？
注意求和技巧已经不再适用，需要用递归的思路进行分析
设序列长度为n时的tot值为T(n)，则T(n)=2T(n/2)+n, T(1)=1 两次长度为n/2的递归调用，
最后的n是合并的时间
这个方程是近似的! n为奇数时,T(n)=T((n-1)/2)+T((n+1)/2)
*/
//必须有至少一个元素
int maxsum(int *A, int x, int y) { //返回数组在左闭右开区间[x,y)中的最大连续和
	if (y - x == 1) return A[x]; //只有一个元素,直接返回
	int m = x + (y - x) / 2; //分治第一步:划分成[x, m)和[m, y)
	//用x+(y-x)/2来确保分界点总是靠近区间起点
	int maxs = max(maxsum(A, x, m), maxsum(A, m, y)); //分治第二步:递归求解
	int v, L, R;
	//精妙！！！
	//L和R分别为从分界线往左、往右能达到的最大连续和
	v = 0; L = A[m - 1]; //分治第三步:合并(1)-从分界点开始往左的最大连续和L
	for (int i = m - 1; i >= x; --i) L = max(L, v += A[i]);
	v = 0; R = A[m]; //分治第三步:合并(2)-从分界点开始往右的最大连续和R
	for (int i = m; i < y; ++i) R = max(R, v += A[i]);
	return max(maxs, L + R); //把子问题的解与L+R比较
}
