/***************************************************************************************
Huffman Codes
In 1953, David A. Huffman published his paper "A Method for the Construction of Minimum-Redundancy Codes", 
and hence printed his name in the history of computer science. As a professor who gives the final exam problem 
on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, 
given a string "aaaxuaxz", we can observe that the frequencies of the characters 'a', 'x', 'u' and 'z' 
are 4, 2, 1 and 1, respectively. We may either encode the symbols as {'a'=0, 'x'=10, 'u'=110, 'z'=111},
or in another way as {'a'=1, 'x'=01, 'u'=001, 'z'=000}, both compress the string into 14 bits.
Another set of code can be given as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, but {'a'=0, 'x'=01, 'u'=011, 'z'=001} 
is NOT correct since "aaaxuaxz" and "aazuaxax" can both be decoded from the code 00001011001001. 
The students are submitting all kinds of codes, and I need a computer program to help me determine 
which ones are correct and which ones are not.
Input Specification:
Each input file contains one test case. For each case, the first line gives an integer N (2≤N≤63), 
then followed by a line that contains all the N distinct characters and their frequencies in the following format:
c[1] f[1] c[2] f[2] ... c[N] f[N]
where c[i] is a character chosen from {'0' - '9', 'a' - 'z', 'A' - 'Z', '_'}, and f[i] is the frequency of c[i] 
and is an integer no more than 1000. The next line gives a positive integer M (≤1000), then followed by M student 
submissions. Each student submission consists of N lines, each in the format:c[i] code[i]
where c[i] is the i-th character and code[i] is an non-empty string of no more than 63 '0's and '1's.
Output Specification:
For each test case, print in each line either "Yes" if the student's submission is correct, or "No" if not.
Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code 
length being optimal is considered correct.
Sample Input:
7
A 1 B 1 C 1 D 3 E 3 F 6 G 6
4
A 00000
B 00001
C 0001
D 001
E 01
F 10
G 11
A 01010
B 01011
C 0100
D 011
E 10
F 11
G 00
A 000
B 001
C 010
D 011
E 100
F 101
G 110
A 00000
B 00001
C 0001
D 001
E 00
F 10
G 11
Sample Output:
Yes
Yes
No
No
*****************************************************************************************/ 
#include <stdio.h> 
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h> 

#define MAXSIZE      10000
#define MinData      NULL
#define MinHeapROOT  1 
#define MaxNumChar   64

/*MinHeap struct data and func*/
typedef struct MinStackNode *MinHeap;
typedef struct TreeNode *MinHeapElementType; 
struct MinStackNode{
	MinHeapElementType* Element;
	int Size;
	int Capacity;
};
MinHeap MinHeapCreate(int MaxSize);
void MinHeapInsert(MinHeap H, MinHeapElementType T);
bool MinHeapIsFull(MinHeap H);
bool MinHeapIsEmpty(MinHeap H);
MinHeapElementType MinHeapDelete(MinHeap H);
void MinHeapPrint(MinHeap H);
/*HuffmannTree struct data and func*/
typedef struct TreeNode *HuffmannTree;
typedef int TreeElementType;
struct TreeNode{
	char S;
	TreeElementType Weight;
	HuffmannTree Left;	
	HuffmannTree Right;
};
HuffmannTree HuffmannTreeCreate(MinHeap H);
void HuffmannTreePrint(HuffmannTree T);
/*Stack struct data and func*/
typedef struct StackNode *Stack;
typedef HuffmannTree StackElementType;
struct StackNode{
	StackElementType *Element;
	int Top;
	int Capacity;
};
Stack StackCreate(int MaxSize);
void Push(Stack Stk, StackElementType item);
StackElementType Pop(Stack Stk);
bool StackIsEmpty(Stack Stk);
bool StackIsFull(Stack Stk);
/*calculate the route*/
int CalWPL_Stack(HuffmannTree T, char S);
int CalWPL_Recur(HuffmannTree T, char S);
/*Test Data struct */
typedef struct _testdata *TestData;
struct _testdata{
	char *S;
	char **Code;
	int CodeLength;
	bool IsPreCode;
};
TestData TestDataCreate(int numChar, int weight[]);
void TestDataDelete(TestData testPtr, int numChar);
int main()
{
	int numChar, numStudent, i, WPL;
	char *str;
	int *weight; 
	HuffmannTree T;
	MinHeap H;
	TestData testData;
	
	scanf("%d", &numChar);
	str = (char *)malloc(sizeof(char) * numChar);
	weight = (int *)malloc(sizeof(int) * numChar);
	/*build num of Tree and insert into MinHeap*/
	H = MinHeapCreate(MAXSIZE);
	for(i = 0; i < numChar; i++){
		T = (HuffmannTree )malloc(sizeof(struct TreeNode));
		scanf("%s", &T->S);scanf("%d", &T->Weight);
		str[i] = T->S;
		weight[i] = T->Weight;
		T->Left = T->Right = NULL;
		MinHeapInsert(H, T);
	}
	//printf("The input MinHeap is:");MinHeapPrint(H);printf("\n");
	/*build the Huffmann Tree*/
	T = HuffmannTreeCreate(H);
	/*print the Huffmann Tree*/
	//printf("The Huffmann Tree is:");HuffmannTreePrint(T);printf("\n");
	/*calculate the least code bit*/
	WPL = 0;
	for(i = 0; i < numChar; i++)
		WPL += weight[i] * CalWPL_Recur(T, str[i]);
	//printf("The WPL is :%d\n", WPL);
	scanf("%d", &numStudent);
//	testData = (TestData )malloc(sizeof(struct _testdata) * numStudent);
	for(i = 0; i < numStudent; i++){
		testData = TestDataCreate(numChar, weight);
		if((testData->CodeLength == WPL) && (testData->IsPreCode))
			printf("Yes\n");
		else 
			printf("No\n");
		/*Delete the testData*/
		TestDataDelete(testData, numChar);
	}
	
	return 0;
}

HuffmannTree HuffmannTreeCreate(MinHeap H)
{
	int i, num;
	HuffmannTree T;
	num = H->Size;
	/*build the Huffmann Tree*/
	for(i = 0; i < (num -1); i++){
		T = (HuffmannTree )malloc(sizeof(struct TreeNode));
		T->Left = MinHeapDelete(H);
		T->Right = MinHeapDelete(H);
		T->Weight = T->Left->Weight + T->Right->Weight;
		T->S = '#';
		MinHeapInsert(H, T);
		//printf("The MinHeap now is:");MinHeapPrint(H);printf("\n");
	}
	T = MinHeapDelete(H);
	
	return T;
}

void HuffmannTreePrint(HuffmannTree T)
{
	if(T){
		HuffmannTreePrint(T->Left);
		printf("%c %d--", T->S, T->Weight);
		HuffmannTreePrint(T->Right);
	}
}
/*采用递归算法求出在T中的字符S的路径长度*/
bool IsFind(HuffmannTree T, char S)
{
	if(T){
		if(T->S == S)
			return true;
		else if(IsFind(T->Left, S))
			return true;
		else if(IsFind(T->Right, S))
			return true;
		else 
			return false;
	}
	else 
		return false;
}
int CalWPL_Recur(HuffmannTree T, char S)
{
	if(T){
		if(T->S == S)
			return 0;
		else if(IsFind(T->Left, S))
			return CalWPL_Recur(T->Left, S) + 1;
		else if(IsFind(T->Right, S))
			return CalWPL_Recur(T->Right, S) + 1;
		else 
			return 0;
	}
	else 
		return 0;
}

int CalWPL_Stack(HuffmannTree T, char S)
{
	int wpl, routeLen;
	HuffmannTree cur;
	Stack Stk;
	/*create a stack */
	Stk = StackCreate(MAXSIZE);
	Push(Stk, T);
	while( !StackIsEmpty(Stk) ){
		while(cur){
			Push(Stk, cur);
			cur = cur->Left;
		}
		cur = Pop(Stk);
		if(cur->S == S)
			break;
		else if(cur->Right){
			Push(Stk, cur);
			cur = cur->Right;
		}
	}
	routeLen = Stk->Top;
	printf("the route length of %c is %d:\n", S, routeLen);
	/*Delete the stack*/	
	free(Stk->Element);
	free(Stk);
	
	return routeLen * cur->Weight;
}

MinHeap MinHeapCreate(int MaxSize)
{
	MinHeap H;
	H = (MinHeap )malloc(sizeof(struct MinStackNode));
	H->Element =(MinHeapElementType *)malloc(sizeof(MinHeapElementType) * MaxSize + 1);
	H->Size = 0;
	H->Capacity = MaxSize;
	H->Element[0] = MinData;
	
	return H;
}
void MinHeapInsert(MinHeap H, MinHeapElementType T)
{
	int cur, parent;
	if( !MinHeapIsFull(H) ){
		/*add item at the end to make it full bintree*/
		H->Element[++(H->Size)] = T;
		/*adjust to make it MinHeap tree(attention: compare the weight not the point here)*/
		for(cur = H->Size; (cur / 2 > 0) && (H->Element[cur/2]->Weight > T->Weight); cur /= 2)
			H->Element[cur] = H->Element[cur / 2];
		H->Element[cur] = T;
	}
	else 
		printf("The MinHeap is Full, insert is failed!\n"); 
}

bool MinHeapIsFull(MinHeap H)
{
	return (H->Size == H->Capacity)? true: false;
}

bool MinHeapIsEmpty(MinHeap H)
{
	return (H->Size == 0)? true: false;
}

MinHeapElementType MinHeapDelete(MinHeap H)
{
	MinHeapElementType T, temp;
	int cur, minchild;
	if( !MinHeapIsEmpty(H) ){
		T = H->Element[MinHeapROOT];
		MinHeapElementType temp = H->Element[H->Size];
		for(cur = MinHeapROOT; (cur * 2) <= H->Size; cur = minchild){
			/*find the minchild of cur*/
			minchild = cur * 2;
			if((minchild + 1) <= H->Size && (H->Element[minchild + 1]->Weight < H->Element[minchild]->Weight))
				minchild ++;
			H->Element[cur] = H->Element[minchild];
		}
		H->Element[cur] = H->Element[(H->Size)--];
	}
	else {
		printf("The MinHeap is Empty, delete is failed!\n");
		T = MinData;
	}
	
	return T;	
}

void MinHeapPrint(MinHeap H)
{
	int i;
	for(i = 1; i <= H->Size; i++)
		printf("%c %d--", H->Element[i]->S, H->Element[i]->Weight );
}

Stack StackCreate(int MaxSize)
{
	Stack Stk;
	Stk = (Stack )malloc(sizeof(struct StackNode));
	Stk->Top = 0;
	Stk->Capacity = MaxSize;
	Stk->Element = (StackElementType *)malloc(sizeof(StackElementType) * MaxSize + 1);
	
	return Stk;
}

bool StackIsFull(Stack Stk)
{
	return ( Stk->Top == Stk->Capacity )? true: false;
}

void Push(Stack Stk, StackElementType item)
{
	if( !StackIsFull(Stk) )
		Stk->Element[(Stk->Top)++] = item;
	else 
		printf("The Stack is Full, Push is failed!\n");
}

bool StackIsEmpty(Stack Stk)
{
	return ( Stk->Top == 0 )? true: false;
}

StackElementType Pop(Stack Stk)
{
	if( !StackIsEmpty(Stk) )
		return Stk->Element[--(Stk->Top)];
	else {
		printf("The Stack is Empty, Pop is failed!\n");
		return NULL;
	}
}

TestData TestDataCreate(int numChar, int weight[])
{
	int i, j;
	int codeLength;
	TestData test;
	test = (TestData )malloc(sizeof(struct _testdata));
	test->S = (char *)malloc(sizeof(char) * numChar);
	test->Code = (char **)malloc(sizeof(char *) * numChar);
	for(i = 0; i < numChar; i++){
		test->Code[i] = (char *)malloc(sizeof(char) * MaxNumChar);
		scanf("%s", &test->S[i]);scanf("%s", test->Code[i]);
	}
	/*calculate the CodeLength*/
	test->CodeLength = 0;
	for(i = 0; i < numChar; i++)
		test->CodeLength += weight[i] * strlen(test->Code[i]);
	/*judge if PreCode*/
	test->IsPreCode = true;
	for(i = 0; i < numChar; i++){
		for(j = i + 1; j < numChar; j++){
			codeLength = strlen(test->Code[i]) > strlen(test->Code[j])? strlen(test->Code[j]): strlen(test->Code[i]);
			if( strncmp(test->Code[i], test->Code[j], codeLength) == 0 ){
				test->IsPreCode = false;
				break;
			}
		}
		if(test->IsPreCode == false)
			break;
	}
		
	return test;
}

void TestDataDelete(TestData testPtr, int numChar)
{
	int i;
	free(testPtr->S);
	for(i = 0; i < numChar; i++)
		free(testPtr->Code[i]);
	free(testPtr->Code);
	free(testPtr);
}
