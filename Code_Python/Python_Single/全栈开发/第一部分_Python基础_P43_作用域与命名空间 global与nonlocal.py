# -*- coding:utf-8 -*-
"""
author      : myRealization
create_time : 2018-09-13 18:38
program     : 学习作用域与命名空间 globals() locals() global nonlocal
"""

"""
解释器在程序运行的时候，会把变量名和值的关系记录下来，但对于函数，则只会将函数名读入，
表示有这个函数，至于函数内部的变量和值，解释器并不关心。

而当函数调用时，就会在调用栈上开辟该函数的命名空间，存入函数的内部变量和值。
随着函数执行完毕，返回时该空间被弹出，函数内部变量占有的空间被回收。

概念：
命名空间：存放变量名和值的关系的空间
- 命名空间分类：
    1 全局命名空间-> 我们自己在顶层文件中、函数外部声明的变量和函数名都属于全局命名空间
    2 局部命名空间-> 在函数内部声明的变量会进入该函数的局部命名空间
    3 内置命名空间-> 存放python解释器为我们提供的名字(如list, dict, tuple)的空间
- 命名空间加载顺序
    内置命名空间 > 全局命名空间 > 局部命名空间(函数执行的时候, 退出时销毁)
- 取值顺序 
    局部命名空间 > 全局命名空间 > 内置命名空间
    * 所以不能在局部和全局声明python解释器已经定义过的名字，会覆盖的

作用域：即作用范围。按照生效范围来看分为全局作用域和局部作用域
    1 全局作用域： 包括全局命名空间内置命名空间，整个文件的内部都可以使用
    2 局部作用域： 即局部命名空间，在函数内部可以使用

globals()和locals()
    * globals() 查看全局作用域中的名字
    * locals()  查看当前作用域中的名字
"""
from pprint import pprint
a = 20
# print(globals(),'\n', locals(), sep='')  # '__builtins__': <module 'builtins' (built-in)> 内置命名空间
# print(globals() == locals())

def func():
    a = 20            # a被赋值创建，为局部变量
    print(a)          # 就近原则
    print(globals())  # 以字典的形式获取全局作用域(内置，全局命名空间)中的所有名字
    print(locals())   # 以字典的形式获取当前作用域的所有名字
# func()

""" 
global和nonlocal
    * global    在函数内部引入全局变量，即把全局变量拿到局部来用，
                使得局部对该全局变量的赋值(而非创建新局部变量)和其他改变操作能反映到全局变量上
    * nonlocal  在函数内部，内层函数访问外层函数中的局部变量，即把离它最近的一层函数的变量拿过来
                该语句不会找全局变量
"""
# ----------------------------global使用------------------------------
def funct():
    # a = 10  在自己的作用域中通过赋值创建了局部变量，是全新的a
    global a  # 引用全局变量a
    a = 30    # 修改会反映到全局变量上
    print(a)

# print(a)  # 20
# funct()   # 30 运行后修改了全局变量
# print(a)  # 30 修改了全局变量

# ----------------------------nonlocal使用------------------------------
def funct1():
    b = 10       # 局部变量
    def funct2():
        b = 20   # 局部变量 无法修改外层函数的变量b
        print(b) # 20
    funct2()
    print(b)     # 10
# funct1()

# 两层函数嵌套 b = 10
def fun1():
    # 如将b=10移出外层函数到全局作用域，报错
    # SyntaxError: no binding for nonlocal 'b' found
    # 也证明了nonlocal不会找到全局中的变量
    b = 10
    def fun2():
        nonlocal b  # 从pycharm的跳转就知道
        b = 20      # 修改了外层函数的b变量的值
        print(b)    # 20
    fun2()
    print(b)        # 20
# fun1()

# 三层函数嵌套
c = 1
def fu1():
    c = 2
    def fu2():
        nonlocal c
        c = 3       # 修改了外层变量
        def fu3():
            c = 4
            print(c)# 4 未修改外层变量
        print(c)    # 3 # 修改了外层变量
        fu3()       # 未修改外层变量
        print(c)    # 3
    print(c)  # 2
    fu2()     # 函数运行后修改了外层变量c
    print(c)  # 3
# fu1()
# print(c)       # 1 全局变量未被修改