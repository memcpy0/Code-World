大家好，在前面四章我为大家把 Disruptor 框架的架子基本搭建起来了，代码写了不少，类关系也简单剖析了一圈，是时候告一段落了。就目前的进度来说，只要大家把前四章引入的一些关键类的关系，以及程序的执行流程掌握了，那么基本上就已经迈进了 Disruptor 框架的大门了，而且是两只脚都迈进了。换句话说，这个框架的学习门槛也就在前四章了，只要掌握了前四章的内容，往后只会越学越容易。这一章我不会再为大家讲解 Disruptor 框架的类结构了，因为结构已经讲得差不多了，这一章我将从优化的角度，为大家分析一下目前框架中有哪些可以优化的地方，优化之后可以进一步提升框架的性能。

**引入高速缓存概念**

一时间不知道怎么讲了，就以一个问题打开局面吧，现在，我想问问大家，怎么就能让程序执行得很快？想象一个场景，现在有一个非常简单的程序，就是计算 1 + 2 的值。具体的流程是什么样呢？按照 CPU 执行程序的常规流程就是先获取指令，然后翻译指令，接着执行指令，获取下一条指令，循环这些步骤即可。这些步骤本身都是硬件控制的，程序员确实做不了什么改变，也无法对其做什么操作，那怎么才能让程序执行得稍微快一点呢？这时候，我们就可以看看这几个步骤中，执行指令的这个步骤。当 CPU 执行指令的时候，显然需要根据指令去获得要操作的数据，也就是获得 1 和 2 这两个数值，然后才能真正执行指令。既然要获得数据，肯定是要访问内存，从内存中获取数据。这个流程想必大家也都很清楚了吧？

当然，访问内存这个步骤也不是程序员可以控制的，数据在内存中，CPU 要执行程序，就不得不访问内存获得数据。但是，请大家想一想，有时候数据也不是真的就在内存当中，当大家使用数据库的时候，就可能会遇到要操作的数据并不在内存的情况，而是在磁盘中，这时候，就要等待数据从磁盘加载到内存当中，然后程序才能继续执行。这也就是说，假如需要的数据存放在磁盘中，CPU 执行程序时需要这些数据时，就不得不等待这些数据被加载到内存，然后才能继续执行。如果这些数据就放在内存中，CPU 直接就能获得这些数据，这样一来，程序执行的速度显然就会稍微快一些。这也是很常规的流程，大家肯定也都知道，而且根据这个常规流程，我们还能意识到，只要 CPU 获得数据更快，那么它执行指令的速度就会更快，这个逻辑没问题吧？如果执行指令的速度加快了，那么循环执行那几个指令的速度显然也会稍微快一点，最后，执行程序也就稍微快一点了。

如果上面那个逻辑大家都理解了，那么让我们再次回到最开始的那个问题，怎么让程序执行的快一点。其实答案也已经很明显了，想想我们在工作中的经验，如果数据放在磁盘中会拖累程序执行的效率，我们就会将它缓存在内存中，不管用什么数据结构吧，总之，肯定会增加一层缓存，把磁盘中的部分数据取出来，放到内存的缓存中。这样 CPU 就可以直接从内存中获得数据，执行起来就会稍微快一点。而现在的情况是什么？现在数据本就在内存当中了，如果希望程序执行的快一点，那该怎么做？很明显，当然是在 CPU 和内存之间增加一层缓存，把数据放到这个缓存中(当然，指令也是可以放在这个缓存中的，但这里我们就以缓存数据为例吧)，这样 CPU 就不必直接访问内存，而是访问这层缓存即可获得数据，可是这层缓存要怎么增加呀？我一个小小的程序员给 CPU 增加缓存，我也太瞧得起自己了吧，简直是癞蛤蟆上秤盘——不知道自己几斤几两。身为一个程序员，还是应该有点自知之明的，但是，我有自知之明是一回事，给 CPU 添加一层缓存是另一回事。缓存肯定是要添加的，但并不是我来添加，而是硬件工程师帮我们添加好了。这就意味着这个缓存层对我们普通程序员来说是可以直接使用的，而且是透明的。

既然已经提到了高速缓存，现在，我就来为大家正式引入高速缓存的概念，实际上，在程序真正执行的时候，CPU 需要操作数据的时候，并不是直接访问内存，从内存中获取数据，而是先访问高速缓存，看看高速缓存中有没有需要的数据，如果有就直接获得这个数据，如果没有才会去内存中获取所需的数据。所以从概念和作用上来说，它就是一个很普通的缓存层，和用户自己在内存中定义的用来缓存磁盘数据的缓存层没什么区别。而从实现上来讲，它是一个硬件，实现原理对业务程序员是透明的，无需过多关注。这就是高速缓存的概念了。

当然，仅仅是了解这些概念还是不够的，作为一个有追求的程序员，最好还是深入了解一下其内部的构造。其实网上已经有很多线程的资料，对高速缓存做了一些介绍。比如说，高速缓存是一个整体的概念，其实这个缓存还可以继续细分，一共划分为三个层级，由高到低分别为 L1、L2、L3。L1 的容量最小，也就是说可以缓存的数据最少，L2 比 L1 大一些，L3 最大。从访问速度来说， CPU 访问 L1 最快，其次是 L2，最后是 L3。从访问顺序来说，其中 L1 最先被 CPU 访问，最后为 L3。具体构造如下图所示。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695446578652-a4dbe341-df64-4405-9209-9109d743a10d.jpeg)

上面的简图就简单展示了 CPU 访问高速缓存的顺序，当 CPU 需要某些数据时，首先会先去 L1 中寻找，如果 L1 中没有找到就会去 L2 中寻找，如果 L2 中没有就会去 L3 中寻找。如果 L3 中还是没有，这时候才会去内存中寻找数据。到此为止，我就把 CPU 执行程序时获得数据的大概流程给大家讲解完了。这点知识还是非常简单的，没什么难度，如果仅仅是这个程度的知识，就没必要给大家讲解了，纯粹是浪费时间。现在，我想在这个 CPU 获取数据的流程之上，提出两个问题。第一，为什么高速缓存要分成 3 个层级？第二，如果高速缓存中没有 CPU 需要的数据，不得不去内存中获取所需的数据，那么从内存中获取的数据需要放到高速缓存中吗？

第一个问题显然很容易回答，高速缓存之所以分成三个层级其实也没有别的原因，主要是考虑到成本，其次就是 CPU 芯片的面积也限制了高速缓存不能做的太大。因为高速缓存这个硬件实际上就是内嵌在 CPU 芯片上的一块存储区域，其实就可以把它看作内存，只不过是访问速度更快的内存。在高速缓存的三个层级中，L1 的制作成本最高，所以它的容量最小，以 KB 来评估容量。L2 的成本稍微次之，容量也稍微大一些，以 KB 或 几MB 来评估容量，L3 的成本最低，所以容量也最大，以数十 MB 来评估容量。如果不考虑成本和芯片的大小，那高速缓存想做多大就做多大，对吧？这个原因说完了，其次才轮到缓存的功能上，简单来说，设计为 3 个层次，其实也是从缓存的角度来考虑的。举个直接的例子，内存其实就可以看作磁盘的缓存，因为磁盘的访问速度太慢了，所以就把数据加载到内存中让 CPU 访问，而高速缓存就可以看作内存的缓存。那么在高速缓存中，L3 的访问速度最慢，L2 快一些，L1 最快。所以就可以把 L1 看作 L2 的缓存，把 L2 看作 L3 的缓存。充分利用各个层级的优点和性能，构建出一个整体的缓存组件。当然，这些都不是我随口说的，在计算机组成原理和计算机操作系统中都有这方法面的知识，大家可以专门看看这些书是怎么讲解和高速缓存相关的知识的。如果上面的这个逻辑大家都清楚了，那么我想问问大家，既然高速缓存的作用就是缓存内存中的数据，使 CPU 获取数据或指令的速度更快。那么，哪些数据可以被缓存到高速缓存中呢？这其实就回到我刚才提出的第二个问题了。从内存中获取的数据应该写入到高速缓存中吗？

最直接的回答显然是要存放到高速缓存中，否则高速缓存怎么体现缓存的作用呢？但是还是让我们认真讨论一下了，既然 CPU 要操作某些数据，那这些数据肯定就是 CPU 需要的，需要的这些数据在高速缓存中找不到，只好从内存中寻找，从内存中找到了返回给 CPU。如果就这么结束了，也不存放起来，如果没过多久 CPU 还需要这些数据，岂不是又要从内存中寻找一次？所以，显然是要把获得的这些数据在返回给 CPU 的同时，也写入到高速缓存中。可是这样一来就延伸出另外几个问题，怎么就知道 CPU 本次从内存获得数据，在下一次还会使用呢？换句话说，CPU 怎么就知道哪些数据可能是自己一直需要的？比如说计算 1 + 2 的值，要循环计算 500 次，那 1 和 2 这两个数值肯定会被 CPU 频繁使用一段时间，所以放到高速缓存中再合适不过，可是假如 CPU 只计算一次 1 + 2 的值，之后就再也不计算了，那么 1 和 2 这两个数值还有必要在高速缓存中放着吗？毕竟缓存是很宝贵的资源，尤其是 L1 高速缓存，更应该让给那些真正被需要的数据存放。还有一个问题，那就是如果 CPU 要计算 1 + 2 + 3 + 4······一直加到 50 的值，当 CPU 第一次获取这些数据的时候，高速缓存中肯定没有，所以 CPU 必须访问内存，那么访问内存的时候 CPU 是先获取一次 1 和 2 这两个值，把这两个值写入高速缓存，然后再访问一次内存，获得 3 和 4 这两个值，然后再访问内存直到获取到 50 这个数值，还是说只访问一次内存，把这些数值一次性全都读取了，放到高速缓存中呢？多次访问内存，把这些数值放到高速缓存，和只访问一次内存，把这些数值放到高速缓存中，最后取得的效果是一样的。但是，多次访问内存效率显然很低，如果是让我选择，我肯定希望一次就把这些需要的数值全都读取了，然后放到高速缓存中。当然，这也只是我自己的设想，CPU 真的可以这么做吗？

大家应该也意识到了，上面这一大段话总结下来，其实就提出了三个问题，第一，CPU 怎么知道哪些数据是自己近期一直需要的；第二，当不需要某些数据的时候，这些数据怎么从高速缓存中移除；第三，当高速缓存中没有 CPU 需要的数据，CPU 不得不从内存中读取然后存放到高速缓存中，以备下一次使用，那么，CPU 每次会从内存中读取多少数据呢？

好了，问题已经给大家列出来了，下面我就先简单为大家解答一下，然后再详细分析。先看第一个问题，其实 CPU 自己也不知道哪些数据会被经常使用，说到底它只是个硬件，是由硬件工程师设计出来的。所以，硬件工程师希望它怎样它就会怎样。而硬件工程师希望这些硬件能够遵循局部性原理来工作，所以 CPU 也会遵从局部性原理来读取数据。所谓局部性原理分为时间局部性和空间局部性，简单来说就是：CPU 正在执行的这条指令很可能在不久之后又会被执行，执行指令时用到的数据很可能在不久之后又会被用到。这就是时间局部性；内存都是连续的，所以存放在内存中的数据也都是连续的。CPU 本次访问的数据，或者说访问了某个字节的数据，那么这个字节附近的一些数据，很可能也会被马上访问到。这就是空间局部性。既然是这样，大家肯定能意识到了，CPU 会按照局部性原理来判断这些数据是不是近期自己一直需要的，所以当 CPU 访问内存的某个字节数据时，不仅会把该字节读取写入到高速缓存中，还会把该字节附近的数据一并读取放入高速缓存中。

好了，现在看第二个问题，当高速缓存中的数据不再被使用时，怎么从高速缓存中移除，这个很简单，其实也没什么移除不移除的，当有新的数据要被放到高速缓存中，而高速缓存空间不够的时候，只要判断哪些被缓存的数据最少被使用，就可以直接把这些数据覆盖了。这样就达到移除的效果。

好了，现在看第三个问题，CPU 一次会从内存中读取多少数据呢？准确的说，是读取多少字节呢？这个也没什么好分析的，就是 64 字节，因为在大多数计算机中，一个高速缓存行的大小就为 64 字节。说得再明确一些，假如 CPU 本次执行指令只需要一个字节大小的数据，而高速缓存中并没有这个数据，那么 CPU 就会去内存中读取这个字节，但根据第一个问题解答的局部性原理，CPU 本次访问内存并不会只读取 1 个字节，而是会把这 1 个字节附近连续的 64 个字节都读取了，然后填充满一个高速缓存行。这时候肯定会有朋友感到困惑，假如一个计算机是 64 位的，也就意味着它的数据总线是 64 位的，8 位为 1 个字节，64 位的数据总线一次最多只能传输 8 个字节，CPU 怎么可能一次读取 64 个字节呢？这其实也没什么好讲的，CPU 访问一次内存并不代表只从内存中读取一次数据，在这次访问内存的时候对读取几次数据不就行了吗？直到这些数据可以填充满一个缓存行了，本次访问内存就结束即可。当然，也许朋友们还会对高速缓存行感到疑惑。在前面还从未对高速缓存行做过铺垫，这个概念就直接出来了。所以接下来我会针对这个概念，为大家把高速缓存和内存之间的映射关系剖析一下。

**剖析高速缓存的工作原理**

在开始讲解高速缓存行这个概念之前，我想先问大家一个问题，如果让你来设计一个专门缓存内存数据的高速缓存系统，你会怎么设计？假如现在整块内存只有 8 个字节大小，现在我想在 CPU 和内存之间搭建一个高速缓存系统，我可能就会选择一种简单干脆的做法，那就是也设计一个 8 字节大小的高速缓存，这样内存中的每一个字节在高速缓存中有一个对应的位置。具体对应关系请看下图。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695377514602-e529f154-c78d-4bbe-85a6-7758cadac73b.jpeg)

请看上图，在处理器和内存中见，就是一个高速缓存系统，这个系统一共有 8 行，每行一个字节，所以总共可以存放 8 个字节。而现在内存的总容量就是 8 个字节，显然这个高速缓存完全可以容纳整个内存。接下来似乎就可以使用这个高速缓存系统了，假如现在 CPU 要使用内存地址为 0 处存放的数据，就可以去内存中把地址 0 处的数据读取出来，放到高速缓存中，以备之后使用。现在问题来了，当 CPU 获取到这个数据之后，要把它放到高速缓存的哪一行呢？我现在的想法很简单，放到哪一行都可以，反正就算把内存的 8 个字节全读取出来，高速缓存也可以一行存放一个。所以最后我就把内存地址为 0 的数据放到了高速缓存的第 5 行，把内存地址为 1 的数据放到了高速缓存的第 3 行，总之全是乱放的，没有一点规律。这样放当然没什么大问题，无非就是 CPU 去高速缓存中获取数据的时候麻烦一点，这个流程将是这样的：首先 CPU 肯定是得到了要获取的数据在内存中的地址，然后根据这个地址先去高速缓存中查看有没有对应的数据，如果高速缓存中没有，那就直接拿着这个内存地址去内存的对应地址获取数据。这个逻辑应该可以理解吧，要想获取一个数据肯定需要的是这个数据在内存中的地址，否则，当数据不在高速缓存中时，也没有内存地址，就无法去内存中获得对应数据了。所以，按照这个流程，想必大家也能推测出来，既然 CPU 要使用内存地址去高速缓存中获得对应的数据，或者是使用内存地址直接去内存中获得对应的数据，这就在一定程度上说明内存地址和高速缓存的行数应该有一定的联系。比如说，内存地址为 0 的数据直接存放到高速缓存的第 0 行，内存地址为 1 的数据，直接存放到高速缓存的第 1 行，这样依此类推。最终就是内存地址对应着每个数据各自的行号。而 CPU 在使用内存地址去高速缓存中获取数据的时候，只需根据内存地址即可确定行号，然后直接去对应的高速缓存行中获取那个字节即可。可是，现在我都他娘的是乱放的，这显然就很麻烦，至少得搞一张表来维护这个混乱的关系吧？所以，我就不乱放了，我也使用内存地址和高速缓存行一一对应，0 地址对应 0 行，就这样把内存的数据存放到高速缓存中。

如果按照上面的方式来实现高速缓存系统，我就真的感觉我也能上了。可惜的是，整个内存不可能只有 8 个字节，如果现在有一个新的要求，那就是整个内存不止 8 个字节了，而是变成了 16 个字节。现在要求我重构刚才设计好的高速缓存系统，我又该怎么办呢？这个变动还算简单，所以我也想简单重构一下就行，刚才每一个高速缓存行只能存放一个字节，把一个字节叫成一行显然有点不合适，所以这次重构我打算把高速缓存行扩容为两个字节，也就是说整个高速缓存还是 8 行，只不过每一行变成了 2 个字节。重构后的高速缓存行和内存地址的映射关系如下图所示，请看下图。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695381056075-7e1df5b0-1334-473b-ac12-e3fbceba43da.jpeg)

在上面的简图中，我们能看到，高速缓存行已经被扩充到了 2 个字节，而内存也扩容到了 16 个字节。现在每个高速缓存行对应两个字节，并且高速缓存存储字节的时候，是按照从左到右的顺序填充高速缓存行的。这么设计倒也挺简单的，但是我想请问大家，现在内存地址和高速缓存行的对应关系是怎样的？之前只存放 8 个字节的时候，每个地址对应一行，关系十分简单。现在是两个地址对应一行了，关系变成了怎样呢？从表面上看似乎根本看不出来，对吧。实际上，真正的内存地址和行号的对应关系，也不是直接就能看出来的，而是要把内存地址转换为二进制之后，才能发现规律。内存地址是用 4 个字节来表示的，所以转换成二进制后是 32 位。请大家看下面的代码块。

```
高速缓存第0行：0的二进制：0000 0000 0000 0000 0000 0000 0000 0000
             1的二进制：0000 0000 0000 0000 0000 0000 0000 0001

高速缓存第1行：2的二进制：0000 0000 0000 0000 0000 0000 0000 0010 
			 3的二进制：0000 0000 0000 0000 0000 0000 0000 0011

高速缓存第2行：4的二进制：0000 0000 0000 0000 0000 0000 0000 0100
			 5的二进制：0000 0000 0000 0000 0000 0000 0000 0101

高速缓存第3行：6的二进制：0000 0000 0000 0000 0000 0000 0000 0110
			 7的二进制：0000 0000 0000 0000 0000 0000 0000 0111

高速缓存第4行：8的二进制：0000 0000 0000 0000 0000 0000 0000 1000
			 9的二进制：0000 0000 0000 0000 0000 0000 0000 1001
```

在上面的代码块中，我只列出了前 5 个高速缓存行对应的内存地址的二进制表现形式。从第 0 行到第 4 行，然后把每一行存放的数据对应的内存地址以二进制的形式展示出来了。猛地一看也看不出什么，但是，让我们仔细地分析一下，首先请看高速缓存第 0 行对应的两个内存地址，地址 0 的二进制的最低位为 0，地址 1 的二进制的最低位为 1。而内存地址 0 存放的数据正好会放到高速缓存第 0 行的第 0 位，内存地址 1 存放的数据正好会被放到高速缓存第 0 行的第 1 位。如果单看二进制的最后一位，也就是那个最低位，高速缓存的每一行映射的两个内存地址，其最低位不是 0 就是 1。并且最低位是 0，对应的就是高速缓存行的第 0 个位置，第 0 个位置相对于整个高速缓存行来说，偏移量就是 0。最低位为 1，对应的就是高速缓存行的第 1 个位置，第 1 个位置相对于整个高速缓存行来说，其偏移量就是 1。看起来，这个地址二进制的最低位还挺有意思的。

当然，不止这个最低位的二进制有意思，我还发现，这个二进制地址的第 1 位、第 2 位、第 3 位也大有用处(注意，这里大家应该意识到二进制有 32 位，按顺序来说是从第 0 位到第 31 位)。如果把它们单独抽取出来，会发现一种很明显的规律。请大家看下面的代码块。

```
高速缓存第0行：0的二进制的<3-1位>：000
             1的二进制的<3-1位>：000

高速缓存第1行：2的二进制的<3-1位>：001
			 3的二进制的<3-1位>：001

高速缓存第2行：4的二进制的<3-1位>：010
			 5的二进制的<3-1位>：010

高速缓存第3行：6的二进制的<3-1位>：011
			 7的二进制的<3-1位>：011

高速缓存第4行：8的二进制的<3-1位>：100
			 9的二进制的<3-1位>：100
```

现在规律已经很明显了，这些地址的 <3-1> 位的二进制数值代表的就是它们各自的所在的高速缓存行数，并且位于同一高速缓存行的两个内存地址的 <3-1> 位的数值是完全相同的。就比如说内存地址为 4 的 <3-1> 位是 010，也就是二进制的 2，所以在高速缓存行的第 2 行，内存地址为 6 的 <3-1> 位是 011，也就是二进制的 3，所以该地址存储的数据会放在高速缓存行的第 3 行。这么一推测的话，好像通过每个内存地址的二进制的 <3-1> 位，就可以得到该地址存储的数据会映射到高速缓存的行数。而结合刚才讲过的二进制最低位的规律，**只要我知道了一个内存地址二进制的低四位，就可以先通过 <3-1> 位得到该内存地址映射到高速缓存行的行数，然后根据最低位，也就是二进制的第 0 位，就可以得到要存放的数据会存放到高速缓存行的哪个位置。**

举一个非常直接的例子，现在有一个内存地址是 14，转换为二进制后就是 0000 0000 0000 0000 0000 0000 0000 1110。根据这个二进制的 <3-1> 位，也就是 111，我们可以知道 111 就是二进制的 7，那么内存地址 14 就会被映射到高速缓存的第 7 行，而这个二进制的第 0 位是 0，意味着该内存地址存储的数据在高速缓存的第 7 行偏移量就为 0，就会被放到高速缓存第 7 行的第 0 位。这和上面那幅简图中呈现出的效果一摸一样。所以，我几乎可以断定，我就要掌握内存地址和高速缓存的映射关系了。但是，这时候情况又发生了变化，在我看来，我设计的高速缓存系统已经比较完美了，但是在真正的行家眼里，我知道我这个系统连小玩具都算不上。所以，我想进一步完善这个系统。在进一步完善之前，先让我们看看这个系统还存在哪些缺陷，其实缺陷也并不多了，只有一个，那就是目前的系统太整齐了，所谓整齐就是每一个高速缓存行都映射给了两个内存地址，并且只映射了一次。换句话说，现在我的内存只有 16 个字节，高速缓存也映射给了 16 个字节，但是高速缓存的容量肯定是远远小于内存的，如果内存的容量超过了高速缓存，高速缓存还怎么映射所有字节呢？比如我现在有一个新的内存大小，整个内存为 32 字节，高速缓存缩短为 4 行了，每行缓存 4 个字节，这样一来，高速缓存总共可以缓存 16 个字节，而内存有 32 个字节，这该怎么映射呢？

按照刚才分析的情况，很明显，高速缓存不可能一行只映射 4 个字节了，只有映射 8 个字节，才能把内存映射完整。那该怎么映射 8 个字节呢？很简单，就轮流着映射即可。具体实现请看下面的简图。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695439460777-d7dddeab-5147-4bb7-bc68-aebc63bd51de.jpeg)

在上面的简图中，我让高速缓存的每一行都映射了 8 个字节，当然， 并不是一次就映射 8 个字节，因为高速缓存行最多只能存放 4 个字节。具体的映射是这样的，拿高速缓存行的第 0 行来解释说明，那就是内存地址为 0-3 数据和地址为 16-19 的数据都会被映射到同一个高速缓存行中。如果 CPU 本次使用的是内存地址为 0-3 的数据，那就把这些数据从内存中取出，放到高速缓存中；假如不久之后要使用地址为 16-19 的数据了，那就会从内存中取出这些数据，直接把高速缓存第 0 行的数据覆盖了即可。这样不就做到了一个高速缓存行同时映射多个内存地址吗？如果这个逻辑大家都明白了，那么接下来我想以高速缓存的第 0 行和第 3 行为例，验证一下之前我摸索到的规律是否正确。下面我把地址的二进制展示下一，请看下面代码块。

```
高速缓存第0行：

第一组映射：0-3地址

0的二进制：0000 0000 0000 0000 0000 0000 0000 0000
             
1的二进制：0000 0000 0000 0000 0000 0000 0000 0001

2的二进制：0000 0000 0000 0000 0000 0000 0000 0010 

3的二进制：0000 0000 0000 0000 0000 0000 0000 0011


第二组映射：16-19地址

16的二进制：0000 0000 0000 0000 0000 0000 0001 0000
             
17的二进制：0000 0000 0000 0000 0000 0000 0001 0001

18的二进制：0000 0000 0000 0000 0000 0000 0001 0010

19的二进制：0000 0000 0000 0000 0000 0000 0001 0011



高速缓存第3行：

第一组映射：12-15地址

12的二进制：0000 0000 0000 0000 0000 0000 0000 1100
             
13的二进制：0000 0000 0000 0000 0000 0000 0000 1101

14的二进制：0000 0000 0000 0000 0000 0000 0000 1110

15的二进制：0000 0000 0000 0000 0000 0000 0000 1111


第二组映射：28-31地址

28的二进制：0000 0000 0000 0000 0000 0000 0001 1100
             
29的二进制：0000 0000 0000 0000 0000 0000 0001 1101

30的二进制：0000 0000 0000 0000 0000 0000 0001 1110

31的二进制：0000 0000 0000 0000 0000 0000 0001 1111



//多写一个地址32的二进制
0000 0000 0000 0000 0000 0000 0010 0000
```

当上面的二进制都列出来之后，我很快就发现此时仅凭二进制的第 0 位已经无法确定要存储的数据在高速缓存行中的偏移量了，也无法凭借二进制的 <3-1> 位确定内存地址要映射到第几个高速缓存行了。因为现在高速缓存行变成了 4 行，每一行存放的字节数变成了 4 个字节。既然是 4 个字节，偏移量肯定就不能用 1 个二进制位来表示，应该用两个才对。就像二进制的 1 位可以表示两个数，两位可以表示 4 个数，三位可以表示 8 个数，这个推算的逻辑大家应该可以理解吧？所以现在要计算内存中的数据要存放到高速缓存行的第几位，就不能再使用二进制的第 0 位来表示了，应该使用二进制的 <1-0>位来表示，两位能表示 4 个数，也就可以得到 4 个偏移量，正好对应了要被缓存的 4 个字节。比如说内存地址为 0 到 3 的数据，它们内存地址二进制的 <1-0> 位分别是 00，01，10，11，也就是二进制的 0，1，2，3。这不就是内存地址为 0 的数据在高速缓存行中的偏移量为 0，要放到高速缓存行的第 0 位吗？总之就是按照偏移量一一对应存放即可。这一点逻辑理清楚了之后，接着我就发现，现在也不必使用内存地址二进制的 <3-1> 位来计算内存地址要映射到高速缓存的第几行了，因为高速缓存只有 4 行了，显然不必再用 3 个二进制位来关联，只需要两个二进制位关联即可，也就是使用内存地址二进制的 <3-2> 位。然后我注意到，内存地址为 0 -3 的二进制的 <3-2> 位都为 00，也就是二进制的 0，所以 0 -3 内存地址的数据都存放在高速缓存的第一行；内存地址为 12-15 的二进制的 <3-2> 位都为 11，也就是二进制的 3，所以 12-15 的数据都存放在高速缓存的第 3 行。内存地址为 16 -19 的二进制的 <3-2> 位都为 00，所以它们也要映射到高速缓存的第 0 行。如果现在多出来一个内存地址是 32，32 的二进制的 <3-2> 位为 00，那么这个内存地址也要映射到高速缓存的第 0 行。

现在，我想我终于可以总结一下我自己的高速缓存系统是怎么映射内存地址的了。**第一点：高速缓存的行数和每行缓存的字节数应该为 2 的 N 次幂。第二点：如果高速缓存的行数和每行缓存的字节数为 2 的 N 次幂，那么就用二进制数的 N 位来计算内存要映射到的高速缓存的行数，用二进制数的 N 位来计算数据在高速缓存行中的存放偏移量。**

已经总结完了，现在我们就来看一个具体的例子。之前我也简单提了一下，很多计算机的一个高速缓存行可以缓存 64 字节。假如像这样的缓存行一共有 8 行，那么内存地址转换成 32 位的二进制后，这个二进制的低 6 位就可以用来表示存储在缓存行中的偏移量，因为 2 的 6 次方为 64。而这个二进制的低 7 位到低 9 为就可以用来关联该地址要映射到高速缓存的行数。请看下面代码块。

```
内存地址64的二进制： 0000 0000 0000 0000 0000 0000 0100 0000

内存地址127的二进制：0000 0000 0000 0000 0000 0000 0111 1111

在64的二进制中，<5-0>位为00 0000，就是二进制的0，表示内存地址为64的数据要存放到高速缓存行的第0位
<8-6>位为001，表示这个内存地址要存放到高速缓存行的第1行

在127的二进制中，<5-0>位为11 1111，就是二进制的63，表示内存地址为127的数据要存放到高速缓存行的第63位，
也就是最后一位。<8-6>位为001，表示这个内存地址要存放到高速缓存行的第1行

这样一来不正好是内存地址为 0-63 的数据存放到高速缓存行的第0行，内存地址 0-127 的数据存放到高速缓存的第1行

//这里多写一个16的二进制
0000 0000 0000 0000 0000 0000 0001 0000
该地址存储的数据会被缓存到高速缓存的第0行的第16位
```

我想上面代码块中的例子已经把高速缓存的工作原理解释得非常透彻了，当然，这个工作原理也仅仅是内存和高速缓存映射的方式。现在结合之前讲解的所有内容，包括什么局部性原理，让我再来为大家梳理一下高速缓存的工作原理。当 CPU 第一次需要某些数据的时候，会根据这个数据的内存地址去访问高速缓存，比如说这个数据的内存地址就是 16。CPU 中的硬件就会帮助我们解析这个内存地址的二进制，然后就知道内存地址 16 的数据会缓存到高速缓存的第 0 行，并且是第 0 行的第 16 位。于是 CPU 就会去高速缓存第 0 行第 16 位查找对应的数据。当然，这时候数据肯定没有被缓存到高速缓存中，查找不到的情况下，CPU 就会去内存中读取数据，虽然 CPU 只需要内存地址 16 的数据，但是根据空间局部性原理，会把该地址附近的数据一起读取了，然后写入到高速缓存中。而读取的规则就是 CPU 每次访问内存都会读取 64 个字节，也就是说每次读取的字节都要把一个缓存行填满。所以，虽然 CPU 只需要内存地址为 16 处的数据，但是它会把 0 - 63 的所有数据都读取了，也就是一次读取 64 个字节，把这 64 个字节放到高速缓存行的第 0 行，把这一行填满。这样，如果 CPU 紧接着就要使用内存地址为 25 的数据，这时候这个地址的数据已经被放到高速缓存行中了，所以直接就可以命中，不必再访问内存了。这个流程也比较清晰了，我想要大家理解也不是什么难题。

一切都看起来很完美，就在我想要完结的时候，我发现情况似乎并不是我想象的这样。现在还是让我们回到之前的那个例子，整个内存只有 32 个字节的情况，并且高速缓存只有 4 行，每行缓存 4 个字节，这样一来，高速缓存的每一行就要对应着两组地址。就像下面代码块呈现的这样。

```
高速缓存第0行：

第一组映射：0-3地址

0的二进制：0000 0000 0000 0000 0000 0000 0000 0000
             
1的二进制：0000 0000 0000 0000 0000 0000 0000 0001

2的二进制：0000 0000 0000 0000 0000 0000 0000 0010 

3的二进制：0000 0000 0000 0000 0000 0000 0000 0011


第二组映射：16-19地址

16的二进制：0000 0000 0000 0000 0000 0000 0001 0000
             
17的二进制：0000 0000 0000 0000 0000 0000 0001 0001

18的二进制：0000 0000 0000 0000 0000 0000 0001 0010

19的二进制：0000 0000 0000 0000 0000 0000 0001 0011
```

假如高速缓存的第 0 行已经缓存了内存地址为 0-3 的数据了，现在高速缓存需要使用内存地址 17 的数据，本来的流程应该是拿着 17 这个内存地址去高速缓存中查看，是不是缓存了这个地址的数据，现在肯定没有缓存，所以会去内存中把内存地址为 16-19 的数据全都读取出来，覆盖高速缓存的第 0 行。但是，现在 CPU 拿到 17 这个内存地址后，根据内存地址的 <1-0> 位和 <3-2> 位去解析，发现这个地址对应的数据已经被缓存到了高速缓存的第 0 行的第 1 位了，所以就会去高速缓存的这个位置获得数据。但我们都知道这个位置缓存的是内存地址为 1 的数据。这样一来程序就出错了。那该怎么解决这种情况呢？方法其实很简单，就是再给高速缓存的每一行多加一个标志位，用来区分被映射到同一行的内存地址的范围。而这个标志位填充的数据也很简单，就是内存地址的二进制数据剩下的位数。比如说内存地址 1 和内存地址 17。请看下面的代码块。

```
1的二进制： 0000 0000 0000 0000 0000 0000 0000 0001
17的二进制：0000 0000 0000 0000 0000 0000 0001 0001

//因为这两个内存地址的后四位是相同的，所以数据会被缓存到同一行的同一个位置
//但是这两个二进制剩下的数据并不是相同的
1的二进制剩下的位数为： 0000 0000 0000 0000 0000 0000 0000
17的二进制剩下的位数为：0000 0000 0000 0000 0000 0000 0001

//并且0-3的内存地址二进制的<31-4>位是完全一样的，而16-19的内存地址二进制的<31-4>位也是完全一样的

//所以，当高速缓存行缓存的是0-3的数据，就用0000 0000 0000 0000 0000 0000 0000来填充标志位
//这一个标志位就可以代表内存地址为0-3的数据都被缓存了

//当高速缓存行缓存的是16-19的数据，就用0000 0000 0000 0000 0000 0000 0001来填充标志位
//这一个标志位就可以代表内存地址为16-19的数据都被缓存了

//当CPU根据内存地址去访问高速缓存时，除了会解析内存地址的二进制来找到数据存放的高速缓存行以及行内的偏移量
//接着还会用这个地址剩下的二进制的位数和高速缓存行标记位中的二进制数值做对比，如果一样，说明此时缓存的数据
//就是真正需要的数据，如果不一样，说明真正需要的数据仍在内存中，还需要去内存中读取数据，然后把新的数据覆盖缓存行

//这时候缓存行的结构如下所示
｜行号｜标记位｜真正缓存数据的区域｜
```

好了，到此为止，我就为大家把一个简单的高速缓存的系统介绍完整了，它的内部构造以及映射内存地址的原理都涉及到了。当然，我想强调一下，我为大家介绍的这种高速缓存机制是最简单的一种，叫做直接映射高速缓存。这种缓存机制非常简单，但是有一个最大的缺点，那就是高速缓存的每一行映射了多组内存，如果需要的内存不同，那么这一行缓存的数据就会频繁变换，有可能刚才还使用地址 0-3 的数据呢，马上就变成内存地址 16-19 的数据了，等再需要 0-3 的数据时仍然需要从内存中读取，可是高速缓存的数据刚替换为 0-3 地址的数据，又需要 16-19 的数据了，然后又要去访问内存。就这样，高速缓存虽然存在，但是完全无法发挥作用。这种情况就被称为高速缓存颠簸。为了缓解这种情况，可以更换高速系统映射内存地址的机制，比如使用双路组相连高速缓存，或者是 N 路组相连高速缓存，也可以是全相连高速缓存。并且，高速缓存既可以和虚拟地址映射，也可以和物理地址映射。讲解这些内容显然超过了本章的知识范围，也是我力不能及的。与其做一个N手知识贩子，不如直接给大家提供知识源头。当然，这个知识源头也仅仅是一些书籍。除了一些大部头书籍，比如计算机操作系统以及计算机组成原理，我给大家推荐的书籍就轻薄很多了，叫做《现代体系结构上的UNIX系统——内核程序员的对称多处理和缓存技术》，这本书对高速缓存以及多核体系下的高速缓存技术做了比较详细的讲解，对高速缓存的一致性也做了详细的讲解。当然，从名字就可以看出来，这本书显然不是为业务程序员创作的，我的建议是，大家可以把这本书放在身边，偶尔读一读，或者就不读，等遇到高速缓存方面的困难了，你知道这本书里可能有解决的答案，然后再翻看这本书就行。这是本老书了，应该也是将近十年前的书，已经绝版了，大家感兴趣的话，可以搜一搜，看看有没有二手的，或者是影印版的。

好了，话题已经扯得太远了。不管怎么说，总之我设计的高速缓存系统，已经可以按照这种简单的机制正常缓存了，如果不同范围的内存地址的数据要缓存到同一个高速缓存行，那么只需要把旧的数据替换掉就行了。很好，终于说到替换了，这就可以引出新的问题，也就是在 Disruptor 框架中需要解决的问题。这就要从多核处理器说起了。但这一章显然是讲不完了，我们下一章再见！

注：一定要看这一句呀，本章中提到的内存访问的地址都是为了讲解方便，在真正的内存访问中，考虑到字节内存对齐，CPU 是不会读奇数地址访问的，大多数计算机平台都要求 CPU 访问内存时使用偶数地址来访问，具体原因下一章就会为大家讲解。