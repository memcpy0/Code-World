大家好，上一章我为大家简单介绍了高速缓存的一些知识，并且为大家介绍了一本这方面的书籍。应该承认，我介绍的知识非常简单，基本上都是从书上学来的。如果稍微自夸一下，我介绍的那点知识也算是对那本书的起到了一个抛砖引入的作用。这一章，我将继续为大家讲解解决高速缓存伪共享的知识，并且围绕着这个知识，看看 Java 对象的属性在内存中是怎样排序的，以及所谓的内存对齐是什么，为什么要对齐，应该怎样对齐。好了，话不多说，直接开始本章内容吧。

**多核处理器体系下的高速缓存结构**

在上一章的结尾，我记得我设计的高速缓存系统，已经可以按照简单的机制正常缓存内存中的数据了，如果不同范围的内存地址的数据要缓存到同一个高速缓存行，那么只需要把旧的数据替换掉就行了。但是我又对大家说，问题就出在替换这里，为大家引出了多核处理器体系。所以这一章我们就以此为起点，开始讲解我们的内容。

实际上在上一节课讲解的所有内容，有一个大的前提，那就是我们讲解的是单核处理器中的高速缓存机制。如果是多核处理器中的高速缓存，那么就会有一点变动。当然，内存地址和高速缓存行映射的机制并没有改变，只不过现在是多核处理器了，这就意味着每个处理器的每个核心都会读取内存中的数据。说的直接一点，在多核体系中，处理器的每个内核都有自己的高速缓存。现在高速缓存和处理器的结构就变成了下面这样，请看下面这幅简图。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695464761839-1e1a2694-d97b-48a6-9758-9eea4a023977.jpeg)

在上图中可以看到，高速缓存体系已经发生了变化，现在是处理器的每个核都拥有自己的高速缓存了，如果计算机是双核的，那么每个核都拥有自己私有的 L1 和 L2 高速缓存，但是 L3 高速缓存会被两个核共享。如果这个知识大家理解了，那么接下来，我先为大家简单讲解一下，高速缓存在 CPU 和内存之间发挥的另一种功能，当 CPU 获取了内存的数据后，经过计算得到了某个值，现在要把这个值写回内存了。但是 CPU 不一定真的会立刻把这个值写回内存。其实大家可以简单想想，之所以引入高速缓存组件，就是为了让 CPU 尽量少和内存打交道，因为访问内存的速度比较慢。现在引入了高速缓存，终于可以不必每次读取数据的时候访问内存了，但是要将计算的值写回内存，并且是每次都写回，这样一来，不就又回到老路了吗？CPU 还是要频繁访问内存呀。所以，为了避免这种情况，两种缓存策略就应运而生了。第一种为写直通策略，如果采用这种策略，那么 CPU 每次都会把计算出的结果或者是修改了的新值在写回高速缓存的同时，也直接写回内存，这样才能保持缓存一致，也就是高速缓存和内存中的数据永远一致。第二种策略为写回策略，如果采用这种策略，那么 CPU 每次计算出一个新值或者把某个旧值修改了，并不会立刻写到内存中，而是先缓存到高速缓存的对应行中，等高速缓存这一行的数据要被替换了，或者是某些其他的原因(这个其他的原因很快就会讲解)，才会将新值写回到内存中。显然，写回策略在性能上是优于第一种性能的，因此写回策略是大多数计算机高速缓存系统采用的策略。

以上就是对两种策略的简单讲解(其实整个过程还要比我讲解的复杂一些，还要考虑高速缓存是否写命中的问题，在这里就不再讲解了)。这时候可能有朋友会感到好奇，为什么非要把新值写到内存中呢，就一直留在高速缓存中不行吗，这样使用的时候可以立即获得？原因其实也很简单，第一点：高速缓存的容量是有限的，每个数据的缓存都和该数据的内存地址一一映射，每一个缓存行会映射不同的内存范围。所以，当不同的内存范围中的数据需要被缓存时，就会替换掉高速缓存行的旧数据，如果这些旧数据和内存中的数据一致，也就是没被 CPU 修改过，那么就会直接替换，并不需要把旧数据写回内存；如果这些旧数据被 CPU 修改过，显然就和内存中原本的数据不相同了，如果直接替换而不把最新的数据写回内存，那么这些数据就要丢失了。那么怎么判断高速缓存行的数据在被替换的时候，需不需要写入内存呢？这时候就应该给高速缓存行的结构在增加一个新的标志位了。实际上每一个高速缓存行都有一个单独的标志位，用一个 bit 表示，当其为 0 的时候，就说明是无效的，当其为 1 的时候，就说明这行数据是有效的，当然，在某些高速缓存系统中可能还会有修改位，也叫做脏位，也是 1 个 bit ，以表示该缓存行中的数据是否被 CPU 修改过。为了简单方便，我就为大家把有效位和修改位都加上(真正的实现方式并不是我这样的，但是本质是一样的，所以我就按最简单的方式来讲解了，毕竟高速缓存体系并不是我们的重点)，所以现在高速缓存行的结构就变成下面这样。请看下面代码块。

```
｜有效位｜修改位｜行号｜标志位｜有效数据区｜

//假如有效位为0，就意味着该行缓存的数据是无效的，有效位是1，意味着该行缓存的数据是有效的，当高速缓存
//刚刚初始化时，所有行的有效位都是0，因为根本没有缓存数据，当然是无效的。只有当存放数据后，有效位
//才会被修改为1。当有效位引入后，CPU从高速缓存中获取数据，在找到了数据对应的缓存行后
//首先会判断该缓存行是否有效，无效的话就去访问内存了
//修改位是0，意味着该行的数据没有被修改过，修改位是1意味着该行的数据被修改过

//在这种情况下，如果一个高速缓存行的修改位是1了，说明CPU修改过这一行的数据，那么这些数据和内存中的
//数据就不一致，如果这时候这一行的数据要被新的数据替换，就必须要先把修改过的数据写回到内存中，这样才能保证数据不丢失
```

如果第一点原因大家都理解了，那么记下来就来看看第二点原因。在多核处理器体系中，程序的执行并不是单线程的，而是多线程，这就意味着处理器的每一个核心都会同时工作，如果核心有两个，那么这两个核心很可能会先后都执行过 1 + 2 这行代码，并且还会执行很多次。这样一来，核心一和核心二就会把 1 和 2 这两个数据都会缓存到自己私有的高速缓存中。因为 1 和 2 在内存中的地址是唯一的，比如地址就是 0 和 1，那么这两个数值在每行缓存 64 字节的高速缓存体系下，一定会被缓存到同一个缓存行，也就是每个核心各自高速缓存的第 0 行。以后这两个核心执行 1 + 2 这行代码时就不必再访问内存了，都使用给自高速缓存中的数据即可。但是假如某个时刻，核心一忽然将数据 1 修改为数据 3 了，这也就意味着 1 + 2 这行代码不会再执行了，取而代之的是执行 3 + 2 这行代码。这时候问题就来了，核心一已经把数据改变了，并且根据高速缓存的写回策略，改变的数据是要放到核心一的高速缓存中的，核心二并不知道，如果核心二仍然执行 1 + 2 这行代码，程序显然就出错了。所以，这时候核心一，就会通过总线通知核心二，它的高速缓存的第 0 行的数据已经失效了，核心二高速缓存行的第 0 行的有效位会被修改为 0。当核心二要使用 1 这个数据时，就会去自己的高速缓存第 0 行中获取数据，但这时候第 0 行的有效位被修改为 0 了，这时候核心二就知道自己的缓存行失效了，于是就会去访问内存，获得最新的数据 3 。但这时候内存中的数据还没有被核心一更新呢，最新的数据还在核心一的高速缓存中存放着，所以这时候核心二就会通过总线通知核心一，让核心一把最新的数据更新到内存。接下来，核心一就会把数据更新到内存了。这就是为什么新值必须要在合适的时机写回内存的第二点原因。

**引出伪共享问题**

如果上面的流程大家都理解了，接下来，我们就来看看多核体系下的高速缓存机制会为程序带来什么问题，以及如何解决这个问题。请大家先看下面的代码块。

```
public class FalseSharing {

    private int a = 18;

    private int b = 20;

    
}
```

在上面的代码块的 FalseSharing 类中，有两个成员变量一个是 a 一个是 b，如果要在堆中创建一个 FalseSharing 类的对象，就把这个对象称为 sharing 吧，并且整个程序中 FalseSharing 类型的对象只有这一个。那么该对象中的字段 a 和 b在内存中也会只有一份，内存地址也是唯一的。假如这个程序执行在双核处理器的计算机中，第一个核心在执行程序的时候需要使用 a 对应的数据，另一个核心在执行程序的时候只会使用 b 对应的数据，假如 a 和 b 的内存地址分别为 0 和 1，根据局部性原理，尽管这两个核心各自只需要其中一个数据，却仍然需要把这两个数据读都取到各自的高速缓存。 根据内存地址来判断，a 和 b 肯定会被缓存到同一个缓存行中，那么这两个变量的数据会被缓存到每个核心私有的高速缓存相同的缓存行中。如果 CPU 对这些数据永远是只读的，那一切就都好说。但现在的情况是，每个核心都会非常频繁地修改各自需要的数据。具体情况请看下图。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695479349527-9319c3be-1b25-4583-9094-53d83e639780.jpeg)

在上面的简图中，我为大家把伪共享的问题解释清楚了，既然问题已经暴露出来了，那么该怎么解决这个问题呢？在我想到这个问题的时候，我脑海里其实就立刻涌现出了一个想法，在现代计算机中，缓存行几乎都是 64 字节的。 刚才这两个变量都是 int，总共是 8 个字节。导致这个问题的原因很简单，就是这两个变量共享同一个缓存行了，只要让这两个变量分到两个缓存行中不就行了吗，这样就算其中一个改变了，另一个也不会受影响，因为在两个不同的缓存行呀。接着我又想到了，在堆中创建了一个对象，这个对象内部的字段，这些数据的内存地址都是连续的，而一个高速缓存行的大小是 64 字节。这就很好办了，我在这两个变量中间插入一些字段，将它们隔开不就完了？那该插入多少个字节呢？显然是插入 60 个字节，这 60 个字节可以用 15 个 int 来表示。就像下面代码块展示的这样。请看下面代码块。

```
public class FalseSharing {

    private int a = 18;

    private int p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15;
    
    private int b = 20;

    
}
```

虽然我在这两个成员变量之间插入的这 15 个 int 字段并没有赋值，但是对象在堆中创建的时候，依然会为这些字段分配内存，只不过内存数据全是 0 而已。现在我已经用 60 个字节将它们隔开了。这样，就算考虑到局部性原理，如果从变量 a 的内存地址恰好映射到高速缓存行的第一位了，那么它后面还有 60 个字节呢，a 是 4 个字节，加起来是 64 个字节，正好占满一个缓存行，变量 b 对应的数据不管缓存到高速缓存的哪个缓存行，反正肯定不会和 a 在同一个缓存行了。如果变量 a 的内存地址恰好映射到高速缓存行的最后一位，这样就更好了，再向缓存行中读取数据，肯定是新挑选一行来缓存了。这两个变量更不会存放到同一行了。我觉得这样就可以了，但是转念又一想，我现在只考虑到 a 和 b 这两个变量了，但是程序中显然有很多对象，程序员也不知道哪个对象和哪个对象在内存中挨着，也不知道那些变量缓存到高速缓存后会出现伪共享问题。现在我就希望不要有其它数据来干扰 a 和 b 这两个变量，因为这两个变量会被频繁使用，和其他任何数据共享缓存行，都可能出现伪共享问题。因此，我又想到了一个极好的解决方法，那就是让变量 a 和 b 各自独占一个缓存行。这样一来，我就需要在 FalseSharing 类中再添加一些成员变量，具体实现请看下面代码块。

```
public class FalseSharing {

    private int p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30;

    private int a = 18;

    private int p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15;
    
    private int b = 20;

    private int p31, p32, p33, p34, p35, p36, p37, p38, p39, p40, p41, p42, p43, p44, p45;
    
}
```

诸位请看，我在变量 a 之前又增添了 15 个 int 变量，一共 60 个字节，在变量 b 之后又增添了 15 个 int 变量，一共 60 个字节。这样一来，不管怎么组合，变量 a 和变量 b 肯定都是各自独占一个缓存行。没有其他任何数据能影响它们了，这样，程序执行起来也就快了。这就是填充无效字节解决伪共享的方法。这么做的好处已经说过了，那就是没有伪共享烦恼，程序执行也会快一些。但缺点也是显而易见的，在缓存行中填充了大量无效字节，对极其宝贵的缓存行资源来说显然是一种浪费，其他本可以使用缓存行缓存的数据，可能就不能很方便的放到缓存行中了。这样算是一种空间换时间的编程思想的运用吧。

当然，我的程序还没有重构完整，因为我自己也意识到了，现在这个 FalseSharing 类的内部结构太乱了，填充了太多 int 字段，看得我眼花缭乱，我想减少一些字段，但是填充的字节总数仍然不变。这个也很简单，直接填充 long 字段不就好了吗？一个 long 字段占 8 个字节，可比填充 int 字段省事多了。那么我填充几个 long 字段呢？这个只好计算一下了，要在变量 a 和 b 之间和前后各填充 60 个字节，一个 long 是 8 字节，7 个 long 就是 56 个字节，还剩下 4 个字节，没办法，只好用 int 来填充吧。所以，改动之后，FalseSharing 类就会变成下面这样，请看下面代码块。

```
public class FalseSharing {

    private long p1, p2, p3, p4, p5, p6, p7;

    private int i;
	//上面的无效字节正好凑够了60个字节
    
    private int a = 18;

    //下面的两行无效字节正好凑够了60个字节
    private int h;
    
    private long p8, p9, p10, p11, p12, p13, p14;

    //上面的两行无效字节正好凑够了60个字节
    private int b = 20;

    //下面的两行无效字节正好凑够了60个字节
    private int j;
    
    private long p15, p16, p17, p18, p19, p20, p21;

    
    public static void main(String[] args) {

        FalseSharing falseSharing = new FalseSharing();
        System.out.println(falseSharing);

    }
    
}
```

这样应该就万无一失了吧，虽然重构之后，添加的字段更加眼花缭乱了(狗头)。重构之后填充的无效字节数和之前一摸一样，肯定也可以起到解决伪共享问题的作用吧？但我可以很明确的告诉大家，这样填充字节根本解决不了伪共享问题，反而会让变量 a 和 b 共享同一个缓存行的几率大大增加。当然，口说无凭，这就要从 Java 对象的字段在内存的排序规则说起了。在讲解之前呢，请大家先跟我看下面的图片。在下面的图片中，我使用 Java 的 HSDB 工具为大家呈现出了上面这个类的对象，其内部字段在内存中是如何排序的。这里我使用的 Win 系统下的 HSDB 工具，我在 Mac 中使用了多个版本，都出现了不兼容的问题，所以只好切换到 Win 系统中了。大家测试的时候可以直接在 Win 系统中测试。请看下面的图片。

![](https://cdn.nlark.com/yuque/0/2023/png/26725125/1695529071620-e54cb646-6cca-47a9-a6bf-0f45c0a3581d.png)在上面的图片中，我从 HSDB 中找到了 FalseSharing 类型的对象 falseSharing 其内部字段在内存中的排序情况，下面我就把各个字段的内存偏移量为大家呈现出来。

![](https://cdn.nlark.com/yuque/0/2023/png/26725125/1695529270441-729578bc-8320-4535-98dc-b20e5334244d.png)

从上面的图片中可以看出，FalseSharing 类中声明的第一个成员变量 p1，按照顺序排在了 falseSharing 对象内部的第一位。括号里表明了 p1 在 falseSharing 对象中的内存偏移量。这里为什么是偏移 16 呢？因为在不开启指针压缩的情况下，一个 Java 对象的对象头是 16 字节，所以堆中的一个对象，要先占用 16 个自己存放自己的对象头，然后才能存放自己的内部的字段。对象头这些知识应该就不用讲解了吧？应该是老八股了吧。都怪我太自己为是了，因为我接着往下看，很快就发现变量 i，它是一个 int，它在对象中的内存偏移量竟然是 12。这个 12 是怎么来的呀，对象头不是已经占了 16 个字节吗，难道这个 int 在对象头中吗？然后我接着往下看，发现对象中字段在内存的偏移量根本不是按照我声明字段的顺序来排列的，而且最要命的是，两个 int 变量 a 和 b 他们的偏移量一个是 184，一个是 192，中间就隔着 8 个字节。之前我们分析过，只有当变量 a 和 b 之间间隔 60 个字节的时候，才能保证这两个变量一定不会共享同一个缓存行，现在它们两个怎么只间隔了 8 个字节呢？我可是填充了非常多的无效字节的呀？如果简单画一下 falseSharing 对象的内存分配图，大概情况就是下图展示的这样。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695530754669-ff4bde2a-0f0e-4593-9e6c-c27f68f600b2.jpeg)

之所以会出现上图中的情况，这就要从字节内存对齐来说起了。

**字节内存对齐规则**

所谓字节内存对齐其实很简单，一句话就能讲解清楚，那就是在计算机中，给一个变量分配内存，其内存地址正好为这个变量长度的整数倍，这种情况下，我们就称内存对齐了。举个例子，如果一个变量是 int，int 的长度或者说大小为 4 个字节，而一个内存地址就代表一个字节，所以给这个变量分配内存的时候，其地址必须是 4 个整数倍，所以我们可以为这个 int 变量分配内存地址 0，也可以分配内存地址 4，也可以分配内存地址 8，但不能分配内存地址 1、2、3、5、6、7······这些值，因为它们都不是 4 的倍数。

在如今的计算机平台上，有一个被广泛应用的内存对齐规则，我列在下面代码块中了。请看下面代码块。

```
char变量只占用一个字节(在C语言中站1个字节)，所以char变量按照1字节对齐即可   分配地址可以任意分配，因为每个地址都代表1字节，是1的倍数
short变量只占用两个字节，所以short变量按照2字节对齐即可 分配地址按照2字节对齐，只能分配2倍数的地址，0、2、4、6、8······	
int变量占用4字节，所以int变量按照4字节对齐    分配地址按照4字节对齐，只能分配4倍数的地址   0、4、8、12、16······     
long变量占用8字节，所以long变量按照8字节对齐  分配地址按照8字节对齐，只能分配8倍数的地址   0、8、16、32、40·····
总结下来就是，该变量的大小是多少，那么就按照这个值对齐即可
```

了解了上面那个规则之后，大家肯定会有一个疑问，为什么要进行内存对齐呢？我最初也有这个疑问，因为内存本来就是一个地址代表一个字节，如果我想给一个 int 分配变量，如果内存的前 3 位都被使用了，也就是地址 0、1、2 不能分配了，那我直接分配地址 3，然后存放这个 int 不就行了吗？这样就从内存地址 3-6 给 int 使用了。然后 CPU 访问内存的时候，如果需要这个 int 变量，直接从内存地址 3 开始读取，读到地址 6 不就行了吗？这不就把这个 int 读取到了吗？这么分配内存当然可以，应该说这样分配内存才会最大程度的利用内存，很可惜，在很多计算机中都不是这么设计的。在大多数计算机平台中，都是要求内存对齐的，这和 CPU 读取内存的规则有关。比如说，有的平台就要求 CPU 读取内存是按照偶数地址来读取的，要求 CPU 按照 4 的倍数读取，比如说 32 位的计算机平台。如果一个计算机的总线是 32 位的，8 位是一个字节，这就意味着这个计算机一次可以在总线上传输 4 个字节。如果按照 4 的倍数读取，这就意味着 CPU 每次访问内存，都可以读取 4 个字节，并且访问的内存地址也是规划好的，如果要访问 2 这个内存地址的数据，CPU 就会从地址 0 开始访问，把 0-3 地址的数据都读取了，正好是 4 个字节。如果要访问 9 这个地址的数据，那么 CPU 就会从地址 8 开始访问，把 8-11 地址的数据都读取了。如果遵循 CPU 访问内存的原则，那么最好就让数据做到内存对齐，给一个 int 分配地址时，就按照 4 的整数倍来分配。这样，CPU 一次就可以把这个 int 全部都去走。如果并不是按照 4 的整数倍来给 int 分配地址，比如就给一个 int 从地址 2 分配内存，到地址 5 结束。CPU 读取这个 int 的时候，就会先读取地址 0-3 的数据，然后解析出这 4 个字节的后两个字节，然后再读取地址 4-7 的数据，解析出这 4 个字节中的前两个字节，最后拼成一个完整的 int。这样一来，岂不是就要读取两次内存才能获得这个 int 吗？显然有点麻烦了。所以，在这种情况下，内存对齐显然是很有必要的。

但是，分析了这么多，我还是有一个疑问，如果一个计算机是 32 位的，反正每次只能读取 4 个字节，那为什么就不能让它随意读取呢？为什么就非要规定它只能读取偶数地址呢？曾经我也百思不得其解，后来我忽然意识到，这个也许就是硬件层面的问题，比如说内存芯片的设计导致了字节在内存中必须对齐，甚至还和高速缓存有关系。很可惜，我对硬件这方面研究甚少，所以也只能给大家讲解一个大概，但眼下不是讲解这个原因的好时候，具体解释，放在文章的最后了。

好了，还是回到 Java 本身来吧，现在我们都已经对内存对齐有了基本了解，那么，就让我们来探讨一下，当内存没有对齐的时候会怎么办呢？做法很简单，既然内存没有对齐，就把它补齐即可。接下来，就让我来给大家举一个具体的例子，来看看所谓的把内存补齐是什么意思。让我们先抛弃 Java 对象头的概念，假如现在就有一个 Java 对象其内部有 3 个成员变量，具体情况请看下面代码块。

```
byte a;
long b;
byte c;
int  d;
```

在这个对象中有以上三个字段，假如现在的内存是一片空白，可以直接从内存地址 0 开始分配内存。那么就可以按照下面这种顺序给对象中的三个成员变量分配内存。请看下面代码块。

```
1：要创建对象了，首先要申请一块连续的内存，用来存放对象。
2：按照字段声明的顺序给这些字段在内存中排序
3：按照内存对齐原则，把内存补齐
```

该对象字段的内存分布如下图所示。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695545755972-d1fbe256-5458-4a6d-8aad-c0cf6ddd439c.jpeg)

所谓内存补齐，就是上面这种情况了。可以看到，本来这几个字段只需要占用 14 个字节即可，可是为了字节内存对齐，不得不多占用 10 个字节，简直是浪费呀。那有没有什么方法能够使内存占用的少一些呢？如果没有头绪，不妨就自己随便探索探索。比如，先试试把相同类型的字段放到一起，然后再按照声明的顺序在内存中分配内存。如果是这样的话，在上面那些字段中，a 和 c 就要放到一起了，然后才是 b 和 d。这样一来，这几个字段在内存中的分布就变成了下面这样。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695545757827-81f42dd7-db1d-414e-bcc0-98991e0dfa30.jpeg)

上图展示的情况似乎稍微好了一些，但是我仍然不满足，我总觉得这几个字段还可以占用更少的内存。我准备先认真分析一下，因为我渐渐意识到，有一种情况是不必内存补齐的，比如说，让 int 变量在 long 变量之后分配内存，肯定就不需要内存补齐了，因为内存肯定是对其的。原因很简单，既然 long 整数一定是按照 8 的倍数来分配内存地址，8 的倍数肯定是 4 的倍数，所以，在 long 整数之后分配内存，那个内存地址一定可以被 4 整除，所以把 int 分配在 long 之后，天然就是内存对齐的。同样的道理，short 分配在 int 后面，一定也是天然对齐的，short 之后再给 byte 分配内存，反正 byte 的内存地址没什么对齐限制。这样一来，我想就可以进一步节省空间了吧？如果按照这种顺序来分配内存，这几个字段在内存中的分布就变成了下面这样。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695544688570-d8ea204c-7443-431b-b05c-c2ac03675a99.jpeg)

按照上面那种排序方式，最终这 4 个字段占用的内存终于变成了 14 个字节。现在我终于可以跟大家总结一下了，刚才我讲解的分配顺序，其实就是 JVM 为 Java 对象内部字段分配内存的方式。实际上，在 JVM 中是没有 byte、boolean、char、int、long····这八种基本数据类型的，取而代之的是 byte、short、word、double 以及 oop。其中 byte 就对应了 Java 基本数据类型中的 boolean 和 byte，大小为 1 个字节；short 对应的基本数据类型就是 char 和 short，大小为两个字节；word 对应的是基本数据类型是 int 和 float，大小为 4 个字节；double 对应的基本数据类型是 long 和 double，大小为 8 个字节。而 oop 对应的就是引用类型，在 64 位计算机平台中，如果开启了指针压缩，oop 的大小为 4 个字节，否则为 8 个字节。

了解了这个映射模式后，我就来为大家简单总结一下，JVM 在给 Java 对象中的字段排序时，首先会把相同类型的字段放到一起，就像上面，我把两个 byte 放到了一起。然后会按照 double——>word——>short——>byte——>oop 顺序开始分配内存；也可能按照 oop——>double——>word——>short——>byte 的顺序分配内存，这里我们只讨论第一种。当然，我们上面的例子并没有涉及 oop，但是按照我为大家总结的这个分配顺序，显然是可以和上面第三种字段分配属性的顺序对应上的。到这里，我就把 JVM 为 Java 对象的字段分配内存的规则讲解完毕了。当然，还有两个小知识点没有讲解。

第一个就是 所有的 Java 对象在内存中都是按照 8 字节对齐的。如果是这样的话，上面第三种为字段分配内存的情况就要变成下面这样了。请看下图。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695548004913-be67e3c1-1a72-4313-99d9-c8c807d5a00d.jpeg)

现在又多出来一条规矩，为了 Java 对象在内存中是按照 8 字节对齐的，所以又要填充一些无效字节。之前这 4 个字段占用 14 个字节，如果不考虑对象头，那么这个对象占用的内存地址为 0 - 13，如果程序中创建新的对象了，需要申请内存，就要把 14 这个内存地址分配出去，14 显然不是 8 的倍数，所以，就要在两个 byte 字节后面再填充两个字节，好让后面对象分配的时候可以内存对齐。那么，为什么要让对象按照 16 字节内存对齐呢？这和之前的道理一样，就是为了提高 CPU 访问对象的效率，就不再细讲了。

第二个小知识就是要考虑对象头的大小，一个完整的对象怎么能没有对象头呢？众所周知，再不开启指针压缩的情况下，对象头的大小为 16 字节，开启了指针压缩后，对象头的大小是 12 字节。我的 JVM 是开启了指针压缩的。如果还是之前这 4 个字段，现在要考虑对象头的情况了，那么它们的顺序该怎么排列呢？

```
byte a;
long b;
byte c;
int  d;
```

还是按照 JVM 给字段分配内存的规则来分析，首先把两个 byte 放在一起排列，然后把 long 放在最前面分配内存，其次是 int，最后是那两个 byte。而且现在加上了对象头，对象头为 12 字节，所以，按照常理来分析，会像下面这样来分配。请看下图。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695548007104-18a25404-0685-4a4d-9fcf-4676b6a72271.jpeg)

本来应该如上图所示的那样分配内存对吧？但是 JVM 对这种情况的内存分配做了一点优化，那就是反正对象头后面需要填充 4 个无效字节，那我还不如直接把对象中小于等于 4 个字节的字段分配在这里呢。所以，具体的分配情况就会变成下面这样。

```
|对象头12个字节|int变量d|long变量b|byte变量a和c|填充无效字节为了对象按8字节对齐
```

当然，口说无凭，我把这几个字段在对象中的偏移量用 HSDB 展示给大家看。请看下面图片。

![](https://cdn.nlark.com/yuque/0/2023/png/26725125/1695548575240-bc61b136-db3e-4c81-bb3f-686abf323180.png)

可以看到，d 的偏移量为 12，也就意味着它正好分配在 12 个字节的对象头后面，代替了无效字节的填充， b 的偏移量为 16，正好分配在 int 后面，剩下的就是两个 byte。这时候可能有朋友会问，如果对象中并没有 int 字段，只有一个 long 和两个 byte 呢？这也很好分析，那就把两个 byte 放到 对象头后面，然后在两个 byte 后面填充两个无效字节即可，接着再给 long 分配内存。具体实现如下。

```
|对象头12个字节|两个byte变量|填充两个无效字节|long变量|12+2+2+8=24，
24正好为8的倍数，所以对象已经按照8字节内存对齐了，不必再填充无效字节
```

到此为止，我相信大家应该也能理解了，为什么最开始那个例子中有一个 int 的偏移量为 12 了吧？好了，到此为止，我就把字节对齐以及 JVM 给字段排序的规则全部讲解完毕了。那么现在让我们回到最开始的那个例子，请看下面代码块。

```
public class FalseSharing {

    private long p1, p2, p3, p4, p5, p6, p7;

    private int i;
	//上面的无效字节正好凑够了60个字节
    
    private int a = 18;

    //下面的两行无效字节正好凑够了60个字节
    private int h;
    
    private long p8, p9, p10, p11, p12, p13, p14;

    //上面的两行无效字节正好凑够了60个字节
    private int b = 20;

    //下面的两行无效字节正好凑够了60个字节
    private int j;
    
    private long p15, p16, p17, p18, p19, p20, p21;

    
    public static void main(String[] args) {

        FalseSharing falseSharing = new FalseSharing();
        System.out.println(falseSharing);

    }
    
}
```

现在我们都知道了 JVM 在内存中给字段排序的规则，也就知道了到底该怎么填充无效字节，才能真正让两个字段真的间隔 60 个字节。按照上面代码块中的方法显然是不对的，如果都用 int 来填充，当然是可以的，但是还有一种最优的方法，那就是把要隔离的两个变量定义为 long 基本类型，然后填充 long 基本类型的无效字节。请看下面代码块。

```
public class FalseSharing {

    private long p1, p2, p3, p4, p5, p6, p7;

    private long a = 18;

    private long p8, p9, p10, p11, p12, p13, p14;

    private long b = 20;
    
    private long p15, p16, p17, p18, p19, p20, p21;

    
    public static void main(String[] args) {

        FalseSharing falseSharing = new FalseSharing();
        System.out.println(falseSharing);

    }
    
}
```

重构完之后请看下图。

![](https://cdn.nlark.com/yuque/0/2023/png/26725125/1695549391288-6c279894-f91a-4f46-a91d-dd18d76063f2.png)

变量 a 和变量 b 的偏移量正好相差 64 个字节，这意味着它们两个绝对不会共享一个缓存行了。不过话说回来，我上面的那个例子还是有些复杂了，在 Disruptor 框架中没有这么复杂，实际上，Disruptor 框架中仅仅是对一个字段做了无效字节填充的处理，意思就是只让这一个字段占据一个缓存行，其他数据别来干扰它就行。具体情况请看下面代码块。

```
public class FalseSharing {

    private long p1, p2, p3, p4, p5, p6, p7;

    private long a = 18;

    private long p8, p9, p10, p11, p12, p13, p14;
    
}
```

如上面代码块所示，只要保证变量 a 不被其他数据干扰，独占一个缓存行即可。所以，就在变量 a 前后各填充了 7 个 long 字段，这样不管 a 和哪一行的字段被一起读取了，都能保证变量 a 独占一个缓存行。这种写法其实就可以了，但是在 Disruptor 中，实际上并不是这么写的，它创建了三个具有父子关系的类，然后把无效字节填充到父类和子类中，有效数据，也就是不被干扰的数据放在了中间类。具体情况请看下面代码块。

```
public class FalseSharing {

    private long p1, p2, p3, p4, p5, p6, p7;


    static class value extends FalseSharing{
        private long a = 18;
    }

    static class Sharing extends value{

        private long p8, p9, p10, p11, p12, p13, p14;


    	//用于HSDB测试
        public static void main(String[] args) {

            Sharing sharing = new Sharing();
            System.out.println(sharing);

        }
    }
}
```

可以看到，在上面的代码块中，我定义了一个 FalseSharing 父类，在这个父类之下创建了一个 value 子类，用这个子类对象来存放真正的有效数据，然后又定义了一个 Sharing 类继承了 value。同时我把无效字节填充到了 FalseSharing 和 Sharing 类中。这种做法其实根本没什么深意，只不过是在 JVM 虚拟机中，子类的对象会继承父类所有的字段，这里说的继承，指的是子类对象会子内部为父类字段开辟内存，就相当于把父类的字段复制到子类中了，所以，子类对象才能使用父类中定义的属性，也才真正实现了继承。当然，口说无凭，还是通过 HSDB 来观察一下。我最终创建的是一个 Sharing 对象，在这个对象内部拥有父类的全部字段。请看下图。

![](https://cdn.nlark.com/yuque/0/2023/png/26725125/1695550896166-bbc1c713-c05d-42c9-a2a9-e941a1f716f8.png)

在上图中可以看到 Sharing 对象中有父类的全部字段。

![](https://cdn.nlark.com/yuque/0/2023/png/26725125/1695550920034-ccac8bc7-90ed-4716-84ec-fe4aa9121904.png)

在上图中可以看到，在 Sharing 对象中，其内部声明的 p8 字段的偏移量是 80，这意味着这个字段前面还有很多字段。我们简单计算一下，Sharing 的对象头为 12 字节，加上后面填充的 4 字节无效字节，加上 8 long 字段，不正是 12 + 4 + 64 = 80 吗？这就直接说明了 Sharing 包含了父类的全部字段。这里我也可以总结一下了，那就是如果一个对象有父类，那么在 JVM 在对其字段进行内存分配的时候，会先分配父类的字段，然后再分配子类的字段，在单独分配父类或子类字段时，父类的所有字段仍然按照之间总结的字段顺序分配内存，子类也是如此。到此为止，如何填充无效字节解决为共享问题的知识，我就为大家讲解完毕了。这一章显然是讲不了 Disruptor 中的代码了，只能留到下一章讲解了。本来这一章到此为止就可以结束了，但是我记得之前有一个小问题，那就是硬件是怎么限制了内存对齐。我先声明，这个问题我也解释不清楚，至少无法详细解释清楚，所以我也就简单谈谈自己的理解，如果有错误的地方，请大家指正。当然，文章的其他地方出现错误了，也希望大家指正。

虽然在过去的课程中我多次为大家画过一些内存分析图，把内存当作一个地址连续的字节数组。但实际上，内存地址并不是连续的，确切地说，虚拟内存地址是连续的，但是并不意味着一段连续的虚拟内存地址，其对应的物理地址就是连续的。要想弄清楚内存对齐的问题，首先要简单了解一下内存芯片的构造。简单来说，内存并不是一整块，而是多个芯片构成的，每一块芯片上有非常多的内存单元，每一个单元代表一个字节。如下图所示。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/26725125/1695552620035-70015577-b06c-4fa9-9491-c6feb502242d.jpeg?x-oss-process=image/auto-orient,1)

在上图中一共有 8 个内存芯片，如果 CPU 使用一个内存地址去访问内存，在访问内存的时候会有一个地址转换器，把这个内存地址转换成行和列，就比如说现在要访问内存地址 8，并且读取 8 个字节，也就是内存地址 8-15 的数据。假设这个内存地址 8 被地址转换器解析成第三行第七列，那么就会找到图中的我画出来的那些内存单元。找到这些内存单元后，第一个内存芯片上的 3 行 7 列的内存单元地址就为 8，第二个内存芯片上的 3 行 7 列的内存单元的地址为 9，直到最后一个内存芯片的 3 行 7 列的内存单元地址为 15。然后就会把这几个芯片上的这几个同行同列的内存单元抽象成一行，把这一行的数据返回给 CPU。所以，这时候大家应该能稍微明白一点了。所谓的内存地址并不是连续的，而一个地址真正被解析后，得到的也只是一个偏移量，只能决定返回内存中哪一行的数据。这种情况下，如果 long 并不是按照 8 字节内存对齐的，它在内存中的地址是 10 - 17，显然就会被存放到两行中了，而一个地址只能决定一行要返回的数据，所以当 long 没有内存对齐的时候，CPU 就不得不再次访问一次内存，把另一行的数据读取出来，然后拼接成一个完整的 long。

如果我讲解的知识有哪些不对的地方，大家一定要给我指正，我会及时更新。分享错误的知识比不愿分享知识还可恶，所以，大家尽可以帮助我改正。谢谢啦。