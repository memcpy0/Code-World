**在看这一篇文章之前，请大家去往盘中下载最新的代码，我在写作的过程中修复了一些注释，当初迭代代码的时候遗漏了一些重要信息，现在全部补充完整了**

上一章我已经为大家实现了动态线程池框架客户端动态刷新线程池配置信息的功能，这个功能的逻辑很简单，但实现代码确实有点复杂。也许现在大家已经把第三版本代码看完了，也许大家还没有看，等着第四版本代码的功能实现完毕了，再去第四版本代码中启动测试类学习，这就是大家自己的意愿了。在这一章，我会为大家实现服务端处理客户端长轮询请求的功能，和上一章想必，这一章的功能实现起来非常简单，处理客户端长轮询请求的入口方法也很清晰，这一点其实在上一章结尾我已经跟大家展示过了。我在服务端定义了一个 ConfigController 控制器对象，这个对象中的 listener 方法就是用来处理客户端长轮询请求的方法，具体实现请看下面代码块。

```
package cn.hippo4j.config.controller;




/**
 * @author:B站UP主陈清风扬，从零带你写框架系列教程的作者，个人微信号：chenqingfengyangjj。
 * @Description:系列教程目前包括手写Netty，XXL-JOB，Spring，RocketMq，Javac，JVM等课程。
 * @Date:2024/4/29
 * @Description:处理线程池配置信息的控制器，这个控制器引入进来是因为当客户端创建动态线程池的时候
 * 会先访问一次服务端，看看服务端的数据库中是否存在线程池的配置信息，如果存在就使用数据库中的信息
 * 刷新客户端动态线程池
 */
@RestController
@AllArgsConstructor
@RequestMapping(Constants.CONFIG_CONTROLLER_PATH)
public class ConfigController {

    private final ConfigService configService;

    //处理长轮询请求的对象
    private final ConfigServletInner configServletInner;


    //这个方法就是用来处理查询线程池配置信息请求的
    @GetMapping
    public Result<ConfigInfoBase> detailConfigInfo(@RequestParam("tpId") String tpId,
                                                   @RequestParam("itemId") String itemId,
                                                   @RequestParam("namespace") String namespace,
                                                   @RequestParam(value = "instanceId", required = false) String instanceId) {
        ConfigAllInfo configAllInfo = configService.findConfigRecentInfo(tpId, itemId, namespace, instanceId);
        return Results.success(configAllInfo);
    }


    //配置变更的入口方法，这个方法是专门处理web界面线程池实例中，修改线程池配置信息请求的方法
    @PostMapping
    public Result<Boolean> publishConfig(@RequestParam(value = "identify", required = false) String identify,
                                         @RequestBody ConfigAllInfo config) {
        configService.insertOrUpdate(identify, true, config);
        return Results.success(true);
    }

    //长轮询的请求会被这个方法处理
    @SneakyThrows
    @PostMapping("/listener")
    public void listener(HttpServletRequest request, HttpServletResponse response) {
        //设置支持处理异步请求标志
        request.setAttribute("org.apache.catalina.ASYNC_SUPPORTED", true);
        //获得要监听的配置信息，这里就把在客户端封装好的所有要监听的线程池信息的字符串得到了
        String probeModify = request.getParameter(Constants.LISTENING_CONFIGS);
        if (StringUtils.isEmpty(probeModify)) {
            throw new IllegalArgumentException("invalid probeModify");
        }
        //解码字符串
        probeModify = URLDecoder.decode(probeModify, Constants.ENCODE);
        //这个map会存放要监听的各个线程池信息
        Map<String, String> clientMd5Map;
        try {
            //解析probeModify，把probeModify中的信息封装到一个map中，然后把map赋值给clientMd5Map
            //这里最后得到的map中的key就是threadPoolId+itemId+tenantId+identify，value就是线程池的md5
            //这里我想多解释一句，其实判断客户端和服务端的配置是否相同，对比线程池的md5即可
            //因为线程池的md5就是根据线程池的配置参数得到的，只要配置参数发生了变化，md5肯定就会发生变化
            //所以只要服务端的md5和客户端线程池的md5不一样，就意味着服务端线程池的配置更新了
            clientMd5Map = Md5ConfigUtil.getClientMd5Map(probeModify);
        } catch (Throwable e) {
            throw new IllegalArgumentException("invalid probeModify");
        }
        //处理长轮询请求的入口方法
        configServletInner.doPollingConfig(request, response, clientMd5Map, probeModify.length());
    }


    //这个方法就是注册客户端线程池信息到服务端的入口方法
    @PostMapping("/register")
    public Result register(@RequestBody DynamicThreadPoolRegisterWrapper registerWrapper) {
        configService.register(registerWrapper);
        return Results.success();
    }
}
```

其实这个 ConfigController 类我们早就见过了，我相信大家肯定都还有印象，在我为大家实现第一版本代码，实现客户端注册线程池信息到服务端功能的时候就展示过这个 ConfigController 类了。现在再次展示这个类，只不过是稍微重构了一个这个 ConfigController 类，在这个类中添加了两个新的方法。**一个就是 publishConfig 方法，这个方法就是用来接收前端 web 页面更改线程池配置信息的请求的，也就是说，用户只要在 web 页面修改了某个线程池的配置信息，这个请求都会被后端的 ConfigController 控制器的 publishConfig 方法接收并处理**；但这个方法目前不是我们要关注的重点，我们重点关注的是 listener 这个方法。这个方法就是用来处理客户端长轮询请求的方法。在我刚刚定义的这个 listener 方法中，大家可以看到程序首先通过 request.getParameter(Constants.LISTENING_CONFIGS) 方法，**获得了客户端传输给服务端要查询的配置变更情况的线程池信息，也就是一个长字符串**。这是上一章的知识，如果大家记不清了，可以去回顾一下，我就不再重复解释了。那得到了这个长字符串之后呢？别忘了，**这个长字符串中包含了客户端订阅的所有动态线程池的 md5 信息，只要我们能得到每一个线程池的 md5 信息，然后和服务端对应线程池的 md5 做一下对比，如果 md5 发生了变化，就说明服务端线程池的配置信息更新了**，这个逻辑大家可以理解吧？

所以，接下来，我们的目的就是解析客户端传输过来的长字符串，从长字符串中得到客户端订阅的每一个动态线程池的 md5 信息。而这一步我也已经在 listener 方法中执行了。执行了 listener 方法中的 Md5ConfigUtil.getClientMd5Map(probeModify) 这行代码，就能得到一个 clientMd5Map。**这个 map 的 key 就是客户端订阅的每一个动态线程池的 threadPoolId+itemId+tenantId+identify，value 就是客户端线程池的 md5 信息。到此为止，我们就得到了客户端订阅的每一个动态线程池的信息，也得到了每一个动态线程池对应的 md5 的值**，接下来，就可以真正处理这个长轮询请求了。所以大家能在 ConfigController 类中看到我又新定义了一个 configServletInner 成员变量，它就是用来处理客户端长轮询请求的组件。具体代码如下所示。

```
package cn.hippo4j.config.service;



import static cn.hippo4j.common.constant.Constants.WEIGHT_CONFIGS;

/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：处理长轮询请求的类
 */
@Service
@RequiredArgsConstructor
public class ConfigServletInner {

    //长轮询服务器
    private final LongPollingService longPollingService;

    private static final int CLIENT_IDENTIFY_MAXIMUM_SIZE = 16384;

    //定义一个map，这个map中存放的key就是客户端的标识符
    private final Cache<String, Long> deWeightCache = Caffeine.newBuilder()
            .maximumSize(CLIENT_IDENTIFY_MAXIMUM_SIZE)
            .build();


    public String doPollingConfig(HttpServletRequest request, HttpServletResponse response, Map<String, String> clientMd5Map, int probeRequestSize) {
        //如果支持长轮询请求，并且请求没有重复发送
        if (LongPollingService.isSupportLongPolling(request) && weightVerification(request)) {
            //就把请求交给长轮询服务对象处理
            longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);
            return HttpServletResponse.SC_OK + "";
        }
        return HttpServletResponse.SC_OK + "";
    }


    //检查长轮询请求是否重复的方法
    private boolean weightVerification(HttpServletRequest request) {
        //得到客户端的唯一标识符
        String clientIdentify = request.getParameter(WEIGHT_CONFIGS);
        //判断map中是否存在对应的标识符了
        Long timeVal = deWeightCache.getIfPresent(clientIdentify);
        if (timeVal == null) {
            //如果不存在就把当前时间戳放到map中
            deWeightCache.put(clientIdentify, System.currentTimeMillis());
            return true;
        }//走到这里意味着map中存在标识符，说明请求重复了，直接返回false即可
        return false;
    }
}
```

在上面的 ConfigServletInner 类中，可以看到一个 doPollingConfig 方法，这个方法就是处理客户端长轮询请求的方法，但是该方法也仅仅是长轮询请求做了一个判断，看看客户端是否重复发送长轮询请求过来了。如果没有重复发送，就可以把长轮询请求交给 longPollingService 对象的 addLongPollingClient 方法来处理。而 longPollingService 对象是我新引入的，这个对象就是真正处理客户端长轮询请求的组件。那么这个 longPollingService 对象内部究竟都有什么呢？接下来请听我慢慢讲解。

## 引入 LongPollingService，实现处理长轮询请求的两种方式

  

现在，我们要实现处理客户端长轮询请求的真正操作了，那么在实现之前，我想问问大家，在服务端处理客户端长轮询请求的时候，有没有什么需要注意的地方？请大家想象一个场景，客户端发送长轮询请求过来之后，肯定是想通过这个请求查询订阅的动态线程池的配置信息在服务端有没有发生变更。如果服务端线程池的配置信息没有发生变更，这时候该怎么办呢？有两种做法摆在大家眼前，**第一种就是立刻同步返回客户端一个空响应，所谓空响应就意味着服务端没有任何线程池发生了配置变更。这样一来，客户端接收到空响应后就会立刻发送下一个长轮询请求到服务端。第二种做法就是服务端把客户端发送的长轮询请求异步挂起一段时间，比如就挂起 30 秒，究竟挂起多少时间，用户可以自己在客户端定义。等 30 秒之后，再回复客户端长轮询请求的响应**。

这两种做法，如果让我来选，我肯定选第二种，如果选第一种的话，假如服务端的线程池的配置信息一直没有发生动态变更，就会立刻给客户端回复长轮询空响应，那对客户端来说，接收到一个长轮询空响应，就要立刻发送下一个长轮询请求，不停地发送无用的网络请求，对资源也是一种浪费。所以，最好的做法就是，**当客户端的长轮询请求发送给服务端之后，只要服务端没有线程池的配置信息发生了变更，那么服务端就可以把客户端的请求挂起，等到 30 秒之后再回复给客户端一个响应**。

当然，我能想到这时候肯定有朋友会问，假如在服务端将客户端长轮询请求挂起的时候，服务端有线程池的信息发生变更了呢？这时候该怎么做？按照常理，**既然客户端发送过来的请求已经在服务端了，服务端就可以直接把发生了配置变更的线程池信息回复给客户端，就通过长轮询请求回复一个异步响应即可**。这个逻辑大家应该也可以理解吧。这里我再多解释一句，我刚才说要把客户端长轮询请求挂起的时候，应该使用异步挂起的方式，**所谓挂起其实就是一直不回复响应，但是请大家想一想，如果一直不回复响应，那么服务器处理请求的线程是不是就什么也不能做？如果长轮询请求都要同步挂起的话，那服务端 web 容器的线程池还怎么正常工作呢？所以，这里应该采取异步挂起的方式**。

好了，这个问题说完了之后，请大家再思考另外一个问题，假如在客户端发送长轮询请求过来之前，服务端这边已经对某个线程池进行了配置信息的动态变更。那么客户端长轮询请求发送过来之后，还需要被挂起吗？按照常规思路，**客户端的长轮询请求发送过来之后，肯定是立刻根据长轮询发送过来的要查询的动态线程池的信息，查看一下这些线程池的配置信息是否发生了变更；如果发现有线程池配置信息发生变更了，那么就不必挂起长轮询请求，而是直接给客户端回复同步响应，通知客户端执行线程池配置变更操作；当然，如果没有发生变更，就按照规定的步骤，把长轮询请求异步挂起 30 秒，在挂起的过程中，如果有线程池配置信息发生变更了，就立刻回复客户端长轮询请求的响应**。这个逻辑想必大家应该也可以理解吧。

按理说，到这里之后，服务端处理客户端长轮询请求的流程就已经分析完毕了。整个流程可以概括成这样：**当服务端接收到客户端的长轮询请求之后，首先根据长轮询请求中的动态线程池信息去查看一下是否有动态线程池的配置发生了变更，如果有线程池的配置发生了变更，服务端就直接同步回复客户端长轮询请求的响应，让客户端立刻执行线程池配置信息刷新操作；如果没有任何线程池的配置发生了变更，那么服务端就可以把长轮询请求异步挂起了，直到 30 秒之后，在回复客户端一个空响应。当然，在长轮询请求被挂起期间，如果用户在 web 界面修改了线程池配置信息，那么服务端也应该立刻异步回复客户端长轮询响应**。目前来看，服务端处理客户端长轮询请求的流程也就是这样了。

但是，没错，还是有一个但是，那就是我之前简单提到过：**长轮询请求在服务端究竟要挂起多久，这个时间可以由用户自己在客户端定义，客户端发送长轮询请求的时候，会把长轮询被挂起的时间设置好，如果用户没有设置，那就可以使用框架内置的默认时间**。假如几个客户端都订阅了相同线程池的配置信息，但是每一个客户端长轮询请求被挂起的时间却不一致(**当然，这种情况一般也不会发生，这里就是为了举一个小例子而已，没有哪个程序员会给多个同样的程序定义不同的配置**)，那么各个客户端请求达到服务端的时间可能也不一致了。说到底，客户端终究是需要长轮询请求到达服务端之后，根据返回的响应来判断是否执行配置变更操作。如果长轮询请求到达服务端的时间不一致，客户端接收长轮询响应的时间也不一致，这样一来，多个客户端执行配置动态变更的操作也就不会同步了。我可不希望服务端线程池的配置已经发生变更了，有的客户端及时把本地线程池配置变更了，而有的客户端却根本没有反应。我希望所有客户端都可以同步执行配置变更操作，这就意味着向服务端发送长轮询的时间间隔都一致，请求到达的时间也一致，以使各个客户端能同时刷新线程池的配置信息。

或者是另一种情况，让我们跳出这个 hioop4j 动态线程池框架，假如多个客户端同时监听了服务端的一批数据，这批数据可能变化比较频繁，或者在一个范围内经常波动，但是这些数据并不是非常重要，不用实时展示给客户端。如果客户端的长连接请求到达服务端检测到数据变化了就返回响应，然后发送下一个请求，又检测到了数据变化，又返回响应，可能在短时间之内，客户端和服务端的 http 连接的创建销毁十分频繁。我刚才说了，如果这些数据的时效性并没有那么重要，那就不必让客户端频繁地向服务端发送长连接请求。那这个问题该怎么解决呢？

其实这些问题并不难解决？最简单的方法就是把长轮询请求被挂起的时间交给服务端来控制，比如说，让服务端来规定，凡是长轮询请求，必须在服务端挂起 20 秒才能回复客户端响应。这样一来，所有长轮询请求的挂起时间就变成了 20 秒，并且是由服务端控制的，服务端每隔 20 秒才回复响应，客户端接收响应之后再向服务端发送下一个长轮询请求，这不就相当于客户端每隔 20 秒向服务端发送一个长轮询请求吗？这样一来客户端的配置变更不就同步了吗？而且在数据不需要实时更新的情况下，服务端可以长时间挂起长轮询请求，如果服务端信息发生变更了，最后返回给客户端的就是这 20 秒内数据的最新信息，这样也避免了客户端与服务端之间出现频繁建立请求然后又销毁请求的情况。这个就是所谓的固定轮询模式。**并且，只要是在固定轮询模式下，请求进来之后并不会先判断订阅的配置信息是否发生了变更，而是直接被挂起，直到 20 秒结束时才会查看一下配置信息是否发生了变更，如果发生变更了，就给客户端回复配置变更响应；并且就算在请求被挂起期间，服务端配置发生变更了，也不会立即回复客户端配置变更响应，这也就是说为什么固定轮询模式牺牲了配置变更的时效性**。

好了，关于固定轮询说得有点多了，本来我不想讲这个的，因为在 hippo4j 框架里根本就没用到固定轮询模式，虽然作者把固定轮询抄过来了，但是作者提供的动态线程池客户端根本就没由提供让用户自己设定长轮询超时时间的功能，nacos 倒是提供了。并且在 hippo4j 框架的服务端中，作者也没有真正设置固定轮询模式的开关，默认就是不开启的。也许是作者发现要复制的代码有点多，引入了固定轮询功能也没用，所以就不实现全部功能了，所以固定轮询就成了半成品。大家知道这个意思即可。

现在让我们言归正传，刚才分析了那么多，我相信对大家来说，编码思路已经很明确了。接下来就要真正实现在上一小节末尾，为程序引入的 LongPollingService 类了。如果让我实现，**首先我会在 LongPollingService 类中定义一个集合成员变量，原因很简单，服务端也许会接收到多个客户端发送过来的长轮询请求，当服务端线程池需要把这些长轮询都挂起的时候，这些长轮询请求肯定需要地方存放吧。所以我打算先在 LongPollingService 类中定义一个专门用来存放长轮询请求的集合**。那么现在问题来了，集合中存放的是是什么对象呢？难道直接存放每一个客户端传递过来的 HttpServletRequest 吗？我并不打算这样做。接下来，我打算换一个思路，从 LongPollingService 类的 addLongPollingClient 方法来为大家分析存放长轮询的集合该如何定义。这个 addLongPollingClient 方法大家应该还有印象吧？这个方法就是 LongPollingService 类处理长轮询请求的方法。根据我刚才的分析，**服务端既可以使用固定轮询模式处理请求，也可以使用类似即时响应的方式处理请求**。所以，当长轮询请求被交给 addLongPollingClient 方法处理时，首先应该判断服务端当前使用的是哪种模式处理的请求，然后根据不同的处理方式处理长轮询请求。

**当然，在真正处理请求之前，需要先获得长轮询请求被挂起的时间。如果没有使用固定轮询模式，那么这个长轮询请求被挂起的时间就是从客户端传递过来的时间，并且会现根据长轮询请求中的信息查询一下服务端线程池的配置是否发生了变更，如果发生了变更，立刻回复响应即可。如果没有发生变更，则将长轮询请求挂起；如果使用的是固定轮询模式，那么服务端就会直接把请求挂起，挂起时间使用的就是服务端自己设置的时间**。这样分析完毕，现在 addLongPollingClient 方法的思路也就整理完了，接下来请看该方法的代码实现，请看下面代码块。

```
package cn.hippo4j.config.service;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：提供处理长轮询请求的服务对象
 */
@Slf4j
@Service
public class LongPollingService {

    //用来计算固定轮询时间间隔的变量
    private static final int FIXED_POLLING_INTERVAL_MS = 10000;

    //从请求中获得长轮询超时时间的key，所谓超时时间，其实就是请求被服务端挂起的时间，这个请求会被hold住
    public static final String LONG_POLLING_HEADER = "Long-Pulling-Timeout";

    //客户端应用名称，在这个框架中并没有向长轮询请求中设置这个值，所以服务端得到的是null
    public static final String CLIENT_APP_NAME_HEADER = "Client-AppName";

    //存放客户端活跃时间戳的map，key就是客户端的唯一标识符，value就是当前时间戳
    private Map<String, Long> retainIps = new ConcurrentHashMap();

    //存放长轮询请求的队列，请求中存放什么对象还没有确定
    final Queue<泛型不确定> allSubs;


    //构造方法
    public LongPollingService() {
        
        //长轮询队列，这个队列中存放什么对象还没有确定，这里只是把队列创建出来而已
        allSubs = new ConcurrentLinkedQueue();
       
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：添加长轮询请求到allSubs队列中的方法
     */
    public void addLongPollingClient(HttpServletRequest req, HttpServletResponse rsp, Map<String, String> clientMd5Map,
                                     int probeRequestSize) {
        
        //得到长轮询超时时间，其实就是hold请求的事件
        //这里得到的就是从客户端传递过来的长轮询请求被挂起的时间
        String str = req.getHeader(LONG_POLLING_HEADER);
        
        //得到客户端应用名称，这里得到的就是null
        String appName = req.getHeader(CLIENT_APP_NAME_HEADER);
        
        //获取固定延时时间，固定延时时间是500ms
        int delayTime = SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, 500);
        
        //计算真正的hold请求的时间，这里会保证hold请求至少10秒
        //当然，大家也会在这里看到，得到的真正的超时时间实际上是用客户端传递过来的时间减去了刚才得到的固定延时时间
        //这就意味着假如客户端设置了30秒超时时间，服务端最多会hold请求29.5s就给客户端响应，这个简单的调整是把网络传输的时间预留出来了
        //以防网络波动，客户端没有及时接收到服务端的消息，出现超时的情况
        //除了网络传输时间，这里其实也算是预留出来的服务端查询数据库或者业务上的操作时间
        //可能有些朋友会感到困惑，为什么固定轮询不需要预留时间？这是因为固定轮询使用的是服务器设置的时间，这个时间会小于等于客户端的长轮询超时时间
        //所以就算服务端固定轮询回复慢了，也不会造成客户端超时，这一点在nacos源码中展示得很清楚，但hippo4j是个半成品，没有展示出这一点。
        long timeout = Math.max(10000, Long.parseLong(str) - delayTime);
        
        //这里有一个判断，判断服务端处理长轮询请求是不是固定轮询模式
        //如果是固定轮询模式，那么就按照固定轮询的时间来hold住请求
        if (isFixedPolling()) {
            //这个时间和上面计算出来的timeout是不一样的，这个固定轮询模式在当前框架中默认不开启
            //实际上，这个模式也是把nacos的那一套机制搬运过来了，但是nacos的固定轮询模式给用户暴露了可以自己调控的开关
            //这个框架并没有给用户暴露开关，除非修改源码，否则服务端无法使用固定轮询模式处理请求，简而言之，这个框架在某些方面还是一个半成品
            //接下来，我还要给大家再解释一下，什么是固定轮询模式，所谓固定轮询模式，服务端每一次接收到客户端的长轮询请求
            //都会以固定的时间hold请求，如果这个固定轮询时间设定的是20s，那么服务端每次都会hold请求20秒，然后给客户端回复响应
            //客户端再发送下一个长轮询请求，这样一来，其实就变成了客户端每隔20秒向服务端发送一个长轮询请求，并且，最重要的一点是
            //在固定轮询模式下，就算服务端的配置信息已经发生变更了，也不会立刻回复客户端响应，仍然会等待20s之后
            //才会回复客户端响应
            timeout = Math.max(10000, getFixedPollingInterval());
        } 


            //下面就是非固定轮询的模式
            
        else {//程序执行到这里就意味着没有使用固定轮询模式处理请求
            //这时候不管客户端传递过来的长轮询请求的超时时间是多少，反正会直接判断一下客户端传递过来的所有线程池的md5
            //和服务端缓存的线程池的md5的信息是否相同，如果不相同说明服务端的线程池更新了，这时候就返回更新的线程池的信息
            //clientMd5Map这个map中存放的是什么，大家应该还有印象吧
            //Md5ConfigUtil.compareMd5(req, clientMd5Map)这行代码的作用就是用来比较客户端传递过来的所有线程池的md5和服务端缓存的线程池的md5的信息是否存在差异
            List<String> changedGroups = Md5ConfigUtil.compareMd5(req, clientMd5Map);
            
            if (!changedGroups.isEmpty()) {
                //如果changedGroups不为空，就立刻回复客户端一个同步响应，告诉客户端有些线程池配置变更了
                generateResponse(rsp, changedGroups);
                //因为发生配置变更了，就不需要把请求挂起了，直接退出当前方法即可
                return;
            } 
        }
       
        
        //程序执行到这里就意味着请求要被hold住了，也就是要被挂起，但要怎么被hold住呢？
       
    }



    //同步回复客户端响应
    private void generateResponse(HttpServletResponse response, List<String> changedGroups) {
        if (CollectionUtil.isNotEmpty(changedGroups)) {
            try {
                String respStr = buildRespStr(changedGroups);
                response.setHeader("Pragma", "no-cache");
                response.setDateHeader("Expires", 0);
                response.setHeader("Cache-Control", "no-cache,no-store");
                response.setStatus(HttpServletResponse.SC_OK);
                response.getWriter().println(respStr);
            } catch (Exception ex) {
                log.error("Response client failed to return data.", ex);
            }
        }
    }

}
```

我在上面代码块中展示的逻辑应该很清楚了，就不再赘述了。**总之就是根据不同的方式来处理长轮询请求，如果是固定轮询模式，就会计算出请求被挂起的时间，然后将请求挂起；如果并没有使用固定轮询模式，就要先得到客户端传输过来的长轮询挂起时间，然后查询服务端线程池的配置信息有没有发生变更，如果发生变更了，直接给客户端回复响应，把配置信息变更的线程池的信息发送给客户端，如果没有发生配置变更，接下来也要把长轮询的请求挂起了**。这里我再多解释一下，在上面代码块的第 92 行，也就是 Md5ConfigUtil.compareMd5(req, clientMd5Map) 这行代码，这行代码就是使用客户端订阅的每一个线程池的 MD5 去和服务端对应线程池的 MD5 做比较，如果不一样，则意味着有线程池的配置发生了变化。这个逻辑大家肯定都清除，但我要解释的是这行代码背后的逻辑。请大家想一想，客户端把本地动态线程池的信息注册到服务端了，这些线程池的信息肯定是存放在数据库中的。这样一来，长轮询请求每次被服务端接收之后，要对客户端线程池和服务端线程池 MD5 是否不同，但服务端线程池的 MD5 在数据库中存放着，这也就意味着服务端每次处理长轮询请求的时候都要查询数据库，如果配置信息发生变化了还好，但配置信息根本没发生变化还总去数据库中查询，这无异于在做无用功。所以，**最好的方法就是也给服务端设计一个缓存线程池信息的组件，客户端注册在服务端的线程池信息不仅仅要存放在数据库中，也可以在内存里缓存一份。等到服务端线程池配置发生变更的时候，把数据库和缓存在内存中的线程池的配置信息以及 MD5 都更新了，这样一来，服务端处理长轮询请求的时候，及可以获得服务端线程池最新的 MD5，又不必去查询数据了**。这个逻辑我相信也不难理解，所以，在这个逻辑的基础上，**应该给服务端再引入一个缓存线程池配置信息的缓存组件，我把它定义为 ConfigCacheService**。但是这个 ConfigCacheService 类的具体内容我就不为大家展示了，内容非常简单，也很常规，大家去我提供的第四版本代码中查看即可。我在这里之所以提到这个，是因为在 Md5ConfigUtil.compareMd5(req, clientMd5Map) 这行代码背后，就要用到 ConfigCacheService 缓存组件。

好了朋友们，我又把话题扯远了，现在让我们继续回归正题，在上面的代码块中，不管使用哪种方式处理客户端的长轮询请求，只要服务端线程池的配置没有发生变更，客户端发送过来的请求就要被挂起。那该怎么挂起呢？我在上面的代码块中并没有实现。因为我还没想好怎么实现，到目前为止，我只知道肯定不能什么也不做，就让执行 addLongPollingClient 方法的线程干等着，一直等到长轮询请求的截止时间。**之前我跟大家分析过所谓长轮询请求被挂起，其实就是让服务端等待，如果长轮询的被挂起时间、也就是客户端设置的长轮询超时时间为 20 秒，在服务端没有发生配置变更的情况下，那么服务端只需要延后 20 秒回复客户端长轮询请求的响应即可**。**如果在服务端延后回复响应的 20 秒里，执行 addLongPollingClient 方法的线程什么也不做，这个线程又是 tomcat web 容器中的线程，那么长轮询请求非常多的情况下，服务端不就没办法处理客户端的其他请求了？因为 web 容器线程都被长轮询占用了**。所以，肯定要找出一个相对完美的方法将长轮询请求挂起。这时候，不就用到我刚才在 LongPollingService 中定义的 allSubs 队列了吗？把长轮询请求直接添加到 allSubs 队列中，addLongPollingClient 方法就可以结束了，这样一来 tomcat 容器线程就可以继续处理别的请求了。

但是，把长轮询请求放到 allSubs 队列之后呢？等待长轮询被挂起的时间结束，然后再回复客户端响应？好像流程就是这么简单，那么怎么就知道长轮询请求被挂起的时间结束了呢？又怎么回复客户端响应呢？这时候大家有没有发现，**回复长轮询请求响应给客户端很像一个定时任务，只要在 addLongPollingClient 方法结束的时候把长轮询对象包装在一个定时任务中，定时任务要执行的操作就是给客户端回复响应，然后把这个定时任务提交给定时任务执行器，并且就是用长轮询被挂起的时间当作定时任务执行时间。这样一来不就实现了服务端客户端长轮询响应的功能了？并且还是在长轮询请求被挂起了规定时间之后回复的响应**。那怎么给客户端回复响应呢？都把长轮询请求包装成任务提交给定时任务执行器了，web 容器线程池肯定也要开始处理别的请求了，肯定就不能同步等待回复客户端响应，**这时候就轮到 AsyncContext 登场了。这个 AsyncContext 对象可以得到用于回复客户端响应的对象，只要定时任务执行器的线程得到了这个 AsyncContext 对象，就可以直接异步回复客户端响应了，而 web 容器中的线程也就可以直接处理其他客户端请求了**。

经过上面的分析，我们也就能想到，**在 addLongPollingClient 方法中把长轮询请求封装成一个定时任务对象时，这个对象肯定要持有一个 AsyncContext 对象，这个是最主要的**，当然，定时任务对象中还要持有一些其他的对象，这里我就不一一讲解了。我直接为大家展示实现好的代码就行。**我新引入了一个 ClientLongPolling 类，这个类的对象就是要添加到 allSubs 队列中的对象，而且，要交给定时任务执行器的定时任务就被包装在这个 ClientLongPolling 对象中**。具体实现请看下面代码块。

```
package cn.hippo4j.config.service;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：提供处理长轮询请求的服务对象
 */
@Slf4j
@Service
public class LongPollingService {

    //用来计算固定轮询时间间隔的变量
    private static final int FIXED_POLLING_INTERVAL_MS = 10000;

    //从请求中获得长轮询超时时间的key，所谓超时时间，其实就是请求被服务端挂起的时间，这个请求会被hold住
    public static final String LONG_POLLING_HEADER = "Long-Pulling-Timeout";

    //客户端应用名称，在这个框架中并没有向长轮询请求中设置这个值，所以服务端得到的是null
    public static final String CLIENT_APP_NAME_HEADER = "Client-AppName";

    //存放客户端活跃时间戳的map，key就是客户端的唯一标识符，value就是当前时间戳
    private Map<String, Long> retainIps = new ConcurrentHashMap();

    //存放长轮询请求的队列，请求中存放什么对象还没有确定
    final Queue<ClientLongPolling> allSubs;


    //构造方法
    public LongPollingService() {
        
        //长轮询队列，这个队列中存放什么对象还没有确定，这里只是把队列创建出来而已
        allSubs = new ConcurrentLinkedQueue();
       
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：添加长轮询请求到allSubs队列中的方法
     */
    public void addLongPollingClient(HttpServletRequest req, HttpServletResponse rsp, Map<String, String> clientMd5Map,
                                     int probeRequestSize) {
        
        //省略之前的代码
       
        
        //程序执行到这里就意味着请求要被hold住了，先得到客户端的唯一标识符
         String clientIdentify = RequestUtil.getClientIdentify(req);
        
        //得到请求的异步上下文，因为现在要hold住请求了，肯定不能再同步等待了，否则其他请求就没办法处理了
        //所以使用异步，到最后回复响应的时候也是回复异步响应
        final AsyncContext asyncContext = req.startAsync();
        
        //设置异步上下文的超时时间
        asyncContext.setTimeout(0L);
        
        //在这里把请求封装到ClientLongPolling长轮询任务中，开始hold住请求，其实就是把请求放到了allSubs队列中
        //ConfigExecutor是一个执行器，执行器会执行ClientLongPolling任务
        ConfigExecutor.executeLongPolling(new ClientLongPolling(asyncContext, clientMd5Map, clientIdentify, probeRequestSize, timeout - delayTime, appName));
       
    }





    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/8
     * @方法描述：这个内部类对象就是一个长轮询任务
     */
    class ClientLongPolling implements Runnable {
        //异步上下文
        final AsyncContext asyncContext;
        //客户端要监听的所有线程池的md5信息
        final Map<String, String> clientMd5Map;
        //长轮询对象创建的时间
        final long createTime;
        //客户端唯一标识
        final String clientIdentify;
        //应用名称
        final String appName;
        //请求内容的字节大小，这个成员变量在框架中并没有用到，在nacos中这个变量也只是在记录日志的时候被用到
        final int probeRequestSize;
        //hold请求的时间
        final long timeoutTime;
        //异步任务返回的future
        Future<?> asyncTimeoutFuture;


        public ClientLongPolling(AsyncContext asyncContext, Map<String, String> clientMd5Map, String clientIdentify, int probeRequestSize, long timeout, String appName) {
            this.asyncContext = asyncContext;
            this.clientMd5Map = clientMd5Map;
            this.clientIdentify = clientIdentify;
            this.probeRequestSize = probeRequestSize;
            this.timeoutTime = timeout;
            this.appName = appName;
            this.createTime = System.currentTimeMillis();
        }


        //任务要执行的方法
        @Override
        public void run() {
            //先使用ConfigExecutor执行器提交了一个定时任务，这个定时任务会在timeoutTime之后执行，这样一来就相当于把请求hold住了timeoutTime时间
            asyncTimeoutFuture = ConfigExecutor.scheduleLongPolling(() -> {
                try {
                    //更新客户端的最后活跃时间，注意，当这个任务执行的时候，就意味着请求已经在服务端被hold住了timeoutTime时间
                    //并且在这期间服务端的事件通知中心也没有发布配置变更事件
                    getRetainIps().put(ClientLongPolling.this.clientIdentify, System.currentTimeMillis());
                    //因为服务端要回复客户端了，不用再hold这个长轮询请求，所以直接从队列中移除即可
                    allSubs.remove(ClientLongPolling.this);
                    //判断是否为固定轮询模式
                    if (isFixedPolling()) {
                        //这里就要再判断一下配置是否发生了变更，为什么这里要再判断一下呢？原因很简单，在固定轮询模式下
                        //从请求进来到请求hold时间结束，都没有主动检查过客户端和服务端线程池的md5是否不同，即便请求被挂起的过程中
                        //配置发生变更了，也不会主动通知客户端，所以要在返回响应之前查看一下配置是否发生变更了，如果发生变更了就通知客户端配置变更
                        List<String> changedGroups = Md5ConfigUtil.compareMd5((HttpServletRequest) asyncContext.getRequest(), clientMd5Map);
                        //判断是否存在配置变更
                        if (!changedGroups.isEmpty()) {
                            //存在配置变更就回复异步响应
                            sendResponse(changedGroups);
                        } else {
                            //没有变更就回复空响应
                            sendResponse(null);
                        }
                    } else {
                        //走动这里就意味着不是固定轮询模式，也直接回复一个空响应即可
                        sendResponse(null);
                    }
                } catch (Exception ex) {
                    log.error("Long polling error: {}", ex.getMessage(), ex);
                }
            }, timeoutTime, TimeUnit.MILLISECONDS);
            
            
            //注意，上面是提交的异步任务，这里是ClientLongPolling任务自己的逻辑，那就是把任务本身提交给长轮询队列
            allSubs.add(this);
        }


        //回复客户端响应的方法
        private void sendResponse(List<String> changedGroups) {
            if (null != asyncTimeoutFuture) {
                asyncTimeoutFuture.cancel(false);
            }
            generateResponse(changedGroups);
        }


        //回复异步响应
        private void generateResponse(List<String> changedGroups) {
            HttpServletResponse response = (HttpServletResponse) asyncContext.getResponse();
            if (null == changedGroups) {
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                asyncContext.complete();
                return;
            }
            try {
                String respStr = buildRespStr(changedGroups);
                response.setHeader("Pragma", "no-cache");
                response.setDateHeader("Expires", 0);
                response.setHeader("Cache-Control", "no-cache,no-store");
                response.setStatus(HttpServletResponse.SC_OK);
                response.getWriter().println(respStr);
            } catch (Exception ex) {
                log.error("Response client failed to return data.", ex);
            } finally {
                asyncContext.complete();
            }
        }
    }

   

}
```

上面代码块中的逻辑是这样的：**当要把长轮询请求挂起的时候，先得到了可以异步回复客户端响应的 AsyncContext 对象。然后创建了一个 ClientLongPolling 任务对象，并且把 AsyncContext 对象交给 ClientLongPolling 任务对象使用。这个 ClientLongPolling 任务对象会被执行器执行。当执行器执行 ClientLongPolling 任务对象的时候，会根据 ClientLongPolling 任务对象 run 方法的逻辑，再次向定时任务执行器 ConfigExecutor 中提交了一个定时任务，定时任务的逻辑就是向客户端回复长轮询请求响应，并且这个定时任务会在长轮询挂起时间到期后被执行。向执行器提交了定时任务之后，又把这个 ClientLongPolling 任务对象存放到了 allSubs 队列之中**。这就是 ClientLongPolling 任务要执行的所有操作。大家可以结合之前的代码品味品味这个流程。

当然，我知道看到这里肯定有朋友会觉得我创建的这个 allSubs 队列似乎没发挥什么作用，反正把定时任务提交给定时任务执行器就行了，到时候定时任务执行器异步回复客户端响应，没必要再把 ClientLongPolling 对象存放到 allSubs 队列中，这么做好像有点多此一举。这时候就不得不考虑另一种情况了：**假如长轮询请求被挂起的过程中，用户忽然在 web 界面更新了某些动态线程池的配置信息，服务端感知到了动态线程池信息发生了变化，这时候肯定要及时通知客户端，向客户端回复配置变更响应，把配置发生变更的线程池信息告诉客户端，这样一来，客户端才能及时执行更新本地动态线程池配置信息的操作。请大家想一想，向客户端回复响应肯定需要 AsyncContext 对象，而 AsyncContext 对象被包装在了 ClientLongPolling 对象中，如果只执行 ClientLongPolling 任务对象中的任务逻辑，而不另外保存 ClientLongPolling 对象，当服务端需要主动给客户端回复响应的时候，就没办法得到 ClientLongPolling 对象了。所以，把 ClientLongPolling 对象保存在 allSubs 队列是很有必要的操作**。这样一来，当服务端感知到线程池配置发生了变化，向及时通知客户端时，就可以从 allSubs 队列中获得对应的 ClientLongPolling，就可以使用 ClientLongPolling 中的 AsyncContext 对象向客户端回复响应了。那么现在问题又来了，服务端主动向客户端回复配置变更响应的功能该怎么实现呢？

也就是说，服务端怎么能感知到有线程池配置发生变更了呢？又通过什么途径执行 ClientLongPolling 对象的 sendResponse 方法呢？这就要回到上一章一开始，我给大家简单提到过来的发布订阅模式了。

## 引入发布订阅模式，实现服务端主动回复客户端配置变更响应功能

**假如我在动态线程池框架中定义了一个时间对象，就叫做 LocalDataChangeEvent，这个事件对象就代表配置文件发生变化事件。然后我再定义一个 NotifyCenter 类，这个类的对象就叫做事件通知中心，最后我再定义一个 DefaultPublisher 类，这个类的对象就是事件发布器**。我知道现在大家可能有点懵，接下来让我为大家简单解释一下，这个 NotifyCenter 事件通知中心我可以定义成下面这样。请看下面代码块。

```
package cn.hippo4j.config.notify;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/8
 * @方法描述：事件通知中心，这个类的代码也是直接把nacos的NotifyCenter的大部分代码搬运过来了，有很多类和判断其实根本用不上，我本来想替作者删除这些无关的代码
 * 但是又想了想，也许作者是给以后的某些功能预留了拓展口，虽然这个可能性并不大，所以就不删除多余的代码了，如果大家先看到的是动态线程池框架，然后再学习nacos
 * 那么nacos的事件通知机制你在动态线程池框架中就能掌握了，学习nacos的时候会简单很多
 */
@Slf4j
public class NotifyCenter {


    //事件通知中心对象最核心的成员变量，专门用来存储事件和对应的发布器的map
    //key是事件名称，value就是对应的发布器，这个map存放的是DefaultPublisher事件发布器
    private final Map<String, DefaultPublisher> publisherMap = new ConcurrentHashMap(16);


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/8
     * @方法描述：注册订阅者到事件通知中心的方法
     */
    public static void registerSubscriber(final AbstractSubscriber consumer) {
       
        //获得订阅者订阅的事件
        final Class<? extends AbstractEvent> subscribeType = consumer.subscribeType();

        //添加到对应的事件发布器中
        addSubscriber(consumer, subscribeType);
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/8
     * @方法描述：把订阅者添加到通知中心的方法
     */
    private static void addSubscriber(final AbstractSubscriber consumer, Class<? extends AbstractEvent> subscribeType) {
        
        //根据订阅者订阅的事件类型获得一个topic，其实就是订阅事件的字符串
        final String topic = ClassUtil.getCanonicalName(subscribeType);
       
        //得到事件对应的事件发布器
        DefaultPublisher publisher = INSTANCE.publisherMap.get(topic);
        
        //添加订阅者到事件发布器中
        publisher.addSubscriber(consumer);
    }


    //接下来就是发布事件的方法

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/8
     * @方法描述：事件通知中心发布事件的方法
     */
    public static boolean publishEvent(final AbstractEvent event) {
        try {//发布事件类型
            return publishEvent(event.getClass(), event);
        } catch (Throwable ex) {
            log.error("There was an exception to the message publishing: {}", ex);
            return false;
        }
    }




    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/8
     * @方法描述：事件通知中心发布事件的方法
     */
    private static boolean publishEvent(final Class<? extends AbstractEvent> eventType, final AbstractEvent event) {
      
        //得到事件的topic名称
        final String topic = ClassUtil.getCanonicalName(eventType);
        
        //从publisherMap中得到对应的事件发布器
        EventPublisher publisher = INSTANCE.publisherMap.get(topic);
        
        if (publisher != null) {
            //发布事件
            return publisher.publish(event);
        }
        
        log.warn("There are no [{}] publishers for this event, please register", topic);
        return false;
    }
}
```

可以看到，在 NotifyCenter 事件通知中心的代码中，我定义了一个 publisherMap 成员变量，这个成员变量是一个 map，map 的 key 就是事件类型字符串，value 就是对应的事件发布器。key-value 映射就表明了一种关系，value 事件发布器只关注 key 事件，也只发布 key 事件。假如我创建了一个 DefaultPublisher 事件发布器，然后创建了一个 LocalDataChangeEvent 事件，并且把它们以 key-value 键值对的形式添加到 NotifyCenter 注册中心的 publisherMap 中了。那么，当 NotifyCenter 事件通知中心调用它的 publishEvent 方法在服务端发布了一个 LocalDataChangeEvent 事件，这时候程序就回去 publisherMap 中找到 LocalDataChangeEvent 事件对应的事件发布器，也就是我刚才创建的 DefaultPublisher 对象。然后调用 DefaultPublisher 对象的 publish 方法，真正发布 LocalDataChangeEvent 事件。请大家先理清楚我刚才阐述的逻辑，然后再向下看。

假如我事先在 DefaultPublisher 对象中定义一个集合，这个集合中存放的是 AbstractSubscriber 订阅者对象，这些订阅者对象只对 LocalDataChangeEvent 事件感兴趣。通过上面 NotifyCenter 中的 registerSubscriber 方法，这些订阅者确实可以全部存放到 DefaultPublisher 的集合中吧？并且只要 DefaultPublisher 事件发布器发布了 LocalDataChangeEvent 事件，DefaultPublisher 事件发布器内部集合中的所有订阅者中的方法都会被回调，到此为止，我是不是就实现了一个最简单的发布订阅模式？DefaultPublisher 事件发布器的代码我也早写好了，请看下面代码块。

```
package cn.hippo4j.config.notify;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：默认的事件发布器，在这个框架中，整个事件通知机制都是复制了nacos的那一套，代码也都几乎一样，其实作者没必要这么搞
 * 应该就是不想自己写了，单纯省事，所以直接把nacos的那一套搬过来了，但是在整个框架中，这个事件通知机制也就长轮询用到了，未免有点小题大做
 */
@Slf4j
public class DefaultPublisher extends Thread implements EventPublisher {

    //存放订阅者的集合
    protected final Set<AbstractSubscriber> subscribers = Collections.synchronizedSet(new HashSet<>());



    //发布事件的方法，这个方法并不是当前线程自己执行的，而是外部线程调用的
    @Override
    public boolean publish(AbstractEvent event) {
        //遍历订阅者
        for (AbstractSubscriber subscriber : subscribers) {
            //通知订阅者执行回调方法
            notifySubscriber(subscriber, event);
        }
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/8
     * @方法描述：本类核心方法，通知订阅者执行回调方法
     */
    @Override
    public void notifySubscriber(AbstractSubscriber subscriber, AbstractEvent event) {
        //创建一个任务，任务逻辑就是执行订阅者的回调方法
        final Runnable job = () -> subscriber.onEvent(event);
        //判断当前订阅者是否自定义了执行器
        final Executor executor = subscriber.executor();
        //如果定义了就使用订阅者自己的执行器执行回调方法
        if (executor != null) {
            executor.execute(job);
        } else {
            try {//没定义就是用当前线程执行回调方法
                job.run();
            } catch (Throwable e) {
                log.error("Event callback exception: {}", e);
            }
        }
    }

    
}
```

到此为止，这个发布订阅者模式就实现了，大家可以仔细看看其中的逻辑，梳理一下程序执行流程。而我之所以实现发布订阅者模式，是想到了**假如我在 LongPollingService 对象中向 DefaultPublisher 事件发布器对象注册一个订阅者，这个订阅者只关注 LocalDataChangeEvent 事件，然后在订阅这种执行服务端主动向客户端回复配置变更响应的操作。这样一来，只要 NotifyCenter 一发布 LocalDataChangeEvent 事件，服务端主动向客户端回复配置变更响应的操作就会执行**，这样一来，上一小节遗留的问题不就解决了吗？

所以，LongPollingService 类还需要被我重构一下，代码我已经实现了，请看下面代码块。

```
package cn.hippo4j.config.service;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：提供处理长轮询请求的服务对象
 */
@Slf4j
@Service
public class LongPollingService {

    //用来计算固定轮询时间间隔的变量
    private static final int FIXED_POLLING_INTERVAL_MS = 10000;

    //从请求中获得长轮询超时时间的key，所谓超时时间，其实就是请求被服务端挂起的时间，这个请求会被hold住
    public static final String LONG_POLLING_HEADER = "Long-Pulling-Timeout";

    //客户端应用名称，在这个框架中并没有向长轮询请求中设置这个值，所以服务端得到的是null
    public static final String CLIENT_APP_NAME_HEADER = "Client-AppName";

    //存放客户端活跃时间戳的map，key就是客户端的唯一标识符，value就是当前时间戳
    private Map<String, Long> retainIps = new ConcurrentHashMap();

    //存放长轮询请求的队列，请求中存放什么对象还没有确定
    final Queue<ClientLongPolling> allSubs;


    //构造方法
    public LongPollingService() {
        
        //长轮询队列，这个队列中存放什么对象还没有确定，这里只是把队列创建出来而已
        allSubs = new ConcurrentLinkedQueue();


        //向事件通知中心注册LocalDataChangeEvent事件发布器，这个LocalDataChangeEvent事件就代表配置变更事件
        //当用户直接在web界面修改了线程池的配置信息，在ConfigServiceImpl类的insertOrUpdate方法中修改了数据库的数据后，会直接发布一个LocalDataChangeEvent事件
        //注册到事件发布器中的订阅者就会执行它们各自的回调方法了
        NotifyCenter.registerToPublisher(LocalDataChangeEvent.class, NotifyCenter.ringBufferSize);
        
        
        //向事件中新注册订阅者，这里注册的订阅者实际上会注册到事件中心内部持有的事件发布器中
        //这里注册的订阅者只关注LocalDataChangeEvent事件，所以这个订阅者会被注册到发布LocalDataChangeEvent事件的事件发布器中
        NotifyCenter.registerSubscriber(new AbstractSubscriber() {

            @Override
            public void onEvent(AbstractEvent event) {
                //当LocalDataChangeEvent事件发布了，就执行DataChangeTask这个任务
                //DataChangeTask这个任务的逻辑就是检查allSubs中是否有对应的线程池信息
                //如果有则向客户端回复长轮询响应，告诉客户端有线程池的信息更新了
                //这里可以看到，固定轮询模式下，不会主动告诉客户端配置发生变更了，会一直等到请求挂起结束
                if (!isFixedPolling() && event instanceof LocalDataChangeEvent) {
                    LocalDataChangeEvent evt = (LocalDataChangeEvent) event;
                    ConfigExecutor.executeLongPolling(new DataChangeTask(evt.identify, evt.groupKey));
                }
            }
            //这里得到的就是订阅者关注的事件类型
            @Override
            public Class<? extends AbstractEvent> subscribeType() {
                return LocalDataChangeEvent.class;
            }
        });
       
    }




    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：服务端向客户端回复长轮询响应的任务，当服务端的事件通知中心发布了LocalDataChangeEvent事件，这个任务就会被订阅者调用
     */
    class DataChangeTask implements Runnable {
        //变更的线程池的实例Id
        final String identify;
        //这是要给组合键，是线程池Id+项目Id+租户Id拼接到一起组成的键
        final String groupKey;

        DataChangeTask(String identify, String groupKey) {
            this.identify = identify;
            this.groupKey = groupKey;
        }

        public void run() {
            try {//从队列中得到所有的长轮询请求，这里大家一定要理清楚，每一个长轮询请求就对应一个客户端
                //因为客户端向服务端发送长轮询请求的时候，会把客户端本地所有要监控的线程池信息拼接成一个字符串发送给服务器
                //所以一个客户端监听着多个线程池
                for (Iterator<ClientLongPolling> iter = allSubs.iterator(); iter.hasNext();) {
                    //获得客户端的长轮询对象
                    ClientLongPolling clientSub = iter.next();
                    //组合成一个标识符
                    String identity = groupKey + GROUP_KEY_DELIMITER + identify;
                    //这里集合中数据的数量为1
                    List<String> parseMapForFilter = CollectionUtil.newArrayList(identity);
                    if (StringUtil.isBlank(identify)) {
                        parseMapForFilter = MapUtil.parseMapForFilter(clientSub.clientMd5Map, groupKey);
                    }
                    //然后开始遍历当前遍历到的客户端中所有线程的信息，如果parseMapForFilter集合中线程的信息和遍历到的线程信息一致
                    //就把这个现成的组合key信息回复给客户端
                    parseMapForFilter.forEach(each -> {
                        if (clientSub.clientMd5Map.containsKey(each)) {
                            //更新客户端最新活跃时间
                            getRetainIps().put(clientSub.clientIdentify, System.currentTimeMillis());
                            //更新服务端缓存的线程池信息的md5
                            ConfigCacheService.updateMd5(each, clientSub.clientIdentify, ConfigCacheService.getContentMd5(each));
                            //将长轮询对象移出队列，下一次客户端发送长轮询请求过来时会重新向队列中添加长轮询对象
                            iter.remove();
                            //向客户端回复长轮询响应，就把更新的线程池的组合key回复给客户端即可，客户端会根据key主动向服务端查询最新的配置信息
                            clientSub.sendResponse(Arrays.asList(groupKey));
                        }
                    });
                }
            } catch (Exception ex) {
                log.error("Data change error: {}", ex.getMessage(), ex);
            }
        }
    }


    //其他内容省略
}
```

可以看到，在上面代码块中，**我在 LongPollingService 类的构造方法中创建了一个订阅者对象，这个订阅者订阅了 LocalDataChangeEvent 事件，只要 NotifyCenter 时间通知中心一发布 LocalDataChangeEvent 事件，订阅者对象的 onEvent 方法就会被执行。接下来我为 LongPollingService 类新引入的 DataChangeTask 任务就会被提交到执行器执行。剩下的就是 DataChangeTask 任务 run 方法的逻辑了，就是找出配置发生变更的线程池信息，把这些信息回复给客户端即可，这个逻辑就不再赘述了**。唯一需要提醒一点的是，在上面代码块的第 55 行，**大家可以看到假如使用固定轮询模式处理请求，服务端是不会主动给客户端回复配置变更响应的**。

实现了这么多功能，那么服务端配置怎么就发生变更了呢？这就要从 web 界面说起了，请看下面的图片。

![](https://cdn.nlark.com/yuque/0/2024/png/26725125/1717243806932-45cb025d-86ac-4525-a5ed-34fffc04365f.png)

当大家在 web 界面的线程池实例页面点击了编辑按钮，就可以修改线程池的配置参数。修改配置参数的请求会被 ConfigController 控制器的 publishConfig 方法接收并处理。请看下面代码块。

```
package cn.hippo4j.config.controller;




/**
 * @author:B站UP主陈清风扬，从零带你写框架系列教程的作者，个人微信号：chenqingfengyangjj。
 * @Description:系列教程目前包括手写Netty，XXL-JOB，Spring，RocketMq，Javac，JVM等课程。
 * @Date:2024/4/29
 * @Description:处理线程池配置信息的控制器，这个控制器引入进来是因为当客户端创建动态线程池的时候
 * 会先访问一次服务端，看看服务端的数据库中是否存在线程池的配置信息，如果存在就使用数据库中的信息
 * 刷新客户端动态线程池
 */
@RestController
@AllArgsConstructor
@RequestMapping(Constants.CONFIG_CONTROLLER_PATH)
public class ConfigController {

    private final ConfigService configService;

    //处理长轮询请求的对象
    private final ConfigServletInner configServletInner;


    //这个方法就是用来处理查询线程池配置信息请求的
    @GetMapping
    public Result<ConfigInfoBase> detailConfigInfo(@RequestParam("tpId") String tpId,
                                                   @RequestParam("itemId") String itemId,
                                                   @RequestParam("namespace") String namespace,
                                                   @RequestParam(value = "instanceId", required = false) String instanceId) {
        ConfigAllInfo configAllInfo = configService.findConfigRecentInfo(tpId, itemId, namespace, instanceId);
        return Results.success(configAllInfo);
    }


    //配置变更的入口方法，这个方法是专门处理web界面线程池实例中，修改线程池配置信息请求的方法
    @PostMapping
    public Result<Boolean> publishConfig(@RequestParam(value = "identify", required = false) String identify,
                                         @RequestBody ConfigAllInfo config) {
        configService.insertOrUpdate(identify, true, config);
        return Results.success(true);
    }

   //其他方法省略
}
```

而在 ConfigController 控制器的 publishConfig 方法中，又会调用 configService 对象的 insertOrUpdate 方法来处理变更的线程池配置信息。总之，逻辑就会来到 configService 对象的 insertOrUpdate 方法中。请看下面代码块。

```
package cn.hippo4j.config.service.biz.impl;



/**
 * @author:B站UP主陈清风扬，从零带你写框架系列教程的作者，个人微信号：chenqingfengyangjj。
 * @Description:系列教程目前包括手写Netty，XXL-JOB，Spring，RocketMq，Javac，JVM等课程。
 * @Date:2024/4/29
 * @Description:从数据库中查询线程池配置信息的类
 */
@Slf4j
@Service
@AllArgsConstructor
public class ConfigServiceImpl implements ConfigService {



    //省略其他内容





    //插入或者更新ConfigAllInfo对象的方法，ConfigAllInfo对象就封装着线程池的核心配置信息
    @Override
    public void insertOrUpdate(String identify, boolean isChangeNotice, ConfigAllInfo configInfo) {
        verification(identify);
        LambdaQueryWrapper<ConfigAllInfo> queryWrapper = Wrappers.lambdaQuery(ConfigAllInfo.class)
                .eq(ConfigAllInfo::getTenantId, configInfo.getTenantId())
                .eq(ConfigInfoBase::getItemId, configInfo.getItemId())
                .eq(ConfigInfoBase::getTpId, configInfo.getTpId());
        ConfigAllInfo existConfig = configInfoMapper.selectOne(queryWrapper);
        ConfigServiceImpl configService = ApplicationContextHolder.getBean(this.getClass());
        configInfo.setCapacity(getQueueCapacityByType(configInfo));
        ConditionUtil.condition(
                existConfig == null,
                () -> configService.addConfigInfo(configInfo),
                () -> configService.updateConfigInfo(identify, isChangeNotice, configInfo));
        if (isChangeNotice) {
            //通知客户端配置变更的操作，ConfigChangePublisher类的内容请看下面的代码
            ConfigChangePublisher.notifyConfigChange(new LocalDataChangeEvent(identify, ContentUtil.getGroupKey(configInfo)));
        }
    }



    //省略其他内容
}






//下面就是ConfigChangePublisher类的内容
package cn.hippo4j.config.service;



/**
 * Config change publisher.
 */
public class ConfigChangePublisher {

    /**
     * Notify configChange.
     *
     * @param event event
     */
    public static void notifyConfigChange(LocalDataChangeEvent event) {
        //用事件通知中心发布了配置变更事件，该事件一发布，服务端就可以通知客户端进行配置变更操作了
        NotifyCenter.publishEvent(event);
    }
}
```

到此为止，我就为大家把服务端处理客户端长轮询的全部功能都实现了，程序执行流程也大概梳理清楚了。这一章和上一章的内容确实很多，所以大家要多看几遍文章，这一篇文章看完之后，大家就可以去我提供的第四版本代码中查看更多的细节，并且可以启动测试类运行程序，观察程序执行流程。下一章我将为大家实现客户端动态线程池运行信息收集功能。好了诸位，我们下一章见！

## 最后补充，一定要看！！！

最后我想跟大家简单解释一下，我文章中展示得发布订阅模式其实过于简单了，实现的 NotifyCenter、DefaultPublisher 还有其他相关组件都过于简单了。确切地说，整个时间通知体系其实比较复杂，我第四版本展示的代码比文章中复杂很多，和框架源码一致。但我没有在文章中讲解，这是因为 hippo4j 框架的作者使用的事件通知体系原本是 nacos 中的代码，这个作者直接把 nacos 事件通知体系的代码搬运过来了。但是这个作者可能比较懒，搬运就搬运了，也不做一点精简，这就导致 nacos 事件通知体系中的很多类，在 hippo4j 中根本用不上。我在第四版本代码中给大家都加上详细注释了，告诉大家哪些地方可以忽略，哪些地方要详细看一看。这个事件通知体系我本来就是打算放在 nacos 的文章中实现，但这里遇上了，就不得不简单讲解一下。当我更新 nacos 文章的时候，会更仔细更全面的实现这个事件通知体系的功能。

现在大家如果有精力、有兴趣，也可以自行去我提供的代码中把这个事件通知体系的代码都看了，说到底，它还是一个简单的发布订阅模式，或者你直接把它当成观察者模式就行了，逻辑真的很简单，只不过功能比较多，所以代码也就多了一点。这就是我要为大家解释的一些事情。接下来就交给大家了，其实到此为止，我们已经看过很多框架了，什么客户端服务端的搭建、心跳检测、超时重试、失败重试、远程调用、配置变更、注册中心、分布式定时任务执行这些功能全都见过，也全都实现过了。把上一章和这一章看完了，我相信每个人都会运用长轮询实现配置变更功能了，结合之前学到的很多知识，你已经完全可以开发一个自己的配置变更框架，也许你对自己没什么自信，但是你确实掌握了必备的知识了。再庞大、再流行的框架也是程序员一行行敲出来的，这些框架也经过无数次修复和优化，如果你现在想开发一个框架，请运用你的奇思妙想，尽可能地去尝试吧，也许你会在第一步犹豫很久，不知道要定义哪些类，哪些方法要定义成静态的，构造方法中要附带什么其他的操作，但请相信我，当你迈出第一步之后，你过去掌握的知识一定会帮助你完成这个框架，并且，你会在其中感到无穷乐趣。