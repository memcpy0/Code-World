大家好，动态线程池框架这个课程终于迎来了尾声。在这一章我将为大家实现动态线程池的报警通知功能，对应的就是第八版本代码，这一章看完之后，大家就可以去看第八版本代码了。所谓的报警通知功能其实非常简单，**就比如说线程池拒绝了一个任务，这个时候就可以给用户发送一个告警通知；或者说任务队列容量不够了，利用率达到了百分之八十，这个时候也可以给用户发送告警通知；或者是线程池执行任务超时了，这个时候也可以给用户发送告警通知**。**或者是线程池配置发生变更了，也可以给用户发送告警通知**。这些其实都是很普通的功能。如果要给通知类型定义一个枚举类，可以定义成下面这样，请看下面代码块。

```
package cn.hippo4j.message.enums;

//通知类型枚举类
public enum NotifyTypeEnum {

    //配置变更
    CHANGE,

    //队列容量使用率通知
    CAPACITY,

    //线程池负载通知
    ACTIVITY,

   //触发拒绝任务通知
    REJECT,

    //任务执行超时通知
    TIMEOUT
}
```

当然，既然要给用户发送告警通知，就要知道要以什么方式通知用户。在 hippo4j 动态线程池框架中，定义了三种通知用户的方式：**第一种就是给用户发送 WeChat 通知；第二种就是给用户发送 lark 通知；第三种就是给用户发送 ding 通知。并且为这三种通知定义了三个实现类，这三个类都实现了 SendMessageHandler 接口**。在这里我就为大家简单展示一下 WeChat 告警通知的实现类，这个告警通知的实现类为 WeChatSendMessageHandler。其他两个就不再展示了。请看下面代码块。

首先是 SendMessageHandler 接口。

```
package cn.hippo4j.message.service;


public interface SendMessageHandler<T extends NotifyRequest, R extends NotifyRequest> {

   //得到要发送的通知平台的类型
    String getType();

   //发送告警通知
    void sendAlarmMessage(NotifyConfigDTO notifyConfig, T alarmNotifyRequest);

    //发送配置变更通知
    void sendChangeMessage(NotifyConfigDTO notifyConfig, R changeParameterNotifyRequest);
}
```

其实在 SendMessageHandler 接口下还有一个 AbstractRobotSendMessageHandler 抽象实现类，然后再是最终的 WeChatSendMessageHandler 实现类。请看下面代码块。

```
package cn.hippo4j.message.platform.base;


/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/10
 * @方法描述：专门给用户发送告警或者线程池配置变化信息的抽象父类处理器
 */
public abstract class AbstractRobotSendMessageHandler implements SendMessageHandler<AlarmNotifyRequest, ChangeParameterNotifyRequest> {

    //构建消息的内容
    protected abstract RobotMessageActualContent buildMessageActualContent();

    //执行真正发送消息的操作，这个方法和上面的方法都由当前类的子类实现
    protected abstract void execute(RobotMessageExecuteDTO robotMessageExecuteDTO);


    //发送告警通知消息
    public void sendAlarmMessage(NotifyConfigDTO notifyConfig, AlarmNotifyRequest alarmNotifyRequest) {
        RobotMessageActualContent robotMessageActualContent = buildMessageActualContent();
        String replaceTxt = robotMessageActualContent.getReplaceTxt();
        String traceReplaceTxt = robotMessageActualContent.getTraceReplaceTxt();
        String alarmContentTxt = robotMessageActualContent.getAlarmMessageContent();
        String alarmTimoutReplaceTxt;
        if (Objects.equals(alarmNotifyRequest.getNotifyTypeEnum(), NotifyTypeEnum.TIMEOUT)) {
            String executeTimeoutTrace = alarmNotifyRequest.getExecuteTimeoutTrace();
            if (StringUtil.isNotBlank(executeTimeoutTrace)) {
                String alarmTimoutTraceReplaceTxt = String.format(traceReplaceTxt, executeTimeoutTrace);
                alarmTimoutReplaceTxt = StringUtil.replace(replaceTxt, traceReplaceTxt, alarmTimoutTraceReplaceTxt);
            } else {
                alarmTimoutReplaceTxt = StringUtil.replace(replaceTxt, traceReplaceTxt, "");
            }
            replaceTxt = String.format(alarmTimoutReplaceTxt, alarmNotifyRequest.getExecuteTime(), alarmNotifyRequest.getExecuteTimeOut());
        } else {
            replaceTxt = "";
        }
        alarmContentTxt = StringUtil.replace(alarmContentTxt, "${timeout-content}", replaceTxt);
        String text = String.format(
                alarmContentTxt,
                alarmNotifyRequest.getActive(),
                alarmNotifyRequest.getNotifyTypeEnum(),
                alarmNotifyRequest.getThreadPoolId(),
                alarmNotifyRequest.getAppName(),
                alarmNotifyRequest.getIdentify(),
                alarmNotifyRequest.getCorePoolSize(),
                alarmNotifyRequest.getMaximumPoolSize(),
                alarmNotifyRequest.getPoolSize(),
                alarmNotifyRequest.getActiveCount(),
                alarmNotifyRequest.getLargestPoolSize(),
                alarmNotifyRequest.getCompletedTaskCount(),
                alarmNotifyRequest.getQueueName(),
                alarmNotifyRequest.getCapacity(),
                alarmNotifyRequest.getQueueSize(),
                alarmNotifyRequest.getRemainingCapacity(),
                alarmNotifyRequest.getRejectedExecutionHandlerName(),
                alarmNotifyRequest.getRejectCountNum(),
                Joiner.on(robotMessageActualContent.getReceiveSeparator()).join(notifyConfig.getReceives().split(",")),
                notifyConfig.getInterval(),
                LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
        //在这里把消息真正发送出去了，具体方法由子类实现
        execute(RobotMessageExecuteDTO.builder().text(text).notifyConfig(notifyConfig).build());
    }


    //发送配置变更消息
    public void sendChangeMessage(NotifyConfigDTO notifyConfig, ChangeParameterNotifyRequest changeParameterNotifyRequest) {
        RobotMessageActualContent robotMessageActualContent = buildMessageActualContent();
        String threadPoolId = changeParameterNotifyRequest.getThreadPoolId();
        String changeSeparator = robotMessageActualContent.getChangeSeparator();
        String text = String.format(
                robotMessageActualContent.getConfigMessageContent(),
                changeParameterNotifyRequest.getActive(),
                threadPoolId,
                changeParameterNotifyRequest.getAppName(),
                changeParameterNotifyRequest.getIdentify(),
                changeParameterNotifyRequest.getBeforeCorePoolSize() + changeSeparator + changeParameterNotifyRequest.getNowCorePoolSize(),
                changeParameterNotifyRequest.getBeforeMaximumPoolSize() + changeSeparator + changeParameterNotifyRequest.getNowMaximumPoolSize(),
                changeParameterNotifyRequest.getBeforeAllowsCoreThreadTimeOut() + changeSeparator + changeParameterNotifyRequest.getNowAllowsCoreThreadTimeOut(),
                changeParameterNotifyRequest.getBeforeKeepAliveTime() + changeSeparator + changeParameterNotifyRequest.getNowKeepAliveTime(),
                changeParameterNotifyRequest.getBeforeExecuteTimeOut() + changeSeparator + changeParameterNotifyRequest.getNowExecuteTimeOut(),
                changeParameterNotifyRequest.getBlockingQueueName(),
                changeParameterNotifyRequest.getBeforeQueueCapacity() + changeSeparator + changeParameterNotifyRequest.getNowQueueCapacity(),
                changeParameterNotifyRequest.getBeforeRejectedName(),
                changeParameterNotifyRequest.getNowRejectedName(),
                Joiner.on(robotMessageActualContent.getReceiveSeparator()).join(notifyConfig.getReceives().split(",")),
                LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
        //在这里把消息真正发送出去了，具体方法由子类实现
        execute(RobotMessageExecuteDTO.builder().text(text).notifyConfig(notifyConfig).build());
    }
}
```

接下来是真正的 WeChatSendMessageHandler 类，这个类是 AbstractRobotSendMessageHandler 的子类。请看下面代码块。

```
package cn.hippo4j.message.platform;



//给微信平台发送消息的发送器
@Slf4j
public class WeChatSendMessageHandler extends AbstractRobotSendMessageHandler {


    //得到要发送消息的平台类型
    @Override
    public String getType() {
        return NotifyPlatformEnum.WECHAT.name();
    }


    //构建微信消息的内容
    @Override
    protected RobotMessageActualContent buildMessageActualContent() {
        String weChatAlarmTxtKey = "message/robot/dynamic-thread-pool/wechat-alarm.txt";
        String weChatConfigTxtKey = "message/robot/dynamic-thread-pool/wechat-config.txt";
        return RobotMessageActualContent.builder()
                .receiveSeparator("><@")
                .changeSeparator("  ➲  ")
                .replaceTxt(WE_CHAT_ALARM_TIMOUT_REPLACE_TXT)
                .traceReplaceTxt(WE_CHAT_ALARM_TIMOUT_TRACE_REPLACE_TXT)
                .alarmMessageContent(Singleton.get(weChatAlarmTxtKey, () -> FileUtil.readUtf8String(weChatAlarmTxtKey)))
                .configMessageContent(Singleton.get(weChatConfigTxtKey, () -> FileUtil.readUtf8String(weChatConfigTxtKey)))
                .build();
    }


    //执行真正发送消息的操作
    @Override
    protected void execute(RobotMessageExecuteDTO robotMessageExecuteDTO) {
        String serverUrl = WE_CHAT_SERVER_URL + robotMessageExecuteDTO.getNotifyConfig().getSecretKey();
        try {
            WeChatReqDTO weChatReq = new WeChatReqDTO();
            weChatReq.setMsgtype("markdown");
            Markdown markdown = new Markdown();
            markdown.setContent(robotMessageExecuteDTO.getText());
            weChatReq.setMarkdown(markdown);
            //在这里发送了消息
            HttpUtil.post(serverUrl, weChatReq);
        } catch (Exception ex) {
            log.error("WeChat failed to send message", ex);
        }
    }


    
    @Data
    @Accessors(chain = true)
    public static class WeChatReqDTO {

        private String msgtype;

        private Markdown markdown;
    }

    @Data
    public static class Markdown {

        private String content;
    }
}
```

在引入了 WeChatSendMessageHandler 类之后，我们就可以使用这个消息发送器直接给用户发送微信平台的消息了。**如果是动态线程池框架的配置发生变更了，就可以调用 WeChatSendMessageHandler 发送器的 sendChangeMessage 方法给微信平台发送动态线程池配置变更通知；如果是触发了某个报警了，那就可以调用 WeChatSendMessageHandler 发送器的 sendAlarmMessage 方法，给用户发送告警通知**。那这个消息发送器究竟会在什么时候被使用呢？确切地说，这个发送器中的方法会在哪里被调用？这个先不必着急展开，接下来请大家跟我回忆一个旧知识。

大家应该还记得我为大家实现第一版本代码的时候，引入了一个 TaskTimerPlugin 类，这个类的对象是一个插件，就是用来计算线程池执行任务是否超时，如果超时了就可以给用户发送一个告警通知。这个 TaskTimerPlugin 类的具体实现如下，我把它搬运过来了，帮助大家回顾一下，请看下面代码块。

```
//计算任务执行耗时，并且判断是否超时的插件
public class TaskTimerPlugin implements ExecuteAwarePlugin {


    private final ThreadLocal<Long> startTimes = new ThreadLocal<>();

    //在这里定义一个成员变量，代表任务超时时间
    private Long executeTimeOut;


    //构造方法
    public TaskTimerPlugin(Long executeTimeOut){
        this.executeTimeOut = executeTimeOut;    
    }
    

    //任务开始执行之前会执行这个方法，在这个方法中把任务开始执行时间放到线程本地map中
    @Override
    public final void beforeExecute(Thread thread, Runnable runnable) {
        startTimes.set(currentTime());
    }


    //该方法会在任务执行之后被调用
    @Override
    public final void afterExecute(Runnable runnable, Throwable throwable) {
        try {
            //从线程本地map中得到任务的开始时间
            Optional.ofNullable(startTimes.get())
                    //计算出耗时时间
                    .map(startTime -> currentTime() - startTime)
                    //交给processTaskTime方法处理
                    .ifPresent(this::processTaskTime);
        } finally {
            //清除线程本地map
            startTimes.remove();
        }
    }

   
    //得到当前时间的方法
    protected long currentTime() {
        return SystemClock.now();
    }


    //设置任务执行超时时间
    public void setExecuteTimeOut(Long executeTimeOut){
        this.executeTimeOut = executeTimeOut;
    }


    //该方法作为一个拓展方法，可以在该方法中把得到的任务耗时信息上报到监控系统
    //也可以在该方法中判断任务执行是否超时，如果超时就通知用户
    protected void processTaskTime(long taskExecuteTime) {

        //判断任务执行耗时是否超时了，没超时则直接返回
        if (taskExecuteTime <= executeTimeOut) {
            return;
        }

        //超时了则向用户报警
        System.out.println("通知用户任务执行超时了！");
       
    }
}
```

在上面这个代码块中有一个 processTaskTime 方法，这个方法就是用来判断线程池执行定时任务是否超时，如果超时了就向用户发送告警通知。但是我当时并没有为大家实现这个 processTaskTime 方法。现在之所以提起这个 TaskTimerPlugin 类，是因为我已经为大家引入了 WeChatSendMessageHandler 发送器对象，正好可以使用这个发送器对象向用户发送微信平台的告警信息了。

不过，在具体实现这个 processTaskTime 方法之前，我还想补充一些知识。如果大家已经看过了第一版本代码，这时候肯定都知道了，实际上这个 TaskTimerPlugin 类在第一版本代码中被拆分成了两个类，一个是 AbstractTaskTimerPlugin，另一个是 AbstractTaskTimerPlugin 的子类，也就是 TaskTimeoutNotifyAlarmPlugin 这个类。这两个类的具体实现如下。

首先是 AbstractTaskTimerPlugin 类，请看下面代码块。

```
package cn.hippo4j.core.plugin.impl;


/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/28
 * @方法描述：计算任务执行是否超时的插件
 */
public abstract class AbstractTaskTimerPlugin implements ExecuteAwarePlugin {


    private final ThreadLocal<Long> startTimes = new ThreadLocal<>();


    //任务开始执行之前会执行这个方法，在这个方法中把任务开始执行时间放到线程本地map中
    @Override
    public final void beforeExecute(Thread thread, Runnable runnable) {
        startTimes.set(currentTime());
    }


    //该方法会在任务执行之后被调用
    @Override
    public final void afterExecute(Runnable runnable, Throwable throwable) {
        try {
            //从线程本地map中得到任务的开始时间
            Optional.ofNullable(startTimes.get())
                    //计算出耗时时间
                    .map(startTime -> currentTime() - startTime)
                    //交给processTaskTime方法处理，这里就会来到具体的子类的中
                    //也就是TaskTimeoutNotifyAlarmPlugin类中
                    .ifPresent(this::processTaskTime);
        } finally {
            //清除线程本地map
            startTimes.remove();
        }
    }


    //得到当前时间
    protected long currentTime() {
        return SystemClock.now();
    }


    //发送任务执行超时报警通知的方法，由子类TaskTimeoutNotifyAlarmPlugin实现
    protected abstract void processTaskTime(long taskExecuteTime);
}
```

接下来是 TaskTimeoutNotifyAlarmPlugin 类，该类中的 processTaskTime 方法也实现了。请看下面代码块。

```
package cn.hippo4j.core.plugin.impl;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/28
 * @方法描述：这个插件就是用来判断线程中的任务执行是否超时了，如果超时了就调用processTaskTime方法执行告警操作
 */
@AllArgsConstructor
public class TaskTimeoutNotifyAlarmPlugin extends AbstractTaskTimerPlugin {

    public static final String PLUGIN_NAME = "task-timeout-notify-alarm-plugin";

   
    private final String threadPoolId;

    
    @Getter
    @Setter
    private Long executeTimeOut;

   
    private final ThreadPoolExecutor threadPoolExecutor;

   
    @Override
    public String getId() {
        return PLUGIN_NAME;
    }

    /**
     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/9
     * @方法描述：线程池执行任务超时，要发送告警消息给用户。
     */
    @Override
    protected void processTaskTime(long taskExecuteTime) {
        //首先判断当前任务的执行时间是否小于用户定义的任务超时时间
        //如果小于说明任务没有超时，如果大于则认为任务超时了
        if (taskExecuteTime <= executeTimeOut) {
            return;
        }//在这里从SpringBoot容器中获得报警通知检查器ThreadPoolCheckAlarm对象
        //用ThreadPoolCheckAlarm对象给用发送报警通知
        Optional.ofNullable(ApplicationContextHolder.getInstance())
                .map(context -> context.getBean(ThreadPoolCheckAlarm.class))
                //在这里调用ThreadPoolCheckAlarm对象的asyncSendExecuteTimeOutAlarm方法
                //给用户发送告警通知
                .ifPresent(handler -> handler.asyncSendExecuteTimeOutAlarm(
                        threadPoolId, taskExecuteTime, executeTimeOut, threadPoolExecutor));
    }
}
```

从上面代码块的 processTaskTime 方法中，大家可以看到假如线程池执行的方法超时了，就会从 SpringBoot 容器中获得一个 ThreadPoolCheckAlarm 对象，然后调用该对象的 asyncSendExecuteTimeOutAlarm 方法，向用户发送任务超时告警通知。我知道，这时候大家肯定会很困惑，不知道这个 ThreadPoolCheckAlarm 对象是什么？别急，接下来就让我来给大家慢慢解释。这个 ThreadPoolCheckAlarm 其实是一个接口，其实现类为 DefaultThreadPoolCheckAlarmHandler。为什么我要新引入了这个类呢？请大家回顾一下，在文章一开始我是不是就定义了一个 NotifyTypeEnum 枚举类，请看下面代码块。

```
package cn.hippo4j.message.enums;

//通知类型枚举类
public enum NotifyTypeEnum {

    //配置变更
    CHANGE,

    //队列容量使用率通知
    CAPACITY,

    //线程池负载通知
    ACTIVITY,

   //触发拒绝任务通知
    REJECT,

    //任务执行超时通知
    TIMEOUT
}
```

这个枚举类定义了需要给用户发送告警通知的信息类型，可以给用户发送队列容量告警通知，线程池负载告警通知，那这些通知怎么发送呢？**线程池在工作的过程中，这些信息都是会实时变化的。所以最好的方法就是定义一个定时任务，在定时任务中不断检查线程池队列容量和线程池中活跃线程是否超过了用户定义的阈值，如果超过了阈值就直接给用户发送告警通知**。所以我就可以在新引入的这个 DefaultThreadPoolCheckAlarmHandler 类中定义一个定时任务执行器，让定时任务执行器执行定时任务，在定时任务中不断检查是否要给用户发送队列容量和线程池负载的告警通知。当然，我还可以给这个 DefaultThreadPoolCheckAlarmHandler 类定义发送告警通知给用户的方法，并且还可以异步发送。所以，这个 DefaultThreadPoolCheckAlarmHandler 类可以定义成下面这样。请看下面代码块。

```
package cn.hippo4j.message.service;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/10
 * @方法描述：默认的给用户发送线程池告警信息的对象，其中ThreadPoolCheckAlarm接口继承了CommandLineRunner接口，所以这个类的对象也要交给SpringBoot容器来管理
 */
@Slf4j
@RequiredArgsConstructor
public class DefaultThreadPoolCheckAlarmHandler implements Runnable, ThreadPoolCheckAlarm {

    //给用户发送告警通知的对象，这是我新引入的类，马上就会讲到
    private final Hippo4jSendMessageService hippo4jSendMessageService;

    @Value("${spring.profiles.active:UNKNOWN}")
    private String active;

    @Value("${spring.dynamic.thread-pool.item-id:}")
    private String itemId;

    @Value("${spring.application.name:UNKNOWN}")
    private String applicationName;

    //检查是否应该给用户发送告警通知信息的频率
    @Value("${spring.dynamic.thread-pool.check-state-interval:5}")
    private Integer checkStateInterval;


    //创建一个定时任务执行器，这个执行器执行的就是定期检查客户端给是否应该用户平台发送告警通知的任务
    private final ScheduledExecutorService ALARM_NOTIFY_EXECUTOR = new ScheduledThreadPoolExecutor(
            1,
            r -> new Thread(r, "client.alarm.notify"));


    //这个线程池执行的就是给用户发送告警通知的任务
    private final ExecutorService ASYNC_ALARM_NOTIFY_EXECUTOR = ThreadPoolBuilder.builder()
            .poolThreadSize(2, 4)
            .threadFactory("client.execute.timeout.alarm")
            .allowCoreThreadTimeOut(true)
            .keepAliveTime(60L, TimeUnit.SECONDS)
            .workQueue(new LinkedBlockingQueue(4096))
            .rejected(new ThreadPoolExecutor.AbortPolicy())
            .build();


    //这个是CommandLineRunner接口中的回调方法
    @Override
    public void run(String... args) throws Exception {
        //该方法执行的时候，会向定时任务执行其中提交定时任务，定时任务执行的频率就是checkStateInterval成员变量的值
        ALARM_NOTIFY_EXECUTOR.scheduleWithFixedDelay(this, 0, checkStateInterval, TimeUnit.SECONDS);
    }

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：这个就是定时任务执行器要定期执行的任务
     */
    @Override
    public void run() {
        //得到客户端所有线程池的Id
        List<String> listThreadPoolId = GlobalThreadPoolManage.listThreadPoolId();
        //遍历线程池Id
        listThreadPoolId.forEach(threadPoolId -> {
            ThreadPoolNotifyAlarm threadPoolNotifyAlarm = GlobalNotifyAlarmManage.get(threadPoolId);
            if (threadPoolNotifyAlarm != null && threadPoolNotifyAlarm.getAlarm()) {
                DynamicThreadPoolWrapper wrapper = GlobalThreadPoolManage.getExecutorService(threadPoolId);
                ThreadPoolExecutor executor = wrapper.getExecutor();
                //检查线程池的队列是否需要报警
                checkPoolCapacityAlarm(threadPoolId, executor);
                //检查线程池活跃度是否需要报警
                checkPoolActivityAlarm(threadPoolId, executor);
            }
        });
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：检查线程池队列容量是否需要报警的方法
     */
    @Override
    public void checkPoolCapacityAlarm(String threadPoolId, ThreadPoolExecutor threadPoolExecutor) {
        ThreadPoolNotifyAlarm alarmConfig = GlobalNotifyAlarmManage.get(threadPoolId);
        if (Objects.isNull(alarmConfig) || !alarmConfig.getAlarm() || alarmConfig.getCapacityAlarm() <= 0) {
            return;
        }
        BlockingQueue blockingQueue = threadPoolExecutor.getQueue();
        //得到队列中当前使用容量
        int queueSize = blockingQueue.size();
        //得到队列剩余容量
        int capacity = queueSize + blockingQueue.remainingCapacity();
        //得到队列容量使用率
        int divide = CalculateUtil.divide(queueSize, capacity);
        //判断队列容量使用率是否超过了告警阈值，alarmConfig.getCapacityAlarm()这里得到的就是告警阈值，可以从registerNotifyAlarm方法中查看阈值是怎么设置的
        //至于registerNotifyAlarm方法，会在DynamicThreadPoolPostProcessor、DynamicThreadPoolConfigService这两个类中被调用
        boolean isSend = alarmConfig.getAlarm() && divide > alarmConfig.getCapacityAlarm();
        if (isSend) {
            //超过了告警阈值就直接给用户发送告警通知
            AlarmNotifyRequest alarmNotifyRequest = buildAlarmNotifyRequest(threadPoolExecutor);
            alarmNotifyRequest.setThreadPoolId(threadPoolId);
            //发送的是队列容量告警通知
            hippo4jSendMessageService.sendAlarmMessage(NotifyTypeEnum.CAPACITY, alarmNotifyRequest);
        }
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：检查线程池活跃度是否需要报警的方法
     */
    @Override
    public void checkPoolActivityAlarm(String threadPoolId, ThreadPoolExecutor threadPoolExecutor) {
        ThreadPoolNotifyAlarm alarmConfig = GlobalNotifyAlarmManage.get(threadPoolId);
        if (Objects.isNull(alarmConfig) || !alarmConfig.getAlarm() || alarmConfig.getActiveAlarm() <= 0) {
            return;
        }//得到线程池当前活跃线程
        int activeCount = threadPoolExecutor.getActiveCount();
        //得到最大线程
        int maximumPoolSize = threadPoolExecutor.getMaximumPoolSize();
        //得到线程池负载率
        int divide = CalculateUtil.divide(activeCount, maximumPoolSize);
        //判断是否超过了阈值
        boolean isSend = alarmConfig.getAlarm() && divide > alarmConfig.getActiveAlarm();
        if (isSend) {
            AlarmNotifyRequest alarmNotifyRequest = buildAlarmNotifyRequest(threadPoolExecutor);
            alarmNotifyRequest.setThreadPoolId(threadPoolId);
            //超过了就发送告警通知，通知类型为线程活跃告警通知
            hippo4jSendMessageService.sendAlarmMessage(NotifyTypeEnum.ACTIVITY, alarmNotifyRequest);
        }
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：异步给线程池发送报警信息的方法，这个方法会在TaskRejectNotifyAlarmPlugin类中被调用，每当线程池拒绝了某个任务，就会调用这个方法通知用户
     */
    @Override
    public void asyncSendRejectedAlarm(String threadPoolId) {
        Runnable checkPoolRejectedAlarmTask = () -> {
            ThreadPoolNotifyAlarm alarmConfig = GlobalNotifyAlarmManage.get(threadPoolId);
            if (Objects.isNull(alarmConfig) || !alarmConfig.getAlarm()) {
                return;
            }
            ThreadPoolExecutor threadPoolExecutor = GlobalThreadPoolManage.getExecutorService(threadPoolId).getExecutor();
            if (threadPoolExecutor instanceof DynamicThreadPoolExecutor) {
                AlarmNotifyRequest alarmNotifyRequest = buildAlarmNotifyRequest(threadPoolExecutor);
                alarmNotifyRequest.setThreadPoolId(threadPoolId);
                hippo4jSendMessageService.sendAlarmMessage(NotifyTypeEnum.REJECT, alarmNotifyRequest);
            }
        };//在这里把任务提交给ASYNC_ALARM_NOTIFY_EXECUTOR线程池
        ASYNC_ALARM_NOTIFY_EXECUTOR.execute(checkPoolRejectedAlarmTask);
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：异步给用户发送线程池中执行任务超时的告警信息的方法
     */
    @Override
    public void asyncSendExecuteTimeOutAlarm(String threadPoolId, long executeTime, long executeTimeOut, ThreadPoolExecutor threadPoolExecutor) {
        ThreadPoolNotifyAlarm alarmConfig = GlobalNotifyAlarmManage.get(threadPoolId);
        if (Objects.isNull(alarmConfig) || !alarmConfig.getAlarm()) {
            return;
        }
        if (threadPoolExecutor instanceof DynamicThreadPoolExecutor) {
            try {
                AlarmNotifyRequest alarmNotifyRequest = buildAlarmNotifyRequest(threadPoolExecutor);
                alarmNotifyRequest.setThreadPoolId(threadPoolId);
                //设置线程执行本次任务耗费的时间，这个时间肯定大于超时时间，否则不会触发告警通知
                alarmNotifyRequest.setExecuteTime(executeTime);
                //设置任务执行的超时时间
                alarmNotifyRequest.setExecuteTimeOut(executeTimeOut);
                //移除线程本地map中的任务超时标志
                String executeTimeoutTrace = ExecutorTraceContextUtil.getAndRemoveTimeoutTrace();
                //把标志设置到请求中，告诉用户
                if (StringUtil.isNotBlank(executeTimeoutTrace)) {
                    alarmNotifyRequest.setExecuteTimeoutTrace(executeTimeoutTrace);
                }
                //创建发送通知的异步任务
                Runnable task = () -> hippo4jSendMessageService.sendAlarmMessage(NotifyTypeEnum.TIMEOUT, alarmNotifyRequest);
                //异步发送告警通知
                ASYNC_ALARM_NOTIFY_EXECUTOR.execute(task);
            } catch (Throwable ex) {
                // 如果在执行过程中出现异常，记录错误日志
                log.error("Send thread pool execution timeout alarm error.", ex);
            }
        }
    }



    public AlarmNotifyRequest buildAlarmNotifyRequest(ThreadPoolExecutor threadPoolExecutor) {
        BlockingQueue<Runnable> blockingQueue = threadPoolExecutor.getQueue();
        RejectedExecutionHandler rejectedExecutionHandler = threadPoolExecutor.getRejectedExecutionHandler();
        long rejectCount = threadPoolExecutor instanceof DynamicThreadPoolExecutor
                ? ((DynamicThreadPoolExecutor) threadPoolExecutor).getRejectCountNum()
                : -1L;
        return AlarmNotifyRequest.builder()
                .appName(StringUtil.isBlank(itemId) ? applicationName : itemId)
                .active(active.toUpperCase())
                .identify(IdentifyUtil.getIdentify())
                .corePoolSize(threadPoolExecutor.getCorePoolSize())
                .maximumPoolSize(threadPoolExecutor.getMaximumPoolSize())
                .poolSize(threadPoolExecutor.getPoolSize())
                .activeCount(threadPoolExecutor.getActiveCount())
                .largestPoolSize(threadPoolExecutor.getLargestPoolSize())
                .completedTaskCount(threadPoolExecutor.getCompletedTaskCount())
                .queueName(blockingQueue.getClass().getSimpleName())
                .capacity(blockingQueue.size() + blockingQueue.remainingCapacity())
                .queueSize(blockingQueue.size())
                .remainingCapacity(blockingQueue.remainingCapacity())
                .rejectedExecutionHandlerName(rejectedExecutionHandler.getClass().getSimpleName())
                .rejectCountNum(rejectCount)
                .build();
    }
}
```

随着上面代码块的展示，大家也就知道了 DefaultThreadPoolCheckAlarmHandler 类的具体作用，**当然，结合 TaskTimeoutNotifyAlarmPlugin 类，大家肯定也就知道了 TaskTimeoutNotifyAlarmPlugin 类的 processTaskTime 方法在检查到有任务执行超时了，调用 handler.asyncSendExecuteTimeOutAlarm 这个方法时，究竟会执行什么操作。实际上，这时候程序就会来到 DefaultThreadPoolCheckAlarmHandler 类中，执行该类的 asyncSendExecuteTimeOutAlarm 方法，异步给用户发送任务超时告警通知**。

  

如果大家掌握了上面代码块中的逻辑，那么大家肯定就会注意到一个新的成员变量，那就是 Hippo4jSendMessageService 类，这个类的对象会被自动注入到 DefaultThreadPoolCheckAlarmHandler 中，所以 Hippo4jSendMessageService 类的对象肯定也要交给 SpringBoot 容器来管理。并且，在 DefaultThreadPoolCheckAlarmHandler 的各个发送告警通知给用户的方法中，我们可以看到，最终还是调用了 Hippo4jSendMessageService 对象的 sendAlarmMessage 方法，把消息通知发送给了用户。**这就意味着 DefaultThreadPoolCheckAlarmHandler 对象的真正作用其实就是用来检查线程池的各个重要信息，然后判断是否要发送告警通知，而真正发送告警通知的操作其实是由 Hippo4jSendMessageService 对象执行的**。好了，现在 Hippo4jSendMessageService 类的功能我们已经清楚了，就是用来给用户发送告警通知的，那么这个 Hippo4jSendMessageService 类中究竟有什么呢？或者说应该定义什么呢？

这个时候我就没必要再绕弯子了，因为已经讲到底了。在文章一开始我就为大家引入了 SendMessageHandler 接口，并且告诉大家这个接口有三个实现类，分别对应三个平台，我还为大家展示了微信平台的告警通知发送器。大家肯定也能猜到了，**不管怎么说，最后发送告警通知肯定还是要用这三个平台消息发送器来发送，就看用户在配置文件中定义的是哪个平台，然后找到对应的平台发送器，最后给平台发送告警通知即可。这些就是 Hippo4jSendMessageService 对象的主要工作**。所以我在 Hippo4jSendMessageService 类中定义了一个 map 成员变量，map 中存放了三个平台消息发送器，Hippo4jSendMessageService 根据用户定义的平台信息选择合适的平台消息发送器，然后发送通知即可。接下来，请大家看一看 Hippo4jSendMessageService 类的具体实现，请看下面代码块。

```
package cn.hippo4j.message.service;


/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/10
 * @方法描述：提供了发送告警信息或者配置变更信息基础服务的类
 */
@Slf4j
@RequiredArgsConstructor
public class Hippo4jBaseSendMessageService implements Hippo4jSendMessageService {


    //存放线程池对应的通知配置信息的map，这个map大家可以暂时忽略
    @Getter
    public final Map<String, List<NotifyConfigDTO>> notifyConfigs = new HashMap<>();


    //存放消息发送器的map，这里的消息发送器就是每个平台消息发送的对象，对应着微信等等平台
    private final Map<String, SendMessageHandler> sendMessageHandlers = new HashMap<>();


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：向用户发送告警通知的方法，方法的逻辑很简单，我就不添加注释了
     */
    @Override
    public void sendAlarmMessage(NotifyTypeEnum typeEnum, AlarmNotifyRequest alarmNotifyRequest) {
        String threadPoolId = alarmNotifyRequest.getThreadPoolId();
        String buildKey = new StringBuilder()
                .append(threadPoolId)
                .append("+")
                .append("ALARM")
                .toString();
        List<NotifyConfigDTO> notifyList = notifyConfigs.get(buildKey);
        if (CollectionUtil.isEmpty(notifyList)) {
            return;
        }
        notifyList.forEach(each -> {
            try {//根据平台类型从sendMessageHandlers得到具体的消息发送器
                SendMessageHandler messageHandler = sendMessageHandlers.get(each.getPlatform());
                if (messageHandler == null) {
                    log.warn("Please configure alarm notification on the server. key: [{}]", threadPoolId);
                    return;
                }//判断是否可以发送报警通知
                if (isSendAlarm(each.getTpId(), each.getPlatform(), typeEnum)) {
                    //设置通知类型
                    alarmNotifyRequest.setNotifyTypeEnum(typeEnum);
                    //如果可以就在这里发送
                    messageHandler.sendAlarmMessage(each, alarmNotifyRequest);
                }
            } catch (Exception ex) {
                log.warn("Failed to send thread pool alarm notification. key: [{}]", threadPoolId, ex);
            }
        });
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：向用户发送配置变更通知的方法，方法的逻辑很简单，我就不添加注释了
     */
    @Override
    public void sendChangeMessage(ChangeParameterNotifyRequest changeParameterNotifyRequest) {
        String threadPoolId = changeParameterNotifyRequest.getThreadPoolId();
        String buildKey = new StringBuilder()
                .append(threadPoolId)
                .append("+")
                .append("CONFIG")
                .toString();
        List<NotifyConfigDTO> notifyList = notifyConfigs.get(buildKey);
        if (CollectionUtil.isEmpty(notifyList)) {
            log.warn("Please configure alarm notification on the server. key: [{}]", threadPoolId);
            return;
        }
        notifyList.forEach(each -> {
            try {//根据平台类型从sendMessageHandlers得到具体的消息发送器
                SendMessageHandler messageHandler = sendMessageHandlers.get(each.getPlatform());
                if (messageHandler == null) {
                    log.warn("Please configure alarm notification on the server. key: [{}]", threadPoolId);
                    return;
                }
                messageHandler.sendChangeMessage(each, changeParameterNotifyRequest);
            } catch (Exception ex) {
                log.warn("Failed to send thread pool change notification. key: [{}]", threadPoolId, ex);
            }
        });
    }


    //判断是否可以向用户发送告警通知的方法
    private boolean isSendAlarm(String threadPoolId, String platform, NotifyTypeEnum typeEnum) {
       //该方法暂不实现
    }

}
```

上面代码块的逻辑，非常简单，我就不再赘述了。如果大家理解了上面代码块的逻辑，心里肯定会有一些挥之不去的疑团，**那就是 sendMessageHandlers 这个 map 中的平台消息发送器是什么时候、是怎么被存放到这个 map 中的呢？这个其实还很好说，只要在 SpringBoot 容器启动的过程中，从 SpringBoot 容器中获得平台消息发送器对象，然后把这些对象放到 map 中即可。当然，这样一来，这些平台消息发送器对象肯定要交给 SpringBoot 容器来管理了**。

**除此之外，在上面的 Hippo4jBaseSendMessageService 类中，还有一个 notifyConfigs 成员变量，这个成员变量的作用是什么呢？我在注释中解释说这个成员变量存放的是每一个动态线程池对应的平台通知配置信息，那这个平台通知配置信息究竟是什么？又是怎么被收集到，然后存放到 notifyConfigs 这个 map 中呢**？

**还有一点，那就是当动态线程池框架给用户发送告警通知时，可不可以定义一个告警通知发送的频率？也就是说虽然我实现了动态线程池向用户发送告警通知功能，但是这个告警通知也没必要一直发送，或者说没必要发送得那么频繁，我可以让它每隔 30 分钟发送一次告警通知。当然，我并不是要程序每隔 30 秒必须发送告警通知，而是在有告警通知的情况下，看看这次通知的发送时间和上一次通知发送时间是否间隔了 30 秒，如果间隔了 30 秒，那就可以发送。这个功能又该怎么实现呢**？接下来，就让我为大家一一解释吧。

实际上，在 web 前端还有一个界面，那就是通知报警界面，具体内容请看下图。

![](https://cdn.nlark.com/yuque/0/2024/png/26725125/1717487876068-099e974e-c223-44a9-ad96-7fac73bb4eda.png)

可以看到，当用户点击了前端的通知报警界面，就可以从后端得到用户配置的动态线程池的告警通知配置信息。这些信息既可以配置在客户端的配置文件中，也可以直接由用户在 web 界面配置。**线程池信息告警通知的平台、频率、通知类型、接收者等等都可以在 web 界面配置**。这就是所谓的平台通知配置信息，也就是 Hippo4jBaseSendMessageService 类的 notifyConfigs 成员变量中应该存放的信息。那么这些信息怎么存放到 notifyConfigs 这个 map 中呢？这时候就要对 Hippo4jBaseSendMessageService 做一点重构了，并且还要引入一个新的类，那就是 NotifyConfigBuilder。从名字上来看，这个 NotifyConfigBuilder 类就是一个通知配置信息构建器，这个类的对象会在动态线程池框架的客户端发挥作用。**实际上，在程序启动的过程中，这个 NotifyConfigBuilder 配置信息构建器会主动访问服务端，从服务端的数据库中把动态线程池的配置信息获取了，这样一来，客户端不就可以得到动态线程池的告警通知配置信息了吗？那怎么让程序启动的时候执行这个操作呢？确切地说，是让 Hippo4jBaseSendMessageService 类执行这个操作，因为最后收集到的动态线程池的通知配置信息肯定是存放到这个类的 notifyConfigs 成员变量中的，这很好办，只要让 Hippo4jBaseSendMessageService 实现 CommandLineRunner 接口，并且把 Hippo4jBaseSendMessageService 类的对象也交给 SpringBoot 容器来管理就行了**。

  

下面就是重构之后的 Hippo4jBaseSendMessageService 类，请看下面代码块。

```

package cn.hippo4j.message.service;


/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/10
 * @方法描述：提供了发送告警信息或者配置变更信息基础服务的类，这个类实现了CommandLineRunner接口
 */
@Slf4j
@RequiredArgsConstructor
public class Hippo4jBaseSendMessageService implements Hippo4jSendMessageService, CommandLineRunner {

    //线程池告警通知配置信息构建器
    private final NotifyConfigBuilder notifyConfigBuilder;

    //这个类是用来限制告警信息发送频率的
    //这个成员变量和上面的成员变量内容都很简单，所以我就不在文章张为大家展示AlarmControlHandler和NotifyConfigBuilder类了
    //大家去看第八版本代码，这两个类的代码很简单，属于那种看一眼就知道是什么逻辑，怎么发挥作用的代码
    private final AlarmControlHandler alarmControlHandler;
    

    //存放线程池对应的通知配置信息的map，这个map大家可以暂时忽略
    @Getter
    public final Map<String, List<NotifyConfigDTO>> notifyConfigs = new HashMap<>();


    //存放消息发送器的map，这里的消息发送器就是每个平台消息发送的对象，对应着微信等等平台
    private final Map<String, SendMessageHandler> sendMessageHandlers = new HashMap<>();


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：向用户发送告警通知的方法，方法的逻辑很简单，我就不添加注释了
     */
    @Override
    public void sendAlarmMessage(NotifyTypeEnum typeEnum, AlarmNotifyRequest alarmNotifyRequest) {
        String threadPoolId = alarmNotifyRequest.getThreadPoolId();
        String buildKey = new StringBuilder()
                .append(threadPoolId)
                .append("+")
                .append("ALARM")
                .toString();
        List<NotifyConfigDTO> notifyList = notifyConfigs.get(buildKey);
        if (CollectionUtil.isEmpty(notifyList)) {
            return;
        }
        notifyList.forEach(each -> {
            try {//根据平台类型从sendMessageHandlers得到具体的消息发送器
                SendMessageHandler messageHandler = sendMessageHandlers.get(each.getPlatform());
                if (messageHandler == null) {
                    log.warn("Please configure alarm notification on the server. key: [{}]", threadPoolId);
                    return;
                }//判断是否可以发送报警通知
                if (isSendAlarm(each.getTpId(), each.getPlatform(), typeEnum)) {
                    //设置通知类型
                    alarmNotifyRequest.setNotifyTypeEnum(typeEnum);
                    //如果可以就在这里发送
                    messageHandler.sendAlarmMessage(each, alarmNotifyRequest);
                }
            } catch (Exception ex) {
                log.warn("Failed to send thread pool alarm notification. key: [{}]", threadPoolId, ex);
            }
        });
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：向用户发送配置变更通知的方法，方法的逻辑很简单，我就不添加注释了
     */
    @Override
    public void sendChangeMessage(ChangeParameterNotifyRequest changeParameterNotifyRequest) {
        String threadPoolId = changeParameterNotifyRequest.getThreadPoolId();
        String buildKey = new StringBuilder()
                .append(threadPoolId)
                .append("+")
                .append("CONFIG")
                .toString();
        List<NotifyConfigDTO> notifyList = notifyConfigs.get(buildKey);
        if (CollectionUtil.isEmpty(notifyList)) {
            log.warn("Please configure alarm notification on the server. key: [{}]", threadPoolId);
            return;
        }
        notifyList.forEach(each -> {
            try {//根据平台类型从sendMessageHandlers得到具体的消息发送器
                SendMessageHandler messageHandler = sendMessageHandlers.get(each.getPlatform());
                if (messageHandler == null) {
                    log.warn("Please configure alarm notification on the server. key: [{}]", threadPoolId);
                    return;
                }
                messageHandler.sendChangeMessage(each, changeParameterNotifyRequest);
            } catch (Exception ex) {
                log.warn("Failed to send thread pool change notification. key: [{}]", threadPoolId, ex);
            }
        });
    }


    //判断是否可以向用户发送告警通知的方法，在这个方法中，alarmControlHandler成员变量就发挥了作用
    private boolean isSendAlarm(String threadPoolId, String platform, NotifyTypeEnum typeEnum) {
        AlarmControlDTO alarmControl = AlarmControlDTO.builder()
                .threadPool(threadPoolId)
                .platform(platform)
                .typeEnum(typeEnum)
                .build();
        return alarmControlHandler.isSendAlarm(alarmControl);
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：CommandLineRunner接口中的回调方法，这个接口回调的时候，会访问服务端，从服务端获取线程池对应的通知告警配置信息
     */
    @Override
    public void run(String... args) throws Exception {
        //在这里从Springboot容器中获得所有的告警通知消息发送器
        Map<String, SendMessageHandler> sendMessageHandlerMap =
                ApplicationContextHolder.getBeansOfType(SendMessageHandler.class);
        //把消息发送器存放到map中
        sendMessageHandlerMap.values().forEach(each -> sendMessageHandlers.put(each.getType(), each));
        //在这里使用配置信息构建器从服务器获取线程池对应的通知配置信息
        Map<String, List<NotifyConfigDTO>> buildNotify = notifyConfigBuilder.buildNotify();
        //缓存到map中
        notifyConfigs.putAll(buildNotify);
    }
    

}
```

到此为止，我就为大家把动态线程池的告警通知功能实现了。当然，还有一些小细节我没有在文章中讲解，这些内容就留到大家去第八版本代码中查看吧。我相信如果大家认真查看第八版本代码的话，这些细节就算我没有讲解，你也无法避开，你肯定会遇到的。就比如说我在本章为大家引入的 DefaultThreadPoolCheckAlarmHandler类，这个类中的 checkPoolCapacityAlarm 方法，该方法代码如下，请看下面代码块。

```
package cn.hippo4j.message.service;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/10
 * @方法描述：默认的给用户发送线程池告警信息的对象，其中ThreadPoolCheckAlarm接口继承了CommandLineRunner接口
 */
@Slf4j
@RequiredArgsConstructor
public class DefaultThreadPoolCheckAlarmHandler implements Runnable, ThreadPoolCheckAlarm {


    //省略其他内容

     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/10
     * @方法描述：检查线程池队列容量是否需要报警的方法
     */
    @Override
    public void checkPoolCapacityAlarm(String threadPoolId, ThreadPoolExecutor threadPoolExecutor) {
        ThreadPoolNotifyAlarm alarmConfig = GlobalNotifyAlarmManage.get(threadPoolId);
        if (Objects.isNull(alarmConfig) || !alarmConfig.getAlarm() || alarmConfig.getCapacityAlarm() <= 0) {
            return;
        }
        BlockingQueue blockingQueue = threadPoolExecutor.getQueue();
        //得到队列中当前使用容量
        int queueSize = blockingQueue.size();
        //得到队列剩余容量
        int capacity = queueSize + blockingQueue.remainingCapacity();
        //得到队列容量使用率
        int divide = CalculateUtil.divide(queueSize, capacity);
        //判断队列容量使用率是否超过了告警阈值，alarmConfig.getCapacityAlarm()这里得到的就是告警阈值，可以从registerNotifyAlarm方法中查看阈值是怎么设置的
        //至于registerNotifyAlarm方法，会在DynamicThreadPoolPostProcessor、DynamicThreadPoolConfigService这两个类中被调用
        boolean isSend = alarmConfig.getAlarm() && divide > alarmConfig.getCapacityAlarm();
        if (isSend) {
            //超过了告警阈值就直接给用户发送告警通知
            AlarmNotifyRequest alarmNotifyRequest = buildAlarmNotifyRequest(threadPoolExecutor);
            alarmNotifyRequest.setThreadPoolId(threadPoolId);
            //发送的是队列容量告警通知
            hippo4jSendMessageService.sendAlarmMessage(NotifyTypeEnum.CAPACITY, alarmNotifyRequest);
        }
    }



    //省略其他内容
}
```

在上面代码块的第 39 行，判断队列负载是否超过了用户定义的阈值，那么这个阈值该怎么获得呢？在上面的代码块中是从 alarmConfig 这个变量中获得的，那么 alarmConfig 这个变量又是怎么获得的呢？从上面的代码块中看，显然是从 GlobalNotifyAlarmManage.get(threadPoolId) 这个方法返回的。那么 GlobalNotifyAlarmManage 是什么呢？这个我没有给大家讲吧？它怎么存放用户定义的报警阈值配置信息呢？这个我也没给大家讲解。但不是我不想写文章了，而是这些类太简单了，整个类就三行代码，我实在不想把时间耗费在这么简单的类上面，所以就留给大家自己查看了。当然，还有一个通知功能我没有给大家讲解，那就是配置变更通知。虽然配置变更通知的方法我在上面的那些代码块中都实现了，但是配置变更通知的方法被调用的起点，这个我也没有为大家讲解。大家可以想一想，客户端动态线程池的配置变更的操作是在哪个对象中执行的，只要配置一发生变更，就可以给用户发送配置变更通知了，那里就是要调用配置变更通知的方法的起点。大家可以把 DefaultThreadPoolConfigChangeHandler 这个类当作突破口学习，其实也就是十几行代码的事。

好了，到此为止，hippo4j 动态线程池框架就结束了。这个框架非常简单，大家学起来也很轻松，所以就把这个框架当作一个休息站吧，这个框架学完了，后面还有一些比较难的框架再等着我们。各位朋友，我们下一个框架见！