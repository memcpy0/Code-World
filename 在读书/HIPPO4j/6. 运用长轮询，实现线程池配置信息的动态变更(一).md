**在看这一篇文章之前，请大家去往盘中下载最新的代码，我在写作的过程中修复了一些注释，当初迭代代码的时候遗漏了一些重要信息，现在全部补充完整了**

如诸位所知，动态线程池框架最重要的一个功能就是动态更新线程池的配置信息。经过前几章的讲解，线程池动态更新的过程想必大家也都清楚了：**那就是客户端启动之后，会把用户创建的动态线程池注册到服务端的数据库中，服务端会把数据库中的动态线程池信息展示在 web 界面，用户想修改某个线程池的配置信息时，就可以直接在 web 界面修改；修改后的数据会传递到服务端，服务端发现某个动态线程池的配置信息被用户修改了，就会通知对应的客户端，让客户端动态修改本地线程池的配置信息**。这个过程看起来非常简单，我相信大家在看到这个过程后很快就可以整理出一个开发思路。**这不就是典型的发布订阅模式吗**？如果配置变更的整个过程都发生在本地，那就更简单了，**只要给动态线程池定义一个监听器，或者说是创建一个对应的订阅者对象，让这个订阅者对象订阅配置变更事件，也就是 LocalDataChangeEvent 事件，当配置发生变更的时候，就让程序发布一个 LocalDataChangeEvent 配置变更事件，订阅了这个事件的订阅者就可以执行内部的方法，当然，这个方法肯定就是刷新线程池配置信息的方法了**。这样一来，线程池的配置信息的动态变更就实现了。

但是，现在我们的动态线程池框架分为了客户端和服务端两个部分，配置变更的操作首先发生在服务端，因为用户在 web 界面修改了线程池的配置之后，首先就会被服务端感知到，随后才会由服务端通知客户端，让客户端进行相应的线程池配置变更操作。**这个时候该怎么运用发布订阅模式呢？或者说，发布订阅模式应该在哪里使用呢**？这是一个疑问，大家可以先思考思考。除了这个问题，我们还面临着一个问题，**那就是客户端线程池的配置变更操作是在服务端的通知下执行的，但客户端和服务端使用的是 http 通信协议，所以一般情况下，就算服务端发现有线程池动态变更了，也不可能主动给客户端发送请求通知，让客户端对线程池进行配置变更**。那这个问题又该怎么解决呢？这个就很简单了，既然服务端不能主动向客户端发送通知请求，**那就让客户端向服务端发送请求，客户端主动去服务端查询线自己注册的动态线程池配置信息是否需要动态变更**。但是客户端又不知道用户什么时候在 web 界面修改了线程池的配置信息，所以，如果要让客户端主动感知到注册在服务端的线程池配置发生变更了，就要让客户端不间断地向服务端发送请求，一直查询是否有线程池配置发生变更了。这不就是很常见的长轮询请求模式吗？所谓长轮询，**就是客户端向服务端发送请求，服务端并不会立刻回复响应，而是 hold 请求，也就是把请求先挂起，等待固定的时间之后，也许是 10 秒，也许是 30 秒，再异步回复客户端响应；在服务端挂起客户端请求的过程中，如果用户在 web 界面修改了线程池信息，那么服务端就可以直接回复客户端响应，通知客户端进行线程池配置变更；当然，如果本次请求客户端并没有发现需要进行配置变更的线程池，客户端在收到服务端回复的空响应之后，就会立即发送新的请求，就这样循环下去即可**。这就是长轮询请求的工作模式。

好了，长轮询工作模式讲解完了，接下来我就先为客户端实现这个长轮询工作模式，毕竟目前我们主要实现的都是客户端的功能。**首先我要做的就是为每一个注册到服务端的动态线程池定义一个监听器**，这一步跨度可能有点大，明明刚才还在讲解客户端要实现的长轮询工作模式，怎么忽然跳转到要给客户端的动态线程池定义监听器了呢？原因其实很简单，**当客户端接收到服务端回复的响应后，如果判断出要对一些线程池进行配置动态变更的操作，这时候肯定要就执行这些操作，这些操作就被我定义在了监听器的方法中。说到底，这个监听器中定义的就是一个刷新线程池配置信息的方法，该方法会在客户端接收到线程池需要动态变更的响应后被回调**。所以，我想在实现客户端的长轮询工作模式之前，先把线程池的监听器功能实现了。

## 引入 DynamicThreadPoolSubscribeConfig，实现线程池配置变更监听功能

  

我实现线程池监听器的功能也很简单，首先我为动态线程池框架定义一个新的类，**就叫做 ServerThreadPoolDynamicRefresh，从名字上也能看出来，这个类的对象就是负责动态刷新线程池配置信息工作的**。在这个 ServerThreadPoolDynamicRefresh 类中，我定义了一个 dynamicRefresh 方法，这个方法就是动态刷新客户端本地线程池配置信息的入口方法，具体实现请看下面代码块。

```
package cn.hippo4j.springboot.start.core;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：线程池配置信息动态刷新器，这个动态刷新器在第三版本还不完善，因为在动态刷新本地线程池信息后，实际上还要通知用户
 * 但是在第三版本代码中，还没有实现通知用户的功能，后面会重构完整，主要是重构refreshDynamicPool方法
 */
@Slf4j
@AllArgsConstructor
public class ServerThreadPoolDynamicRefresh implements ThreadPoolDynamicRefresh {


    //动态刷新本地线程池的入口方法
    //content就是从服务端传递过来的最新的线程池的配置信息字符串对象
    @Override
    public void dynamicRefresh(String content) {
        //把从服务端得到的最新的线程池的配置信息转换为ThreadPoolParameterInfo对象
        ThreadPoolParameterInfo parameter = JSONUtil.parseObject(content, ThreadPoolParameterInfo.class);
        //得到线程池Id
        String threadPoolId = parameter.getTpId();
        //从全局线程池管理器中得到对应的线程池，这个线程池就是程序中正在运行的线程池
        ThreadPoolExecutor executor = GlobalThreadPoolManage.getExecutorService(threadPoolId).getExecutor();
        //刷新线程池的信息
        changePoolInfo(parameter, executor);
    }

}
```

可以看到，在上面的代码块的 dynamicRefresh 方法中，会先把从服务端得到的最新的动态线程池配置信息字符串对象转换为一个 ThreadPoolParameterInfo 对象，然后根据动态线程池的 threadPoolId 从全局线程池管理器中获得对应的动态线程池，接着执行了 changePoolInfo 方法真正改变线程池的配置信息。changePoolInfo 方法我也实现好了，请看下面代码块。

```
package cn.hippo4j.springboot.start.core;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：线程池配置信息动态刷新器，这个动态刷新器在第三版本还不完善，因为在动态刷新本地线程池信息后，实际上还要通知用户
 * 但是在第三版本代码中，还没有实现通知用户的功能，后面会重构完整，主要是重构refreshDynamicPool方法
 */
@Slf4j
@AllArgsConstructor
public class ServerThreadPoolDynamicRefresh implements ThreadPoolDynamicRefresh {


    //动态刷新本地线程池的入口方法
    //content就是从服务端传递过来的最新的线程池的配置信息字符串对象
    @Override
    public void dynamicRefresh(String content) {
        //把从服务端得到的最新的线程池的配置信息转换为ThreadPoolParameterInfo对象
        ThreadPoolParameterInfo parameter = JSONUtil.parseObject(content, ThreadPoolParameterInfo.class);
        //得到线程池Id
        String threadPoolId = parameter.getTpId();
        //从全局线程池管理器中得到对应的线程池，这个线程池就是程序中正在运行的线程池
        ThreadPoolExecutor executor = GlobalThreadPoolManage.getExecutorService(threadPoolId).getExecutor();
        //刷新线程池的信息
        changePoolInfo(parameter, executor);
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：刷线客户端本地线程池信息的方法
     */
    private void changePoolInfo(ThreadPoolExecutor executor, ThreadPoolParameter parameter) {
        //判断一下服务端更新之后的线程池信息是否设置了线程池的核心线程数和最大线程数
        if (parameter.getCoreSize() != null && parameter.getMaxSize() != null) {
            //如果服务端更新之后的最大线程数小于当前客户端线程池的最大线程数
            if (parameter.getMaxSize() < executor.getMaximumPoolSize()) {
                //那就先更新核心线程数，防止最大线程数小于本地线程池的核心线程数
                executor.setCorePoolSize(parameter.getCoreSize());
                //然后再更新本地现成的最大线程数
                executor.setMaximumPoolSize(parameter.getMaxSize());
            } else {
                //走到这里就意味着服务端的最大线程数大于本地的最大线程数
                //那就可以先更新最大线程数，然后再更新核心线程数
                executor.setMaximumPoolSize(parameter.getMaxSize());
                executor.setCorePoolSize(parameter.getCoreSize());
            }
        } else {
            if (parameter.getMaxSize() != null) {
                executor.setMaximumPoolSize(parameter.getMaxSize());
            }
            if (parameter.getCoreSize() != null) {
                executor.setCorePoolSize(parameter.getCoreSize());
            }
        }//判断队列容量做非空判断，同时判断队列类型是否为ResizableCapacityLinkedBlockingQueue类型
        if (parameter.getCapacity() != null
                && Objects.equals(BlockingQueueTypeEnum.RESIZABLE_LINKED_BLOCKING_QUEUE.getType(), parameter.getQueueType())) {
            if (executor.getQueue() instanceof ResizableCapacityLinkedBlockingQueue) {
                ResizableCapacityLinkedBlockingQueue queue = (ResizableCapacityLinkedBlockingQueue) executor.getQueue();
                queue.setCapacity(parameter.getCapacity());
            } else {
                log.warn("The queue length cannot be modified. Queue type mismatch. Current queue type: {}", executor.getQueue().getClass().getSimpleName());
            }
        }//更新线程存活时间
        if (parameter.getKeepAliveTime() != null) {
            executor.setKeepAliveTime(parameter.getKeepAliveTime(), TimeUnit.SECONDS);
        }//更新任务执行超时时间
        Long executeTimeOut = Optional.ofNullable(parameter.getExecuteTimeOut()).orElse(0L);
        if (executor instanceof DynamicThreadPoolExecutor) {
            ((DynamicThreadPoolExecutor) executor).setExecuteTimeOut(executeTimeOut);
        }//更新拒绝策略
        if (parameter.getRejectedType() != null) {
            RejectedExecutionHandler rejectedExecutionHandler = RejectedPolicyTypeEnum.createPolicy(parameter.getRejectedType());
            executor.setRejectedExecutionHandler(rejectedExecutionHandler);
        }//更新是否允许超过存活时间的核心线程终止工作
        if (parameter.getAllowCoreThreadTimeOut() != null) {
            executor.allowCoreThreadTimeOut(EnableEnum.getBool(parameter.getAllowCoreThreadTimeOut()));
        }
    }

}
```

changePoolInfo 方法的逻辑非常简单，就是动态刷新线程池的配置信息的逻辑，我就不再重复讲解了。只要线程池的配置信息刷新了，之后线程池在运行的过程中，就会按照最新的配置信息来运行。到此为止，动态刷新线程池的功能，我就给大家实现了。当然，确切地说，我只是实现了第一步，最简单的一步，因为对整个动态线程池框架来说，重要的不是这个 changePoolInfo 方法，而是在哪里触发这个方法，在哪里调用这个方法。而这个刚才我已经为大家分析了，只要为每一个动态线程池定义一个监听器对象即可。所以，接下来就轮到监听器对象登场了。

大家应该都还记得在程序启动的过程中，动态线程池框架的客户端会把用户创建的所有动态线程池对象都注册到服务端，具体操作是在 DynamicThreadPoolPostProcessor 类中执行的，具体实现请看下面代码块。

```
package cn.hippo4j.springboot.start.support;




@Slf4j
@AllArgsConstructor
public final class DynamicThreadPoolPostProcessor implements BeanPostProcessor {

    //配置信息对象
    private final BootstrapProperties properties;

    //客户端代理对象
    private final HttpAgent httpAgent;





     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/27
     * @方法描述：这个方法就是本类最核心的方法，用来处理DynamicThreadPoolExecutor对象
     */
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {

        //省略方法部分内容
        
        //在这里把动态线程池的信息注册给服务端了
        ThreadPoolExecutor remoteThreadPoolExecutor = fillPoolAndRegister(dynamicThreadPoolWrapper);

        //省略方法部分内容
            
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/27
     * @方法描述：注册线程池信息到服务端的方法
     */
    protected ThreadPoolExecutor fillPoolAndRegister(DynamicThreadPoolWrapper dynamicThreadPoolWrapper) {

        //省略方法部分内容
        
        //在这里使用parameterInfo创建了DynamicThreadPoolRegisterWrapper对象，这个对象要发送给服务端进行注册
        DynamicThreadPoolRegisterWrapper registerWrapper = DynamicThreadPoolRegisterWrapper.builder()
                .parameter(parameterInfo)
                   .build();
        //将线程池信息注册到服务端，这里是通过线程池全局管理器来注册的
        GlobalThreadPoolManage.dynamicRegister(registerWrapper);

        
        //省略方法部分内容
              
    }

}
```

在第一版本代码中，我就为大家实现了客户端向服务端注册线程池配置信息的功能，这个功能很简单，其实没必要重复讲解。但我在这里忽然提到这个功能是有原因的，**如果大家都用过 nacos，肯定也知道 nacos 的客户端会把提供服务的服务器包装成一个服务实例对象注册到服务端，不仅如此，nacos 客户端还提供了服务订阅功能，当 nacos 的某个客户端订阅了服务器的某个服务之后，那么 nacos 的客户端就会获得该服务下的所有服务实例信息，并且当这些服务实例信息在服务端发生变更之后，服务端会及时通知客户端更新本地缓存到服务实例信息**。现在，我准备仿照 nacos 的这个服务订阅功能，也为我的动态线程池框架的客户端提供服务订阅功能，**只要是客户端注册到服务端的线程池，客户端都可以订阅它们的信息，并且可以根据服务端的通知判断是否可以动态刷新所订阅的线程池的配置信息；换句话说，如果客户端把某个动态线程池注册到服务端了，但是并没有订阅这个线程池的配置信息，那么这个线程池的配置即便在服务端发生变更了，客户端也不会对其进行动态更新**。但用户使用我开发的动态线程池框架，肯定希望创建的所有动态线程池对象的配置信息都可以动态更新，我也不希望用户自己手动订阅线程池配置变更信息，这就太麻烦了，所以我打算是当客户端在 DynamicThreadPoolPostProcessor 对象中把线程池注册到服务端了，紧接着就在框架内部自动订阅注册到服务端的线程池。为了实现这个功能，我又为动态线程池框架引入了一个新的类，就是 DynamicThreadPoolSubscribeConfig，翻译过来就是订阅线程池配置信息的类。这个类的具体实现如下，请看下面代码块。

```
package cn.hippo4j.springboot.start.core;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：客户端动态线程池订阅服务端配置信息的类
 */
@RequiredArgsConstructor
public class DynamicThreadPoolSubscribeConfig {

    //动态线程池配置信息刷新器
    private final ThreadPoolDynamicRefresh threadPoolDynamicRefresh;

    //配置信息对象
    private final BootstrapProperties properties;

    //创建一个执行器，这个执行器是专门用来执行监听器中的任务的
    //既然要订阅服务端配置信息是否发生变化，肯定就要创建一个对应的监听器，使用观察者模式呀
    //这样一来，等客户端监听到服务端配置信息发生变化了，就会立刻调用监听器中的方法，而监听器中的方法就是动态刷新本地动态线程池的方法
    //这个刷新的操作就由下面创建的执行器来异步执行
    private final ExecutorService configRefreshExecutorService = ThreadPoolBuilder.builder()
            .corePoolSize(1)
            .maxPoolNum(2)
            .keepAliveTime(2000)
            .timeUnit(TimeUnit.MILLISECONDS)
            .workQueue(BlockingQueueTypeEnum.SYNCHRONOUS_QUEUE)
            .allowCoreThreadTimeOut(true)
            .threadFactory("client.dynamic.threadPool.change.config")
            .rejected(new ThreadPoolExecutor.AbortPolicy())
            .build();


    //订阅服务端线程池配置信息的方法
    public void subscribeConfig(String threadPoolId) {
        //在这里把要坚挺的动态线程池的id和对应的监听器方法都传进去了
        subscribeConfig(threadPoolId, threadPoolDynamicRefresh::dynamicRefresh);
    }


    //订阅服务端线程池配置信息的方法，这个方法比上面方法多了一个功能，那就是用户可以自己定义监听器方法
    public void subscribeConfig(String threadPoolId, ThreadPoolSubscribeCallback threadPoolSubscribeCallback) {
        //创建监听器对象
        Listener configListener = new Listener() {

            //监听器要执行的回调方法
            @Override
            public void receiveConfigInfo(String config) {
                threadPoolSubscribeCallback.callback(config);
            }

            //执行监听器方法时用到的执行器
            @Override
            public Executor getExecutor() {
                return configRefreshExecutorService;
            }
        };

        //接下来要怎么处理创建好的这个监听器对象呢？
    }
}
```

接下来是重构好的 DynamicThreadPoolPostProcessor 类，请看下面代码块。

```
package cn.hippo4j.springboot.start.support;




@Slf4j
@AllArgsConstructor
public final class DynamicThreadPoolPostProcessor implements BeanPostProcessor {

    //配置信息对象
    private final BootstrapProperties properties;

    //客户端代理对象
    private final HttpAgent httpAgent;

    //订阅服务端动态线程池配置信息的对象
    private final DynamicThreadPoolSubscribeConfig dynamicThreadPoolSubscribeConfig;




     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/27
     * @方法描述：这个方法就是本类最核心的方法，用来处理DynamicThreadPoolExecutor对象
     */
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {

        //省略方法部分内容
        
        //在这里把动态线程池的信息注册给服务端了
        ThreadPoolExecutor remoteThreadPoolExecutor = fillPoolAndRegister(dynamicThreadPoolWrapper);

        //dynamicThreadPoolWrapper就是刚刚注册到服务端的线程池
        //这里还有一个操作，就是订阅了dynamicThreadPoolWrapper在服务端的配置信息，订阅之后，服务端线程池信息一旦更新，就会通知客户端动态更新线程池信息
        subscribeConfig(dynamicThreadPoolWrapper);
        
        //省略方法部分内容
            
    }



    //订阅服务端动态线程池配置信息的方法
    protected void subscribeConfig(DynamicThreadPoolWrapper dynamicThreadPoolWrapper) {
        if (dynamicThreadPoolWrapper.isSubscribeFlag()) {
            //这里仅仅是把要定于的动态线程池的Id传进去了
            dynamicThreadPoolSubscribeConfig.subscribeConfig(dynamicThreadPoolWrapper.getThreadPoolId());
        }
    }

}
```

可以看到，在上面的 DynamicThreadPoolPostProcessor 类的 postProcessAfterInitialization 方法中，客户端把动态线程池注册到服务端之后，紧接着执行了 subscribeConfig(dynamicThreadPoolWrapper) 这个方法，而在这个 subscribeConfig 方法中，就会调用我刚才新引入的 DynamicThreadPoolSubscribeConfig 类中的 subscribeConfig 方法。所以接下来程序地逻辑 DynamicThreadPoolSubscribeConfig 类的 subscribeConfig 方法中。而 DynamicThreadPoolSubscribeConfig 类的 subscribeConfig 方法得到了要订阅的动态线程池的 threadPoolId，最后执行的逻辑就是为这个动态线程池创建了一个监听器对象，监听器中定义的回调方法就是之前我为大家实现的 ServerThreadPoolDynamicRefresh 类中的 dynamicRefresh 方法。到此为止，前后的逻辑不就衔接上了吗？

让我再来为大家梳理一下程序的执行流程，**当用户在程序中创建了一个动态线程池之后，在程序的启动过程中，动态线程池框架的客户端会在 DynamicThreadPoolPostProcessor 处理器的 postProcessAfterInitialization 后置处理方法中把动态线程池对象注册到服务端，注册完毕之后，紧接着客户端就会使用 DynamicThreadPoolSubscribeConfig 线程池配置信息订阅器订阅刚刚注册到服务端的线程池的配置信息；而所谓订阅，就是为该线程池创建了一个监听器，监听器中定义的方法就是 ServerThreadPoolDynamicRefresh 线程池配置信息动态刷新器中的 dynamicRefresh 方法，该方法会在客户端接收到服务端发送的线程池配置变更响应后被回调，然后，客户端就会使用服务端传送过来的线程池最新的配置信息刷新本地线程池的配置信息**。这就是客户端动态刷新本地线程池配置信息的大概流程。当然，大家应该也注意到了，不管是我刚才为大家引入的 DynamicThreadPoolSubscribeConfig 类还是 ServerThreadPoolDynamicRefresh 类，这些类的对象都被其他类持有了，显然需要被 SpringBoot 依赖注入。请看下面代码块。

```
package cn.hippo4j.springboot.start.core;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：客户端动态线程池订阅服务端配置信息的类
 */
@RequiredArgsConstructor
public class DynamicThreadPoolSubscribeConfig {

    //在这里持有了动态线程池配置信息刷新器
    private final ThreadPoolDynamicRefresh threadPoolDynamicRefresh;


    //其他内容省略
}







package cn.hippo4j.springboot.start.support;




@Slf4j
@AllArgsConstructor
public final class DynamicThreadPoolPostProcessor implements BeanPostProcessor {


    //在这里持有了订阅服务端动态线程池配置信息的对象
    private final DynamicThreadPoolSubscribeConfig dynamicThreadPoolSubscribeConfig;



    //其他内容省略
}
```

这么一来，DynamicThreadPoolSubscribeConfig 和 ServerThreadPoolDynamicRefresh 类创建的对象显然需要被 SpringBoot 管理，所以在第三版本代码中，大家会看到 DynamicThreadPoolAutoConfiguration 类中又多了一些对象。实际上，大家在渐进式学习每一版本代码时，就可以把 DynamicThreadPoolAutoConfiguration 类当作突破口，基本上每个版本添加的新功能，提供这些功能的对象都被定义在了 DynamicThreadPoolAutoConfiguration 类中。在第三版本代码中，DynamicThreadPoolAutoConfiguration 类中的主要对象如下。请看下面代码块。

```
package cn.hippo4j.springboot.start.config;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/26
 * @方法描述：这个就是spring-starter中的核心类，这个类使用了大量springboot的功能，这个类上的springboot注解应该都是常用注解了，所以这些功能我就不写注释了
 */
@Configuration
@AllArgsConstructor
@ConditionalOnBean(MarkerConfiguration.Marker.class)
@EnableConfigurationProperties(BootstrapProperties.class)
@ConditionalOnProperty(prefix = BootstrapProperties.PREFIX, value = "enable", matchIfMissing = true, havingValue = "true")
@ImportAutoConfiguration({DiscoveryConfiguration.class, UtilAutoConfiguration.class})
public class DynamicThreadPoolAutoConfiguration {

    //在这里把配置文件中的相关信息封封装到这个成员变量中了
    private final BootstrapProperties properties;

    //springboot的环境变量
    private final ConfigurableEnvironment environment;


    //创建动态线程池的服务对象，在第一版本代码中提供了注册线程池信息到服务端功能
    @Bean
    @SuppressWarnings("all")
    public DynamicThreadPoolService dynamicThreadPoolConfigService(HttpAgent httpAgent) {
        return new DynamicThreadPoolConfigService(httpAgent, properties);
    }


    //动态线程池处理器，这个处理器其实是就是spring中的一个bean处理器，在这个bean处理器中把动态线程池包装成了DynamicThreadPoolRegisterWrapper对象
    //然后开始服务端注册该动态线程池的信息
    @Bean
    @SuppressWarnings("all")
    public DynamicThreadPoolPostProcessor threadPoolBeanPostProcessor(HttpAgent httpAgent,
                                                                      ApplicationContextHolder hippo4JApplicationContextHolder,
                                                                      DynamicThreadPoolSubscribeConfig dynamicThreadPoolSubscribeConfig) {
        return new DynamicThreadPoolPostProcessor(properties, httpAgent, dynamicThreadPoolSubscribeConfig);
    }


    //远程通信组件，使用的是http通信方式
    @Bean
    public HttpAgent httpAgent(BootstrapProperties properties) {
        return new ServerHttpAgent(properties);
    }

  
    //动态刷新线程池配置信息的对象,这个对象后面还需要重构
    @Bean
    public ThreadPoolDynamicRefresh threadPoolDynamicRefresh() {
        return new ServerThreadPoolDynamicRefresh();
    }

    //订阅服务端动态线程池配置信息的对象，这个对象中的方法可以为对应的线程池设置监听器
    //一旦监听到服务器存储的线程信息发生了变化，这里就可以直接动态刷新客户端本地线程池信息
    //现在大家还不必关心这个ClientWorker客户端长轮询对象
    @Bean
    public DynamicThreadPoolSubscribeConfig dynamicThreadPoolSubscribeConfig(ThreadPoolDynamicRefresh threadPoolDynamicRefresh,
                                                                             ClientWorker clientWorker) {
        return new DynamicThreadPoolSubscribeConfig(threadPoolDynamicRefresh, clientWorker, properties);
    }


}
```

好了，随着监听器功能的实现，客户端动态刷新线程池的功能已经完成了第二步，之所以说是第二步，是因为我们目前只是给每一个注册到服务端的线程池创建了监听器对象，但是怎么处理这个监听器，我还没为大家分析。接下来就让我们围绕着这个问题讨论一下。

## 引入 ClientWorker 对象

请大家思考一个问题，在上一小节我跟大家说，**为每一个动态线程池对象创建的监听器，其内部定义的方法会在客户端接收到服务端发送的配置变更响应后被回调**。那么，监听器怎么才能和服务端发送回来的配置变更响应产生联系呢？这时候就要从客户端即将实现的长轮询工作模式入手了。在上一小节我已经为大家分析过了，因为使用的是 http 协议，所以服务端只能向客户端回复响应，无法主动发送请求，当然，如果服务端也定义了 HttpAgent 通信组件，客户端也部署在 web 服务器中，服务端肯定也可以向客户端主动发送请求，但就目前来说，服务端还不具备主动向客户端发送 http 请求的能力。所以为了让客户端及时知道本地的哪个线程池的配置信息可以刷新，就应该让客户端主动向服务端发送长轮询请求，并且在上一个请求收到响应后，紧接着就发送下一个请求。这是上一小节一开始，我就为大家分析好的思路。

那现在问题来了，我要为客户端实现长轮询工作模式，客户端需要主动向服务端发送请求查询那个线程池的配置信息可以刷新，那么客户端本地可能创建了多个动态线程池对象，客户端发送的请求到底是查询的哪个动态线程池对象的配置信息呢？也许应该全部查询，也许应该有选择性的查询，总之得知道要查询哪些动态线程池的配置信息，对吧？这个问题其实已经被我们解决了，**在上一小节我们刚实现了客户端订阅线程池配置信息的功能，只要是被客户端订阅了的动态线程池，都会被创建一个响应的监听器对象**，没有被订阅的动态线程池，客户端长轮询请求就不会去服务端查询它们的配置信息是否需要动态更新。那客户端的长轮询工作组件怎么就知道哪些动态线程池被客户端订阅了呢？**既然被客户端订阅了动态线程池，程序就会为它创建一个监听器对象，那么只要把这个监听器对象和对应的动态线程池的 Id 交给客户端的长轮询工作组件，这样一来，长轮询工作组件不就知道发送长轮询请求的时候，为客户端的哪些动态线程池查询服务端的配置信息了**？

其实客户端长轮询工作组件我早就定义好了，就是 ClientWorker 类，这个类目前的内容如下所示，请看下面代码块。

```
package cn.hippo4j.springboot.start.core;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：客户端长轮询对象，在这个对象中，开启了定时任务，定时任务会定期向服务端发送长轮询请求，监听服务端的动态线程池配置信息是否有更新
 * 如果更新了客户端就会及时感知到，然后使用服务端的配置信息更新本地线程池。这里我要多说一句，这个框架的长轮询功能其实就是复制了nacos旧版长轮询的代码
 * 代码几乎一模一样，当然，hippo4j的长轮询代码量要少一点。这一点在客户端和服务端的长轮询组件中都很明显。
 */
@Slf4j
public class ClientWorker {


   //内容暂时省略
    
}
```

是的，目前这个 ClientWorker 客户端长轮询类中什么内容也没有，不过我刚才说了，要把为每一个动态线程池对象创建的监听器对象交给长轮询对象，这样，客户端长轮询对象就知道要去服务端查询哪些线程池的配置信息变更情况了。所以我决定在 ClientWorker 类中定义一个 map，map 的 key 为动态线程池的 Id，value 就是对应的监听器对象，然后再定义一个 addTenantListeners 方法， 这个方法会把动态线程池的监听器对象添加到 ClientWorker 对象的 map 中。具体实现请看下面代码块。

```
package cn.hippo4j.springboot.start.core;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：客户端长轮询对象，在这个对象中，开启了定时任务，定时任务会定期向服务端发送长轮询请求，监听服务端的动态线程池配置信息是否有更新
 * 如果更新了客户端就会及时感知到，然后使用服务端的配置信息更新本地线程池。这里我要多说一句，这个框架的长轮询功能其实就是复制了nacos旧版长轮询的代码
 * 代码几乎一模一样，当然，hippo4j的长轮询代码量要少一点。这一点在客户端和服务端的长轮询组件中都很明显。
 */
@Slf4j
public class ClientWorker {


   //这个map就是用来缓存所有监听器对象的，每创建一个监听器对象，就意味着客户端向服务端订阅了一个线程池的配置信息
    //value就是监听器，key就是线程池的Id
    private final ConcurrentHashMap<String, Listener> cacheMap = new ConcurrentHashMap<>(16);


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：为对应的线程池添加监听器的方法
     */
    public void addTenantListeners(String threadPoolId, Listener listeners) {
       cacheMap.put(threadPoolId,listeners);
    }
    
}
```

可以看到，ClientWorker 类实现的非常简单，只要执行了 ClientWorker 对象的 addTenantListeners 方法，长轮询工作对象就知道哪些动态线程池被订阅了。那么，addTenantListeners 方法在哪里被调用呢？这时候答案已经不言而喻了，就在上一小节引入的 DynamicThreadPoolSubscribeConfig 类中，具体实现请看下面代码块。

```
package cn.hippo4j.springboot.start.core;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：客户端动态线程池订阅服务端配置信息的类
 */
@RequiredArgsConstructor
public class DynamicThreadPoolSubscribeConfig {

    //持有了长轮询对象
    private final ClientWorker clientWorker;

    //动态线程池配置信息刷新器
    private final ThreadPoolDynamicRefresh threadPoolDynamicRefresh;

    //配置信息对象
    private final BootstrapProperties properties;

    //省略其他内容


    //订阅服务端线程池配置信息的方法，这个方法比上面方法多了一个功能，那就是用户可以自己定义监听器方法
    public void subscribeConfig(String threadPoolId, ThreadPoolSubscribeCallback threadPoolSubscribeCallback) {
        //创建监听器对象
        Listener configListener = new Listener() {

            //监听器要执行的回调方法
            @Override
            public void receiveConfigInfo(String config) {
                threadPoolSubscribeCallback.callback(config);
            }

            //执行监听器方法时用到的执行器
            @Override
            public Executor getExecutor() {
                return configRefreshExecutorService;
            }
        };

        //在这里把监听器添加到长轮询对象中了
        clientWorker.addTenantListeners(threadPoolId, configListener);
    }
}




//DynamicThreadPoolSubscribeConfig类中持有了ClientWorker对象，这时候大家应该也意识到了，这个ClientWorker
//对象肯定也是要交给SpringBoot容器来管理的，所以ClientWorker对象也要定义在DynamicThreadPoolAutoConfiguration类中
//就像下面这样
package cn.hippo4j.springboot.start.config;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/26
 * @方法描述：这个就是spring-starter中的核心类，这个类使用了大量springboot的功能，这个类上的springboot注解应该都是常用注解了，所以这些功能我就不写注释了
 */
@Configuration
@AllArgsConstructor
@ConditionalOnBean(MarkerConfiguration.Marker.class)
@EnableConfigurationProperties(BootstrapProperties.class)
@ConditionalOnProperty(prefix = BootstrapProperties.PREFIX, value = "enable", matchIfMissing = true, havingValue = "true")
@ImportAutoConfiguration({DiscoveryConfiguration.class, UtilAutoConfiguration.class})
public class DynamicThreadPoolAutoConfiguration {

    //在这里把配置文件中的相关信息封封装到这个成员变量中了
    private final BootstrapProperties properties;

    //springboot的环境变量
    private final ConfigurableEnvironment environment;


    //其他内容省略
    
     //客户端长轮询对象
    @Bean
    public ClientWorker hippo4jClientWorker(HttpAgent httpAgent,
                                            InetUtils hippo4JInetUtils,
                                            ServerHealthCheck serverHealthCheck) {
        //得到服务实例的标识
        //这个其实就是客户端的ip地址+端口号+uuid
        String identify = IdentifyUtil.generate(environment, hippo4JInetUtils);
        return new ClientWorker(httpAgent, identify, serverHealthCheck);
    }
    
  
    //动态刷新线程池配置信息的对象,这个对象后面还需要重构
    @Bean
    public ThreadPoolDynamicRefresh threadPoolDynamicRefresh() {
        return new ServerThreadPoolDynamicRefresh();
    }

    //订阅服务端动态线程池配置信息的对象，这个对象中的方法可以为对应的线程池设置监听器
    //一旦监听到服务器存储的线程信息发生了变化，这里就可以直接动态刷新客户端本地线程池信息
    //现在大家还不必关心这个ClientWorker客户端长轮询对象
    @Bean
    public DynamicThreadPoolSubscribeConfig dynamicThreadPoolSubscribeConfig(ThreadPoolDynamicRefresh threadPoolDynamicRefresh,
                                                                             ClientWorker clientWorker) {
        return new DynamicThreadPoolSubscribeConfig(threadPoolDynamicRefresh, clientWorker, properties);
    }


}

```

好了，现在大家应该都知道了客户端长轮询对象怎么知道要去服务端查询哪些动态线程池的配置变更情况了。接下来，我就要继续完善这个 ClientWorker 类，把服务端交互的功能全部实现，也就是发送长轮询请求和接收响应的功能。但是在实现这个功能之前，我又想到了一个问题，DynamicThreadPoolSubscribeConfig 对象可以为线程池创建监听器对象，并且 DynamicThreadPoolSubscribeConfig 对象是交给 SpringBoot 容器来管理的，既然是这样，这个对象肯定也可以被用户获得。如果用户想给某个动态线程池框架自定义一些监听器，这些监听器中的方法也会在线程池配置变更时被回调，这时候会怎么样呢？就像下面这样，请看下面代码块。

```
DynamicThreadPoolSubscribeConfig sub = ApplicationContext.get(DynamicThreadPoolSubscribeConfig.class);
//下面就写成伪代码了
sub.subscribeConfig(线程池Id,回调方法);
```

当上面代码块的 sub.subscribeConfig(线程池Id,回调方法) 方法执行之后，程序就会来到 DynamicThreadPoolSubscribeConfig 类中，**执行 subscribeConfig 方法，把监听器对象添加到 clientWorker 对象的 map 成员变量中。可是，clientWorker 的 map 成员变量中已经添加了动态线程池框架内置的刷新线程池配置信息的监听器了，这样一来不就把这个最重要的监听器给覆盖了吗**？这是第一个问题。

还有一个问题，我想问问大家，假如服务端把某个动态线程池最新的配置信息传输给客户端了，当 ClientWorker 长轮询对象接收到这些信息之后，还需不需要再和客户端本地缓存的线程池的配置信息做一下对比呢？看看是不是真的发生了变化？我认为这个对比的步骤肯定不能省略。那假如要对比又该怎么对比呢？换句话说，**通过什么方式对比同一个线程池的两份配置信息，然后判断配置信息是否发生变更呢**？有一个常规做法，就是使用 MD5 字符串，线程池的核心配置信息其实就是那几个成员变量的值，如果把线程池的这些配置信息拼接成一个长字符串，然后使用这个字符串计算出一个 MD5 字符串，那对于这个线程池来说，在当前这个线程池的 MD5 就是固定的。就像下面代码块展示的这样，请看下面代码块。

```
//根据线程池的信息拼接出一个长字符串
public static String getPoolContent(ThreadPoolParameter parameter) {
    ThreadPoolParameterInfo threadPoolParameterInfo = new ThreadPoolParameterInfo();
    threadPoolParameterInfo.setTenantId(parameter.getTenantId())
            .setItemId(parameter.getItemId())
            .setTpId(parameter.getTpId())
            .setCoreSize(parameter.getCoreSize())
            .setMaxSize(parameter.getMaxSize())
            .setQueueType(parameter.getQueueType())
            .setCapacity(parameter.getCapacity())
            .setKeepAliveTime(parameter.getKeepAliveTime())
            .setExecuteTimeOut(parameter.getExecuteTimeOut())
            .setIsAlarm(parameter.getIsAlarm())
            .setCapacityAlarm(parameter.getCapacityAlarm())
            .setLivenessAlarm(parameter.getLivenessAlarm())
            .setAllowCoreThreadTimeOut(parameter.getAllowCoreThreadTimeOut())
            .setRejectedType(parameter.getRejectedType());
    return JSONUtil.toJSONString(threadPoolParameterInfo);
}




//然后把线程池的长字符串交给下面这个方法使用
//得到线程池的md5
public static String getMd5String(String config) {
    return (null == config) ? Constants.NULL : Md5Util.md5Hex(config, Constants.ENCODE);
}
```

那得到了线程池的 MD5 有什么用呢？**请大家想一想，线程池本身的 TenantId、ItemId、ThreadPoolId 是不会变的，剩下的就是线程池的配置信息了，如果线程池的配置信息发生了一点变化，根据这些信息计算出来的 MD5 的值肯定就不同了。所以，我们只要比较同一个线程池两个时刻的 MD5 的值，判断这两个值是否相同，就可以知道线程池的配置信息是否发生了变化**。这个逻辑大家应该都清楚吧。但现在我们在 ClientWorker 类中定义的 map 存放的只是 ThreadPoolId——Listener 的键值对，ClientWorker 长轮询对象就算从服务端获得了线程池最新的配置信息，也没办法立刻比较，那这个问题该怎么解决呢？

## 引入 CacheData 对象

在上一小节我给大家提出了两个问题，**第一是用户无法为线程池创建多个监听器对象；第二就是 ClientWorker 长轮询对象就算从服务端获得了线程池最新的配置信息，也没办法立刻比较线程池的配置信息是否发生了变更**。要想解决这两个问题，我就需要为我们的框架引入一个新的类，那就是 CacheData 类，简而言之，**这个类的对象就是客户端动态线程池的缓存对象，每当客户端向服务端订阅了一个动态线程池的配置信息，客户端就会为这个线程池创建一个 CacheData 对象，与这个动态线程池对应的监听器对象就会存放在这个 CacheData 缓存对象的集合中，并且动态线程池的 MD5 信息也会缓存在 CacheData 对象中。而创建出来的这个 CacheData 缓存对象，就会替代 Listener 监听器对象，存放到 ClientWorker 长轮询对象的 map 中**。CacheData 类的代码我已经实现好了，请看下面代码块。

```
package cn.hippo4j.springboot.start.core;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：动态线程池在客户端的缓存数据对象
 */
@Slf4j
public class CacheData {

    //动态线程池的md5
    @Getter
    public volatile String md5;

    //动态线程池的核心配置信息
    //这个就是线程池各个配置信息拼接起来的长字符串
    public volatile String content;

    //租户Id
    public final String tenantId;

    //项目Id
    public final String itemId;

    //线程池Id
    public final String threadPoolId;

    //当前动态线程池对应的监听器集合，用户定义的动态线程池监听器都会存放到这个集合中
    //这里是集合就意味着，不仅仅是动态刷新配置信息的监听器会放到这里，用户定义的其他监听器也会放到这里
    private final CopyOnWriteArrayList<ManagerListenerWrapper> listeners;

    //构造方法
    public CacheData(String tenantId, String itemId, String threadPoolId) {
        this.tenantId = tenantId;
        this.itemId = itemId;
        this.threadPoolId = threadPoolId;
        this.content = ContentUtil.getPoolContent(GlobalThreadPoolManage.getPoolParameter(threadPoolId));
        //在这里设置了md5的值
        this.md5 = getMd5String(content);
        this.listeners = new CopyOnWriteArrayList();
    }

    //添加监听器的方法
    public void addListener(Listener listener) {
        if (null == listener) {
            throw new IllegalArgumentException("Listener is null.");
        }//包装一下监听器，就是把线程池的md5和监听器绑定到一起了
        //等服务端传递会最新的线程池的MD5后，就会使用最新的MD5和监听器持有的旧的md5做对比，看看配置是否发生了变更
        ManagerListenerWrapper managerListenerWrap = new ManagerListenerWrapper(md5, listener);
        //把监听器放到集合中
        if (listeners.addIfAbsent(managerListenerWrap)) {
            log.info("Add listener status: ok, thread pool id: {}, listeners count: {}", threadPoolId, listeners.size());
        }
    }

    //检查服务端线程池的md5是否和客户端线程池的md5是否不同
    public void checkListenerMd5() {
        for (ManagerListenerWrapper managerListenerWrapper : listeners) {
            //如果不同就意味着在服务端动态线程池的配置信息发生了变化，所以这里就要动态刷新客户端本地线程池的信息
            if (!md5.equals(managerListenerWrapper.getLastCallMd5())) {
                //调用线程池对应的监听器，执行监听器中的方法
                safeNotifyListener(content, md5, managerListenerWrapper);
            }
        }
    }

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：执行监听器的回调方法，动态刷新本地线程池信息
     */
    private void safeNotifyListener(String content, String md5, ManagerListenerWrapper managerListenerWrapper) {
        //得到监听器本身
        Listener listener = managerListenerWrapper.getListener();
        //封装一个新的任务，在任务执行监听器的回调方法，并且更新客户端缓存的线程池最新的md5的值
        Runnable runnable = () -> {
            managerListenerWrapper.setLastCallMd5(md5);
            //这里的content就是从服务端传递过来的最新的配置信息
            //receiveConfigInfo就是监听器中的回调方法，该方法一执行，就会使用最新的配置信息更新本地动态线程池的配置信息
            listener.receiveConfigInfo(content);
        };
        try {//在这里得到了监听器持有的执行器，用这个执行器来执行监听器任务
            listener.getExecutor().execute(runnable);
        } catch (Exception ex) {
            log.error("Failed to execute listener. message: {}", ex.getMessage());
        }
    }

    //更新当前CacheData对象缓存的线程池的最新配置信息以及md5
    public void setContent(String content) {
        this.content = content;
        //计算MD5，并且赋值给md5成员变量
        this.md5 = getMd5String(this.content);
    }

    //得到线程池md5的方法
    public static String getMd5String(String config) {
        return (null == config) ? Constants.NULL : Md5Util.md5Hex(config, Constants.ENCODE);
    }

}
```

当 CacheData 引入之后，我们也就可以重构 DynamicThreadPoolSubscribeConfig 类和 ClientWorker 类了。首先是 DynamicThreadPoolSubscribeConfig 类，请看下面代码块。

```
package cn.hippo4j.springboot.start.core;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：客户端动态线程池订阅服务端配置信息的类
 */
@RequiredArgsConstructor
public class DynamicThreadPoolSubscribeConfig {

    //持有了长轮询对象
    private final ClientWorker clientWorker;

    //动态线程池配置信息刷新器
    private final ThreadPoolDynamicRefresh threadPoolDynamicRefresh;

    //配置信息对象
    private final BootstrapProperties properties;

    //省略其他内容


    //订阅服务端线程池配置信息的方法，这个方法比上面方法多了一个功能，那就是用户可以自己定义监听器方法
    public void subscribeConfig(String threadPoolId, ThreadPoolSubscribeCallback threadPoolSubscribeCallback) {
        //创建监听器对象
        Listener configListener = new Listener() {

            //监听器要执行的回调方法
            @Override
            public void receiveConfigInfo(String config) {
                threadPoolSubscribeCallback.callback(config);
            }

            //执行监听器方法时用到的执行器
            @Override
            public Executor getExecutor() {
                return configRefreshExecutorService;
            }
        };

        //在这里把监听器添加到长轮询对象中了，实际上会在长轮询对象中为监听器创建一个对应的CacheData对象，监听器对象就交给CacheData对象持有
        //当监听器对象中的方法要被执行时，就会调用CacheData对象的safeNotifyListener方法，在safeNotifyListener方法中，先获得监听器的执行器
        //然后使用执行器执行监听器的receiveConfigInfo方法刷新本地线程池配置信息
        clientWorker.addTenantListeners(properties.getNamespace(), properties.getItemId(), threadPoolId, Arrays.asList(configListener));
    }
}
```

接着是 CacheData 类，请看下面代码块。

```
package cn.hippo4j.springboot.start.core;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：客户端长轮询对象，在这个对象中，开启了定时任务，定时任务会定期向服务端发送长轮询请求，监听服务端的动态线程池配置信息是否有更新
 * 如果更新了客户端就会及时感知到，然后使用服务端的配置信息更新本地线程池。这里我要多说一句，这个框架的长轮询功能其实就是复制了nacos旧版长轮询的代码
 * 代码几乎一模一样，当然，hippo4j的长轮询代码量要少一点。这一点在客户端和服务端的长轮询组件中都很明显。
 */
@Slf4j
public class ClientWorker {


    //这个map就是用来缓存所有CacheData对象的，每创建一个CacheData对象，就意味着客户端向服务端订阅了一个线程池的配置信息
    //CacheData对象中封装了对应的监听器，key就是线程池的Id
    private final ConcurrentHashMap<String, CacheData> cacheMap = new ConcurrentHashMap<>(16);



    
    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：为对应的线程池添加监听器的方法
     */
    public void addTenantListeners(String namespace, String itemId, String threadPoolId, List<? extends Listener> listeners) {
        //从cacheMap中得到线程池对应的CacheData对象，在addCacheDataIfAbsent方法中，如果CacheData不存在，就创建新的CacheData对象
        CacheData cacheData = addCacheDataIfAbsent(namespace, itemId, threadPoolId);
        //遍历用户要添加的监听器
        for (Listener listener : listeners) {
            //添加到CacheData对象的监听器集合中
            cacheData.addListener(listener);
        }
    }



     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：为要监听的线程池创建对应的CacheData对象的方法
     */
    public CacheData addCacheDataIfAbsent(String namespace, String itemId, String threadPoolId) {
        CacheData cacheData = cacheMap.get(threadPoolId);
        if (cacheData != null) {
            return cacheData;
        }
        //如果CacheData为null，创建一个CacheData对象
        cacheData = new CacheData(namespace, itemId, threadPoolId);
        //把新的CacheData放到cacheMap中
        CacheData lastCacheData = cacheMap.putIfAbsent(threadPoolId, cacheData);
        return lastCacheData;
    }
    
}
```

程序重构成这样，我相信之前的两个问题已经解决了，现在 ClientWorker 长轮询对象可以得到每一个订阅了配置信息的动态线程池的 CacheData 对象，而 CacheData 对象缓存了线程池当前的配置信息，以及 MD5 字符串，还存放了线程池对应的所有监听器对象，这样一来，**ClientWorker 长轮询对象接收到服务端发送过来的配置变更响应后，就可以直接判断是否要对某些线程池执行配置变更操作，以及执行这些线程池的监听器方法了**。当然，这个功能我还没有为大家首先，但离实现也不远了。

## 完善 ClientWorker 对象，实现客户端动态刷新线程池配置信息

这一小节，我们没有其他的任务了，主要是完善一下 ClientWorker 长轮询对象和服务端交互的功能，这个功能完善之后，客户端本身动态变更线程池的功能就实现完整了。至于服务端那边对应功能该如何实现，那就是下一章的任务了。好了，让我们言归正传，立刻着手实现 ClientWorker 长轮询对象和服务端交互的功能吧。这个功能说到底就是客户端向服务端发送长轮询请求而已，并且 ClientWorker 客户端在接收到上一个请求的响应后，立刻发送下一个请求，既然这样，**那我直接在 ClientWorker 中定义一个执行器，执行器执行发送长轮询请求给服务端的任务，并且在任务结束的时候，也就是收到了响应之后，提交下一个任务给执行器**。这样不就做到了执行器一直向服务端发送长轮询请求的操作吗？

当然，在发送长轮询请求的时候还应该注意一点，那就是确保 ClientWorker 对象的 cacheMap 成员变量中存在数据，如果这个 map 中根本没有数据，就说明客户端根本没有订阅任何线程池的配置信息，那 ClientWorker 长轮询客户端对象还向服务端发送什么长轮询请求啊，根本就不用发送。所以这里还需要稍微处理一下，只有当 cacheMap 中有数据的时候，ClientWorker 中的执行器才能向服务端一直发送长轮询请求。按照这个思路，我们可以先简单重构一下 ClientWorker 类，请看下面代码块。

```
package cn.hippo4j.springboot.start.core;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：客户端长轮询对象，在这个对象中，开启了定时任务，定时任务会定期向服务端发送长轮询请求，监听服务端的动态线程池配置信息是否有更新
 * 如果更新了客户端就会及时感知到，然后使用服务端的配置信息更新本地线程池。这里我要多说一句，这个框架的长轮询功能其实就是复制了nacos旧版长轮询的代码
 * 代码几乎一模一样，当然，hippo4j的长轮询代码量要少一点。这一点在客户端和服务端的长轮询组件中都很明显。
 */
@Slf4j
public class ClientWorker {


     //长轮询请求超时时间
    private long timeout;
    //通信组件
    private final HttpAgent agent;
    //客户端唯一标识
    private final String identify;
    //健康检查器
    private final ServerHealthCheck serverHealthCheck;
    
    
    //启动长轮询定时任务的执行器
    private final ScheduledExecutorService executorService;


    //当cacheMap中存在CacheData后，cacheCondition就会调用它的countDown方法，让程序继续执行下去
    //这个时候就意味着在客户端订阅了某些线程池的动态信息，客户端终于可以发送长轮询请求给服务端监听线程池信息是否发生变更了
    //在addTenantListeners方法中，会调用cacheCondition.countDown()方法，让长轮询任务执行下去
    private final CountDownLatch cacheCondition = new CountDownLatch(1);


    //这个map就是用来缓存所有CacheData对象的，每创建一个CacheData对象，就意味着客户端向服务端订阅了一个线程池的配置信息
    //CacheData对象中封装了对应的监听器，key就是线程池的Id
    private final ConcurrentHashMap<String, CacheData> cacheMap = new ConcurrentHashMap<>(16);




    //构造方法
    @SuppressWarnings("all")
    public ClientWorker(HttpAgent httpAgent, String identify, ServerHealthCheck serverHealthCheck) {
        this.agent = httpAgent;
        this.identify = identify;
        this.timeout = CONFIG_LONG_POLL_TIMEOUT;
        this.serverHealthCheck = serverHealthCheck;
        //创建executorService执行器
        this.executorService = Executors.newSingleThreadScheduledExecutor(
                ThreadFactoryBuilder.builder().prefix("client.long.polling.executor").daemon(true).build());
        log.info("Client identify: {}", identify);
        //向执行其中提交任务，这时候执行器就开始执行长轮询任务了，就开始向服务端发送长轮询请求
        //文章中展示的这一部分代码其实存在bug，请大家想一想，ClientWorker是被SpringBoot管理的对象
        //在对象创建的过程中，程序也在启动，但是这里大家会发现，在ClientWorker对象创建的过程中，就直接向服务端发送长轮询请求了
        //如果其他要用到的组件对象还没创建呢？所以这个任务应该在SpringBoot上下文刷新完毕之后才提交给执行器，在我提供的第三版本代码中就是这么做的
        //但为了简化文章代码，我把对应的代码删去了，大家可以去第三版本代码中看看具体是怎么等待SpringBoot上下文刷新完毕的
        executorService.execute(new LongPollingRunnable(cacheMap.isEmpty(), cacheCondition));
    }






    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：这个内部类的对象就是长轮询任务对象
     */
    class LongPollingRunnable implements Runnable {
        //cacheMap中是否为空
        private boolean cacheMapInitEmptyFlag;
        //程序能执行下去的条件对象
        private final CountDownLatch cacheCondition;

        //构造方法
        public LongPollingRunnable(boolean cacheMapInitEmptyFlag, CountDownLatch cacheCondition) {
            this.cacheMapInitEmptyFlag = cacheMapInitEmptyFlag;
            this.cacheCondition = cacheCondition;
        }

        @Override
        @SneakyThrows
        public void run() {
            //这里判断cacheMap中是否为空，如果为空就意味着当前客户端还没有向服务端订阅任何一个线程池的信息
            if (cacheMapInitEmptyFlag) {
                //这就意味着没必要执行长轮询任务，因为就算你请求发过去了，也不知道要监听哪个线程池信息的变化
                //在addTenantListeners添加监听器方法中，会执行cacheCondition的countDown方法
                //这时候就意味着客户端监听了某些动态线程池的信息了
                cacheCondition.await();
                //更新标志为false，程序继续向下执行
                cacheMapInitEmptyFlag = false;
            }
            //首先检查服务器的健康状态
            serverHealthCheck.isHealthStatus();


            
            //中间过程暂时不实现


            
            //提交下一个长轮询任务给定时任务执行器
            executorService.execute(this);
        }

        
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：为对应的线程池添加监听器的方法
     */
    public void addTenantListeners(String namespace, String itemId, String threadPoolId, List<? extends Listener> listeners) {
        //从cacheMap中得到线程池对应的CacheData对象，在addCacheDataIfAbsent方法中，如果CacheData不存在，就创建新的CacheData对象
        CacheData cacheData = addCacheDataIfAbsent(namespace, itemId, threadPoolId);
        //遍历用户要添加的监听器
        for (Listener listener : listeners) {
            //添加到CacheData对象的监听器集合中
            cacheData.addListener(listener);
        }
        //在这里执行了cacheCondition.countDown()方法，因为cacheMap中有数据了，程序就可以继续执行下去了
        if (awaitApplicationComplete.getCount() == 0L) {
            cacheCondition.countDown();
        }
    }



     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：为要监听的线程池创建对应的CacheData对象的方法
     */
    public CacheData addCacheDataIfAbsent(String namespace, String itemId, String threadPoolId) {
        CacheData cacheData = cacheMap.get(threadPoolId);
        if (cacheData != null) {
            return cacheData;
        }
        //如果CacheData为null，创建一个CacheData对象
        cacheData = new CacheData(namespace, itemId, threadPoolId);
        //把新的CacheData放到cacheMap中
        CacheData lastCacheData = cacheMap.putIfAbsent(threadPoolId, cacheData);
        return lastCacheData;
    }
    
}
```

上面代码块中的逻辑应该很清楚了，只要程序启动完毕了，并且客户端确实订阅了某些线程池的配置信息，ClientWorker 就可以真正执行 LongPollingRunnable 长轮询任务，在这个任务中，**ClientWorker 对象会向服务端发送长轮询请求，并且在任务执行结束的时候，向执行器提交下一个任务，这样一来，ClientWorker 长轮询客户端就会一直向服务端发送长轮询请求，监听服务端哪个线程池的配置信息发生了变化**。不过，具体和服务端交互的过程我还没有实现，因为这就是接下来我要跟大家讨论的地方。

请大家想一想，假如客户端订阅了 3 个动态线程池的配置变更信息，这也就意味着在 ClientWorker 对象的 map 成员变量中存放了三个 CacheData 对象，这也就意味着客户端要监听这三个动态线程池的配置变更情况。这样一来，当客户端向服务端发送长轮询请求的时候，应该怎么发送呢？**是为每一个动态线程池都发送一个长轮询请求呢？还是说只发送一个长轮询请求，使用一个请求一次从服务端查询三个线程池的配置变更情况**？我目前的实现思路是这样的：**首先肯定是只发送一个请求，在一个请求中把三个要查询的动态线程池的信息都传输给服务端，至于怎么传输，这个很好办，每一个动态线程池不是都有命名空间、itemId、threadPoolId、 identify 客户端唯一标识、以及最重要的 md5 这些信息吗？我把每一个线程池的这些信息都拼接起来，得到一个长字符串，这样一来我就会得到三个动态线程池的长字符串对象；然后我再把这三个动态线程池的长字符串拼接成一个更长的字符串对象，客户端把这个对象传输给服务端，这样一来，服务端解析了字符串信息后，得到了客户端传输过来的每一个线程池的 md5 信息，不就可以使用客户端线程池的 md5 信息和服务端线程池最新的 md5 做比对，判断哪个线程池的配置信息更新了。如果发现有一个线程池的配置信息更新了，服务端只需要把配置信息更新的线程池的命名空间、itemId、threadPoolId 这些信息拼接成字符串，返回给客户端即可。这样一来，服务端就算是给客户端回复了长轮询请求的响应。当客户端发现长轮询请求的响应不为空，就可以根据服务端回复的动态线程池的信息再次访问服务端，直接去服务端查询该动态线程池的最新配置信息，这样一来客户端就获得了对应线程池最新的配置信息，然后就可以拿着最新信息中的 md5 和 CacheData 对象中缓存的 md5 做对比，如果确实不一样，就可以执行线程池对应监听器中的回调方法，动态更新本地线程池的配置信息**。加上前面我为大家已经实现的功能，到此为止，我们就得到了完整的客户端动态刷新本地线程池配置信息的全流程，这个逻辑大家可以仔细梳理梳理，接下来就让我为大家展示一下对应的代码，也就是重构之后的 ClientWorker 类。请看下面代码块。

```
package cn.hippo4j.springboot.start.core;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/5/7
 * @方法描述：客户端长轮询对象，在这个对象中，开启了定时任务，定时任务会定期向服务端发送长轮询请求，监听服务端的动态线程池配置信息是否有更新
 * 如果更新了客户端就会及时感知到，然后使用服务端的配置信息更新本地线程池。这里我要多说一句，这个框架的长轮询功能其实就是复制了nacos旧版长轮询的代码
 * 代码几乎一模一样，当然，hippo4j的长轮询代码量要少一点。这一点在客户端和服务端的长轮询组件中都很明显。
 */
@Slf4j
public class ClientWorker {


    //长轮询请求超时时间
    private long timeout;
    //通信组件
    private final HttpAgent agent;
    //客户端唯一标识
    private final String identify;
    //健康检查器
    private final ServerHealthCheck serverHealthCheck;
    
    
    //启动长轮询定时任务的执行器
    private final ScheduledExecutorService executorService;


    //当cacheMap中存在CacheData后，cacheCondition就会调用它的countDown方法，让程序继续执行下去
    //这个时候就意味着在客户端订阅了某些线程池的动态信息，客户端终于可以发送长轮询请求给服务端监听线程池信息是否发生变更了
    //在addTenantListeners方法中，会调用cacheCondition.countDown()方法，让长轮询任务执行下去
    private final CountDownLatch cacheCondition = new CountDownLatch(1);


    //这个map就是用来缓存所有CacheData对象的，每创建一个CacheData对象，就意味着客户端向服务端订阅了一个线程池的配置信息
    //CacheData对象中封装了对应的监听器，key就是线程池的Id
    private final ConcurrentHashMap<String, CacheData> cacheMap = new ConcurrentHashMap<>(16);


    //构造方法省略






    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：这个内部类的对象就是长轮询任务对象
     */
    class LongPollingRunnable implements Runnable {
        //cacheMap中是否为空
        private boolean cacheMapInitEmptyFlag;
        //程序能执行下去的条件对象
        private final CountDownLatch cacheCondition;

        //构造方法
        public LongPollingRunnable(boolean cacheMapInitEmptyFlag, CountDownLatch cacheCondition) {
            this.cacheMapInitEmptyFlag = cacheMapInitEmptyFlag;
            this.cacheCondition = cacheCondition;
        }

        @Override
        @SneakyThrows
        public void run() {
            //这里判断cacheMap中是否为空，如果为空就意味着当前客户端还没有向服务端订阅任何一个线程池的信息
            if (cacheMapInitEmptyFlag) {
                //这就意味着没必要执行长轮询任务，因为就算你请求发过去了，也不知道要监听哪个线程池信息的变化
                //在addTenantListeners添加监听器方法中，会执行cacheCondition的countDown方法
                //这时候就意味着客户端监听了某些动态线程池的信息了
                cacheCondition.await();
                //更新标志为false，程序继续向下执行
                cacheMapInitEmptyFlag = false;
            }
            //首先检查服务器的健康状态
            serverHealthCheck.isHealthStatus();




            
            //定义一个集合，这个集合会存放cacheMap中的所有value，也就是所有CacheData对象
            List<CacheData> cacheDataList = new ArrayList();
            
            //把cacheMap中的所有value都存放到cacheDataList中
            cacheMap.forEach((key, val) -> cacheDataList.add(val));

            //这里就是检查服务端对应的线程池的信息是否更新了的操作，如果有线程池在服务端更新了，这里就会把线程池的相关信息返回给客户端
            //其实就是得到了每一个更新了的线程池的线程池Id、项目Id、租户信息
            List<String> changedTpIds = checkUpdateDataIds(cacheDataList);


            //遍历所有更新的线程池信息
            for (String groupKey : changedTpIds) {
                //得到线程池具体的信息
                String[] keys = groupKey.split(GROUP_KEY_DELIMITER_TRANSLATION);
                //线程池Id
                String tpId = keys[0];
                //项目Id
                String itemId = keys[1];
                //命名空间，其实就是租户信息
                String namespace = keys[2];
                try {
                    //根据刚才得到的线程池的相关信息，访问服务端，从服务端获取线程池最新的配置信息
                    String content = getServerConfig(namespace, itemId, tpId, 3000L);
                    //从客户端得到缓存了线程池信息的CacheData对象
                    CacheData cacheData = cacheMap.get(tpId);
                    //然后把从服务端得到的最新信息更新到对应的本地CacheData对象中即可
                    String poolContent = ContentUtil.getPoolContent(JSONUtil.parseObject(content, ThreadPoolParameterInfo.class));
                    //这个操作同时也会更新CacheData对象的md5成员变量
                    cacheData.setContent(poolContent);
                } catch (Exception ignored) {
                    log.error("Failed to get the latest thread pool configuration.", ignored);
                }
            }



            //这里就是刷新客户端本地的线程池信息的操作
            for (CacheData cacheData : cacheDataList) {
                //在这里刷新客户端本地的线程池信息
                //cacheData的checkListenerMd5方法会对比服务端和客户端线程池的md5信息，不一样则执行线程池监听器中的方法
                //刷新本地线程池的配置信息
                cacheData.checkListenerMd5();  
            }

            
            //提交下一个长轮询任务给定时任务执行器
            executorService.execute(this);
        }

        
    }




    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/5/7
     * @方法描述：检查线程池信息是否在服务端更新了的入口方法
     */
    private List<String> checkUpdateDataIds(List<CacheData> cacheDataList) {
        StringBuilder sb = new StringBuilder();
        //拼接所有线程池的相关信息，注意，这里是把本地所有监听了服务端配置信息的线程池的相关信息都拼接到一起了
        for (CacheData cacheData : cacheDataList) {
            //拼接线程池ID
            sb.append(cacheData.threadPoolId).append(WORD_SEPARATOR);
            //拼接项目Id
            sb.append(cacheData.itemId).append(WORD_SEPARATOR);
            //拼接租户Id
            sb.append(cacheData.tenantId).append(WORD_SEPARATOR);
            //拼接客户端唯一标识
            sb.append(identify).append(WORD_SEPARATOR);
            //拼接当前线程对应的md5
            sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);
            //这里再判断一下当前正在遍历的cacheData对象是否为初始化状态
            if (cacheData.isInitializing()) {
                //如果是则添加到初始化集合中
                inInitializingCacheList.add(GroupKey.getKeyTenant(cacheData.threadPoolId, cacheData.itemId, cacheData.tenantId));
            }
        }
      
        //在下面这个方法中就会发送长轮询请求给服务端
        //checkUpdateTpIds方法我就不在文章中展示了，就是设置长轮询请求头，然后向服务端发送请求的操作
        return checkUpdateTpIds(sb.toString());
    }




    //向服务器发送请求，获得线程池最新配置信息的方法，这个方法的操作在第一版本代码中已经见过了，所以就不添加注释了
    public String getServerConfig(String namespace, String itemId, String threadPoolId, long readTimeout) {
        Map<String, String> params = new HashMap<>(3);
        params.put("namespace", namespace);
        params.put("itemId", itemId);
        params.put("tpId", threadPoolId);
        params.put("instanceId", identify);
        Result result = agent.httpGetByConfig(CONFIG_CONTROLLER_PATH, null, params, readTimeout);
        if (result.isSuccess()) {
            return JSONUtil.toJSONString(result.getData());
        }
        log.error("Sub server namespace: {}, itemId: {}, threadPoolId: {}, result code: {}", namespace, itemId, threadPoolId, result.getCode());
        return NULL;
    }


   //其余方法省略
    
}
```

到此为止，这个 ClientWorker 类就重构完整了，代码中注释很详细，程序指令流程我就不再重复梳理了，之前已经为大家梳理过一次了。当然，我还得解释一下，在我为大家提供的第三版本代码中，客户端长轮询对象，也就是 ClientWorker 类的代码和文章稍微有些不一样，文章中展示的代码在第三版本代码中全都存在，但是第三版本代码的 ClientWorker 类比文章中的 ClientWorker 类稍微多了一些内容，这部分内容也是 nacos 长轮询对象中的内容，我就不在文章中展示了，大家看看我提供的代码即可。**在这一章我只是为大家把客户端线程池动态刷新的功能实现了，但服务端究竟怎么处理客户端发送的长轮询请求，发布订阅模式又该如何运用，这些我都没有讲解，这都是下一章的内容，如果大家等不及可以先看看第四版本代码的 ConfigController 类，这个类中的 listener 方法就是服务端处理客户端长轮询请求的入口方法，知道了入口方法，那么之后的逻辑就全可以查看了**。因为第三版本代码和第四版本代码是一个整体，实现的是线程池配置动态刷新整个功能，但第三版本代码只实现了客户端动态刷新线程池配置信息的功能，所以第三版本代码没有测试类，大家要想看测试例子的话，只能去第四版本代码中查看，或者等我把第四版本代码讲了，大家再启动测试类，仔细梳理程序的执行流程。好了，这一章的内容已经很多了，就到此为止吧，下一章我们将实现服务端处理客户端长轮询请求的功能。朋友们，我们下一章见！