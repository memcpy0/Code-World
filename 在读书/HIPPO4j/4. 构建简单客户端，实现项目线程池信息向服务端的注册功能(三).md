书接上回，跟大家提出这样一个问题：**假如用户在使用我们开发的动态线程池框架时，创建了第三方的线程池，但是在该线程池对象上加上了 `@DynamicThreadPool` 注解，这又该怎么办呢**？我相信很多朋友不明白我这个问题是什么意思，接下来给大家举一个简单的例子。当我们使用 SpringBoot 开发动态线程池框架之后，用户再想创建一个动态线程池对象，并且这个对象要交给 SpringBoot 的容器来管理，这个时候就可以使用下面这种方式创建动态线程池对象。请看下面代码块。
```java
package cn.hippo4j.example.core.config;

@Slf4j
@Configuration
public class DynamicThreadPoolConfig {
    @Bean
    @DynamicThreadPool
    public Executor testConsumeTtlDynamicThreadPool() {
        String threadPoolId = "test-consume";
        ThreadPoolExecutor customExecutor = ThreadPoolBuilder.builder()
                .dynamicPool()
                .threadFactory(threadPoolId)
                .threadPoolId(threadPoolId)
                .executeTimeOut(800L)
                .waitForTasksToCompleteOnShutdown(true)
                .awaitTerminationMillis(5000L)
                .taskDecorator(new TaskTraceBuilderHandler())
                .build();
        return customExecutor;
    }
}
```
可以看到，在上面的代码块中，**我定义了一个 SpringBoot 的配置类，在配置类中定义了一个 `DynamicThreadPoolExecutor` 对象交给了 SpringBoot 容器来管理，并且还在该对象上面添加了 `@DynamicThreadPool` 注解**。这样一来，我肯定就可以**在引入的 `DynamicThreadPoolPostProcessor` 对象处理器的 `postProcessAfterInitialization` 方法中得到该对象，然后判断该对象是否为动态线程池对象，如果是的话，就可以把这个动态线程池的信息注册到服务端**。`postProcessAfterInitialization` 类的代码如下。
```java
package cn.hippo4j.springboot.start.support;

@Slf4j
@AllArgsConstructor
public final class DynamicThreadPoolPostProcessor implements BeanPostProcessor {

    // 配置信息对象
    private final BootstrapProperties properties;

    // 客户端代理对象
    private final HttpAgent httpAgent;

    // bean前置处理方法
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean;
    }

   // bean后置处理方法
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
       // 在这里判断bean是否为动态线程池对象，如果是的话就可以把动态线程池信息注册到服务端
    }
} 
```
好了，现在正常创建动态线程池的例子已经展示完了，现在回到最初的那个问题：**假如用户在使用我们开发的动态线程池框架时，创建了第三方的线程池，但是在该线程池对象上加上了 `@DynamicThreadPool` 注解，这又该怎么办呢**？什么是第三方线程池？很简单，反正我们在程序中已经引入了 SpringBoot，假如用户就想使用 SpringBoot 中的线程池呢？比如 `ThreadPoolTaskExecutor` ，或者说用户创建的确实是 `DynamicThreadPoolExecutor` 动态线程池对象，但为了在使用线程池时，能够让线程私有变量在不同的线程间传递，用户又把 `DynamicThreadPoolExecutor` 动态线程池包装到了 Alibaba 开源的 `Transmittable-Thread-Local` 框架的线程池对象中，并且最后返回给用户的是 `Transmittable-Thread-Local` 的线程池对象，这个时候，又该怎么办呢？具体示例请看下面代码块。
```java
package cn.hippo4j.example.core.config;

@Slf4j
@Configuration
public class DynamicThreadPoolConfig {
    @Bean
    @DynamicThreadPool
    public Executor messageConsumeTtlDynamicThreadPool() {
        String threadPoolId = "message-consume";
        ThreadPoolExecutor customExecutor = ThreadPoolBuilder.builder()
                .dynamicPool()
                .threadFactory(threadPoolId)
                .threadPoolId(threadPoolId)
                .executeTimeOut(800L)
                .waitForTasksToCompleteOnShutdown(true)
                .awaitTerminationMillis(5000L)
                .taskDecorator(new TaskTraceBuilderHandler())
                .build();
        // 在这里使用Transmittable-Thread-Local包装了动态线程池
        // 返回给用户Transmittable-Thread-Local框架中的线程池对象
        Executor ttlExecutor = TtlExecutors.getTtlExecutor(customExecutor);
        return ttlExecutor;
    }    
}
```
**如果是上面的情况，用户确实创建了一个动态线程池对象，但又把这个对象交给了第三方线程池，最后用户仍然想把这个动态线程池对象注册到服务端，因为不管这个动态线程池被怎么包装，最后执行任务肯定是这个动态线程池来执行啊**。那这种情况又该怎么办呢？怎么将动态线程池的信息注册到服务端呢？

当然，肯定还是要在 `DynamicThreadPoolPostProcessor` 处理器的 `postProcessAfterInitialization` 后置方法内获得对象，然后处理这个被包装过的动态线程池对象，因为上面代码块创建的对象也交给 SpringBoot 容器来管理了。

但请大家注意，当 `DynamicThreadPoolExecutor` 动态线程池被第三方框架包装了之后，在 `DynamicThreadPoolPostProcessor` 处理器的 `postProcessAfterInitialization` 后置方法内获得的对象肯定就不再是 `DynamicThreadPoolExecutor` 类型的了，这个想必大家都能理解。

但是，我们的目的是把被第三方线程池包装的动态线程池对象注册到服务器，这个时候，就必须采取一些措施了：**那就是从第三方线程池中获得真正的动态线程池对象，然后把动态线程池注册到服务器即可**。这个方法肯定是可行的，因为第三方线程池肯定也是在内部定义了一个线程池成员变量，这样才能包装动态线程池啊。就像下面代码块中展示的这样。
```java
package com.alibaba.ttl.threadpool;

// 这是Transmittable-Thread-Local框架中的线程池
class ExecutorTtlWrapper implements Executor, TtlWrapper<Executor>, TtlEnhanced {
    // 在这里定义了一个线程池对象，动态线程池就会赋值给这个成员变量
    private final Executor executor;
    protected final boolean idempotent;

    ExecutorTtlWrapper(@NonNull Executor executor, boolean idempotent) {
        this.executor = executor;
        this.idempotent = idempotent;
    }

    public void execute(@NonNull Runnable command) {
        this.executor.execute(TtlRunnable.get(command, false, this.idempotent));
    }

    @NonNull
    public Executor unwrap() {
        return this.executor;
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        } else if (o != null && this.getClass() == o.getClass()) {
            ExecutorTtlWrapper that = (ExecutorTtlWrapper)o;
            return this.executor.equals(that.executor);
        } else {
            return false;
        }
    }

    public int hashCode() {
        return this.executor.hashCode();
    }

    public String toString() {
        return this.getClass().getName() + " - " + this.executor.toString();
    }
}
```
所以，我们目前的问题，就变成了**如何在 `DynamicThreadPoolPostProcessor` 处理器的 `postProcessAfterInitialization` 后置方法内，判断当前处理的对象是被第三方线程池包装的动态线程池对象**，如果这一点可以判断清楚了，那就能直接从第三方线程池中获得真正的动态线程池，接着把动态线程池信息注册到服务端即可。为了解决这个问题，接下来给我们的动态线程池框架再次引入一个新的组件，**那就是第三方线程池适配器**。
## 引入线程池适配器，完善 **postProcessAfterInitialization**

要定义这个适配器其实也很简单，**只要这个适配器能够判断一个线程池对象中包装着真正的动态线程池对象即可**，而且我们实现也知道了，`Transmittable-Thread-Local` 框架的 `ExecutorTtlWrapper` 对象可能包装真正的动态线程池对象。所以我就先定义一个 `TransmittableThreadLocalExecutorAdapter` 适配器类，这个适配器的对象就是专门用来**解析被 `Transmittable-Thread-Local` 框架的 `ExecutorTtlWrapper` 对象包装的动态线程池对象**。具体实现请看下面代码块。
```java
package cn.hippo4j.core.executor.support.adpter;

/**
 * @方法描述：ExecutorTtlWrapper对象的适配器，可以从ExecutorTtlWrapper对象中获得其持有的DynamicThreadPoolExecutor对象
 */
public class TransmittableThreadLocalExecutorAdapter implements DynamicThreadPoolAdapter {
    private static String MATCH_CLASS_NAME = "ExecutorTtlWrapper";

    private static String FIELD_NAME = "executor";

    // 判断传进来的对象是否和当前适配器器对象匹配
    @Override
    public boolean match(Object executor) {
        // 其实就是判断对象的类名是否为ExecutorTtlWrapper，如果是就意味着是第三方线程池
        // 这个线程池中持有者动态线程池对象
        return Objects.equals(MATCH_CLASS_NAME, executor.getClass().getSimpleName());
    }

    // 从ExecutorTtlWrapper对象中获得其持有的DynamicThreadPoolExecutor对象
    @Override
    public DynamicThreadPoolExecutor unwrap(Object executor) {
        // 通过反射获得ExecutorTtlWrapper对象的executor成员变量
        // 在之前展示的ExecutorTtlWrapper类的代码中，可以看到，动态线程池会赋值给
        // ExecutorTtlWrapper的executor成员变量
        Object unwrap = ReflectUtil.getFieldValue(executor, FIELD_NAME);
        if (unwrap != null && unwrap instanceof DynamicThreadPoolExecutor) {
            return (DynamicThreadPoolExecutor) unwrap;
        }
        return null;
    }


    // 将dynamicThreadPoolExecutor对象替换到executor中
    @Override
    public void replace(Object executor, Executor dynamicThreadPoolExecutor) {
        ReflectUtil.setFieldValue(executor, FIELD_NAME, dynamicThreadPoolExecutor);
    }
}
```
好了，现在 `ExecutorTtlWrapper` 的适配器已经实现了。**在这个适配器中，我定义了一个 `match` 方法，该方法的作用就是判断一个对象的简单类名是否为 `ExecutorTtlWrapper` ，如果是 `ExecutorTtlWrapper` ，就意味着当前对象是一个第三方线程池对象，那么它就包装着一个真正的动态线程池对象，然后调用适配器的 `unwrap` 方法，就可以获得真正执行任务的动态线程池对象**。

这里我要再多说一句，在 Hippo4j 框架中，不仅仅定义了一个 `TransmittableThreadLocalExecutorAdapter` 适配器，除此之外，还定义了两个适配器，分别是 `ThreadPoolTaskExecutorAdapter` 和 `TransmittableThreadLocalExecutorServiceAdapter` 适配器，这两个适配器分别是用来解析 SpringBoot 的 `ThreadPoolExecutor` 和 Transmittable-Thread-Local 框架的 `ExecutorServiceTtlWrapper` 线程池对象的。这两个适配器的逻辑和 TransmittableThreadLocalExecutorAdapter 的逻辑几乎一样，所以大家直接去看提供的第一版本源码即可。

当然，既然整个框架中定义了 3 个适配器，那么在处理对象时就要提供一个选择器，选择正确的适配器来解析 SpringBoot 容器中的对象。所以，我还要在框架中再定义一个 `DynamicThreadPoolAdapterChoose` **适配器选择器**，具体实现请看下面代码块。
```java
package cn.hippo4j.core.executor.support.adpter;

/**
 * @方法描述：动态线程池适配器选择类
 */
public class DynamicThreadPoolAdapterChoose {
    // 存储了所有执行器适配器对象的集合
    private static List<DynamicThreadPoolAdapter> DYNAMIC_THREAD_POOL_ADAPTERS = new ArrayList<>();

    // 添加三个动态线程池适配器对象
    static {
        DYNAMIC_THREAD_POOL_ADAPTERS.add(new TransmittableThreadLocalExecutorAdapter());
        DYNAMIC_THREAD_POOL_ADAPTERS.add(new TransmittableThreadLocalExecutorServiceAdapter());
        DYNAMIC_THREAD_POOL_ADAPTERS.add(new ThreadPoolTaskExecutorAdapter());
    }


    // 匹配执行器的适配器对象
    public static boolean match(Object executor) {
        return DYNAMIC_THREAD_POOL_ADAPTERS.stream().anyMatch(each -> each.match(executor));
    }

    // 使用执行器的适配器对象得到执行器中的动态线程池
    public static DynamicThreadPoolExecutor unwrap(Object executor) {
        Optional<DynamicThreadPoolAdapter> dynamicThreadPoolAdapterOptional = DYNAMIC_THREAD_POOL_ADAPTERS.stream().filter(each -> each.match(executor)).findFirst();
        return dynamicThreadPoolAdapterOptional.map(each -> each.unwrap(executor)).orElse(null);
    }

    // 使用dynamicThreadPoolExecutor替代executor中的线程池成员变量
    public static void replace(Object executor, Executor dynamicThreadPoolExecutor) {
        Optional<DynamicThreadPoolAdapter> dynamicThreadPoolAdapterOptional = DYNAMIC_THREAD_POOL_ADAPTERS.stream().filter(each -> each.match(executor)).findFirst();
        if (dynamicThreadPoolAdapterOptional.isPresent()) {
            dynamicThreadPoolAdapterOptional.get().replace(executor, dynamicThreadPoolExecutor);
        }
    }
}
```
上面代码块中的方法非常简单，我就不再赘述了。好了，到此为止，适配器组件也就为大家实现完毕了。接下来，就该真正实现 `DynamicThreadPoolPostProcessor` 处理器了。之前展示的 `DynamicThreadPoolPostProcessor` 处理器中的 `postProcessAfterInitialization` 后置处理方法一直是空方法，但现在程序的适配器组件也开发完毕了，我们也就可以在 `postProcessAfterInitialization` 后置方法中处理各种线程池对象了。

现在实现 `postProcessAfterInitialization` 后置处理方法的思路也很明确了：**反正只要是被这个方法处理的 `bean` 对象都是 SpringBoot 管理的对象，用户创建的所有动态线程池对象也会被交给 SpringBoot 容器管理，并且添加 `@DynamicThreadPool` 注解，所以我只要在这个 `postProcessAfterInitialization` 方法中先判断当前处理的 `bean` 对象是否为 `DynamicThreadPoolExecutor` 类型的，如果是这个类型的，那肯定就是动态线程池对象本身，接在再判断对象上是否存在 `@DynamicThreadPool` 注解，如果这个条件也满足，就可以直接把动态线程池的信息注册到服务器；如果对象并不是 `DynamicThreadPoolExecutor` 类型的，那就使用 `DynamicThreadPoolAdapterChoose` 第三方线程池适配选择器对象去选择对应的适配器，如果能选则到对应的适配器，说明用户创建了动态线程池，只不过动态线程池被第三方框架包装了，接在再判断对象上是否存在 `@DynamicThreadPool` 注解，如果这个条件同样满足，就可以使用适配器获得真正的动态线程池，然后把动态线程池的信息注册到服务器**。具体实现请看下面代码块。
```java
package cn.hippo4j.springboot.start.support;

@Slf4j
@AllArgsConstructor
public final class DynamicThreadPoolPostProcessor implements BeanPostProcessor {
    // 配置信息对象
    private final BootstrapProperties properties;

    // 客户端代理对象
    private final HttpAgent httpAgent;

    // bean前置处理方法
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean;
    }

   /**
     * @方法描述：这个方法就是本类最核心的方法，用来处理DynamicThreadPoolExecutor对象
     */
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        // 这里会先判断一下传进来的bean是否属于DynamicThreadPoolExecutor类型，如果大家看了我在DynamicThreadPoolConfig类提供的几个例子
        // 就会发现我创建动态线程池对象最终是以Executor或者ThreadPoolExecutor形式返回的，如果是以Executor形式返回的，这个Executor接收的还并不是一个DynamicThreadPoolExecutor对象
        // 而是一个ExecutorTtlWrapper对象，这个ExecutorTtlWrapper对象的作用我已经在DynamicThreadPoolConfig类中解释了，这时候，ExecutorTtlWrapper对象肯定就不属于DynamicThreadPoolExecutor类型了
        // 但是先别急，虽然ExecutorTtlWrapper对象不属于DynamicThreadPoolExecutor类型，但是后面的DynamicThreadPoolAdapterChoose.match(bean)这个条件还是可以通过的，所以仍然可以进入下面的分支
        // 那为什么要执行DynamicThreadPoolAdapterChoose.match(bean)这行代码呢？原因也很简单，因为有时候用户可能会使用spring本身的线程池，或者其他第三方形式的线程池，比如ExecutorTtl，比如spring的ThreadPoolTaskExecutor
        // 该动态线程池框架也想收集这些线程池的信息，所以就会在DynamicThreadPoolAdapterChoose.match(bean)中判断程序内是否有这些第三方线程池的适配器，如果有，就可以使用这些适配器把这些第三方线程池转换成DynamicThreadPoolExecutor对象
        // 之后的逻辑就和处理真正的DynamicThreadPoolExecutor对象一样了，无非就是把线程池信息注册到服务端，然后把线程池保存在线程池全局管理器中
        // DynamicThreadPoolAdapterChoose.match(bean)就是判断bean的类型是否为ThreadPoolTaskExecutor、ExecutorTtlWrapper、ExecutorServiceTtlWrapper中的一个，这些都是第三方的线程池
        if (bean instanceof DynamicThreadPoolExecutor || DynamicThreadPoolAdapterChoose.match(bean)) {
            DynamicThreadPool dynamicThreadPool;
            try {//判断该线程池对象上是否存在DynamicThreadPool注解
                dynamicThreadPool = ApplicationContextHolder.findAnnotationOnBean(beanName, DynamicThreadPool.class);
                //如果找不到该注解，就进入下面这个分支
                if (Objects.isNull(dynamicThreadPool)) {
                    //这里就是为了适配SpringBoot低版本，使用DynamicThreadPoolAnnotationUtil工具再次查找注解
                    dynamicThreadPool = DynamicThreadPoolAnnotationUtil.findAnnotationOnBean(beanName, DynamicThreadPool.class);
                    if (Objects.isNull(dynamicThreadPool)) {
                        //还是找不到则直接返回bean即可
                        return bean;
                    }
                }
            } catch (Exception ex) {
                log.error("Failed to create dynamic thread pool in annotation mode.", ex);
                return bean;
            }
            
            //走到这里意味着当前的bean上有DynamicThreadPool注解，也就意味着是一个动态线程池，下面就要收集动态线程池配置信息了
            //定义一个动态线程池
            DynamicThreadPoolExecutor dynamicThreadPoolExecutor;


            //下面的if分支会先从适配器中获得真正的动态线程池，如果获得的线程池为空，说明当前bean本身就是动态线程池，如果不为空，则正好得到了真正的动态线程池，并且赋值给dynamicThreadPoolExecutor了
            //将bean转换为dynamicThreadPoolExecutor类型，确切地说不是把当前要交给容器的这个bean转换成dynamicThreadPoolExecutor对象
            //实际上ExecutorTtlWrapper只是持有了dynamicThreadPoolExecutor的引用，这里只不过是直接利用反射从ExecutorTtlWrapper把dynamicThreadPoolExecutor对象取出来了
            if ((dynamicThreadPoolExecutor = DynamicThreadPoolAdapterChoose.unwrap(bean)) == null) {
                dynamicThreadPoolExecutor = (DynamicThreadPoolExecutor) bean;
            }
            
            
            //将刚刚得到的dynamicThreadPoolExecutor对象包装成一个DynamicThreadPoolWrapper对象，这个对象会被交给线程池全局管理器来管理
            //之后收集线程池运行信息时都要用到这个对象
            DynamicThreadPoolWrapper dynamicThreadPoolWrapper = new DynamicThreadPoolWrapper(dynamicThreadPoolExecutor.getThreadPoolId(), dynamicThreadPoolExecutor);
            
            //在这里把动态线程池的信息注册给服务端了
            ThreadPoolExecutor remoteThreadPoolExecutor = fillPoolAndRegister(dynamicThreadPoolWrapper);
            return DynamicThreadPoolAdapterChoose.match(bean) ? bean : remoteThreadPoolExecutor;
        }
    }

      
} 







//因为上面代码的第73行用到了一个DynamicThreadPoolWrapper对象，但是这个DynamicThreadPoolWrapper类的代码我还未给大家展示
//下面就展示一下，这个类的内容非常简单
package cn.hippo4j.core.executor;


/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/28
 * @方法描述：动态线程池包装类
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DynamicThreadPoolWrapper implements DisposableBean {

    //线程池租户信息，其实就是命名空间，项目Id,线程池Id
    private String tenantId, itemId, threadPoolId;

    //动态线程池本身
    private ThreadPoolExecutor executor;

    //构造方法
    public DynamicThreadPoolWrapper(String threadPoolId, ThreadPoolExecutor threadPoolExecutor) {
        this.threadPoolId = threadPoolId;
        this.executor = threadPoolExecutor;
    }


    public void execute(Runnable command) {
        executor.execute(command);
    }


    public Future<?> submit(Runnable task) {
        return executor.submit(task);
    }


    public <T> Future<T> submit(Callable<T> task) {
        return executor.submit(task);
    }



    @Override
    public void destroy() throws Exception {
        if (executor instanceof DynamicThreadPoolExecutor) {
            ((DynamicThreadPoolExecutor) executor).destroy();
        }
    }
}
```

上面代码块中 postProcessAfterInitialization 方法的代码仍然很少，只是注释多一点，代码逻辑也都是我之前为大家分析的那样：**首先判断 bean 对象是否为 DynamicThreadPoolExecutor 类型，如果不是则判断适配选择器是否能为 bean 对象选择到合适的适配器；只要这两个条件满足一个，就可以继续判断当前 bean 对象上是否存在 @DynamicThreadPool 注解，如果存在注解，就可以将动态线程池的配置信息收集起来，然后注册到服务端。而收集动态线程池配置信息，注册到服务端的操作，就在上面代码块中的 fillPoolAndRegister 方法中执行**。而 fillPoolAndRegister 方法还未实现，接下来我就一鼓作气，为大家实现这个 fillPoolAndRegister 方法。

## 引入 GlobalThreadPoolManage 线程池全局管理器

  

fillPoolAndRegister 方法实现思路非常简单，但要执行的操作就稍微多一些了，我之所以说该方法实现思路简单，**是因为在该方法中，只需要把动态线程池的配置信息封装到一个新的对象，就是我即将要定义的 DynamicThreadPoolRegisterParameter 对象中，然后将这个对象直接通过 HttpAgent 通信组件发送给服务端即可**。DynamicThreadPoolRegisterParameter 类的代码如下。

```
package cn.hippo4j.common.model.register;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/26
 * @方法描述：封装动态线程池核心信息的对象
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DynamicThreadPoolRegisterParameter {

    /**
     * Thread-pool id
     * Empty or empty strings are not allowed, and `+` signs are not allowed
     */
    private String threadPoolId;

    /**
     * Content
     */
    private String content;

    /**
     * Core pool size
     */
    private Integer corePoolSize;

    /**
     * Maximum pool size
     */
    private Integer maximumPoolSize;

    /**
     * Blocking queue type
     */
    private BlockingQueueTypeEnum blockingQueueType;

    /**
     * Capacity
     */
    private Integer capacity;

    /**
     * Keep alive time
     */
    private Long keepAliveTime;

    /**
     * Rejected policy type
     */
    private RejectedPolicyTypeEnum rejectedPolicyType;

    /**
     * Is alarm
     */
    private Boolean isAlarm;

    /**
     * Capacity alarm
     */
    private Integer capacityAlarm;

    /**
     * Active alarm
     */
    @JsonAlias("livenessAlarm")
    private Integer activeAlarm;

    /**
     * Allow core thread timeout
     */
    private Boolean allowCoreThreadTimeOut;

    /**
     * Thread name prefix
     */
    private String threadNamePrefix;

    /**
     * Execute timeout
     */
    private Long executeTimeOut;

    public Integer getIsAlarm() {
        return this.isAlarm ? 1 : 0;
    }

    public Integer getAllowCoreThreadTimeOut() {
        return this.allowCoreThreadTimeOut ? 1 : 0;
    }
}
```

注册线程池信息到服务端的逻辑很简单纯粹，几乎不用动脑子就能想到。但我又说这个方法操作步骤多一些，是因为在这个方法中要考虑一些其他的措施。因为我们要开发的是一个动态线程池框架，这个框架并不是说把动态线程池配置信息注册到服务端就完事了，还要收集动态线程池运行信息，以及根据服务端的通知动态更新客户端动态线程池的配置信息。客户端每次收集动态线程池信息的时候，肯定要获得动态线程池本身吧？进行配置动态变更的时候，肯定也要获得动态线程池本身，难道每一次我都要从 SpringBoot 容器中获得吗？再说了，我又怎么知道从 SpringBoot 容器中获得的动态线程池就是我要动态变更的线程池呢？所以，要想解决这种情况**，我还应该在程序中定义一个全局的线程池管理器，也就是 GlobalThreadPoolManage 类。只要客户端把动态线程池成功注册到服务端了，就紧接着把动态线程池本身和动态线程池当前的配置信息都注册到 GlobalThreadPoolManage 线程池全局管理器中**。注册的方法也很简单，就是在 GlobalThreadPoolManage 中定义两个 map，key 都是线程池 Id，value 就是线程池本身，和封装了线程池配置信息的对象。这样一来，只要以后再用到动态线程池，就可以直接根据动态线程池 Id 从线程池全局管理器中得到动态线程池了，这样岂不是方便很多？现在我就可以跟大家直说了，将动态线程池注册到线程池全局管理器中的操作，就要在 fillPoolAndRegister 方法中执行。

接下来我先为大家展示一下 GlobalThreadPoolManage 线程池全局管理器的代码，请看下面代码块。

```
package cn.hippo4j.core.executor.manage;


/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/27
 * @方法描述：线程池全局管理器
 */
public class GlobalThreadPoolManage {


    //下面这两个成员变量在第一版本还发挥不了作用，在第三版本代码中就可以发挥作用了
    //存放动态线程池核心参数的map，这个会在动态刷新线程池的时候用到
    private static final Map<String, ThreadPoolParameter> POOL_PARAMETER = new ConcurrentHashMap();

    //存放动态线程池包装对象的map，收集线程运行时信息的时候会用到
    private static final Map<String, DynamicThreadPoolWrapper> EXECUTOR_MAP = new ConcurrentHashMap();


    //根据线程池Id得到对应的DynamicThreadPoolWrapper对象
    public static DynamicThreadPoolWrapper getExecutorService(String threadPoolId) {
        return EXECUTOR_MAP.get(threadPoolId);
    }


    //根据线程池Id得到ThreadPoolExecutor的方法
    public static ThreadPoolExecutor getExecutor(String threadPoolId) {
        return Optional.ofNullable(EXECUTOR_MAP.get(threadPoolId)).map(each -> each.getExecutor()).orElse(null);
    }

    //根据线程池Id得到对用的线程池核心参数对象的方法
    public static ThreadPoolParameter getPoolParameter(String threadPoolId) {
        return POOL_PARAMETER.get(threadPoolId);
    }


    //把线程池核心参数信息和线程池包装对象交给线程池全局管理器管理的方法
    public static void register(String threadPoolId, ThreadPoolParameter threadPoolParameter, DynamicThreadPoolWrapper executor) {
        registerPool(threadPoolId, executor);
        registerPoolParameter(threadPoolId, threadPoolParameter);
    }


    public static void registerPool(String threadPoolId, DynamicThreadPoolWrapper executor) {
        EXECUTOR_MAP.put(threadPoolId, executor);
    }


    public static void registerPoolParameter(String threadPoolId, ThreadPoolParameter threadPoolParameter) {
        POOL_PARAMETER.put(threadPoolId, threadPoolParameter);
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/27
     * @方法描述：注册动态线程池信息到服务端的方法，这个方法大家先混个眼熟，很快就会用到
     */
    public static void dynamicRegister(DynamicThreadPoolRegisterWrapper registerWrapper) {
        //这里从ApplicationContext中得到了DynamicThreadPoolService对象
        //ApplicationContextHolder其实就是SpringBoot的ApplicationContext
        DynamicThreadPoolService dynamicThreadPoolService = ApplicationContextHolder.getBean(DynamicThreadPoolService.class);
        //DynamicThreadPoolService对象把动态线程池信息注册到服务端
        dynamicThreadPoolService.registerDynamicThreadPool(registerWrapper);
    }

    public static List<String> listThreadPoolId() {
        return new ArrayList<>(EXECUTOR_MAP.keySet());
    }


    public static Integer getThreadPoolNum() {
        return listThreadPoolId().size();
    }
}
```

引入线程池全局管理器之后，fillPoolAndRegister 方法其实才实现了一半。因为还有一种情况要跟大家解释清除。我们开发的这个动态线程池框架和 xxl-job 一样，都有 web 界面，也就是控制台，用户本来就可以在控制台添加动态线程池的信息，这样就带来了一种情况，那就是用户可能实现在控制台设置了动态线程池，这些信息已经存放到服务端的数据库中了，然后用户在客户端启动了程序，这样一来，在程序启动的过程中，客户端是不是就要先去访问服务端，看看服务端的数据库中是否存在相对应的动态线程池的配置信息，如果存在，就使用服务端的配置信息，因为这个信息是用户最新配置的。**所以，在 fillPoolAndRegister 方法中，客户端把动态线程池配置信息注册到服务端之前，要先去服务端查看一下数据库里是否存在对应线程池的配置信息，如果存在就是用服务端的配置信息。如果不存在，说明当前动态线程池是第一次向服务端注册，那么就收集动态线程池信息，注册到服务端即可。当然，不管动态线程池使用的是服务端的配置信息，还是直接把自己的信息注册到服务单，最后都不要忘了把线程池的信息注册到线程池全局管理器中**。到此为止，我才把 fillPoolAndRegister 方法的全部逻辑为大家分析完毕了，接下来就直接为大家展示代码。请看下面代码块。

```
package cn.hippo4j.springboot.start.support;


@Slf4j
@AllArgsConstructor
public final class DynamicThreadPoolPostProcessor implements BeanPostProcessor {


    //配置信息对象
    private final BootstrapProperties properties;

    //客户端代理对象
    private final HttpAgent httpAgent;


    //bean前置处理方法
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean;
    }



   /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/27
     * @方法描述：这个方法就是本类最核心的方法，用来处理DynamicThreadPoolExecutor对象
     */
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {

            //省略其他内容
            
            //将刚刚得到的dynamicThreadPoolExecutor对象包装成一个DynamicThreadPoolWrapper对象，这个对象会被交给线程池全局管理器来管理
            //之后收集线程池运行信息时都要用到这个对象
            DynamicThreadPoolWrapper dynamicThreadPoolWrapper = new DynamicThreadPoolWrapper(dynamicThreadPoolExecutor.getThreadPoolId(), dynamicThreadPoolExecutor);
            
            //在这里把动态线程池的信息注册给服务端了，注意，这里交给fillPoolAndRegister方法的已经是dynamicThreadPoolWrapper
            //对象了，而dynamicThreadPoolWrapper对象的代码之前已经展示过了
            ThreadPoolExecutor remoteThreadPoolExecutor = fillPoolAndRegister(dynamicThreadPoolWrapper);
            return DynamicThreadPoolAdapterChoose.match(bean) ? bean : remoteThreadPoolExecutor;
        }
    }





     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/27
     * @方法描述：注册线程池信息到服务端的方法，注意，这里交给fillPoolAndRegister方法的已经是dynamicThreadPoolWrapper对象了，而dynamicThreadPoolWrapper对象的代码之前已经展示过了
     */
    protected ThreadPoolExecutor fillPoolAndRegister(DynamicThreadPoolWrapper dynamicThreadPoolWrapper) {
        //先得到要注册的线程池的Id
        String threadPoolId = dynamicThreadPoolWrapper.getThreadPoolId();
        //得到真正的DynamicThreadPoolExecutor动态线程池
        ThreadPoolExecutor executor = dynamicThreadPoolWrapper.getExecutor();
        //封装线程池Id，命名空间，项目Id信息
        Map<String, String> queryStrMap = new HashMap(3);
        queryStrMap.put(TP_ID, threadPoolId);
        queryStrMap.put(ITEM_ID, properties.getItemId());
        queryStrMap.put(NAMESPACE, properties.getNamespace());
        //创建封装线程池参数信息的对象
        ThreadPoolParameterInfo threadPoolParameterInfo;


        
        //下面就是首先访问服务端，看看服务端是否存在动态线程池的配置信息的操作，如果存在就是用服务端的信息刷新本地动态线程池的配置信息
        
        
        try {//这里做了一个访问服务端的操作，这是因为也许用户通过web界面，已经实现在服务端定义好了线程池的配置信息
            //所以要以服务端的配置信息为主，因此在这里先访问服务端，看看服务端有没有设置好的动态线程池信息，其实就是去服务端查询数据库而已
            //这里访问的就是服务端的ConfigController类的detailConfigInfo方法
            //Constants.CONFIG_CONTROLLER_PATH就是要访问的服务端的接口，路径为"/hippo4j/v1/cs/configs"
            Result result = httpAgent.httpGetByConfig(Constants.CONFIG_CONTROLLER_PATH, null, queryStrMap, 5000L);
            //判断返回的结果中是否存在最新的线程池配置信息
            if (result.isSuccess() && result.getData() != null) {
                //如果存在就获取信息，然后转换成threadPoolParameterInfo对象
                String resultJsonStr = JSONUtil.toJSONString(result.getData());
                if ((threadPoolParameterInfo = JSONUtil.parseObject(resultJsonStr, ThreadPoolParameterInfo.class)) != null) {
                    //在这里刷新本地动态线程池的信息
                    threadPoolParamReplace(executor, threadPoolParameterInfo);
                    //然后把动态线程池交给本地的全局线程池管理器管理即可
                    //注意，这个时候从服务端返回了最新的动态线程池信息，就意味着动态线程池在之前注册到服务端了，并且信息已经存放到数据库了
                    //所以就不用再重复注册了，至于后面线程池的信息怎么动态刷新，这个后面再为大家实现
                    GlobalThreadPoolManage.register(dynamicThreadPoolWrapper.getThreadPoolId(), threadPoolParameterInfo, dynamicThreadPoolWrapper);
                }
            } 
            
            
            //下面就是第一次把动态线程池注册到服务端的操作
            
            else {
                //源码中这个分支有一个严重的bug，会导致程序无法正常运行，我给修正了一下
                //如果走到这里就意味着服务端没有当前动态线程池的任何信息，那就要在客户端构建一个DynamicThreadPoolRegisterWrapper对象，然后把这个对象直接发送给服务端，进行注册即可
                //这里创建的这个DynamicThreadPoolRegisterParameter对象封装了动态线程池的核心参数信息
                DynamicThreadPoolRegisterParameter parameterInfo = DynamicThreadPoolRegisterParameter.builder()
                        //线程Id
                        .threadPoolId(threadPoolId)
                        //核心线程
                        .corePoolSize(executor.getCorePoolSize())
                        //最大线程数
                        .maximumPoolSize(executor.getMaximumPoolSize())
                        //阻塞队列的类型
                        .blockingQueueType(BlockingQueueTypeEnum.getBlockingQueueTypeEnumByName(executor.getQueue().getClass().getSimpleName()))
                        //队列容量
                        .capacity(executor.getQueue().remainingCapacity())
                        //是否允许核心线程超过空闲时间后种植
                        .allowCoreThreadTimeOut(executor.allowsCoreThreadTimeOut())
                        //线程存活时间
                        .keepAliveTime(executor.getKeepAliveTime(TimeUnit.MILLISECONDS))
                        //是否启动告警，这里是默认不启用，但是在web界面可以修改是否启动的功能
                        .isAlarm(false)
                        //告警的活跃线程数量阈值
                        .activeAlarm(80)
                        //告警的队列容量阈值
                        .capacityAlarm(80)
                        //拒绝策略类型
                        .rejectedPolicyType(RejectedPolicyTypeEnum.getRejectedPolicyTypeEnumByName(executor.getRejectedExecutionHandler().getClass().getSimpleName()))
                        //构建DynamicThreadPoolRegisterParameter对象，其实这里面其实还有几个成员变量没有赋值，比如线程名称前缀，线程池执行任务的超时时间
                        .build();
                //在这里创建了DynamicThreadPoolRegisterWrapper对象，并且把刚才创建的parameterInfo交给registerWrapper对象，这个registerWrapper对象要发送给服务端进行注册
                DynamicThreadPoolRegisterWrapper registerWrapper = DynamicThreadPoolRegisterWrapper.builder()
                        .parameter(parameterInfo)
                        .build();
                
                //将线程池信息注册到服务端，这里是通过线程池全局管理器来注册的
                //还记得我之前在展示GlobalThreadPoolManage代码的时候，让大家对dynamicRegister方法混个眼熟，这里就用到了dynamicRegister方法
                //开始真正把客户端线程池信息注册到服务端了
                GlobalThreadPoolManage.dynamicRegister(registerWrapper);
                //再次得到parameter信息
                ThreadPoolParameterInfo parameter = JSONUtil.parseObject(JSONUtil.toJSONString(parameterInfo), ThreadPoolParameterInfo.class);
                //注册服务端成功之后，再把动态线程池注册到本地的线程池全局管理器中,这里只需要把DynamicThreadPoolWrapper注册到线程池全局管理器中即可
                //因为注册线程池的动作并没有更新本地动态线程池，使用的就是客户端默认配置的线程池参数创建的动态线程池，所以直接存放DynamicThreadPoolWrapper对象即可
                GlobalThreadPoolManage.register(dynamicThreadPoolWrapper.getThreadPoolId(), parameter, dynamicThreadPoolWrapper);
            }
        } catch (Exception ex) {
            log.error("Failed to initialize thread pool configuration. error message: {}", ex.getMessage());
        }
        //返回executor，如果服务端存在配置信息，那么这里返回的就是经过刷新的动态线程池对象
        return executor;
    }


    //使用服务端传回来的动态线程池的配置信息刷新本地线程池信息
    private void threadPoolParamReplace(ThreadPoolExecutor executor, ThreadPoolParameterInfo threadPoolParameterInfo) {
        BlockingQueue workQueue = BlockingQueueTypeEnum.createBlockingQueue(threadPoolParameterInfo.getQueueType(), threadPoolParameterInfo.getCapacity());
        //利用反射设置队列
        ReflectUtil.setFieldValue(executor, "workQueue", workQueue);
        //下面的逻辑很简单，就不添加注释了
        executor.setCorePoolSize(threadPoolParameterInfo.corePoolSizeAdapt());
        executor.setMaximumPoolSize(threadPoolParameterInfo.maximumPoolSizeAdapt());
        executor.setKeepAliveTime(threadPoolParameterInfo.getKeepAliveTime(), TimeUnit.SECONDS);
        executor.allowCoreThreadTimeOut(EnableEnum.getBool(threadPoolParameterInfo.getAllowCoreThreadTimeOut()));
        executor.setRejectedExecutionHandler(RejectedPolicyTypeEnum.createPolicy(threadPoolParameterInfo.getRejectedType()));
        if (executor instanceof DynamicThreadPoolExecutor) {
            Optional.ofNullable(threadPoolParameterInfo.getExecuteTimeOut())
                    .ifPresent(executeTimeOut -> ((DynamicThreadPoolExecutor) executor).setExecuteTimeOut(executeTimeOut));
        }
    }
    
} 




//在上面代码的第126行，用到了一个DynamicThreadPoolRegisterWrapper对象，这个类的内容如下所示
package cn.hippo4j.common.model.register;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/26
 * @方法描述：这个动态线程池的包装注册器对象，这个对象中封装了动态线程池中要注册到服务端的重要信息
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DynamicThreadPoolRegisterWrapper {


    //这个对象中封装了动态线程池的核心信息，什么核心线程，存活时间，最大线程等等重要信息，都在这个对象中
    private DynamicThreadPoolRegisterParameter parameter;

    //租户Id，也就是命名空间
    private String tenantId;

    //项目Id
    private String itemId;

}
```

在上面代码块中，我就把注册客户端动态线程池信息到服务端的操作实现完毕了，当然，最终注册的步骤还没有给大家展示，因为最后又调用了 GlobalThreadPoolManage.dynamicRegister(registerWrapper) 方法，把注册操作交给了 GlobalThreadPoolManage 线程池全局管理器执行。所以接下来我们要再回到 GlobalThreadPoolManage 对象中，看看 dynamicRegister 方法的具体逻辑。请看下面代码块。

```
package cn.hippo4j.core.executor.manage;


/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/27
 * @方法描述：线程池全局管理器
 */
public class GlobalThreadPoolManage {


    //下面这两个成员变量在第一版本还发挥不了作用，在第三版本代码中就可以发挥作用了
    //存放动态线程池核心参数的map，这个会在动态刷新线程池的时候用到
    private static final Map<String, ThreadPoolParameter> POOL_PARAMETER = new ConcurrentHashMap();

    //存放动态线程池包装对象的map，收集线程运行时信息的时候会用到
    private static final Map<String, DynamicThreadPoolWrapper> EXECUTOR_MAP = new ConcurrentHashMap();

    //省略其他方法

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/27
     * @方法描述：注册动态线程池信息到服务端的方法，这个方法大家先混个眼熟，很快就会用到
     */
    public static void dynamicRegister(DynamicThreadPoolRegisterWrapper registerWrapper) {
        //这里从ApplicationContext中得到了DynamicThreadPoolService对象
        //ApplicationContextHolder其实就是SpringBoot的ApplicationContext
        DynamicThreadPoolService dynamicThreadPoolService = ApplicationContextHolder.getBean(DynamicThreadPoolService.class);
        //DynamicThreadPoolService对象把动态线程池信息注册到服务端
        dynamicThreadPoolService.registerDynamicThreadPool(registerWrapper);
    }


}
```

可以看到，在上面代码块的 dynamicRegister 方法中，其实是从 SpringBoot 容器中获得了一个 DynamicThreadPoolService 对象，然后调用了这个对象的 registerDynamicThreadPool 方法，把动态线程池的信息注册到客户端了。

  

## 引入 DynamicThreadPoolConfigService，实现线程池信息注册

  

那 DynamicThreadPoolService 又是什么呢？之前好像也没有提到过它，这里我就不卖关子了，DynamicThreadPoolService 其实是一个接口，其具体的实现类为 DynamicThreadPoolConfigService，具体实现请看下面代码块。

```
package cn.hippo4j.springboot.start.support;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/26
 * @方法描述：这个类的对象是客户端非常重要的一个组件，就是这个类的对象提供了把动态线程池信息注册到服务端的功能
 */
@Slf4j
@RequiredArgsConstructor
public class DynamicThreadPoolConfigService extends AbstractDynamicThreadPoolService {

    //得到访问服务单的http代理
    private final HttpAgent httpAgent;

    //得到配置信息对象
    private final BootstrapProperties properties;

    //注册动态线程池信息到服务端的入口方法
    @Override
    public void registerDynamicThreadPool(DynamicThreadPoolRegisterWrapper registerWrapper) {
        registerExecutor(registerWrapper);
    }

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/26
     * @方法描述：在该方法中把动态线程池的信息注册到服务端，注意，只要执行了注册方法，就意味着服务端之前是没有动态线程池信息的，也就意味着客户端本地的动态线程池的配置信息就是最新的
     * 源码中这个方法中有一个严重的bug，会导致程序无法正常运行，我给修正了一下
     */
    private void registerExecutor(DynamicThreadPoolRegisterWrapper registerWrapper) {
        //从动态线程池的包装注册器中得到要注册到服务端的动态线程池的参数信息对象
        DynamicThreadPoolRegisterParameter registerParameter = registerWrapper.getParameter();
        //检查线程池参数是否合法
        checkThreadPoolParameter(registerParameter);
        //得到动态线程池Id
        String threadPoolId = registerParameter.getThreadPoolId();
        try {//向要注册到服务端的线程池对象中设置租户信息和项目Id
            failDynamicThreadPoolRegisterWrapper(registerWrapper);
            //在这里向服务端注册了动态线程池的信息，注意，这里是直接把registerWrapper这个DynamicThreadPoolRegisterWrapper类型的对象传输给服务端了
            //并且这里使用的是http通信方式，服务端接收这个请求的是ConfigController类的register方法，大家可以直接去服务端看看接收之后的注册逻辑
            //REGISTER_DYNAMIC_THREAD_POOL_PATH就是服务端对应的接口，完整路径为"/hippo4j/v1/cs/configs/register"
            Result registerResult = httpAgent.httpPost(REGISTER_DYNAMIC_THREAD_POOL_PATH, registerWrapper);
            //根据返回结果判断是否注册成功了
            if (registerResult == null || !registerResult.isSuccess()) {
                throw new ServiceException("Dynamic thread pool registration returns error."
                        + Optional.ofNullable(registerResult).map(Result::getMessage).orElse(""));
            }
        } catch (Throwable ex) {
            log.error("Dynamic thread pool registration execution error: {}", threadPoolId, ex);
            throw ex;
        }
    }


    //判断线程池参数是否合法的方法
    private void checkThreadPoolParameter(DynamicThreadPoolRegisterParameter registerParameter) {
        //判断线程池Id中是否不包含+号，如果包含就意味着有敏感字符
        Assert.isTrue(!registerParameter.getThreadPoolId().contains("+"), "The thread pool contains sensitive characters.");
    }

    //向要注册到服务端的线程池对象中设置租户信息和项目Id的方法
    private void failDynamicThreadPoolRegisterWrapper(DynamicThreadPoolRegisterWrapper registerWrapper) {
        registerWrapper.setTenantId(properties.getNamespace());
        registerWrapper.setItemId(properties.getItemId());
    }
}





//既然DynamicThreadPoolConfigService对象可以从SpringBoot容器中获得，所以这个对象其实也是要交给SpringBoot容器管理的
//因为，我把这个对象也定义在DynamicThreadPoolAutoConfiguration类中了，所以DynamicThreadPoolAutoConfiguration配置类也需要重构一下，请看下面代码块
package cn.hippo4j.springboot.start.config;


/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/26
 * @方法描述：这个就是spring-starter中的核心类，这个类使用了大量springboot的功能，这个类上的springboot注解应该都是常用注解了，所以这些功能我就不写注释了
 */
@Configuration
@AllArgsConstructor
@ConditionalOnBean(MarkerConfiguration.Marker.class)
//这个注解会使BootstrapProperties类上的ConfigurationProperties注解生效，BootstrapProperties对象就可以被SpringBoot容器管理了
@EnableConfigurationProperties(BootstrapProperties.class)
@ConditionalOnProperty(prefix = BootstrapProperties.PREFIX, value = "enable", matchIfMissing = true, havingValue = "true")
public class DynamicThreadPoolAutoConfiguration {

    //在这里把配置文件中的相关信息封封装到这个成员变量中了
    //properties对象会被自动注入
    private final BootstrapProperties properties;


    //远程通信组件，使用的是http通信方式
    @Bean
    public HttpAgent httpAgent(BootstrapProperties properties) {
        return new ServerHttpAgent(properties);
    }


    //创建动态线程池的服务对象，在第一版本代码中提供了注册线程池信息到服务端功能
    @Bean
    @SuppressWarnings("all")
    public DynamicThreadPoolService dynamicThreadPoolConfigService(HttpAgent httpAgent) {
        return new DynamicThreadPoolConfigService(httpAgent, properties);
    }


    //动态线程池处理器，这个处理器其实是就是spring中的一个bean处理器，在这个bean处理器中把动态线程池包装成了DynamicThreadPoolRegisterWrapper对象
    //然后开始向服务端注册该动态线程池的信息
    @Bean
    @SuppressWarnings("all")
    public DynamicThreadPoolPostProcessor threadPoolBeanPostProcessor(HttpAgent httpAgent,
                                                                      ApplicationContextHolder hippo4JApplicationContextHolder) {
        return new DynamicThreadPoolPostProcessor(properties, httpAgent);
    }

} 
```

到此为止，我就为大家把客户端注册动态线程池配置信息到服务端的功能完整实现了。代码量其实一点也不多，只不过是我为了给大家解释得更详细一些，添加的注释多一点。现在大家已经可以去看第一版本代码了，可以结合第一版本代码多看看文章。这个就是大家自己的事了。

## 服务端注册的简单实现

  

客户端注册动态线程池信息到服务端的功能我已经给大家全部实现完毕了，在本章的最后一小节，我打算跟大家简单讲解一下动态线程池框架服务端功能的实现。其实所谓的服务端，就是一个 SpringBoot 开发的 web 服务器而已，使用的就是 tomcat，端口号为 6691，大家可以直接启动第一版本代码中的 ServerApplication 类，代码如下。

```
package cn.hippo4j.server;


//这个类在hippo4j-server-01模块下的hippo4j-bootstrap-01模块中
@EnableTransactionManagement
@SpringBootApplication(scanBasePackages = "cn.hippo4j")
@MapperScan(basePackages = {"cn.hippo4j.config.mapper", "cn.hippo4j.auth.mapper"})
public class ServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServerApplication.class, args);
    }
}
```

程序启动之后，服务端的 ConfigController 控制器对象就可以发挥作用了。这个控制器就是处理服务端动态线程池配置信息的入口。具体实现请看下面代码块。

```
package cn.hippo4j.config.controller;

import cn.hippo4j.common.constant.Constants;
import cn.hippo4j.common.model.register.DynamicThreadPoolRegisterWrapper;

import cn.hippo4j.common.web.base.Result;
import cn.hippo4j.common.web.base.Results;
import cn.hippo4j.config.model.ConfigAllInfo;
import cn.hippo4j.config.model.ConfigInfoBase;
import cn.hippo4j.config.service.biz.ConfigService;
import lombok.AllArgsConstructor;
import lombok.SneakyThrows;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Map;

/**
 * @author:B站UP主陈清风扬，从零带你写框架系列教程的作者，个人微信号：chenqingfengyangjj。
 * @Description:系列教程目前包括手写Netty，XXL-JOB，Spring，RocketMq，Javac，JVM等课程。
 * @Date:2024/4/29
 * @Description:处理线程池配置信息的控制器，这个控制器引入进来是因为当客户端创建动态线程池的时候
 * 会先访问一次服务端，看看服务端的数据库中是否存在线程池的配置信息，如果存在就使用数据库中的信息
 * 刷新客户端动态线程池
 */
@RestController
@AllArgsConstructor
@RequestMapping(Constants.CONFIG_CONTROLLER_PATH)
public class ConfigController {

    //这个就是操作数据库的对象，其实现类为ConfigServiceImpl
    private final ConfigService configService;


    //这个方法就是用来处理查询线程池配置信息请求的
    //客户端在注册动态线程池之前，会首先到服务端查询一下，数据库中是否存在对应的线程池配置信息
    @GetMapping
    public Result<ConfigInfoBase> detailConfigInfo(@RequestParam("tpId") String tpId,
                                                   @RequestParam("itemId") String itemId,
                                                   @RequestParam("namespace") String namespace,
                                                   @RequestParam(value = "instanceId", required = false) String instanceId) {
        ConfigAllInfo configAllInfo = configService.findConfigRecentInfo(tpId, itemId, namespace, instanceId);
        return Results.success(configAllInfo);
    }


    //配置变更的入口方法，用户在web界面改变数据库中线程池的配置信息时，前端请求会被这个方法接收并处理
    @PostMapping
    public Result<Boolean> publishConfig(@RequestParam(value = "identify", required = false) String identify,
                                         @RequestBody ConfigAllInfo config) {
        //暂时还不实现
        return Results.success(true);
    }

    //客户端长轮询的请求会被这个方法处理
    @SneakyThrows
    @PostMapping("/listener")
    public void listener(HttpServletRequest request, HttpServletResponse response) {
        //暂时还不实现
    }

    
    //这个方法就是注册客户端线程池信息到服务端的入口方法
    @PostMapping("/register")
    public Result register(@RequestBody DynamicThreadPoolRegisterWrapper registerWrapper) {
        configService.register(registerWrapper);
        return Results.success();
    }

}
```

到此为止，第一版本服务端的简单实现也就给大家展示完毕了，当然，服务端的核心功能肯定都在 ConfigServiceImpl 对象中，但是这个对象中都是对线程池的配置信息增删改查的方法，都类似于业务逻辑，要和数据库打交道。这写代码我就不讲了，大家简单看看就成。也可以把数据库的脚本文件运行一看，看看数据库都有什么表，哪个表对应哪个实体类，每一个实体类有什么区别。我想这些逻辑对大家来说应该都很简单，这里我多说一句，因为 hippo4j 框架使用的是 mybatisplus，所以有些 Mapper 并没有 sql 语句，大家看代码的时候仔细一点就行。还有就是在和数据库打交道的时候，大家会看到两个类，一个是 ConfigAllInfo，一个是 ConfigInstanceInfo，这两个类的对象封装的线程池配置信息其实没什么区别，主要区别就是 ConfigInstanceInfo 还封装了客户端实例的 Id，其实就是客户端地址+一个uuid。在前端展示给用户信息的时候，会体现出这两个对象的区别，在第一版本大家还不用关注这一点。当客户端把动态线程池信息注册到服务端时，会把这些信息封装到 ConfigAllInfo 对象中，然后把数据存入数据库。

  

这一章的内容到这里就结束了，目前我们已经实现了客户端把动态线程池的配置信息注册到服务端的功能，接下来还有两个重要功能等着我们实现。**一个是客户端收集动态线程池运行时信息，上报给服务端；另一个就是客户端根据服务端通知，动态刷新本地线程池配置信息**。这两个功能也都很简单，不过下一章我们的内容并不是这个，而是要先实现一下客户端和服务端的 **服务发现、健康检测以及过期服务移除功能**，不然客户端运行了一段时间，直接和服务端断开连接了，那就什么也做不了了。好了朋友们，这一章就到此为止，我们下一章见！