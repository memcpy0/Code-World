在上一章结尾我就跟大家说了，这一章要实现 nacos 框架中最核心的功能机制，那就是事件通知机制。按照以往文章更新的方式，我很少会在文章开头就把本章要实现的功能直接说清楚。通常我都是提出几个问题，从目前构建好的程序中挑出一些缺点，然后跟大家一起解决这些问题，而解决问题的方式就是为框架引入新的功能机制，不断重构框架，最后把要实现的功能迭代完整，展示给大家。但在本章一开始，我就跟大家说这一章要实现 nacos 的事件通知机制功能，这是因为在之前更新的 hippo4j 动态线程池框架中，我已经为大家简单展示过这个事件通知机制功能了。hippo4j 动态线程池框架大量借鉴了 nacos 的代码，其中就有时间通知机制功能。不过 hippo4j 框架借鉴的事件通知机制并不完善，也有很多功能根本用不上，仅仅通过 hippo4j 这个框架，大家根本无法领略 nacos 框架事件通知机制的精髓，所以这一章，我会从头开始为大家把 nacos 框架的事件通知机制一点点实现了。当然，就目前框架的完成度来说——因为我们只构建了注册中心客户端——就算实现了这个事件通知机制，也无法完全发挥这个机制的作用，实际上，在 nacos 服务端才把这个事件通知机制的功能发挥得淋漓尽致。等我们真正开始实现 nacos 服务端功能时，大家就会发现，在 nacos 服务端，很多功能组件之所以能协同工作，正是因为事件通知机制将它们衔接起来了。好了，多余的话就不说了，直接开始本章内容吧。

## 引入事件机制，重用监听器模式

如果大家还记得前几章的内容，那么对注册中心客户端的操作重试功能肯定还有印象，在实现这个功能的时候，我引入了一个 NamingGrpcRedoService 失败重试组件，这个组件本身就是一个 ConnectionEventListener 监听器对象，专门监听连接事件，也就是 ConnectionEvent 事件。只要监听器对象监听到了客户端与服务端连接的断开和重建事件，这个 NamingGrpcRedoService 失败重试组件就会执行相应的方法，判断是否应该对失败的操作进行重试。这个功能的实现原理也非常简单，无非就是把监听器对象添加到 RpcClient 的连接事件监听器队列中了，只要触发了连接事件，就会通知监听器队列中的监听器对象执行其内部的方法。这些知识想必大家都还有印象。

现在呢，我想说的是，在我们实现的这个注册中心客户端中，可能并不只是存在连接事件，或者说可能我们并不仅仅需要关注客户端与服务端连接的断开与重建，程序中还有很多其他的重要变更需要我们关注。比如说上一章我们刚刚实现了注册中心客户端向服务端订阅服务实例信息的功能，随着这个功能的实现，客户端就可以从服务端得到所订阅的服务实例的相关信息了，当然，服务端也会根据情况把变更后最新的服务实例信息主动推送给客户端。当客户端接收到服务端传输过来的服务实例信息之后，总会调用服务实例信息缓存对象，也就是 ServiceInfoHolder 对象，调用这个对象的 processServiceInfo 方法处理这些服务实例信息，会判断这些服务实例信息是否发生过变化，如果发生过变化，**并且服务实例最新的引用时间比客户端本地缓存的服务实例的引用时间大，就意味着服务端传送过来的服务实例的信息是最新的**，因为客户端还要对接收到的服务实例信息做持久化操作，所以客户端一旦判断出来从服务端接收到的服务实例信息发生过变更，就可以更新存储了服务实例信息的本地文件的内容了。这是上一章实现的功能，非常简单，我想大家肯定也都看过第四版本代码了。

那么接下来，我想问的是，请大家想一想，当客户端调用 ServiceInfoHolder 对象的 processServiceInfo 方法处理从服务端接收到服务实例信息时，发现服务实例的信息发生过变更，除了可以执行更新本地文件的操作，还可以执行什么操作呢？最简单的，**我完全可以定义一个记录日志信息的操作，把服务实例变更的信息记录在日志中；还可以把服务实例变更信息上报到监控平台，这些都是用来观测和调整程序运行状况的重要信息；当然，如果是 RPC 远程调用框架的消费者使用了注册中心的客户端，那我还可以直接通知 RPC 框架的消费者，告诉服务实例信息发生变更了，这样一来，它在使用负载均衡策略选择服务器远程调用目标方法时，就可以选择到正常提供服务的服务提供者**。还有很多其他可以执行的操作，我就不一一列举了，总之大家可以看到，当客户端发现服务实例信息发生变更之后，有很多操作可以执行，虽然我们可以把某些操作内置在注册中心的客户端里，比如记录日志的操作，但是还有很多其他操作，可能和注册中心客户端本身没什么关系。**既然是这样，那我为什么不再定义一个监听器对象，在监听器对象中定义方法，然后把这个监听器暴露给用户，这样一来，用户就可以在监听器的方法中定义自己想要的操作，然后在客户端发现服务实例信息发生变更时，直接调用用户定义的这个监听器中的方法不就行了**？当然，为了让这个功能的机制更健全一些，这时候我是不是就可以模仿操作失败重试功能，专门为服务实例信息变更定义一个事件，然后再定义一个监听器对象，专门监听这个事件呢？接下来就让我们来实现这个功能吧。

首先为服务实例信息变更定义一个事件，比如就定义为 InstancesChangeEvent，既然这个事件会在服务实例信息变更之后发布，那么这个事件对象肯定要封装最新的服务实例信息吧，这个事件肯定会被用户在监听器中获得，如果得到了事件对象，但是事件对象中关于服务实例的什么最新信息都没有，那定义这个事件对象还有什么用呢？所以我把事件对象定义成了下面这样，请看下面代码块。

```
package com.cqfy.nacos.client.naming.event;


//这里可以看到，这个InstancesChangeEvent服务实例变更事件其实继承了Event类
//Event是一个抽象类，之所以会有Event这个抽象类，是因为在nacos框架中存在各种各样的事件对象
//有服务实例变更事件对象，有服务实例注销事件，有客户端变更事件，还有集群成员变更事件等等
//总之这些事件都继承了Event抽象父类，在Event抽象父类中给每一个事件定义了事件序号，其他的作用就没有了
//所以，Event类的内容非常简单，非常少，所以我就先不给大家展示这个Event抽象类了
//等后面讲到事件序号的时候，我再为大家展示这个Event抽象父类
public class InstancesChangeEvent extends Event{

    private static final long serialVersionUID = -8823087028212249603L;

    //事件作用域标志，这个作用域标志大家暂时忽略，后面马上就会具体展示
    private final String eventScope;

    //订阅的服务实例名称
    private final String serviceName;

    //分组名称
    private final String groupName;

    //集群名称
    private final String clusters;

    //最新的服务实例信息
    private final List<Instance> hosts;

    public InstancesChangeEvent(String eventScope, String serviceName, String groupName, String clusters, List<Instance> hosts) {
        this.eventScope = eventScope;
        this.serviceName = serviceName;
        this.groupName = groupName;
        this.clusters = clusters;
        this.hosts = hosts;
    }

    public String getServiceName() {
        return serviceName;
    }

    public String getGroupName() {
        return groupName;
    }

    public String getClusters() {
        return clusters;
    }

    public List<Instance> getHosts() {
        return hosts;
    }

    
    public String scope() {
        return this.eventScope;
    }
}
```

从上面的代码块可以看到，我新定义的这个 InstancesChangeEvent 事件对象把最新服务实例的信息全部都封装了。接下来，**只要客户端检测到从服务端传输过来的服务实例信息更新了，那就可以创建一个 InstancesChangeEvent 事件对象，把最新服务实例信息封装到 InstancesChangeEvent 对象中。然后调用用户自己定义的监听器即可。当然，在调用监听器方法的时候，肯定需要把刚创建的这个 InstancesChangeEvent 服务实例变更事件对象传递到监听器的方法中**。所以下面我就为大家展示一下我新定义的监听器接口，也就是 EventListener，这个接口的具体内容如下，请看下面代码块。

```
package com.cqfy.nacos.api.naming.listener;


public interface EventListener {

    //在onEvent方法中，用户可以把Event事件对象转换成它的子类对象
    void onEvent(Event event);
}
```

可以看到，我在这个 EventListener 接口中定义了一个 onEvent 方法，这个 EventListener 接口的实现类，也就是这个接口中的 onEvent 方法就可以交给用户自己实现，通过 onEvent 方法，可以获得封装了最新服务实例信息的 InstancesChangeEvent 事件对象，接下来执行什么操作，那就是用户自己的事情了。当然，这里其实还可以再扩展一下，请大家想一想，InstancesChangeEvent 肯定是由注册中心客户端发布的，因为是注册中心客户端接收到服务端传递过来的服务实例信息后，判断服务实例信息是否发生变更了，如果发生变更了，就发布 InstancesChangeEvent 服务实例变更事件，然后再调用用户自己定义的监听器对象中的方法，执行用户自己定义的额外的操作。到目前为止，这些操作应该都是注册中心客户端中的线程执行的(其实是 Grpc 框架的业务线程池执行的)，并且接下来注册中心客户端的线程还要进一步执行用户自定义的操作。假如这些操作非常耗时，难道还要让注册中心客户端的线程执行吗？如果用户定义的操作非常耗时，倒不如就让用户自己定义的线程池来执行这些耗时的操作。也就是说，**用户可以在创建监听器对象的时候，专门为监听器对象执行一个线程池，这个线程池就用来执行监听器对象的 onEvent 方法**。当然，有的监听器对象的 onEvent 方法要执行的操作并不繁琐，那就没必要执行线程池来执行了。为了实现这个功能，**我又为 EventListener 接口定义了一个抽象实现类，那就是 AbstractEventListener**，具体实现如下，请看下面代码块。

```
package com.cqfy.nacos.api.naming.listener;


public abstract class AbstractEventListener implements EventListener {

   
    public Executor getExecutor() {
        return null;
    }

}
```

可以看到，在 AbstractEventListener 类中定义了一个 getExecutor 方法，这个方法也可以由用户自己实现，返回用户自己定义的执行器对象，并且就用这个执行器执行监听器对象的 onEvent 方法。接下来我为大家写了一个创建监听器对象的例子，请大家看一看，请看下面代码块。

```
//创建一个执行器，用来执行监听器对象的onEvent方法
Executor executor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),
        runnable -> {
            Thread thread = new Thread(runnable);
            thread.setName("test-thread");
            return thread;
        });


//下面是创建监听器对象的操作
EventListener listener = new AbstractEventListener() {

            //用户可以自定义一个线程池，异步执行监听器的回调任务，如果没有自定义线程池，那么监听器中的方法就不异步执行了
            //这里就是返回了上面定义的执行器对象
            @Override
            public Executor getExecutor() {
                return executor;
            }

            @Override
            public void onEvent(Event event) {
                //在回调方法中具体执行什么操作就先省略了
            }
        }
```

通过上面的例子，现在大家应该都明白了监听器对象该怎么创建了吧。好了，到此为止监听器对象就告一段落，监听器功能本来就很简单，大家关注的重点应该也不在此。我想，目前大家最困惑的是：**怎么让用户自己定义的执行器来执行监听器对象的 onEvent 方法**。毕竟我们只是实现了监听器对象本身，我并没有跟大家讲解，怎么使用监听器对象的执行器执行它的 onEvent 方法。我的建议是暂时把这个问题放一放，这个还不是最棘手的问题，不管怎么说，首先得让监听器对象的 onEvent 方法被调用了，才能考虑怎么让用户自己定义的执行器来执行，对吧？那么监听器对象的 onEvent 方法该如何被调用呢？

## 引入 InstancesChangeNotifier 服务实例变更事件通知器

请大家想一想，我们现在定义的这个监听器对象主要是监听服务实例变更事件。那么，要想让监听器对象的方法被调用，肯定需要注册中心客户端检测到从服务端传输过来的服务实例信息发生变更了，而这个判断的操作是在 ServiceInfoHolder 服务实例信息缓存器的 processServiceInfo 方法中执行的，就是下面代码块展示的这些，请看下面代码块。

```
package com.cqfy.nacos.client.naming.cache;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/24
 * @方法描述：该类的对象就是客户端的服务信息保存器，从服务端订阅的所有服务实例的信息都会存放在这个类的对象中
 */
public class ServiceInfoHolder implements Closeable {

    //其余内容省略


    //这个map中缓存了从服务端获得的服务实例的信息，把服务实例缓存在内存中，同时也会存储在本地硬盘上
    //string就是服务名称，ServiceInfo封装着该服务下所有服务实例信息
    private final ConcurrentMap<String, ServiceInfo> serviceInfoMap;


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/24
     * @方法描述：这是本类中最重要的方法，就是处理ServiceInfo对象的方法，这个ServiceInfo对象一般都是从服务端返回的
     * 该方法的逻辑很简单，那就是看看新得到的这个ServiceInfo对象相对于本地缓存的ServiceInfo对象是否产生了变化，如果产生变化就要发布服务实例变更事件
     */
    public ServiceInfo processServiceInfo(ServiceInfo serviceInfo) {
        
        //得到ServiceInfo的key
        String serviceKey = serviceInfo.getKey();
        if (serviceKey == null) {
            return null;
        }
        
        
        //从map中得到客户端缓存的旧的ServiceInfo对象
        ServiceInfo oldService = serviceInfoMap.get(serviceInfo.getKey());
        
        //走到这里就要先更新缓存中的ServiceInfo对象
        serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);
        
        //判断新的ServiceInfo对象相对于旧的是否发生了变化
        boolean changed = isChangedServiceInfo(oldService, serviceInfo);
        //这里是设置一下新的ServiceInfo对象中的json串，后面将ServiceInfo对象写到本地文件中时要用到
        if (StringUtils.isBlank(serviceInfo.getJsonFromServer())) {
            serviceInfo.setJsonFromServer(JacksonUtils.toJson(serviceInfo));
        }
        
        
        //判断服务实例是否发生变化
        if (changed) {
            NAMING_LOGGER.info("current ips:({}) service: {} -> {}", serviceInfo.ipCount(), serviceInfo.getKey(),
                    JacksonUtils.toJson(serviceInfo.getHosts()));
            
            //如果发生了变化，就把最新的ServiceInfo写入到本地文件中
            DiskCache.write(serviceInfo, cacheDir);
        }
        
        return serviceInfo;
    }



    //其余内容省略
    
}
```

在上面代码块的第 52 行，会判断从服务端接收到的服务实例的信息是否更新了，如果更新了，就要把缓存了服务实例信息的本地文件也更新了，这是第四版本代码的操作。但现在我们已经引入了服务实例变更事件，并且也为该事件定义了监听器对象，现在我们希望定义的监听器对象能够被调用，这就很简单了，**直接在客户端检测到服务实例信息发生变更，然后发布服务实例变更事件，再执行监听器对象中的方法不就行了**？那这样一来我是不是就要在 ServiceInfoHolder 类中再定义一个 map，这个 map 专门存放各个服务实例对应的监听器对象。可能这一步跨度有点大，接下来让我为大家仔细分析一下。

假如说注册中心客户端从服务端订阅了一个服务实例的信息，这就意味着客户端会检查这个服务实例的信息是否发生变更了，用户也可以为这个服务实例是否变更专门定义一个监听器，一旦服务实例发生变更，客户端直接发布服务实例变更事件，然后调用用户定义的监听器中的方法即可。这里我们只是定义了一个监听器，但实际上，**用户可能并不会只为这个服务实例定义一个监听器对象，可能用户会定义多个监听器对象，因为有很多操作可能会在该服务实例的信息发生变更之后被同时执行**。所以，在这种情况下，**我其实应该在 ServiceInfoHolder 类中定义一个监听器集合比较合适。集合中存放了为某个服务实例定义的监听器对象，只要客户端发布了服务实例变更事件，那就可以直接调用集合中的每一个监听器对象的方法，执行用户定义的操作就行了。当然，既然能从监听器集合中得到监听器对象本身了，当然可以先从监听器对象中获得用户自己定义的执行器，然后使用执行器执行监听器的方法**。这个操作流程应该很容易理解吧。

按照刚才的分析，我其实就可以直接在 ServiceInfoHolder 类中定义监听器集合了，但是在定义之前，请大家再想一想，注册中心客户端不可能只订阅一个服务实例的信息，或者说不可能只订阅一种服务实例的信息，也许注册中心还会订阅多种实例信息，只不过这些服务实例在另外的 Group 中，可能服务名称不同，提供的服务也不相同。也就是说，**用户可能为不同的服务实例变更情况定义多个不同的监听器对象**，那这种情况下，**就不能在 ServiceInfoHolder 中定义监听器集合了，而是应该定义一个 map，这个 map 的key 就是服务实例的具体名称，所谓具体名称就是服务实例的 serviceName + groupName + clusters 得到的字符串，对应的 value 就是监听器集合**。所以，现在大家应该明白了，我说要在 ServiceInfoHolder 类中定义一个 map 是什么意思了吧？

经过刚才的分析，重构之后的 ServiceInfoHolder 类就可以写成下面这样，请看下面代码块。

```
package com.cqfy.nacos.client.naming.cache;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/24
 * @方法描述：该类的对象就是客户端的服务信息保存器，从服务端订阅的所有服务实例的信息都会存放在这个类的对象中
 */
public class ServiceInfoHolder implements Closeable {

    //其余内容省略


    //这个map中缓存了从服务端获得的服务实例的信息，把服务实例缓存在内存中，同时也会存储在本地硬盘上
    //string就是服务名称，ServiceInfo封装着该服务下所有服务实例信息
    private final ConcurrentMap<String, ServiceInfo> serviceInfoMap;


    //这个map中存放的就是真正的事件监听器，也就是用户定义的事件监听器
    //其中key就是坚挺的具体服务的名称，value就是对应的监听器集合，当某个服务下的服务实例信息发生变更，客户端知道后就会执行用户自己定义的监听器中的方法
    private final Map<String, ConcurrentHashSet<EventListener>> listenerMap = new ConcurrentHashMap<>();


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/24
     * @方法描述：这是本类中最重要的方法，就是处理ServiceInfo对象的方法，这个ServiceInfo对象一般都是从服务端返回的
     * 该方法的逻辑很简单，那就是看看新得到的这个ServiceInfo对象相对于本地缓存的ServiceInfo对象是否产生了变化，如果产生变化就要发布服务实例变更事件
     */
    public ServiceInfo processServiceInfo(ServiceInfo serviceInfo) {
        
        //得到ServiceInfo的key
        String serviceKey = serviceInfo.getKey();
        if (serviceKey == null) {
            return null;
        }
        
        
        //从map中得到客户端缓存的旧的ServiceInfo对象
        ServiceInfo oldService = serviceInfoMap.get(serviceInfo.getKey());
        
        //走到这里就要先更新缓存中的ServiceInfo对象
        serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);
        
        //判断新的ServiceInfo对象相对于旧的是否发生了变化
        boolean changed = isChangedServiceInfo(oldService, serviceInfo);
        //这里是设置一下新的ServiceInfo对象中的json串，后面将ServiceInfo对象写到本地文件中时要用到
        if (StringUtils.isBlank(serviceInfo.getJsonFromServer())) {
            serviceInfo.setJsonFromServer(JacksonUtils.toJson(serviceInfo));
        }
        
        
        //判断服务实例是否发生变化
        if (changed) {
            NAMING_LOGGER.info("current ips:({}) service: {} -> {}", serviceInfo.ipCount(), serviceInfo.getKey(),
                    JacksonUtils.toJson(serviceInfo.getHosts()));

            
            //在这里创建服务实例变更事件，其实就是发布服务实例变更事件
            InstancesChangeEvent instancesChangeEvent = new InstancesChangeEvent(serviceInfo.getName(), serviceInfo.getGroupName(), serviceInfo.getClusters(), serviceInfo.getHosts());

            //调用map中对应监听器的方法
            
            //得到对应的服务信息，也就是说，是这个服务下的服务实例发生了变更
            String key = ServiceInfo.getKey(NamingUtils.getGroupedName(serviceInfo.getName(), serviceInfo.getGroupName(), serviceInfo.getClusters());
            //根据key得到对应的value，value是一个集合，里面存放了所有监听器
            ConcurrentHashSet<EventListener> eventListeners = listenerMap.get(key);

            //调用监听器中的方法
            //遍历集合
            for (final EventListener listener : eventListeners) {

                //下面就是得到监听器自己的执行器的方法，然后执行监听器对象的onEvent的方法
                
                //判断监听器是不是AbstractEventListener类型的，因为AbstractEventListener类中定义了一个getExecutor()方法，这个方法可以由用户自己实现
                //也就是用户自己定义一个执行器，假如用户实现了这个方法，那么监听器的回调方法就可以由用户定义的执行器异步执行了，否则就由调用当前onEvent方法的线程执行监听器的回调方法
                if (listener instanceof AbstractEventListener && ((AbstractEventListener) listener).getExecutor() != null) {
                    ((AbstractEventListener) listener).getExecutor().execute(() -> listener.onEvent(namingEvent));
                } else {
                    //这里就是用户没有在监听器中定义执行器的逻辑，直接由调用当前onEvent方法的线程执行监听器的回调方法
                    listener.onEvent(namingEvent);
                }
            }
        

            
            //如果发生了变化，就把最新的ServiceInfo写入到本地文件中
            DiskCache.write(serviceInfo, cacheDir);
        }
        
        return serviceInfo;
    }


    //既然监听器的map定义在本类中了，那么本类当然还要定义向map中添加监听器对象的方法，还要定义移除监听器对象的方法
    //这些方法暂时就不展示了


    //其余内容省略
    
}
```

在上面的代码块中，大家可以从重构之后的 processServiceInfo 方法中看到，**客户端一旦检测到服务实例发生变更了，就会创建一个 InstancesChangeEvent 服务实例变更事件，然后从 listenerMap 中得到对应的监听器集合，执行监听器中的方法**。这个逻辑可以说很完美了，几乎没什么瑕疵，要说有什么瑕疵，那就是我把它们定义在了 ServiceInfoHolder 类中了。ServiceInfoHolder 本来是服务实例信息缓存器，但现在我定义了很多和监听器相关的操作和方法，这实际会让 ServiceInfoHolder 组建的职责显得杂乱一些。**最好的方式就是我引入一个新的组件，这个组件只和服务实例变更事件监听器相关，然后我把 ServiceInfoHolder 类中新增添的内容都定义在这个新组件中，只要能让 ServiceInfoHolder 组件及时得到新组建就行了**。这样一来，**就可以在 ServiceInfoHolder 的 processServiceInfo 方法中判断服务实例发生变更了，创建了服务实例变更事件之后直接把事件发布给新引入的监听器组件，剩下的操作都让新引入的监听器组件完成即可**。光用文字描述确实不够直观，接下来我就为大家先引入新的监听器组件，**也就是 InstancesChangeNotifier 类，这个类的对象就是服务实例变更通知器，专门用来在服务实例变更事件发布之后，执行对应监听器中的方法的**。具体实现请看下面代码块。

```
package com.cqfy.nacos.client.naming.event;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/24
 * @方法描述：这个类的对象就是一个服务实例更新通知器，当服务端的服务实例发生变化时，如果客户端订阅了服务端的服务实例，那么服务端的服务实例一旦发生变化就会通知客户端
 * 客户端在感知到服务实例发生变化之后，就会通过NotifyCenter发布InstancesChangeEvent事件，InstancesChangeNotifier观察器观察到事件后，就会执行内部的回调方法
 */
public class InstancesChangeNotifier extends Subscriber<InstancesChangeEvent> {

    //通知事件唯一标识，这个唯一标识是从NacosNamingService中传递过来的
    //其实大家就可以把这个eventScope看作是和NacosNamingService绑定在一起的
    //一个NacosNamingService对应了一个eventScope，假如一个服务器中存在多个NacosNamingService，凭借这个标识就可以分隔各自的服务实例变更事件
    private final String eventScope;

    //这个map中存放的就是真正的事件监听器，也就是用户定义的事件监听器
    //其中key就是坚挺的具体服务的名称，value就是对应的监听器集合，当某个服务下的服务实例信息发生变更，客户端知道后就会执行用户自己定义的监听器中的方法
    private final Map<String, ConcurrentHashSet<EventListener>> listenerMap = new ConcurrentHashMap<>();

    //构造方法
    public InstancesChangeNotifier(String eventScope) {
        this.eventScope = eventScope;
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/24
     * @方法描述：注册监听器到服务实例更新通知器中
     */
    public void registerListener(String groupName, String serviceName, String clusters, EventListener listener) {
        //根据监听器坚挺的服务信息生成key
        String key = ServiceInfo.getKey(NamingUtils.getGroupedName(serviceName, groupName), clusters);
        //根据key从listenerMap中得到对应的value，这里的value是一个set集合，意味着程序中可能有多个监听器都监听同一事件
        ConcurrentHashSet<EventListener> eventListeners = listenerMap.computeIfAbsent(key, keyInner -> new ConcurrentHashSet<>());
        //把用户定义的监听器放到集合中
        eventListeners.add(listener);
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/24
     * @方法描述：取消监听器的方法
     */
    public void deregisterListener(String groupName, String serviceName, String clusters, EventListener listener) {
        String key = ServiceInfo.getKey(NamingUtils.getGroupedName(serviceName, groupName), clusters);
        ConcurrentHashSet<EventListener> eventListeners = listenerMap.get(key);
        if (eventListeners == null) {
            return;
        }
        eventListeners.remove(listener);
        if (CollectionUtils.isEmpty(eventListeners)) {
            listenerMap.remove(key);
        }
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/24
     * @方法描述：根据服务信息判断这个服务是否被监听了，也就是说是否有监听器监听了这个服务下服务实例的变化
     */
    public boolean isSubscribed(String groupName, String serviceName, String clusters) {
        String key = ServiceInfo.getKey(NamingUtils.getGroupedName(serviceName, groupName), clusters);
        ConcurrentHashSet<EventListener> eventListeners = listenerMap.get(key);
        return CollectionUtils.isNotEmpty(eventListeners);
    }


    //得到所有被监听的ServiceInfo的信息
    public List<ServiceInfo> getSubscribeServices() {
        List<ServiceInfo> serviceInfos = new ArrayList<>();
        for (String key : listenerMap.keySet()) {
            serviceInfos.add(ServiceInfo.fromKey(key));
        }
        return serviceInfos;
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/24
     * @方法描述：这个方法是本类中最核心的方法，当InstancesChangeEvent事件被NotifyCenter发布后，该方法就会被调用
     */
    @Override
    public void onEvent(InstancesChangeEvent event) {
        //从事件中得到对应的服务信息，也就是说，是这个服务下的服务实例发生了变更
        String key = ServiceInfo.getKey(NamingUtils.getGroupedName(event.getServiceName(), event.getGroupName()), event.getClusters());
        //根据key得到对应的value，value是一个集合，里面存放了所有监听器
        ConcurrentHashSet<EventListener> eventListeners = listenerMap.get(key);
        if (CollectionUtils.isEmpty(eventListeners)) {
            return;
        }
        //遍历集合
        for (final EventListener listener : eventListeners) {
           
            //判断监听器是不是AbstractEventListener类型的，因为AbstractEventListener类中定义了一个getExecutor()方法，这个方法可以由用户自己实现
            //也就是用户自己定义一个执行器，假如用户实现了这个方法，那么监听器的回调方法就可以由用户定义的执行器异步执行了，否则就由调用当前onEvent方法的线程执行监听器的回调方法
            if (listener instanceof AbstractEventListener && ((AbstractEventListener) listener).getExecutor() != null) {
                ((AbstractEventListener) listener).getExecutor().execute(() -> listener.onEvent(namingEvent));
            } else {
                //这里就是用户没有在监听器中定义执行器的逻辑，直接由调用当前onEvent方法的线程执行监听器的回调方法
                listener.onEvent(namingEvent);
            }
        }
    }

  

    //得到该订阅者订阅的事件类型，InstancesChangeNotifier继承了Subscriber抽象类，所以是一个订阅者
    @Override
    public Class<? extends Event> subscribeType() {
        return InstancesChangeEvent.class;
    }

    //判断事件中的标识符和当前通知器持有的eventScope是否一致
    @Override
    public boolean scopeMatches(InstancesChangeEvent event) {
        return this.eventScope.equals(event.scope());
    }
}
```

在上面的代码块中可以看到，我只不过是把定义在 ServiceInfoHolder 中的操作搬运到 InstancesChangeNotifier 类中了，核心操作在 InstancesChangeNotifier 类的 onEvent 方法中，然后增加了几个向 listenerMap 中添加监听器对象和移除监听器对象的方法，这都是已经讲过的内容，我就不再重复讲解了。当然，细心的朋友可能已经注意到了，**这个 InstancesChangeNotifier 类还继承了 Subscriber 类，并且在 InstancesChangeNotifier 类中有一个 subscribeType 方法，表示该通知器定于了哪种类型的事件，该方法返回的是服务实例变更事件，这就意味着我刚定义的这个 InstancesChangeNotifier 组件只关心服务实例变更事件**。大家应该也意识到了，**这个 InstancesChangeNotifier 服务实例变更通知器实际上是一个订阅器，这又是怎么回事呢？Subscriber 究竟是什么呢**？**用户怎么把监听器对象添加到 InstancesChangeNotifier 中呢？也就是说，InstancesChangeNotifier 对象的 registerListener 方法什么时候被调用呢？**还有，**现在我们引入了 InstancesChangeNotifier 组件，那么 ServiceInfoHolder 怎么得到这个组件呢**？也就是说，**InstancesChangeNotifier 对象的 onEvent 方法什么时候被调用呢？**只有得到这个组件，ServiceInfoHolder 对象才能在它的 processServiceInfo 方法中把创建好的 InstancesChangeEvent 服务实例变更事件交给 InstancesChangeNotifier 服务实例变更通知器的 onEvent 方法使用。别急，接下来就让我为大家详细剖析这几个问题。

## 引入 DefaultPublisher 事件发布器

**首先我们来看一看这个 Subscriber 类究竟是干什么用的**。这就要从另一个问题说起了，请大家想一想，目前我们只是为注册中心的客户端定义了一个 InstancesChangeEvent 服务实例变更事件，但这并不意味着在整个 nacos 框架中只有这一个事件，实际上还有很多重要事件可以被发布。比如：客户端变更事件，服务实例注册事件，服务实例注销事件，集群成员变更事件，客户端连接建立事件，客户端连接注销事件等等，当然，这些都是 nacos 服务端会发布的事件。虽然现在我们还用不到这些事件，但这些事件的存在足以使我们明白一个重要的逻辑：**那就是我们完全可以为这么多事件都定义不同的监听器对象**。

比如说服务端发现有一个客户端连接断开了，就会发布一个客户端连接注销事件，而为该事件创建的监听器就可以执行相应的操作，比如从服务器清除该客户端的相关信息；如果服务端发现客户端注册了新的服务实例，就会发布一个服务实例注册事件，同时还会发布一个客户端变更事件，服务实例注册事件的监听器就会执行一个非常重要的操作，那就是把最新的服务实例信息主动推送给注册了该服务实例的客户端；而客户端变更事件的监听器就会把新增加的服务实例传输给集群中的其他节点。

还有很多这样的例子，我就不细说了，总之通过刚才的讲解大家应该能意识到，**在整个 nacos 框架中存在各种各样的事件，各种各样的事件都有对应的监听器**。而我们刚才只定义了一个 InstancesChangeNotifier 服务实例变更通知器，这个通知器中存放的都是服务实例变更事件对应的监听器；既然框架中有各种各样的事件，那肯定就会有什么客户端变更事件通知器，或者是什么客户端连接事件通知器等等，这些通知器会订阅相应的事件，在程序发布事件之后，通知器就会执行相对应的方法，处理事件。所以，我们又可以把这些通知器称为事件订阅者，刚才大家看到我新引入的 InstancesChangeNotifier 组件继承了 Subscriber 类，因此 InstancesChangeNotifier 就是一个订阅者，专门订阅服务实例变更事件，只要服务实例变更事件一发布，InstancesChangeNotifier 服务实例变更通知器就会执行它的 onEvent 方法，然后调用其内部的监听器的方法。接下来，我就为大家展示一下这个 Subscriber 类的具体内容，请看下面代码块。

```
package com.cqfy.nacos.common.notify.listener;


@SuppressWarnings("PMD.AbstractClassShouldStartWithAbstractNamingRule")
public abstract class Subscriber<T extends Event> {

    //订阅者的回调方法
    public abstract void onEvent(T event);


    //订阅者订阅的事件类型
    public abstract Class<? extends Event> subscribeType();

    //执行订阅者onEvent方法的执行器，这里和监听器对象的getExecutor方法的逻辑类似    
    public Executor executor() {
        return null;
    }

    //是否忽略过期事件，后面会讲解这里，现在大家可以暂时忽略这个方法
    public boolean ignoreExpireEvent() {
        return false;
    }

    
}
```

在看过了 Subscriber 类的内容后，现在大家对 InstancesChangeNotifier 这个组件应该有了更深的理解，意识到这个 InstancesChangeNotifier 组件其实就是一个订阅者，订阅了服务实例变更事件。只要程序发布了服务实例变更事件，其内部的 onEvent 方法就会被调用。这个逻辑应该也很清晰了。但是，看到这里，我想大家肯定还是有疑问，首先，用户为服务实例变更事件自定义的监听器对象什么时候添加到这个 InstancesChangeNotifier 中呢？也就是什么时候调用 InstancesChangeNotifier 的 registerListener 方法呢？第二个问题就是 InstancesChangeNotifier 的 onEvent 方法什么时候会执行呢？第二个问题非常简单，肯定就是在程序发布了服务实例变更事件之后执行啊。但是，这个时候我又想到一个新的问题，**那就是客户端肯定会订阅多个服务实例的信息，假如多个服务实例的信息先后发生变更了，这就意味着客户端要发布多个服务实例变更事件，如果 InstancesChangeNotifier 订阅者没有及时消费这些服务实例变更事件，岂不是就会丢失某些信息，也许一些重要的操作就无法在监听器中执行了**。那这个问题该怎么解决呢？其实也很简单，**只需要定义一个事件队列，把客户端发布的事件都存放到事件队列中，反正每一个服务实例变更事件中都封装着最新服务实例的信息，这样一来 InstancesChangeNotifier 订阅者只需要从队列中取出每一个事件，然后根据事件中的服务实例信息从自己的 listenerMap 中找到对应的监听器集合，再依次执行集合中每一个监听器对象的方法就行了**。这样一来，程序发布的事件肯定就不会丢失了，只需要被及时消费就行，这个逻辑应该也不难理解。

为了实现这个功能，我又给程序引入了一个新的组件，**那就是 DefaultPublisher 类，我把它称为事件发布器，我在这个类中定义了一个事件队列，并且明确了这个事件发布器发布的事件，比如我只让这个事件发布器发布服务实例变更事件，这样一来，我就可以在这个类中再定义一个订阅者集合，并且只把订阅了服务实例变更事件的订阅者放到集合中，只要事件发布器一发布服务实例变更时间，订阅者集合中每一个订阅者的 onEvent 方法就会被调用**。这个 DefaultPublisher 事件发布器的具体实现如下，请看下面代码块。

```
package com.cqfy.nacos.common.notify;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/25
 * @方法描述：默认的事件发布器，这个事件发布器只处理单一事件，也就是只能处理一种事件
 */
public class DefaultPublisher extends Thread implements EventPublisher {


     protected static final Logger LOGGER = LoggerFactory.getLogger(NotifyCenter.class);

    //这个事件发布器继承了一个线程，实际上它就是一个线程，所以要弄一个初始化状态，线程一旦启动，就把这个标志设置为true
    //代表线程已经启动了，并且只能启动一次
    private volatile boolean initialized = false;

    //线程是否停止工作
    private volatile boolean shutdown = false;

    //当前事件发布器关注的事件
    private Class<? extends Event> eventType;

    //存放订阅者的集合
    protected final ConcurrentHashSet<Subscriber> subscribers = new ConcurrentHashSet<>();

    //队列最大容量
    private int queueMaxSize = -1;

    //存放事件的队列
    private BlockingQueue<Event> queue;

    //被处理过的最新事件的序号
    protected volatile Long lastEventSequence = -1L;

    //原子更新器，用来更新队列中最后一个时间序号
    private static final AtomicReferenceFieldUpdater<DefaultPublisher, Long> UPDATER = AtomicReferenceFieldUpdater
            .newUpdater(DefaultPublisher.class, Long.class, "lastEventSequence");



    //初始化方法
    @Override
    public void init(Class<? extends Event> type, int bufferSize) {
        //设置守护线程
        setDaemon(true);
        //设置线程名称
        setName("nacos.publisher-" + type.getName());
        //设置关注的事件类型
        this.eventType = type;
        //设置队列最大容量
        this.queueMaxSize = bufferSize;
        if (this.queueMaxSize == -1) {
            this.queueMaxSize = ringBufferSize;
        }
        //创建事件队列
        this.queue = new ArrayBlockingQueue<>(this.queueMaxSize);
        //在这里启动了线程
        start();
    }


    //启动线程
    @Override
    public synchronized void start() {
        if (!initialized) {
            super.start();
            initialized = true;
        }
    }



     //当前线程要执行的方法
    @Override
    public void run() {
        //处理事件队列中的事件
        openEventHandler();
    }



     //添加订阅者的方法
    @Override
    public void addSubscriber(Subscriber subscriber) {
        subscribers.add(subscriber);
    }

    //移除订阅者的方法
    @Override
    public void removeSubscriber(Subscriber subscriber) {
        subscribers.remove(subscriber);
    }


    

    //判断是否有订阅者的方法
    private boolean hasSubscriber() {
        return CollectionUtils.isNotEmpty(subscribers);
    }

    

    //处理事件队列中事件的方法
    void openEventHandler() {
        try {
            //这里的设定比较细节，请大家想一想，假如有事件发布了，但是没有订阅者怎么办？那这个事件就直接丢掉吗？
            //直接丢掉显然不合适，但是事件发布了很久，一直没有订阅者，就可以丢掉了，所有这里定义了一个等待时间
            int waitTimes = 60;
            //在循环中判断线程是否停止工作了，然后判断是不是没有订阅者，并且等待时间仍然大于0
            while (!shutdown && !hasSubscriber() && waitTimes > 0) {
                //只要上面三个条件都满足，就让当前线程睡一会，等待订阅者订阅事件
                ThreadUtils.sleep(1000L);
                //如果等待时间减到0了，不管有没有订阅者，都要处理事件队列中的事件了
                waitTimes--;
            }//下面就是处理事件队列中事件的操作
            while (!shutdown) {
                //这里使用阻塞获取事件的方法来获取事件，也就意味着假如现在发布器中有订阅者订阅了事件，但是一直没有事件发布
                //那么当前线程也会阻塞，直到有事件发布
                final Event event = queue.take();
                //处理事件
                receiveEvent(event);
                //更新被处理过的最新事件的序号
                UPDATER.compareAndSet(this, lastEventSequence, Math.max(lastEventSequence, event.sequence()));
            }
        } catch (Throwable ex) {
            LOGGER.error("Event listener exception : ", ex);
        }
    }




     //发布事件的方法，这个方法并不是当前线程自己执行的，而是外部线程调用的
    @Override
    public boolean publish(Event event) {
        //判断线程是否启动
        checkIsStart();
        //把事件放到事件队列中
        boolean success = this.queue.offer(event);
        //添加失败则直接处理事件
        if (!success) {
            LOGGER.warn("Unable to plug in due to interruption, synchronize sending time, event : {}", event);
            //这里直接处理时间的话，就是外部线程在处理事件
            receiveEvent(event);
            return true;
        }
        return true;
    }


    void checkIsStart() {
        if (!initialized) {
            throw new IllegalStateException("Publisher does not start");
        }
    }


    @Override
    public void shutdown() {
        this.shutdown = true;
        this.queue.clear();
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/25
     * @方法描述：本类核心方法，处理事件，遍历订阅者，执行订阅者回调方法
     */
    void receiveEvent(Event event) {
        //得到当前处理事件的序号
        final long currentEventSequence = event.sequence();
        //判断是否没有订阅者，如果仍然没有，那这个事件就被丢弃了
        if (!hasSubscriber()) {
            LOGGER.warn("[NotifyCenter] the {} is lost, because there is no subscriber.", event);
            return;
        }
        //遍历订阅者
        for (Subscriber subscriber : subscribers) {
            //对比通知事件的唯一标识
            if (!subscriber.scopeMatches(event)) {
                continue;
            }
            //根据事件的序号判断一下当前事件是否过期了，如果过期了并且订阅者设置了忽略过期事件，就不处理当前事件了
            //因为序号大的肯定是最新发布的事件啊，要处理就处理最新发布的事件，最新发布的事件已经处理了，就不处理旧的了
            //这里大家可能有点疑惑，为什么都放到队列中了，怎么还会跳过序号小的事件，直接处理序号大的事件呢？
            //这是因为各个事件向队列中存放的时候会出现并发情况，并不是按照事件的生产顺序存放的，可能有多个线程一起向队列中存放事件
            //所以序号小的后放，序号大的先放，也是有可能的。但这里我还要再补充一点，其实在整个nacos框架中，只有MembersChangeEvent事件的观察者才会忽略过期事件，其他观察者都不会忽略过期事件
            //因为MembersChangeEvent是集群成员变更事件，这个可以按照事件序号判断哪个集群成员信息是最新的，或者说观察的事件内容单一性比较强；但是其他观察者观察的事件内容比较复杂，就不能按照事件序号来判断
            //事件内容的新旧了。所以不能忽略过期事件
            if (subscriber.ignoreExpireEvent() && lastEventSequence > currentEventSequence) {
                LOGGER.debug("[NotifyCenter] the {} is unacceptable to this subscriber, because had expire", event.getClass());
                continue;
            }
            //通知订阅者执行回调方法
            notifySubscriber(subscriber, event);
        }
    }

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/25
     * @方法描述：本类核心方法，通知订阅者执行回调方法
     */
    @Override
    public void notifySubscriber(final Subscriber subscriber, final Event event) {
        LOGGER.debug("[NotifyCenter] the {} will received by {}", event, subscriber);
        //创建一个任务，任务逻辑就是执行订阅者的回调方法
        final Runnable job = () -> subscriber.onEvent(event);
        //判断当前订阅者是否自定义了执行器
        final Executor executor = subscriber.executor();
        //如果定义了就使用订阅者自己的执行器执行回调方法
        if (executor != null) {
            executor.execute(job);
        } else {
            try {//没定义就是用当前线程执行回调方法
                job.run();
            } catch (Throwable e) {
                LOGGER.error("Event callback exception: ", e);
            }
        }
    }

}
```

在阅读完了上面的代码块之后，大家可以了解到，实际上这个 DefaultPublisher 事件发布器就是一个线程，事件发布器对象在初始化的时候会启动线程，然后在 run 方法中调用 openEventHandler 方法处理事件队列中的事件，openEventHandler 方法的具体逻辑我都写在注释中了，就不在文章中重复讲解了。除此之外，我们还能看到在 DefaultPublisher 事件发布器中还定义了 addSubscriber 方法，把订阅者添加到时间发布器的集合中。当然，还有 publish 发布事件的方法，以及最终在处理事件时，通知集合中每一个订阅者执行它的 onEvent 方法的 notifySubscriber 方法。现在 DefaultPublisher 事件发布器组件我也为大家实现完毕了。

我知道大家可能觉得思路有些混乱了，所以接下来让我来为大家梳理一下目前程序地执行流程：**如果用户想在服务实例变更之后做一些重要操作，那就要创建一个监听器对象，实现监听器对象的 onEvent 方法；如果这个监听器对象的方法要想被执行，就要接着创建一个 InstancesChangeNotifier 服务实例变更通知器，这个通知器其实就是一个订阅者，专门订阅服务实例变更事件；用户就可以把自己创建的监听器对象存放到这个 InstancesChangeNotifier 订阅者的 listenerMap 成员变量中；这样一来，只要程序发布了服务实例变更事件，InstancesChangeNotifier 订阅者就会执行它的 onEvent 方法，在 onEvent 方法中执行对应服务实例变更监听器的方法。当然，为了保证程序发布的服务实例变更事件不丢失，以至于遗漏了一些重要操作，接下来我们又定义了 DefaultPublisher 事件发布器对象，事件发布器对象只发布服务实例变更事件，然后我们把创建的 InstancesChangeNotifier 订阅者添加到事件发布器的 subscribers 订阅者集合中。这样一来，只要 DefaultPublisher 事件发布器启动，并且发布了 InstancesChangeEvent 事件，就会把该事件放到事件队列中，然后事件发布器会在一个循环中不断处理事件队列中的事件，也就是通知每一个订阅者执行自己的 onEvent 方法**。

**所以，总结下来就是事件发布器发布事件，订阅者执行 onEvent 方法，然后是订阅者内部的监听器执行自己的 onEvent 方法**。到这里，用户定义的监听器的方法终于执行了。当然，逻辑梳理到这里还是有一些疑问没解开，**比如用户定义的监听器对象是在哪里添加到 InstancesChangeNotifier 订阅者对象中的呢？这个问题一直没有解决**；除此之外，还有一个最重要的问题，**那就是程序中存在各种各样的事件，也就可能存在各种各样的订阅者，因为订阅者订阅了某种事件呐，既然存在各种各样的订阅者，就会存在各种各样的事件发布器。当然，这里说得各种各样的事件发布器并不是指存在不同类型的事件发布器，而是存在发布不同事件的事件发布器**。程序发布各种事件的时候，肯定要把事件交给事件发布器来发布，但我可不想各种各样的事件发布器散落在程序各个地方，那样做不仅会使各种各样的事件发布器入侵到某些类中，破坏类的结构，还会使程序显得散乱。这是我不希望看到的，如果能有一个组件把各个事件发布器收集起来就好了，这时候，**就轮到时间通知机制中最重要的一个组件登场了，也就是 NotifyCenter 类**。

## 引入 NotifyCenter 类，完善事件通知机制

那么这个 NotifyCenter 类怎么把各个事件发布器收集起来呢？这个很好办，直接定义一个 map 即可，map 的 key 就是事件类型，value 就是对应的事件发布器。所以，这个 NotifyCenter 类我可以先定义成下面这样，请看下面代码块。

```
package com.cqfy.nacos.common.notify;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/25
 * @方法描述：事件通知中心，这个通知中心是nacos框架中非常核心的一个组件，也是非常精妙的一个设计，这个事件通知中心使用了单例模式，也就是在程序内部，所有事件都会交给这个事件中心来统一发布，这个事件中心还存放了各种发布器，这些事件发布器关注了不同的事件
 * 事件中心发布事件，然后再由具体的事件发布器把事件分发下去
 */
public class NotifyCenter {


    private static final Logger LOGGER = LoggerFactory.getLogger(NotifyCenter.class);



    //事件通知中心的单例
    private static final NotifyCenter INSTANCE = new NotifyCenter();

    //这个就是事件通知中心最核心的成员变量了，专门用来存储事件和对应的发布器的map
    //key是事件名称，value就是对应的发布器，这个map存放的是DefaultPublisher事件发布器
    private final Map<String, EventPublisher> publisherMap = new ConcurrentHashMap<>(16);


}
```

NotifyCenter 事件通知中心定义完毕之后，怎么把事件发布器添加到事件通知中心的 publisherMap 中呢？**这时候就要为这个 NotifyCenter 类定义一个 registerSubscriber 方法，该方法的作用很丰富，它除了把事件发布器添加到 publisherMap 中，还会把订阅者添加到事件发布器中**。具体实现请看下面代码块。

```
package com.cqfy.nacos.common.notify;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/25
 * @方法描述：事件通知中心，这个通知中心是nacos框架中非常核心的一个组件，也是非常精妙的一个设计，这个事件通知中心使用了单例模式，也就是在程序内部，所有事件都会交给这个事件中心来统一发布，这个事件中心还存放了各种发布器，这些事件发布器关注了不同的事件
 * 事件中心发布事件，然后再由具体的事件发布器把事件分发下去
 */
public class NotifyCenter {


    private static final Logger LOGGER = LoggerFactory.getLogger(NotifyCenter.class);



    //事件通知中心的单例
    private static final NotifyCenter INSTANCE = new NotifyCenter();

    //这个就是事件通知中心最核心的成员变量了，专门用来存储事件和对应的发布器的map
    //key是事件名称，value就是对应的发布器，这个map存放的是DefaultPublisher事件发布器
    private final Map<String, EventPublisher> publisherMap = new ConcurrentHashMap<>(16);


    //这个成员变量是给事件发布器使用的，事件工厂创建事件发布器的时候，需要给事件发布器内部的队列定义长度
    //这时候就可以使用这个成员变量来定义。并且这个成员变量是给DefaultPublisher默认事件发布器使用的
    public static int ringBufferSize;

    //事件发布器的类型，这个是要从spi文件中加载的，如果用户没有设置，就是用默认的DefaultPublisher事件发布器
    private static Class<? extends EventPublisher> clazz;

    //事件发布器的工厂，这个工厂专门创建事件发布器
    private static final EventPublisherFactory DEFAULT_PUBLISHER_FACTORY;


    //静态代码块做一些出事的赋值操作，下面代码相对于我提供的第五版本代码，做了一些简化，具体细节还要去看第五版本代码
    static {
        //给ringBufferSize赋值
        String ringBufferSizeProperty = "nacos.core.notify.ring-buffer-size";
        ringBufferSize = Integer.getInteger(ringBufferSizeProperty, 16384);

       //这里创建的就是默认的事件发布者，因为没有定义spi文件
        clazz = DefaultPublisher.class;
        

        //在这里创建了事件发布器工厂，这个工厂就是专门创建事件发布器的
        //cls就是事件发布器关注的类型，buffer就是事件发布器中事件队列的大小
        DEFAULT_PUBLISHER_FACTORY = (cls, buffer) -> {
            try {//先获得一个默认的事件发布器，这里需要注意一下，并不是每注册一个订阅者，就要为这个订阅者者创建一个事件发布器
                //而是每个事件类型，就要定义一个对应的事件发布器。如果多个订阅者都订阅的是服务实例变更事件
                //那么只需要一个发布器即可，这些订阅者会被存放到发布期内部的set集合中
                EventPublisher publisher = clazz.newInstance();
                //事件发布器初始化，在init方法中，事件发布器就会启动了
                publisher.init(cls, buffer);
                return publisher;
            } catch (Throwable ex) {
                LOGGER.error("Service class newInstance has error : ", ex);
                throw new NacosRuntimeException(SERVER_ERROR, ex);
            }
        };
       
        //添加一个JVM钩子函数，当程序关闭的时候，回调这个方法，这里我还是要解释一下，因为事件发布器都继承Thread对象
        //所以每一个时间按发布器都会启动一个线程工作，当程序结束的时候，就会通过这个钩子方法，停止所有事件发布器工作
        //也就是停止了多个线程工作
        ThreadUtils.addShutdownHook(NotifyCenter::shutdown);
    }


    //下面代码相对于我提供的第五版本代码，做了一些简化，具体细节还要去看第五版本代码

    
    //注册订阅者到事件通知中心的方法
    public static void registerSubscriber(final Subscriber consumer) {
        //这里把事件发布器工厂传进去了
        registerSubscriber(consumer, DEFAULT_PUBLISHER_FACTORY);
    }



     //注册订阅者到事件通知中心的方法
    public static void registerSubscriber(final Subscriber consumer, final EventPublisherFactory factory) {
       
        //获得订阅者订阅的事件
        final Class<? extends Event> subscribeType = consumer.subscribeType();
        
        //添加到publisherMap中
        addSubscriber(consumer, subscribeType, factory);
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/25
     * @方法描述：把订阅者添加到通知中心的方法
     */
    private static void addSubscriber(final Subscriber consumer, Class<? extends Event> subscribeType,
                                      EventPublisherFactory factory) {

        //根据订阅者订阅的事件类型获得一个topic，其实就是订阅事件的字符串
        final String topic = ClassUtils.getCanonicalName(subscribeType);
        
        synchronized (NotifyCenter.class) {
            //判断publisherMap中是否存在了对应的事件发布器，如果不存在，就以topic为key，事件工厂创建的事件发布器为publisherMap的value
            //把键值对放到publisherMap中，到这里大家可以明白了，所有的订阅者其实都会存放到事件发布器中，而事件发布器又会存放到事件通知中心的publisherMap中
            //所以时间通知中心一旦发布事件，就可以从publisherMap中获得对应的事件发布器，事件发布器再进一步执行内部存放的订阅者的回调方法即可
            MapUtil.computeIfAbsent(INSTANCE.publisherMap, topic, factory, subscribeType, ringBufferSize);
        }
        
        //得到事件对应的事件发布器
        EventPublisher publisher = INSTANCE.publisherMap.get(topic);
        
        //把订阅者添加到事件发布器中
        publisher.addSubscriber(consumer);
        
    }


    //这个是根据事件类型创建对应的事件发布器的方法
    public static EventPublisher registerToPublisher(final Class<? extends Event> eventType, final int queueMaxSize) {
        return registerToPublisher(eventType, DEFAULT_PUBLISHER_FACTORY, queueMaxSize);
    }


    //这个是根据事件类型创建对应的事件发布器的方法，并且把事件发布器添加到map中
    //注意，这个方法只会创建事件发布器，和订阅者没有关系
    public static EventPublisher registerToPublisher(final Class<? extends Event> eventType,
                                                     final EventPublisherFactory factory, final int queueMaxSize) {

        
        final String topic = ClassUtils.getCanonicalName(eventType);
        
        synchronized (NotifyCenter.class) {
            MapUtil.computeIfAbsent(INSTANCE.publisherMap, topic, factory, eventType, queueMaxSize);
        }
        
        return INSTANCE.publisherMap.get(topic);
    }

    
}
```

在看过上面代码块的 registerSubscriber 方法和 addSubscriber 方法的逻辑之后，现在大家应该都明白了事件发布器对象是怎么创建的，也明白了事件发布器对象是怎么添加到 NotifyCenter 事件通知中心的 publisherMap 成员变量中的；当然，订阅者添加到对应的事件发布器中的逻辑也展示得很清楚了。这些操作逻辑明白了之后，接下来我会为 NotifyCenter 再引入一个方法，这个方法会将之前我们讲解过的所有内容串联起来，那就是 publishEvent 方法。请看下面代码块。

```
package com.cqfy.nacos.common.notify;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/25
 * @方法描述：事件通知中心，这个通知中心是nacos框架中非常核心的一个组件，也是非常精妙的一个设计，这个事件通知中心使用了单例模式，也就是在程序内部，所有事件都会交给这个事件中心来统一发布，这个事件中心还存放了各种发布器，这些事件发布器关注了不同的事件
 * 事件中心发布事件，然后再由具体的事件发布器把事件分发下去
 */
public class NotifyCenter {


    private static final Logger LOGGER = LoggerFactory.getLogger(NotifyCenter.class);



    //事件通知中心的单例
    private static final NotifyCenter INSTANCE = new NotifyCenter();

    //这个就是事件通知中心最核心的成员变量了，专门用来存储事件和对应的发布器的map
    //key是事件名称，value就是对应的发布器，这个map存放的是DefaultPublisher事件发布器
    private final Map<String, EventPublisher> publisherMap = new ConcurrentHashMap<>(16);


    //这个成员变量是给事件发布器使用的，事件工厂创建事件发布器的时候，需要给事件发布器内部的队列定义长度
    //这时候就可以使用这个成员变量来定义。并且这个成员变量是给DefaultPublisher默认事件发布器使用的
    public static int ringBufferSize;

    //事件发布器的类型，这个是要从spi文件中加载的，如果用户没有设置，就是用默认的DefaultPublisher事件发布器
    private static Class<? extends EventPublisher> clazz;

    //事件发布器的工厂，这个工厂专门创建事件发布器
    private static final EventPublisherFactory DEFAULT_PUBLISHER_FACTORY;


    //静态代码块做一些出事的赋值操作，下面代码相对于我提供的第五版本代码，做了一些简化，具体细节还要去看第五版本代码
    static {
        //给ringBufferSize赋值
        String ringBufferSizeProperty = "nacos.core.notify.ring-buffer-size";
        ringBufferSize = Integer.getInteger(ringBufferSizeProperty, 16384);

       //这里创建的就是默认的事件发布者，因为没有定义spi文件
        clazz = DefaultPublisher.class;
        

        //在这里创建了事件发布器工厂，这个工厂就是专门创建事件发布器的
        //cls就是事件发布器关注的类型，buffer就是事件发布器中事件队列的大小
        DEFAULT_PUBLISHER_FACTORY = (cls, buffer) -> {
            try {//先获得一个默认的事件发布器，这里需要注意一下，并不是每注册一个订阅者，就要为这个订阅者者创建一个事件发布器
                //而是每个事件类型，就要定义一个对应的事件发布器。如果多个订阅者都订阅的是服务实例变更事件
                //那么只需要一个发布器即可，这些订阅者会被存放到发布期内部的set集合中
                EventPublisher publisher = clazz.newInstance();
                //事件发布器初始化，在init方法中，事件发布器就会启动了
                publisher.init(cls, buffer);
                return publisher;
            } catch (Throwable ex) {
                LOGGER.error("Service class newInstance has error : ", ex);
                throw new NacosRuntimeException(SERVER_ERROR, ex);
            }
        };
       
        //添加一个JVM钩子函数，当程序关闭的时候，回调这个方法，这里我还是要解释一下，因为事件发布器都继承Thread对象
        //所以每一个时间按发布器都会启动一个线程工作，当程序结束的时候，就会通过这个钩子方法，停止所有事件发布器工作
        //也就是停止了多个线程工作
        ThreadUtils.addShutdownHook(NotifyCenter::shutdown);
    }


    //下面代码相对于我提供的第五版本代码，做了一些简化，具体细节还要去看第五版本代码

    
    //注册订阅者到事件通知中心的方法
    public static void registerSubscriber(final Subscriber consumer) {
        //这里把事件发布器工厂传进去了
        registerSubscriber(consumer, DEFAULT_PUBLISHER_FACTORY);
    }



     //注册订阅者到事件通知中心的方法
    public static void registerSubscriber(final Subscriber consumer, final EventPublisherFactory factory) {
       
        //获得订阅者订阅的事件
        final Class<? extends Event> subscribeType = consumer.subscribeType();
        
        //添加到publisherMap中
        addSubscriber(consumer, subscribeType, factory);
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/25
     * @方法描述：把订阅者添加到通知中心的方法
     */
    private static void addSubscriber(final Subscriber consumer, Class<? extends Event> subscribeType,
                                      EventPublisherFactory factory) {

        //根据订阅者订阅的事件类型获得一个topic，其实就是订阅事件的字符串
        final String topic = ClassUtils.getCanonicalName(subscribeType);
        
        synchronized (NotifyCenter.class) {
            //判断publisherMap中是否存在了对应的事件发布器，如果不存在，就以topic为key，事件工厂创建的事件发布器为publisherMap的value
            //把键值对放到publisherMap中，到这里大家可以明白了，所有的订阅者其实都会存放到事件发布器中，而事件发布器又会存放到事件通知中心的publisherMap中
            //所以时间通知中心一旦发布事件，就可以从publisherMap中获得对应的事件发布器，事件发布器再进一步执行内部存放的订阅者的回调方法即可
            MapUtil.computeIfAbsent(INSTANCE.publisherMap, topic, factory, subscribeType, ringBufferSize);
        }
        
        //得到事件对应的事件发布器
        EventPublisher publisher = INSTANCE.publisherMap.get(topic);
        
        //把订阅者添加到事件发布器中
        publisher.addSubscriber(consumer);
        
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/25
     * @方法描述：事件通知中心发布事件的方法
     */
    public static boolean publishEvent(final Event event) {
        try {
            //发布事件类型
            return publishEvent(event.getClass(), event);
        } catch (Throwable ex) {
            LOGGER.error("There was an exception to the message publishing : ", ex);
            return false;
        }
    }



     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/25
     * @方法描述：事件通知中心发布事件的方法
     */
    private static boolean publishEvent(final Class<? extends Event> eventType, final Event event) {
       
        //得到事件的topic名称
        final String topic = ClassUtils.getCanonicalName(eventType);
       
        //从publisherMap中得到对应的value
        EventPublisher publisher = INSTANCE.publisherMap.get(topic);
        
        if (publisher != null) {
            //发布事件
            return publisher.publish(event);
        }
        
        LOGGER.warn("There are no [{}] publishers for this event, please register", topic);
        return false;
    }
    
}
```

**从上面代码块的 publishEvent 方法可以看到，该方法为静态方法，并且只要事件通知中心发布了事件，就会根据事件类型从 publisherMap 中得到对应的 事件发布器，然后事件发布器就可以发布事件了。事件发布器一旦发布事件，事件发布器内部的订阅者就会处理事件，执行自己的 onEvent 方法，而订阅者的 onEvent 方法一旦执行，那么订阅者内部对应的监听器对象就会执行自己的 onEvent 方法**。到此用户定义的监听器方法就终于执行了。如果这些逻辑大家都清楚了，接下来只要客户端在 ServiceInfoHolder 对象的 processServiceInfo 方法中发现服务实例发生变更了，直接调用 NotifyCenter 事件通知中心的 publishEvent 静态方法，发布 InstancesChangeEvent 事件，那么用户定义的监听器方法就可以执行了。所以，ServiceInfoHolder 类最终重构之后的 processServiceInfo 方法可以写成下面这样。请看下面代码块。

```
package com.cqfy.nacos.client.naming.cache;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/24
 * @方法描述：该类的对象就是客户端的服务信息保存器，从服务端订阅的所有服务实例的信息都会存放在这个类的对象中
 */
public class ServiceInfoHolder implements Closeable {

    //其余内容省略


    //这个map中缓存了从服务端获得的服务实例的信息，把服务实例缓存在内存中，同时也会存储在本地硬盘上
    //string就是服务名称，ServiceInfo封装着该服务下所有服务实例信息
    private final ConcurrentMap<String, ServiceInfo> serviceInfoMap;


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/24
     * @方法描述：这是本类中最重要的方法，就是处理ServiceInfo对象的方法，这个ServiceInfo对象一般都是从服务端返回的
     * 该方法的逻辑很简单，那就是看看新得到的这个ServiceInfo对象相对于本地缓存的ServiceInfo对象是否产生了变化，如果产生变化就要发布服务实例变更事件
     */
    public ServiceInfo processServiceInfo(ServiceInfo serviceInfo) {
        
        //得到ServiceInfo的key
        String serviceKey = serviceInfo.getKey();
        if (serviceKey == null) {
            return null;
        }
        
        
        //从map中得到客户端缓存的旧的ServiceInfo对象
        ServiceInfo oldService = serviceInfoMap.get(serviceInfo.getKey());
        
        //走到这里就要先更新缓存中的ServiceInfo对象
        serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);
        
        //判断新的ServiceInfo对象相对于旧的是否发生了变化
        boolean changed = isChangedServiceInfo(oldService, serviceInfo);
        //这里是设置一下新的ServiceInfo对象中的json串，后面将ServiceInfo对象写到本地文件中时要用到
        if (StringUtils.isBlank(serviceInfo.getJsonFromServer())) {
            serviceInfo.setJsonFromServer(JacksonUtils.toJson(serviceInfo));
        }
        
        
        //判断服务实例是否发生变化
        if (changed) {
            NAMING_LOGGER.info("current ips:({}) service: {} -> {}", serviceInfo.ipCount(), serviceInfo.getKey(),
                    JacksonUtils.toJson(serviceInfo.getHosts()));
            
            //因为ServiceInfo更新了，所以要发送要给服务实例更新事件，通知订阅了该服务的监听器执行回调方法，注意，这里把notifierEventScope标识符交给InstancesChangeEvent事件对象了
            //这时候，InstancesChangeEvent事件对象持有的标识符就和InstancesChangeNotifier对象中持有的一致了
            NotifyCenter.publishEvent(new InstancesChangeEvent(notifierEventScope, serviceInfo.getName(), serviceInfo.getGroupName(), serviceInfo.getClusters(), serviceInfo.getHosts()));
            
            //如果发生了变化，就把最新的ServiceInfo写入到本地文件中
            DiskCache.write(serviceInfo, cacheDir);
        }
        
        return serviceInfo;
    }



    //其余内容省略
    
}
```

到此为止本章的内容就全部结束了，事件发布器终于都收集到一起了，以后只要程序中哪里需要发布事件，直接调用 NotifyCenter 的 publishEvent 方法即可。当然，这样其实也带来一个问题，**那就是可能在很多类中，要主动调用 NotifyCenter 的 registerSubscriber 方法，在 registerSubscriber 方法内部创建订阅者对应的事件发布器，然后把订阅者添加到事件发布器中，最后把事件发布器添加到 NotifyCenter 的 publisherMap 成员变量中**。好了，这些问题就不多说了，没有十全十美的程序，其实讲到现在，还遗留着几个小疑问没有解决：**那就是用户定义的监听器对象究竟怎么添加到 InstancesChangeNotifier 服务实例变更通知器中呢？还有一个就是 InstancesChangeNotifier 这个订阅者怎么添加到事件发布器中呢**？其实还有最重要的，那就是 **InstancesChangeNotifier 订阅者在哪里创建呢**？请大家带着这些疑问，看看我最后重构完的程序吧。

## 重构 NacosNamingService

主要重构其实都在 NacosNamingService 类中，请看下面代码块。

```
package com.cqfy.nacos.client.naming;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/10
 * @方法描述：这个类是注册中心客户端的核心类，可以说是注册服务实例，订阅服务实例等等操作的入口类，很多重要的操作都是由这个类的对象发起的
 * 但在第一版本代码中，该类只提供了注册服务实例到注册中心的方法
 */
@SuppressWarnings("PMD.ServiceOrDaoClassShouldEndWithImplRule")
public class NacosNamingService implements NamingService {


    private String namespace;

    private NamingClientProxy clientProxy;

    private ServiceInfoHolder serviceInfoHolder;

    //通知事件的唯一标识，如果一个进程中有好几个NacosNamingService对象，注册了不同的服务实例，订阅了不同的服务实例
    //但是这几个NacosNamingService对象共用同一个NotifyCenter事件通知中心，各个NacosNamingService对象关心的事件相同
    //但是事件内容并不相同，比如一个NacosNamingService订阅了一些服务实例信息，关注服务实例变更事件
    //另一个NacosNamingService也订阅了不同的服务实例信息，关注服务实例变更事件，当事件通知中心发布服务实例变更事件时
    //就应该首先使用这个notifierEventScope成员变量区分发布的事件是哪个NacosNamingService的
    private String notifierEventScope;

    //服务实例更新通知器
    private InstancesChangeNotifier changeNotifier;


    //构造方法，该构造方法通过Properties文件创建NacosNamingService对象，反射调用的就是这个构造方法
    public NacosNamingService(Properties properties) throws NacosException {
        init(properties);
    }


    //初始化NacosNamingService对象的方法，在该方法对NacosNamingService内部要使用的一些组件进行了创建和初始化
    private void init(Properties properties) throws NacosException {
        
        //异步加载Jackson组件
        PreInitUtils.asyncPreLoadCostComponent();
        
        
        final NacosClientProperties nacosClientProperties = NacosClientProperties.PROTOTYPE.derive(properties);
       
        //给当前NacosNamingService对象的命名空间赋值
        this.namespace = InitUtils.initNamespaceForNaming(nacosClientProperties);
       
        //初始化序列化方式
        InitUtils.initSerialization();
       
        //生成通知事件唯一标识
        this.notifierEventScope = UUID.randomUUID().toString();
        
        //创建服务实例更新通知器
        this.changeNotifier = new InstancesChangeNotifier(this.notifierEventScope);
        
        //给通知中心注册一个事件发布者，这个事件发布者专门发布服务实例更新事件，而刚才创建的changeNotifier对象专门观察服务实例更新事件
        NotifyCenter.registerToPublisher(InstancesChangeEvent.class, 16384);
        
        //把服务实例更新通知器注册到通知中心，其实这个服务实例更新通知器就是一个观察者
        //这两个操作执行下来，其实大家就可以想到了，只要注册中心发布了InstancesChangeEvent事件，注册到注册中心的changeNotifier就会执行对应的回调方法
        NotifyCenter.registerSubscriber(changeNotifier);
       
        //创建服务实例信息保存器
        this.serviceInfoHolder = new ServiceInfoHolder(namespace, this.notifierEventScope, nacosClientProperties);
        
        //创建代理客户端对象
        this.clientProxy = new NamingClientProxyDelegate(this.namespace,serviceInfoHolder,nacosClientProperties,changeNotifier);
    }

    //其他内容省略
}
```

可以看到，在 NacosNamingService 的 init 方法中，创建了 changeNotifier 服务实例更新通知器，然后调用了 NotifyCenter 的 registerToPublisher 方法为 InstancesChangeEvent 服务实例变更事件创建了事件通知器，并且把事件通知器添加到 NotifyCenter 的 map 成员变量中了，紧接着又执行了 NotifyCenter 的 registerSubscriber 方法，把服务实例变更事件订阅器添加到事件发布器的 set 集合中了。这时候，就已经完成了 InstancesChangeNotifier 对象的创建。那什么时候把用户自己定义的监听器存放到 InstancesChangeNotifier 中呢？请看下面代码块。

```
package com.cqfy.nacos.client.naming;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/10
 * @方法描述：这个类是注册中心客户端的核心类，可以说是注册服务实例，订阅服务实例等等操作的入口类，很多重要的操作都是由这个类的对象发起的
 * 但在第一版本代码中，该类只提供了注册服务实例到注册中心的方法
 */
@SuppressWarnings("PMD.ServiceOrDaoClassShouldEndWithImplRule")
public class NacosNamingService implements NamingService {


    private String namespace;

    private NamingClientProxy clientProxy;

    private ServiceInfoHolder serviceInfoHolder;

    //通知事件的唯一标识，如果一个进程中有好几个NacosNamingService对象，注册了不同的服务实例，订阅了不同的服务实例
    //但是这几个NacosNamingService对象共用同一个NotifyCenter事件通知中心，各个NacosNamingService对象关心的事件相同
    //但是事件内容并不相同，比如一个NacosNamingService订阅了一些服务实例信息，关注服务实例变更事件
    //另一个NacosNamingService也订阅了不同的服务实例信息，关注服务实例变更事件，当事件通知中心发布服务实例变更事件时
    //就应该首先使用这个notifierEventScope成员变量区分发布的事件是哪个NacosNamingService的
    private String notifierEventScope;

    //服务实例更新通知器
    private InstancesChangeNotifier changeNotifier;


    //构造方法，该构造方法通过Properties文件创建NacosNamingService对象，反射调用的就是这个构造方法
    public NacosNamingService(Properties properties) throws NacosException {
        init(properties);
    }


    //初始化NacosNamingService对象的方法，在该方法对NacosNamingService内部要使用的一些组件进行了创建和初始化
    private void init(Properties properties) throws NacosException {
        
        //异步加载Jackson组件
        PreInitUtils.asyncPreLoadCostComponent();
        
        
        final NacosClientProperties nacosClientProperties = NacosClientProperties.PROTOTYPE.derive(properties);
       
        //给当前NacosNamingService对象的命名空间赋值
        this.namespace = InitUtils.initNamespaceForNaming(nacosClientProperties);
       
        //初始化序列化方式
        InitUtils.initSerialization();
       
        //生成通知事件唯一标识
        this.notifierEventScope = UUID.randomUUID().toString();
        
        //创建服务实例更新通知器
        this.changeNotifier = new InstancesChangeNotifier(this.notifierEventScope);
        
        //给通知中心注册一个事件发布者，这个事件发布者专门发布服务实例更新事件，而刚才创建的changeNotifier对象专门观察服务实例更新事件
        NotifyCenter.registerToPublisher(InstancesChangeEvent.class, 16384);
        
        //把服务实例更新通知器注册到通知中心，其实这个服务实例更新通知器就是一个观察者
        //这两个操作执行下来，其实大家就可以想到了，只要注册中心发布了InstancesChangeEvent事件，注册到注册中心的changeNotifier就会执行对应的回调方法
        NotifyCenter.registerSubscriber(changeNotifier);
       
        //创建服务实例信息保存器
        this.serviceInfoHolder = new ServiceInfoHolder(namespace, this.notifierEventScope, nacosClientProperties);
        
        //创建代理客户端对象
        this.clientProxy = new NamingClientProxyDelegate(this.namespace,serviceInfoHolder,nacosClientProperties,changeNotifier);
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/24
     * @方法描述：这个就是订阅服务信息的方法
     */
    @Override
    public void subscribe(String serviceName, EventListener listener) throws NacosException {
        subscribe(serviceName, new ArrayList<>(), listener);
    }


    @Override
    public void subscribe(String serviceName, List<String> clusters, EventListener listener) throws NacosException {
        subscribe(serviceName, Constants.DEFAULT_GROUP, clusters, listener);
    }


    @Override
    public void subscribe(String serviceName, String groupName, List<String> clusters, EventListener listener)
            throws NacosException {
        if (null == listener) {
            return;
        }
        String clusterString = StringUtils.join(clusters, ",");
        //在这里把用户自己定义的监听器，注册到了服务实例更新通知器中，因为服务实例通知更新器专门通知服务实例更新事件
        changeNotifier.registerListener(groupName, serviceName, clusterString, listener);
        clientProxy.subscribe(serviceName, groupName, clusterString);
    }


    

    //其他内容省略
}
```

从上面的代码块中可以看到，在 subscribe 方法中，把用户自己定义的监听器对象添加到了 changeNotifier 这个订阅者中了。从上面代码块可以看出了，subscribe 方法实际上经过重构了，接下来我就展示一个测试类，给大家看看重构之后的客户端如何订阅服务实例，请看下面代码块。

```
package com.cqfy.nacos.example;



public class NamingExample {

    private static final String INSTANCE_SERVICE_NAME = "cqfy.test.3";

    private static final String INSTANCE_IP = "11.11.11.12";

    private static final int INSTANCE_PORT = 8889;

    private static final String INSTANCE_CLUSTER_NAME = "TEST1";

    public static void main(String[] args) throws NacosException, InterruptedException {

        Properties properties = new Properties();
        //在这里设置了要注册到注册中心的服务实例的地址和命名空间
        properties.setProperty("serverAddr", System.getProperty("serverAddr", "localhost"));
        properties.setProperty("namespace", System.getProperty("namespace", "public"));
        //根据配置类创建了一个NamingService对象，在第一版本中，NamingService对象提供了将服务实例注册到注册中心的功能
        NamingService naming = NamingFactory.createNamingService(properties);

        //在这里发起了注册服务实例到注册中心的操作
        //方法中的这几个参数都是用来构建服务实例对象的，也就是Instance对象
        naming.registerInstance(INSTANCE_SERVICE_NAME, INSTANCE_IP, INSTANCE_PORT, INSTANCE_CLUSTER_NAME);

       
        
        //下面是和服务订阅有关的代码
        NacosNamingService namingService = (NacosNamingService)naming;
       
        
        //使用监听器订阅服务实例信息
        Executor executor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),
                runnable -> {
                    Thread thread = new Thread(runnable);
                    thread.setName("test-thread");
                    return thread;
                });

        naming.subscribe(INSTANCE_SERVICE_NAME, new AbstractEventListener() {

            //用户可以自定义一个线程池，异步执行监听器的回调任务，如果没有自定义线程池，那么监听器中的方法就不异步执行了
            @Override
            public Executor getExecutor() {
                return executor;
            }

            @Override
            public void onEvent(Event event) {
                //省略具体的操作了
            }
        });

        Thread.sleep(100000);
    }
}
```

现在大家也都知道了，**原来在客户端订阅服务实例信息时，就可以自定义监听器对象，该监听器对象在客户端接收到服务端传输过来的服务实例信息后，发现服务实例信息发生变更了，该监听器对象中的方法就会被回调**。好了，到此为止本章内容就全部结束了，虽然本章内容看起来很多，但是实现的功能都非常简单，就是观察者模式那一套，你把它叫做监听模式、观察者模式都一样，没什么大区别，逻辑非常简单。当然，文章中有些代码和我提供的第五版本代码有些不同，部分内容做了简化，大家可以去我提供的第五版本代码中再看看代码。各位，我们下一章见！