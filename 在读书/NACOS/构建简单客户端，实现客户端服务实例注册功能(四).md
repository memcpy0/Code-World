## 引入 ServerListManager 类，完善 NamingClientProxyDelegate

在上一章结尾，我跟大家说我要引入一个新的组件，那就是服务器列表管理器，这个管理器组件负责管理集群中所有服务器的网络地址，如果没有搭建服务端集群，那这个管理器只管理单个注册中心服务器的网络地址即可。**我把这个服务器列表管理器定义为了 ServerListManager 类，并且在这个类中定义了一个非常核心的 genNextServer 方法，假如客户端和服务端连接出现问题了，通过 genNextServer 方法，客户端就可以获得一个新的注册中心服务端的网络地址**。接下来，我把这个新引入的 ServerListManager 服务列表管理器给大家展示一下，请看下面代码块。

```
package com.cqfy.nacos.client.naming.core;


//nacos服务地址管理器，这个类的逻辑非常简单，大家自己看看就行
//在这里大家也可以看到，新引入的这个ServerListManager服务地址管理器实际上实现了ServerListFactory接口
public class ServerListManager implements ServerListFactory, Closeable {

    //所属命名空间
    private final String namespace;

    //客户端当前建立连接的服务端地址在下面serverList集合中的索引
    private final AtomicInteger currentIndex = new AtomicInteger();

    //这个集合存放到就是注册中心集群中所有服务器的地址，如果没有搭建服务器集群
    //那么这个集合中只会存放一个服务器地址
    private final List<String> serverList = new ArrayList<>();




    //在这个构造方法中，使用NacosClientProperties对象初始化ServerListManager对象
    public ServerListManager(NacosClientProperties properties, String namespace) {

        this.namespace = namespace;
        
        //在这里调用了本类的初始化方法，将properties对象中的服务器地址存放到了serverList集合中
        initServerAddr(properties);
 
        //判断serverList集合是否为空，因为initServerAddr方法已经初始化完毕了
        //所以集合中显然应该存放数据了，如果集合为空则报错
        if (getServerList().isEmpty()) {
            throw new NacosLoadException("serverList is empty,please check configuration");
        } else {
            //走到这里就说明serverList集合不为空，已经有服务器地址存放到集合中了
            //接下来就要给currentIndex赋值，也就是说，从serverList集合中随机选取一个地址，让客户端建立连接
            //当然，如果没有大家服务端集群，集合中肯定只有一个地址，那这里得到的随机数就是0
            //currentIndex也就会被赋值为0
            currentIndex.set(new Random().nextInt(getServerList().size()));
        }
    }



    //在这个方法中，就是把配置文件中定义的nacos服务端的地址列表存放到ServerListManager对象的serverList成员变量中
    private void initServerAddr(NacosClientProperties properties) {

        //PropertyKeyConst.SERVER_ADDR其实就是"serverAddr"，我们之前在测试类中向properties对象中设置了服务器地址键值对
        //"serverAddr", "localhost"，现在大家应该回想起来了
        String serverListFromProps = properties.getProperty(PropertyKeyConst.SERVER_ADDR);
        //对value判空，value就是注册中心服务器地址，我们也可以设置多个地址，用逗号隔开，也可以只定义一个，在测试类中我只定义了一个
        if (StringUtils.isNotEmpty(serverListFromProps)) {
            //下面就是把地址用逗号隔开，然后添加到serverList成员变量中的操作
            this.serverList.addAll(Arrays.asList(serverListFromProps.split(",")));
        }
    }


    //得到serverList成员变量
    @Override
    public List<String> getServerList() {
        return serverList;
    }

    //得到下一个nacos服务器地址的方法
    @Override
    public String genNextServer() {
        int index = currentIndex.incrementAndGet() % getServerList().size();
        return getServerList().get(index);
    }

    //得到当前使用的nacos服务器地址的方法
    @Override
    public String getCurrentServer() {
        return getServerList().get(currentIndex.get() % getServerList().size());
    }

    
}
```

在上面的代码块中，我就把新引入的 ServerListManager 服务地址管理器展示给大家了。这个管理器对象的逻辑也非常简单，直接从它的构造方法入手即可。可以看到，在它的构造方法中，必须要把 NacosClientProperties 配置组件传递进来，然后直接使用 NacosClientProperties 配置组件中的注册中心服务器地址初始化 serverList 成员变量即可。至于 ServerListManager 服务地址管理器中的其他方法都很简单，代码中也有注释，我就不再重复解释了。到此为止，ServerListManager 这个组件我也就为大家展示完毕了。当然，我还得再说一句，目前我给大家展示的这个组件其实经过了大幅度简化，在我提供的代码中也是这些简化之后的内容，但是随着服务端集群的引入，这个 ServerListManager 类还会进一步重构，到时候它就会变得复杂一些，至于扩充了什么内容，要如何重构，这就是后面要讲解的内容了，现在先让我们回归正题，看看在 ServerListManager 组件引入之后，NamingClientProxyDelegate 类应该如何重构。

如果大家还记得上一章末尾的内容，肯定就知道，我们之所以引入了这个 ServerListManager 组件，是因为首先讨论了 NamingClientProxyDelegate 这个客户端代理对象该如何创建，这个大家应该还有印象吧？**因为我们想使用 init-start 模式重构程序，并且也确定了这个模式应该应用在 NacosNamingService 类中，在这个类的 init 方法中把注册中心客户端使用的核心功能组件展示出来，而 NamingClientProxyDelegate 恰好就是比较核心的网络通信组件，所以它自然也应该展示在 NacosNamingService 类的 init 方法中**。因此才引入了一个重要问题，那就是 NamingClientProxyDelegate 对象究竟应该怎么创建？**因为 NamingClientProxyDelegate 类作为网路通信组件，必须要知道注册中心服务端的网络地址，但我们目前实现的 NamingClientProxyDelegate 类，还无法做到这一点**。也正是根据这个问题，引申出了另一个新的组件，就是我刚刚为大家展示的 ServerListManager 类。**如果把 ServerListManager 类的对象定义为 NamingClientProxyDelegate 类的成员变量，这样一来，NamingClientProxyDelegate 不就可以直接从 ServerListManager 管理器对象中获得注册中心的地址了吗？当然，这么做有一个前提，那就是肯定要把 NacosClientProperties 配置组件交给 ServerListManager 管理器使用，以便用来初始化期内部的 serverList 成员变量**。现在 ServerListManager 已经实现完毕了，就应该回到正题上，对 NamingClientProxyDelegate 组件进行重构。当然，大家应该也猜到了，随着 ServerListManager 服务地址管理器的引入，我肯定早就想好了怎么重构 NamingClientProxyDelegate 客户端代理组件，接下来就请大家看看重构之后的 NamingClientProxyDelegate 类，请看下面代码块。

```
package com.cqfy.nacos.client.naming.remote;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/10
 * @方法描述：代理客户端，这个客户端内部持有了grpcClientProxy客户端，真正发送服务实例给服务端的操作，是grpcClientProxy客户端执行的
 */
public class NamingClientProxyDelegate implements NamingClientProxy {

    //服务地址管理器，这里我要解释一下，这个服务管理器管理的是nacos服务器的，因为nacos本身就可以搭建成集群，并且还是raft集群
    //nacos客户端向nacos服务端发送消息的时候，如果接收消息的服务端故障了，这个时候nacos客户端就可以选择另外的服务端地址重新发送消息给服务端
    //这个nacos服务端地址可以定义在配置文件中，也可以定义在配置类中，总之会在ServerListManager兑现初始化的时候被设置到ServerListManager的serverList成员变量中
    private final ServerListManager serverListManager;


    //下面这两个通信组件都是伪代码，后面还会重构
    private final HttpClient httpClient;
    
    private final GrpcClient grpcClient;


    //定义构造方法
    public NamingClientProxyDelegate(String namespace, NacosClientProperties properties) throws NacosException {

        //在这里创建了ServerListManager服务地址管理器对象
        this.serverListManager = new ServerListManager(properties, namespace);
    }
    


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/10
     * @方法描述：进一步注册服务实例到服务端的方法
     */
    @Override
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
        //getExecuteClientProxy就是根据服务实例得到对应的客户端的方法
        //得到了具体的客户端之后，再执行客户端的registerService方法，把服务实例注册到服务端
        getExecuteClientProxy(instance).registerService(serviceName, groupName, instance);
    }


    //根据服务实例得到对应的客户端的方法
    private NamingClientProxy getExecuteClientProxy(Instance instance) {

        //暂时省略，反正不是返回httpClient就是返回grpcClient
    }
    

}
```

以上就是重构完毕的 NamingClientProxyDelegate 类，可以看到，所谓重构只不过是定义了一个 ServerListManager 成员变量，以及一个有参构造方法，构造方法中有一个非常重要的参数，那就是 NacosClientProperties 对象，这个对象就可以用来初始化 ServerListManager 对象中的 serverList 集合。其他代码和之前没什么区别，依然是一些伪代码。好了，现在 NamingClientProxyDelegate 类也重构完了，我们终于知道创建 NamingClientProxyDelegate 对象的方式了，接下来就可以使用 init-start 方式继续重构 NacosNamingService 类。我把重构之后的 NacosNamingService 类也展示在下面了，请看下面代码块。

```
package com.cqfy.nacos.client.naming;




//从上面的包名可以看到这个接口实际上在api模块中
//这个类是注册中心客户端的核心类，可以说是注册服务实例，订阅服务实例等等操作的入口类，很多重要的操作都是由这个类的对象发起的
//但在第一版本代码中，该类只提供了注册服务实例到注册中心的方法
@SuppressWarnings("PMD.ServiceOrDaoClassShouldEndWithImplRule")
public class NacosNamingService implements NamingService {

    //从我在测试类为大家提供的代码，大家也能看出来，实际上NacosNamingService类的对象是通过反射创建的
    //反射调用该类的构造方法，并且调用的是参数为Properties的构造方法，而在测试类的Properties中，设置了要创建的NacosNamingService对象
    //的命名空间，这就意味着每一个NacosNamingService对象都有自己的命名空间，下面这个成员变量表示的就是当前NacosNamingService对象的命名空间，在测试类中为创建的
    //NacosNamingService对象设置了默认的命名空间，也就是public
    private String namespace;

    //代理客户端，该客户端就是用来向注册中心服务器发送请求的
    //这里之所以叫代理客户端，是因为NamingClientProxy内部真正向服务器发送消息时，使用的是grpc构建的客户端
    private NamingClientProxy clientProxy;


    //构造方法，该构造方法通过Properties文件创建NacosNamingService对象
    public NacosNamingService(Properties properties) throws NacosException {
        //在这里调用了init方法
        init(properties);
    }


     //初始化NacosNamingService对象的方法，在该方法对NacosNamingService内部要使用的一些组件进行了创建和初始化
    private void init(Properties properties) throws NacosException {
        
        //创建一个Nacos客户端的配置文件类，这个步骤其实就是把在测试类中定义的配置文件中的所有内容都放到了
        //新创建的这个nacosClientProperties配置类中了，以后需要什么配置信息都从这个nacosClientProperties配置类中寻找即可
        //这个NacosClientProperties中定义了属性源提供属性时的优先级，可以点进去看一看，注释非常详细
        final NacosClientProperties nacosClientProperties = NacosClientProperties.PROTOTYPE.derive(properties);
        
        //给当前NacosNamingService对象的命名空间赋值
        this.namespace = InitUtils.initNamespaceForNaming(nacosClientProperties);
        
       //创建代理客户端对象
        this.clientProxy = new NamingClientProxyDelegate(this.namespace,nacosClientProperties);
    }
    

    //注册服务实例到服务端的方法
    @Override
    public void registerInstance(String serviceName, String ip, int port, String clusterName) throws NacosException {
        //这里把服务实例所在的group设置为DEFAULT_GROUP了
        registerInstance(serviceName, Constants.DEFAULT_GROUP, ip, port, clusterName);
    }


    //也是注册服务实例的方法，只不过在这个方法中创建了服务实例对象
    @Override
    public void registerInstance(String serviceName, String groupName, String ip, int port, String clusterName) throws NacosException {
        //创建服务实例对象
        Instance instance = new Instance();
        //设置服务实例对象属性
        instance.setIp(ip);
        instance.setPort(port);
        //权重的作用大家应该都清楚，权重高的服务实例，负载均衡时提供服务的概率更大
        //默认权重为1.0
        instance.setWeight(1.0);
        //设置服务实例所属集群的名称，现在我们是单机部署，并没有引入集群
        instance.setClusterName(clusterName);
        
       //服务实例创建完毕了，然后继续调用下面的registerInstance方法，把服务实例注册到服务端
        registerInstance(serviceName, groupName, instance);
    }




    //注册服务实例的方法，在该方法中，会调用代理客户端的registerService方法，把服务实例注册到服务端
    @Override
    public void registerInstance(String serviceName, String groupName, Instance instance) throws NacosException {
        
        //检查服务实例的各种参数是否合法
        NamingUtils.checkInstanceIsLegal(instance);
        
        //检查服务实例分组名称是否合法，该方法我就不展示了，大家去看我提供的第一版本代码即可
        checkAndStripGroupNamePrefix(instance, groupName);
        
        //在这里用代理客户端把服务实例注册到服务器
        clientProxy.registerService(serviceName, groupName, instance);
    }

   
}
```

可以看到，最新重构之后的 NacosNamingService 类和之前比起来也没什么大变化，只不过就是把之前定义在 NacosNamingService 类中的伪代码，也就是那个 Client 成员变量替换成了 NamingClientProxy 对象，当然，NamingClientProxy 只是一个接口，其实现类就是 NamingClientProxyDelegate。到此为止，就目前我们要求的功能组件来说，NacosNamingService 类其实也重构得差不多了。还记得我们在开始构建注册中心客户端之前提出来的那几个要点吗？就是下面这 5 条：

**1 注册中心客户端需要和服务端进行网络通信，所以网络通信组件必不可少。**

**2 既然涉及到网络通信，那么各种通信处理器也必不可少。**

**3 注册中心客户端需要把服务实例注册到服务端的注册表中，所以注册中心客户端需要具备注册服务实例的功能。**

**4 为了与注册中心服务端的判活功能对接，注册中心客户端还需要提供向服务端发送心跳信息的功能。只有让服务端定期都接收到心跳信息，这样一来，服务端才会认为该客户端注册的所有服务实例都存活。**

**5 最后仍然是 init-start 开发模式。**

以上 5 条就包含了我们想要开发的客户端最基本的功能组件，而经过我们几次迭代后的框架，目前也具备了网络通信组件，也具备了注册服务实例到服务端的功能，init-start 模式也用上了，也就是说 1、3、5 都已经实现了；最后只剩下客户端和服务端的通信处理器组件和心跳功能没有实现了。当然，我能想到看到这里肯定有朋友会有很多疑问，觉得我并没有真正实现了 1、3、5 需要的功能组件，**因为说到底我引入的只是一个客户端代理组件，这个组件并不会真正和服务端建立网络连接，也不会真正向服务端发送消息。就算现在 NamingClientProxyDelegate 客户端代理对象可以通过内部的 ServerListManager 服务地址管理器得到注册中心服务端的地址了，又该如何使用呢**？**所谓的 NamingClientProxyDelegate 组件终究只是一个客户端代理对象，最终建立和服务端的连接，以及向服务端发送消息，肯定还是真正的客户端通信组件的工作，也就是 httpClient 和 grpcClient 的工作**。除了这一点，还有所谓的实现了客户端向服务端注册服务实例功能，这也有点胡扯了。这个功能的实现离不开注册中心客户端向服务端发送消息，离不开客户端和服务端建立网络连接，但现在我们连客户端和服务端建立网络连接这一步都没做到，怎么能说实现了客户端注册服务实例到服务端的功能呢？总之这样分析下来，只要我们没有引入真正的客户端网络通信组件，那我们就不能说实现了以上几个功能。所以，接下来我们还是要围绕着客户端网络通信组件来讲解，要尽快引入真正的客户端网络通信组件。

## 引入 GrpcClient，完善客户端网络通信组件

通过之前引入的 NamingClientProxyDelegate 类，我们可以知道，这个 NamingClientProxyDelegate 类只是一个客户端代理对象，其内部持有者真正的用来和服务端通信的组件。而且我已经根据 nacos 源码，为大家明确了两种类型的通信组件，一个就是 http 通信组件，一个就是 grpc 通信组件。所以接下来只要引入这两个真正的通信组件即可。当然，我并不会真的把两种类型的通信组件都引入到我们的框架中，因为在 2.0 之后的 nacos 框架中已经不再使用 http 通信组件和服务端建立连接了，取而代之的是 grpc 框架，所以为了向最新版本的 nacos 框架靠拢，也为了简化我们的学习难度，在我为大家提供的代码中，我已经把 http 通信组件省略了，感兴趣的朋友可以直接查看源码学习。接下来，**我就为注册中心客户端引入真正的网络通信组件，也就是 grpc 框架的客户端**。

  

当然，大家也别以为引入要引入 Grpc 框架的客户端了，接下来会面临很大的工作量。我可以很负责任地告诉大家，其实工作量一点也不大，甚至还非常简单。原因有两点：首先我们已经把 http 通信组件给省略了，所有注意力都集中在 Grpc 框架客户端即可；第二，就算是要使用 Grpc 框架，也只需要把它的代码直接拿过来用就行，Grpc 框架的使用方法非常简单。如果有朋友对 Grpc 框架不太熟悉，我在下面给大家展示了两个例子，请大家简单看一下。

因为 Grpc 框架使用了 protobuf，所以首先应该定义一个 protobuf 文件，请看下面代码块。

```
syntax = "proto3";


service Greeter {
    
    //为单向流存根定义的方法
    rpc SayHello (HelloRequest) returns (HelloResponse);

    //为双向流存根定义的方法
    rpc Chat (stream ChatMessage) returns (stream ChatMessage);
}

//下面都是消息体了
message HelloRequest {
    string name = 1;
}

message HelloResponse {
    string message = 1;
}

message ChatMessage {
    string message = 1;
}
```

在上面的代码块中，我定义了两个方法，一个是 SayHello，一个是 Chat。其中 SayHello 方法是为单向流存根定义的，Chat 方法是为双向流存根定义的。可能有朋友对存根这个概念比较困惑，所以我想简单解释解释一下：**所谓存根就是在客户端发起远程调用的代理对象**。如果大家还是不明白，那也没关系，我把 Grpc 框架的服务端和客户端代码展示出来了，大家看完代码肯定就直接明白了。首先是 Grpc 服务端代码，请看下面代码块。

```
public class GrpcServer {

    
    public static void main(String[] args) throws IOException, InterruptedException {
        //创建和启动gRPC服务端
        Server server = ServerBuilder.forPort(8888)
                //添加具体的提供服务的对象
                .addService(new GreeterImpl())
                .build()
                .start();

        System.out.println("Grpc服务器启动了!");

        //防止主线程退出
        server.awaitTermination();
    }

    
    //实现服务内容
    static class GreeterImpl extends GreeterGrpc.GreeterImplBase {

        //这个sayHello方法就是服务端提供的服务，客户端使用存根直接远程调用sayHello方法后
        //请求到达服务端后，就会调用真正的sayHello方法来处理请求，然后回复响应
        @Override
        public void sayHello(HelloRequest request, StreamObserver<HelloResponse> responseObserver) {
            String name = request.getName();
            HelloResponse response = HelloResponse.newBuilder()
                    .setMessage("Hello, " + name)
                    .build();

            //返回响应
            responseObserver.onNext(reply);
            //发送响应结束
            responseObserver.onCompleted();
        }
    }
}
```

接下来是 Grpc 客户端，请看下面代码块。

```
public class GrpcClient {

    
    public static void main(String[] args) {
        //创建客户端与服务端之间的channel，注意，这里只是把channel创建出来了，客户端和服务端
        //的连接并没有建立，具体细节得看源码才知道，后面给大家讲解grpc框架的时候再细说吧
        ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", 8888)
                .usePlaintext()
                .build();

        //创建单向流存根，所谓的这个单向流存根，其实就是用来发送请求给服务器的
        //注意，这里的存根只能处理请求响应模式，是单向流，并不是双向流
        GreeterGrpc.GreeterFutureStub futureStub = GreeterGrpc.newFutureStub(channel);

        //创建请求
        HelloRequest request = HelloRequest.newBuilder()
                .setName("Nacos")
                .build();

        //发送请求
        try {//这里调用了get方法，这就会导致主线程阻塞，直到响应到来
            //你也可以给future定义回调方法，让它成为一个完全异步的操作，这时候就变成异步发送请求了
            //下面就直接调用了sayHello方法，服务端有sayHello方法的具体实现
            HelloResponse response = futureStub.sayHello(request).get();
            //阻塞结束后，输出结果
            System.out.println("Response: " + response.getMessage());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }

        //关闭通道
        channel.shutdown();
    }
}
```

在上面代码块的第 13 行，**大家就看到一个 futureStub 对象，它就是一个客户端存根对象，这个存根对象可以直接远程调用 sayHello 方法，调用的整个过程以及其中的所有细节用户完全不必关系，只需要得到这个存根对象，然后使用存根对象直接调用目标方法即可**。当然，了解了什么是存根对象后，也许有的朋友还对另一个概念感到困惑，那就是单向流存根中的单向流，**所谓单向流也很容易解释，其实就是客户端可以发送请求接收响应，但是服务端不能主动发送消息给客户端。也就是最简单的请求——响应模式**，这就是单向的含义。既然有单向肯定就有双向，也就是双向流存根，**所谓双向流存根就是客户端可以主动向服务器发送消息，服务器也可以主动向客户端发送消息，做到了真正意义上的全双工通信**。我同样为大家准备了一个双向流的 Grpc 客户端，已经展示在下面的代码块中了，请看下面代码块。

```

//这里我多解释一句，当我们使用双向流存根构建客户端时，服务端也应该重构为双向流，但这里我就不展示重构之后的服务端了，后面更新grpc时再为大家详细讲解
public class GrpcClient {

    
    public static void main(String[] args) {
        //创建channel
        ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", 8888)
                .usePlaintext()
                .build();

        //得到异步存根
        GreeterGrpc.GreeterStub asyncStub = GreeterGrpc.newStub(channel);


         //使用异步存根创建一个请求观察者，用于发送消息到服务器
        StreamObserver<ChatMessage> requestObserver = asyncStub.chat(new StreamObserver<ChatMessage>() {
            
            //收到服务器消息时调用，服务器主动发送过来的消息，就会被这个方法接收并处理
            @Override
            public void onNext(ChatMessage chatMessage) {
                System.out.println("接收到来自服务器的消息: " + chatMessage.getMessage());
            }

            //发生错误时调用
            @Override
            public void onError(Throwable t) {
                System.err.println("发生错误: " + t.getMessage());
              
            }

            //流完成时调用
            @Override
            public void onCompleted() {
                System.out.println("聊天结束.");
               
            }
        });


        try {
            //发送多条消息到服务器
            for (int i = 1; i <= 5; i++) {
                //创建一条ChatMessage消息
                ChatMessage message = ChatMessage.newBuilder()
                        .setMessage("Message " + i)
                        .build();

                //通过请求观察者发送消息
                requestObserver.onNext(message);

                //等待1秒，模拟延迟
                Thread.sleep(1000);
            }

            //通知服务器不再发送更多消息
            requestObserver.onCompleted();

        } catch (Exception e) {
            //发生异常时通知服务器
            requestObserver.onError(e);
        }

        
        //确保主线程不会立即退出，以等待响应
        try {
            Thread.sleep(100000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //关闭channel
        channel.shutdown();
    }
}
```

好了，到此为止，我就为大家把 Grpc 的一些知识简单介绍完毕了，介绍的这些内容几乎都和 Grpc 客户端有关，等后面我们实现 nacos 注册中心服务端的时候，我再为大家介绍 Grpc 服务端的功能。接下来让我们言归正传吧，把 Grpc 框架的客户端引入到我们正在开发的注册中心客户端中。刚才我已经跟大家说了，把 Grpc 客户端引入进来的工作非常简单，都是现成的代码直接拿过来用即可，但就算可以直接拿过来使用，我觉得还是简单封装一下比较好。**我们不是在 NamingClientProxyDelegate 类中定义了一个 GrpcClient 类型的成员变量吗？用 GrpcClient 对象来表示 Grpc 通信组件，反正都已经定义好了，不如就把 Grpc 框架的客户端代码封装在这个 GrpcClient 类中吧，GrpcClient 也就相当于 Grpc 客户端了**。当然，我们已经决定把 http 通信组件省略了，所以接下来还是先对 NamingClientProxyDelegate 类重构一下，请看下面代码块。

```
package com.cqfy.nacos.client.naming.remote;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/10
 * @方法描述：代理客户端，这个客户端内部持有了grpcClientProxy客户端，真正发送服务实例给服务端的操作，是grpcClientProxy客户端执行的
 */
public class NamingClientProxyDelegate implements NamingClientProxy {

    //服务地址管理器
    private final ServerListManager serverListManager;

    //代表grpc客户端的通信组件，这里大家可以思考一下，这个grpcClient客户端对象该怎么创建呢？
    private final GrpcClient grpcClient;


    //定义构造方法
    public NamingClientProxyDelegate(String namespace, NacosClientProperties properties) throws NacosException {

        //在这里创建了ServerListManager服务地址管理器对象
        this.serverListManager = new ServerListManager(properties, namespace);

        
    }
    


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/10
     * @方法描述：进一步注册服务实例到服务端的方法
     */
    @Override
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
        //getExecuteClientProxy就是根据服务实例得到对应的客户端的方法
        //得到了具体的客户端之后，再执行客户端的registerService方法，把服务实例注册到服务端
        getExecuteClientProxy(instance).registerService(serviceName, groupName, instance);
    }


    //根据服务实例得到对应的客户端的方法
    private NamingClientProxy getExecuteClientProxy(Instance instance) {

        //现在就没必要纠结返回哪个客户端通信组件了，因为只剩下grpc通信组件了
        //但是我要补充一点，在我提供的第一版本代码以及nacos的源码中
        //这里有一个判断，那就是判断要注册的instance是否为临时的，如果注册的实例不是临时的
        //并且grpc客户端也不支持注册持久服务实例，这种情况下就会使用http通信组件发送请求
        //具体的逻辑可以去我提供的第一版本代码或者源码中查看，我在第一版本代码中保留了部分http通信组件的代码
        //只不过给注释了，大家可以简单看看
        return grpcClient;
    }
    

}
```

好了，现在 NamingClientProxyDelegate 类又经过一点小小的重构了。在看完目前的这个 NamingClientProxyDelegate 类之后，我不知道大家会不会有这样一个疑问，那就是当 NamingClientProxyDelegate 对象调用它的 registerService 方法时，会首先获得 grpcClient 客户端对象，然后又调用了 grpcClient 客户端对象的 registerService 方法，把服务实例注册到注册中心服务端。**这就意味着在我们接下来要实现的这个 GrpcClient 类中，应该定义一个 registerService 方法，这样一来真正的客户端通信组件才能把服务实例注册到服务端**。很好，现在问题就来了，既然要使用 grpcClient 客户端对象，那首先就要创建这个对象吧？可是在上面的代码开中，并没有展示 grpcClient 成员变量是在什么时候被创建的。**那这个对象该怎么创建呢？在哪里创建呢？别忘了，这个对象是真正的客户端通信组件，是要和注册中心服务端建立网络连接的，这样一来，这个 grpcClient 对象肯定就要知道服务器的网络地址吧**？而我们已经为框架引入了服务地址管理器，也就是 ServerListManager 对象，所以按照常规逻辑，**其实只需要把 ServerListManager 对象交给 grpcClient 对象使用即可**。所以，接下来我就要按照当前的分析先把 grpcClient 客户端对象实现出来，然后再考虑创建 grpcClient 对象的问题。

根据刚才的分析，我们已经知道 GrpcClient 类中肯定要定义一个 registerService 方法，还有一个 ServerListManager 成员变量，这样一来，GrpcClient 对象就可以从 ServerListManager 服务地址管理器中获得注册中心服务器的网络地址，建立连接之后，把服务实例注册到服务器。所以，这个 GrpcClient 类可以先被定义成下面这样，请看下面代码块。

```
package com.cqfy.nacos.common.remote.client;

//grpc客户端的实现类，该类中定义了grpc客户端的核心功能，连接服务端的操作都定义在这个类中了
@SuppressWarnings("PMD.AbstractClassShouldStartWithAbstractNamingRule")
public class GrpcClient{

    //naocs服务器地址管理器
    private ServerListFactory serverListFactory;


    //注册服务实例到服务端的方法
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
       //暂时先不实现
    }


    //设置服务地址管理器的方法
    public RpcClient serverListFactory(ServerListFactory serverListFactory) {
        this.serverListFactory = serverListFactory;
    }
}
```

从上面的代码块中可以看到，**我其实并没有给 GrpcClient 类定义构造方法，而是定义了一个 serverListFactory 方法，这个方法就是用来给 GrpcClient 的成员变量 serverListFactory 对象赋值的**。我们当然可以定义一个有参构造，然后在构造方法中给 serverListFactory 成员变量赋值，但现在 GrpcClient 类不是还没有实现完整吗？我想先把其他的内容都引入进来了，最后再来解决 GrpcClient 对象的创建问题。而 GrpcClient 类的其他内容其实也已经讲解完了，就是之前我为大家介绍的 Grpc 框架客户端的代码。我之前跟大家说了，引入 Grpc 客户端组建的工作量非常小，就是直接把 Grpc 客户端的代码拿来用就行，我们要做的只不过是用 GrpcClient 类把 Grpc 客户端的代码封装好。大家应该对刚才展示的 Grpc 客户端代码还有印象，**一个客户端使用的是单向流存根对象，另一个客户端使用的是双向流存根对象；实际上在 nacos 中把这两类存根对象都引入了，所以我也把这两类存根对象都引入到我们自己的框架中了**。接下来，请大家看一看再次重构之后的 GrpcClient 类，请看下面代码块。

```
package com.cqfy.nacos.common.remote.client;

//grpc客户端的实现类，该类中定义了grpc客户端的核心功能，连接服务端的操作都定义在这个类中了
@SuppressWarnings("PMD.AbstractClassShouldStartWithAbstractNamingRule")
public class GrpcClient {

    //naocs服务器地址管理器
    private ServerListFactory serverListFactory;

    //Grpc客户端配置类，这个成员变量内部定义了一些默认配置参数
    //逻辑很简单，大家直接看第一版本代码即可
    private final GrpcClientConfig clientConfig;

     //grpc要用到的业务线程池，这个线程池在创建Grpc客户端和服务端channel的时候会用到
    private ThreadPoolExecutor grpcExecutor;


    //注册服务实例到服务端的方法
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
       //暂时先不实现
    }


    //设置服务地址管理器的方法
    public RpcClient serverListFactory(ServerListFactory serverListFactory) {
        this.serverListFactory = serverListFactory;
    }


    
    //创建grpcExecutor成员变量的方法
    protected ThreadPoolExecutor createGrpcExecutor(String serverIp) {
        serverIp = serverIp.replaceAll("%", "-");
        //在这里创建了线程池对象，定义了线程池的核心线程数，最大线程数等等
        ThreadPoolExecutor grpcExecutor = new ThreadPoolExecutor(clientConfig.threadPoolCoreSize(),
                clientConfig.threadPoolMaxSize(), clientConfig.threadPoolKeepAlive(), TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(clientConfig.threadPoolQueueSize()),
                new ThreadFactoryBuilder().daemon(true).nameFormat("nacos-grpc-client-executor-" + serverIp + "-%d")
                        .build());
        grpcExecutor.allowCoreThreadTimeOut(true);
        return grpcExecutor;
    }


    
    //创建客户端和服务端之间的channel的方法
    private ManagedChannel createNewManagedChannel(String serverIp, int serverPort) {
        LOGGER.info("grpc client connection server:{} ip,serverPort:{},grpcTslConfig:{}", serverIp, serverPort,JacksonUtils.toJson(clientConfig.tlsConfig()));
        //下面就是设置一些配置参数的操作了
        ManagedChannelBuilder<?> managedChannelBuilder = buildChannel(serverIp, serverPort, buildSslContext())
                .executor(grpcExecutor)
                .compressorRegistry(CompressorRegistry.getDefaultInstance())
                .decompressorRegistry(DecompressorRegistry.getDefaultInstance())
                .maxInboundMessageSize(clientConfig.maxInboundMessageSize())
                .keepAliveTime(clientConfig.channelKeepAlive(), TimeUnit.MILLISECONDS)
                .keepAliveTimeout(clientConfig.channelKeepAliveTimeout(), TimeUnit.MILLISECONDS);
        return managedChannelBuilder.build();
    }




    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：这个方法中都是grpc代码的逻辑，还没有基础过grpc的朋友们可以去找找grpc的资料，简单来说，当grpc的服务端向客户端发送了请求之后，程序就会调用这个方法
     * 确切地说，是调用该方法内部的onNext方法，来处理服务端主动发送过来的请求
     */
    private StreamObserver<Payload> bindRequestStream(final BiRequestStreamGrpc.BiRequestStreamStub streamStub,
                                                      final GrpcConnection grpcConn) {

        return streamStub.requestBiStream(new StreamObserver<Payload>() {

            //Payload就是请求体
            @Override
            public void onNext(Payload payload) {

                //具体逻辑暂时不做实现
            }

            @Override
            public void onError(Throwable throwable) {

                 //具体逻辑暂时不做实现
            }

            @Override
            public void onCompleted() {

                 //具体逻辑暂时不做实现
            }
        });
    }
    
}
```

经过这次重构之后，GrpcClient 类中的内容就多起来了。接下来先让我为大家简单梳理一下，虽然上面代码块中内容很多，但是大多数代码都和 Grpc 框架的客户端有关，和 nacos 本身关系不大。**比如说我引入的 grpcExecutor 成员变量，这个成员变量会在创建 Grpc 客户端和服务端之间的 channel 时发挥作用，而创建 channel 的方法就是 createNewManagedChannel 方法。这些方法和成员变量都是为 Grpc 客户端定义的。当然还有一个最重要的方法，那就是 bindRequestStream 方法，该方法会返回一个 Grpc 客户端可以使用的双向流存根，到时候就会使用这个存根对象向 Grpc 服务端发送消息**。但是定义了这么多内容，我们真正要做的工作还没有做呀，引入了 Grpc 客户端之后要做什么？第一件事肯定是要和服务端建立连接呀。这时候流程就和之前我之前为大家展示得差不多了，无非就是创建出客户端和服务端的 channel，得到单向流存根和双向流存根。这里我还要补充一下，**大家应该发现了，在这里我并没有说得到单向流和双向流存根之后，Grpc 客户端和服务端的连接就建立完毕了，如果大家看过 Grpc 框架的源码就会知道，实际上 Grpc 客户端和服务端的连接是在客户端使用存根对象第一次执行远程方法调用时才建立的。也就是说，当我们得到了存根对象，使用存根对象第一次对目标方法进行远程调用时，在这个过程中客户端和服务端的连接才会建立**。这些细节的内容我就不展开讲解了，否则就要说到 Grpc 框架负载均衡的细节了；等后面为大家更新 Grpc 框架的时候再说吧。总之，大家现在只需要了解 Grpc 客户端和服务端的框架并不是在创建 channel 的时候建立的就行了，反正我们可以得到两个存根对象，后面直接使用存根对象向服务端发送消息即可，连接的建立的操作就让 Grpc 框架内部自己执行吧。

虽然我为大家补充了一些细节，但这并不影响我再为 GrpcClient 类定义一个名为 connectToServer 的方法，这个方法从表面上看是连接到服务器的作用，但是我刚才说只是创建 channel、得到两个存根对象并不意味着客户端和服务端连接建立了，等到存根对象第一次执行目标方法调用或者向服务端发送消息时，客户端和服务端连接才会真正建立。这其实也很好办，**我完全可以再给 GrpcClient 类定义一个 serverCheck 方法，这个方法的作用就是检查客户端和服务端是否建立连接了。这个方法的逻辑也很简单，就是使用单向流存根对象向服务端发送一个健康检查请求，在发送的过程中客户端和服务端的连接就会建立，只要 Grpc 服务端回复了成功响应，就意味着客户端和服务端连接成功建立了**。这个逻辑就这么简单。当然，在调用 serverCheck 方法之前必须保证得到存根对象，拿得到存根对象的操作就可以定义在 connectToServer 方法中，因此，serverCheck 方法也要在 connectToServer 方法中被调用了。好了，具体的逻辑已经分析完了，接下来就看一看重构之后的 GrpcClient 类吧，请看下面代码块。

```
package com.cqfy.nacos.common.remote.client;



//grpc客户端的实现类，该类中定义了grpc客户端的核心功能，连接服务端的操作都定义在这个类中了
@SuppressWarnings("PMD.AbstractClassShouldStartWithAbstractNamingRule")
public class GrpcClient {

    //naocs服务器地址管理器
    private ServerListFactory serverListFactory;

    //Grpc客户端配置类，这个成员变量内部定义了一些默认配置参数
    //逻辑很简单，大家直接看第一版本代码即可
    private final GrpcClientConfig clientConfig;

     //grpc要用到的业务线程池，这个线程池在创建Grpc客户端和服务端channel的时候会用到
    private ThreadPoolExecutor grpcExecutor;


    //注册服务实例到服务端的方法
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
       //暂时先不实现
    }


    //设置服务地址管理器的方法
    public RpcClient serverListFactory(ServerListFactory serverListFactory) {
        this.serverListFactory = serverListFactory;
    }


    
    //创建grpcExecutor成员变量的方法
    protected ThreadPoolExecutor createGrpcExecutor(String serverIp) {
        serverIp = serverIp.replaceAll("%", "-");
        //在这里创建了线程池对象，定义了线程池的核心线程数，最大线程数等等
        ThreadPoolExecutor grpcExecutor = new ThreadPoolExecutor(clientConfig.threadPoolCoreSize(),
                clientConfig.threadPoolMaxSize(), clientConfig.threadPoolKeepAlive(), TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(clientConfig.threadPoolQueueSize()),
                new ThreadFactoryBuilder().daemon(true).nameFormat("nacos-grpc-client-executor-" + serverIp + "-%d")
                        .build());
        grpcExecutor.allowCoreThreadTimeOut(true);
        return grpcExecutor;
    }


    
    //创建客户端和服务端之间的channel的方法
    private ManagedChannel createNewManagedChannel(String serverIp, int serverPort) {
        LOGGER.info("grpc client connection server:{} ip,serverPort:{},grpcTslConfig:{}", serverIp, serverPort,JacksonUtils.toJson(clientConfig.tlsConfig()));
        //下面就是设置一些配置参数的操作了
        ManagedChannelBuilder<?> managedChannelBuilder = buildChannel(serverIp, serverPort, buildSslContext())
                .executor(grpcExecutor)
                .compressorRegistry(CompressorRegistry.getDefaultInstance())
                .decompressorRegistry(DecompressorRegistry.getDefaultInstance())
                .maxInboundMessageSize(clientConfig.maxInboundMessageSize())
                .keepAliveTime(clientConfig.channelKeepAlive(), TimeUnit.MILLISECONDS)
                .keepAliveTimeout(clientConfig.channelKeepAliveTimeout(), TimeUnit.MILLISECONDS);
        return managedChannelBuilder.build();
    }




    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：这个方法中都是grpc代码的逻辑，还没有基础过grpc的朋友们可以去找找grpc的资料，简单来说，当grpc的服务端向客户端发送了请求之后，程序就会调用这个方法
     * 确切地说，是调用该方法内部的onNext方法，来处理服务端主动发送过来的请求
     */
    private StreamObserver<Payload> bindRequestStream(final BiRequestStreamGrpc.BiRequestStreamStub streamStub,
                                                      final GrpcConnection grpcConn) {

        return streamStub.requestBiStream(new StreamObserver<Payload>() {

            //Payload就是请求体
            @Override
            public void onNext(Payload payload) {

                //具体逻辑暂时不做实现
            }

            @Override
            public void onError(Throwable throwable) {

                 //具体逻辑暂时不做实现
            }

            @Override
            public void onCompleted() {

                 //具体逻辑暂时不做实现
            }
        });
    }


    //得到服务地址管理器
    public ServerListFactory getServerListFactory() {
        return serverListFactory;
    }


    //通过服务地址管理器得到下一个nacos服务器地址的方法
    //ServerInfo对象封装了注册中心服务器地址信息
    //在这个方法被调用之后，会得到一个封装了注册中心服务器地址信息的ServerInfo对象
    //然后会调用connectToServer方法和服务器建立连接，并且把这个ServerInfo对象交给connectToServer方法使用
    protected ServerInfo nextRpcServer() {
        //从服务地址管理器中得到一个可用的注册中心服务器地址
        String serverAddress = getServerListFactory().genNextServer();
        //解析serverAddress，把服务器地址信息封装到一个ServerInfo对象中
        //resolveServerInfo方法和ServerInfo都非常简单，我就不再代码中展示了
        return resolveServerInfo(serverAddress);
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：这个方法就是用来得到grpc服务端端口号偏移量的方法，这里得到的就是1000，在下面的connectToServer方法中就会用到
     */
    public int rpcPortOffset() {
        return Integer.parseInt(System.getProperty(GrpcConstants.NACOS_SERVER_GRPC_PORT_OFFSET_KEY,
                String.valueOf(Constants.SDK_GRPC_PORT_DEFAULT_OFFSET)));
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：连接到gprc服务端的方法，连接成功后，该方法会返回一个Connection对象
     */
    public void connectToServer(ServerInfo serverInfo) {
        //接收连接id
        String connectionId = "";
        try {
            //创建grpc要用到的线程池，这个线程池也用在异步发送请求到服务器时，处理回调方法使用的，在回调方法中，处理接收到的服务器响应
            //和sofajraft也有点像
            if (grpcExecutor == null) {
                this.grpcExecutor = createGrpcExecutor(serverInfo.getServerIp());
            }
            
            //得到grpc服务器的端口号，其实就是nacos服务器端口号加上1000的偏移量
            //到这里大家应该意识到了，我们在测试类中定义的注册中心服务端端口号为8848，但这个端口号实际上是tomcat程序的端口号，web控制台访问服务器访问的就是8848这个端口号
            //它并不是grpc服务器的端口号，真正的grpc服务器端口号要在8848的基础上加上1000的偏移量，这里就得到了真正的注册中心服务器端口号
            int port = serverInfo.getServerPort() + rpcPortOffset();
            
            //创建channel
            ManagedChannel managedChannel = createNewManagedChannel(serverInfo.getServerIp(), port);
            
            //在grpc中把下面创建的这个对象叫做存根，在我们的代码中，就是用它来向grpc服务器发送请求的
            //这个是发送单向请求的存根，也就是请求响应模式
            //在这里得到的单向流存根
            RequestGrpc.RequestFutureStub newChannelStubTemp = createNewChannelStub(managedChannel);
            
            //检查连接服务器是否成功，如果大家看过第四章之后，就会知道使用这个单向流存根向服务器第一次发送消息时，就会真正建立客户端和服务端的连接
            Response response = serverCheck(serverInfo.getServerIp(), port, newChannelStubTemp);
            //如果连接成功，这里应该接收到ServerCheckResponse响应
            if (!(response instanceof ServerCheckResponse)) {
                shuntDownChannel(managedChannel);
                return null;
            }
            ServerCheckResponse serverCheckResponse = (ServerCheckResponse) response;
            //获取连接id，这个连接id是从服务端传递过来的
            connectionId = serverCheckResponse.getConnectionId();
            
            
            //创建了一个双向的流式存根，这个存根对象也是grpc框架中的对象，这个对象既可以接收服务器发送过来的消息
            //也可以向服务器发送消息
            BiRequestStreamGrpc.BiRequestStreamStub biRequestStreamStub = BiRequestStreamGrpc.newStub(newChannelStubTemp.getChannel());
            
            //将grpcConn交给双向流存根使用，在这里就得到了请求观察者对象
            //大家可以暂时忽略方法中的第二个参数，也就是grpcConn参数对象
            StreamObserver<Payload> payloadStreamObserver = bindRequestStream(biRequestStreamStub, grpcConn);
            
        } catch (Exception e) {
            LOGGER.error("[{}]Fail to connect to server!,error={}", GrpcClient.this.getName(), e);
        }
    }

    

     //创建单向流存根对象
    protected RequestGrpc.RequestFutureStub createNewChannelStub(ManagedChannel managedChannelTemp) {
        return RequestGrpc.newFutureStub(managedChannelTemp);
    }

    
    

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：检查服务器是否连接成功的方法，其实就是真正创建客户端和服务端连接的方法
     */
    private Response serverCheck(String ip, int port, RequestGrpc.RequestFutureStub requestBlockingStub) {
        try {//创建检查服务器连接是否成功的请求，这个请求体是nacos自己定义的，类中就没什么内容，很简单，大家直接去看第一版本代码即可
            ServerCheckRequest serverCheckRequest = new ServerCheckRequest();
            //把请求转换为protobuf定义的请求，这里要给大家补充一下，Payload是grpc框架客户端服务端通信的对象
            //但是在nacos内部定义了很多注册中心客户端服务端通信的请求体对象，注册中心客户端向服务端发送消息时，会把nacos自己定义的请求体对象转换成Payload对象
            //然后使用grpc客户端的存根对象把Payload对象发送给grpc服务器
            Payload grpcRequest = GrpcUtils.convert(serverCheckRequest);
            //发送消息给服务器并接受响应，这里和我之前展示的例子一样了
            ListenableFuture<Payload> responseFuture = requestBlockingStub.request(grpcRequest);
            //限时等待响应
            Payload response = responseFuture.get(clientConfig.serverCheckTimeOut(), TimeUnit.MILLISECONDS);
            //再把响应转换为nacos自己定义的响应体对象
            return (Response) GrpcUtils.parse(response);
        } catch (Exception e) {
            LoggerUtils.printIfErrorEnabled(LOGGER,
                    "Server check fail, please check server {} ,port {} is available , error ={}", ip, port, e);
            if (this.clientConfig != null && this.clientConfig.tlsConfig() != null && this.clientConfig.tlsConfig()
                    .getEnableTls()) {
                LoggerUtils.printIfErrorEnabled(LOGGER,
                        "current client is require tls encrypted ,server must support tls ,please check");
            }
            return null;
        }
    }
    
}
```

接下来让我简单为大家梳理一下上面代码块的执行流程，**要想调用 connectToServer 方法建立 Grpc 客户端和服务端之间的连接，首先要调用 nextRpcServer 方法，返回要给封装了服务端信息的 ServerInfo 对象；然后把这个对象交给 connectToServer 方法使用，调用 connectToServer 方法建立客户端与服务端之间的连接；在 connectToServer 方法执行的过程中，会首先创建 channel，然后创建单向流存根对象，接着调用 serverCheck 方法，这个方法在调用的过程中会真正建立客户端与服务端的连接，之后又创建了双向流存根对象**；到此为止，整个 connectToServer 方法就结束了。大家可以仔细品味品味客户端与服务端连接建立的过程，如果这个逻辑理解了，接下来大家可以思考这样一个问题：**那就是在 connectToServer 方法中得到的单向流和双向流存根该怎么使用呢**？

## 引入 GrpcConnection 组件，封装发送请求功能

在上一小节我为大家展示的 GrpcClient 类的 connectToServer 方法中，得到了单向流和双向流存根，并且我们也知道只有使用这两个存根对象才可以和服务端进行通信，才能把服务实例注册到服务端。但是 connectToServer 方法中得到了这两个存根对象之后，我们什么也没有做，只是使用单向流存根建立了和服务端的连接，这样一来等 connectToServer 方法结束之后，这两个存根对象就丢失了。这显然是个很严重的问题，所以要想以后继续使用这两个存根对象，就应该把这两个存根对象接收起来，至于怎么接收我也已经想好了。connectToServer 方法不是用来建立和服务端的连接吗？所以我就新定义了一个类，**命名为 GrpcConnection 类，并且我还把在 connectToServer 方法中创建的两个存根对象定义为了 GrpcConnection 类的成员变量，然后继续在 GrpcConnection 类中定义了发送消息给服务器的方法，这样一来，就相当于我把发送消息给服务器的功能单独抽取出来，封装到了 GrpcConnection 组件中**。这个 GrpcConnection 类的内容非常简单，我已经实现完毕了，接下来就展示给大家，请看下面代码块。

```
package com.cqfy.nacos.common.remote.client.grpc;




/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/11
 * @方法描述：该类的对象就是客户端和服务端构建的连接
 */
public class GrpcConnection{


    //连接id
    private String connectionId;

    //grpc底层使用的是channel，所谓创建连接，实际上就是创建了channel对象
    protected ManagedChannel channel;

    //异步处理响应的线程池
    Executor executor;

    //下面这两个都是grpc中的工具了，这个就是用来发送grpc请求给服务器的成员变量
    //单向流存根对象
    protected RequestGrpc.RequestFutureStub grpcFutureServiceStub;
    
    //该对象是用来向grpc服务器回复响应的
    //双向流存根对象
    protected StreamObserver<Payload> payloadStreamObserver;

    public GrpcConnection(Executor executor) {
        this.executor = executor;
    }

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：在第一版本代码中，向服务端发送请求调用的就是这个方法，这个方法使用的是单向流存根对象
     */
    @Override
    public Response request(Request request, long timeouts) throws NacosException {
        //将nacos中的请求转换为protobuf定义的请求对象
        Payload grpcRequest = GrpcUtils.convert(request);
        //发送请求
        ListenableFuture<Payload> requestFuture = grpcFutureServiceStub.request(grpcRequest);
        Payload grpcResponse;
        try {
            if (timeouts <= 0) {
                //不设置超时时间，一直阻塞直到有响应返回
                grpcResponse = requestFuture.get();
            } else {//设置超时时间则在规定时间内等待响应返回
                grpcResponse = requestFuture.get(timeouts, TimeUnit.MILLISECONDS);
            }
        } catch (Exception e) {
            throw new NacosException(NacosException.SERVER_ERROR, e);
        }
        //在这里将protobuf的响应对象转换为nacos中定义的响应对象
        return (Response) GrpcUtils.parse(grpcResponse);
    }


    //设置连接id
    public void setConnectionId(String connectionId) {
        this.connectionId = connectionId;
    }


    //双向流存根回复响应的方法
    public void sendResponse(Response response) {
        Payload convert = GrpcUtils.convert(response);
        payloadStreamObserver.onNext(convert);
    }


    //双向流存根发送请求的方法
    public void sendRequest(Request request) {
        Payload convert = GrpcUtils.convert(request);
        payloadStreamObserver.onNext(convert);
    }


     //关闭当前连接的方法
    public void close() {
        if (this.payloadStreamObserver != null) {
            try {
                payloadStreamObserver.onCompleted();
            } catch (Throwable ignored) {
            }
        }

        if (this.channel != null && !channel.isShutdown()) {
            try {
                this.channel.shutdownNow();
            } catch (Throwable ignored) {
            }
        }
    }


    //设置channel的方法
    public void setChannel(ManagedChannel channel) {
        this.channel = channel;
    }


    //设置单向流存根的方法
    public void setGrpcFutureServiceStub(RequestGrpc.RequestFutureStub grpcFutureServiceStub) {
        this.grpcFutureServiceStub = grpcFutureServiceStub;
    }


    //设置双向流存根的方法
    public void setPayloadStreamObserver(StreamObserver<Payload> payloadStreamObserver) {
        this.payloadStreamObserver = payloadStreamObserver;
    }
    //其他方法暂时省略，在第一版本中用不到

}
```

这个 GrpcConnection 类定义完毕之后，接下来就应该重构一下 GrpcClient 类的 connectToServer 方法，毕竟我们要在 connectToServer 方法中接收两个存根对象。connectToServer 方法我也重构完毕了，请看下面代码块。

```
package com.cqfy.nacos.common.remote.client;



//grpc客户端的实现类，该类中定义了grpc客户端的核心功能，连接服务端的操作都定义在这个类中了
@SuppressWarnings("PMD.AbstractClassShouldStartWithAbstractNamingRule")
public class GrpcClient {


    //连接对象，Connection是接口，我们刚才引入的GrpcConnection是实现类
    protected volatile Connection grpcConn;


     //naocs服务器地址管理器
    private ServerListFactory serverListFactory;

    //Grpc客户端配置类，这个成员变量内部定义了一些默认配置参数
    //逻辑很简单，大家直接看第一版本代码即可
    private final GrpcClientConfig clientConfig;

     //grpc要用到的业务线程池，这个线程池在创建Grpc客户端和服务端channel的时候会用到
    private ThreadPoolExecutor grpcExecutor;



    //其他内容省略

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：连接到gprc服务端的方法，连接成功后，该方法会返回一个Connection对象
     */
    public Connection connectToServer(ServerInfo serverInfo) {
        //接收连接id
        String connectionId = "";
        try {
            //创建grpc要用到的线程池，这个线程池也用在异步发送请求到服务器时，处理回调方法使用的，在回调方法中，处理接收到的服务器响应
            //和sofajraft也有点像
            if (grpcExecutor == null) {
                this.grpcExecutor = createGrpcExecutor(serverInfo.getServerIp());
            }
            
            //得到grpc服务器的端口号，其实就是nacos服务器端口号加上1000的偏移量
            //到这里大家应该意识到了，我们在测试类中定义的注册中心服务端端口号为8848，但这个端口号实际上是tomcat程序的端口号，web控制台访问服务器访问的就是8848这个端口号
            //它并不是grpc服务器的端口号，真正的grpc服务器端口号要在8848的基础上加上1000的偏移量，这里就得到了真正的注册中心服务器端口号
            int port = serverInfo.getServerPort() + rpcPortOffset();
            
            //创建channel
            ManagedChannel managedChannel = createNewManagedChannel(serverInfo.getServerIp(), port);
            
            //在grpc中把下面创建的这个对象叫做存根，在我们的代码中，就是用它来向grpc服务器发送请求的
            //这个是发送单向请求的存根，也就是请求响应模式
            //在这里得到的单向流存根
            RequestGrpc.RequestFutureStub newChannelStubTemp = createNewChannelStub(managedChannel);
            
            //检查连接服务器是否成功，如果大家看过第四章之后，就会知道使用这个单向流存根向服务器第一次发送消息时，就会真正建立客户端和服务端的连接
            Response response = serverCheck(serverInfo.getServerIp(), port, newChannelStubTemp);
            //如果连接成功，这里应该接收到ServerCheckResponse响应
            if (!(response instanceof ServerCheckResponse)) {
                shuntDownChannel(managedChannel);
                return null;
            }
            ServerCheckResponse serverCheckResponse = (ServerCheckResponse) response;
            //获取连接id，这个连接id是从服务端传递过来的
            connectionId = serverCheckResponse.getConnectionId();
            
            
            //创建了一个双向的流式存根，这个存根对象也是grpc框架中的对象，这个对象既可以接收服务器发送过来的消息
            //也可以向服务器发送消息
            BiRequestStreamGrpc.BiRequestStreamStub biRequestStreamStub = BiRequestStreamGrpc.newStub(newChannelStubTemp.getChannel());



            //在这里创建了nacos自己定义的连接对象
            grpcConn = new GrpcConnection(serverInfo, grpcExecutor);
            //设置连接id
            grpcConn.setConnectionId(connectionId);



            
            
            //将grpcConn交给双向流存根使用，在这里就得到了请求观察者对象，现在大家应该知道第二个参数对象代表什么了
            StreamObserver<Payload> payloadStreamObserver = bindRequestStream(biRequestStreamStub, grpcConn);


            //接下来就是向nacos自己定义的请求中设置属性的操作了，持有上面创建的对象，grpcConn才可以向服务端发送消息
            grpcConn.setPayloadStreamObserver(payloadStreamObserver);
            grpcConn.setGrpcFutureServiceStub(newChannelStubTemp);
            grpcConn.setChannel(managedChannel);

             //返回连接对象
            return grpcConn;
            
        } catch (Exception e) {
            LOGGER.error("[{}]Fail to connect to server!,error={}", GrpcClient.this.getName(), e);
        }

        return null;
    }





    //其他内容省略


    
}
```

在上面代码块展示完毕之后，大家应该都清楚了这些存根对象是怎么被收集，又是怎么发挥作用了吧？并且还可以注意到，connectToServer 方法有了返回值，这个返回值就是我们刚才引入的 GrpcConnection 对象。也许没人问我，但我还是要是说，我之所以这么做是有原因的。现在我们的程序其实已经构建得差不多了，作为一个注册中心客户端，真正的通信组件已经引入进来了，它已经可以和服务端建立连接，然后通信，只要接下来我们再把 registerService 方法实现了，那么注册中心客户端注册服务实例到服务单的功能就彻底实现了。但是在我继续实现 registerService 方法之前，我想问问大家，难道大家不觉得这个 GrpcClient 类过于杂乱了吗？**这个类中定义了很多成员变量和方法，虽然这些成员变量和方法都和 Grpc 客户端与服务端建立连接有关，但是有些成员变量和方法似乎并不是那么纯粹**。这个念头一旦产生，就在我脑海里挥之不去了，我越看这个 GrpcClient 类越不顺眼，实际上，**我希望它是一个纯粹和 Grpc 客户端有关的组件，如果可以的话，我希望它只负责和服务端建立连接这个功能，其他的方法和成员变量都交给其他组件管理**。为什么我会有这种念头呢？很简单，因为我考虑到这个框架中每一个组件的方法面面了，就比如说我们正在实现的客户端组件吧，客户端有启动就由关闭，连接有创建就有关闭，关闭的操作很简单，调用一个 shutdown 方法就可以了，但是判断客户端是否要关闭就复杂多了；正常来说，我们肯定也要为客户端引入状态，根据客户端的状态判断客户端是否需要关闭，根据程序的执行状况改变客户端的状况，这些都是我很快就要引入的内容。难道这些内容也要定义在 GrpcClient 这个类中吗？这个类被定义为 GrpcClient，就让它只和 Grpc 框架相关吧，其他的内容可以定义在另外的组件中，只要 GrpcClient 对象可以使用那些组件即可。这么分析下来可能大家还是有些迷惑，不要紧，接下来看我怎么重构 GrpcClient 类就行了。但重构 GrpcClient 类的内容这一章显然是讲不完了，就留到下一章讲解吧。

很抱歉，这一张仍然没有把 nacos 第一版本代码的内容讲完，没别的原因，就是我讲得过于详细了，还请大家理解一下，与其我急匆匆讲过，大家反复看好几遍文章和代码；不如抽丝剥茧把每个组件分析透彻，这样大家一遍就能掌握这些知识。好了朋友们，我们下一章见！