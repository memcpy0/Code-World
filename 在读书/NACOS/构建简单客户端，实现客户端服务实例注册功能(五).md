## 引入 RpcClient，完善客户端通信体系

朋友们，在上一章结尾我说我想重构一下 Grpc 的客户端，也就是 GrpcClient 这个类，原因很直接，那就是我认为在目前的这个 GrpcClient 类中，杂揉了太多内容，我希望这个 GrpcClient 类中的内容只和 Grpc 框架的客户端有关，确切地说：**我希望它是一个纯粹和 Grpc 客户端有关的组件，如果可以的话，我希望它只负责和服务端建立连接这个功能，其他的方法和成员变量都交给其他组件管理**；如果大家对这一点还是不太明白，那我就给大家举一个最明显的例子，在我们目前定义的 GrpcClient 类中，有一个 registerService 方法，想必大家都还有印象吧？这个 registerService 方法就是 nacos 注册中心客户端将服务实例注册到服务端的方法，显然，这个方法是属于 nacos 注册中心客户端的功能，并不是 GrpcClient 的功能。GrpcClient 只和 Grpc 框架有关，客户端和服务端之间要建立网络连接，建立连接的功能就是属于 GrpcClient 客户端对象的，所以这个功能可以定义在 GrpcClient 类中，也就是说，connectToServer 方法应该定义在 GrpcClient 类中，但是把服务实例注册到注册中心服务端的 registerService 方法，显然是注册中心客户端的功能，肯定就不应该定义在 GrpcClient 类中了。

除此之外，请大家再思考一下，在上一章我给 GrpcClient 类定义了 connectToServer 方法，**这个方法就是让 Grpc 客户端和服务端建立连接的，并且这个方法还会返回一个 Connection 连接对象，该对象中封装着两个存根对象，并且封装了向服务端发送请求消息的功能，也就是说，只要得到了这个 Connection 对象，就可以使用这个 Connection 对象向 Grpc 的服务端发送消息了**。但是，connectToServer 能够执行的前提是得到了 Grpc 服务端的网络地址，当然，我把得到 Grpc 服务端网络地址的方法也定义在 GrpcClient 中了，就是 nextRpcServer 方法，并且也把服务地址管理器 ServerListFactory 对象定义在 GrpcClient 类中了。现在我想说的是，我觉得这些内容也不该定义在 GrpcClient 类中，因为我之前说过，ServerListFactory 服务地址管理器管理的是 nacos 注册中心服务端集群的地址，从 ServerListFactory 地址管理器中选出一个服务地址，然后交给 GrpcClient 客户端去建立连接，这似乎是更常规的做法。**总之就是把 nacos 注册中心客户端的功能和 Grpc 客户端的功能完全隔离开**。从层次上来说，会让我们的编码以及框架结构更加清晰。

讲到这里，我想先把话题岔开一下，因为我忽然意识到可能有一些朋友在看完刚才的分析后感到疑惑，**因为我刚才说只要得到了 Connection 这个组件，就可以使用这个组件和 Grpc 服务端展开通信**。这句话本身没有问题，但是有的朋友可能会觉得，Grpc 不是一个远程调用框架吗？**Grpc 服务端提供服务，客户端作为消费者消费服务端提供的服务，也就是执行远程方法调用，调用目标方法，服务端的目标方法处理请求之后把方法结果返回给客户端。这是我们熟悉的远程调用，也就是 RPC 框架的常规流程**。可为什么在我的描述下，Grpc 框架作为一个 RPC 框架，远程调用的功能似乎根本没体现出来，或者说被弱化了很多，反而成为了一个单纯用来通信交流的网络框架，这是怎么回事呢？我想也许有朋友会对这一点感到困惑，所以就借此机会，把这一块的内容展开解释一下。

实际上，在 nacos 中定义了很多请求对象和响应对象，比如说很快我就要为大家实现的注册服务实例到服务端的功能，这个功能就需要一个请求对象和响应对象来实现，请求对象就是 InstanceRequest，注册中心客户端会把服务实例对象封装到 InstanceRequest 对象中，然后把该对象发送给服务端，服务端把服务实例成功存放到注册表之后，就会回复给客户端一个 InstanceResponse 成功响应，这样一来，注册中心客户端注册服务实例的操作就算成功结束了。整个流程看起来和方法的远程调用没有一点关系，别急，听我慢慢讲解。**实际上，在 nacos 框架中，像这样的请求和响应对象还有很多，比如心跳检测功能，就需要客户端发送心跳请求对象给服务端，服务端返回一个心跳响应给客户端；比如客户端订阅服务端服务实例时，就需要发送一个订阅服务实例请求对象给服务端，服务端返回一个服务实例订阅响应给客户端；像这样的请求响应对还有很多，我就不一一列举了**。总之从上面的分析大家就可以看到，nacos 注册中心的客户端与服务端是完全遵循请求响应对来进行通信的，但是它内部使用的是 Grpc 框架啊，这么做的话，就完全体现不出 RPC 远程调用框架的作用了。

这时候就要从 nacos 和 Grpc 功能衔接的细节来看一看了，通过上一章的讲解，我们都知道 Grpc 框架的客户端和服务端要想进行通信，首先得在 proto 文件中把通信的对象定义出来，**而 nacos 使用的 Grpc 框架就把这个消息载体定义为了 Payload 对象，这样一来，nacos 中使用的 Grpc 客户端和服务端通信时，只要发送 Payload 对象即可，当然，Grpc 服务端也要回复 Payload 响应**。这里的逻辑我相信大家都可以理解。接下来有一个很重要的操作：**那就是 nacos 中定义的所有请求响应对，这些对象在被发送给 Grpc 客户端或者服务端时都会被转换为 Payload 对象，并且转换完毕的 Payload 对象会封装请求的具体类型，这样一来就实现了 Grpc 框架的通信**。具体转换的细节我就不再展示了，大家可以直接去我提供的第一版本代码中查看，代码的 com.cqfy.nacos.common.remote.client.grpc 包下有一个 GrpcUtils 工具类，**这个工具类就负责 nacos 定义的请求响应对象和 Grpc 定义的 Payload 对象的互相转化**。

那么实现了 nacos 定义的请求响应对象和 Grpc 定义的 Payload 对象的互相转化之后呢？消息确实可以发送了，但是该怎么处理呢？接下来就要引入消息处理器这个组件了，所谓消息处理器就是一堆 handler。我刚才不是说在 nacos 中定义了很多请求响应对吗？**注册服务实例有 InstanceRequest 请求对象，其他功能有其他请求和响应对象，实际上在 nacos 中每一个功能都有对应的 handler 处理器，或者说每一个请求响应对都有对应的 handler 处理器**。就比如说 InstanceRequest 请求吧，当这个请求被发送到注册中心服务端时，它是被转换成了 Payload 对象发送到服务端的，Payload 对象会封装请求的类型，所以服务端直接可以从 Payload 对象中判断这个请求的类型，然后找到对应的处理器，这个 InstanceRequest 请求对应的处理器就是 InstanceRequestHandler(这个 InstanceRequestHandler 我们目前还不会引入，等实现服务端功能的时候再引入)，根据请求类型得到了对应的处理器后，就会在处理器中执行具体的操作。现在，大家应该清楚了 nacos 客户端服务端交互的原理了吧。

讲到这里，我已经为大家把 nacos 客户端与服务端的交互逻辑讲完了，但这时候还没有解决之前的问题，那就是 Grpc 方法远程调用体现在哪里呢？如果大家的思路稍微灵活一点，肯定就可以想到了，反正客户端发送给服务端的所有请求对象都会转换成 Payload 对象，而 Payload 对象会封装请求的具体类型。**那么我只需要在服务端定义一个 request 方法，这个方法接收 Payload 参数，用这个方法作为 Grpc 服务端提供的服务方法。当 Grpc 服务端使用 request 方法接收到了客户端发送过来的请求时，不管是什么请求，服务端首先会从 Payload 对象中的到请求的具体类型，然后根据请求类型找到请求对应的 handler，接着处理请求即可。当然，既然服务端提供服务的方法明确了，那么客户端远程调用的方法也就确定了，就是这个 request 方法，不管是什么请求，客户端都可以通过 request 方法发送给 Grpc 服务端**。这样一来，岂不是即使用了 Grpc 框架的远程调用功能，也实现了 nacos 客户端与服务端请求响应的通信模式吗？这时候，大家心里的疑惑应该烟消云散了。如果以上逻辑大家都理解了，接下来我就为大家展示一下 nacos 使用的 Grpc 框架定义的 proto 文件，请看下面代码块。

```
syntax = "proto3";

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

option java_multiple_files = true;
option java_package = "com.cqfy.nacos.api.grpc.auto";


//请求元数据对象
message Metadata {
  //请求类型
  string type = 3;
  string clientIp = 8;
  map<string, string> headers = 7;
}


//客户端和服务端的通信对象
message Payload {
  Metadata metadata = 2;
  google.protobuf.Any body = 3;
}

//单向流的远程调用方法
service Request {
  // Sends a commonRequest
  rpc request (Payload) returns (Payload) {
  }
}


//双向流的远程调用方法
service BiRequestStream {
  // Sends a biStreamRequest
  rpc requestBiStream (stream Payload) returns (stream Payload) {
  }
}







//在看完了上面的文件，请大家看一看上一章我在GrpcClient类中定义的serverCheck方法
//这个方法的作用想必大家还有印象，就是使用Grpc客户端向服务端发送一个消息，建立客户端和服务端的连接
private Response serverCheck(String ip, int port, RequestGrpc.RequestFutureStub requestBlockingStub) {
    try {//创建检查服务器连接是否成功的请求，这个请求体是nacos自己定义的，类中就没什么内容，很简单，大家直接去看第一版本代码即可
        ServerCheckRequest serverCheckRequest = new ServerCheckRequest();


        //下面就把请求转换为了Payload对象
        
        //把请求转换为protobuf定义的请求，这里要给大家补充一下，Payload是grpc框架客户端服务端通信的对象
        //但是在nacos内部定义了很多注册中心客户端服务端通信的请求体对象，注册中心客户端向服务端发送消息时，会把nacos自己定义的请求体对象转换成Payload对象
        //然后使用grpc客户端的存根对象把Payload对象发送给grpc服务器
        Payload grpcRequest = GrpcUtils.convert(serverCheckRequest);

        
        //requestBlockingStub是单向流存根，所以直接调用了request目标方法把请求发送给服务端了
        
        
        //发送消息给服务器并接受响应，这里和我之前展示的例子一样了
        ListenableFuture<Payload> responseFuture = requestBlockingStub.request(grpcRequest);
        //限时等待响应
        Payload response = responseFuture.get(clientConfig.serverCheckTimeOut(), TimeUnit.MILLISECONDS);
        //再把响应转换为nacos自己定义的响应体对象
        return (Response) GrpcUtils.parse(response);
    } catch (Exception e) {
        LoggerUtils.printIfErrorEnabled(LOGGER,
                "Server check fail, please check server {} ,port {} is available , error ={}", ip, port, e);
        if (this.clientConfig != null && this.clientConfig.tlsConfig() != null && this.clientConfig.tlsConfig()
                .getEnableTls()) {
            LoggerUtils.printIfErrorEnabled(LOGGER,
                    "current client is require tls encrypted ,server must support tls ,please check");
        }
        return null;
    }
}
```

好了，到此为止题外话就结束了，现在让我们言归正传，让我来为大家阐述最后一个我希望 GrpcClient 类变得纯粹的理由：那就是上一章结尾我引入的客户端状态这个概念，我认为这也是 nacos 注册中心客户端的功能。**因为客户端有启动就由关闭，连接有创建就有关闭，关闭的操作很简单，调用一个 shutdown 方法就可以了，但是判断客户端是否要关闭就复杂多了**；**我们肯定要为客户端引入状态，根据客户端的状态判断客户端是否需要关闭，根据程序的执行状况改变客户端的状况**，这些都是我接下来就要引入的内容。我认为客户端状态的管理并不是 GrpcClient 对象工作，GrpcClient 只需要根据客户端状态执行对应的操作就行了，这个操作也许是关闭真正的连接，也许是和一个新的服务器地址建立新的连接等等；这才是 GrpcClient 应该负责的工作。总而言之，**我现在迫切希望把 nacos 注册中心客户端的工作和 GrpcClient 本身的工作分隔开**，使我的框架从结构上看起来更加清晰，**这时候，就应该引入一个新的组件了，那就是 RpcClient。我把这个 RpcClient 看作 nacos 注册中心的客户端，把 GrpcClient 看作纯粹的 Grpc 的客户端**。

首先从名称上把两个组建的关系划分清晰，**引入了 RpcClient 组件之后，我就可以把 registerService 注册服务实例到服务端的方法定义在 RpcClient 中了，也可以把 serverListFactory 服务地址管理器，以及 nextRpcServer 都定义在 RpcClient 中了，让 GrpcClient 类只保留和创建客户端连接相关的内容**。当然，如果把 registerService 方法定义在 RpcClient 类中，就意味着 nacos 注册中心的客户端需要向服务端发送请求消息，**发送消息的这个功能已经被我们封装到了 Connection 连接对象中了，这也就意味着这个 Connection 连接对象也要定义在 RpcClient 类中**，至于怎么获得这个 Connection 连接对象，这很简单，只需要调用 GrpcClient 的 connectToServer 方法即可。最后，也别忘了引入最重要的客户端状态，**这个我也使用一个枚举类定义好了，那就是 RpcClientStatus 类，很快就会展示给大家**。如果说还有什么要补充的，那就只有 GrpcClient 和 RpcClient 的关系了，这个我也已经想好了，**我决定直接让 GrpcClient 继承 RpcClient，虽然这两个类从职责上可以划分关系，但是从功能上来说，这两个类是无法分割的，毕竟 RpcClient 要使用 GrpcClient 的功能**。否则客户端与服务端连接怎么建立呢？好了，分析就到此为止了，接下来请大家看一看我重构之后的 GrpcClient 和 RpcClient。

在展示 GrpcClient 和 RpcClient 之前，首先让我来为大家展示一下表示客户端状态的枚举类，也就是 RpcClientStatus，请看下面代码块。

```
package com.cqfy.nacos.common.remote.client;

/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/11
 * @方法描述：这个枚举类中的对象表示rpc客户端的状态
 */
public enum RpcClientStatus {

    //等待初始化
    WAIT_INIT(0, "Wait to init server list factory..."),

    //初始化完毕
    INITIALIZED(1, "Server list factory is ready, wait to starting..."),

    //正在启动
    STARTING(2, "Client already staring, wait to connect with server..."),

    //不健康的状态
    UNHEALTHY(3, "Client unhealthy, may closed by server, in reconnecting"),

    //工作中
    RUNNING(4, "Client is running"),

    //停止工作
    SHUTDOWN(5, "Client is shutdown");

    int status;

    String desc;

    RpcClientStatus(int status, String desc) {
        this.status = status;
        this.desc = desc;
    }
}
```

接下来就是重构之后的 GrpcClient 类，请看下面代码块。

```
package com.cqfy.nacos.common.remote.client;



//grpc客户端的实现类，该类中定义了grpc客户端的核心功能，连接服务端的操作都定义在这个类中了
//继承关系体现出来了
@SuppressWarnings("PMD.AbstractClassShouldStartWithAbstractNamingRule")
public class GrpcClient extends RpcClient{


    //Grpc客户端配置类，这个成员变量内部定义了一些默认配置参数
    //逻辑很简单，大家直接看第一版本代码即可
    private final GrpcClientConfig clientConfig;

     //grpc要用到的业务线程池，这个线程池在创建Grpc客户端和服务端channel的时候会用到
    private ThreadPoolExecutor grpcExecutor;


    
    //创建grpcExecutor成员变量的方法
    protected ThreadPoolExecutor createGrpcExecutor(String serverIp) {
        serverIp = serverIp.replaceAll("%", "-");
        //在这里创建了线程池对象，定义了线程池的核心线程数，最大线程数等等
        ThreadPoolExecutor grpcExecutor = new ThreadPoolExecutor(clientConfig.threadPoolCoreSize(),
                clientConfig.threadPoolMaxSize(), clientConfig.threadPoolKeepAlive(), TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(clientConfig.threadPoolQueueSize()),
                new ThreadFactoryBuilder().daemon(true).nameFormat("nacos-grpc-client-executor-" + serverIp + "-%d")
                        .build());
        grpcExecutor.allowCoreThreadTimeOut(true);
        return grpcExecutor;
    }


    
    //创建客户端和服务端之间的channel的方法
    private ManagedChannel createNewManagedChannel(String serverIp, int serverPort) {
        LOGGER.info("grpc client connection server:{} ip,serverPort:{},grpcTslConfig:{}", serverIp, serverPort,JacksonUtils.toJson(clientConfig.tlsConfig()));
        //下面就是设置一些配置参数的操作了
        ManagedChannelBuilder<?> managedChannelBuilder = buildChannel(serverIp, serverPort, buildSslContext())
                .executor(grpcExecutor)
                .compressorRegistry(CompressorRegistry.getDefaultInstance())
                .decompressorRegistry(DecompressorRegistry.getDefaultInstance())
                .maxInboundMessageSize(clientConfig.maxInboundMessageSize())
                .keepAliveTime(clientConfig.channelKeepAlive(), TimeUnit.MILLISECONDS)
                .keepAliveTimeout(clientConfig.channelKeepAliveTimeout(), TimeUnit.MILLISECONDS);
        return managedChannelBuilder.build();
    }




    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：这个方法中都是grpc代码的逻辑，还没有基础过grpc的朋友们可以去找找grpc的资料，简单来说，当grpc的服务端向客户端发送了请求之后，程序就会调用这个方法
     * 确切地说，是调用该方法内部的onNext方法，来处理服务端主动发送过来的请求
     */
    private StreamObserver<Payload> bindRequestStream(final BiRequestStreamGrpc.BiRequestStreamStub streamStub,
                                                      final GrpcConnection grpcConn) {

        return streamStub.requestBiStream(new StreamObserver<Payload>() {

            //Payload就是请求体
            @Override
            public void onNext(Payload payload) {

                //具体逻辑暂时不做实现，这里确实涉及到一些细节，代码长一些，所以我就不在文章中展示了
                //我提供的第一版本代码中注释非常清楚，大家可以直接去我提供的第一版本代码中查看具体逻辑
            }

            @Override
            public void onError(Throwable throwable) {

                 //具体逻辑暂时不做实现
            }

            @Override
            public void onCompleted() {

                 //具体逻辑暂时不做实现
            }
        });
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：这个方法就是用来得到grpc服务端端口号偏移量的方法，这里得到的就是1000，在下面的connectToServer方法中就会用到
     */
    public int rpcPortOffset() {
        return Integer.parseInt(System.getProperty(GrpcConstants.NACOS_SERVER_GRPC_PORT_OFFSET_KEY,
                String.valueOf(Constants.SDK_GRPC_PORT_DEFAULT_OFFSET)));
    }


     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：连接到gprc服务端的方法，连接成功后，该方法会返回一个Connection对象
     */
    @Override
    public Connection connectToServer(ServerInfo serverInfo) {
        //接收连接id
        String connectionId = "";
        try {
            //创建grpc要用到的线程池，这个线程池也用在异步发送请求到服务器时，处理回调方法使用的，在回调方法中，处理接收到的服务器响应
            //和sofajraft也有点像
            if (grpcExecutor == null) {
                this.grpcExecutor = createGrpcExecutor(serverInfo.getServerIp());
            }
            
            //得到grpc服务器的端口号，其实就是nacos服务器端口号加上1000的偏移量
            //到这里大家应该意识到了，我们在测试类中定义的注册中心服务端端口号为8848，但这个端口号实际上是tomcat程序的端口号，web控制台访问服务器访问的就是8848这个端口号
            //它并不是grpc服务器的端口号，真正的grpc服务器端口号要在8848的基础上加上1000的偏移量，这里就得到了真正的注册中心服务器端口号
            int port = serverInfo.getServerPort() + rpcPortOffset();
            
            //创建channel
            ManagedChannel managedChannel = createNewManagedChannel(serverInfo.getServerIp(), port);
            
            //在grpc中把下面创建的这个对象叫做存根，在我们的代码中，就是用它来向grpc服务器发送请求的
            //这个是发送单向请求的存根，也就是请求响应模式
            //在这里得到的单向流存根
            RequestGrpc.RequestFutureStub newChannelStubTemp = createNewChannelStub(managedChannel);
            
            //检查连接服务器是否成功，如果大家看过第四章之后，就会知道使用这个单向流存根向服务器第一次发送消息时，就会真正建立客户端和服务端的连接
            Response response = serverCheck(serverInfo.getServerIp(), port, newChannelStubTemp);
            //如果连接成功，这里应该接收到ServerCheckResponse响应
            if (!(response instanceof ServerCheckResponse)) {
                shuntDownChannel(managedChannel);
                return null;
            }
            ServerCheckResponse serverCheckResponse = (ServerCheckResponse) response;
            //获取连接id，这个连接id是从服务端传递过来的
            connectionId = serverCheckResponse.getConnectionId();
            
            
            //创建了一个双向的流式存根，这个存根对象也是grpc框架中的对象，这个对象既可以接收服务器发送过来的消息
            //也可以向服务器发送消息
            BiRequestStreamGrpc.BiRequestStreamStub biRequestStreamStub = BiRequestStreamGrpc.newStub(newChannelStubTemp.getChannel());



            //在这里创建了nacos自己定义的连接对象
            grpcConn = new GrpcConnection(serverInfo, grpcExecutor);
            //设置连接id
            grpcConn.setConnectionId(connectionId);



            
            
            //将grpcConn交给双向流存根使用，在这里就得到了请求观察者对象，现在大家应该知道第二个参数对象代表什么了
            StreamObserver<Payload> payloadStreamObserver = bindRequestStream(biRequestStreamStub, grpcConn);


            //接下来就是向nacos自己定义的请求中设置属性的操作了，持有上面创建的对象，grpcConn才可以向服务端发送消息
            grpcConn.setPayloadStreamObserver(payloadStreamObserver);
            grpcConn.setGrpcFutureServiceStub(newChannelStubTemp);
            grpcConn.setChannel(managedChannel);

             //返回连接对象
            return grpcConn;
            
        } catch (Exception e) {
            LOGGER.error("[{}]Fail to connect to server!,error={}", GrpcClient.this.getName(), e);
        }

        return null;
    }

    

     //创建单向流存根对象
    protected RequestGrpc.RequestFutureStub createNewChannelStub(ManagedChannel managedChannelTemp) {
        return RequestGrpc.newFutureStub(managedChannelTemp);
    }

    
    

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：检查服务器是否连接成功的方法，其实就是真正创建客户端和服务端连接的方法
     */
    private Response serverCheck(String ip, int port, RequestGrpc.RequestFutureStub requestBlockingStub) {
        try {//创建检查服务器连接是否成功的请求，这个请求体是nacos自己定义的，类中就没什么内容，很简单，大家直接去看第一版本代码即可
            ServerCheckRequest serverCheckRequest = new ServerCheckRequest();
            //把请求转换为protobuf定义的请求，这里要给大家补充一下，Payload是grpc框架客户端服务端通信的对象
            //但是在nacos内部定义了很多注册中心客户端服务端通信的请求体对象，注册中心客户端向服务端发送消息时，会把nacos自己定义的请求体对象转换成Payload对象
            //然后使用grpc客户端的存根对象把Payload对象发送给grpc服务器
            Payload grpcRequest = GrpcUtils.convert(serverCheckRequest);
            //发送消息给服务器并接受响应，这里和我之前展示的例子一样了
            ListenableFuture<Payload> responseFuture = requestBlockingStub.request(grpcRequest);
            //限时等待响应
            Payload response = responseFuture.get(clientConfig.serverCheckTimeOut(), TimeUnit.MILLISECONDS);
            //再把响应转换为nacos自己定义的响应体对象
            return (Response) GrpcUtils.parse(response);
        } catch (Exception e) {
            LoggerUtils.printIfErrorEnabled(LOGGER,
                    "Server check fail, please check server {} ,port {} is available , error ={}", ip, port, e);
            if (this.clientConfig != null && this.clientConfig.tlsConfig() != null && this.clientConfig.tlsConfig()
                    .getEnableTls()) {
                LoggerUtils.printIfErrorEnabled(LOGGER,
                        "current client is require tls encrypted ,server must support tls ,please check");
            }
            return null;
        }
    }


    //当前连接类型为grpc连接
    @Override
    public ConnectionType getConnectionType() {
        return ConnectionType.GRPC;
    }
    
}
```

可以看到，很多成员变量以及方法都被我移除了。接下来就是我新引入的 RpcClient 类，请看下面代码块。

```
package com.cqfy.nacos.common.remote.client;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/11
 * @方法描述：客户端的顶级抽象父类，这个类中定义了一些公共方法，让http客户端和grpc客户端实现类去实现
 */
@SuppressWarnings("PMD.AbstractClassShouldStartWithAbstractNamingRule")
public abstract class RpcClient implements Closeable {


    //naocs服务器地址管理器
    private ServerListFactory serverListFactory;

    //源自引用类表示客户端的状态，客户端状态发生变更时可以安全更新
    protected volatile AtomicReference<RpcClientStatus> rpcClientStatus = new AtomicReference<>(RpcClientStatus.WAIT_INIT);

    //表示和服务器构建的连接对象
    protected volatile Connection currentConnection;

    //最新的收到服务器消息的时间戳
    private long lastActiveTimeStamp = System.currentTimeMillis();

    //rpc客户端的配置类
    protected RpcClientConfig rpcClientConfig;

    //这个集合存放了用于处理服务器发送的请求的处理器
    //服务器可能会向客户端主动发送各种各样的请求，所以就在客户端定义了一些处理器，专门用于处理对应的服务器发送过来的请求
    protected List<ServerRequestHandler> serverRequestHandlers = new ArrayList<>();



    static {
        //这个静态代码块中的操作很重要，在下面这个方法中，就通过spi把所有的Payload接口的实现类
        //也就是那nacos定义的各种请求和响应类加载到程序中了
        PayloadRegistry.init();
    }



    //下面都是一些构造方法了
    public RpcClient(RpcClientConfig rpcClientConfig) {
        this(rpcClientConfig, null);
    }

    public RpcClient(RpcClientConfig rpcClientConfig, ServerListFactory serverListFactory) {
        this.rpcClientConfig = rpcClientConfig;
        this.serverListFactory = serverListFactory;
        //在这里进行rpc客户端的初始化
        init();
    }

    //客户端的初始化方法
    protected void init() {
        //在这里判断nacos服务器地址管理器是否已经被赋值了，如果被赋值，就原子更新客户端状态为初始化完毕
        if (this.serverListFactory != null) {
            rpcClientStatus.compareAndSet(RpcClientStatus.WAIT_INIT, RpcClientStatus.INITIALIZED);
            LoggerUtils.printIfInfoEnabled(LOGGER, "RpcClient init in constructor, ServerListFactory = {}",
                    serverListFactory.getClass().getName());
        }
    }

    //设置服务地址管理器的方法，在我为大家提供的代码中，调用的就是这个方法
    public RpcClient serverListFactory(ServerListFactory serverListFactory) {
        //先判断客户端状态是否为等待初始化
        if (!isWaitInitiated()) {
            return this;
        }
        this.serverListFactory = serverListFactory;
        //在这里把客户端状态给更新为初始化完毕
        rpcClientStatus.compareAndSet(RpcClientStatus.WAIT_INIT, RpcClientStatus.INITIALIZED);
        LoggerUtils.printIfInfoEnabled(LOGGER, "[{}] RpcClient init, ServerListFactory = {}", rpcClientConfig.name(),
                serverListFactory.getClass().getName());
        return this;
    }
    

    //下面几个就是判断客户端处理什么状态的方法，逻辑简单，就不一一注释了
    public boolean isWaitInitiated() {
        return this.rpcClientStatus.get() == RpcClientStatus.WAIT_INIT;
    }


    public boolean isRunning() {
        return this.rpcClientStatus.get() == RpcClientStatus.RUNNING;
    }


    public boolean isShutdown() {
        return this.rpcClientStatus.get() == RpcClientStatus.SHUTDOWN;
    }

    //得到客户端与服务端连接的连接类型，这里得到的肯定是grpc连接类型，由子类去实现
    public abstract ConnectionType getConnectionType();


     //得到客户端名称
    public String getName() {
        return rpcClientConfig.name();
    }


    //得到服务地址管理器
    public ServerListFactory getServerListFactory() {
        return serverListFactory;
    }


    //通过服务地址管理器得到下一个nacos服务器地址的方法
    protected ServerInfo nextRpcServer() {
        String serverAddress = getServerListFactory().genNextServer();
        return resolveServerInfo(serverAddress);
    }



    //得到当前连接的nacos服务器地址的方法
    protected ServerInfo currentRpcServer() {
        String serverAddress = getServerListFactory().getCurrentServer();
        return resolveServerInfo(serverAddress);
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：解析nacos服务器地址的方法
     */
    @SuppressWarnings("PMD.UndefineMagicConstantRule")
    private ServerInfo resolveServerInfo(String serverAddress) {
        //使用正则表达式移除服务地址中的协议部分
        Matcher matcher = EXCLUDE_PROTOCOL_PATTERN.matcher(serverAddress);
        if (matcher.find()) {
            serverAddress = matcher.group(1);
        }
        //下面就是得到具体的ip地址和端口号的操作了
        String[] ipPortTuple = InternetAddressUtil.splitIPPortStr(serverAddress);
        int defaultPort = Integer.parseInt(System.getProperty("nacos.server.port", "8848"));
        String serverPort = CollectionUtils.getOrDefault(ipPortTuple, 1, Integer.toString(defaultPort));
        //最后把地址封装在ServerInfo对象中
        return new ServerInfo(ipPortTuple[0], NumberUtils.toInt(serverPort, defaultPort));
    }


     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：连接服务器的方法，该方法由子类实现
     */
    public abstract Connection connectToServer(ServerInfo serverInfo) throws Exception;

    
    
}
```

上面代码块中的内容虽然有点多，但展示的都是一些简单的小方法，所以具体逻辑我就不再讲解了，大家简单看看就行。但是，就算大家把上面代码块中的内容来来回回看好几遍，恐怕也找不到两个最重要的内容，**那就是 currentConnection 成员变量怎么赋值呢？还有就是怎么把消息发送给服务器呢**？大家找不到很正常，因为我根本就没有实现这两个功能。接下来，我想跟大家分析一下这两个功能该如何实现，并且实现的时候要注意什么细节。首先来看看 currentConnection 成员变量怎么赋值吧，currentConnection 其实就相当于客户端到服务端的连接，这个对象中封装了存根对象，可以向服务端发送请求消息。而得到 currentConnection 这个对象的方法非常简单，在上面的 RpcClient 类中，我定义了一个 connectToServer 抽象方法，这个方法就是用来获得客户端与服务端连接的方法，这个方法已经在 RpcClient 的子类 GrpcClient 中实现了，所以我只需要在 RpcClient 中直接调用子类的方法就可以得到这个连接了。那这个 connectToServer 方法要在什么时候调用呢？**我的理解是一旦 connectToServer 方法被调用，就意味着注册中心客户端与服务端的连接就建立了，客户端就启动了，可以开始工作了，所以我想在 RpcClient 类中定义一个 start 方法，这个方法就是用来启动 RpcClient 客户端的，在 strat 方法中，调用 connectToServer 方法建立客户端与服务端之间的连接**。我想这个逻辑还是比较容易理解的，当客户端启动之后，还可以执行更新客户端状态的操作，这些都可以在 start 方法中执行。当然，这里其实还有一个细节，因为 RpcClient 已经持有了服务地址管理器，也就是 serverListFactory 对象，而 serverListFactory 服务地址管理器管理了注册中心集群中所有服务器的地址，当然，如果没有搭建集群，这个管理器中只管理一个服务地址。

请大家想一想，**如果在客户端与服务端建立连接的时候，通过服务地址管理器得到了一个服务地址，然后客户端根据这个地址去访问服务端，结果连接没有建立成功，这种情况也不是不可能出现。所以我们可以定义一个连接重试次数，在 start 方法启动 nacos 客户端的过程中，如果第一次没有连接成功，那就再通过 serverListFactory 得到一个新的服务地址，再去和服务端建立连接，直到连接建立成功或者达到连接重试次数的限制**。这个操作想必是很容易理解的，这就是我要实现的 start 方法的完整逻辑。

好了，start 方法分析完了，接下来让我们讨论一下 RpcClient 对象怎么把请求消息发送给服务器。这个就更容易实现了，**我直接在 RpcClient 类中定义一个 request 方法，然后在其内部调用 Connection 连接对象的 request 方法，不就可以把请求消息发送给服务端了吗**？我在上一章已经为大家引入了 Connection，所以就不再重复展示 Connection 的代码了。因为网络环境是波动的，如果大家希望这个 request 方法实现得也严谨一些，也可以定义一个请求发送的重试次数，**如果请求重试次数用完了，请求仍然没有发送成功，这可能就意味着客户端与服务端的连接出现问题了，这时候就要重新建立客户端与服务端的连接**。好了，到此为止，RpcClient 对象把请求消息发送给服务器的方法也分析完了，接下来就请大家看一下我重构之后的代码，请看下面代码块。

```
package com.cqfy.nacos.common.remote.client;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/11
 * @方法描述：客户端的顶级抽象父类，这个类中定义了一些公共方法，让http客户端和grpc客户端实现类去实现
 */
@SuppressWarnings("PMD.AbstractClassShouldStartWithAbstractNamingRule")
public abstract class RpcClient implements Closeable {


    //naocs服务器地址管理器
    private ServerListFactory serverListFactory;

    //源自引用类表示客户端的状态，客户端状态发生变更时可以安全更新
    protected volatile AtomicReference<RpcClientStatus> rpcClientStatus = new AtomicReference<>(RpcClientStatus.WAIT_INIT);

    //表示和服务器构建的连接对象
    protected volatile Connection currentConnection;

    //最新的收到服务器消息的时间戳
    private long lastActiveTimeStamp = System.currentTimeMillis();

    //rpc客户端的配置类
    protected RpcClientConfig rpcClientConfig;

    //这个集合存放了用于处理服务器发送的请求的处理器
    //服务器可能会向客户端主动发送各种各样的请求，所以就在客户端定义了一些处理器，专门用于处理对应的服务器发送过来的请求
    protected List<ServerRequestHandler> serverRequestHandlers = new ArrayList<>();



    static {
        //这个静态代码块中的操作很重要，在下面这个方法中，就通过spi把所有的Payload接口的实现类
        //也就是那nacos定义的各种请求和响应类加载到程序中了
        PayloadRegistry.init();
    }




    //省略其他内容


    //设置服务地址管理器的方法，在我为大家提供的代码中，调用的就是这个方法
    public RpcClient serverListFactory(ServerListFactory serverListFactory) {
        //先判断客户端状态是否为等待初始化
        if (!isWaitInitiated()) {
            return this;
        }
        this.serverListFactory = serverListFactory;
        //在这里把客户端状态给更新为初始化完毕
        rpcClientStatus.compareAndSet(RpcClientStatus.WAIT_INIT, RpcClientStatus.INITIALIZED);
        LoggerUtils.printIfInfoEnabled(LOGGER, "[{}] RpcClient init, ServerListFactory = {}", rpcClientConfig.name(),
                serverListFactory.getClass().getName());
        return this;
    }

    

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：启动rpc客户端的方法
     */
    public final void start() throws NacosException {
        
        //因为本类的serverListFactory方法会比start方法先调用，具体逻辑很快就会展示，在serverListFactory方法中会将客户端状态更新为初始化完毕状态
        //这就意味着这个时候客户端其实已经初始化完毕了，所以当前的客户端状态应该为初始化完毕状态，这里要做一个状态的判断
        boolean success = rpcClientStatus.compareAndSet(RpcClientStatus.INITIALIZED, RpcClientStatus.STARTING);
        if (!success) {
            //状态错误直接退出当前方法
            return;
        }
        
        
        //定义一个连接对象，用来接收客户端到服务端的连接
        Connection connectToServer = null;
        //更新客户端状态为开始状态
        rpcClientStatus.set(RpcClientStatus.STARTING);
        
        
        //获取连接重试次数
        int startUpRetryTimes = rpcClientConfig.retryTimes();
        //在循环中开始连接服务端，循环次数就为连接重试次数
        while (startUpRetryTimes >= 0 && connectToServer == null) {
            try {
                //连接失败一次，则次数减1
                startUpRetryTimes--;
                
                //因为上一次连接失败了，肯定是nacos服务端有问题，所以这里从服务地址管理器中获得一个新的服务端地址
                //ServerInfo是一个内部类，里面封装nacos服务器地址信息
                ServerInfo serverInfo = nextRpcServer();
                
                LoggerUtils.printIfInfoEnabled(LOGGER, "[{}] Try to connect to server on start up, server: {}",rpcClientConfig.name(), serverInfo);
                
                //连接服务器，连接成功则返回一个连接对象
                connectToServer = connectToServer(serverInfo);
            } catch (Throwable e) {
                
                LoggerUtils.printIfWarnEnabled(LOGGER,
                        "[{}] Fail to connect to server on start up, error message = {}, start up retry times left: {}",
                        rpcClientConfig.name(), e.getMessage(), startUpRetryTimes, e);
            }
        }

        //连接重试也失败的逻辑我并没有给大家展示，因为那是第二版本代码的功能，下一章才会为大家讲解
        
        //下面是连接成功的逻辑
        
        if (connectToServer != null) {
            LoggerUtils.printIfInfoEnabled(LOGGER, "[{}] Success to connect to server [{}] on start up, connectionId = {}",
                    rpcClientConfig.name(), connectToServer.serverInfo.getAddress(),
                    connectToServer.getConnectionId());
            
            //走到这里意味着连接成功，给currentConnection赋值即可
            this.currentConnection = connectToServer;
            
            //更新客户端运行状态
            rpcClientStatus.set(RpcClientStatus.RUNNING);
        }
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：客户端向服务端发送请求的方法
     */
    public Response request(Request request) throws NacosException {
        //超时时间，如果用户没有定义，那么默认为3秒，这个3秒默认时间是客户端配置类中定义好的
        return request(request, rpcClientConfig.timeOutMills());
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：真正向服务端发送请求的方法
     */
    public Response request(Request request, long timeoutMills) throws NacosException {
        
        //重试次数初始为0
        int retryTimes = 0;
        //接收响应对象
        Response response;
        //接收异常信息
        Throwable exceptionThrow = null;
        //得到操作的开始时间
        long start = System.currentTimeMillis();
        
        
        //在循环中发送请求到服务器，这里之所以是在循环中执行操作，是因为请求发送有可能失败
        //这时候就要重新发送请求，所以就要在循环中判断是否超过了规定的请求重试次数
        //以及是否超过了请求超时时间，这两个都没有超过才能继续重新发送请求
        while (retryTimes <= rpcClientConfig.retryTimes() && (timeoutMills <= 0 || System.currentTimeMillis() < timeoutMills + start)) {
            
            //定义一个是否等待重新连接服务器的标志
            boolean waitReconnect = false;
            
            try {
                //判断当前客户端是否处于运行状态，对当前连接判空
                if (this.currentConnection == null || !isRunning()) {
                    //有一个为真则意味着客户端与服务端连接出问题，需要进行重连
                    waitReconnect = true;
                    throw new NacosException(NacosException.CLIENT_DISCONNECT,
                            "Client not connected, current status:" + rpcClientStatus.get());
                }
                
                
                //在这里把请求发送给了服务器，并得到了响应
                response = this.currentConnection.request(request, timeoutMills);
                
                
                //下面是一些响应失败要执行的操作
                if (response == null) {
                    throw new NacosException(SERVER_ERROR, "Unknown Exception.");
                }
                if (response instanceof ErrorResponse) {
                    if (response.getErrorCode() == NacosException.UN_REGISTER) {
                        synchronized (this) {
                            waitReconnect = true;
                            if (rpcClientStatus.compareAndSet(RpcClientStatus.RUNNING, RpcClientStatus.UNHEALTHY)) {
                                LoggerUtils.printIfErrorEnabled(LOGGER,
                                        "Connection is unregistered, switch server, connectionId = {}, request = {}",
                                        currentConnection.getConnectionId(), request.getClass().getSimpleName());
                                //这里是异步切换服务地址重新建立连接的操作
                                //switchServerAsync();
                            }
                        }
                    }
                    throw new NacosException(response.getErrorCode(), response.getMessage());
                }
                
                
                //更新客户端最新接收到服务端消息的时间戳
                lastActiveTimeStamp = System.currentTimeMillis();
               
                //走到这里意味着响应没有问题，直接退出当前方法即可
                return response;
            } catch (Throwable e) {
                
                //走到这里说明上面抛出异常了，这意味着客户端与服务端连接有问题，需要重新等待客户端连接服务端
                if (waitReconnect) {
                    try {
                        //让线程睡一会，但是在第一版本代码中，客户端重连服务端的功能我还没有为大家实现，下一版本才会为大家实现
                        //是在定时任务中执行的
                        Thread.sleep(Math.min(100, timeoutMills / 3));
                    } catch (Exception exception) {
                    }
                }
                LoggerUtils.printIfErrorEnabled(LOGGER,"Send request fail, request = {}, retryTimes = {}, errorMessage = {}", request, retryTimes,e.getMessage());
                exceptionThrow = e;
            }
            //自增请求重试次数
            retryTimes++;
        }
       
        
        //走到这里意味着连接出问题了，这时候就要把客户端状态更新为不健康状态，等待客户端异步连接服务器成功
        if (rpcClientStatus.compareAndSet(RpcClientStatus.RUNNING, RpcClientStatus.UNHEALTHY)) {
            //这个异步连接服务器的功能也放在后面实现了
            //switchServerAsyncOnRequestFail();
        }
        if (exceptionThrow != null) {
            throw (exceptionThrow instanceof NacosException) ? (NacosException) exceptionThrow
            : new NacosException(SERVER_ERROR, exceptionThrow);
        } else {
            throw new NacosException(SERVER_ERROR, "Request fail, unknown Error");
        }
    }



    






    //省略其他内容
    
    
}
```

以上就是 RpcClient 启动和发送消息的功能流程，代码注释非常详细，我就不重复讲解了。到此为止，RpcClient 组件我也为大家实现完毕了。看到这里，如果大家仍然心存疑惑也很正常，因为我也想到这一点了，**并且我知道大家疑惑的地方可能在于我实现的这个 RpcClient 类，它的 start 方法要在哪里被调用呢？只有调用了它的 start 方法，nacos 注册中心客户端才算真正启动，客户端与服务端连接才算真的建立了；还有就是 registerService 方法呢？RpcClient 中没有 registerService 方法，只定义 request 方法有什么用呢？RpcClient 怎么把服务实例注册到服务端呢**？**RpcClient 类的对象又该在哪里创建呢？当然，RpcClient 是抽象父类，创建的对象肯定还是其子类 GrpcClient 的对象。**

要解决这几个问题，就要回顾一下之前的知识了。也许大家忘记了我为注册中心客户端引入的第一个组件，就是 NacosNamingService 类，我把这个类的代码搬运过来了，请看下面代码块。

```
package com.cqfy.nacos.client.naming;




//从上面的包名可以看到这个接口实际上在api模块中
//这个类是注册中心客户端的核心类，可以说是注册服务实例，订阅服务实例等等操作的入口类，很多重要的操作都是由这个类的对象发起的
//但在第一版本代码中，该类只提供了注册服务实例到注册中心的方法
@SuppressWarnings("PMD.ServiceOrDaoClassShouldEndWithImplRule")
public class NacosNamingService implements NamingService {

    //从我在测试类为大家提供的代码，大家也能看出来，实际上NacosNamingService类的对象是通过反射创建的
    //反射调用该类的构造方法，并且调用的是参数为Properties的构造方法，而在测试类的Properties中，设置了要创建的NacosNamingService对象
    //的命名空间，这就意味着每一个NacosNamingService对象都有自己的命名空间，下面这个成员变量表示的就是当前NacosNamingService对象的命名空间，在测试类中为创建的
    //NacosNamingService对象设置了默认的命名空间，也就是public
    private String namespace;

    //代理客户端，该客户端就是用来向注册中心服务器发送请求的
    //这里之所以叫代理客户端，是因为NamingClientProxy内部真正向服务器发送消息时，使用的是grpc构建的客户端
    private NamingClientProxy clientProxy;


    //构造方法，该构造方法通过Properties文件创建NacosNamingService对象
    public NacosNamingService(Properties properties) throws NacosException {
        //在这里调用了init方法
        init(properties);
    }


     //初始化NacosNamingService对象的方法，在该方法对NacosNamingService内部要使用的一些组件进行了创建和初始化
    private void init(Properties properties) throws NacosException {
        
        //创建一个Nacos客户端的配置文件类，这个步骤其实就是把在测试类中定义的配置文件中的所有内容都放到了
        //新创建的这个nacosClientProperties配置类中了，以后需要什么配置信息都从这个nacosClientProperties配置类中寻找即可
        //这个NacosClientProperties中定义了属性源提供属性时的优先级，可以点进去看一看，注释非常详细
        final NacosClientProperties nacosClientProperties = NacosClientProperties.PROTOTYPE.derive(properties);
        
        //给当前NacosNamingService对象的命名空间赋值
        this.namespace = InitUtils.initNamespaceForNaming(nacosClientProperties);
        
       //创建代理客户端对象
        this.clientProxy = new NamingClientProxyDelegate(this.namespace,nacosClientProperties);
    }
    

    //注册服务实例到服务端的方法
    @Override
    public void registerInstance(String serviceName, String ip, int port, String clusterName) throws NacosException {
        //这里把服务实例所在的group设置为DEFAULT_GROUP了
        registerInstance(serviceName, Constants.DEFAULT_GROUP, ip, port, clusterName);
    }


    //也是注册服务实例的方法，只不过在这个方法中创建了服务实例对象
    @Override
    public void registerInstance(String serviceName, String groupName, String ip, int port, String clusterName) throws NacosException {
        //创建服务实例对象
        Instance instance = new Instance();
        //设置服务实例对象属性
        instance.setIp(ip);
        instance.setPort(port);
        //权重的作用大家应该都清楚，权重高的服务实例，负载均衡时提供服务的概率更大
        //默认权重为1.0
        instance.setWeight(1.0);
        //设置服务实例所属集群的名称，现在我们是单机部署，并没有引入集群
        instance.setClusterName(clusterName);
        
       //服务实例创建完毕了，然后继续调用下面的registerInstance方法，把服务实例注册到服务端
        registerInstance(serviceName, groupName, instance);
    }




    //注册服务实例的方法，在该方法中，会调用代理客户端的registerService方法，把服务实例注册到服务端
    @Override
    public void registerInstance(String serviceName, String groupName, Instance instance) throws NacosException {
        
        //检查服务实例的各种参数是否合法
        NamingUtils.checkInstanceIsLegal(instance);
        
        //检查服务实例分组名称是否合法，该方法我就不展示了，大家去看我提供的第一版本代码即可
        checkAndStripGroupNamePrefix(instance, groupName);
        
        //在这里用代理客户端把服务实例注册到服务器
        clientProxy.registerService(serviceName, groupName, instance);
    }

   
}
```

可以看到，在这个 NacosNamingService 类中定义了一个 init 方法，也就是我跟大家提到的 init-start 模式，在 init 方法中创建了 NamingClientProxyDelegate 组件。而 NamingClientProxyDelegate 组件我也为大家实现了，请看下面代码块。

```
package com.cqfy.nacos.client.naming.remote;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/10
 * @方法描述：代理客户端，这个客户端内部持有了grpcClientProxy客户端，真正发送服务实例给服务端的操作，是grpcClientProxy客户端执行的
 */
public class NamingClientProxyDelegate implements NamingClientProxy {

    //服务地址管理器
    private final ServerListManager serverListManager;

    //代表grpc客户端的通信组件，这里大家可以思考一下，这个grpcClient客户端对象该怎么创建呢？
    private final GrpcClient grpcClient;


    //定义构造方法
    public NamingClientProxyDelegate(String namespace, NacosClientProperties properties) throws NacosException {

        //在这里创建了ServerListManager服务地址管理器对象
        this.serverListManager = new ServerListManager(properties, namespace);

        
    }
    


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/10
     * @方法描述：进一步注册服务实例到服务端的方法
     */
    @Override
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
        //getExecuteClientProxy就是根据服务实例得到对应的客户端的方法
        //得到了具体的客户端之后，再执行客户端的registerService方法，把服务实例注册到服务端
        getExecuteClientProxy(instance).registerService(serviceName, groupName, instance);
    }


    //根据服务实例得到对应的客户端的方法
    private NamingClientProxy getExecuteClientProxy(Instance instance) {

        //现在就没必要纠结返回哪个客户端通信组件了，因为只剩下grpc通信组件了
        //但是我要补充一点，在我提供的第一版本代码以及nacos的源码中
        //这里有一个判断，那就是判断要注册的instance是否为临时的，如果注册的实例不是临时的
        //并且grpc客户端也不支持注册持久服务实例，这种情况下就会使用http通信组件发送请求
        //具体的逻辑可以去我提供的第一版本代码或者源码中查看，我在第一版本代码中保留了部分http通信组件的代码
        //只不过给注释了，大家可以简单看看
        return grpcClient;
    }
    

}
```

可以看到，在上面的代码块中，NamingClientProxyDelegate 类中定义了 GrpcClient 类型的成员变量，上一章 NamingClientProxyDelegate 类确实就是这么定义的。但是这一章我们已经引入了 RpcClient，并且也明确了 RpcClient 和 GrpcClient 的父子类关系。所以，**现在我希望用 RpcClient 类型的成员变量取代原本的 GrpcClient 类型的成员变量。这样一来，我就可以直接在 NamingClientProxyDelegate 的构造方法中先把 RpcClient 对象创建出来，然后定义一个 start 方法，在 start 方法中调用 RpcClient 的 start 方法。这个时候，注册中心客户端就会真正启动，并且我们也使用 init-start 模式把框架重构完毕了**。接下来就让大家看一下重构之后的 NamingClientProxyDelegate 类，请看下面代码块。

```
package com.cqfy.nacos.client.naming.remote;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/10
 * @方法描述：代理客户端，这个客户端内部持有了grpcClientProxy客户端，真正发送服务实例给服务端的操作，是grpcClientProxy客户端执行的
 */
public class NamingClientProxyDelegate implements NamingClientProxy {

    //服务地址管理器
    private final ServerListManager serverListManager;

    private final RpcClient rpcClient;

    
    //请求超时时间
    private final Long requestTimeout;



    //定义构造方法
    public NamingClientProxyDelegate(String namespace, NacosClientProperties properties) throws NacosException {

        //在这里创建了ServerListManager服务地址管理器对象
        this.serverListManager = new ServerListManager(properties, namespace);

        //从配置类中获得请求超时时间，如果没有定义，就返回默认值-1
        this.requestTimeout = Long.parseLong(properties.getProperty(CommonParams.NAMING_REQUEST_TIMEOUT, "-1"));
        
        //在这里创建了rpc客户端
        //RpcClientTlsConfig.properties(properties.asProperties()得到了一个tls配置类对象，创建rpc客户端时会用到
        //这里最终创建的其实是grpc客户端的对象，rpcClient是抽象父类
        this.rpcClient = RpcClientFactory.createClient(uuid, ConnectionType.GRPC, labels, RpcClientTlsConfig.properties(properties.asProperties()));
       
        //启动rpc客户端
        start(serverListFactory);
    }



    //启动rpc客户端工作的方法
    private void start(ServerListFactory serverListFactory) throws NacosException {
        //把nacos服务地址管理器交给rpc客户端使用，ServerListManager实现了ServerListFactory接口，所以这里传递的是一个接口
        //调用这个方法的时候就会把注册中心客户端的状态更新为初始化状态
        rpcClient.serverListFactory(serverListFactory);
        //启动rpc客户端
        rpcClient.start();
    }


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/10
     * @方法描述：进一步注册服务实例到服务端的方法
     */
    @Override
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
        //getExecuteClientProxy就是根据服务实例得到对应的客户端的方法
        //得到了具体的客户端之后，再执行客户端的registerService方法，把服务实例注册到服务端
        getExecuteClientProxy(instance).registerService(serviceName, groupName, instance);
    }


    //根据服务实例得到对应的客户端的方法
    private NamingClientProxy getExecuteClientProxy(Instance instance) {

        //现在就没必要纠结返回哪个客户端通信组件了，因为只剩下grpc通信组件了
        //但是我要补充一点，在我提供的第一版本代码以及nacos的源码中
        //这里有一个判断，那就是判断要注册的instance是否为临时的，如果注册的实例不是临时的
        //并且grpc客户端也不支持注册持久服务实例，这种情况下就会使用http通信组件发送请求
        //具体的逻辑可以去我提供的第一版本代码或者源码中查看，我在第一版本代码中保留了部分http通信组件的代码
        //只不过给注释了，大家可以简单看看
        return rpcClient;
    }
    

}
```

好了，在展示完上面的代码块之后，大家应该也知道了 GrpcClient 对象的创建时机，以及注册中心的客户端是怎么启动的了。但是现在还有一个问题没有解决，那就是 registerService 方法还是没有实现。这个问题该怎么解决呢？

## 引入 NamingGrpcClientProxy，注册中心客户端构建完毕

在上一小节，我们遗留了一个小尾巴，那就是 RrpcClient 类的 registerService 方法还没有实现。而我之所以迟迟不实现这个方法是有原因的，因为在 nacos 源码中还有一个 NamingGrpcClientProxy 类，这个类是我接下来要为大家引入的最后一个客户端组件。**这个组件从名字上来看也是代理类的意思，并且这个类的对象才会真正被定义为 NamingClientProxyDelegate 类的成员变量。而 RpcClient 实际上是 NamingGrpcClientProxy 类的成员变量**。也就是说，在 NamingClientProxyDelegate 类和 RpcClient 类之间又多了一层代理类，那就是 NamingGrpcClientProxy 类。具体的类结构就变成了下面这样，请看下面代码块。

```
NamingClientProxyDelegate
           |
 NamingGrpcClientProxy
           |
        RpcClient
```

那为什么要引入这个类呢？这时候就要再补充一些额外的知识，实际上在 nacos 注册中心客户端把服务实例注册到服务端时，会根据要注册的服务实例是临时还是持久的特性选择不同的注册方式。**所谓不同的服务方式就是具体发送给注册中心服务器的请求类型不一样，如果注册的是临时服务实例，就会向注册中心服务端发送 InstanceRequest 请求，如果注册的是持久服务实例，那就会向服务器发送 PersistentInstanceRequest 请求**，这个功能就被定义在 NamingGrpcClientProxy 类中了，当然，**在 NamingGrpcClientProxy 代理对象中还定义了其他功能，比如 registerService 这个方法实际上会定义在 NamingGrpcClientProxy 类中，而不是 RpcClient 类中，RpcClient 类已经实现了发送请求到服务器的方法就够了**；还有失败重试的功能，不过这是第三章的知识，到时候大家就知道这个 NamingGrpcClientProxy 类的具体作用了。现在为了注册中心客户端类结构的完善，接下来我就要按照源码的方式重构一下我们的程序。NacosNamingService 类的内容不用改变，重构可以从 NamingClientProxyDelegate 类开始，至于重构的内容也很简单，就是把 NamingClientProxyDelegate 类中的 RpcClient 成员变量替换成 NamingGrpcClientProxy 成员变量，然后把 RpcClient 启动的操作交给 NamingGrpcClientProxy 对象来执行。具体实现请看下面代码块。

首先是 NamingClientProxyDelegate 类。

```
package com.cqfy.nacos.client.naming.remote;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/10
 * @方法描述：代理客户端，这个客户端内部持有了grpcClientProxy客户端，真正发送服务实例给服务端的操作，是grpcClientProxy客户端执行的
 */
public class NamingClientProxyDelegate implements NamingClientProxy {

    //服务地址管理器
    private final ServerListManager serverListManager;

    //这个就是grpc客户端，这里我还要强调一下，实际上在nacos中还有一个http客户端，这个是旧版本的nacos中使用的客户端
    //但是我们是基于最新版本nacos框架来更新课程的，在2.x版本后，nacos引入了grpc框架来实现网络通信，所以我就直接把http客户端暂时移除了
    //不管我们要注册的服务实例是临时的还是持久化的，都可以使用grpc客户端来发送响应的注册服务实例请求给服务端
    private final NamingGrpcClientProxy grpcClientProxy;


    //定义构造方法
    public NamingClientProxyDelegate(String namespace, NacosClientProperties properties) throws NacosException {

        //在这里创建了ServerListManager服务地址管理器对象
        this.serverListManager = new ServerListManager(properties, namespace);

        //在这里创建了NamingGrpcClientProxy对象
        this.grpcClientProxy = new NamingGrpcClientProxy(namespace, serverListManager, properties);
    }
    


    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/10
     * @方法描述：进一步注册服务实例到服务端的方法
     */
    @Override
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
        //getExecuteClientProxy就是根据服务实例得到对应的客户端的方法
        //得到了具体的客户端之后，再执行客户端的registerService方法，把服务实例注册到服务端
        getExecuteClientProxy(instance).registerService(serviceName, groupName, instance);
    }


    //根据服务实例得到对应的客户端的方法
    private NamingClientProxy getExecuteClientProxy(Instance instance) {

        //现在就没必要纠结返回哪个客户端通信组件了，因为只剩下grpc通信组件了
        //但是我要补充一点，在我提供的第一版本代码以及nacos的源码中
        //这里有一个判断，那就是判断要注册的instance是否为临时的，如果注册的实例不是临时的
        //并且grpc客户端也不支持注册持久服务实例，这种情况下就会使用http通信组件发送请求
        //具体的逻辑可以去我提供的第一版本代码或者源码中查看，我在第一版本代码中保留了部分http通信组件的代码
        //只不过给注释了，大家可以简单看看
        return grpcClient;
    }
    

}
```

接下来就是 NamingGrpcClientProxy 类。

```
package com.cqfy.nacos.client.naming.remote.grpc;



/**
 * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
 * @author：陈清风扬，个人微信号：chenqingfengyangjj。
 * @date:2024/4/10
 * @方法描述：grpc客户端，在第一版本代码中，我对这个类的内容做了大量删减，方法也做了很多简化
 */
public class NamingGrpcClientProxy {

    //服务实例的命名空间
    private final String namespaceId;

    //要创建的rpc客户端的唯一标识
    private final String uuid;

    //请求超时时间
    private final Long requestTimeout;

    //rpc客户端
    private final RpcClient rpcClient;

    
     //构造方法，这里面的操作大多比较简单，注释就不加得很详细了
    public NamingGrpcClientProxy(String namespaceId, ServerListFactory serverListFactory, NacosClientProperties properties) throws NacosException {
        
        this.namespaceId = namespaceId;
        
        //创建rpc客户端的唯一标识
        this.uuid = UUID.randomUUID().toString();
        
        //从配置类中获得请求超时时间，如果没有定义，就返回默认值-1
        this.requestTimeout = Long.parseLong(properties.getProperty(CommonParams.NAMING_REQUEST_TIMEOUT, "-1"));
      
        //在这里创建了rpc客户端
        //RpcClientTlsConfig.properties(properties.asProperties()得到了一个tls配置类对象，创建rpc客户端时会用到
        //这里最终创建的其实是grpc客户端的对象，rpcClient是抽象父类
        this.rpcClient = RpcClientFactory.createClient(uuid, ConnectionType.GRPC, labels, RpcClientTlsConfig.properties(properties.asProperties()));
        
        //启动rpc客户端
        start(serverListFactory);
    }

    //启动rpc客户端工作的方法
    private void start(ServerListFactory serverListFactory) throws NacosException {
        //把nacos服务地址管理器交给rpc客户端使用，ServerListManager实现了ServerListFactory接口，所以这里传递的是一个接口
        rpcClient.serverListFactory(serverListFactory);
        //启动rpc客户端
        rpcClient.start();
    }



    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/10
     * @方法描述：注册服务实例到服务端的方法
     */
    @Override
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
        NAMING_LOGGER.info("[REGISTER-SERVICE] {} registering service {} with instance {}", namespaceId, serviceName,
                instance);
        //判断要注册的服务实例是否为临时的
        if (instance.isEphemeral()) {
            //如果是临时的直接调用下面这个方法即可
            registerServiceForEphemeral(serviceName, groupName, instance);
        } else {
            //走到这里意味着要注册的服务实例是持久的，这时候调用下面这个方法即可
            //但在第一版本我还未给大家实现该方法，后面会重构完整
            //doRegisterServiceForPersistent(serviceName, groupName, instance);
        }
    }



     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/10
     * @方法描述：注册临时服务实例到服务端的方法
     */
    private void registerServiceForEphemeral(String serviceName, String groupName, Instance instance) throws NacosException {
        doRegisterService(serviceName, groupName, instance);
    }

    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/10
     * @方法描述：该方法同上，就是在该方法中创建了一个InstanceRequest请求，然后把请求发送给服务端了
     */
    public void doRegisterService(String serviceName, String groupName, Instance instance) throws NacosException {
        //创建了InstanceRequest请求对象，这个对象中封装了各种参数，命名空间，服务名称，分组名称等等
        InstanceRequest request = new InstanceRequest(namespaceId, serviceName, groupName,
                NamingRemoteConstants.REGISTER_INSTANCE, instance);
        //在这里把请求发送给服务端，并且指定了要返回的对象类型
        requestToServer(request, Response.class);
    }



    
    /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/10
     * @方法描述：该方法就是把请求发送给服务端的方法，发送请求之后要返回一个响应对象，该方法的第二个参数就指定了要返回的对象的类型
     */
    private <T extends Response> T requestToServer(AbstractNamingRequest request, Class<T> responseClass)
            throws NacosException {
        //定义一个局部变量，接收服务器响应
        Response response = null;
        try {
            //判断用户是否定义了请求超时时间，如果requestTimeout小于0则意味着没有定义
            //那么发送请求的时候就不必使用超时时间
            //这里就会把请求发送给服务器，并且得到一个响应
            response = requestTimeout < 0 ? rpcClient.request(request) : rpcClient.request(request, requestTimeout);
            //判断响应是否成功，不成功则抛出异常
            if (ResponseCode.SUCCESS.getCode() != response.getResultCode()) {
                throw new NacosException(response.getErrorCode(), response.getMessage());
            }
            //判断响应类型是否与方法指定的参数类型匹配
            if (responseClass.isAssignableFrom(response.getClass())) {
                return (T) response;
            }
            //下面就是异常情况了，大家看看即可
            NAMING_LOGGER.error("Server return unexpected response '{}', expected response should be '{}'",
                    response.getClass().getName(), responseClass.getName());
            throw new NacosException(NacosException.SERVER_ERROR, "Server return invalid response");
        } catch (NacosException e) {
            throw e;
        } catch (Exception e) {
            throw new NacosException(NacosException.SERVER_ERROR, "Request nacos server failed: ", e);
        }
    }

    
}
```

到此为止，注册中心客户端就已经构建完毕了，所有组件也都重构玩成了，接下来让我为大家梳理一下程序的执行流程。

## 梳理程序执行流程

  

程序执行的起点肯定还是要从 NacosNamingService 类开始，**要想执行注册服务实例到注册中心服务端的方法，首先得创建一个 NacosNamingService 对象，而在创建 NacosNamingService 对象的过程中会接着创建 NamingClientProxyDelegate 对象，在创建 NamingClientProxyDelegate 对象的过程中又会创建 NamingGrpcClientProxy 对象，而在创建 NamingGrpcClientProxy 对象的过程中又会创建 RpcClient 对象，当然创建的其实是一个 GrpcClient 对象，只不过是用其父类接收了这个对象。接着就会调用 RpcClient 对象的 start 方法，这时候注册中心客户端就启动完毕，客户端与服务端之间的连接也建立成功了。然后直接调用 NacosNamingService 的 registerInstance 方法把服务实例注册到服务端即可**。

  

当然，**在调用了 NacosNamingService 的 registerInstance 方法之后，程序首先就会来到 NacosNamingService 类中，执行该类的 registerInstance 方法；而在这个 registerInstance 方法中，又会执行 NamingClientProxyDelegate 类的 registerInstance 方法；而在执行 NamingClientProxyDelegate 类的 registerInstance 方法时，程序又回来到 NamingGrpcClientProxy 类中，执行该类的 registerInstance 方法，接着又会掉用该类的 requestToServer 方法，在 requestToServer 方法中，调用 RpcClient 对象的 request 方法，把服务实例信息发送给注册中心服务端**。

到此为止，注册中心客户端启动流程和注册服务实例全流程也就为大家分析完毕了。如果大家愿意的话，可以自己画画图，我是觉得这个流程本身就比较简单，所以就不再画图了。这一章看完之后，大家就可以去看我提供的第一版本代码了，并且可以启动 nacos 源码的服务端，然后启动我提供的第一版本代码中的 NamingExample 测试类，很快大家就可以在 web 控制台上看到服务实力注册成功了。这里我要多说一句，**大家启动了我提供的第一版本代码之后，会发现客户端与服务端建立的连接过一会就会自动断开了，这在我预料之中，因为在第一版本代码中我还没有实现健康检查功能，这是第二版本代码的内容，实现了这个内容之后，客户端和服务端的连接就不会再断开了**。还有一点要补充的就是，整篇文章看完之后，大家应该也发现了，GrpcClient 类中定义的那个请求观察者中的三个方法我一直没有为大家实现，就是下面代码块中的内容，请看下面代码块。

```
     /**
     * @课程描述:从零带你写框架系列中的课程，整个系列包含netty，xxl-job，rocketmq，nacos，sofajraft，spring，springboot，disruptor，编译器，虚拟机等等。
     * @author：陈清风扬，个人微信号：chenqingfengyangjj。
     * @date:2024/4/11
     * @方法描述：这个方法中都是grpc代码的逻辑，还没有基础过grpc的朋友们可以去找找grpc的资料，简单来说，当grpc的服务端向客户端发送了请求之后，程序就会调用这个方法
     * 确切地说，是调用该方法内部的onNext方法，来处理服务端主动发送过来的请求
     */
    private StreamObserver<Payload> bindRequestStream(final BiRequestStreamGrpc.BiRequestStreamStub streamStub,
                                                      final GrpcConnection grpcConn) {

        return streamStub.requestBiStream(new StreamObserver<Payload>() {

            //Payload就是请求体
            @Override
            public void onNext(Payload payload) {

                //具体逻辑暂时不做实现，这里确实涉及到一些细节，代码长一些，所以我就不在文章中展示了
                //客户端处理服务端发送过来请求的逻辑就定义在这里
                //我提供的第一版本代码中注释非常清楚，大家可以直接去我提供的第一版本代码中查看具体逻辑
            }

            @Override
            public void onError(Throwable throwable) {

                 //具体逻辑暂时不做实现
            }

            @Override
            public void onCompleted() {

                 //具体逻辑暂时不做实现
            }
        });
    }
```

这是因为这三个方法内容比较多，也确实包含了一些细节知识，**其中 onNext 方法最为重要，因为客户端处理服务端主动发送过来请求的操作就定义在 onNext 方法中**。但我就不在文章中展示了，如果所有细节都一一展开了讲解，那文章内容就太多太多了，而且逻辑确实也非常简单。大家直接去我提供的第一版本代码中查看即可，里面注释非常详细，我相信大家只要把客户端启动流程看明白了，各个组件的作用掌握了，这三个方法的内容很容易就能看明白，它们和 grpc 没有关系，具体逻辑和 nacos 客户端以及客户端的状态有关。

好了，多的就不说了，大家结合文章查看代码看看就行了。下一章内容会非常少，也特别简单，各位，我们下一章见！