大家好，和内存有关的章节终于结束了，经过了前面几个章节的折磨，我相信大家多少都有点精疲力尽了。所以在这里安排一个章节，专门讲解 IO 事件的处理流程。这一章的知识没有一丁点难度，安排在这里，也是为了让大家休息休息，如果说前面的内容都是计算 2584 * 8874 的结果这种难度的，那这一章的难度就相当于计算 10 * 10 的结果。这节课讲解的知识点并没有多少，第一个知识点就是掌握 Netty 处理 IO 事件的全流程，第二个知识点就是掌握 Netty 对 NIO 原生 Selector 的优化逻辑，第三个知识点就是触发了 NIO 的空轮询 BUG 之后怎么办？可见知识点还是很少的，所以这一章学起来会格外轻松。好了，在开始讲解之前，先让我们回顾一下 Netty 处理 IO 事件的简单流程。

**简单回顾 Netty 处理 IO 事件的流程**

我们自己搭建的 Netty 走到如今的规模，显然经历了太多次重构。但是，几乎所有的重构都是在为我们的 Netty 添加新的功能，或者解决一些并发问题，很少是专门为了对曾经的某个方法，或者某些操作的流程进行重构。比如说我们的 Netty 已经讲了这么多章了，可自从前两章我为大家把单线程执行器的概念引入进来之后，为大家把 NioEventLoop 这个类引入了之后，后面就再也没有回顾过这个类了，我印象中似乎只有在讲解定时任务体系的章节时，才带领着大家重新回顾 NioEventLoop 类的 run 方法和 select 方法，因为引入了定时任务体系，这个类的 run 方法和 select 方法需要做一点小小的改动。现在，我就把陪我们走过了二十多个章节的 NioEventLoop 类的部分代码搬运到这里，请大家简单回顾一下。请看下面代码块。

java

复制代码

`/**  * @Author: PP-jessica  * @Description:该类就是真正执行循环事件的类，nio中selector轮询事件，包括处理事件，都在该类中进行  */ public class NioEventLoop extends SingleThreadEventLoop {     private static final Logger logger = LoggerFactory.getLogger(NioEventLoop.class);     private final Selector selector;     private final SelectorProvider provider;     //得到多路复用器     private Selector openSecector() {         //未包装过的选择器         final Selector unwrappedSelector;         try {             //这里返回的仍然是未包装过后的selector，重构之后就不会只返回它了             unwrappedSelector = provider.openSelector();             return unwrappedSelector;         } catch (IOException e) {             throw new RuntimeException("failed to open a new selector", e);         }     }     //返回Selector     public Selector unwrappedSelector() {         return selector;     }     /**      * @Author: PP-jessica      * @Description:在这里进行选择器的轮询      */     @Override     @SuppressWarnings("InfiniteLoopStatement")     protected void run() {         for (;;) {             try {                 //没有事件就阻塞在这里                 select();                 //如果有事件,就处理就绪事件                 processSelectedKeys();             } catch (Exception e) {                 e.printStackTrace();             } finally {             //执行单线程执行器中的所有任务             runAllTasks();             }         }     }     private void select() throws IOException {         Selector selector = this.selector;         //这里是一个死循环         for (;;){             //如果没有就绪事件，就在这里阻塞3秒             int selectedKeys = selector.select(1000);             //如果有事件或者单线程执行器中有任务待执行，就退出循环             if (selectedKeys != 0 || hasTasks()|| hasScheduledTasks()) {                 break;             }         }     }     private void processSelectedKeys() throws Exception {         //未优化过的处理事件方式         processSelectedKeysPlain(selector.selectedKeys());     }     private void processSelectedKeysPlain(Set<SelectionKey> selectedKeys) throws Exception {         if (selectedKeys.isEmpty()) {             return;         }         Iterator<SelectionKey> i = selectedKeys.iterator();         for (;;) {             final SelectionKey k = i.next();             //还记得channel在注册时的第三个参数this吗？这里通过attachment方法就可以得到nio类的channel             final Object a = k.attachment();             i.remove();             //处理就绪事件             if (a instanceof AbstractNioChannel) {                 processSelectedKey(k,(AbstractNioChannel) a);             }             if (!i.hasNext()) {                 break;             }         }     }     /**      * @Author: PP-jessica      * @Description:既然都引入了channel，那么nioeventloop也可以和socketChannel，serverSocketChannel解耦了      * 这里要重写该方法，现在应该发现了，AbstractNioChannel作为抽象类，既可以调用服务端channel的方法，也可以调用客户端channel的      * 方法，这就巧妙的把客户端和服务端的channel与nioEventLoop解耦了      */     private void processSelectedKey(SelectionKey k,AbstractNioChannel ch) throws Exception {         try {             //获取Unsafe类             final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();             //得到key感兴趣的事件             int ops = k.interestOps();             //如果是连接事件             if (ops == SelectionKey.OP_CONNECT) {                 //移除连接事件，否则会一直通知，这里实际上是做了个减法。位运算的门道，我们会放在之后和线程池的状态切换一起讲                 //这里先了解就行                 ops &= ~SelectionKey.OP_CONNECT;                 //重新把感兴趣的事件注册一下                 k.interestOps(ops);                 //这里要做真正的客户端连接处理                 unsafe.finishConnect();             }             //如果是write事件             if ((ops & SelectionKey.OP_WRITE) != 0) {                //这里就会执行强制刷新的方法，就会把消息从写缓冲区中刷新到socket中                 unsafe.forceFlush();             }             //如果是读事件，不管是客户端还是服务端的，都可以直接调用read方法             //这时候一定要记清楚，NioSocketChannel和NioServerSocketChannel并不会纠缠             //用户创建的是哪个channel，这里抽象类调用就是它的方法             //如果不明白，那么就找到AbstractNioChannel的方法看一看，想一想，虽然那里传入的参数是this，但传入的并不是抽象类本身，想想你创建的             //是NioSocketChannel还是NioServerSocketChannel，是哪个，传入的就是哪个。只不过在这里被多态赋值给了抽象类             //创建的是子类对象，但在父类中调用了this，得到的仍然是子类对象             if (ops ==  SelectionKey.OP_READ) {                 unsafe.read();             }             if (ops == SelectionKey.OP_ACCEPT) {                 unsafe.read();             }         } catch (CancelledKeyException ignored) {             throw new RuntimeException(ignored.getMessage());         }     } }`

虽说只是搬运部分代码，但是 NioEventLoop 这个类的大部分代码都展示得差不多了，毕竟该类的内容并不多。现在我想为大家重新梳理一下该类的核心知识，其实大家应该也能看出来，NioEventLoop 类目前的内容并不多，并且这些内容几乎都是围绕着该类的 run 方法来工作的，而该类的 run 方法实际上会被单线程执行器调用。如果大家还记得单线程执行器是怎么一回事，肯定会明白，在 Netty 中不管是 ServerSocketChannel 代表的服务端，还是被 ServerSocketChannel 管理的 SocketChannel 代表的客户端，其实背后都是依靠着单线程执行器在工作。也就是说服务端和客户端的工作流程是一摸一样的，只不过是处理的 IO 时间不同。服务端的 ServerSocketChannel 处理的只有 OP_ACCEPT IO 事件，而 SocketChannel 则处理 OP_WRITE 和 OP_READ 事件。当然，如果是纯粹的客户端，那么 SocketChannel 还会处理 OP_CONNECT IO 事件。总之一句话总结下来，单线程执行器的存在把客户端和服务端执行流程统一了，但是具体处理的 IO 事件做了细致的区分。所以，我们这一章讲解的 Netty 处理 IO 事件的流程，是在一个更宽广的角度来讲解的，并不仅仅针对于服务端或者客户端。说了这么多，还是让我们尽快看看目前这个 NioEventLoop 类的核心知识吧。

首先，这个类中定义了一个 Selector 成员变量，这很合理，如果没有这个 Selector 多路复用起，还怎么使用 IO 多路复用机制呢？紧接着又定义了一个 SelectorProvider 成员变量，这也很正常，如果没有 SelectorProvider，该怎么得到 Selector 呢？重要的成员变量就这两个，接下来就可以把目光集中在 run 方法上了，这个 run 方法就是单线程执行器一旦启动，就要执行的 run 方法，该方法内有一个死循环，也就是说单线程执行器一旦启动，就永远都停不下来了。当然，这很不合理，一个线程只有启动却没有终止，放在哪个程序中，这种设计都是极其失败的。放到我们自己搭建的 Netty 中也是一样，当然，在最后一个版本我会为大家把终止程序，也就是终止线程的方法加上，这一章就不再讨论这个知识了。

线程进入无限循环后，就会执行 select 方法，接着是 processSelectedKeys 方法，然后是 runAllTasks 方法。然后就进入下一轮循环。 select 方法的逻辑十分简单，请看下面代码块。

java

复制代码

`private void select() throws IOException {     Selector selector = this.selector;     //这里是一个死循环     for (;;){         //如果没有就绪事件，就在这里阻塞1秒         int selectedKeys = selector.select(1000);         //如果有事件或者单线程执行器中有任务待执行，就退出循环         if (selectedKeys != 0 || hasTasks()|| hasScheduledTasks()) {             break;         }     } }`

在上面的代码块中，可以看到 select 方法中也是一个死循环，在该循环中，程序会先判断 Selector 的对象是否检测到 IO 事件了，如果检测到了，就可以打破死循环，继续运行程序了。当然，没有 IO 事件，但是用户向单线程执行器提交了普通任务，或者用户自己提交了定时任务，这两种情况都会促使程序脱离这个死循环。如果 IO 事件和用户提交的任务都没有，那么单线程执行器就会在 select 方法中阻塞 1 秒，醒过来后会继续判断有没有 IO 事件和用户提交的任务，如果仍然没有就再次阻塞 1 秒，循环往复。如果终于检测到 IO 事件，或者用户提交任务了，单线程执行器就会跳出循环，然后执行 run 方法中的 processSelectedKeys 方法了。在 processSelectedKeys 方法中，会先判断究竟有没有 IO 事件，如果没有就直接退出该方法，如果有的话就处理 IO 事件。处理事件的过程就不再讲解了，这部分代码很简单，而且大家也都很熟悉了。接下来就是要处理用户提交给单线程执行器的任务了，单线程执行器中有一个任务队列，用户提交给它的任务，以及定时任务最终都会放到单线程执行器中，所以在 run 这个方法的循环中，最后都会处理用户提交的这些任务。如果没有任务那么就会直接进入下一次循环，而处理所有任务的方法就是下面代码块中展示的这个。请看下面代码块。

java

复制代码

`/**  * @Author: PP-jessica  * @Description:执行所有任务  */ protected boolean runAllTasks() {     assert inEventLoop(Thread.currentThread());     boolean fetchedAll;     boolean ranAtLeastOne = false;     do {         //把到期的定时任务从任务队列取出放到普通任务队列中         fetchedAll = fetchFromScheduledTaskQueue();         //执行任务队列中的任务，该方法返回true，则意味着至少执行了一个任务         if (runAllTasksFrom(taskQueue)) {             //给该变量赋值为true             ranAtLeastOne = true;         }         //没有可执行的定时任务时，就退出该循环     } while (!fetchedAll);     //执行尾部队列任务，这里还暂不实现     //afterRunningAllTasks();     return ranAtLeastOne; }`

上面这个方法是单线程执行器，也就是 SingleThreadEventExecutor 类中的方法。好了，现在 NioEventLoop 类的 run 方法的逻辑已经分析完了，也就意味着单线程执行器的执行逻辑分析完了。不管是为客户端服务的单线程执行器还是为服务端服务的单线程执行器，都要严格遵循这个执行逻辑来工作。也就是说，当一个单线程执行器启动了之后，在 run 方法中，首先会进入到 select 方法中判断是否有 IO 事件到来，如果没有，就会判断单线程执行器中的任务队列中是否有用户提交的任务，如果也没有那么单线程执行器就阻塞 1 秒。醒来后会接着判断，直到可以跳出 select 方法中的循环。然后就会执行 processSelectedKeys 和 runAllTasks 方法，在执行这两个方法的过程中都会根据具体情况判断是否真的有 IO 事件到来或者任务队列中有任务，如果没有的话会直接退出要执行的方法。然后单线程执行器就会进入下一轮循环了。这就是目前 Netty 处理 IO 事件的逻辑。可以看到，虽然我一直说是处理 IO 事件，实际上在单线程执行的流程中，是 IO 事件和用户提交的定时任务并存的，单线程执行器会同时处理这两种不同的任务。稍微想一想，感觉也没什么问题，程序中本来就存在两种任务情况，所以一个单线程执行器就应该同时处理这两种任务情况。但是，我不得不提醒大家，说到底 Netty 是一个以网络通信为主要功能的框架，或者说负责网络通信是这个框架的主要职责。处理用户提交的任务只是捎带脚的事。但现在这个框架把向单线程执行器提交任务的权限暴露给用户了，用户想提交什么任务就提交什么任务，如果用户心血来潮，向单线程执行器中提交了成千上万个任务，那么单线程执行器在 run 方法的循环中每次都要执行 runAllTasks 方法，结果执行这些方法花费了很长时间，导致单线程执行器迟迟不能进入 run 方法的下一次循环，不进入下一次循环就无法执行 select 方法和 processSelectedKeys 方法，也就无法处理 IO 事件了。这样一来麻烦就大了，身为一个网络通信框架，主业明明是实现网络通信，结果却花大量的时间执行用户提交的任务，这不是本末倒置吗？显然，回到我们自己实现的 Netty 框架中，肯定也不能让单线程执行器无限制地执行用户提交的定时任务。如果说有什么方法能解决这个问题，很抱歉，比较高明的方法真的没有，只有一个简单的土方法，那就是对单线程执行器处理用户提交的任务的时间做一些限制。比如，定义一个 ioRatio 成员变量，翻译过来就是 IO 比例的意思。用这个成员变量来控制单线程执行器处理 IO 事件和用户提交的任务的时间比例。这样一来，这个问题就算是解决了。

但是这个问题解决了，也只是第一步，让我们再把目光移回到 run 方法中的 select 方法，在这个方法中，当没有 IO 事件，用户也没有提交任务的时候，就让单线程执行器阻塞 1 秒。这个时间当然是我自己的定义的。但是，请容我说一句，这个时间定义的真的合理吗？能随随便便就定义吗？单线程执行器一旦阻塞可就真的什么活都不能干了呀，众所周知，在 Netty 中，线程是十分宝贵的资源，能让线程干活就绝不能让线程休息，这很像资本家压榨工人。但确实就是这样，请大家想一想，如果现在并没有 IO 事件，用户也没有提交什么任务给单线程执行器，所以我就让线程睡 1 秒，但就在睡得过程中，用户提交了任务了。执行完这个任务可能只需要不到 1 毫秒的时间，但现在线程却要睡整整 1 秒才能继续工作，这何尝不是一种浪费呢？还有最严重的一个问题，那就是当我们引入定时任务体系后，用户是可以向程序提交定时任务的呀，如果单线程执行器刚刚阻塞，下一秒就轮到一个定时任务要执行了，可是线程要阻塞一秒，不就错过这次定时任务的执行了吗？所以，在让单线程执行器阻塞的时候，肯定也要考虑定时任务的情况，单线程执行器可以阻塞，但是必须要在下一个定时任务执行之前醒来，这样才能执行到期的定时任务。总之，还是一句话，能让单线程执行器干活就绝不要让单线程执行器休息。拼命压榨它就对了。

说了这么多，总该展示一下代码，看看上面列出的两个问题用代码怎么解决。下面就是我已经重构好的代码，大家在看代码的时候一定要带着这样一种思路，那就是：单线程执行器要均衡分配处理 IO 事件和用户提交任务的时间，不能无限制执行用户提交的任务，要随时随刻把处理 IO 事件放在首位即可，因为 Netty 本来就是一个网络通信框架，这个是它的首要任务。然后再考虑处理用户提交的任务。run 方法的重构将会帮助我们的程序实现这种功能；同时也要考虑，当程序中的某个时刻既没有 IO 事件，单线程执行器的任务队列中也没有要执行的任务，就要让单线程执行器阻塞，这个阻塞的时间需要考虑到用户提交了定时任务的情况。select 方法的重构将会帮助我们的程序实现该功能。好了，下面就请大家看下面几个代码块。

首先是均衡处理 IO 事件和用户提交任务的时间分配。请看下面代码块。

java

复制代码

`public class NioEventLoop extends SingleThreadEventLoop {     /**      * @Author: PP-jessica      * @Description:单线程执行器执行IO事件的百分比，默认为百分之50，就是IO事件和用户提交的定时任务各执行一半      * 总的来说，就是根据这个百分比，各IO事件和用户提交的任务分配单线程执行器的使用时间      */     private volatile int ioRatio = 50;     /**      * @Author: PP-jessica      * @Description:重构之后的run方法      */     @Override     protected void run() {        //当然，仍然是在一个死循环中         for (;;) {                 //这里把false传进去，其实就是在select方法内部阻塞的意思             	//这里就是重构后的select方法，具体逻辑也在下面展示了                 select(false);                           //下面就是根据具体的IO比来处理IO事件和用户提交的任务了                 //默认的IO占比为百分之50，也就是处理IO事件和用户的任务的事件各位一半，是相等的                 final int ioRatio = this.ioRatio;                 //如果IO占比为百分之百，就先执行IO事件，处理完所有IO事件了，再去执行用户的任务                 //这时候执行用户的任务就没有时间限制了，也是处理完就行                 if (ioRatio == 100) {                     try {                         //先处理IO事件                         processSelectedKeys();                     } finally {                         //最后处理所有用户提交的任务                         runAllTasks();                     }                 } else {                     //走到这里说明IO占比不是百分之百                     //就要具体考虑了，先记录一下处理IO事件的起始时间                     final long ioStartTime = System.nanoTime();                     try {                         //这里仍然是先执行IO事件                         processSelectedKeys();                     } finally {                         //当前得到的纳秒值，减去处理IO事件的起始时间，这就得到了处理IO事件花费的时间                         final long ioTime = System.nanoTime() - ioStartTime;                         //然后就根据占比，得到执行任务的时间                         //假如执行IO时间用了10秒，IO占比为百分之80                         //那就意味着处理任务用百分之20                         //100-80，再用20处以80，得到1/4，处理用户提交的任务的时间乘以这个比例即可                         //这里就是处理IO事件用了10秒，那么处理用户提交的任务就是使用20秒                         //这里大家会发现，runAllTasks方法有了参数，说明这个方法也重构了，重构后的逻辑                         //也放在下面的代码块中了，当然，原来的runAllTasks方法仍然会保留                         //因为程序中还要使用                         runAllTasks(ioTime * (100 - ioRatio) / ioRatio);                     }                 }             }         }     } 	/**      * @Author: PP-jessica      * @Description:真正select的方法，经过重构了，并且在该方法内解决了nio的空轮训bug      * 这里传进来的参数为false      */     private void select(boolean oldWakenUp) throws IOException {         //得到selector         Selector selector = this.selector;         try {             //这里会得到当前时间             long currentTimeNanos = System.nanoTime();             //然后得到下一个定时任务要执行的时间             //大家可以想一下，用户如果提交了定时任务，怎么可能到了执行时间还不执行呢？如果到了定时任务的执行时间             //肯定就不能让单线程执行器在你selector上继续阻塞，应该去执行定时任务了             //这里其实还对应一种情况，如果用户根本没有提交定时任务呢？如果根本没有定时任务             //那么delayNanos方法就会返回1纳秒，具体逻辑可以去我提供的源码中查看             long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);             for (;;) {                 //这里得到的就是selector要在select方法上阻塞的时间，然后把时间换算成毫秒                 long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;                 if (timeoutMillis <= 0) {                     //小于0说明已经超过定时任务要执行的事件了，要立刻去执行定时任务                     //在这里打破循环，就意味着任务队列中有定时任务要被执行了                     break;                 }                 //如果走到这里，说明还没有到达定时任务的执行时间，或者根本就没有定时任务，但这里会判断一下任务队列中是否有普通任务要去执行                 //所以这里又判断了一下                 if (hasTasks()) {                     //selector.selectNow()和selector.select()方法类似，只是不会阻塞，并且返回有事件的个数                     //这个方法执行后，如果有事件，key上其实就有事件可以得到了，所以这个方法break循环了之后                     //在run方法内就可以执行IO事件了                     //由此可以再次看到，这个netty的用户任务和IO事件的执行是很讲究的。会随时随地判断是否有IO事件                     //毕竟是个网络通信框架，如果有IO事件，就会执行IO事件                     //但是大家同时也可以认识到，在这个大的select方法中，已经有两个机会可以直接打破循环了                     //这么做其实也很容易理解，就是能不让单线程执行器阻塞，就尽量不阻塞，有IO事件或者任务的时候，                     //直接去执行就行                     selector.selectNow();                     break;                 }                 //走到这里就说明没有IO事件和用户提交的任务，selector就可以在select方法阻塞了                 //并且会阻塞到下一个定时任务开始执行之前，如果没有定时任务，那么也会timeoutMillis                 //因为就算没有定时任务，timeoutMillis这个值也是大于零的，可以用来当作阻塞时间的                 //这里就是真正让单线程执行器阻塞的方法了                 //当然，上面所说的一切都是建立在没有IO事件的情况下，如果在阻塞的过程中有IO事件                 //就会直接醒过来了，这个selector.select()方法的逻辑是一样的                 //这不过有时间参数的这个方法最多会阻塞这么长的时间，而没有时间参数的方法会一直阻塞到IO事件到来                 int selectedKeys = selector.select(timeoutMillis);                 //走到这里说明短暂的阻塞结束了，又要开始新一轮的判断                 //判断有没有就绪的IO事件，判断有没有用户提交的任务和定时任务，只要有就可以打破循环了                 //如果什么都没有就继续循环，和我们重构前的select方法一样                 //这里看到了，传进来的oldWakenUp一直为false，所以其他三个条件都不成立的时候，线程就会阻塞了                 if (selectedKeys != 0 || oldWakenUp || hasTasks() || hasScheduledTasks()) {                     break;                 }                 //得到当前时间                 long time = System.nanoTime();                 //给currentTimeNanos赋值，用来在下一次循环中计算线程阻塞时间                 currentTimeNanos = time;             }         } catch (CancelledKeyException e) {             if (logger.isDebugEnabled()) {                 logger.debug(CancelledKeyException.class.getSimpleName() + " raised by a Selector {} - JDK bug?",                         selector, e);             }         }     } }`

在上面的代码块中，一共展示了两个方法，第一个是重构后的 run 方法，第二个就是重构后的 select 方法。在 run 方法中，可以看到程序执行的流程和重构之前非常相似，一开始都是进入 select 方法，判断是否应该阻塞，接下来就要视情况看看是否可以处理 IO 事件或者是用户提交的任务。只不过在执行这些流程的时候，需要新定义的成员变量 ioRatio 的帮助，来决定处理 IO 事件和用户提交任务的时间。代码块中的注释已经十分详细了，所以我就不再重复讲解了。在 select 方法中，就实现了单线程执行器根据定时任务到期时间阻塞的功能，这其实很简单，就是判断程序中下一个定时任务的执行时间，然后在没有 IO 事件的时候，让单线程执行器阻塞到该时间即可。当然，可能会有人感到困惑，假如程序中确实有定时任务，但这个定时任务要在一个小时执行，那么单线程执行器在阻塞的过程中，一直没有 IO 事件到来，难道单线程执行器就要一直阻塞下去吗？其实理性分析，在程序中既没有 IO 事件，也没有近期要执行的定时任务，就让单线程执行器阻塞下去也不是不行，反正没活干呀。但是，如果在单线程执行器阻塞的过程中，用户忽然提交了普通任务呢？这个时候单线程执行器还阻塞着呢，难道要等到单线程阻塞结束之后，才执行用户提交的普通任务吗？显然是不能这样的，所以应该再实现一个功能，那就是在用户提交普通任务的时候，可以及时的唤醒正在阻塞的多路复用器。这个功能 Netty 已经实现了。具体的逻辑就在 SingleThreadEventExecutor 这个类的 execute 方法中。具体逻辑请看下面代码块。

java

复制代码

`/**  * @Author: PP-jessica  * @Description:执行器执行任务  */ @Override public void execute(Runnable task) {     if (task == null) {         throw new NullPointerException("task");     }     //这里一定会返回false，因为是其他线程向单线程执行器中提交任务的     boolean inEventLoop = inEventLoop(Thread.currentThread());     //把任务提交到任务队列中     addTask(task);     //启动单线程执行器中的线程     startThread();     //这里还有一个这个操作，比较重要的，就是要调用子类NioEventLoop中的wakeup方法，唤醒selector     //以便执行用户提交的任务     if (!addTaskWakesUp && wakesUpForTask(task)) {         //唤醒seletor         wakeup(inEventLoop);     } }`

可以看到，在用户每次提交了普通任务之后，都会尝试唤醒多路复用器。如果多路复用器正在阻塞，那就直接唤醒了，如果并没有阻塞，那么也不会造成什么影响。更进一步的逻辑我就不再讲解了，大家直接去我提供的源码中学习即可。都很简单，所以我们就点到为止吧。

好了，接下来，就该为大家展示一下重构之后的 runAllTasks 方法。该方法也在 SingleThreadEventExecutor 类中，请看下面代码块。

java

复制代码

`/** * @Author: PP-jessica * @Description:这个是新添加的方法 * 传进来的参数就是执行用户提交的任务所限制的时间 */ protected boolean runAllTasks(long timeoutNanos) {     //先通过下面这个方法，把定时任务添加到普通的任务队列中，这个方法会循环拉取     //也就是说，可能会把很多定时任务拉取到普通任务队列中，直到无法拉取就结束     fetchFromScheduledTaskQueue();     //从普通的任务队列中获得第一个任务     Runnable task = pollTask();     //如果任务为null，直接退出即可     if (task == null) {         return false;     }     //这里通过ScheduledFutureTask.nanoTime()方法计算出第一个定时任务开始执行到当前时间为止经过了多少时间     //然后加上传进来的这个参数，也就是限制用户任务执行的时间，得到的其实就是一个执行用户任务的截止时间     //也就是说，执行用户任务，只能执行到这个时间     final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;     //这个变量记录已经执行了的任务的数量     long runTasks = 0;     //最后一次执行的时间     long lastExecutionTime;     //开始循环执行了     for (;;) {         //执行任务队列中的任务         safeExecute(task);         //执行任务数量加1         runTasks ++;         //十六进制的0x3F其实就是十进制63         //其二进制为111111，下面这里做&运算，如果等于0说明，runTasks的二进制的低6位都为0        //而64的二进制为1000000，也就是说，只有当runTasks到达64的时候，下面这个判断条件就成立了        //这里其实也是做了一个均衡的处理，就是判断看执行了64个用户提交的任务时，看看用户任务        //的截止时间是否到了，如果到达截止时间，就退出循环。        if ((runTasks & 0x3F) == 0) {            //得到最后一次执行完的时间            lastExecutionTime = ScheduledFutureTask.nanoTime();            //这里判断是否超过限制的时间了            if (lastExecutionTime >= deadline) {                //超过就退出循环，没超过就继续执行                break;            }        }        //走到这里就是获取下一个任务        task = pollTask();        if (task == null) {            //如果为null，给最后一次执行完的时间赋值            lastExecutionTime = ScheduledFutureTask.nanoTime();            break;        }    }    //给最后一次执行完的时间赋值    this.lastExecutionTime = lastExecutionTime;    return true; }`

上面代码块中的逻辑也非常清楚，唯一值得注意的一点就是，当单线程执行器执行了 64 个用户提交的任务时，会判断一下执行的时间是否已经超过了 timeoutNanos 规定的时间，除此之外，这个方法中也没有什么重点值得讲解了。所以，到此为止，我就为大家把重构之后的 run 方法和 select 方法讲解完了。也就意味着我已经把 Netty 处理 IO 事件的全流程讲解完了。

**优化 Selector 的方式**

好了，既然 Netty 处理 IO 事件的全流程已经重构完了，那本章最重要的知识点也就讲解完了。接下来，就该看看 Selector 该怎么优化了。当然，这个优化措施并不是我自己想出来了，在没看 Netty 源码之前，我也没想过可以对 Selector 进行优化。看了源码之后，我才意识到，确实可以稍微优化一下，但是要说优化过的 Selector 性能究竟能提升多少，或者说优化的作用有多大，这个我也不好定论。但这好歹是个知识点，所以就列出来简单讲讲。如果对 NIO 稍微熟悉一点人，肯定知道，每当用户把一个 Channel 注册到 Selector 上，都会返回一个特定的 Key，这个 Key 其实就是 SelectionKey，之后程序都会通过这个 SelectionKey 处理 IO 事件。只要使用 NIO 搭建过简单客户端和服务端，我相信肯定就知道这个知识点。当然，在我们的程序中，肯定不会只有一个 Channel 注册到 Selector 上，如果有多个 Channel 都注册到 Selector 上了，肯定就会有多个 SelectionKey 呀。所以，在 NIO 中，IO 事件已经就绪的那些 SelectionKey 都是存放在一个 Set 集合中的。这些 Channel 如果有对应的 IO 事件到来了，就会通过存放在 Set 集合中的这些 SelectionKey 感知到，然后就可以操作了。而 Set 这种数据结构大家肯定也很熟悉了，优缺点我也就不再讲解了，总之，Netty 就是对 NIO 的 Selector 做了一翻优化。优化的手段就是把 Selector 中的 Set 成员变量，替换成 Netty 自己定义的 SelectedSelectionKeySet了。所以，接下来，让我们来看看 NIO 中 Selector 中的部分源码，然后再看看重构之后的代码。

首先是 NIO 中 SelectorImpl 的部分源码，SelectorImpl 是 Selector 的子类，主要成员变量都应以在该类中。请看下面代码块。

java

复制代码

`public abstract class SelectorImpl extends AbstractSelector {     //该成员变量就要被SelectedSelectionKeySet替换     protected Set<SelectionKey> selectedKeys; 	//该成员变量也要被SelectedSelectionKeySet替换     private Set<SelectionKey> publicSelectedKeys;           protected HashSet<SelectionKey> keys;     // Public views of the key sets     private Set<SelectionKey> publicKeys;                      	//构造方法，在构造方法中可以看到，selectedKeys和publicSelectedKeys都是HashSet     protected SelectorImpl(SelectorProvider sp) {         super(sp);         keys = new HashSet<SelectionKey>();         selectedKeys = new HashSet<SelectionKey>();         if (Util.atBugLevel("1.4")) {             publicKeys = keys;             publicSelectedKeys = selectedKeys;         } else {             publicKeys = Collections.unmodifiableSet(keys);             publicSelectedKeys = Util.ungrowableSet(selectedKeys);         }     } }`

Netty 使用 SelectedSelectionKeySet 类的对象替换了 selectedKeys 和 publicSelectedKeys 成员变量，那么 SelectedSelectionKeySet 究竟是什么呢？请看下面代码块。

java

复制代码

`/**  * @Author: PP-jessica  * @Description:这个就是netty自定义的key的集合类，这个类的对象要通过反射设置到selector中，取代原来的SelectionKey  * 在这个key的集合中，会发现使用的是数组存储的key  */ final class SelectedSelectionKeySet extends AbstractSet<SelectionKey> {     SelectionKey[] keys;     int size;     SelectedSelectionKeySet() {         keys = new SelectionKey[1024];     }     @Override     public boolean add(SelectionKey o) {         if (o == null) {             return false;         }         keys[size++] = o;         if (size == keys.length) {             increaseCapacity();         }         return true;     }     @Override     public boolean remove(Object o) {         return false;     }     @Override     public boolean contains(Object o) {         return false;     }     @Override     public int size() {         return size;     }     @Override     public Iterator<SelectionKey> iterator() {         return new Iterator<SelectionKey>() {             private int idx;             @Override             public boolean hasNext() {                 return idx < size;             }             @Override             public SelectionKey next() {                 if (!hasNext()) {                     throw new NoSuchElementException();                 }                 return keys[idx++];             }             @Override             public void remove() {                 throw new UnsupportedOperationException();             }         };     }     void reset() {         reset(0);     }     void reset(int start) {         Arrays.fill(keys, start, size, null);         size = 0;     }     private void increaseCapacity() {         SelectionKey[] newKeys = new SelectionKey[keys.length << 1];         System.arraycopy(keys, 0, newKeys, 0, size);         keys = newKeys;     } }`

可以看到，SelectedSelectionKeySet 类继承了 AbstractSet 抽象类，说明它本身也是个 Set，所以可以替换 Selector 中的两个成员变量。接着我们可以发现，在 SelectedSelectionKeySet 中定义了一个 SelectionKey[] 数组，说明使用数组来存放 SelectionKey 的。所以，到这里大家也就应该明白了，为什么 Netty 要优化 Selector，以及对 Selector 做了什么优化。这就要对比数组和 HashSet 这两种数据结构优缺点了，而且不能还要假设一个特定的场景，比如就在一个高并发的环境中，每个时刻都有大量的 IO 事件已就绪的 SelectionKey 要存放到 Set 中，如果使用 HashSet 来存放这些数据，免不了要频繁计算哈希值，还要插入链表，进行和链表相关的操作。而存放到数组中就十分轻松简单了。再比如说，当容量不够的时候，不管是 HashSet 和数组都会进行扩容，就扩容方面来说，可能还是数组更高效一些。说了这么多，那么 Netty 究竟怎么把 Selector 的那两个成员变量替换成 SelectedSelectionKeySet 类的对象呢？其实使用的方法很简单，就是使用的反射。具体的代码逻辑就在重构后的 NioEventLoop 类的 openSelector 方法中。也就是说，NioEventLoop 类中用来得到多路复用器的 openSelector 方法也被我重构了。这里我就只展示一些关键代码，更加具体的逻辑，就请大家到我提供的源码中学习吧。请看下面代码块。

java

复制代码

`/**      * @Author: PP-jessica      * @Description:selector就是在该方法内被包装的，非常重要      */     private SelectorTuple openSelector() {         //先得到原声Selector          final Selector unwrappedSelector = provider.openSelector();         //使用反射功能得到SelectorImpl的Class文件         Object maybeSelectorImplClass = AccessController.doPrivileged(new PrivilegedAction<Object>() {             @Override             public Object run() {                 try {                     //得到原生selector的实现类                     //private Set<SelectionKey> publicKeys                     //private Set<SelectionKey> publicSelectedKeys                     //上面两个关键属性都在SelectorImpl类中                     return Class.forName(                             "sun.nio.ch.SelectorImpl",                             false,                             PlatformDependent.getSystemClassLoader());                 } catch (Throwable cause) {                     return cause;                 }             }         });         //转换一下，得到selectorImplClass         final Class<?> selectorImplClass = (Class<?>) maybeSelectorImplClass;         //把SelectedSelectionKeySet对象创建好，因为这个对象要使用反射设置到selector中         final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();     	//通过反射得到要被替换的属性         Field selectedKeysField = selectorImplClass.getDeclaredField("selectedKeys");         Field publicSelectedKeysField = selectorImplClass.getDeclaredField("publicSelectedKeys");         //在这里替换成功         selectedKeysField.set(unwrappedSelector, selectedKeySet);         publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);         //省略其他逻辑。。。     }`

好了，优化 Selector 的逻辑我也给大家讲解完毕了，接下来就看看本章最后一个知识点，也就是解决 NIO 的空轮询 BUG。

**解决 NIO 空轮询 BUG**

问题总是一个接着一个，令人心累呀，但没办法，编程如同生活，没有十全十美的人生，也没有十全十美的程序。任何程序，只要想找缺点，总是能找到的，更别说如同破洞一样明显的 BUG。而 NIO 中所谓的空轮询 BUG，就是指在没有任何 IO 事件就绪的情况下，Selector 本来应该阻塞等待，可它却依然拼命的轮询各个 Channel 查看是否有就绪的 IO 事件。这么做显然十分浪费 CPU 资源。那么，Netty 是怎么解决它的呢？很简单，一旦发生空轮询了，就立刻销毁之前的 Selector，然后创建一个新的 Selector，接着再把程序中的 Channel 注册到这个新的 Selector 上来。那么问题又来了，怎么就知道程序中出现了空轮询 BUG 了呢？和之前一样，仍然没有什么十分高明的方法，既然是空轮询，就说明 Selector 执行 select 方法根本不阻塞，也就意味着不怎么耗费时间，所以只需在执行 select 方法时，判断其执行前后时间差是否明显，如果几乎没有时间差，显然就是触发空轮询了。比如说，触发空轮询的次数超过 512 次了，那么就重建 Selector。这就是 Netty 解决空轮询 BUG 的方式。既然都分析到这里了，就不妨再分析一下，怎么得到 select 方法的执行时间差。其实这个问题已经讲过了，本章的第一小节重构 select 方法的时候，就已经展示过相关代码了。其实就是在 int selectedKeys = selector.select(timeoutMillis) 这行代码前后得到时间差就行，并且得到的时间差可以直接和 timeoutMillis 做判断，因为 Selector 本来是要阻塞 timeoutMillis 这么长时间的，如果出发空轮询了，显然就不会阻塞，那么时间差一定比 timeoutMillis 小。这样一来，就和之前的知识串联起来了。所以，接下来，我就直接把最终重构好的 select 方法展示给大家。请看下面代码块。

java

复制代码

	`/**      * @Author: PP-jessica      * @Description:真正select的方法，经过重构了，并且在该方法内解决了nio的空轮训bug      * 这里传进来的参数为false      */     private void select(boolean oldWakenUp) throws IOException {         //得到selector         Selector selector = this.selector;         try {             //记录selector轮训过的次数，这个就是用来判断是否触发空轮训了             int selectCnt = 0;                          //这里会得到当前时间             long currentTimeNanos = System.nanoTime();             long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);             for (;;) {                 //这里得到的就是selector要在select方法上阻塞的时间，然后把时间换算成毫秒                 long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;                 if (timeoutMillis <= 0) {                     //小于0说明已经超过定时任务要执行的事件了，要立刻去执行定时任务                     if (selectCnt == 0) {                         //这里会判断一下，看有没有轮训过IO事件                         //如果一次都没有，就无阻塞的select一下，然后打破循环                         //为什么要select一下呢？大家可以想一想，单线程处理器分配工作其实是很均衡的，同时也能体现出netty框架本身的职责                         //说白了，它的主要职责是网络通信，所以，就算要去执行定时任务，也要先判断一下有没有IO事件                         //执行了下面的方法，如果有IO事件，key其实就可以使用了，就可以去处理IO事件了                         //所以这次打破循环后，单线程执行器就会去处理定时任务和IO事件                         selector.selectNow();                         selectCnt = 1;                     }                     break;                 }                 //如果走到这里，说明还没有到达定时任务的执行时间，或者根本就没有定时任务，但这里会判断一下任务队列中是否有普通任务要去执行                 //所以这里又判断了一下                 if (hasTasks()) {                     selector.selectNow();                     selectCnt = 1;                     break;                 }                 //在这里阻塞                 int selectedKeys = selector.select(timeoutMillis);                 //阻塞完了之后，轮训的次数加1                 selectCnt ++;                 if (selectedKeys != 0 || oldWakenUp || hasTasks() || hasScheduledTasks()) {                     break;                 }                 //得到当前时间                 long time = System.nanoTime();                  //这里的意思是，既然上面的selector已经阻塞结束了，那就看看当前时间减去阻塞结束的时间是不是大于之前得到当前时间                 //如果大于就意味着真的阻塞了那么久，才开始继续向下执行的，如果时间差小于阻塞的时间，就意味着没有阻塞，直接就返回了                 //这就是触发了空轮训bug                 if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {                     selectCnt = 1;                 } else if (selectCnt >= 512) {                     //轮训次数大于阈值了，触发空轮训bug了，所以可以重建selector了                     selector = selectRebuildSelector(selectCnt);                     //重建之后，把轮训次数置为1                     selectCnt = 1;                     break;                 }                                  //给currentTimeNanos赋值，用来在下一次循环中计算线程阻塞时间                 currentTimeNanos = time;             }         } catch (CancelledKeyException e) {             if (logger.isDebugEnabled()) {                 logger.debug(CancelledKeyException.class.getSimpleName() + " raised by a Selector {} - JDK bug?",                         selector, e);             }         }     }`

上面代码块中展示的就是解决空轮询 BUG 的具体逻辑了。注释同样很详细，就不再细讲了，唯一需要值得注意的就是重建 Selector 的方法，也就是 selectRebuildSelector 方法。这个方法在上面代码块中被调用了，我没有讲解，因为其逻辑很长，代码内容比较多，所以我也就不放在文章中讲解了，我提提供的源码中注释非常详细，几乎每一行代码都有注释，大家可以直接对照着源码学习。

好了，这一章就到此为止，我们下一章见。

**总结**

总的来说，本章就解决了三个问题，一是 Netty 处理 IO 事件流程的重构，这其中不仅要考虑处理 IO 事件和用户提交的任务的时间分配，还要考虑有定时任务的情况下单线程执行器应该怎样阻塞。第二就是对 NIO 的 Selector 做了一点微小的优化，第三就是解决了空轮询 BUG，当然，我并没有在代码中呈现全部逻辑，只是讲解了一下大概的思路，所以大家还是要继续从源码中学习。学无止境呀，只要你想学，总有学不完的知识，所以我的建议是合理安排时间，不要总是学习。本来工作已经够累了，下了班还要学习，岂不是累上加累。最好就是把工作的时间用来学习，下班的时间用来娱乐。这样知识也学到了，身体和精神也得到了放松和休息。一举两得。