大家好，在上一章的末尾，我为大家分析了重构之后的 Recycler 存在着什么样的缺陷，并且为大家分析了可能出现的并发问题。当然这个问题还没有解决，这一章我将为大家解决这个问题，并且再次重构我们的对象池，直到它的核心原理和 Netty 的源码一致。好了，话不多说直接开始本章内容的讲解吧。

# 并发问题的解决方法

在开始讲解之前，让我们先来回顾一下上一章讲解的内容。首先，我还是把上一章重构好的 Recycler 类搬运到这里。请看下面的代码块。

java

复制代码

`public abstract class Recycler<T> {     //这个属性就是staack最大的容量值,默认为4096     private static final int DEFAULT_MAX_CAPACITY_PER_THREAD = 4 * 1024;     /**      * @Author: PP-jessica      * @Description:stack默认的初始容量，为256个      */     private static final int INITIAL_CAPACITY = 256;     //抽象方法也重构了     protected abstract T newObject(Handle<T> handle);     //获取线程私有对象池的入口方法     private final FastThreadLocal<Stack<T>> threadLocal = new FastThreadLocal<Stack<T>>() {         //这个就是返回线程私有栈stack的方法，这个不用多讲了吧，这是fastthreadlocal的知识。         @Override         protected Stack<T> initialValue() {             return new Stack<T>(DEFAULT_MAX_CAPACITY_PER_THREAD);         }     };     public final T get() {         Stack<T> stack = threadLocal.get();         //从stack对象池中取出被缓存的DefaultHandle对象         DefaultHandle<T> handle = stack.pop();          //如果DefaultHandle为null，说明对象池中还没有缓存的对象         if (handle == null) {             //首先创建一个handle             handle = stack.newHandle();             //然后创建一个新的要被线程使用的对象交给handle             //这里调用了newObject方法，这个方法就是Recycler类中需要重写的一个抽象方法             //要把哪个类的对象设置成对象池模式，就在哪个类中创建Recycler对象，然后重写newObject方法。             handle.value = newObject(handle);         }         //返回对象         return (T) handle.value;     }     //内部接口      public interface Handle<T> {      //回收对象的方法         void recycle(T object);          }     //内部接口的静态实现类     static final class DefaultHandle<T> implements Handle<T> {             //handle中是要持有stack的，这个很重要。因为handle要知道这个对象本身是从那个线程的对象池中获得的             private Stack<?> stack;             //这个属性就是要被池化的那个对象             private Object value;             //构造方法             DefaultHandle(Stack<?> stack) {                this.stack = stack;             }                       /**               * @Author: PP-jessica               * @Description:回收对象的方法               */              @Override              public void recycle(Object object) {                  //如果对象为null，直接抛出异常                  if (object != value) {                      throw new IllegalArgumentException("object does not belong to handle");                  }                     //得到对象所属的Stack                 Stack<?> stack = this.stack;                 //把DefaultHandle对象回收到线程对应的stack对象池中                 stack.push(this);                        }              }     static final class Stack<T> {                  //当前stack数组中存储了多少个对象         private int size;         //stack中数组的最大容量         private final int maxCapacity;         //stack中存储对象的数组容器         private DefaultHandle<?>[] elements;         //构造方法         Stack(int maxCapacity) {             //这里INITIAL_CAPACITY是stack中数组的初始容量             elements = new DefaultHandle[INITIAL_CAPACITY];             //最大容量赋值             this.maxCapacity = maxCapacity;         }         //创建一个handle，用来包装要被缓存的对象         DefaultHandle<T> newHandle() {             return new DefaultHandle<T>(this);         }                  //这个就是从stack对象池获取缓存对象的方法，         DefaultHandle<T> pop() {             //得到数组中存储的对象的个数             int size = this.size;             if (size == 0) {                 //如果没有对象，直接返回null                  return null;             }             //要从stack中拿走一个对象，所以要减1             size --;             //存储对象的个数减1正好得到数组存储的最后一个对象的数组下标，取出该下标的对象             DefaultHandle object = elements[size];             //把数组原位置置为null             elements[size] = null;             //取走了一个对象，要重新给size赋值             this.size = size;             //返回该对象             return object;         }         //归还对象的方法          void push(DefaultHandle<?> object) {              //首先得到数组的存储数据的个数             int size = this.size;             //在这里判断一下stack存储的对象的个数是否超过了最大容量             if (size >= maxCapacity) {                 //超过最大容量就不能再回收了                 return;             }             //走到这里说明stack允许存放的对象的个数还未到最大值，但是数组容量不够了，就把数组扩容             if (size == elements.length) {                 //扩容一倍                 elements = Arrays.copyOf(elements, min(size << 1, maxCapacity));             }             //对象真正被回收到stack中了             elements[size] = item;             //增添了一个对象，所以size加1             this.size = size + 1;          }     }      }`

接下来，我再把上一章结尾为大家展示的测试类搬运过来。请看下面代码块。

java

复制代码

`public class RecyclerTest {     public static void main(String[] args) throws Exception {         //主线程从对象池中获得了对象         Book book = Book.newInstance();         //但是这个对象马上就交给一个新的线程使用了，并且在新的线程中被归还给对象池         new Thread(() -> {             //新的线程把对象归还给对象池，这里请大家思考一下，将对象归还给对象池的时候             //是不是直接就把对象归还给1号线程的对象池了？             book.recycle();         }, "Thread-1").start();     } }`

大家肯定还记得，在上一章的结尾，我在例子中引入两个线程，分别是 1 号线程和 2 号线程。在上面的代码块中，就可以把主线程看作 1 号线程，把新创建的线程看作 2 号线程。1 号线程从自己的对象池中获得了对象，这个对象使用完了本应该被 1 号线程回收，结果却由 2 号线程帮忙回收了，该对象当然也会被 2 号线程回收到 1 号线程私有的对象池中。可如果在 2 号线程帮忙 1 号线程回收对象的时候，1 号线程本身也在回收自己的其它对象呢？这时候，就相当有两个线程同时向 1 号线程的 Stack 中的数组容器中存储数据，很有可能出现并发问题。如果考虑得更全面一些，当用户使用程序的时候，故意让十几个线程同时帮忙 1 号线程回收十几个对象，这时候就是十几个线程同时操纵一个数组，并发问题出现的概率就会大大增加。显然这种情况是很有可能出现的，因为你不知道使用你开发的框架的用户，究竟会对你的框架做什么操作。

那么这个问题该怎么解决呢？为了在一定程度上保障程序执行的性能，还不能引入同步锁，这确实是有点棘手。在上一章的末尾我还给了大家一点小小的提示，希望大家继续沿用上一章的思想来解决问题。不知道大家思考的怎么样了，不过还不急，在为大家继续分析并发问题的解决思路之前，我想为大家举一个小小的例子。就比如说，作为程序员的你工作很努力，辛辛苦苦工作了三年，攒了十万块钱。这时候你有十个朋友都来找你借钱，每个人借一万，把你的十万块钱借光了。你也不怎么在乎，反正都是好朋友，借就借了。可是半年之后，你打算娶老婆了，手里没钱，就打算通知你的每个朋友还钱，让你的朋友们把借走的钱都送回来。但你的老婆不让你这么做，如果让你的每一个朋友都来找你还钱，给你一万块钱就走了，那有时候好几个朋友一起过来，可能你还没记清楚是谁还的钱，那些朋友就走了。也许有的人根本就不还钱呢？最后可能借出去十万，只收回来九万。你觉你的老婆事多，怎么能这样揣测你的朋友们呢？但你又很听你老婆的话，你老婆让你亲自去找你的朋友，挨个要钱，而不是让你的朋友们来找你还钱。这样只有你自己在处理这件事情，肯定就不会出错了，如果有哪个朋友暂时换不了钱，你也会记的很清楚，哪些朋友把钱还了，你也都知道。听了老婆的建议，最后你把借出去的十万块钱全收回来了。这个故事告诉我们没事最好别娶什么老婆，娶老婆就会带来麻烦的事，又要担心借出去的钱收不回来，还要亲自去把钱要回来，太麻烦了。当然，你也可以选择不交朋友，不交朋友，不就没有这么多事了吗？当然，你也可以选择根本就不往外借钱，不借钱自然就不用通知朋友们还钱了；其实，你还可以选择根本就不挣钱，或者挣了钱就花掉，自己没钱，想借给朋友也无能为力呀。所以说，如果你是个穷光蛋，就会少了很多很多麻烦。

好了，这只是一个小玩笑，还是让我们言归正传吧。从上面的小例子中可以看到，当很多朋友同时来还钱的时候，就相当于很多线程同时把对象归还给 1 号线程的私有对象池，很容易出现并发问题。要想解决这个并发问题，就可以仿照上面例子中的那种做法，并不让所有线程都来把对象归还给 1 号线程的私有对象池中。而是让帮助回收对象的那些线程暂时保管着 1 号线程的对象，让 1 号线程在某个时机把这些待归还的对象从其他线程中回收过来。这样不就没有并发的情况了吗？既然只有 1 号线程自己在做回收对象的工作，肯定就不会出现并发问题了，对吧？这样一来，就从根源上把问题解决了。

如果这个逻辑大家都能接受的话，现在，最关键的地方就是帮助 1 号线程回收对象的线程，它们在获得了 1 号线程私有对象池中的对象后，该保存到哪里，才能让 1 号线程在合适的时机把它们取走，然后放回到自己的对象池中呢？其实借着这个问题还可以进一步延伸，1 号线程要在什么时候，才可以去帮助它回收对象的那些线程中，把待回收的对象转移到自己的对象池中呢？这个问题其实挺容易回答的，当 1 号线程从自己的对象池中获取对象的时候，发现对象池已经空了，这个时候，就可以去保管着它的对象的其他线程中把那些待回收的对象转移到自己的对象池中。所以，接下来似乎又回到了老问题，那些帮助 1 号线程回收对象的线程，应该把 1 号线程的对象暂时存放到哪里呢？

让我再来为大家分析一下，我们都知道，为了解决对象池中缓存对象可能出现的并发问题，我就运用空间换时间的思想，给每一个线程都创建了一个私有对象池，也就是 Stack。并且，为了让每个对象知道自己是属于哪个对象池，我还特意设计了一个 DefaultHandle 对象，把真正要使用的对象封装到 DefaultHandle 对象中了，而 DefaultHandle 对象持有了自己所属的 Stack 的引用。这样，每一个对象就知道自己究竟是属于哪个 Stack 的了。所以，尽管现在是 2 号线程要帮助 1 号线程回收对象，2 号线程也能知道要被回收的对象究竟是属于哪个 Stack，然后就可以把对象归还给 1 号线程的对象池了。这个逻辑大家肯定都已经很熟悉了，那么，假如现在 2 号线程要帮助 1 号线程回收 10 个对象呢？这 10 个对象都来自 1 号线程，也就是说，这 10 个对象都对应着同一个 Stack。这样一来，我是不是可以用一种很简单的数据结构把这些对象存储到一起呢？既然 10 个线程都对应着同一个 Stack，这不就是很明显的键值对结构吗？无非就是一个 Stack 对应着一个存储着 10 个对象的队列。就像下面代码块展示的那样。请看下面的代码块。

java

复制代码

`//定义了一个Map，这个Map的键就是Stack，也就是要被回收的对象对应的对象池 //而value是一个WeakOrderQueue队列，这个队列是Netty源码中定义好的，我这里直接拿过来了 //类名中有一个weak单词，显然和弱引用有一定的关系，至于为什么和弱引用有关系 //就留给大家去源码中学习吧，我提供的源码中有十分详细的注释 Map<Stack<?>, WeakOrderQueue> map = new Map()<>;`

一旦我们确定了用 Map 来缓存要被回收的对象，那么接下来代码的重构就会变的容易很多了。尽管现在 2 号线程只是帮助 1 号线程回收对象，回收的对象可以用键值对的方式暂时存储在 2 号线程持有的这个 Map 中，那假如 2 号线程不止是帮助 1 号线程回收对象，同时也帮助 3 号线程，4 号线程回收对象呢？我们通通不用怕。只要让 2 号线程多存储几个键值对不就好了？3 号线程的对象也可以用 Stack 和 WeakOrderQueue 的形式存储在 2 号线程的 Map 中呀，4 号线程的对象仍然可以。那么这个 2 号线程的 Map 究竟要创建在哪里？这里我就直说了，就使用 FastThreadLocal 体系的知识，获得 2 号线程私有的 Map，然后把这个要创建的 Map 创建出来，然后存储到线程私有的 Map 中。请看下面的代码块。

java

复制代码

    `/**      * @Author: PP-jessica      * @Description:这里之所以用弱引用来包装key，还是考虑到stack对应的线程挂掉了，弱引用可以帮助垃圾回收      * 对应的value在下一次操作map时也就被相应回收了      * 这里我们先不讲解这个属性是什么，后面自会知晓      */     private static final FastThreadLocal<Map<Stack<?>, WeakOrderQueue>> DELAYED_RECYCLED =             new FastThreadLocal<Map<Stack<?>, WeakOrderQueue>>() {                 @Override                 protected Map<Stack<?>, WeakOrderQueue> initialValue() {                     return new WeakHashMap<Stack<?>, WeakOrderQueue>();                 }             };`

上面的代码块一展示出来，我们所学习的知识点不就和上一章联系起来了吗？这时候，我们终于能明白了，其实在 Netty 的对象池体系中，每一个使用了对象池的线程，都会在线程的私有 Map 中存储两个对象，一个就是 Stack 本身，一个就是键为 Stack，value 为 WeakOrderQueue 的 Map。这个脉络还是十分清晰的。当然，这么说有点不严谨，应该说每个使用了对象池的线程，至少会在线程的私有 Map 中存储两个对象。因为程序中不可能只有一个对象使用了对象池技术呀，现在只有 Book 使用了对象池，线程会为 Book 创建一个私有的对象池，可是程序中还会有其他的对象，如果再来一个 Student 也要使用对象池技术呢？显然就要再为 Student 创建一个私有的对象池，对吧？但是，我们讲了这么多，甚至都引入了 WeakOrderQueue 队列了，但是我仍然没有为大家讲解，被其它线程持有的对象要缓存在哪里，即便引入了 WeakOrderQueue 队列，可它也仅仅是个队列呀，内部必须有可以缓存数据的容器才可以。在 Netty 中，WeakOrderQueue 队列是由一个个 Link 节点构成的，而每一个 Link 节点中，都有一个数组容器用来缓存其他线程的对象池中的对象。接下来，我会为大家展示一个代码块，然后配上一副简图，帮助大家理解这一部分的知识。

首先是 WeakOrderQueue 类的内容，请看下面代码块。

java

复制代码

`//这里之所以是静态类，是因为该类也是Recycler的内部类 private static final class WeakOrderQueue {     //这里可以看到，Link其实就是WeakOrderQueue的一个内部类     static final class Link extends AtomicInteger {         //link中用来存储待回收对象的容器，是个数组，该数组的容量为16，是默认的，如果数组满了，就会创建新的link对象，添加到link         //链表的尾部，这里是尾插法。         private final DefaultHandle<?>[] elements = new DefaultHandle[LINK_CAPACITY];         //这个相当于读指针         private int readIndex;         //链表指针，指向下一个link节点         //因为WeakOrderQueue队列是由一个个link节点构成的，所以这里会有下一个link节点的指针         //并且从这里可以看出来，WeakOrderQueue队列的链表还是单向链表         Link next;     }     //这里又是一个内部类，是WeakOrderQueue队列中的头节点     static final class Head {         //link链表的头节点，该头节点在head节点中         Link link;         //构造方法         Head() {                     }     }     //接下来的这些成员变量就是WeakOrderQueue对象的了     //WeakOrderQueue对象中的head节点，头节点中指向了下一个link节点。链表从head节点内部开始了。     //这个head节点中的link指针指向的下一个link节点，就是转移对象时最先被查找的节点。     //用一句话概括就是，link节点的插入采用的是尾插法，而转移link节点数组中存储的对象，采用的是头查法，从头节点开始查找     //用这种方式避开了并发的情况     private final Head head;     //WeakOrderQueue对象中link链表的尾节点     private Link tail;     //构造方法     private WeakOrderQueue(Stack<?> stack, Thread thread) {         //link链表的尾节点被创建         tail = new Link();         //创建头节点         head = new Head();         //链表中还没有数据，所以暂时让头节点指向尾节点         head.link = tail;     }     /**      * @Author: PP-jessica      * @Description:添加新的未被回收的对象时，从尾节点添加，取走未被回收的对象时，从头节点取走。      */     void add(DefaultHandle<?> handle) {         //找到link链表的尾节点。就像我们上面说的，从尾节点添加被回收对象，从头节点取走         Link tail = this.tail;         //然后就把要帮忙回收的其它线程对象池中的对象添加到尾节点的数组中         //这里就先不实现了，逻辑非常复杂，不是一两句就可以讲清楚的     }     /**      * @Author: PP-jessica      * @Description:这个可以说是WeakOrderQueue类中最重要的一个方法了，这个方法就是把要被回收的对象从WeakOrderQueue节点中      * 移动到原来线程的stack中，该方法是在stack类中的方法内被调用的      */     boolean transfer(Stack<?> dst) {          //要从WeakOrderQueue的link节点中转移数据了          //从头节点开始转移，所以要先获得头节点          Link head = this.head.link;          //后面的逻辑也就先不做实现了，因为太复杂了     } }`

接着是一副简图，为大家展示一下，线程使用对象池之后，用到的所有组件的一个关系。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f34112a670c4dee886ba622f32c5768~tplv-k3u1fbpfcp-jj-mark:1890:0:0:0:q75.awebp#?w=1720&h=887&e=jpg&b=ffffff)

我相信上面的代码块已经把新引入的类的作用给大家解释清楚了。如果 2 号线程要帮助 1 号线程回收对象，这个要被回收的对象会暂时存放到一个键值对为 Stack 和 WeakOrderQueue 的 Map 中，并且这个 Map 对象会存储到 2 号线程的私有 Map 中。其中 Stack 就是要被回收的对象所属的对象池，而 WeakOrderQueue 队列，就是用来存放其他线程的对象池中的对象的。这个 WeakOrderQueue 其实就是一个链表，是由一个个 Link 类型的对象构成的，对象就存储在 Link 对象的数组中。当该链表中存储的其他线程的对象比较多时，一个 Link 对象已经储存不下了，这时候就会创建新的 Link 对象添加到链表中，并且是从链表的尾部开始添加。当 1 号线程要将 2 号线程保存的对象转移到自己的对象池中时，是从 WeakOrderQueue 链表的第一个 Link 节点开始转移的。通过这种方式，巧妙地解决了添加和转移对象时可能产生的并发问题。

# 再次重构 Recycler 类

讲了这么多，接下来就该真正重构 Recycler 类了。是的，显然 Recycler 类还要再重构一次，把新引入的内部类补充完整。但是在重构之前，我想再为大家分析一下，既然现在是在多线程的情况下回收对象，那么在回收对象的时候就必须得知道，当前正在执行回收对象的线程，回收的究竟是不是自己对象池的对象，对吧？这个似乎只能通过线程来判断了，因为对象池就是每一个线程私有的。所以，我想在 Stack 对象中添加一个新的成员变量，那就是这个对象池所属的线程，这样，在回收对象的时候，就可以直接使用当前线程和 Stack 中的线程做对比，以此来判断该对象是要直接放进自己所属的对象池中，还是其他线程的私有 Map 中。请大家带着这个重构的思路，来浏览下面的代码块吧。

java

复制代码

`public abstract class Recycler<T> {     //这个属性就是staack最大的容量值,默认为4096     private static final int DEFAULT_MAX_CAPACITY_PER_THREAD = 4 * 1024;     /**      * @Author: PP-jessica      * @Description:stack默认的初始容量，为256个      */     private static final int INITIAL_CAPACITY = 256;     //抽象方法也重构了     protected abstract T newObject(Handle<T> handle);     //获取线程私有对象池的入口方法     private final FastThreadLocal<Stack<T>> threadLocal = new FastThreadLocal<Stack<T>>() {         //这个就是返回线程私有栈stack的方法         @Override         protected Stack<T> initialValue() {             //在这里把对象池所属的线程传到构造方法中了             return new Stack<T>(DEFAULT_MAX_CAPACITY_PER_THREAD,Thread.currentThread());         }     };     public final T get() {         Stack<T> stack = threadLocal.get();         //从stack对象池中取出被缓存的DefaultHandle对象         DefaultHandle<T> handle = stack.pop();          //如果DefaultHandle为null，说明对象池中还没有缓存的对象         if (handle == null) {             //首先创建一个handle             handle = stack.newHandle();             //然后创建一个新的要被线程使用的对象交给handle             //这里调用了newObject方法，这个方法就是Recycler类中需要重写的一个抽象方法             //要把哪个类的对象设置成对象池模式，就在哪个类中创建Recycler对象，然后重写newObject方法。             handle.value = newObject(handle);         }         //返回对象         return (T) handle.value;     }     //内部接口      public interface Handle<T> {      //回收对象的方法         void recycle(T object);          }     //内部接口的静态实现类     static final class DefaultHandle<T> implements Handle<T> {             //handle中是要持有stack的，这个很重要。因为handle要知道这个对象本身是从那个线程的对象池中获得的             private Stack<?> stack;             //这个属性就是要被池化的那个对象             private Object value;             //构造方法             DefaultHandle(Stack<?> stack) {                this.stack = stack;             }                       /**               * @Author: PP-jessica               * @Description:回收对象的方法               */              @Override              public void recycle(Object object) {                  //如果对象为null，直接抛出异常                  if (object != value) {                      throw new IllegalArgumentException("object does not belong to handle");                  }                     //得到对象所属的Stack                 Stack<?> stack = this.stack;                 //把DefaultHandle对象回收到线程对应的stack对象池中                 stack.push(this);                        }              }     /**      * @Author: PP-jessica      * @Description:这里之所以用弱引用来包装key，还是考虑到stack对应的线程挂掉了，弱引用可以帮助垃圾回收      * 对应的value在下一次操作map时也就被相应回收了      */     private static final FastThreadLocal<Map<Stack<?>, WeakOrderQueue>> DELAYED_RECYCLED =             new FastThreadLocal<Map<Stack<?>, WeakOrderQueue>>() {                 @Override                 protected Map<Stack<?>, WeakOrderQueue> initialValue() {                     return new WeakHashMap<Stack<?>, WeakOrderQueue>();                 }             };     private static final class WeakOrderQueue {             //这里可以看到，Link其实就是WeakOrderQueue的一个内部类             static final class Link extends AtomicInteger {                 //link中用来存储待回收对象的容器，是个数组，该数组的容量为16，是默认的，如果数组满了，就会创建新的link对象，添加到link                 //链表的尾部，这里是尾插法。                 private final DefaultHandle<?>[] elements = new DefaultHandle[LINK_CAPACITY];                 //这个相当于读指针                 private int readIndex;                 //链表指针，指向下一个link节点                 //因为WeakOrderQueue队列是由一个个link节点构成的，所以这里会有下一个link节点的指针                 //并且从这里可以看出来，WeakOrderQueue队列的链表还是单向链表                 Link next;             }                               //这里又是一个内部类，是WeakOrderQueue队列中的头节点             static final class Head {                 //link链表的头节点，该头节点在head节点中                 Link link;                          //构造方法                 Head() {                                 }             }                      //接下来的这些成员变量就是WeakOrderQueue对象的了             //WeakOrderQueue对象中的head节点，头节点中指向了下一个link节点。链表从head节点内部开始了。             //这个head节点中的link指针指向的下一个link节点，就是转移对象时最先被查找的节点。             //用一句话概括就是，link节点的插入采用的是尾插法，而转移link节点数组中存储的对象，采用的是头查法，从头节点开始查找             //用这种方式避开了并发的情况             private final Head head;             //WeakOrderQueue对象中link链表的尾节点             private Link tail;                      //构造方法             private WeakOrderQueue(Stack<?> stack) {                 //link链表的尾节点被创建                 tail = new Link();                 //创建头节点                 head = new Head();                 //链表中还没有数据，所以暂时让头节点指向尾节点                 head.link = tail;             }         /**         * @Author: PP-jessica         * @Description:创建一个新的WeakOrderQueue对象的方法         */         static WeakOrderQueue allocate(Stack<?> stack) {             return newQueue(stack);         }         /**          * @Author: PP-jessica          * @Description:WeakOrderQueue的构造方法是private修饰的，所以有一个静态方法来对外创建对象          */         static WeakOrderQueue newQueue(Stack<?> stack) {             //创建一个WeakOrderQueue对象             final WeakOrderQueue queue = new WeakOrderQueue(stack);             return queue;         }                      /**              * @Author: PP-jessica              * @Description:添加新的未被回收的对象时，从尾节点添加，取走未被回收的对象时，从头节点取走。              */             void add(DefaultHandle<?> handle) {                 //找到link链表的尾节点。就像我们上面说的，从尾节点添加被回收对象，从头节点取走                 Link tail = this.tail;                 //然后就把要帮忙回收的其它线程对象池中的对象添加到尾节点的数组中                 //这里就先不实现了，逻辑非常复杂，不是一两句就可以讲清楚的             }             /**              * @Author: PP-jessica              * @Description:这个可以说是WeakOrderQueue类中最重要的一个方法了，这个方法就是把要被回收的对象从WeakOrderQueue节点中              * 移动到原来线程的stack中，该方法是在stack类中的方法内被调用的              */             boolean transfer(Stack<?> dst) {                  //要从WeakOrderQueue的link节点中转移数据了                  //从头节点开始转移，所以要先获得头节点                  Link head = this.head.link;                  //后面的逻辑也就先不做实现了，因为太复杂了             }         }     static final class Stack<T> {         //这个threadRef我们之前分析过，这个就是stack对象池对应的所属线程，但这里为什么要采用弱引用的方式呢？         //我们思考这样一种情况，现在，stack引用的所属线程的线程，而handl又持有了其对应的stack，所以handle可以得到stack         //stack又可以得到线程，如果对象池对应的线程挂掉了，可是stack中还持有这个线程的强引用，         //就不利于线程的垃圾回收，所以这里搞成弱引用，帮助垃圾回收而已         final WeakReference<Thread> threadRef;         //当前stack数组中存储了多少个对象         private int size;         //stack中数组的最大容量         private final int maxCapacity;         //stack中存储对象的数组容器         private DefaultHandle<?>[] elements;         //构造方法         Stack(int maxCapacity,Thread thread) {             //这里INITIAL_CAPACITY是stack中数组的初始容量             elements = new DefaultHandle[INITIAL_CAPACITY];             //最大容量赋值             this.maxCapacity = maxCapacity;             threadRef = new WeakReference<Thread>(thread);         }         //创建一个handle，用来包装要被缓存的对象         DefaultHandle<T> newHandle() {             return new DefaultHandle<T>(this);         }                  //这个就是从stack对象池获取缓存对象的方法，该方法要经过重构了         DefaultHandle<T> pop() {             //得到数组中存储的对象的个数             int size = this.size;             if (size == 0) {                 //如果为0，说明当前stack中没有可以取出的对象，这时候就要从其他帮忙回收对象的线程的WeakOrderQueue对象中                 //看看是否有可以转移回来的对象，如果有就转移回来，如果也没有，就直接返回null。                 //scavenge方法就会从其他线程的WeakOrderQueue对象中转移对象到自身的对象池中                 if (!scavenge()) {                     //WeakOrderQueue对象中没有数据就直接返回null                     return null;                 }                 //走到这里说明WeakOrderQueue对象中有数据，转移完成之后重新给size赋值                 size = this.size;             }             //要从stack中拿走一个对象，所以要减1             size --;             //存储对象的个数减1正好得到数组存储的最后一个对象的数组下标，取出该下标的对象             DefaultHandle object = elements[size];             //把数组原位置置为null             elements[size] = null;             //取走了一个对象，要重新给size赋值             this.size = size;             //返回该对象             return object;         }         /**          * @Author: PP-jessica          * @Description:该方法就是扫描其他线程的WeakOrderQueue对象中是否有对象          */         boolean scavenge() {             //这里我就遇到麻烦了，因为我根本不知道怎么访问其他线程的WeakOrderQueue对象         }         /**          * @Author: PP-jessica          * @Description:该方法就是把对象放回stack中去，这里面会根据回收对象的线程做一个判断          * 如果是从自己对象池中拿到对象的线程，就直接放回对象池中，如果是其他线程帮忙回收的，就放进其他线程的WeakOrderQueue对象中          */         void push(DefaultHandle<?> item) {             //得到执行当前方法的线程             Thread currentThread = Thread.currentThread();             //判断该线程是否和stack所属的线程相等             if (threadRef.get() == currentThread) {                 //相等则表明是得到对象的线程自己回收的，那就直接放进stack中去即可                 pushNow(item);             } else {                 //不想等则表明是其他线程帮忙回收的，那就放进其他线程对应的WeakOrderQueue对象中即可                 //注意，这里既然走到这里，就说明执行当前方法的线程已经是帮忙回收对象的线程了                 //这个currentThread参数也就是帮忙回收对象的线程。所以才会有了后来每一个帮忙回收对象的线程都有一个WeakOrderQueue对象                 pushLater(item, currentThread);             }         }                  //归还对象的方法          void pushNow(DefaultHandle<?> object) {              //首先得到数组的存储数据的个数             int size = this.size;             //在这里判断一下stack存储的对象的个数是否超过了最大容量             if (size >= maxCapacity) {                 //超过最大容量就不能再回收了                 return;             }             //走到这里说明stack允许存放的对象的个数还未到最大值，但是数组容量不够了，就把数组扩容             if (size == elements.length) {                 //扩容一倍                 elements = Arrays.copyOf(elements, min(size << 1, maxCapacity));             }             //对象真正被回收到stack中了             elements[size] = item;             //增添了一个对象，所以size加1             this.size = size + 1;          }         /**          * @Author: PP-jessica          * @Description:把对象放到WeakOrderQueue对象中的方法，这个方法同样非常重要          */         private void pushLater(DefaultHandle<?> item, Thread thread) {             //注意这里的视角切换，执行当前方法的线程为帮助线程回收对象的线程。这个一定要理清楚             //DELAYED_RECYCLED就是一个fastthreadlocal，每个帮助其他线程回收对象的线程会通过这个             //得到自己拥有的map，然后从map中得到一个WeakHashMap，这个逻辑也要理清楚             //而这个WeakHashMap里面的key就是该线程帮忙回收对象线程所拥有的stack，value就是该线程             //自己的WeakOrderQueue             //要记住啊，这个WeakHashMap其实就是存储在该线程私有的map中的             Map<Stack<?>, WeakOrderQueue> delayedRecycled = DELAYED_RECYCLED.get();             //注意啊，这里的这个this，就是原stack所属的那个线程的stack，因为pushLater这个方法是在stack             //中被调用的，可以自己去看看调用链，这个方法是由 stack.push(this)方法一路调用至此的，虽然线程             //不是对象所属的线程，但这和Stack的身份是两回事             //这里就是想得到WeakHashMap中stack对应的value             WeakOrderQueue queue = delayedRecycled.get(this);             if (queue == null) {                 //如果queue为空，说明这是该线程第一次帮忙其他线程回收对象，那么直接创建一个WeakOrderQueue                 //对象，然后把要缓存的对象放到WeakOrderQueue对象中即可，当然，最后肯定是放到Link对象的数组中了                 queue = WeakOrderQueue.allocate(this);             }             //创建好的key-value放进map当中             delayedRecycled.put(this, queue);             //这里是吧handl这个要被回收的对象，用尾插法，添加到WeakOrderQueue对象中link链表的尾节点中了             queue.add(item);         }     } }`

可以看到，经过不断的重构，上面代码亏的内容已经非常多了，而且代码中添加的注释也越来越多，几乎是每一行代码都有特别详细的注释。我希望大家把每一行都仔细地看一看，或者可以直接打开我为大家提供的源码，结合着代码阅读文章。毕竟已经添加了太多的注释了，所以，我就不再费功夫重复讲解执行流程了。当然，上面的代码块仍然是残缺的，可以看到，在 WeakOrderQueue 这个静态内部类中，add 和 transfer 方法都还没有实现，这两个方法本身就蕴含着非常多的细节，一时半会还实现不了，但是逻辑我已经给大家讲清楚了。所以，暂时不实现也就罢了。可是，在重构之后的 Recycler 类中，还有一个最重要的方法没有实现，那就是静态内部类 Stack 中的 scavenge 方法。该方法的作用十分重要，就是在该方法中，1 号线程会访问 2 号线程的 WeakOrderQueue 对象，并且把该对象中缓存的对象转移到自身的对象池中，可是偏偏这个方法我没有为大家实现。原因我也在注释中写明了，因为我根本不知道如何让 1 号线程访问到 2 号线程的 WeakOrderQueue 对象。这真是有意思，明明我们刚才已经设计了一个绝佳的编程思路，结果却发现根本没办法访问到其他线程中的 WeakOrderQueue 对象。

不仅如此，我还想到了一个其他的问题。在我为大家举的例子中，只引入了两个线程，1 号线程和 2 号线程。如果现在忽然多出来一个 3 号线程呢？3 号线程和 2 号线程一样，也想帮助 1 号线程回收对象，这样一来，3 号线程是不是也要创建一个 WeakOrderQueue 对象，专门用来存放为 1 号线程回收的对象？最后肯定也是以 Stack 和 WeakOrderQueue 键值对的形式存储在 3 号线程的私有 Map 中。如果是这样的话，请大家思考一个场景，如果现在 2 号线程和 3 号线程都在帮助 1 号线程回收对象，并且我们就假设 1 号线程此刻可以访问到 2 号线程的 WeakOrderQueue 对象。可是，现在 2 号线程的 WeakOrderQueue 链表中没有 1 号线程的对象了，那该怎么办？按照我们正常人的理解，这时候 1 号线程肯定就要接着向后寻找，看看 3 号线程的 WeakOrderQueue 链表中是否缓存着 1 号线程对象池中的对象，那问题就来了，1 号线程怎么去访问 3 号线程呢？如果这时候程序中还有 4 号，5 号，6 号线程，这些线程都帮助 1 号线程回收过对象，也就是说这些线程都有和 1 号线程对应的 WeakOrderQueue 对象，那么 1 号线程在回收自己对象的时候，怎么访问这些线程的 WeakOrderQueue 对象呢？这个问题一旦解决了，我们的对象池就可以继续重构下去了，换句话说，我们的对象池也就终于可以重构完整了。

让我再来为大家分析一下，现在的情况是如果一个线程帮助另一个线程回收过对象，就会创建一个 Stack 和 WeakOrderQueue 的键值对，其中 Stack 就是另一个线程的私有对象池，而 WeakOrderQueue 链表就是存放另一个线程对象池中的对象的。如果这个线程为两个线程回收过对象，就会创建两个这样的键值对放到一个 Map 中，而这个 Map 会存储到该线程的私有 Map 中，之后以此类推。这就造成了一局面，假如程序中有七八个线程都为同一个线程回收过对象，那么这七八个线程就会分别创建一个键值对，其中键就是那个线程的 Stack，而 WeakOrderQueue 对象中存放的就全都是那一个线程对象池中的对象。这样一来，当这个线程要从自己的对象池中获取对象时，发现对象池空了，就要先去这七八个为它回收过对象的线程的 WeakOrderQueue 链表中查看，看有没有保管着它的对象，如果有就转移到自己的对象池中。所以，我们现在最关键的一步就是如何让这个线程能访问到这七八个线程的 WeakOrderQueue 对象。我们都知道，这七八个线程各自的 WeakOrderQueue 对象肯定是创建在堆中的，一旦创建内存地址就确定了，地址肯定也不会是连续的，这种情况，是不是就该轮到链表这种数据结构登场了？WeakOrderQueue 对象本身就是一个链表，但现在我想在程序中再构建一个链表，链表的每一个节点都是 WeakOrderQueue 对象。

为什么要这么做的？因为目前的程序中有一个很明显的头节点，我相信大家应该也看出来了。比如说现在就是 1 号线程要从自己的对象池中获取对象，但是对象池中没有对象了。不过 2 号，3 号，4 号线程都帮助它回收过对象，那么 1 号线程就要先去 2 号线程的 WeakOrderQueue 链表中查看，如果这个里面没有，就再去 3 号线程的 WeakOrderQueue 链表中查看，如果仍然没有就去 4 号线程的 WeakOrderQueue 链表中查看。而 1 号线程从对象池中获取对象的动作是 1 号线程自己的对象池，也就是 Stack 发起的，那我是不是就可以在这个 Stack 中引入一个新的成员变量，就是一个 WeakOrderQueue 对象，这个对象就是新构建的链表的头节点，从头节点开始向后连接，把其他线程中对应的 WeakOrderQueue 节点都连接起来。这样一来，新的链表就构建成功了，链表的每一个节点都是 WeakOrderQueue 对象。光用文字描述显然还有点抽象，下面我就再为大家配上一副简图，帮助大家理解现在对象池的整体结构。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec996203aa842cf96ff511e8a7cf570~tplv-k3u1fbpfcp-jj-mark:1890:0:0:0:q75.awebp#?w=1937&h=3354&e=jpg&b=ffffff)

在上面的简图中，我用链表的方式把线程的 WeakOrderQueue 对象连接起来了。当然，只有对应着同一个线程的 WeakOrderQueue 对象才会被连接起来，对应着不同线程的 WeakOrderQueue 对象是不会被连接的。比如说2 号线程和 3 号线程都在帮助 1 号线程回收对象，那么 2 号线程和 3 号线程中为 1 号线程创建的 WeakOrderQueue 对象就可以连接起来。但是假如 3 号线程还为 2 号线程回收对象，那么为 2 号线程创建的 WeakOrderQueue 对象是不会被 1 号线程的头节点连接起来的。那么说了这么多，这些节点究竟是在哪里被连接到一起的呢？大家肯定都还记得 WeakOrderQueue 对象是怎么被创建的吧？请看下面的代码块。

java

复制代码

`/**          * @Author: PP-jessica          * @Description:把对象放到WeakOrderQueue对象中的方法，这个方法同样非常重要          该方法是在Stack类中的          */         private void pushLater(DefaultHandle<?> item, Thread thread) {             Map<Stack<?>, WeakOrderQueue> delayedRecycled = DELAYED_RECYCLED.get();             //注意啊，这里的这个this，就是原stack所属的那个线程的stack，因为pushLater这个方法是在stack             //中被调用的，可以自己去看看调用链，这个方法是由 stack.push(this)方法一路调用至此的，虽然线程             //不是对象所属的线程，但这和Stack的身份是两回事             //这里就是想得到WeakHashMap中stack对应的value             WeakOrderQueue queue = delayedRecycled.get(this);             if (queue == null) {                 //如果queue为空，说明这是该线程第一次帮忙其他线程回收对象，那么直接创建一个WeakOrderQueue                 //对象，然后把要缓存的对象放到WeakOrderQueue对象中即可，当然，最后肯定是放到Link对象的数组中了                 queue = WeakOrderQueue.allocate(this, thread);             }             //创建好的key-value放进map当中             delayedRecycled.put(this, queue);             //这里是吧handl这个要被回收的对象，用尾插法，添加到WeakOrderQueue对象中link链表的尾节点中了             queue.add(item);         }`

在上面代码块的第 16 行，WeakOrderQueue 对象就被创建了，而在上面的代码块中，恰好可以得到帮助其他线程回收的 DefaultHandle 对象，而 DefaultHandle 对象恰好可以得到其所属的对象池 Stack。刚才我就说了，我要在 Stack 中引入一个新的成员变量，就是一个 WeakOrderQueue 对象，当作 WeakOrderQueue 对象构建的链表的头节点，这样一来，我就可以在上面代码块的方法中直接得到链表的头节点了。如果我使用头插法，不就可以把每一个帮助回收对象的线程创建的 WeakOrderQueue 对象连接起来了吗？当然，既然是头插法，就意味着着多个线程要操作同一个数据，为什么说是多个线程呢？因为在程序中不止一个线程会帮助另一个线程回收对象，也许 2 号，3 号，4 号等等线程都在帮助 1 号线程回收对象，那么这几个线程专门为 1 号线程创建的 WeakOrderQueue 对象都要采用头插法添加到 1 号线程的 Stack 里面，也许这几个线程会同时添加呀，所以显然我们又遇到了一个并发问题。由此可见，并发情况在程序中是无处不在的。当然，解决这个情况就简单很多了，因为几个线程同时插入头节点的概率并不高，所以这里我们直接使用同步锁就够了。这也就是说，在整个对象池体系中，只有插入头节点这一个地方使用了同步锁。接下来，就请大家看一下最终重构好的 Recycler 类。当然，这里我就不再展示整个类了，只展示需要重构的部分代码。请看下面的代码块。‘

java

复制代码

`public abstract class Recycler<T> {     //其他内容暂时省略     private static final class WeakOrderQueue {             //这里可以看到，Link其实就是WeakOrderQueue的一个内部类             static final class Link extends AtomicInteger {                 //link中用来存储待回收对象的容器，是个数组，该数组的容量为16，是默认的，如果数组满了，就会创建新的link对象，添加到link                 //链表的尾部，这里是尾插法。                 private final DefaultHandle<?>[] elements = new DefaultHandle[LINK_CAPACITY];                 //这个相当于读指针                 private int readIndex;                 //链表指针，指向下一个link节点                 //因为WeakOrderQueue队列是由一个个link节点构成的，所以这里会有下一个link节点的指针                 //并且从这里可以看出来，WeakOrderQueue队列的链表还是单向链表                 Link next;             }                               //这里又是一个内部类，是WeakOrderQueue队列中的头节点             static final class Head {                 //link链表的头节点，该头节点在head节点中                 Link link;                          //构造方法                 Head() {                                 }             }                      //接下来的这些成员变量就是WeakOrderQueue对象的了             //WeakOrderQueue对象中的head节点，头节点中指向了下一个link节点。链表从head节点内部开始了。             //这个head节点中的link指针指向的下一个link节点，就是转移对象时最先被查找的节点。             //用一句话概括就是，link节点的插入采用的是尾插法，而转移link节点数组中存储的对象，采用的是头查法，从头节点开始查找             //用这种方式避开了并发的情况             private final Head head;             //WeakOrderQueue对象中link链表的尾节点             private Link tail;         //每一个WeakOrderQueue对象中都会有下一个WeakOrderQueue节点的指针。这个链表实际上是从stack对象中延伸出来的。         //因为WeakOrderQueue对象就是stack类的一个成员变量，就相当于stack的头节点，头节点正好指向下一个WeakOrderQueue节点         private WeakOrderQueue next;                      //构造方法             private WeakOrderQueue(Stack<?> stack) {                 //link链表的尾节点被创建                 tail = new Link();                 //创建头节点                 head = new Head();                 //链表中还没有数据，所以暂时让头节点指向尾节点                 head.link = tail;             }         /**         * @Author: PP-jessica         * @Description:创建一个新的WeakOrderQueue对象的方法         */         static WeakOrderQueue allocate(Stack<?> stack) {             return newQueue(stack);         }         /**          * @Author: PP-jessica          * @Description:WeakOrderQueue的构造方法是private修饰的，所以有一个静态方法来对外创建对象          这个方法在这里重构了          */         static WeakOrderQueue newQueue(Stack<?> stack) {             //创建一个WeakOrderQueue对象             final WeakOrderQueue queue = new WeakOrderQueue(stack);             //还记得之前说的吗？WeakOrderQueue都是头插法插入到WeakOrderQueue链表中的             //点进去会发现setHead方法是整个类中唯一一个加了锁了方法。因为把WeakOrderQueue对象添加到WeakOrderQueue链表头部             //很可能是多个线程同时在进行，因为一个线程从对象池中获得的多个对象可能需要多个线程帮其回收，每个帮助回收的             //线程都对应着一个WeakOrderQueue对象，自然会出现同时把WeakOrderQueue对象添加到头节点的情况             //这时候就必须用synchronized来防止并发问题的出现             //注意，这里是stack在调用setHead方法             stack.setHead(queue);             return queue;         }         /**          * @Author: PP-jessica          * @Description:把一个节点向后移动。          */         private void setNext(WeakOrderQueue next) {             assert next != this;             this.next = next;         }                      /**              * @Author: PP-jessica              * @Description:添加新的未被回收的对象时，从尾节点添加，取走未被回收的对象时，从头节点取走。              */             void add(DefaultHandle<?> handle) {                 //找到link链表的尾节点。就像我们上面说的，从尾节点添加被回收对象，从头节点取走                 Link tail = this.tail;                 //然后就把要帮忙回收的其它线程对象池中的对象添加到尾节点的数组中                 //这里就先不实现了，逻辑非常复杂，不是一两句就可以讲清楚的             }             /**              * @Author: PP-jessica              * @Description:这个可以说是WeakOrderQueue类中最重要的一个方法了，这个方法就是把要被回收的对象从WeakOrderQueue节点中              * 移动到原来线程的stack中，该方法是在stack类中的方法内被调用的              */             boolean transfer(Stack<?> dst) {                  //要从WeakOrderQueue的link节点中转移数据了                  //从头节点开始转移，所以要先获得头节点                  Link head = this.head.link;                  //后面的逻辑也就先不做实现了，因为太复杂了             }         }     static final class Stack<T> {         //这个threadRef我们之前分析过，这个就是stack对象池对应的所属线程，但这里为什么要采用弱引用的方式呢？         //我们思考这样一种情况，现在，stack引用的所属线程的线程，而handl又持有了其对应的stack，所以handle可以得到stack         //stack又可以得到线程，如果对象池对应的线程挂掉了，可是stack中还持有这个线程的强引用，         //就不利于线程的垃圾回收，所以这里搞成弱引用，帮助垃圾回收而已         final WeakReference<Thread> threadRef;         //当前stack数组中存储了多少个对象         private int size;         //stack中数组的最大容量         private final int maxCapacity;         //stack中存储对象的数组容器         private DefaultHandle<?>[] elements;         //终于看到WeakOrderQueue节点了，stack中既有数组，同时也存在一个WeakOrderQueue对象构成的链表         //定义了当前节点和前驱节点         private WeakOrderQueue cursor, prev;         //WeakOrderQueue头节点         private volatile WeakOrderQueue head;         //构造方法         Stack(int maxCapacity,Thread thread) {             //这里INITIAL_CAPACITY是stack中数组的初始容量             elements = new DefaultHandle[INITIAL_CAPACITY];             //最大容量赋值             this.maxCapacity = maxCapacity;             threadRef = new WeakReference<Thread>(thread);         }         //之前解释过，插入WeakOrderQueue头节点的时候是头插法，并且是多个线程一起工作的，所以会存在并发问题         //所以在这里用了对象池中唯一的一个锁         synchronized void setHead(WeakOrderQueue queue) {             //头插法             queue.setNext(head);             head = queue;         }         //创建一个handle，用来包装要被缓存的对象         DefaultHandle<T> newHandle() {             return new DefaultHandle<T>(this);         }                  //这个就是从stack对象池获取缓存对象的方法，该方法要经过重构了         DefaultHandle<T> pop() {             //得到数组中存储的对象的个数             int size = this.size;             if (size == 0) {                 //如果为0，说明当前stack中没有可以取出的对象，这时候就要从其他帮忙回收对象的线程的WeakOrderQueue对象中                 //看看是否有可以转移回来的对象，如果有就转移回来，如果也没有，就直接返回null。                 //scavenge方法就会从其他线程的WeakOrderQueue对象中转移对象到自身的对象池中                 if (!scavenge()) {                     //WeakOrderQueue对象中没有数据就直接返回null                     return null;                 }                 //走到这里说明WeakOrderQueue对象中有数据，转移完成之后重新给size赋值                 size = this.size;             }             //要从stack中拿走一个对象，所以要减1             size --;             //存储对象的个数减1正好得到数组存储的最后一个对象的数组下标，取出该下标的对象             DefaultHandle object = elements[size];             //把数组原位置置为null             elements[size] = null;             //取走了一个对象，要重新给size赋值             this.size = size;             //返回该对象             return object;         }         /**          * @Author: PP-jessica          * @Description:该方法就是扫描其他线程的WeakOrderQueue对象中是否有对象          这个方法在这里也被重构了          */         boolean scavenge() {             //这一步就是从其他线程的WeakOrderQueue对象中把属于自己对象池的对象移回到自己的stack中             if (scavengeSome()) {                 return true;             }             //如果所有WeakOrderQueue节点中都没有对象，就把当前节点和前驱节点重新初始化，因为在查找的过程中，这两个值已经发生             //改变了             prev = null;             cursor = head;             return false;         }         /**          * @Author: PP-jessica          * @Description:这个可以说是stack类中最重要的一个方法了，这个方法的作用就是检查WeakOrderQueue链表中的节点          * 如果有数据就回收到自己的stack中          */         boolean scavengeSome() {             //这个方法在这里同样就不做实现了，总之，这个方法的核心逻辑就是从WeakOrderQueue             //对象构成的链表中查找缓存的对象，如果第一个WeakOrderQueue节点没有，就查找第二个             //基本上都是对链表进行的操作，具体逻辑可以去看源码，源码中有非常详细的注释，一看就明白了         }         /**          * @Author: PP-jessica          * @Description:该方法就是把对象放回stack中去，这里面会根据回收对象的线程做一个判断          * 如果是从自己对象池中拿到对象的线程，就直接放回对象池中，如果是其他线程帮忙回收的，就放进其他线程的WeakOrderQueue对象中          */         void push(DefaultHandle<?> item) {             //得到执行当前方法的线程             Thread currentThread = Thread.currentThread();             //判断该线程是否和stack所属的线程相等             if (threadRef.get() == currentThread) {                 //相等则表明是得到对象的线程自己回收的，那就直接放进stack中去即可                 pushNow(item);             } else {                 //不想等则表明是其他线程帮忙回收的，那就放进其他线程对应的WeakOrderQueue对象中即可                 //注意，这里既然走到这里，就说明执行当前方法的线程已经是帮忙回收对象的线程了                 //这个currentThread参数也就是帮忙回收对象的线程。所以才会有了后来每一个帮忙回收对象的线程都有一个WeakOrderQueue对象                 pushLater(item, currentThread);             }         }                  //归还对象的方法          void pushNow(DefaultHandle<?> object) {              //首先得到数组的存储数据的个数             int size = this.size;             //在这里判断一下stack存储的对象的个数是否超过了最大容量             if (size >= maxCapacity) {                 //超过最大容量就不能再回收了                 return;             }             //走到这里说明stack允许存放的对象的个数还未到最大值，但是数组容量不够了，就把数组扩容             if (size == elements.length) {                 //扩容一倍                 elements = Arrays.copyOf(elements, min(size << 1, maxCapacity));             }             //对象真正被回收到stack中了             elements[size] = item;             //增添了一个对象，所以size加1             this.size = size + 1;          }         /**          * @Author: PP-jessica          * @Description:把对象放到WeakOrderQueue对象中的方法，这个方法同样非常重要          */         private void pushLater(DefaultHandle<?> item, Thread thread) {             //注意这里的视角切换，执行当前方法的线程为帮助线程回收对象的线程。这个一定要理清楚             //DELAYED_RECYCLED就是一个fastthreadlocal，每个帮助其他线程回收对象的线程会通过这个             //得到自己拥有的map，然后从map中得到一个WeakHashMap，这个逻辑也要理清楚             //而这个WeakHashMap里面的key就是该线程帮忙回收对象线程所拥有的stack，value就是该线程             //自己的WeakOrderQueue             //要记住啊，这个WeakHashMap其实就是存储在该线程私有的map中的             Map<Stack<?>, WeakOrderQueue> delayedRecycled = DELAYED_RECYCLED.get();             //注意啊，这里的这个this，就是原stack所属的那个线程的stack，因为pushLater这个方法是在stack             //中被调用的，可以自己去看看调用链，这个方法是由 stack.push(this)方法一路调用至此的，虽然线程             //不是对象所属的线程，但这和Stack的身份是两回事             //这里就是想得到WeakHashMap中stack对应的value             WeakOrderQueue queue = delayedRecycled.get(this);             if (queue == null) {                 //如果queue为空，说明这是该线程第一次帮忙其他线程回收对象，那么直接创建一个WeakOrderQueue                 //对象，然后把要缓存的对象放到WeakOrderQueue对象中即可，当然，最后肯定是放到Link对象的数组中了                 queue = WeakOrderQueue.allocate(this);             }             //创建好的key-value放进map当中             delayedRecycled.put(this, queue);             //这里是吧handl这个要被回收的对象，用尾插法，添加到WeakOrderQueue对象中link链表的尾节点中了             queue.add(item);         }     } }`

到此为止，这节课的所有内容就讲解完毕了。内容也是挺多的，主要还是分析得过程比较详细。当然，还有一些比较细节的知识点我并没有讲解，最终呈现给大家的代码块也有几个方法并没有实现。如果全都展开来讲，恐怕还要再写一章，这一块的知识才能讲解全面，我的精力并没有那么充足。但是我可以跟大家保证，就算你对 Netty 对象池的掌握是零基础，看了我这两篇，你对 Netty 对象池中的各个组件的功能和作用，以及原理和实现绝对可以了如指掌。更加具体的细节，就从我为大家提供的源码中学习吧，其实说到底也没剩下多少知识了，只有三四个方法和一些属性没有引入和实现，带着目的去源码中学习，可以学习得更快更好。

最后，我还想跟大家聊几句，虽然最终我为大家呈现的 Recycler 类看起来比较复杂，但是大家千万不要对这一块的知识产生畏惧心理。这两章我花了这么多文字来讲解对象池，其实大家可以想一想，对象池的本质是什么？在 Netty 中创建对象池的目的是什么？说白了就一句话，创建对象池就是为了不让对象被垃圾回收，从而达到复用的目的。那一个对象不能被垃圾回收，最简单的做法是什么？就是让它一直被强引用引用着即可。所以，对象池的本质是什么？就是给对象施加一个强引用，仅此而已。如果理解了这个本质，再来看对线程并发回收对象就简单的多了，什么对象先放在这个线程的 WeakOrderQueue 对象中，然后再转移到原来线程的对象池中，这些转移来转移去的动作其实都是假象，对象一旦创建，就在堆中的位置固定了，如果没有特殊情况，对象的内存地址将不会改变，并且是唯一的。也就是说，对象只有一个，对象池中所做的这些操作，无非就是把对象的引用改来改去，让这个对象时时刻刻都有一个强引用引用着，不就是这个道理吗？这个就是对象池的本质。

还是前面几章我反复给大家灌输的一句话：复杂的问题都可以用简单的思想来解决，之所以最后呈现出的知识体系比较复杂，是因为在解决问题的过程中，遇到了更为复杂的问题。但是每一个复杂的问题都可以用简单的思想来解决，其实大家可以把这个 Recycler 类拆分一下，会发现每个知识点都非常简单。我一直觉得，学习其实是最容易的事，因为知识都是摆在大家眼前的，大家根本不必创造知识，所有的知识都是别人创造好，并且总结好的。大家要做的仅仅是学会而已。这也是我的从零带你写框架系列定价非常便宜的原因，最后可能也只是定价在 500 元，但是这个系列包含 Netty，XXL-JOB，Disruptor，Spring，SpringBoot，RocketMq，Nacao，Javac，JVM 等等课程。平均下来一门课也就 50 多块钱。因为我只是个知识的搬运工，也并不创造知识。好了，话题显然已经扯远了，我之所以说这么多，是希望大家能以一种积极地心态去学习知识，因为这些知识都很简单，包括后面要讲解的内存池，虽然整个体系十分复杂，但是拆解一下，会发现每个知识点也特别简单。如果遇到一个陌生的知识，或者说有一定难度的知识，我希望大家可以把这视为一种充满乐趣的挑战，亲自去揭开它神秘的面纱，而不是从心底里就打退堂鼓。好了，这一章就到此为止吧。我们下一章见。

# 总结

这一章讲下来，其实还是运用了空间换时间的思想，这种思想运用起来确实是挺简单的，也挺过瘾的，但是，千万别忘记考虑内存。说的直接一点，就是要考虑对象池的容量，不可能创建一个对象就放到对象池中，这样的话，很容易就内存溢出了。所以，我们不可能让对象池无限扩大，既然不可能回收所有的对象，那就要考虑对象的回收频率。比如，每当垃圾回收掉七个对象之后，第八个对象就把它回收到对象池。再比如说，程序中有 100 个线程，现在 1 号线程的对象要交给其他线程帮忙回收，难道剩下的 99 个线程都可以帮忙回收对象吗？如果都可以帮忙回收岂不是要创建 99 个 WeakOrderQueue对象？这不是有病吗？所以，帮助 1 号线程回收对象的线程也要从数量上进行限制，比如，如果有一个线程需要其他线程帮忙回收对象，那么其他帮忙线程的最大数量限制为 5，当然，也可以是其他的值。总之要对其进行限制。这些内容就是隐藏在源码中的细节，大家可以带着这几个细节去学习源码。除此之外，Netty 的对象池中也没什么知识了。