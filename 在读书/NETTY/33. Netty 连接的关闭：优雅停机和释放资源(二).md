这一章，我会紧接着上一章的内容，为大家把 NioServerSocketChannel 调用 close 方法的流程和 NioSocketChannel 调用 close 方法的流程梳理清楚。

**NioSocketChannel 被动关闭的执行流程**

在上一章的结尾，我为大家引入了一个新的问题，那就是 Channel 调用了它的 close 方法后，在这个 close 方法中具体会发生什么。现在我们可以仔细探讨探讨了，其实，这个 close 方法还可以进一步扩展，因为关闭 Channel 可以分为两种情况，一种是主动关闭，比如服务端的 NioServerSocketChannel 或者是客户端的 NioSocketChannel 主动关闭；另一种是被动关闭，比如某个客户端关闭的时候，会通知服务端，这时候服务端管理的与这个客户端对应的 NioSocketChannel 就会接收到一个 OP_READ 事件，服务端就会关闭对应的 NioSocketChannel，也就会调用这个 Channel 的 close 方法。所以，这一章就会围绕着这两种 Channel 关闭的模式来讲解，接下来，我先为大家分析 Channel 被动关闭的整个流程。

根据刚才的分析，假如一个客户端主动关闭，然后通知服务端，这时候服务端所管理的与这个客户端对应的 NioSocketChannel 就会触发一个 OP_READ 事件，接着程序就会执行到 Unsafe 的 read 方法中。这个流程大家应该很熟悉了吧，这就是常规的接收消息的流程。当然，如果是关闭 Channel 处罚的接收时间，服务端这边管理的 Channel 就会读取到 -1，就像下面代码块展示的这样。请看下面代码块。

java

复制代码

`public abstract class AbstractNioByteChannel extends AbstractNioChannel{     //其他内容省略     //内部类     protected class NioByteUnsafe extends AbstractNioUnsafe {         //省略部分内容         //接收消息的方法         @Override         public final void read() {             //省略部分内容                          //得到配置类             final ChannelConfig config = config();                         final ChannelPipeline pipeline = pipeline();             //得到内存分配器，这个是真正的内存分配器             final ByteBufAllocator allocator = config.getAllocator();             //得到动态内存分配器的处理器，这个处理器要配合内存分配器来使用             final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();             //和之前学习的服务端接收客户端连接时一样，下面这个方法同样是用来在本次接收数据之前，重置一下状态。就是把上一次接收到的数据清零             allocHandle.reset(config);             ByteBuf byteBuf = null;             boolean close = false;             try {                 do {                     //分配一块内存，注意，如果是第一次来读取字节消息，但是并没有上一次接收到的字节数量做参考，我们怎么知道第一次要分配                     //多大的ByteBuf呢？所以这里有一个默认值，1024，第一次会分配1024个字节大小，用于接收数据                     byteBuf = allocHandle.allocate(allocator);                     //doReadBytes(byteBuf)方法返回的是本次接收到的字节数量。然后把该值记录下来。                     allocHandle.lastBytesRead(doReadBytes(byteBuf));                     //这里是得到本次读取到的数据，如果读取到的数据等于0，说明到此为止，客户端channel中的数据已经全部读取完了                     //可以直接退出循环了                     if (allocHandle.lastBytesRead() <= 0) {                         //退出循环之前，释放该ByteBuf                         byteBuf.release();                         //清除引用                         byteBuf = null;                                                  //重点就在这里                         //如果本次接收到的结果小于0，就意味着客户端要关闭了，当接收为-1时，代表客户端channel要关闭                         close = allocHandle.lastBytesRead() < 0;                                                  if (close) {                            //把该属性置为false                             readPending = false;                         }                         break;                     }                                          //判断是否要结束循环了                 } while (allocHandle.continueReading());             }         }     }      }`

在上面代码块的第 46 行，如果本次读取到的字节小于 0，也就是 -1，就意味着当前的 NioSocketChannel 要关闭了。因为与这个 NioSocketChannel 对应的客户端要关闭了，否则当前的 NioSocketChannel 也不会读取到 -1 了。既然当前的 NioSocketChannel 要关闭了，就要执行 close 方法。但是就在这里，Netty 中的处理方式可能跟大家想象的有些不同。在网络编程中，Channel 是属于全双工的数据传输通道，简单来说，就是使用 Channel 可以同时发送消息和接收消息，数据的流动是双向的，可以同时进行。与此相对应的就是半双工，比如输入流和输出流，同一个时刻只能输入或者输出。我之所以在这里引入这个概念是因为在 Netty 中，如果服务端管理的某个 NioSocketChannel 要被动关闭了，这时候，就会先让该 Channel 进入半关闭状态，在这个状态中只可以发送消息，而不会再接收消息。因为服务端管理的 NioSocketChannel 的写缓冲区中可能还有待发送的数据，也就是 outboundBuffer 对象中还残留着部分数据需要刷新到 Socket 输出缓冲区中，所以先让 Channel 处于半关闭状态，只能发送消息，不能接收消息。等到这个 Channel 的写缓冲区中的消息刷新完毕后，再执行真正的 close 方法，将这个半关闭状态的 Channel 完全关闭。

那这个功能要怎么实现呢？如果接收到了 -1，意味着当前 Channel 要被动关闭了，在上面的代码块中也只是将 close 这个局部变量修改为 true，并没有执行真正的关闭操作。所以，接下来我们就要为程序定义一个新的方法，在这个方法中执行 Channel 半关闭的操作，并且在半关闭之后将 Channel 写缓冲区中的数据刷新出去，等到数据刷新完毕之后，再执行 Channel 的 close 方法，使当前的 Channel 完全关闭。并且，新定义的这个方法会在上面代码块的 read 方法中被调用。这个方法的名字我也想好了，就叫 closeOnRead 方法，具体实现请看下面代码块。

java

复制代码

`/**  * @Author: PP-jessica  * @Description:服务端半关闭客户端channel的方法  */ private void closeOnRead(ChannelPipeline pipeline) {     //先判断管理的channel是否半关闭了，注意这里的半关闭和客户端不同，服务端的半关闭状态，     //关闭的是输入流，也就是不能再从socket缓冲区中     //读取数据了，但是可以发送消息，这里最终会调用到NIO中的方法，就不再详细展示了     if (!isInputShutdown0()) {         //接着判断是否允许Channel半关闭，这个ChannelOption.ALLOW_HALF_CLOSURE是可配置的参数         //这个方法最终会调用到配置类中，都是可配置的         if (isAllowHalfClosure(config())) {             //如果允许，就可以直接半关闭了             //这里要提醒一点，处于半关闭的channel，会不停地触发读事件，接收到-1             //如果不想一直接收到读事件，就应该把读事件从selector上取消             //这里就是一路调用，调用到NioSocketChannel中，最终调用NIO的shutdownInput方法，             //方法逻辑都很简单，就不再详细展示了             shutdownInput();             //回调UserEventTriggered方法，注意，这个方法非常重要，在这里回调的这个方法             //就是用来给用户扩展的，在这个方法中传进去了一个事件参数ChannelInputShutdownEvent.INSTANCE             //这个就是channel半关闭事件，用户需要自己定义一个处理器，并且实现userEventTriggered方法             //判断该方法中接收到的是否为ChannelInputShutdownEvent.INSTANCE，如果是，就可以得到当前Channel             //的写缓冲区对象，然后把写缓冲区对象中的数据刷新到Socket输出缓冲区中了，在这个代码块中有一个例子，就在该方法下面，大家可以看一看             pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);         } else {             //走到这里就意味着不支持半关闭，所以直接关闭close即可，注意，这里可以看到，服务端管理的客户端channel要关闭             //传入的是voidPromise类型的promise             close(voidPromise());         }     } else {         //走到这里说明channel不能再从socket中接收消息了，半关闭已经执行完成了         //为什么会再次走到这里呢？前面说过，当设调用了半关闭方法，会不停触发读事件，所以会循环到这里     	//但是走到这里的时候，上面那个if分支中的代码肯定已经执行完毕了，因为触发读事件，就代表着多路复用器         //又轮循了一次，而在轮循之前，肯定要把上一轮的IO事件处理完毕，也会把用户提交的任务处理一部分         //所以在触发读事件又一次走到这里后，就说明半关闭方法已经执行完成了，残留在写缓冲区的消息已经完全发送给客户端了         //因此，可以直接在下面的回调方法中执行真正的关闭客户端的方法         //也就是close方法，让channel完全关闭即可         inputClosedSeenErrorOnRead = true;         //这里又给用户暴露出一个扩展事件，走到这里就意味着半关闭已经完成，数据也从写缓冲区对象中刷新完毕了         //这时候用户自己定义的处理器中实现的userEventTriggered方法就要判断是不是触发了ChannelInputShutdownReadComplete.INSTANCE事件         //一旦触发这个事件就说明残留的消息已经刷新完毕了，可以完全关闭channel了，具体例子请看下面的方法         pipeline.fireUserEventTriggered(ChannelInputShutdownReadComplete.INSTANCE);     } } //下面就是用户自己定义的一个处理器 public class MyChannelHandler extends ChannelDuplexHandler {     @Override     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {         //检查触发的事件类型         if (evt == ChannelInputShutdownEvent.INSTANCE) {             //如果触发的是ChannelInputShutdownEvent.INSTANCE事件，表示Channel的输入流已经关闭，             //但是输出流可能还有数据需要发送。我们需要获得Channel的写缓冲区对象，             //并尝试把写缓冲区中的数据刷新出去。             //获取ChannelOutboundBuffer对象             ChannelOutboundBuffer cob = ctx.channel().unsafe().outboundBuffer();             //检查ChannelOutboundBuffer是否为空，如果不为空，则尝试刷新数据             if (cob != null) {                 cob.flush();             }             //当然，也可以直接在这里调用channel的writeAndflush方法发送消息，反正write了就会flush             //同样起到了flush的作用，这里我就不再展示了         } else if (evt == ChannelInputShutdownReadComplete.INSTANCE) {             //如果触发的是ChannelInputShutdownReadComplete.INSTANCE事件，触发这个事件其实是代表已经不能             //再从Socket中读取消息了，因为输入流已经完全关闭了，这就意味着channel半关闭的操作已经执行完了             //这同时也表示残留的消息已经刷新完毕了，所以可以在这里把channel直接关闭了             ctx.close();         } else {             //如果触发的事件不是我们关心的类型，我们需要把它传递给ChannelPipeline中的下一个ChannelHandler。             super.userEventTriggered(ctx, evt);         }     } }`

好了，这个 closeOnRead 方法定义好之后，接下来就该调用它了。调用它的时机也已经分析过了，就是在 AbstractNioByteChannel 内部类 NioByteUnsafe 的 read 方法中，只要接收到的为 -1，就意味着当前 Channel 需要被动关闭，直接调用这个 closeOnRead 方法即可。具体实现请看下面代码块。

java

复制代码

`public abstract class AbstractNioByteChannel extends AbstractNioChannel{     //其他内容省略     //内部类     protected class NioByteUnsafe extends AbstractNioUnsafe {         //省略部分内容         //接收消息的方法         @Override         public final void read() {             //省略部分内容                          //得到配置类             final ChannelConfig config = config();             //还记得在closeOnRead方法中，将channel半关闭之后会一直触发读事件吗？             //如果不想一直触发，就要取消读事件，取消读事件的操作就在这里进行             //这里注释写得比较简单，其实还有一些复杂逻辑，我写在代码中了，可以去代码中看看             if (shouldBreakReadReady(config)) {                 //清除读事件                 clearReadPending();                 return;             }                         final ChannelPipeline pipeline = pipeline();             ······             boolean close = false;             try {                 do {                     ······                                          //可以直接退出循环了                     if (allocHandle.lastBytesRead() <= 0) {                         //退出循环之前，释放该ByteBuf                         byteBuf.release();                         //清除引用                         byteBuf = null;                         //如果本次接收到的结果小于0，就意味着客户端要关闭了，当接收为-1时，代表客户端channel要关闭                         close = allocHandle.lastBytesRead() < 0;                         if (close) {                            //把该属性置为false                             readPending = false;                         }                         break;                     }                     ······                                          //判断是否要结束循环了                 } while (allocHandle.continueReading());             	//在这里判断是否可以执行关闭当前channel的操作                 if (close) {                     //接收到-1就意味着要关闭了，在这里执行关闭channel的方法                     //这里把pipeline传进去是为了调用回调方法                     closeOnRead(pipeline);                 }             }         }     }      }`

到此为止，Channel 半关闭的流程就为大家讲解完毕了。这虽然是一个知识点，但还不是核心知识点，因为在讲解的过程中，仍然没有对 close 这个方法展开剖析。接下来，就让我来为大家分析一下这个方法，看看当 Channel 终于要关闭的时候，会执行什么操作。

假设当前要关闭的 Channel 已经被半关闭了，并且已经将写缓冲区中的数据刷新完毕了，接下来要真正的关闭 Channel 了。当 Channel 真正要关闭的时候，需要处理什么操作呢？其实讲解到这里已经很简单了，现在就只剩下关闭 Channel，清空这个 Channel 私有的写缓冲区，也就是清空这个 Channel 拥有的 ChannelOutboundBuffer 对象，最后就是取消该 Channel 注册到多路复用器上的所有感兴趣事件。之后就没什么要做的了，具体的实现就在下面的代码块中，请看下面代码块。

java

复制代码

`public abstract class AbstractChannel extends DefaultAttributeMap implements Channel{     //省略其他内容      //内部类      protected abstract class AbstractUnsafe implements Unsafe {         //当前channel拥有的写缓冲区         private volatile ChannelOutboundBuffer outboundBuffer = new ChannelOutboundBuffer(AbstractChannel.this);          //省略部分内容          /**          * @Author: PP-jessica          * @Description:该方法是正常关闭channel的入口方法          * 客户端可以调用该方法，而当服务端接收到客户端关闭channel的通知后，也就是接收到-1了，          * 也会调用该方法，关闭服务端管理的客户端的channel          */         @Override         public final void close(final ChannelPromise promise) {             assertEventLoop();             //这里创建的异常是要传递给写缓冲区的，因为channel要关闭了，写缓冲区不能再存放消息对象了             ClosedChannelException closedChannelException = new ClosedChannelException();             close(promise, closedChannelException, closedChannelException, false);         }          /**          * @Author: PP-jessica          * @Description:关闭channel的方法，文章中简化了该方法，第20版本的源码中还有一些逻辑          * 这些逻辑和TCP中的一些参数有关，所以就不放在文章中讲解了，源码中注释非常详细          */         private void close(final ChannelPromise promise, final Throwable cause,                            final ClosedChannelException closeCause, final boolean notify) {                         //还没有关闭，所以channel的状态肯定返回true             final boolean wasActive = isActive();             //得到当前channel私有的写缓冲区对象             final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;             //缓冲区设为null，注意，这里只是把全局变量的引用设置为null，并不是意味着对中的写缓冲区对象不存在了             //这个对象此刻还被上面定义的这个局部变量引用着             this.outboundBuffer = null;             //开始执行关闭channel的操作             doClose0(promise);             //这里并不会为null，局部变量的引用还持有者堆中的对象呢，当方法执行完毕后，全局引用已经为null了             //局部引用也没了，写缓冲区对象就会被垃圾回收了             if (outboundBuffer != null) {                 //设置写缓冲区发送失败标志，并且在该方法中清空写缓冲区中剩余的待发送的数据                 outboundBuffer.failFlushed(cause, notify);                 //该方法中会彻底清空写缓冲区                 outboundBuffer.close(closeCause);             }             //通过这个回调方法，取消channel注册到多路复用器上的所有事件             //并且在这个方法中，还会进一步回调channelInactive方法             fireChannelInactiveAndDeregister(wasActive);         }          /**          * @Author: PP-jessica          * @Description:真正关闭channel的方法          */         private void doClose0(ChannelPromise promise) {             try {                 //关闭channel                 doClose();                 //设置promise成功                 safeSetSuccess(promise);             } catch (Throwable t) {                 //有异常则设置失败                 safeSetFailure(promise, t);             }         }          /**          * @Author: PP-jessica          * @Description:取消注册事件的方法          */         private void fireChannelInactiveAndDeregister(final boolean wasActive) {             deregister(voidPromise(), wasActive && !isActive());         }          /**          * @Author: PP-jessica          * @Description:取消注册事件的方法          */         private void deregister(final ChannelPromise promise, final boolean fireChannelInactive) {             //省略部分内容                          //提交一个异步任务，在该任务中取消channel事件             invokeLater(new Runnable() {                 @Override                 public void run() {                     try {                         //取消channel的事件注册                         doDeregister();                     } catch (Throwable t) {                         logger.warn("Unexpected exception occurred while deregistering a channel.", t);                     } finally {                         if (fireChannelInactive) {                             //回调ChannelInactive事件                             pipeline.fireChannelInactive();                         }                         //设置promise成功                         safeSetSuccess(promise);                     }                 }             });         }           } /**  * @Author: PP-jessica  * @Description:取消多路复用器上对应的channel的selectionKey，该方法其实是在AbstractNioChannel类中  * 这里为了展示代码逻辑，直接放在这里了  */ @Override protected void doDeregister() throws Exception {     eventLoop().cancel(selectionKey()); }`

到此为止，服务端管理的 NioSocketChannel 完整的关闭流程，已经给大家分析完毕了。当然，根据上面的分析，如果是客户端或者服务端主动关闭 Channel，这时候不管是 NioSocketChannel 还是 NioServerSocketChannel 其实都可以直接调用 close 方法，调用了该方法后，经过 ChannelPipeline 上的传递之后，最后程序会来到 Unsafe 对象中，执行其中的 close 方法，而该方法的流程已经为大家分析完毕了。所以，就不再重复讲解了。这时候，我就可以为大家简单的总结一下了，服务端的 NioServerSocketChannel 并不会出现被动关闭的情况，因为它管理者众多 NioSocketChannel，如果它想要关闭，直接调用 close 方法即可，流程就是刚才分析的那样；如果是被 NioServerSocketChannel 管理的 NioSocketChannel，这样的 Channel 是被动关闭，并且是可以进行半关闭的，半关闭之后还要调用 close 方法才能完全关闭，这个流程也已经分析过了。但是现在有这样一种情况，那就是当客户端主动关闭的时候，这个主动关闭的客户端 Channel 可以进行半关闭吗？这时候的半关闭就是不能再向服务端发送消息了，但是还可以接收服务端发送过来的消息。

如果真的有半关闭的需求，那么这个功能该如何实现呢？答案就在我为大家提供的第 20 版本代码中，实际上 Netty 的作者已经为大家实现了客户端主动关闭时，首先进入半关闭状态的功能，具体实现就在 shutdownOutput 方法中。该方法也在 AbstractChannel 的内部类 AbstractUnsafe 中。其流程逻辑和之前分析的 closeOnRead 方法的实现逻辑非常相似，所以我也就不再重复了，就留给大家去源码中学习吧。我给大家提供了一个 ClientTest 测试类，大家测试的时候可以把 channel.close() 这行代码注释掉，直接执行 socketChannel.shutdownOutput() 这行代码即可。

好了各位，到此为止，这套课程就全部结束了。感谢各位耗时观看，谢谢！

**总结**

可能有很多人会觉得最后这两章写得很快，有一些细节没有详细展开，我想解释一下，并不是我想偷懒，想尽快结束这个课程。而是我把关键流程和最核心的逻辑都在文章中讲解了，而我提供的代码中有非常详细的注释，所有细节都在注释中写到了，非常详细。所以，我也就不再重复写在文章中了。和之前的文章相比，最后几章确实少了一些循序渐进的过程，更像是在剖析源码的实现逻辑和执行流程，迭代的过程没有了。这个我也解释过了，因为后面都是一些边角料知识，本身就没有难度，也没有成体系和规模，所以就这样讲解了。希望大家可以理解一下。如果课程中有任何不明白的地方可以直接加我微信，我会耐心为你解答。

最后，我再强调一下，这套课程的所有文章和我提供的代码是一个整体，千万不要把它们分隔开，否则代码中那么详细的注释就白添加了，它们都是非常重要的学习资料。