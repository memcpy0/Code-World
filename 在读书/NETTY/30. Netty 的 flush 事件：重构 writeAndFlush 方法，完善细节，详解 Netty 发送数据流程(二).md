大家好，在上一章我为大家简单剖析了一下 Netty 发送消息的全流程，并且引入了一个新的组件，就是 ChannelOutboundBuffer。关于这个组件，还有很多知识没有讲完，在上一章的末尾我也为大家列出了几个问题，这一章，我们就重点看看这几个问题如何解决。当所有问题都解决了，这一章的重点知识也就讲完了。

**实现 ByteBuf 到 ByteBuffer 的转换**

大家肯定还记得，在上一章的结尾，我提出了一个非常关键的问题。现在存放在每个 Channel 写缓冲区 ChannelOutboundBuffer 的 Entry 链表中的都是一个个 ByteBuf 对象，但是最终发送消息的时候，使用仍然是 NIO 的 SocketChannel 来发送的，发送的时候使用的是 ByteBuffer 对象作为 write 方法的参数。就像下面这样。

java

复制代码

`public abstract int write(ByteBuffer src) throws IOException;`

SocketChannel 的 write 方法传递的参数是一个 ByteBuffer 对象，但是在 Netty 程序中存放字节消息的载体是 ByteBuf 对象，现在要把这些 ByteBuf 对象刷新到 Socket 输出缓冲区中了，当然不能直接刷新 ByteBuf 对象。这就意味着还需要对 ByteBuf 对象做一个转换，使其转换成 ByteBuffer 对象，然后才能把要发送的数据交给 NIO 的 SocketChannel 来发送。那么这个操作该怎么实现呢？

当然，在实现这个操作之前，我们还是先来明确一下要在哪里实现这个操作吧。这个非常容易确认，在上一章我都已经为大家分析过了。最终发送消息的工作都是由 NIioSocketChannel 来干的，就在这个类的 doWrite 方法中，而在这个方法中，就会先获得 NIO 的 SocketChannel，然后调用 SocketChannel 的 write 方法发送消息到 Socket 输出缓冲区中。所以，将 ByteBuf 转换成 ByteBuffer 的操作肯定也是在 doWrite 方法中执行。具体逻辑请看下面代码块。

java

复制代码

`public class NioSocketChannel extends AbstractNioByteChannel { 	      @Override     protected void doWrite(ChannelOutboundBuffer in) throws Exception {         //得到SocketChannel，这个是java的nio中原生channel     	SocketChannel ch = javaChannel();         //省略部分代码         //在这里有一个小步骤，就是先得到一个默认的可以向Socket缓冲区中刷新的最大字节数         //并且根据这个字节数去ChannelOutboundBuffer中将一定数量的ByteBuf转换为ByteBuffer对象         //这个数量很容易计算，每一个ByteBuf不都是包装在Entry中吗？Entry中记录着每一个ByteBuf包装的消息字节的大小         //现在有一个总的可以发送的大小，这样不就可以知道能够转换几个ByteBuf对象为ByteBuffer对象了吗？         //并且这个字节数是可以动态调整的，假如说这次从ChannelOutboundBuffer得到了这么多字节         //但是并没有全刷新到Socket输出缓冲区中，那么在下一次刷新的时候，这个值就会减少         //其实从这里也能看出来，ChannelOutboundBuffer和这个局部变量配合         //也可以起到流量控制的作用，这也是ChannelOutboundBuffer的重要作用之一     	int maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();                           //通过ChannelOutboundBuffer得到要发送的数据         //注意，这里和上一章展示的步骤不同了，这里要从ChannelOutboundBuffer中         //得到ByteBuffer数组，这个数组中存放的都是可以刷新到Socket输出缓冲区中的ByteBuffer对象         //nioBuffers方法，就是把Entry链表中的ByteBuf对象转换为ByteBuffer数组的方法         //这个方法就在ChannelOutboundBuffer类中                  //这里是要把写缓冲区中存放的待刷新消息转换成ByteBuffer，如果消息有很多，就把它们转换成ByteBuffer数组         //实际上就是把ByteBuf转换成ByteBuffer         //因为说到底Netty是建立在nio之上的一个框架，底层发送消息使用的仍然是nio的数据结构，也就是ByteBuffer，向         //channel中写入数据使用的就是ByteBuffer，所以，要把ByteBuf转换成ByteBuffer         //该方法中的两个参数含义其实很明显，因为要把ByteBuf转换成ByteBuffer数组，1024指的就是这次发送消息，最多可以转换1024个ByteBuffer         //也就是说，nioBuffers数组的长度最大为1024，maxBytesPerGatheringWrite就是本次发送消息所能发送的最大字节数         ByteBuffer[] nioBuffers = in.nioBuffers(1024, maxBytesPerGatheringWrite);         //这里得到了要发送的ByteBuffer的个数，也就是一共转成了多少个ByteBuffer对象         //这个数量会记录在ChannelOutboundBuffer类中         int nioBufferCnt = in.nioBufferCount();                  //在这里通过NIO的Channel把消息发送出去         //这里是用的这个也是SocketChannel中的方法，就是下面这个         //public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException;         ch.write(nioBuffers, 0, nioBufferCnt);     } }`

上面的逻辑应该很容易理解，毕竟都是一些表面逻辑。如果上面的逻辑清楚了，接下来，我们的重点就是要具体看一看 in.nioBuffers(1024, maxBytesPerGatheringWrite) 这个方法的具体逻辑了，就是在这个方法中，一个个被 Entry 包装的 ByteBuf 对象就被转换成了 ByteBuffer 对象， 并且以 ByteBuffer 数组的形式返回。如果这个方法理解了，那么我们对发送消息的关键步骤也就掌握了。至于 Socket 输出缓冲区中的数据怎么发送出去，那就是操作系统的工作了，不是我们这个课程讲授的范围。好了，接下来，我们就来看一看 in.nioBuffers(1024, maxBytesPerGatheringWrite) 方法的具体逻辑。

在具体学习这个方法的逻辑之前呢，还有一点琐碎的知识需要补充一下，还记得上一章我为大家讲解过的 Entry 类吗？我当时说这个类封装了 ByteBuf 对象的一些信息，比如 ByteBuf 对象包装的字节大小，返回执行结果的 Promise 等等。现在每一个 ByteBuf 要转换成 ByteBuffer 对象了，那么与每一个 ByteBuf 对象对应的 Entry 对象也会持有这个 ByteBuffer 对象的引用，除此之外，大家还会发现在 ChannelOutboundBuffer 类中还新定义了一些成员变量，其中比较有意思的就是一个 NIO_BUFFERS 静态成员变量，它其实是一个数组的对象池，对象池中的数组长度为 1024。既然 ChannelOutboundBuffer 的 nioBuffers 方法会返回一个 ByteBuffer 数组，数组的最大长度为 1024，每一个单线程执行器都会执行这个方法，索性就创建一个数组的对象池，供每个单线程执行器使用。这些补充知识讲完了之后，接下来，就让我们一起看看 nioBuffers 方法的具体逻辑吧。请看下面代码块。

java

复制代码

`public final class ChannelOutboundBuffer {         private static final Logger logger = LoggerFactory.getLogger(ChannelOutboundBuffer.class);         //一个ByteBuffer[]的对象池     private static final FastThreadLocal<ByteBuffer[]> NIO_BUFFERS = new FastThreadLocal<ByteBuffer[]>() {         @Override         protected ByteBuffer[] initialValue() throws Exception {             //默认的初始容量为1024             return new ByteBuffer[1024];         }     };          //表明属于那个channel     private final Channel channel;          //这个就是写缓冲区中要刷新到socket中的第一个entry     private Entry flushedEntry;          //还未发送的第一个entry，其实就是entry链表的头节点     //发送数据的时候，flushedEntry会指向unflushedEntry     private Entry unflushedEntry;          //entry链表的尾节点，也就是最后一个要发送的entry     private Entry tailEntry;          //累计要刷新多少个entry的个数     private int flushed;          //要发送的ByteBuffer的数量     private int nioBufferCount;          //要发送的总的ByteBuffer的字节大小     private long nioBufferSize;          //是否刷新失败了     private boolean inFail;     //构造器方法     ChannelOutboundBuffer(AbstractChannel channel) {         this.channel = channel;     }     /**      * @Author: PP-jessica      * @Description:这个方法就是把消息放到写缓冲区的entry链表中，采用的是尾插法      */     public void addMessage(Object msg, int size, ChannelPromise promise) {         //从entry的对象池中获取一个entry对象         Entry entry = Entry.newInstance(msg, size, total(msg), promise);         //这里要提醒大家一下tailEntry，flushedEntry和unflushedEntry在初始化的时候都是null         //所以这里会判断一下是不是null         if (tailEntry == null) {             flushedEntry = null;         } else {             //走到这里说明不是null，也就意味着已经插入过带发送的消息了             //之所以得到尾节点，因为采用的是尾插法             Entry tail = tailEntry;             tail.next = entry;         }         //走到这里说明是null，说明是第一次添加消息，直接给了尾节点就行         tailEntry = entry;         if (unflushedEntry == null) {             unflushedEntry = entry;         }         //更新写缓冲区存入的字节总量，这个方法暂时不必关心         incrementPendingOutboundBytes(entry.pendingSize, false);     }     /**      * @Author: PP-jessica      * @Description:准备刷新数据到socket中      */     public void addFlush() {         //这里得到的就是第一个没有发送的消息对象，其实得到的就是没有entry链表的头节点         Entry entry = unflushedEntry;         if (entry != null) {             //如果头节点不为null，要刷新的第一个节点为null             if (flushedEntry == null) {                 //在这里把要发送的第一个消息赋值给flushedEntry                 //其实就相当于让刷新数据的指针执行了Entry链表的头节点                 flushedEntry = entry;             }             //unflushedEntry置为null             unflushedEntry = null;         }     }     /**      * @Author: PP-jessica      * @Description:这个方法就是把写缓冲区中的ByteBuf转换成ByteBuffer数组      */     public ByteBuffer[] nioBuffers(int maxCount, long maxBytes) {         assert maxCount > 0;         assert maxBytes > 0;         //要发送的总的ByteBuffer的字节大小         long nioBufferSize = 0;         //要发送的ByteBuffer的个数         int nioBufferCount = 0;         //从对象池中获得ByteBuffer数组         final InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();         //在这里用到了上面那个对象池，从对象池中获取nioBuffers数组         ByteBuffer[] nioBuffers = NIO_BUFFERS.get(threadLocalMap);                  //获取要发送的第一个entry节点，这个节点中的数据要刷新到Socket输出缓冲区中了         Entry entry = flushedEntry;                  //下面就是一个循环，在循环中依次得到entry节点         while (isFlushedEntry(entry) && entry.msg instanceof ByteBuf) {             //判断发送消息是否被取消了，没取消才可以继续向下执行             if (!entry.cancelled) {                                  //从Entry节点中得到真正包装msg的ByteBuf                 ByteBuf buf = (ByteBuf) entry.msg;                                  //得到读指针                 final int readerIndex = buf.readerIndex();                                  //写指针减去读指针，得到要发送的消息的字节大小                 final int readableBytes = buf.writerIndex() - readerIndex;                                  //判断可发送的数据是否大于0的                 if (readableBytes > 0) {                     //如果大于0，就用本次可以发送的最大字节数减去这个ByteBuf中可发送的数据的字节大小                     //这个maxBytes就是之前在NioSocketChannel的doWrite方法中得到的maxBytesPerGatheringWrite                     if (maxBytes - readableBytes < nioBufferSize && nioBufferCount != 0) {                         //直到循环一定次数之后，判断了多个ByteBuf之后，本次可发送的最大字节数要超过maxBytes                         //这时候就可以退出循环了，因为本次发送的最大字节数不能超过maxBytes                         break;                     }                     //这里累加一下，得到总的要发送的字节数                     nioBufferSize += readableBytes;                                          //得到该entry中有几个ByteBuffer，其实只有一个                     int count = entry.count;                     if (count == -1) {                         //这里count会被赋值为1，因为buf.nioBufferCount()返回值为1                         entry.count = count = buf.nioBufferCount();                     }                     //这里取最小值，maxCount就是之前传进来的1024，这里就是保证一次要发送的nioBufferCount的数量不能超过1024                     int neededSpace = min(maxCount, nioBufferCount + count);                                          //这里会判断本次可以发送的ByteBuffer的个数是否大于数组现有的容量                     if (neededSpace > nioBuffers.length) {                         //大于就扩容nioBuffers数组                         nioBuffers = expandNioBufferArray(nioBuffers, neededSpace, nioBufferCount);                         NIO_BUFFERS.set(threadLocalMap, nioBuffers);                     }                     //这里count已经被赋值为1了                     if (count == 1) {                         ByteBuffer nioBuf = entry.buf;                         if (nioBuf == null) {                             //通过buf.internalNioBuffer(readerIndex, readableBytes)把                             //ByteBuf先转换成它内部的ByteBuffer，这个是ByteBuf自己的方法，大家可以看一看                             //会发现这里其实和我们之前讲解的内存分配的知识连接起来了                             //然后再把这个ByteBuffer赋给entry中的ByteBuffer                             entry.buf = nioBuf = buf.internalNioBuffer(readerIndex, readableBytes);                         }                         //这里把ByteBuffer放到数组中                         nioBuffers[nioBufferCount++] = nioBuf;                     } else {                         //如果不是1，说明有多个，就循环放到数组中                         nioBufferCount = nioBuffers(entry, buf, nioBuffers, nioBufferCount, maxCount);                     }//这里会判断一下，如果转换的ByteBuffer的个数已经达到1024个了，就直接退出循环                     if (nioBufferCount == maxCount) {                         break;                     }                 }             }             entry = entry.next;         }         //这里给这两个成员变量赋值，这时候已经跳出循环了         this.nioBufferCount = nioBufferCount;         this.nioBufferSize = nioBufferSize;     	//返回ByteBuffer数组         return nioBuffers;     }     //下面是Entry内部类     static final class Entry {                 //Entry的对象池         private static final Recycler<Entry> RECYCLER = new Recycler<Entry>() {             @Override             protected Entry newObject(Handle<Entry> handle) {                 return new Entry(handle);             }         };         //对象池的外部句柄，回收对象时会用到         private final Recycler.Handle<Entry> handle;         //entry是一个链表，而且是单向链表，这里自然要得到下一个节点的指针         Entry next;         //待刷新的数据就会放到这里         Object msg;         //这个数组引用会在nioBuffers方法中用到         ByteBuffer[] bufs;         //ByteBuf转换成ByteBuffer后会将引用也交给Entry对象         ByteBuffer buf;         ChannelPromise promise;         //这个是当前Entry刷新了多少数据的一个进度         long progress;         //这个属性表示该Entry对象要刷新的总的数据         //并不包含Entry对象的大小哦         long total;         //这个是Entry对象包含的总的内存大小         //在构造函数中可以看到，这个属性为要刷新的数据的大小加上Entry对象的96字节的大小         int pendingSize;         //该属性表示要刷新的数据被几个ByteBuffer包装着         //这个值初始化为-1，后面会被赋值为1         //entry对象回收的时候会重置为-1         int count = -1;         //发送消息的操作是否被取消         boolean cancelled;              //其他内容省略              } }`

上面的代码块，基本上就把 ByteBuf 转换为 ByteBuffer 的逻辑完全展示出来了，总的来说，就是将写缓冲区 ChannelOutboundBuffer 内部持有的 Entry 链表中，每一个 Entry 对象包装的 ByteBuf 转换为 ByteBuffer 对象，在转换的时候会判断每一个 ByteBuf 包装的消息字节的大小和转换成 ByteBuffer 对象的个数，如果总的要发送的字节消息和 ByteBuffer 的数量达到上限了，就退出方法中的循环，把所有转换成功的 ByteBuffer 以数组的形式返回。所有细节都在代码中，而不在文章中，但是文章已经为大家把前置知识铺垫好了，所以，我想通过上面那个注释详细的代码块，应该也可以掌握 nioBuffers 方法的逻辑了。当然，这个 nioBuffers 方法的逻辑还只是我们这一章内容的一小部分。这个问题解决了，就请大家再思考另一个问题该怎么解决。

**引入写缓冲区的高低水位线**

大家应该还记得，在上一章的结尾，我还向大家提出了这样一个问题：ChannelOutboundBuffer 持有的 Entry 链表是没有容量限制的，这就意味着每一个 Channel 都可以向其拥有的 ChannelOutboundBuffer 写缓冲区中一直写入待发送的数据。如果和 Channel 对应的 Socket 输出缓冲区写满了，就意味着 ChannelOutboundBuffer 持有的 Entry 链表中的数据无法再刷新到 Socket 输出缓冲区中了，那这些数据就会一直堆积在 Channel 自己的写缓冲区 ChannelOutboundBuffer 中，时间长了就会占用大量的内存，并且程序中的每一个 Channel 都有一个写缓冲区，都会占用大量内存，也许就会造成内存溢出了。针对这种情况，该怎么办呢？

最简单的方法往往最直接，比如就可以给 ChannelOutboundBuffer 写缓冲区设置限制，当写缓冲区中存放的待发送的总的字节数超过了某个界限，那就不能再继续向写缓冲区中存放数据了，而当写缓冲区中存入的消息小于某个界限时，就允许待发送的字节消息可以存入写缓冲区。

展开来说，就是计算每一个要存入 ChannelOutboundBuffer 写缓冲区的 ByteBuf 包装的消息字节的大小，然后对存放进来的消息字节进行累加，一旦累加之后的总的字节数超过限制了，就不能再让 Channel 向自己拥有的写缓冲区中写入数据；写缓冲区中的数据一旦刷新到 Socket 输出缓冲区后，ChannelOutboundBuffer 中存放的总的字节数就会相应减少，当 ChannelOutboundBuffer 中存放的总的字节数低于一个界限，就重新恢复 Channel 向其 ChannelOutboundBuffer 写缓冲区中写入字节消息的功能。

所以，要想实现上面的功能，程序中显然又要引入一些新的组件。首先就是用来限制 ChannelOutboundBuffer 存入字节的临界值。在 Netty 中，这样的临界值一共有两个，一个作为 ChannelOutboundBuffer 中可以存入字节的上限，也就是最多可以存放的字节总数；另一个作为 ChannelOutboundBuffer 中可以存入字节的下限，当然，这里大家千万不要把这个下限当成必须要存放这么多字节的意思，如果一个 Channel 一直没有发送消息，难道也要向自己的写缓冲区中存放字节吗？这里的下限指的就是当存放的字节低于这个值时，Channel 就可以继续向 ChannelOutboundBuffer 中写入待刷新的字节消息了。

在 Netty 中，这两个临界值都定义在一个名为 WriteBufferWaterMark 的类中，这个类名翻译过来就是 写缓冲区水位标记的意思，我一般把它称为写缓冲区水位线。上临界值就是高水位线，下临界值就是低水位线。该类的具体内容请看下面代码块。

java

复制代码

`/**  * @Author: PP-jessica  * @Description:数据写入写缓冲区时的高低水位线类  */ public final class WriteBufferWaterMark {     //下面这两个属性就是水位线的高位和水位线的低位     //ChannelOutboundBuffer写缓冲区中的高水位线就是默认的64KB，而低水位线就是默认的32KB     //这就意味着当发送的数据超过了高水位线，channel就不能再继续向写缓冲区发送数据了     //而低于32KB时，channel就可以发送数据     private static final int DEFAULT_LOW_WATER_MARK = 32 * 1024;     private static final int DEFAULT_HIGH_WATER_MARK = 64 * 1024;     //单例，把该类的对象暴露出去     public static final WriteBufferWaterMark DEFAULT =             new WriteBufferWaterMark(DEFAULT_LOW_WATER_MARK, DEFAULT_HIGH_WATER_MARK, false); 	     private final int low;     private final int high; 	//构造方法     public WriteBufferWaterMark(int low, int high) {         this(low, high, true);     }     WriteBufferWaterMark(int low, int high, boolean validate) {         if (validate) {             checkPositiveOrZero(low, "low");             if (high < low) {                 throw new IllegalArgumentException(                         "write buffer's high water mark cannot be less than " +                                 " low water mark (" + low + "): " +                                 high);             }         }         this.low = low;         this.high = high;     } 	//得到低水位线     public int low() {         return low;     } 	//得到高水位线     public int high() {         return high;     }     @Override     public String toString() {         StringBuilder builder = new StringBuilder(55)                 .append("WriteBufferWaterMark(low: ")                 .append(low)                 .append(", high: ")                 .append(high)                 .append(")");         return builder.toString();     } }`

这个 WriteBufferWaterMark 类的对象会被 Channel 的默认配置类 DefaultChannelConfig 持有，然后通过 getWriteBufferHighWaterMark 和 getWriteBufferLowWaterMark 方法在 ChannelOutboundBuffer 写缓冲区中发挥作用。

java

复制代码

`public class DefaultChannelConfig implements ChannelConfig{     //省略其他内容     /**      * @Author: PP-jessica      * @Description:水位线属性终于引入进来了，高水位线为64KB，低水位线为32KB      */     private volatile WriteBufferWaterMark writeBufferWaterMark = WriteBufferWaterMark.DEFAULT;     //省略其他内容     @Override     public int getWriteBufferHighWaterMark() {         return writeBufferWaterMark.high();     }     @Override     public int getWriteBufferLowWaterMark() {         return writeBufferWaterMark.low();     }      }`

既然高低水位线已经引入进来了，接下来，我们就来看一个具体的小例子，看看高低水位线是怎么使用的。就以高水位线为例吧，大家肯定还记得 ChannelOutboundBuffer 中的 addMessage 方法，该方法就是把包装着待发送的字节消息的 ByteBuf 对象添加到写缓冲区内部持有的 Entry 链表中。一旦添加到链表中，就意味着 ByteBuf 包装的消息字节就存放到了写缓冲区中了，自然要计算一下写缓冲区中存放的总的字节数，如果超过了界限，那就停止 Channel 向其持有的写缓冲区中写入字节消息。具体逻辑请看下面代码块。

java

复制代码

`public final class ChannelOutboundBuffer {     //totalPendingSize属性的原子更新器     private static final AtomicLongFieldUpdater<ChannelOutboundBuffer> TOTAL_PENDING_SIZE_UPDATER =             AtomicLongFieldUpdater.newUpdater(ChannelOutboundBuffer.class, "totalPendingSize");     //这个属性记录的就是发送的数据大小，这个属性会和高低水位线做对比，以此决定channel的socket是否还可写     @SuppressWarnings("UnusedDeclaration")     private volatile long totalPendingSize;     //unwritable属性的原子更新器     private static final AtomicIntegerFieldUpdater<ChannelOutboundBuffer> UNWRITABLE_UPDATER =             AtomicIntegerFieldUpdater.newUpdater(ChannelOutboundBuffer.class, "unwritable");          //这个属性是表示socket是否可写，0为可写，1为不可写     @SuppressWarnings("UnusedDeclaration")     private volatile int unwritable;     //省略其他内容     public void addMessage(Object msg, int size, ChannelPromise promise) {         //从entry的对象池中获取一个entry对象         Entry entry = Entry.newInstance(msg, size, total(msg), promise);         //这里要提醒大家一下tailEntry，flushedEntry和unflushedEntry在初始化的时候都是null         //所以这里会判断一下是不是null         if (tailEntry == null) {             flushedEntry = null;         } else {             //走到这里说明不是null，也就意味着已经插入过带发送的消息了             //之所以得到尾节点，因为采用的是尾插法             Entry tail = tailEntry;             tail.next = entry;         }         //走到这里说明是null，说明是第一次添加消息，直接给了尾节点就行         tailEntry = entry;         if (unflushedEntry == null) {             unflushedEntry = entry;         }         //更新写缓冲区存入的字节总量，这时候，就要重点关注这个方法了         incrementPendingOutboundBytes(entry.pendingSize, false);     }     /**      * @Author: PP-jessica      * @Description:更新写缓冲区增加的字节总量      */     private void incrementPendingOutboundBytes(long size, boolean invokeLater) {         //如果size为0，直接返回         if (size == 0) {             return;         }         //用TOTAL_PENDING_SIZE_UPDATER原子更新器把新存入的字节加上去         //addAndGet相当于++i         //得到最新的总存放的字节数         long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);         //这里就比较关键了，其实就是判断totalPendingSize是不是大于了高水位线         if (newWriteBufferSize > channel.config().getWriteBufferHighWaterMark()) {             //如果高于了设置当前的Channel为不可写状态             setUnwritable(invokeLater);         }     }     /**      * @Author: PP-jessica      * @Description:设置channel为不可写入的状态，0为可写，1为不可写      */     private void setUnwritable(boolean invokeLater) {         for (;;) {             final int oldValue = unwritable;             final int newValue = oldValue | 1;             //原子更新器更新unwritable成员变量的值             if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) {                 if (oldValue == 0 && newValue != 0) {                     //在这里还触发了一个回调事件，就是channel不可写之后回调handler中的方法                     //当然，前提是用户的handler中重写了channelWritabilityChanged方法                     fireChannelWritabilityChanged(invokeLater);                 }                 break;             }         }     }     /**      * @Author: PP-jessica      * @Description:该方法就是用来在pipeline中触发fireChannelWritabilityChanged事件，在用户自定义的handler中      * 重写channelWritabilityChanged方法，就可以做出不同的判断处理      */     private void fireChannelWritabilityChanged(boolean invokeLater) {         final ChannelPipeline pipeline = channel.pipeline();         if (invokeLater) {             //封装一个异步任务，这下本类中的fireChannelWritabilityChangedTask成员变量终于用上了             Runnable task = fireChannelWritabilityChangedTask;             if (task == null) {                 fireChannelWritabilityChangedTask = task = new Runnable() {                     @Override                     public void run() {                         //触发回调                         pipeline.fireChannelWritabilityChanged();                     }                 };             }             //异步任务提交给单线程执行器             channel.eventLoop().execute(task);         } else {             pipeline.fireChannelWritabilityChanged();         }     }     /**      * @Author: PP-jessica      * @Description:判断channel是否可写      */     public boolean isWritable() {         return unwritable == 0;     }     //省略其他内容 }`

可以看到，在上面的代码块中，我在 ChannelOutboundBuffer 类中新添加了四个成员变量，分别是用来表示写缓冲区存放的总字节数的 totalPendingSize 和该成员变量的原子更新器 TOTAL_PENDING_SIZE_UPDATER，以及用来表示当前 ChannelOutboundBuffer 对应的 Channel 是否可写的成员变量 unwritable 和该成员变量的院子更新器 UNWRITABLE_UPDATER。每次调用写缓冲区 ChannelOutboundBuffer 的 addMessage 方法向写缓冲区存放字节消息后，都会判断当前写缓冲区存放的总的字节数是否超过了高水位线，也就是超过了 64 KB，如果超过了就限制该 Channel 继续向其对应的写缓冲区中写入字节消息，并且更新 unwritable 成员变量的值为 1，代表当前 Channel 不再能向其对应的写缓冲区中写入数据，并且在 fireChannelWritabilityChanged 方法中还触发了一个入站事件，会在 ChannelPipeline 上回调 channelWritabilityChanged 方法。这就是上面代码块展示的全部逻辑。这里其实也把 ChannelOutboundBuffer 写缓冲区对流量控制的功能体现得更明显了。

但是，这里我必须要强调一下，在 Netty 中，如果一个 Channel 写缓冲区存放的字节总量达到了高水位线的限制，那么所做的也仅仅是把 unwritable 这个成员变量的状态更改为 1，其他的强制 Channel 不能再向写缓冲区写入字节的手段几乎没有。但是，在 Channel 不可写时还出发了一个入站事件，在 ChannelPipeline 上回调 channelWritabilityChanged 方法以此来通知用户。其实这个用意已经很明显了，这显然就是当 Channel 不可写时，让用户按照自己的意愿来处理这种状况。虽说现在是不可写了，但要写还是可以硬写的，反正写缓冲区 ChannelOutboundBuffer 中的 Entry 链表也没有容量限制。当然，用户也可以直接选择不再发送消息了。分析了这么多，那么该怎么通知用户当前 Channel 是否可写呢？具体的做法非常简单，如果用户希望能及时知道一个 Channel 是否可写，就可以直接在自己定义的 handler 处理器中重写 channelWritabilityChanged 方法，在该方法中进行判断和处理。而 Channel 接口中还提供了判断 Channel 是否可写的方法。具体实现请看下面代码块。

java

复制代码

`public interface Channel extends AttributeMap,  ChannelOutboundInvoker{     //其他内容省略     //判断当前Channel是否可写     boolean isWritable(); }`

接下来是 isWritable 方法的具体实现。

java

复制代码

`public abstract class AbstractChannel extends DefaultAttributeMap implements Channel{     //其他内容省略     //判断Channel是否可写     @Override     public boolean isWritable() {         //得到写缓冲区对象         ChannelOutboundBuffer buf = unsafe.outboundBuffer();         return buf != null && buf.isWritable();     } }`

接着，我们再看看用户自行处理 Channel 不可写的情况。这时候就需要用户自己定义一个 handler 处理器，然后在该处理器中重写 channelWritabilityChanged 方法，在该方法中判断 Channel 是否可写。如果不可写，就进一步通知用户。具体实现请看下面代码块。

java

复制代码

`//在自己定义的处理器中重写该方法 @Override public void channelWritabilityChanged(ChannelHandlerContext ctx) {    if (!ctx.channel().isWritable()) {         //走到这里就说明Channel是不可写的了         //用户可以自己定义一些操作    } }`

到此为止，我就为大家把 ChannelOutboundBuffer 写缓冲区的核心知识讲解完毕了。当然，也有一些比较重要的知识没有在文章中涉及，比如当 NIO 的 SocketChannel 把写缓冲区中的数据刷新到 Socket 输出缓冲区后，写缓冲区中的对应数据怎样删除，以及删除之后和低水位线做对比等等操作都没有讲解，但是这些操作的核心逻辑刚才讲解的没什么不同，因此就省略了。不过在我提供的源码中注释非常详细，大家尽可以自己去看一看。接下来，就让我们来看看本章最后一个重要知识点，那就是 OP_WRITE 事件该怎么注册，何时注册。

**注册 OP_WRITE 事件的时机**

之前我们已经接触过 OP_CONNECT、OP_READ 和 OP_ACCEPT 事件，并且知道这些事件的具体作用，只有一个 OP_WRITE 事件还没讲解过。也许有些人会感到困惑，好端端的为什么突然提到了 OP_WRITE 事件？这个就要从 Socket 输出缓冲区说起了。在讲解 ChannelOutboundBuffer 写缓冲区的时候，我们已经了解了 Channel 发送的消息会先存放到写缓冲区中，只有调用了 flush 方法之后，才会把写缓冲区中的消息刷新到 Socket 输出缓冲区中，然后在操作系统的帮助下发送出去。与此同时，我也为大家分析了，Socket 输出缓冲区的容量也是有限制的，并不是可以一直存放数据，假如 Socket 输出缓冲区不能再写入消息了呢？也就是说 Socket 输出缓冲区满了，这时候 Channel 的写缓冲区中还有很多消息等着刷新到 Socket 输出缓冲区中呢，那该怎么办呢？

还是使用最简单直接的方法，既然 Socket 输出缓冲区写满了消息，无法再继续写入消息，那就给当前的 Channel 注册一个 OP_WRITE 事件，只有当 Socket 输出缓冲区可写了，这个 OP_WRITE 事件就会被处罚，然后就可以继续调用 flush 方法，将 ChannelOutboundBuffer 写缓冲区中的数据刷新到 Socket 输出缓冲区中了。当然，触发 OP_WRITE 事件的逻辑肯定是在 NioSocketChannel 中实现的，所以，一会我们还要到 NioSocketChannel 中看一看具体的逻辑是怎么实现的。

现在，让我再来为大家把逻辑梳理一下，真正发送消息的操作是在 NioSocketChannel 的 doWrite 方法中。在该方法中会显得到对应的写缓冲区 ChannelOutboundBuffer 对象和该 NioSocketChannel 包装的 NIO 原生的 SocketChannel，然后根据设定好的发送字节的容量从写缓冲区对象中转换一定数量的 ByteBuffer 对象，这些 ByteBuffer 对象会以数组的形式返回。得到了这些数组之后，就调用 SocketChannel 的 write 方法，直接把这些消息发送到 Socket 输出缓冲区中即可。到此为止，发送消息的关键流程似乎就可以结束了，但是，我不得不提醒一句，如果某个 Channel 某一次要发送的消息特别多，难道一次就能够发送完毕吗？比如说一次要发送 1024 个字节，但是一次只能向 Socket 输出缓冲区中刷新 512 个字节，Socket 输出缓冲区可以存放 4096 个字节。如果是这样的话，只刷新一次到 Socket 输出缓冲区，那还剩下 512 可以刷新呢，对吧？所以，如果一次刷新不完，当然要继续刷新，直到没有数据刷新为止。这时候大家应该也可以意识到了，发送消息的关键流程肯定应该在一个循环之中进行，直到没有数据发送，也就是没有数据可以再刷新到 Socket 输出缓冲区中才能退出循环。

那么，一个新的问题就随之而来了，假如发送消息的关键流程要在一个循环中不断执行，这个循环的次数有限制吗？答案是显而易见的，当然应该有次数限制，这个次数就是 16，具体原因不比我再解释了吧，在重构 read 方法那一章中已经讲过相同的知识了。分析到此，就可以去代码层面看一看，这些逻辑究竟是怎么实现的了。请看下面代码块。

java

复制代码

`public class NioSocketChannel extends AbstractNioByteChannel {     //其他内容省略 	      @Override     protected void doWrite(ChannelOutboundBuffer in) throws Exception {                   //得到SocketChannel，这个是java的nio中原生channel         SocketChannel ch = javaChannel();         //这里会得到写数据的最大次数，默认为16次。限定这个16次的原因和read方法的接收数据和连接的原因一样         //都是为了均衡单线程执行器的工作对象。因为单线程执行器管理了多个channel，还要执行用户提交的各种任务         //不能把单线程执行器都用在一个channel上         //当然，这个参数也是可以通过配置修改的。就是通过ChannelOption.WRITE_SPIN_COUNT来修改         int writeSpinCount = config().getWriteSpinCount();     	     	//下面开始进入循环         do {             //判断写缓冲区是否为空，因为要从写缓冲区中把数据刷新到socket中             if (in.isEmpty()) {                 //直接返回即可，注意，这里直接返回了是因为写缓冲区为null，没有消息可以被刷新到socket中，所以直接返回了                 //到此为止，其实大家应该明白一点，肯定是在下面的逻辑中达到某个限制了，不能再                 return;             }                          //这里得到的是一个默认的可以发送消息的最大字节数，并且这个最大字节数是可以动态调整的             int maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();                          //这里是要把写缓冲区中存放的待刷新消息转换成ByteBuffer，如果消息有很多，就把它们转换成ByteBuffer数组             //实际上就是把ByteBuf转换成ByteBuffer，为什么要这么做呢？再往下看大家就会明白了             //因为说到底Netty是建立在nio之上的一个框架，底层发送消息使用的仍然是nio的数据结构，也就是ByteBuffer，向             //channel中写入数据使用的就是ByteBuffer，所以，要把ByteBuf转换成ByteBuffer             //该方法中的两个参数含义其实很明显，因为要把ByteBuf转换成ByteBuffer数组，1024指的就是这次发送消息，最多可以转换1024个ByteBuffer             //也就是说，nioBuffers数组的长度最大为1024，maxBytesPerGatheringWrite就是本次发送消息所能发送的最大字节数             ByteBuffer[] nioBuffers = in.nioBuffers(1024, maxBytesPerGatheringWrite);                          //这里得到了要发送的ByteBuffer的个数             int nioBufferCnt = in.nioBufferCount();             //走到这里说明要发送的不是单个ByteBuffer，是一个ByteBuffer数组             //这里得到要发送的总的ByteBuffer的字节大小             long attemptedBytes = in.nioBufferSize();                          //开始刷新消息到socket中             final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt);                          //这里判断上面的返回值是不是小于等于0的，如果是说明socket缓冲区已经满了             //不能再继续写入数据，这时候就要注册write事件，而该事件会在socket可写时被触发，然后会通过unsafe调用flush方法             //继续刷新消息到socket中             if (localWrittenBytes <= 0) {                 //注册write事件                 incompleteWrite(true);                 return;             }                          //走到这里说明localWrittenBytes是大于0的，也就是发送消息成功的意思             //下面这个方法就是根据已发送的字节数，调整下一次可以发送的消息字节的数量             adjustMaxBytesPerGatheringWrite((int) attemptedBytes, (int) localWrittenBytes,                     maxBytesPerGatheringWrite);                          //已经从写缓冲区中刷新了这么多字节了，所以要把这些字节从写缓冲区中删除了             in.removeBytes(localWrittenBytes);             //写次数减1             --writeSpinCount;             //循环退出的条件         } while (writeSpinCount > 0);     } }`

上面代码块中的逻辑已经非常清晰了，当 Channel 对应的写缓冲区中没有数据可刷新到 Socket 输出缓冲区中时，就会直接退出该方法；如果 Socket 输出缓冲区中数据写满了呢？这时候就执行了 incompleteWrite(true) 这样一个方法。这个方法定义在了 AbstractNioByteChannel 类中，具体实现如下。

java

复制代码

`public abstract class AbstractNioByteChannel extends AbstractNioChannel{     //其他内容省略     /**      * @Author: PP-jessica      * @Description:给多路复用器注册write事件的方法      */     protected final void incompleteWrite(boolean setOpWrite) {         if (setOpWrite) {             //如果setOpWrite为true，就直接向多路复用器注册wirte事件即可             setOpWrite();         } else {             //暂时省略         }     }     /**      * @Author: PP-jessica      * @Description:向多路复用器注册write事件      */     protected final void setOpWrite() {         final SelectionKey key = selectionKey();         if (!key.isValid()) {             return;         }         final int interestOps = key.interestOps();         if ((interestOps & SelectionKey.OP_WRITE) == 0) {             key.interestOps(interestOps | SelectionKey.OP_WRITE);         }     } }`

这样一来，OP_WRITE 事件就终于注册成功了。当然，当 Socket 输出缓冲区再次可写时，就会触发 OP_WRITE 事件，这时候逻辑就来到了 NioEventLoop 中了。请看下面代码块。

java

复制代码

`public class NioEventLoop extends SingleThreadEventLoop {     //其他内容省略     private void processSelectedKey(SelectionKey k,AbstractNioChannel ch) throws Exception {         try {             //获取Unsafe类             final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();             //得到key感兴趣的事件             int ops = k.interestOps();             //如果是连接事件             if (ops == SelectionKey.OP_CONNECT) {                 //移除连接事件，否则会一直通知，这里实际上是做了个减法。位运算的门道，我们会放在之后和线程池的状态切换一起讲                 //这里先了解就行                 ops &= ~SelectionKey.OP_CONNECT;                 //重新把感兴趣的事件注册一下                 k.interestOps(ops);                 //这里要做真正的客户端连接处理                 unsafe.finishConnect();             }             //如果是write事件             if ((ops & SelectionKey.OP_WRITE) != 0) {                //这里就会执行强制刷新的方法，就会把消息从写缓冲区中刷新到socket中                 unsafe.forceFlush();             }             if (ops ==  SelectionKey.OP_READ) {                 unsafe.read();             }             if (ops == SelectionKey.OP_ACCEPT) {                 unsafe.read();             }         } catch (CancelledKeyException ignored) {             throw new RuntimeException(ignored.getMessage());         }     } }`

如果触发了 OP_WRITE 事件，在上面代码块的第 26 行，就会调用 unsafe.forceFlush() 这行代码。经过调用链路上的几个方法之后，最后程序又会来到 AbstractChannel 类中，执行该类的 flush0() 方法。于是，当前 Channel 持有的写缓冲区中的数据又会开始向 Socket 输出缓冲区中刷新。到此为止，发送消息的整体流程似乎已经讲解完毕了。但是，情况没有我们认为的这么简单。

请大家仔细想想，在之前的 doWrite 方法中，我们虽然已经实现了注册 OP_WRITE 事件，但实际上，只处理了两种情况。第一种就是写缓冲区为空，根本就没有数据要刷新到 Socket 输出缓冲区中，这种情况就可以直接退出 doWrite 方法；第二种情况就是在一个循环中不停地把写缓冲区中的数据刷新到 Socket 输出缓冲区中，直到输出缓冲区被写满了，这时候就不得不注册一个 OP_WRITE 事件，等待该事件触发，然后重新调用 flush 方法，继续将写缓冲区中的数据刷新到 Socket 输出缓冲区中。但是还有第三种情况呢，假如循环了 16 次，写缓冲区中仍然有数据需要刷新到 Socket 输出缓冲区中呢？并且 Socket 输出缓冲区依然可写，可这时候显然不能继续刷新了，因为其他 Channel 还要使用这个线程来刷新自己的数据到自己的 Socket 输出缓冲区中，不能只让一个 Channel 独占线程资源。这时候该怎么办呢？

在 Netty 中，如果出现了这种情况，就单独封装一个异步任务，在这个异步任务中就会最终调用 AbstractChannel 类的 flush0() 方法，然后把这个异步任务提交给单线程执行器，让单线程执行器有时间的时候执行便可。不得不说，在分配资源的处理上，Netty 的手段真的很高明，把一个线程资源压榨到了极致。具体实现请看下面代码块。

首先还是 NioSocketChannel 的 doWrite 方法，这里给大家展示循环满 16 次后，写缓冲区中还有数据需要刷新到 Socket 输出缓冲区的情况。

java

复制代码

`public class NioSocketChannel extends AbstractNioByteChannel {      //其他内容省略 	      @Override     protected void doWrite(ChannelOutboundBuffer in) throws Exception {          //部分代码省略              	//下面开始进入循环         do {             //部分代码省略                         --writeSpinCount;         } while (writeSpinCount > 0);         //走到这里就已经退出了while循环         //在下面的方法中会判断writeSpinCount是否小于0         //writeSpinCount默认是16次，就算全部循环完也只会等于0         //所以不会小于0，下面方法中传进去的参数就是false         //并且这时候Socket输出缓冲区中一定是可写的，如果不可写就注册write事件         //然后直接退出该方法了，根本就执行不到这里         incompleteWrite(writeSpinCount < 0);     }      }`

接下来是定义好的异步任务，这个异步任务定义在了 AbstractNioByteChannel 类中。

java

复制代码

`public abstract class AbstractNioByteChannel extends AbstractNioChannel{     //提交给单线程执行器一个异步任务，用于刷新缓冲区     private final Runnable flushTask = new Runnable() {         @Override         public void run() {             ((AbstractNioUnsafe) unsafe()).flush0();         }     };     //其他内容省略     /**      * @Author: PP-jessica      * @Description:给多路复用器注册write事件的方法      */     protected final void incompleteWrite(boolean setOpWrite) {         if (setOpWrite) {             //如果setOpWrite为true，就直接向多路复用器注册wirte事件即可             setOpWrite();         } else {             //这里就是提交了一个异步任务，在异步任务中执行了 ((AbstractNioUnsafe) unsafe()).flush0()方法             //这里也再次反映出了单线程执行器的均衡性，不会把自己交给一个channel无限执行它的发送消息任务             eventLoop().execute(flushTask);         }     } }`

到此为止，这一章的内容才算是全部讲解完毕了。Netty 发送消息的核心流程也就完全展示给大家了。当然，还有一些细节，比如写缓冲区中的数据刷新到 Socket 输出缓冲区后怎么从写缓冲区中删除，怎么动态调整每一次可以向 Socket 输出缓冲区发送的最大字节数，这些逻辑流程就留给大家去我提供的源码中学习吧。其中，删除写缓冲区中的数据还是很重要的步骤，大家要仔细看一看。

好了，我们下一章见。

**总结**

本章的内容并不算多，总体上也就三个知识点：第一是实现 ByteBuf 转换为 ByteBuffer 功能；第二个是解决写缓冲区内存溢出；第三就是剖析注册 OP_WRITE 事件时机，以及如何处理 OP_WRITE 事件。这些都没什么好说的了。我只想再多说一点，算是一个小问题吧，那就是当调用 writeAndFlush 方法的时候，同时也会向方法中传入一个 Promise 对象，用户可以从这个对象中获得发送消息是否成功的结果。我想问大家的问题是，这个 Promise 什么时候就会被设置为成功状态了呢？这没什么好说的，自然是当要发送的消息刷新到 Socket 输出缓冲区之后了。那么，刷新成功之后，这个 Promise 在哪里被设置为成功状态了呢？这就是我留给大家的问题。我现在可以直接告诉大家答案，就是在写缓冲区删除已经成功刷新到 Socket 输出缓冲区中的数据的时候，也就是在写缓冲区 ChannelOutboundBuffer 的 remove 方法中，这个逻辑就留给大家自己去看吧。