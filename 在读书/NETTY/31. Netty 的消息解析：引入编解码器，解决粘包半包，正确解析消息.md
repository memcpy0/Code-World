大家好，这一章的内容非常简单，就是对 Netty 中编解码器的一个讲解。知识点只有两个，第一就是编码器的实现，第二就是解码器的实现。

**编码器的实现原理**

所谓编解码器，说到底其实都是 Netty 的 ChannelPipeline 上的节点处理器。这一点想必大家已经很熟悉了。当要把一条消息发送出去的时候，肯定会调用 Channel 的 write 方法，把要发送的消息存放到 Channel 拥有的写缓冲区中，然后会进一步调用 flush 方法，写缓冲区中的消息才能刷新到 Socket 输出缓冲区中。这是上一章的知识，这里之所以再次回顾，是因为在发送消息的过程中，少了一个关键的步骤，那就是给要发送的消息进行编码。请大家想一想，当我们要发送一条消息给目标服务器时，就比如说进行 RPC 远程调用吧，我们发送一条消息，肯定是把这条消息封装到一个对象中，而不是单独发送，比如封装到一个 Request 对象中。也就是说我们发送消息的时候，发送的就是一个 Request 对象。要网络传输这个 Request 对象，肯定就要对这个对象进行序列化，这个序列化的操作就是在编码器中进行的。紧接着，就将编码完成的消息存放到 Channel 对应的写缓冲区中，等待刷新到 Socket 输出缓冲区中。到此为止，发送消息流程才算是完整了。

现在让我再来为大家总结一下发送消息的流程，首先是 Channel 调用 write 方法，这个方法通常是在用户自己定义的消息处理器中被调用的(一条消息被接收到后肯定会在用户自己定义的消息处理器中被处理，但处理完之后，就会在处理器中立刻给目标服务器回复一条消息，所以我就直接让消息在消息处理器中发送了)，也就是说，会先经过用户自己定义的处理器发送消息；之后发送的这条消息就会传递到 ChannelPipeline 链表上面，同时触发 ChannelPipeline 链表中所有出站节点，也就是所有出站处理器中 write 方法的回调(这些都是旧知识，所以我就不再详细讲解了)；这时候传递的这个消息，假如说就是一个 Request 对象，这个对象还没有经过序列化，是无法在网络中传输的，就算经过了序列化，也要根据相应的传输协议进行编码，才能被目标服务器接收之后顺利解析，所以这个消息对象显然就要经过编码处理器进行编码，这就意味着编码处理器肯定是个出站处理器，同时也意味着，编码处理器肯定要重写 write 方法，在 write 方法中对消息对象 Request 进行序列化然后编码，因为发送消息时触发的是每一个出站处理器 write 方法的回调；接下来编码完成的消息对象就会被传递到 ChannelPipeline 链表的头节点，在头节点中被放到 Channel 对应的写缓冲区中，等待刷新到 Socket 输出缓冲区中。

在此，我为大家准备了一幅简图用来对上面的整个流程做补充说明。请看下面简图。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f227abde7159496c8bd113a05b17862c~tplv-k3u1fbpfcp-jj-mark:1890:0:0:0:q75.awebp#?w=1642&h=556&s=58555&e=jpg&b=fefefe)

当然，编码器也是需要用户自己来定义的。并且，如果要从代码上实现我刚才为大家总结的流程，就要使用 Netty 构建下面的服务端，或者是客户端。其实是客户端或者是服务端并不重要，重要的是用户自己定义的消息处理器和用户自己定义的编码器在 ChannelPipeline 上的排列顺序。因为消息是要向外发送的，触发的肯定是出站事件，要发送的消息对象会从 ChannelPipeline 链表的尾部向头部传递，消息会先经过用户用户自己定义的消息处理器，然后再传递到编码器中，最后再传递到 ChannelPipeline 链表的头节点中。

java

复制代码

`public class ServerTest {     public static void main(String[] args) throws UnknownHostException, InterruptedException {         EventLoopGroup bossGroup = new NioEventLoopGroup();         EventLoopGroup workerGroup = new NioEventLoopGroup();         try {             ServerBootstrap b = new ServerBootstrap();             b.group(bossGroup, workerGroup)                     .channel(NioServerSocketChannel.class)                     .handler(new LoggingHandler(LogLevel.INFO))                     .childHandler(new ChannelInitializer<SocketChannel>() {                         @Override                         public void initChannel(SocketChannel ch) throws Exception {                             ChannelPipeline pipeline = ch.pipeline();                             //下面写成伪代码                             //先添加编码器                             pipeline.addLast(new 编码器());                             //再添加用户自定义的消息处理器                             pipeline.addLast(new 消息处理器());                         }                     });             ChannelFuture f = b.bind(port).sync();             f.channel().closeFuture().sync();         } finally {             bossGroup.shutdownGracefully();             workerGroup.shutdownGracefully();         }     } }`

到此为止，要发送的消息经过的全流程就已经补充完整了。当然，我也只是简单引入了编码器这个功能组件，并没有真正实现一个。为了使大家对编码过程理解得更透彻，接下来我就来为大家实现一个编码器。要实现编码器，首先就要明确编码器的身份，其次，还需要明确编码器的功能，也就是说，要知道究竟要让编码器做什么工作。最后，还要考虑到编码器工作时会不会受到什么限制。接下来，我就从这三方面一点点为大家剖析，迭代出一个功能完整的编码器。

首先，编码器的身份就不用多说了，肯定是一个出站处理器，并且要重写父类的 write 方法。既然我提到了父类，这时候大家肯定就意识到了，我要定义的这个编码器一定继承了某个类。根据之前讲过的内容，显然，这个编码器应该继承了 ChannelOutboundHandlerAdapter 类。这个类是一个出站处理器适配器，也是一个出站处理器。我要定义的出站处理器一但继承了这个类，肯定也就是一个出站处理器了。当然，让我定义的编码器继承这个 ChannelOutboundHandlerAdapter 类不仅只有这一个好处，请大家先看看 ChannelOutboundHandlerAdapter 类的具体内容，一定会觉得十分熟悉。

java

复制代码

`/**  * @Author: PP-jessica  * @Description:该类中的所有入出站方法都加上了@Skip注解，那么该类的实现类就可以重写该类的某些方法，去掉@Skip注解，表示该handler对  * 特定的事件感兴趣  */ public class ChannelOutboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelOutboundHandler {     @Skip     @Override     public void bind(ChannelHandlerContext ctx, SocketAddress localAddress,                      ChannelPromise promise) throws Exception {         ctx.bind(localAddress, promise);     }     @Skip     @Override     public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,                         SocketAddress localAddress, ChannelPromise promise) throws Exception {         ctx.connect(remoteAddress, localAddress, promise);     }     @Skip     @Override     public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise)             throws Exception {         ctx.disconnect(promise);     }     @Skip     @Override     public void close(ChannelHandlerContext ctx, ChannelPromise promise)             throws Exception {         ctx.close(promise);     }     @Skip     @Override     public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {         ctx.deregister(promise);     }     @Skip     @Override     public void read(ChannelHandlerContext ctx) throws Exception {         ctx.read();     }     @Skip     @Override     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {         ctx.write(msg, promise);     }     @Skip     @Override     public void flush(ChannelHandlerContext ctx) throws Exception {         ctx.flush();     } }`

在 ChannelOutboundHandlerAdapter 类中的每一个方法上面都有一个 @Skip 注解，这个注解的作用十分明显，只要添加了这个注解的方法，就意味着对 ChannelPipeline 链表中触发的某些事件不感兴趣，也就不会回调对应的方法。而没有添加 @Skip 注解的方法，就意味着对某个事件感兴趣，其对应的方法也会被回调。如果我定义的编码器继承了 ChannelOutboundHandlerAdapter 类，并且重写了 wirte 方法，重写之后的 write 方法去掉了 @Skip 注解。这样一来，就表明我定义的编码器，其作为出站处理器对 write 方法触发的出站事件感兴趣，而编码器的 write 方法也会被毁掉。这样一来，我们就可以在编码器的 write 方法中对一路传递过来的要发送的消息对象进行序列化和编码操作了。所以，我定义的编码器已经初步成型了，可以写成下面这样。请看下面代码块。

既然是我自己定义的编码器，就叫做 MyEncoder 吧。

java

复制代码

`public abstract class MyEncoder extends ChannelOutboundHandlerAdapter {     //构造方法     protected MyEncoder() {              }     //在该方法内对要发送的消息对象进行序列化和编码，在该方法的参数列表中，msg这个参数就是要发送的消息对象     @Override     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {         //暂时还不做实现     } }`

在上面的代码块中，我定义了一个结构简单的编码器 MyEncoder，当然，这个编码器中的 write 方法还没做实现。因为我忽然意识到我定义的编码器有一个必须具备的功能，应该先把这个必须具备的功能实现了，才能考虑如何给要发送的消息对象编码。根据前两章讲解的内容，我们已经知道了，所有要发送的消息不管怎么编码，它们其实都要存放到一块堆外缓冲区中，也就是要使用一个 ByteBuf 对象包装。这个 ByteBuf 对象最终会被存放到与发送消息的 Channel 对应的 写缓冲区中，然后转换成 ByteBuffer 刷新到 Socket 输出缓冲区中。这也就意味着，我们要发送的这条消息首先应该被包装在一个 ByteBuf 对象中。这一点，我想是很容易理解的。

但是请各位再想想，难道可以直接在用户自己定义的消息处理器中把要发送的消息交给一个 ByteBuf 对象吗？也就是说在在用户想发送消息的时候，用户已经把消息内容封装到自己定义的消息对象中了，然后还要再创建一个 ByteBuf 对象，接着把消息对象序列化，因为 ByteBuf 持有的堆外内存中只能写入字节，所以把消息对象序列化是必须的。序列化完成之后再把消息对象写入到 ByteBuf 对象中，接着把这个 ByteBuf 对象向 ChannelPipeline 链表头部传递，传递到用户自己定义的编码器中，对这个 ByteBuf 对象持有的消息对象按照传输协议进行编码。就像下面这段伪代码，请看下面代码块。

java

复制代码

`//这是用户自己定义的消息处理器 public class TestHandler extends ChannelInboundHandlerAdapter {     @Override     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {         //假如用户定义的消息发送对象为RequestMsg。消息的响应对象为ResponseMsg         //首先把msg参数转换为消息响应对象，类型判断我就省略了，这里得到的消息响应对象msg         //是已经成功解码之后的对象，所以可以直接转换         ResponseMsg rsp = (ResponseMsg)msg;         //对响应回来的消息进行处理         System.out.println("处理响应消息");         //处理完消息之后，如果有需要就再发送一条请求消息。其实写过一些rpc框架的朋友可能会觉得         //通常都是在消息处理器中接收到RequestMsg，然后把消息交给业务线程池去处理，最后在         //业务线程池中回复消息，因为是业务线程池回复的消息，而在Netty中所有消息的发送都是由         //单线程执行器来处理的，所以会把发送消息的操作封装成异步任务，提交给单线程执行器的任务队列         //这里我们就不那么严谨了，毕竟只是一个小例子，就直接在消息处理器中回复消息，或者说是再发送         //一条请求消息，接下来，就要创建一个请求消息对象         RequestMsg req = new RequestMsg();         //设置要发送的消息内容         req.set(消息内容);         //序列化RequestMsg对象，你可以使用Protocol Buffers来序列化消息对象，这里我就写成伪代码了         byte[] bytes = req.toByteArray();         //创建一个ByteBuf对象，这里就暴露出问题了，一会就会讲解         ByteBuf out = new ByteBuf();         //把序列化好的对象写入到ByteBuf中         out.writeBytes(bytes);         //将ByteBuf对象向链表前方传递         super.channelRead(ctx, msg);     } }`

上面代码块中的缺点是显而易见的，首先最不能容忍的就是要交给用户自己操作的步骤实在是太多了，如果我作为用户使用一个框架，我希望当我定义好要发送的消息对象后，直接调用相应方法发送就可以了，当然，肯定要按照我自己的定义的方式编码。至于其他的，这个消息怎么被包装到一个 ByteBuf 对象中，ByteBuf 对象怎么放到写缓冲区中，又怎样刷新到 Socket 输出缓冲区中我通通不想关心，如果我要关心这么多操作，甚至是自己亲自实现比较多的操作步骤，那还不如我自己开发一个框架。所以，上面代码块中创建 ByteBuf 对象的操作应该全部删去。当然，如果有的用户偏偏希望就在消息处理器中创建 ByteBuf 对象，就像上面那样，让我们看看会出现什么问题。就在上面代码块的第 26 行，创建了一个 ByteBuf 对象，请大家想一想，这么做合适吗？如果大家还记的内存分配模块的知识，就会意识到这么做大有问题。在 Netty 中只有经过内存分配体系创建出来的 ByteBuf 对象才持有堆外内存，也就是从内存分配器中分配出来的 ByteBuf 才能被我们使用。直接创建一个 ByteBuf 对象根本没办法被顺利使用。所以，如果要在消息处理器中创建 ByteBuf 对象，显然也要在消息处理器中得到内存分配器，让内存分配器帮我们分配出一个持有了堆外内存的 ByteBuf 对象。可这样一来，用户定义的消息处理器就要添加新的成员变量，或者定义新的方法来得到内存分配器，要做的事越来越多。所以，我们最好不要直接就在消息处理器中创建 ByteBuf 对象，消息处理器所做的就是将用户定义好的消息对象向 ChannelPipeline 链表之前传递就行了。但是消息对象总该存放到 ByteBuf 对象中啊，在哪里存放呢？我决定在编码器中进行这一步操作。

除了把创建 ByteBuf 对象的操作放在编码器中，让我们再来想一想，编码器还需要进行怎样的改造。通常来说，在 RPC 远程调用的时候，编码器是用户自己的定义的，传输协议也是用户自己定义的，序列化对象的方式也是用户自己定义的。当然，这些都可以在框架中提供一些现成的组件，但是最终决定权还是要交给用户。这就意味着，在 Netty 框架中，肯定要暴露给用户一个接口或者是抽象类，让用户可以在实现类中大展拳脚。之前我定义的消息处理器中使用的是 Protocol Buffers 来序列化对象，难道就不能使用 JDK 自带的序列化方式序列化对象吗？当然，你也可以使用 SPI 方式进一步为序列化方式提供更多的扩展，但这不是本章的内容，所以不做讨论。

总之，我现在的意图很明显，考虑到框架的灵活性和扩展性，用户可以自己定义编码方式和序列化方式，所以我决定在框架中提供一个抽象父类，这个抽象父类所做的工作就是创建 ByteBuf 对象，把这个 ByteBuf 对象交给编码器使用，同时我还要在抽象父类中定义一个名为 encode 的抽象方法。如果用户想自己实现一个编码器，那就直接继承这个抽象父类，实现 encode 抽象方法，在该方法中对要传输的消息对象进行序列化操作，然后根据传输协议进行编码操作，把数据写入 ByteBuf 对象中。这就是我框架中内置编码器的最终实现版本。这时候，我就不再称编码器为 MyEncoder，而是换成一个更正规的名字，叫做 MessageToByteEncoder。接下来，我们就先来看看 MessageToByteEncoder 具体是怎么实现的。请看下面代码块。

下面代码块中的泛型 I 先不必关心。

java

复制代码

`public abstract class MessageToByteEncoder<I> extends ChannelOutboundHandlerAdapter {     //使用的是否为直接内存     private final boolean preferDirect;          protected MessageToByteEncoder() {         //默认为true，说明ByteBuf对象使用的是堆外内存         this.preferDirect = true;     }     @Override     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {         ByteBuf buf = null;         //把ByteBuf创建出来，因为最后编码完成的字节还是要放到ByteBuf中的         //这里虽然把msg传到下面的方法中了，但是在方法内并没有用到msg，所以大家可以忽略这一点         buf = allocateBuffer(ctx, cast, preferDirect);                  //这里是真正编码的逻辑，是个抽象方法，一般由用户自己实现，这就意味着用户自定义的编码器类         //要继承这个MessageToByteEncoder类的         //当然，用户也可以使用Netty为大家定义好的编解码器，这里我就不讲解了，大家可以自己查查         //其实最核心的就是这个encode抽象方法的实现逻辑         encode(ctx, cast, buf);                  //有数据就在管道上一路传递即可，最后出站发送出去         ctx.write(buf, promise);     }     //创建ByteBuf的方法，就是直接让内存分配器分配一个持有了堆外内存的ByteBuf对象     protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, @SuppressWarnings("unused") I msg,                                      boolean preferDirect) throws Exception {         if (preferDirect) {             //这里没有传入一个要分配的内存容量，是因为在内部用一个初始值256分配内存了             //当然，也可能会遇到分配的内存不够的情况，这时候ByteBuf会自动扩容的             //大家可以顺着逻辑点一点，方法在AbstractByteBuf类中             return ctx.alloc().ioBuffer();         } else {             return ctx.alloc().heapBuffer();         }     }     /**      * @Author: PP-jessica      * @Description:编码的抽象方法，要交给子类来实现      */     protected abstract void encode(ChannelHandlerContext ctx, I msg, ByteBuf out) throws Exception;     protected boolean isPreferDirect() {         return preferDirect;     } }`

接下来我再定义一个真正的编码器，这个编码器就是用户真正定义的，我可以把它叫做 MyEncoder，这个编码器要继承上面的 MessageToByteEncoder 类，请看下面代码块。

java

复制代码

`public abstract class MyEncoder extends MessageToByteEncoder<RequestMsg> {     //在该方法内对要发送的消息对象进行序列化和编码，在该方法的参数列表中，msg这个参数就是要发送的消息对象     @Override     public void write(ChannelHandlerContext ctx, RequestMsg msg, ChannelPromise promise) throws Exception {         //这里就让用户自己去实现吧     } }`

这时候大家应该能够回想起来了，在使用 Netty 开发的时候，往往就是以上面代码块的方式来创建自己定义的编码器的。这个逻辑都很简单，代码块中的注释也很详细，所以我就不再讲解了。现在我们要关心的一点就是，在 MessageToByteEncoder 类中有一个泛型 I，之前我没有给大家解释这个泛型的作用，但是当我展示了上面的 MyEncoder 类之后，我相信大家也已经明白了，这个泛型其实就是用来限制要编码的消息对象。也就是说，当一个消息对象要被序列化然后进行编码的时候，应该让编码器知道，正在被编码的消息对象是否是自己想要的。如果我定义的是一个 RequestMsg 消息对象的编码器，这个编码器只对 RequestMsg 消息对象进行编码，但这时候传递到消息对象中的是一个 String，显然就不能编码成功。因为，需要设定一个泛型，让当前的编码器知道自己正在处理器的对象是否与设定的一致。这样一来，编码器中显然应该还增加一个功能，那就是根据自己泛型的类型来判断，当前正在处理的消息对象是否与泛型类型一致。这个功能自然也要在抽象父类 MessageToByteEncoder 中实现。在 Netty 中有一个名为 TypeParameterMatcher 的类型匹配器定义在 MessageToByteEncoder 类中了，这个 TypeParameterMatcher 类型匹配器就是用来判断要处理的消息对象是否和泛型中的类型一致。具体逻辑请看下面重构完善的 MessageToByteEncoder 类。请看下面代码块。

java

复制代码

`public abstract class MessageToByteEncoder<I> extends ChannelOutboundHandlerAdapter {     //这个成员变量就是类型匹配器，用它来判断将要编码的对象是否和类中的泛型一致     //这个属性在UnpaddedInternalThreadLocalMap中被保存了     //TypeParameterMatcher类的具体内容就不在文章中讲解了，提供的源码中有详细注释     private final TypeParameterMatcher matcher;     //使用的是否为直接内存     private final boolean preferDirect;     //这个构造函数没有把要编码的类型传进来，所以内部会使用反射得到要编码的类型，然后再创建对应的类型匹配起     protected MessageToByteEncoder() {         this(true);     }     protected MessageToByteEncoder(boolean preferDirect) {         //通过静态方法find得到对应的类型匹配器         matcher = TypeParameterMatcher.find(this, MessageToByteEncoder.class, "I");         this.preferDirect = preferDirect;     }      /**      * @Author: PP-jessica      * @Description:检查要编码的类型是否和泛型类型匹配的方法      */     public boolean acceptOutboundMessage(Object msg) throws Exception {         return matcher.match(msg);     }     /**      * @Author: PP-jessica      * @Description:编码的方法，这里我想跟大家多说一句，请大家回想一下在Netty中是怎么发送消息的      * 在常规项目中，比如用Netty进行通信等等，我们回自己定义请求和响应的编解码器，对吧？我们通过      * writeAndFlush方法发送的其实就是一个request类型的对象，然后这个对象会经过编码器，在编码器中      * 被类型匹配器判断通过，然后在下面的这个write方法中被编码，然后用ByteBuf来包装编码后的字节      * 最后一路传递到出站的头节点，把消息发送出去。整个流程就是这样，大家要梳理清楚。虽然我们是渐进式学习代码      * 总是局部地学习一块块知识，但是整体的大局观和流程要时刻梳理，这样才有助于你的工作      */     @Override     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {         ByteBuf buf = null;         try {             //首先仍然是判断当前传进来的msg是否符合泛型的类型             //会通过类型匹配器来判断             if (acceptOutboundMessage(msg)) {                 //转换成对应的类型                 @SuppressWarnings("unchecked")                 I cast = (I) msg;                 //把ByteBuf创建出来，因为最后编码完成的字节还是要放到ByteBuf中的                 buf = allocateBuffer(ctx, cast, preferDirect);                 try {                     //这里是真正编码的逻辑，是个抽象方法，一般由用户自己实现，这就意味着用户自定义的编码器类                     //要继承这个MessageToByteEncoder类的                     //当然，用户也可以使用Netty为大家定义好的编解码器，这里我就不讲解了，大家可以自己查查                     //其实最核心的就是这个encode抽象方法的实现逻辑                     encode(ctx, cast, buf);                 } finally {                     //这时候就要释放cast了，也就是源码的msg的内存。注意，这个cast已经转换成对应的泛型类型了                     //它不一定是ByteBuf，或者说，它其实就是一个非ByteBuf的对象，因为这些消息的载体对象都是用户自定义的                     //所以下面并不会把它当作ByteBuf来释放内存空间，而是直接返回false，由垃圾回收机制来释放内存                     ReferenceCountUtil.release(cast);                 }                 //因为已经编码完毕了，所以判断ByteBuf中是否有数据了                 if (buf.isReadable()) {                     //有数据就在管道上一路传递即可，最后出站发送出去                     ctx.write(buf, promise);                 } else {                     //没有数据就释放ByteBuf                     buf.release();                     //传递一个空的ByteBuf给下一个处理器                     //这行被注释掉的代码是源码，因为没有引入Unpooled，所以就注释掉了                     //ctx.write(Unpooled.EMPTY_BUFFER, promise);                     ctx.write(null, promise);                 }                 buf = null;             } else {                 //到这里就说明一开始类型就不匹配，直接向下一个handler传递即可                 ctx.write(msg, promise);             }         } catch (EncoderException e) {             throw e;         } catch (Throwable e) {             throw new EncoderException(e);         } finally {             if (buf != null) {                 buf.release();             }         }     }     protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, @SuppressWarnings("unused") I msg,                                      boolean preferDirect) throws Exception {         if (preferDirect) {             //这里没有传入一个要分配的内存容量，是因为在内部用一个初始值256分配内存了             //当然，也可能会遇到分配的内存不够的情况，这时候ByteBuf会自动扩容的             //大家可以顺着逻辑点一点，方法在AbstractByteBuf类中             return ctx.alloc().ioBuffer();         } else {             return ctx.alloc().heapBuffer();         }     }     /**      * @Author: PP-jessica      * @Description:编码的抽象方法，要交给子类来实现      */     protected abstract void encode(ChannelHandlerContext ctx, I msg, ByteBuf out) throws Exception;     protected boolean isPreferDirect() {         return preferDirect;     } }`

好了，到此为止，如果用户想创建一个编码器，就可以直接定义一个类继承 MessageToByteEncoder 类，然后在自己定义的类中实现 encode 方法。而在程序执行的时候，当要发送的消息对象传递到用户自己定义的编码器中时，程序就会先来到其抽象父类 MessageToByteEncoder 中，执行 write 方法的回调，执行了一系列操作之后，会来到子类中执行 encode 方法，进行真正的编码，最后又会回到父类中，继续把 ByteBuf 对象向链表前面传递，这就是编码器负责的整个流程。

**解码器的实现原理**

编码器的具体实现原理已经剖析完毕，并且我也给大家呈现了一个完整的编码器。接下来就轮到解码器登场了。在讲解编码器的时候，我为大家详细分析了编码器的抽象父类的由来，因此，讲解解码器时就不再重复分析了。说到底，编解码器本质上就是 ChannelPipeline 链表上的处理器。编码器是出站处理器，相对应的，解码器就是入站处理器。编码器可以由用户自己定义编写，解码器当然也可以由用户自己编写定义。当然，用户定义的解码器仍然需要继承一个抽象父类，在抽象父类中实现一些操作，而用户自己创建的解码器只需要专心解码即可。所以，现在的问题就变成了，抽象父类解码器中要提前实现什么操作？

首先还是考虑 ByteBuf 对象的创建，所有接收到的消息同样需要写入一块堆外内存中，而堆外内存被 ByteBuf 对象包装着，所以接收到的消息需要一个 ByteBuf 对象来包装。但是，这个 ByteBuf 对象在接收消息的时候就创建了，并不需要在解码器中创建，换句话说，传递到解码器中的消息对象已经被包装在 ByteBuf 对象中了，传递过来的就是一个 ByteBuf 对象。解码器要做的就是从 ByteBuf 对象中按照传输协议读取字节然后判断，最后对其进行解码。

既然不用在解码器中创建 ByteBuf 对象了，那解码器似乎就剩下一个需要考虑的问题了，那就是当前被解码的消息对象并不完整时，应该怎么办？所谓被解码的消息对象并不完整，就是当接收到一条消息时，发现这条消息并不是一条完整的消息，按照通常的做法，会直接退出解码的方法，等待消息接收完整后，再重新解码。具体例子可以看下面的代码块。

下面就是一个自定义解码器。

java

复制代码

`/**  * 自定义解码器类，继承自Netty的ByteToMessageDecoder类。  * 使用Netty进行网络编程时，可以在ChannelPipeline中添加这个解码器，用于将接收到的字节流解码为字符串。  */ public class ByteToStringDecoder extends ByteToMessageDecoder {     /**      * 该方法用于将字节流解码为字符串。      *      * @param ctx ChannelHandlerContext对象，提供了许多操作Channel的方法      * @param in 接收到的字节流      * @param out 解码后的字符串将被添加到这个List对象中      */     @Override     protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {         //检查是否至少有4个字节可以读取（一个 int 的长度）         if (in.readableBytes() < 4) {             //消息不完整，退出方法             return;          }                   //标记当前的读位置，如果消息不完整，可以回滚到这个位置         in.markReaderIndex();                  //读取传入的字节长度         int length = in.readInt();         //检查ByteBuf中是否有足够的字节来读取，如果字节长度不够，说明不是一个完整的消息         if (in.readableBytes() < length) {             //回滚到标记的读位置             in.resetReaderIndex();              //消息不完整，退出方法             return;         }         //读取字节到bytes字节数组中         byte[] bytes = new byte[length];         in.readBytes(bytes);         //将字节转换为字符串并添加到解码消息的列表中         out.add(new String(bytes, StandardCharsets.UTF_8));     } }`

上面就是一个常规的自定义解码器的雏型，在 RPC 远程调用的时候，解码器就是这样定义的。但现在我只是列出来一个定义好的解码器，那么当解码器中接收到的消息并不完整时，这些不完整的消息要怎样处理呢？这就是上面这个解码器的抽象父类 ByteToMessageDecoder 要做的工作了。实际上，在 ByteToMessageDecoder 类中，定义了一个名为 cumulation 的成员变量，这个成员变量是 ByteBuf 类型，持有了一块堆外内存，当接收到的消息不完整时，就可以把接收到的消息直接存放到这个 ByteBuf 对象持有的堆外内存中，ByteBuf 是可以自动扩容的，所以也不必担心容量不够用的问题。而那些解码完毕，也就是解码成功，消息完整的消息对象，就会全部放到一个 List 集合中，这个集合是 Netty 自己定义的，叫做 CodecOutputList，该类继承了 AbstractList，显然就是一个集合。

这样一来流程就很清晰了。当编码器接收到的消息不完整时，那就不对这条消息进行解码，把接收到的数据暂时存放到 ByteToMessageDecoder 类中的 cumulation 成员变量中，当消息接收完整时，会再对消息进行解码，解码成功后的消息会存放到 CodecOutputList 集合中。然后将 CodecOutputList 集合中存放的消息向 ChannelPipeline 链表后面的处理器中传递。这时候大家应该也能意识到了，其实这个 CodecOutputList 集合就是上面代码块中 decode 方法的第三个参数，第三个参数 out 恰好是一个 List 集合，并且在方法中判断接收到的消息是完整的，就会将消息解码，然后添加到 out 集合中。接下来我们就来看看 CodecOutputList 和 ByteToMessageDecoder 这两个类是怎么实现的。

首先是 CodecOutputList 类，请看下面代码块。

java

复制代码

`/**  * @Author: PP-jessica  * @Description:这个类的作用很简单，就是把累加缓冲区的字节，解码后存放到这个类的对象中，然后从这个类的对象中，把消息  * 传递给后面的handler  */ final class CodecOutputList extends AbstractList<Object> implements RandomAccess {     /**      * @Author: PP-jessica      * @Description:这个是CodecOutputList对象的回收器，但这个里面什么也没干，实际上还是垃圾回收来处理CodecOutputList对象      * 具体原因会在下面解释      */     private static final CodecOutputListRecycler NOOP_RECYCLER = new CodecOutputListRecycler() {         @Override         public void recycle(CodecOutputList object) {                      }     };     /**      * @Author: PP-jessica      * @Description:CodecOutputList对象的对象池，这里大家要注意，从对象池中得到的其实是一个容量为16的CodecOutputLists对象      * CodecOutputLists对象为内部类      */     private static final FastThreadLocal<CodecOutputLists> CODEC_OUTPUT_LISTS_POOL =             new FastThreadLocal<CodecOutputLists>() {                 @Override                 protected CodecOutputLists initialValue() throws Exception {                     //这么做其实就意味着，每一次获得out对象，实际上是从这个CodecOutputLists对象中获得一个CodecOutputList对象                     //因为CodecOutputLists容量为16，所以16个CodecOutputList对象都获得完了，没有新的对象可获得了                     //就会创建一个不会缓存的CodecOutputList对象，而这个对象内部只能存放4个消息对象                     //所以逻辑已经很清晰了，解码后的消息对象明确放在CodecOutputList对象内部的数组中，但是中间会经过CodecOutputLists对象                     //从该对象中获得CodecOutputList对象，而CodecOutputLists对象是从对象池中获得的。这个逻辑要理清楚                     return new CodecOutputLists(16);                 }             };     /**      * @Author: PP-jessica      * @Description:回收CodecOutputList对象的接口      */     private interface CodecOutputListRecycler {         void recycle(CodecOutputList codecOutputList);     }     /**      * @Author: PP-jessica      * @Description:内部类CodecOutputLists，该类中有一个CodecOutputList数组，存放了16个CodecOutputList对象      */     private static final class CodecOutputLists implements CodecOutputListRecycler {         //存放CodecOutputList对象的数组，CodecOutputList对象会被拿走用来存储解码后的消息对象         private final CodecOutputList[] elements;         //掩码，用啦计算数组下标的         private final int mask;         //当前的索引         private int currentIdx;         //CodecOutputList对象的个数         private int count;         /**          * @Author: PP-jessica          * @Description:构造方法          */         CodecOutputLists(int numElements) {             //创建数组，这里的数组长度会设置成2的幂次方             elements = new CodecOutputList[MathUtil.safeFindNextPositivePowerOfTwo(numElements)];             //为数组的每个位置赋值             for (int i = 0; i < elements.length; ++i) {                 //这里也可以看到，一个CodecOutputList对象可以存储16个解码后的消息对象                 elements[i] = new CodecOutputList(this, 16);             }             //CodecOutputList个数赋值             count = elements.length;             //当前索引设置为数组长度，这里其实能看出来，从数组中取出CodecOutputList对象，是从后往前取的             //不然就会把当前索引置为0了             currentIdx = elements.length;             //掩码赋值，数组长度减1，想起hashmap中计算下标的方法了吗？都是一样一样的             //可见这种长度设置成2次幂，然后掩码设置为长度减1，是各个变成大佬公认的一种稍微提高性能的方法             mask = elements.length - 1;         }         /**          * @Author: PP-jessica          * @Description:从CodecOutputLists对象中得到一个CodecOutputList对象          */         public CodecOutputList getOrCreate() {             //这里会判断CodecOutputLists的数组中剩余的CodecOutputList个数             if (count == 0) {                 //如果个数为0，就要创建新的不会被缓存的CodecOutputList对象，该对象有垃圾回收处理，所以把一个                 //空实现的回收器传进去了，然后设置容量长度为4。正常情况下，CodecOutputList对象内部的数组长度也为16                 return new CodecOutputList(NOOP_RECYCLER, 4);             }             //CodecOutputList数量减1             --count;             //这里可以看出来是从CodecOutputLists数组中从后向前取走CodecOutputList的             int idx = (currentIdx - 1) & mask;             //注意哦，这里并没有把数组中相应位置的引用置为null             CodecOutputList list = elements[idx];             //当前索引赋值             currentIdx = idx;             //返回CodecOutputList对象             return list;         }         /**          * @Author: PP-jessica          * @Description:该方法会释放CodecOutputList对象到数组中          */         @Override         public void recycle(CodecOutputList codecOutputList) {             //得到当前索引             int idx = currentIdx;             //直接放回去即可             elements[idx] = codecOutputList;             //重置当前索引             currentIdx = (idx + 1) & mask;             ++count;             assert count <= elements.length;         }     }     /**      * @Author: PP-jessica      * @Description:从对象池中获得CodecOutputList对象的方法，从这里开始，就又回到了CodecOutputList类中      * 不再是内部类CodecOutputLists中的方法了      */     static CodecOutputList newInstance() {         return CODEC_OUTPUT_LISTS_POOL.get().getOrCreate();     }     //对象池回收句柄     private final CodecOutputListRecycler recycler;     //存放的消息对象的个数     private int size;     //存放消息对象的数组     private Object[];     //是否有消息对象存放进来过，有消息对象放进来后，该属性就会被置为true了，只有在CodecOutputList被回收的时候才被置为false     private boolean insertSinceRecycled;     private CodecOutputList(CodecOutputListRecycler recycler, int size) {         this.recycler = recycler;         array = new Object[size];     }     @Override     public Object get(int index) {         checkIndex(index);         return array[index];     }     @Override     public int size() {         return size;     }     /**      * @Author: PP-jessica      * @Description:添加消息对象到CodecOutputList对象的数组中      */     @Override     public boolean add(Object element) {         checkNotNull(element, "element");         try {             insert(size, element);         } catch (IndexOutOfBoundsException ignore) {             expandArray();             insert(size, element);         }         //消息对象个数加1         ++ size;         return true;     }     @Override     public Object set(int index, Object element) {         checkNotNull(element, "element");         checkIndex(index);         Object old = array[index];         insert(index, element);         return old;     }     /**      * @Author: PP-jessica      * @Description:添加到指定的位置      */     @Override     public void add(int index, Object element) {         checkNotNull(element, "element");         checkIndex(index);         if (size == array.length) {             //是否需要扩容             expandArray();         }         if (index != size) {             System.arraycopy(array, index, array, index + 1, size - index);         }         insert(index, element);         ++ size;     }     /**      * @Author: PP-jessica      * @Description:删除固定位置的消息对象      */     @Override     public Object remove(int index) {         checkIndex(index);         Object old = array[index];         int len = size - index - 1;         if (len > 0) {             System.arraycopy(array, index + 1, array, index, len);         }         array[-- size] = null;         return old;     }     /**      * @Author: PP-jessica      * @Description:清空消息对象个数，这里只是把size置为0了，并不是真的清空了      */     @Override     public void clear() {         size = 0;     }     boolean insertSinceRecycled() {         return insertSinceRecycled;     }     /**      * @Author: PP-jessica      * @Description:释放CodecOutputList对象的外层方法      */     void recycle() {         for (int i = 0 ; i < size; i ++) {             array[i] = null;         }         size = 0;         insertSinceRecycled = false;         //真正回收的方法         recycler.recycle(this);     } 	//通过索引获得数组中对应的数据的方法     Object getUnsafe(int index) {         return array[index];     }     private void checkIndex(int index) {         if (index >= size) {             throw new IndexOutOfBoundsException();         }     }     /**      * @Author: PP-jessica      * @Description:将消息对象添加到固定位置      */     private void insert(int index, Object element) {         array[index] = element;         insertSinceRecycled = true;     }     /**      * @Author: PP-jessica      * @Description:扩容的方法      */     private void expandArray() {         //左移一位，扩容2倍         int newCapacity = array.length << 1;         if (newCapacity < 0) {             throw new OutOfMemoryError();         }         Object[] newArray = new Object[newCapacity];         System.arraycopy(array, 0, newArray, 0, array.length);         array = newArray;     } }`

通过上面的代码块，我们可以知道 CodecOutputList 类内部其实定义了一个 Object 数组，而解码完毕的消息对象就可以存放到 CodecOutputList 内部的数组中，然后发送给 ChannelPipeline 链表后面的处理器。当然，这个 CodecOutputList 中还有一个 CodecOutputLists 内部类，以及一个 CodecOutputLists 内部类的对象池。为什么定义这个内部类和对象池的具体原因我都写在注释中了，所以就不再详细解释了。简单来说就是每个 Channel 接收到的消息都需要解码，也就意味着都需要一个 CodecOutputList 对象，既然是这样，CodecOutputList 对象显然就会频繁创建，因此就定义了一个 CodecOutputLists 的对象池，这样一来每一个单线程执行器都可以获得一个私有的 CodecOutputLists 对象。而 CodecOutputLists 对象中定义了一个 CodecOutputList 数组，数组中存放了 16 个 CodecOutputList 对象，这就使得每个单线程执行器获得了 16 个可以使用的 CodecOutputList 对象。了解了这些知识，接下来，就可以看看用户自定义的解码器的抽象父类，也就是 ByteToMessageDecoder 类。请看下面代码块(文章中展示的 ByteToMessageDecoder 类省略了部分代码)。

java

复制代码

`/**  * @Author: PP-jessica  * @Description:Netty解码器的核心类，把ByteBuf解码成用户自己设定的对象，这里要为大家强调一点的是，解码器是有状态的，这就意味着它  * 不可能被channel共享，每一个channel都要有自己的解码器handler  */ public abstract class ByteToMessageDecoder extends ChannelInboundHandlerAdapter {     /**      * @Author: PP-jessica      * @Description:这个就是解码器中的累加器，当接收到的数据还不足以解码成一个完整的消息时，接收到的数据会      * 暂时存储在这个属性中      */     public static final Cumulator MERGE_CUMULATOR = new Cumulator() {         //这里要多说一句，第一次解码消息的时候，并不会调用这个方法，因为还不知道能不能解码成一个完整的消息         //之后再次解码，才会调用该方法，如果之前接收到的字节不能解码成完整的消息，就会存储在这个cumulation对象中         //这个对象就是可累加的缓冲区         @Override         public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {             try {                 final ByteBuf buffer;                 //这里就意味着cumulation的容量不够了，需要扩容，其实writerIndex和readableBytes都是用到了写指针                 //其实下面这个不等式可以变成cumulation.writerIndex()+in.readableBytes()>cumulation.maxCapacity()                 //两部分要存储起来的字节已经超过了cumulation的最大容量，当然就要扩容了                 if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes()                         || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {                     //在这里扩容，返回一个新的byteBuf                     buffer = expandCumulation(alloc, cumulation, in.readableBytes());                 } else {                     //如果走这个分支，就使用原来的ByteBuf                     buffer = cumulation;                 }                 //把接收到的字节从缓冲区写入到累加器中                 buffer.writeBytes(in);                 return buffer;             } finally {                 //释放用来接收消息的ByteBuf                 in.release();             }         }     };          //这个属性就是可累加的缓冲区     ByteBuf cumulation;          //向累加缓冲区写入数据的累加器     private Cumulator cumulator = MERGE_CUMULATOR;          //是否只解码一次     private boolean singleDecode;          //是否第一次使用累加缓冲区     private boolean first;          //这个属性下面会用到，就是当接收到的消息非常多，解码很多次也没有解码完整     //就不会再继续让这些消息占用内存了，就会把它们丢弃掉，下面这个值就是用来确定     //从什么时候开始丢弃的     private int discardAfterReads = 16;          //这个是解码器处理消息的次数，就是读取了多少次消息的意思，会和上面的16做     //判断，如果超过16次，消息还没解码完整，就可以丢弃字节了     private int numReads;      /**      * @Author: PP-jessica      * @Description:这个就是解码器中最核心的方法，接收消息会触发入站事件，同时触发channelRead方法      * 的回调，所以解码操作也会在channelRead方法中进行      */     @Override     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {         //这里就可以大胆地判断类型了，因为接收消息时都会把字节存放在ByteBuf中         //所以这里要判断是不是ByteBuf类型的         if (msg instanceof ByteBuf) {             //这里得到的CodecOutputList类型很有意思，它存放的其实就是暂时解码了的消息             //使用其内部的数组来存放消息对象             CodecOutputList out = CodecOutputList.newInstance();             try {                 //转换类型，这里之所以可以直接转换类型，是因为所有被接收到的消息都会被包装在一个ByteBuf对象中                 ByteBuf data = (ByteBuf) msg;                 //如果是第一次接收到消息并解码，这时候累加缓冲区肯定还没用到，得等到第一次解码完了才能知道                 //消息是否完整。注意，这里cumulation == null中间是==，是一个判断，这行代码                 //会返回true或者false给first赋值。如果是消息第一次解码，累加缓冲区中肯定还没有数据呢                 //所以肯定是null，所以返回true，first也就是true                 first = cumulation == null;                 if (first) {                     //直接赋值即可，都是ByteBuf类型的对象                     cumulation = data;                 } else {                     //走到这里就意味着不是第一次解码，所以要把接收到的字节通过累加器写入到累加缓冲区中                     cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);                 }                 //在这里进行解码，解码完毕后，会把累加缓冲区中的字节存放到out对象的数组中，然后传递给后面的handler                 callDecode(ctx, cumulation, out);             } catch (DecoderException e) {                 throw e;             } catch (Exception e) {                 throw new DecoderException(e);             } finally {                 //这里会有判断，就是判断累加缓冲区不为null，说明已经不是第一次解码消息了                 //并且累加缓冲区中没有可读的字节数，这种情况就说明累加缓冲区已经处理过消息，并且消息已经存放到out对象或者是                 //直接传递给后面的处理器中了，这就意味着这一次解码消息已经完整了，可以放心地释放各种ByteBuf对象了                 if (cumulation != null && !cumulation.isReadable()) {                     //处理消息的次数清0                     numReads = 0;                     //释放缓冲区                     cumulation.release();                     //帮助垃圾回收                     cumulation = null;                     //走到这里就意味着处理消息的次数已经超过16次了，比如解码一条消息，每一次接收到的字节都不能将消息拼凑完整                     //处理了16次了，这时候就要直接丢弃读到的数据了，考虑到会占用很多内存                     //这其实也会提醒我们，一次发送太多消息，可能Netty就不会在接受的过程中丢弃一部分                 } else if (++ numReads >= discardAfterReads) {                    //清0次数                     numReads = 0;                     //丢弃处理过的字节数                     discardSomeReadBytes();                 }//得到out对象中一共存放了多少解码完毕的消息                 int size = out.size();                 //解码完成了，就把所有解码完毕的消息从out对象中向后面的handler传递                 fireChannelRead(ctx, out, size);                 //释放out对象，out对象也是有对象池的                 out.recycle();             }         } else {             //类型不匹配，就传给下一个handler             ctx.fireChannelRead(msg);         }     }     //把结完成功的数据发送给链表后面的处理器     static void fireChannelRead(ChannelHandlerContext ctx, CodecOutputList msgs, int numElements) {         //循环发送         for (int i = 0; i < numElements; i ++) {             //根据索引从CodecOutputList内部的数组中获得对应数据             ctx.fireChannelRead(msgs.getUnsafe(i));         }     }     /**      * @Author: PP-jessica      * @Description:解码消息的方法      */     protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {         try {             //在一个循环中处理接收到的字节消息             while (in.isReadable()) {                 //得到out对象内存储消息对象的个数                 int outSize = out.size();                 //如果大于0，意味着之前解码到了完整的消息，可以继续向后面的handler传递了                 //这里还是要结合具体的编解码器来理解的                 if (outSize > 0) {                     //向后传递消息                     fireChannelRead(ctx, out, outSize);                     //把out对象内存储的消息对象清空                     out.clear();                     //判断该解码器handler是否被删除                     if (ctx.isRemoved()) {                         break;                     }                     outSize = 0;                 }                 //走到这里说明outSize中还未存储消息对象                 //这可能就意味着解码后的消息一直不完整，没办法从累加缓冲区中存放到out对象中                 //这里也要结合具体的解码器来理解。我刚才为大家提供的那个ByteToStringDecoder解码器中就体现了这种情况                 //结合具体的例子，大家就明白这里是什么意思了                 //这里是得到可以读到的所有字节数                 int oldInputLength = in.readableBytes();                 //在下面的方法中真正解码                 decodeRemovalReentryProtection(ctx, in, out);                 //判断这个handler是否删除了                 if (ctx.isRemoved()) {                     break;                 }                 //走到这里说明已经经过解码了，但是大家要注意，虽然解码了，但是out对象中未必有数据，因为                 //解码后的消息不完整，是不会把消息对象存入到out对象中的                 //所以很有可能已经解码消息了，但是out对象中的消息对象还是0，上面代码的逻辑必然会让out对象赋值为0                 //但还有一种情况，也可能根本就没有消息了，消息已经解码完整了并且发送给下一个handler了，                 //下一轮循环时没有消息可解码了                 if (outSize == out.size()) {                     //所以这里要判断一下，累加缓冲区中的可读字节数是否有变化                     if (oldInputLength == in.readableBytes()) {                         //如果没变化，可能根本就没消息，也可能是消息不完整，消息本来被读取了一些                         //但是读取标志又重置了，参考ByteToStringDecoder类中的代码逻辑                         //所以可读字节没变化，并且意味着消息不完整                         //总之可以直接退出循环了，在上一层方法中等待累加器向累加缓冲区中写入更多字节                         break;                     } else {                         //有变化则继续循环即可                         continue;                     }                 }                 //走到这里说明out对象中的size不为0，就意味着肯定解码成功了                 //但是累加缓冲区中的可读字节书没变化，肯定就出问题了，抛出异常即可                 if (oldInputLength == in.readableBytes()) {                     throw new DecoderException(                             StringUtil.simpleClassName(getClass()) +                                     ".decode() did not read anything but decoded a message.");                 }                 //如果只解码一次，则循环一次直接退出即可                 if (isSingleDecode()) {                     break;                 }             }         } catch (DecoderException e) {             throw e;         } catch (Exception cause) {             throw new DecoderException(cause);         }     }     /**      * @Author: PP-jessica      * @Description:解码的抽象方法，交给具体的子类来实现      */     protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception;     final void decodeRemovalReentryProtection(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)             throws Exception {         //真正开始解码，这里省略了部分代码，只保留核心代码         //该方法就是用户自己定义的解码器实现的，就是ByteToStringDecoder类中实现的方法         decode(ctx, in, out);     } }`

到此为止，我也为大家实现了一个完整的解码器。本章的内容也就结束了，我们下一章再见。

**总结**

这一章内容其实不必写这么长的，因为内容本来就不多，就是编解码器的简单实现。主要是文章中展示的代码多了一些，这不是我的本意，我想删掉一些，但是即便删掉一些内容还是很多，如果省略的代码多了，可能逻辑就不连贯了，所以就越写越多了。如果大家从文字上已经掌握了文章中讲解的知识，可以直接去看源码了。