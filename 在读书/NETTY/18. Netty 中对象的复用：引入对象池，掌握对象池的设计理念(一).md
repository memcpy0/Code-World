大家好，在这一章终于要开始学习这本小册的难点之一了。在整个 Netty 的知识体系中，对象池可以说是难点之一，紧随其后的内存池可以说是最难理解的知识。如果这两部分的知识都掌握了，其实这本小册的重点也就学完了。我不知道大家对这些知识究竟掌握到什么程度了，但我希望看了我的文章之后。我的文章能为大家提供一些帮助，这些帮助可能很直接，也可能只是一些启发性的帮助。无论如何，我希望大家能从我的文章中明白，为什么有些代码要这样设计，而不是只记住了代码的运行逻辑。本章也会和以前一样，从分析理论过渡到代码实战。当然，在学习本章之前，大家最好先把上一章的 FastThreadLocal 体系掌握了，因为后面的两大池化技术都要用到 FastThreadLocal 体系的知识。

# 池化技术的重要性

池化技术对大家来说，一定不是一个陌生的概念了。在我们的日常开发或者学习中，肯定都多多少少接触过池化技术，也知道池化技术出现的原因。线程池应该是我们接触到的最早的池化技术了，线程的创建和销毁十分消耗资源，所以要把线程创建出来，用完了并不销毁，而是循环复用，直到任务队列中没有任务了才让线程停止工作。用比较专业的话来总结一下，**就是对象的创建成本很高，而且要被经常用到，频繁地创建然后销毁，显然不如循环复用效率高。** 接着大家接触到的可能就是数据库的连接池，也是创建成本过高，所以在最开始就创建多个数据库连接，然后循环使用。当然，在接触这两个池化技术之前，大家肯定还学习过一个池化技术运用的知识点，只是这个知识太过简单，以至于常常被人忘记。那就是 Integer 中用到的池化技术。请看下面的代码块。

Java

复制代码

`priate static class IntegerCache {     static final int low = -128;     static final int high;     static final Integer cache[];     static {         // high value may be configured by property         int h = 127;         String integerCacheHighPropValue =             sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");         if (integerCacheHighPropValue != null) {             try {                 int i = parseInt(integerCacheHighPropValue);                 i = Math.max(i, 127);                 // Maximum array size is Integer.MAX_VALUE                 h = Math.min(i, Integer.MAX_VALUE - (-low) -1);             } catch( NumberFormatException nfe) {                 // If the property cannot be parsed into an int, ignore it.             }         }         high = h;         cache = new Integer[(high - low) + 1];         int j = low;         for(int k = 0; k < cache.length; k++)             //在这里把每一个Integer对象创建出来并缓存             cache[k] = new Integer(j++);         // range [-128, 127] must be interned (JLS7 5.1.7)         assert IntegerCache.high >= 127;     }     private IntegerCache() {} }`

在上面的代码块中，我截取了 Integer 类的部分代码展示给大家，可以看到，在 IntegerCache 方法中，就创建了一个 Integer 对象的对象池，该对象池中缓存了 -128 到 127 的 Integer 对象。而这个对象池创建的原因也很简单，因为 JDK 的作者认为在 -128 到 127 这个区间的整数会被用户经常使用，所以就创建了这个对象池。这样一来，频繁地使用这个区间的对象时，就不用再创建了，而是直接从对象池中获取即可。总而言之，通过上面的一些小例子，大家应该能意识到，对象池的存在，就是为了提高程序的执行效率。对象池的好处是显而易见了，那么，假如在程序中引入了对象池，会不会引发什么问题呢？请大家一起跟我看下面一个小例子。

Java

复制代码

`public class TestObjectPool {     //在这里创建一个书的对象池，就用集合来当作对象池容器吧     private static List<Book> list = new ArrayList<>();     public static void main(String[] args) {         //向对象池中添加三本书         for (int i = 1; i < 4; i++) {             list.add(new Book("第"+i+"本书！"));         }         //创建三个线程         for (int i = 0; i < 3; i++) {             int finalI = i;             new Thread(new Runnable() {                 @Override                 public void run() {                     //为了模拟并发的情况，就让每个线程都拿走集合中的首位元素                     Book book = list.remove(0);                     System.out.println("线程"+ finalI +"拿到了"+book.index);                 }             }).start();         }     }     static class Book{         //表示是第几本书，当然，对象池中的对象应该是一样的，但这里我们添加一个多余的属性         //是为了将对象池中的问题很好地暴露出来         private String index;         //表示书翻到第几页了，刚从对象池中拿出来时，默认是在第0页         private int pageNow = 0;         //默认书的最后一页为第500页         private int pageEnd = 500;         public Book() {         }         public Book(String index) {             this.index = index;         }         //翻页的方法         public void pageTurn() {             while (pageNow <= pageEnd) {                 pageNow++;                 System.out.println("这本书翻到第"+pageNow+"页了！");             }             System.out.println("这本书已经翻到最后一页了！");         }         //把书页重置到第0页         public void resetPage() {             pageNow = 0;         }         public String getIndex() {             return index;         }         public void setIndex(String index) {             this.index = index;         }         public int getPageNow() {         return pageNow;     }     } }`

启动测试类，得到如下结果。

Java

复制代码

`/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/bin/java -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=52809:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/charsets.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/cldrdata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/dnsns.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/jaccess.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/localedata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/nashorn.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunec.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/zipfs.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jce.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jfr.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jsse.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/management-agent.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/resources.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/rt.jar:/Users/chenqingyang/code/gitcode/my-netty/netty-13/target/classes:/Users/chenqingyang/Repository/org/slf4j/slf4j-api/1.7.30/slf4j-api-1.7.30.jar:/Users/chenqingyang/Repository/org/slf4j/slf4j-simple/1.7.28/slf4j-simple-1.7.28.jar:/Users/chenqingyang/Repository/org/jctools/jctools-core/3.0.0/jctools-core-3.0.0.jar com.pp.netty.test.TestObjectPool 线程1拿到了第1本书！ 线程2拿到了第3本书！ 线程0拿到了第1本书！ Process finished with exit code 0`

显然程序很快就出现了并发问题。因为我在上面的程序中，让创建的三个线程都去获取集合首位的数据，之所以这么做，是因为我既然用集合来模拟对象池，而集合中存储数据的容器是数组。当一个线程从对象池中获取对象后，肯定是要把这个对象拿走，所以我这里使用了 remove 方法。当集合中首位的数据被拿走后，根据数组的特性，后面的数据要移动位置，所以，数组的首位永远是有数据的，因此，我就让每个线程获得集合中数组首位的数据。这就是一个最简单的对象池的模拟实现。当然，在多线程情况下，可以看到在从对象池中获得对象的时候，出现了很明显的并发问题。两个线程拿到了相同的对象，这肯定是不能接受的。而且，上面列举的只是诸多并发问题中的一种。可以看到，我在上面的程序中只是让线程从对象池中把书拿走了，并没有归还给对象池。如果线程使用完书籍之后，要把书归还给对象池，并且都是在同一时刻归还，这种情况下仍然会产生并发问题，对吧？因为 ArrayList 本身就不是一个并发安全的集合。

除此之外，还可能会出现一种情况，请大家仔细想想，在上面的程序中，每个线程都从对象池中获取了一个对象，我们就假设在获取对象的时候没有出现并发问题，每个线程获取的都是唯一的对象，但是在使用的过程中，也就是每个线程都调用对象的 pageTurn 方法，不停地翻动书页。如果有的线程把书页翻动到第 500 页，并且没有重置书页，就把书放回到对象池中了。那下一个线程获取到了这个对象，这时候，对象的初始状态显然是不对的。因此，也就牵扯出第二个可能存在的问题，那就是在并发情况下，对象池中对象的状态可能出现错乱的问题。所以，这就要求我们在使用对象池的时候，既要考虑获得和归还对象时的并发问题，也要考虑到对象状态重置的问题。我想，这两点大家应该认识清楚了。接下来，我就可以根据以上分析来改造我的对象池。

首先要解决的就是对象池容器的并发问题，ArrayList 是一个并发不安全的容器，肯定就不能再使用它了。而且，在解决并发问题的同时，还要考虑对象回收时状态重置的问题，显然是要定义一些方法的。既然是这样，我不如就专门为对象池定义一个类型，然后把和对象池相关的功能都在这个类中实现了。

# 设计一个简单的对象池

这个对象池的类型暂且就叫做 ObjectPool 吧。请看下面的代码。

Java

复制代码

`public class ObjectPool {     //先定义一个存放对象的数组容器     private final Book[] elements;     //数组的初始化容量，默认为256     private  int INITIAL_CAPACITY = 256;     //数组存储元素的个数     private int size;     //无参构造器     public ObjectPool() {         //在这里把数组创建好         elements = new Book[INITIAL_CAPACITY];     }     //从对象池中获取对象     public Book getBook() {         //第一次测试的时候，先把同步锁注释掉         //synchronized (elements) {             if (size == 0) {                 //走到这里说明对象池中还没有对象，所以就创建一个Book对象，直接返回                 return new Book("对象池中没对象了之后创建的书");             }             //走到这里说明对象池中已经有对象了，可以直接返回对象了             //这一次从数组的尾部取走元素，从尾部获取元素可以避免数组中的数据的频繁移动             Book book = elements[--size];             //把对象池中的数组置为空             elements[size] = null;             return book;         //}     }     //将对象归还给对象池     public void backBook(Book book) {         //synchronized (elements) {             //先重置book书页的状态             book.resetPage();             //把对象归还到对象池中             elements[size++] = book;         //}     }     public void iterate() {         for (int i = 0; i < size; i++) {             System.out.println(elements[i].index+"初始页数为"+elements[i].getPageNow());         }         System.out.println("对象池中共有"+size+"书籍！");     } }`

下面启动对应的测试类。

Java

复制代码

`public class TestObjectPool {     public static void main(String[] args) throws InterruptedException {         //创建一个Book对象的对象池         ObjectPool bookPool = new ObjectPool();         //先往对象池中放3本书         for (int i = 0; i < 3; i++) {             Book booK = new Book("第"+i+"本书");             bookPool.backBook(booK);         }         //创建5个线程，每个线程都去对象池中获取书籍         for (int i = 0; i < 5; i++) {             new Thread(new Runnable() {                 @Override                 public void run() {                     //从对象池中获得书                     Book book = bookPool.getBook();                     System.out.println(Thread.currentThread().getName()+"获得了"+book.getIndex());                 }             }).start();         }     } }`

上面的测试类启动之后，结果如下。可以看到，当我把同步锁注释掉之后，程序果然出现了并发问题，如果没有并发问题，创建了 5 个线程，完美的结果应该是 3 个线程获得了不同的书籍，另外两个线程获得的是对象池中没有对象之后创建的书籍，但下面的结果却是 4 线程获得了书籍，其中两个线程获得的书籍一样，只有一个线程获得的是创建的书籍。并发问题已经很明显了。

Java

复制代码

`/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/bin/java -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=56719:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/charsets.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/cldrdata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/dnsns.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/jaccess.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/localedata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/nashorn.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunec.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/zipfs.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jce.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jfr.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jsse.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/management-agent.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/resources.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/rt.jar:/Users/chenqingyang/code/gitcode/my-netty/netty-13/target/classes:/Users/chenqingyang/Repository/org/slf4j/slf4j-api/1.7.30/slf4j-api-1.7.30.jar:/Users/chenqingyang/Repository/org/slf4j/slf4j-simple/1.7.28/slf4j-simple-1.7.28.jar:/Users/chenqingyang/Repository/org/jctools/jctools-core/3.0.0/jctools-core-3.0.0.jar com.pp.netty.test.TestObjectPool Thread-0获得了第2本书 Thread-2获得了第1本书 Thread-3获得了第1本书 Thread-1获得了第0本书 Thread-4获得了对象池中没对象了之后创建的书 Process finished with exit code 0`

紧接着，我把 ObjectPool 类的 getBook 方法中同步锁加上，并且一开始就向对象池中放了 20 本书，创建了 20 个线程同时去对象池中获取对象，然后再次启动测试类，结果如下。

Java

复制代码

`/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/bin/java -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=57184:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/charsets.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/cldrdata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/dnsns.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/jaccess.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/localedata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/nashorn.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunec.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/zipfs.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jce.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jfr.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jsse.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/management-agent.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/resources.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/rt.jar:/Users/chenqingyang/code/gitcode/my-netty/netty-13/target/classes:/Users/chenqingyang/Repository/org/slf4j/slf4j-api/1.7.30/slf4j-api-1.7.30.jar:/Users/chenqingyang/Repository/org/slf4j/slf4j-simple/1.7.28/slf4j-simple-1.7.28.jar:/Users/chenqingyang/Repository/org/jctools/jctools-core/3.0.0/jctools-core-3.0.0.jar com.pp.netty.test.TestObjectPool Thread-0获得了第19本书 Thread-2获得了第17本书 Thread-4获得了第15本书 Thread-1获得了第18本书 Thread-3获得了第16本书 Thread-5获得了第14本书 Thread-6获得了第13本书 Thread-7获得了第12本书 Thread-8获得了第11本书 Thread-9获得了第10本书 Thread-10获得了第9本书 Thread-11获得了第8本书 Thread-12获得了第7本书 Thread-13获得了第6本书 Thread-14获得了第5本书 Thread-15获得了第4本书 Thread-16获得了第3本书 Thread-17获得了第2本书 Thread-18获得了第1本书 Thread-19获得了第0本书 Process finished with exit code 0`

可见同步锁放开了之后，并发获取对象的问题似乎已经消失了。这个问题结束了之后，接下来，就该再次验证一下并发向对象池中存放对象的情况了，看这种情况下是否存在并发问题。同样的，我们仍然先把 ObjectPool 类的 backBook 方法中的同步锁注释掉，然后启动下面的测试类。

Java

复制代码

`public class TestObjectPool {     public static void main(String[] args) throws InterruptedException {         //创建一个Book对象的对象池         ObjectPool bookPool = new ObjectPool();         //创建20个线程，每个线程都去往对象池中存放书籍         for (int i = 0; i < 20; i++) {             int finalI = i;             new Thread(new Runnable() {                 @Override                 public void run() {                     //在这里把书放到对象池                     bookPool.backBook(new Book("第"+ finalI +"本书"));                 }             }).start();         }         //下面用主线程检查对象池中有没有出现并发问题         //这里要让主线程睡一会，因为上面的20个线程可能还在操作对象池的数组，这时候遍历数组，就会出现并发问题         Thread.sleep(1000);         bookPool.iterate();     } }`

接下来就是测试的结果，可以看到，有两本书直接消失了，明明往对象池中存放了 20 本书籍，现在却变成了 18 本。

Java

复制代码

`/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/bin/java -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=57313:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/charsets.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/cldrdata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/dnsns.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/jaccess.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/localedata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/nashorn.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunec.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/zipfs.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jce.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jfr.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jsse.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/management-agent.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/resources.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/rt.jar:/Users/chenqingyang/code/gitcode/my-netty/netty-13/target/classes:/Users/chenqingyang/Repository/org/slf4j/slf4j-api/1.7.30/slf4j-api-1.7.30.jar:/Users/chenqingyang/Repository/org/slf4j/slf4j-simple/1.7.28/slf4j-simple-1.7.28.jar:/Users/chenqingyang/Repository/org/jctools/jctools-core/3.0.0/jctools-core-3.0.0.jar com.pp.netty.test.TestObjectPool 第0本书初始页数为0 第2本书初始页数为0 第3本书初始页数为0 第4本书初始页数为0 第5本书初始页数为0 第6本书初始页数为0 第7本书初始页数为0 第8本书初始页数为0 第9本书初始页数为0 第10本书初始页数为0 第12本书初始页数为0 第13本书初始页数为0 第14本书初始页数为0 第15本书初始页数为0 第16本书初始页数为0 第17本书初始页数为0 第18本书初始页数为0 第19本书初始页数为0 对象池中共有18书籍！ Process finished with exit code 0`

然后我把 backBook 方法中的同步锁加上，请大家再看最后的测试结果。

Java

复制代码

`/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/bin/java -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=57279:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/charsets.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/cldrdata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/dnsns.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/jaccess.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/localedata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/nashorn.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunec.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/zipfs.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jce.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jfr.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jsse.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/management-agent.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/resources.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/rt.jar:/Users/chenqingyang/code/gitcode/my-netty/netty-13/target/classes:/Users/chenqingyang/Repository/org/slf4j/slf4j-api/1.7.30/slf4j-api-1.7.30.jar:/Users/chenqingyang/Repository/org/slf4j/slf4j-simple/1.7.28/slf4j-simple-1.7.28.jar:/Users/chenqingyang/Repository/org/jctools/jctools-core/3.0.0/jctools-core-3.0.0.jar com.pp.netty.test.TestObjectPool 第0本书初始页数为0 第1本书初始页数为0 第2本书初始页数为0 第3本书初始页数为0 第4本书初始页数为0 第5本书初始页数为0 第6本书初始页数为0 第7本书初始页数为0 第8本书初始页数为0 第9本书初始页数为0 第10本书初始页数为0 第11本书初始页数为0 第12本书初始页数为0 第13本书初始页数为0 第14本书初始页数为0 第15本书初始页数为0 第16本书初始页数为0 第17本书初始页数为0 第18本书初始页数为0 第19本书初始页数为0 对象池中共有20书籍！ Process finished with exit code 0`

从上面的结果可以看出来，我自己定义的对象池，到目前来说，终于算是重构成功了，用同步锁完美解决了可能会出现的任何并发问题，简单直接，简直是 perfect 了！当然，大家肯定知道我是在开玩笑，如果把程序重构成这样，还能舔着脸说一句 perfect，那我不就成大司马了吗！这是我绝对不能接受的，所以，我的程序肯定还要再经过一系列重构，才能真正的交给用户使用。既然还要接着重构，那就请大家来跟我一起分析分析，目前的程序存在哪些缺陷吧。

首先有一个问题特别明显，我的对象池只能交给 Book 类型的对象使用，这一点是最失败，如果你在程序中创建的一个组件只能交给特定的对象使用，那你创建的这个组件基本上就可以说是一个失败品了。程序中会有各种各样的对象，难道要为每一个对象都创建一个 ObjectPool？显然是不可能的。最简单通用的方法就是为对象池引入泛型，然后就可以作为所有对象的对象池了。这个问题看起来已经解决了，也并没有什么困难，对吧？但下一个问题就值得我们思考思考了。

请大家认真想一想，对象池这种功能真的可以交给用户使用吗？就比如说刚才的那个 Book 类型，要为这个类型创建一个对象池，如果用户想这么做，并且对象池也引入泛型了，那用户就要自己为 Book 类型创建一个对象池，就像下面这样。

Java

复制代码

`ObjectPool<Book> bookPool = new ObjectPool();`

如果要从对象池中获取对象，就调用对象池的 getObject 方法，归还对象就调用 backObject 方法。先不说这样麻烦不麻烦，我们先来探讨，在一个程序中，难道任何对象都可以由用户来决定是否创建对象池吗？**对象池说白了就是一种缓存的手段，对象创建了之后缓存起来，并不销毁，以此来循环复用。但既然是缓存，就要存放到容器中，不管是什么容器吧，肯定是要占据** **内存** **的。** 如果一个用户心血来潮，觉得可以使用对象池了，就无节制地为自己可能用到的所有对象都创建对象池，如果用户缓存的对象特别多，占用的内存就会特别多，说不定就会搞出内存溢出这种问题了，就算内存不溢出，内存使用率比较高的时候，垃圾回收会很频繁，这对程序的执行效率来说是一种严重的拖累。所以，在我这样的程序员看来，对象池是一种比较高阶的技术，根本就不能对普通用户开放。说的直接一点，普通用户懂什么呀，根本就不知道什么对象可以使用对象池，什么对象不能使用对象池。而作为程序的开发者，我们这些程序员当然知道在程序的运行过程中，会创建什么对象，肯定也会很清楚哪些对象适合使用池化技术。因此，程序最好的重构方式，就是事先在程序内部定义好一些可以池化的对象，并且事先实现好这些对象的对象池，并且把从对象池中获得对象，归还对象给对象池的方法封装到该对象中。而对象池本身并不对用户直接暴露。当然，高手还是可以获得程序中的对象池的，但是普通的用户，就直接使用我们事先为他们创建好的并且已经池化了的对象即可。说了这么多，那究竟该怎么重构我们的程序呢？

# 重构对象池

首先，还是按照老规矩，既然要将程序重构得正式一些，那么对象池的类名自然也要正式一点，像 ObjectPool 这种名字，会降低程序员的格调。直接来一个一般人看不懂的类名，就叫做 Recycler。厉害一点的程序员可能直接就从类名上猜到这个类的作用了，而普通一点的程序员可能得翻译一下，才知道这个英语词汇翻译过来是回收站的意思。那名字确定好以后呢？肯定是定义存储数据的容器，对吧？之前我使用的是数组来存放被缓存的对象，现在要重构对象池了，缓存对象的容器需要改变吗？我的决定是不需要更换容器，首先不用考虑 Map，因为对象根本不是以键值对的形式缓存的。那么，要变更成链表呢？对象确实是要经常从容器中取出然后放回，这意味着容器肯定要经常进行一些增删的操作，而根据以往编程的经验，好像是有这么一句话：如果对数据经常进行增删的操作，选择链表当作存放数据的容器要比数组在性能上更加优秀。因为数组每删除一次数据都会涉及到数据的移动。但是，在展示了上面那个例子之后，大家肯定都会觉得这种看似有道理的话其实并不一定正确。如果每次从数组末尾删除数据，根本就不会涉及数据的移动，并且查找数据的效率比链表高出很多。因此，在我将要重构的对象池中，我仍然使用数组来存放被缓存的对象，每次从对象池中获取对象，也是获取数组的最后一位，而归还对象的时候，也是放在数组的最后一位。下面，就请看我重构好的代码。

Java

复制代码

`public abstract class Recycler<T> {      //先定义一个存放对象的数组容器     private final Object[] elements;     //数组的初始化容量，默认为256     private  int INITIAL_CAPACITY = 256;     //数组存储元素的个数     private int size;     //无参构造器     public Recycler() {         //在这里把数组创建好         elements = new Object[INITIAL_CAPACITY];     }     //从对象池中获取对象     public T pop() {         synchronized (elements) {             if (size == 0) {                 //走到这里说明对象池中还没有对象，所以就创建一个对象，直接返回                 return newObject();             }             //走到这里说明对象池中已经有对象了，可以直接返回对象了             //这一次从数组的尾部取走元素，从尾部获取元素可以避免数组中的数据的频繁移动             T object = (T)elements[--size];             //把对象池中的数组置为空             elements[size] = null;             return object;         }     }     //抽象方法     protected abstract T newObject();     //将对象归还给对象池     public void push(T object) {         synchronized (elements) {             //把对象归还到对象池中             elements[size++] = object;         }     } }`

现在，我们就假设在程序执行过程中，要频繁地使用 Book 对象，所以，为了提高程序执行的效率，并且不让用户来操作对象池。我就事先在程序内部为 Book 对象创建一个对象池。请看下面的代码块。

Java

复制代码

`public class Book{     //在这里创建Book自己的对象池,从静态属性可以看出来，该对象池只创建一次，只创建一个     private static final Recycler<Book> RECYCLER = new Recycler<Book>() {         @Override         protected Book newObject() {             return new Book("对象池中还没有对象创建的书籍");         }     };     //该方法就是从book的对象池中获得book对象的方法     static Book newInstance() {         //从对象池中获取对象         return = RECYCLER.pop();     }     //回收对象的方法     public void recycle() {         RECYCLER.push(this);     }          //表示是第几本书，当然，对象池中的对象应该是一样的，但这里我们添加一个多余的属性     //是为了将对象池中的问题很好地暴露出来     public String index;     //表示书翻到第几页了，刚从对象池中拿出来时，默认是在第0页     private int pageNow = 0;     //默认书的最后一页为第500页     private int pageEnd = 500;     public Book() {     }     public Book(String index) {         this.index = index;     }     //翻页的方法     public void pageTurn() {         while (pageNow <= pageEnd) {             pageNow++;             System.out.println("这本书翻到第"+pageNow+"页了！");         }         System.out.println("这本书已经翻到最后一页了！");     }     //把书页重置到第0页     public void resetPage() {         pageNow = 0;     }     public String getIndex() {         return index;     }     public void setIndex(String index) {         this.index = index;     }     public int getPageNow() {         return pageNow;     } }`

请看上面的代码块，我在 Book 类中创建了一个静态的成员变量 RECYCLER，RECYCLER 是一个抽象类，所以创建其对象时就要实现它的抽象方法 newObject，而该方法的实现逻辑恰好就是创建一个 Book 对象。这样一来，当程序执行下面的代码块时，就会从 Book 的对象池中自动获取 Book 对象。请看下面的代码块。

Java

复制代码

`//直接使用静态方法从对象池中获取对象，如果在获取的过成功发现对象池还没有缓存对象 //就会调用Recycler的newObject方法创建一个book对象返回给用户 Book book = Book.newInstance(); //使用完对象后，就把对象直接返回给对象池 book.recycle();`

到目前为止，程序就已经重构得比较完美了，并发问题通过同步锁解决了，也引入了泛型，只要我们愿意，每个对象都可以创建自己的对象池了。现在想想，好像程序已经没有什么问题了。但没问题也许就是最大的问题，正如人总是在最得意的时候犯下致命错误。让我再来提醒大家一下，**当一个程序能够完美地运行起来，不出现任何错误的时候，就应该考虑性能了。总之，安全和性能，是我们设计程序的两个基本要求。安全就是保证程序不能出错，性能就要求程序执行得越快越好，或者说响应得越快越好。** 可是看看现在的对象池，安全倒是安全了，性能呢？如果在超级并发的情况，就比如说在 Netty 中，要不停地收发消息，这就意味着要不断地使用 ByteBuf 来包装字节消息，这种情况下就会大量使用 ByteBuf 对象，所以，在 Netty 中，就为 ByteBuf 创建了对象池。本来创建对象池是为了提高性能的，但刚才我强调了，在超级并发的情况下，这样每个线程都来对象池中获取 ByteBuf 对象，都要经过同步锁，这么一来，不就又和串行没有区别了吗？就像引入对象池一样，我们引入多线程并发执行任务本来是要提高程序性能的呀，对吧？这时候，一般的程序员可能就会想，如果没有多线程就好了。但这显然是不可能的，正是多核 CPU 才有了今天计算机工作性能的提升，也正是多线程才让如今的程序运行飞快。当然，多线程也会带来很多问题，如果大家简单回顾一下前面那些章节讲过的内容，就会发现我在好多章节中不断地重构程序，就是为了解决并发问题，既把问题解决了，还要让性能得到保障。 不过让我们再来想想，取消多线程是不可能的，但有没有一种方法，既能使用多线程，而每个线程和每个线程操纵的变量又互不干涉呢？简而言之，就是这些线程根本不需要同时去争抢同一个对象就好了，没有这种竞争的状态，也就不必用到同步锁，对吧？那该怎么实现呢？

请大家想一想，不管在什么程序中，只要是在 Java 中，执行任务，或者说执行方法的一定是线程，每一个线程都会去公共的对象池中获得对象，竞争状态下，就不得不使用同步锁来避免并发问题的出现。既然是线程去对象池中获得对象，那么就给线程创建一个私有的对象池不就好了？换句话说，**就是给每个线程都创建一个私有的对象池，这样每个线程就可以只去自己私有的对象池中获得对象即可。** 这当然是可行的，而且，往大了说，这可以说是从底层延伸过来的一种编程思想，举个最简单的例子，每一个线程都有自己的栈，每个线程的局部变量都存储在自己的栈中。很好，既然说到这里，我就想请大家看一下刚才程序中的两段代码。请看下面的代码块。

这个是最开始的那个测试类，在下面代码块的第 8 到第 10 行，向对象池中放了 20 本书，并且是按照从小到大的顺序放进去的。比如，先放进去的是第一本书，然后是第二本等等。

Java

复制代码

`public class TestObjectPool {     public static void main(String[] args) throws InterruptedException {         //创建一个Book对象的对象池         ObjectPool bookPool = new ObjectPool();         //先往对象池中放20本书         for (int i = 0; i < 20; i++) {             Book booK = new Book("第"+i+"本书");             bookPool.backBook(booK);         }         //创建5个线程，每个线程都去对象池中获取书籍         for (int i = 0; i < 20; i++) {             new Thread(new Runnable() {                 @Override                 public void run() {                     //从对象池中获得书                     Book book = bookPool.getBook();                     System.out.println(Thread.currentThread().getName()+"获得了"+book.getIndex());                 }             }).start();         }     } }`

启动上面的测试类之后，得到下面的结果。

Java

复制代码

`/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/bin/java -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=57184:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/charsets.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/cldrdata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/dnsns.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/jaccess.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/localedata.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/nashorn.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunec.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/ext/zipfs.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jce.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jfr.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/jsse.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/management-agent.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/resources.jar:/Users/chenqingyang/Library/Java/JavaVirtualMachines/corretto-1.8.0_372/Contents/Home/jre/lib/rt.jar:/Users/chenqingyang/code/gitcode/my-netty/netty-13/target/classes:/Users/chenqingyang/Repository/org/slf4j/slf4j-api/1.7.30/slf4j-api-1.7.30.jar:/Users/chenqingyang/Repository/org/slf4j/slf4j-simple/1.7.28/slf4j-simple-1.7.28.jar:/Users/chenqingyang/Repository/org/jctools/jctools-core/3.0.0/jctools-core-3.0.0.jar com.pp.netty.test.TestObjectPool Thread-0获得了第19本书 Thread-2获得了第17本书 Thread-4获得了第15本书 Thread-1获得了第18本书 Thread-3获得了第16本书 Thread-5获得了第14本书 Thread-6获得了第13本书 Thread-7获得了第12本书 Thread-8获得了第11本书 Thread-9获得了第10本书 Thread-10获得了第9本书 Thread-11获得了第8本书 Thread-12获得了第7本书 Thread-13获得了第6本书 Thread-14获得了第5本书 Thread-15获得了第4本书 Thread-16获得了第3本书 Thread-17获得了第2本书 Thread-18获得了第1本书 Thread-19获得了第0本书 Process finished with exit code 0`

当然，上面线程打印到控制台的顺序有些散乱，但是如果大家按照线程从小到大的顺序去观察，会发现第 0 号线程拿走了第 19 本书，第 1 号线程拿走了第 18 本书，而最后一个线程，也就是 19 号线程，拿走了第 0 本书。总之，就是最先被放进来的书最晚被拿走，而最后被放进来书，最早被拿走。先进后出，后进先出，这多像一个栈呀。既然气氛都烘托到这里了，我们为什么不直接用数组给每个线程模拟一个私有的栈呢？既然是每个线程私有的栈，就可以使用上一章讲到的 FastthreadLocal 体系了。这简直太完美了！面对难题，并不感到恐惧，而是发散思路解决难题，这才是一个有胆识的程序员的所作所为！现在，既然是为每一个线程创建一个私有栈，也就是私有的对象池，存储在线程的本地 Map 中，线程从私有的对象池中获得对象，然后把对象放回到私有的对象池中，只要线程一直存活，它就可以一直使用自己的对象池。同步锁也就不再使用了，这就是一次典型的无锁化思想的具体实践。当然，同时也应该认识到，既然要为每一个线程都创建私有对象池，这就意味着要占用更多内存，以空间换时间。这就要求程序员仔细考虑对象池的创建，不可能为很多对象都创建，而且对象池中的数组容量怎么限制，创建出来的每一个对象都要回收到对象池中吗？这些就是更复杂的细节问题了。再进一步讨论之前，先让我用栈再次重构程序中的对象池吧。

# 为线程创建私有对象池

请看下面的代码，在下面的代码块中，会借助 FasThreadLocal 体系为线程创建私有的对象池，而对象池的名称就是 Stack，也就是栈的意思。Stack 中有一个数组容器用来存放可以复用的对象。

Java

复制代码

 `//对象池究竟是什么？首先要清楚一个概念，对象池是对于线程而言的，每个线程都有自己的对象缓存，也就是对象池  //可以这么说，对象池实际上就是每一个线程的本地栈，也就是stack。而Recycler这个类，在我看来，这个类只不过是每个线程  //从各自对象池中获取对象的入口。由该类的方法得到fastthreadlocal，然后得到本地线程的map，每个线程的stack就存储在这个  //私有的map当中，是真正的对象池 public abstract class Recycler<T> {     //这个属性就是staack最大的容量值,默认为4096     private static final int DEFAULT_MAX_CAPACITY_PER_THREAD = 4 * 1024;     /**      * @Author: PP-jessica      * @Description:stack默认的初始容量，为256个      */     private static final int INITIAL_CAPACITY = 256;     //抽象方法     protected abstract T newObject();     //获取线程私有对象池的入口方法     private final FastThreadLocal<Stack<T>> threadLocal = new FastThreadLocal<Stack<T>>() {         //这个就是返回线程私有栈stack的方法，这个不用多讲了吧，这是fastthreadlocal的知识。         @Override         protected Stack<T> initialValue() {             return new Stack<T>(DEFAULT_MAX_CAPACITY_PER_THREAD);         }     };     //对象池的重点方法，我称它为每个线程的对象池的入口方法，就是通过这个方法，每个线程得到了     //各自的stack，stack就是每个线程自己的对象池     //由此可见，Recycler类其实就是对每个线程的对象池做了一个封装     public final T get() {         //从线程的私有map中获得stack，这里就是通过之前创建的fastthreadlocal得到私有的map，其实map中存储数据的是数组，数组的下标         //由fastthreadlocal确定了。接着就取出固定下标位置的stack，也就是该线程拥有的一个对象池         Stack<T> stack = threadLocal.get();         //从stack对象池中取出被缓存的对象         Object object = stack.pop();          //如果object为null，说明对象池中还没有缓存的对象         if (object == null) {             //这里调用了newObject方法，这个方法就是Recycler类中需要重写的一个抽象方法             //要把哪个类的对象设置成对象池模式，就在哪个类中创建Recycler对象，然后重写newObject方法。             object = newObject();         }         //返回对象         return (T) object;     }     //回收对象的方法     public void recycle(Object object) {         //这里就遇到难题了，在上一个版本的Recycler类中，直接通过elements[size++] = object         //这行代码就把对象归还给数组了，但现在我已经为Recycler类引入了一个Stack，现在         //Stack才是真正的线程私有的对象池，可是，现在归还的对象，根本不知道自己属于哪个对象池         //也就是说，根本不知道自己属于哪个栈，这该怎么归还呢              }     static final class Stack<T> {                  //当前stack数组中存储了多少个对象         private int size;         //stack中数组的最大容量         private final int maxCapacity;         //stack中存储对象的数组容器         private Object[] elements;         //构造方法         Stack(int maxCapacity) {             //这里INITIAL_CAPACITY是stack中数组的初始容量             elements = new Object[INITIAL_CAPACITY];             //最大容量赋值             this.maxCapacity = maxCapacity;         }                  //这个就是从stack对象池获取缓存对象的方法，         Object pop() {             //得到数组中存储的对象的个数             int size = this.size;             if (size == 0) {                 //如果没有对象，直接返回null                  return null;             }             //要从stack中拿走一个对象，所以要减1             size --;             //存储对象的个数减1正好得到数组存储的最后一个对象的数组下标，取出该下标的对象             Object object = elements[size];             //把数组原位置置为null             elements[size] = null;             //取走了一个对象，要重新给size赋值             this.size = size;             //返回该对象             return object;         }         //归还对象的方法          void push( Object object) {              //首先得到数组的存储数据的个数             int size = this.size;             //在这里判断一下stack存储的对象的个数是否超过了最大容量             if (size >= maxCapacity) {                 //超过最大容量就不能再回收了                 return;             }             //走到这里说明stack允许存放的对象的个数还未到最大值，但是数组容量不够了，就把数组扩容             if (size == elements.length) {                 //扩容一倍                 elements = Arrays.copyOf(elements, min(size << 1, maxCapacity));             }             //对象真正被回收到stack中了             elements[size] = item;             //增添了一个对象，所以size加1             this.size = size + 1;          }     }      }`

上面就是我重构好的 Recycler 类，而 Book 类稍微有些变动。请看下面的代码块。

Java

复制代码

`public class Book{     //在这里创建Book自己的对象池,从静态属性可以看出来，该对象池只创建一次，只创建一个     private static final Recycler<Book> RECYCLER = new Recycler<Book>() {         @Override         protected Book newObject() {             return new Book();         }     };     //该方法就是从book的对象池中获得book对象的方法     static Book newInstance() {         //从对象池中获取对象         return  RECYCLER.get();     }     //回收对象的方法     public void recycle() {         RECYCLER.recycle(this);     }          //其他方法暂且省略 }`

接着是一个测试例子。

Java

复制代码

`Book book = Book.newInstance(); book.recycle();`

现在应该为大家梳理程序的执行流程了，但是执行流程一点也不复杂，所以我就简单分析一下。当程序执行 Book.newInstance() 这行代码的时候，会先通过 Recycler 的 get 方法去获得存储在线程的私有 Map 中的对象池，如果对象池还未创建，就创建对象池。接着会从对象池中获取对象，如果对象池中没有对象，就创建对象然后返回该对象，如果有对象，就直接获得对象使用。对象使用完毕后，会调用对象的 recycle 方法，将对象归还给对象池。流程确实一点也不复杂，但是如大家所见，在重构后的 Recycler 类中，有一个很重要的方法尚未实现，就是归还对象给对象池的方法。原因很简单，因为程序根本不知道归还的对象究竟是属于哪个对象池，或者说，根本没办法得到线程私有的 Stack。我知道肯定有人会建议我像下面这样编写代码。

Java

复制代码

 `//回收对象的方法     public void recycle(Object object) {         //得到了Stack         Stack<T> stack = threadLocal.get();             stack.push(object);     }`

向上面这样不就可以了吗？多么简单的事啊！对啊，多么简单的事啊，你能想出来，难道正在给你写文章讲解对象池的我想不出来吗？所以，我不这么写肯定是有原因的，而且是十分重要的原因，但这个原因现在还不能透露给大家。现在，我只要求大家想想，不通过上面那种做法，怎么让对象知道自己是属于哪个 Stack 的？讲到这里，大家其实应该对这些编程套路都很熟悉了，无非就是两种方法，要不然把 Stack 定义成对象的成员变量，创建对象的时候把 Stack 赋值给对象的成员变量，这种做法显然十分麻烦，可以直接排除了。第二种做法就是给要缓存的对象做一层包装，而且是在程序内部做包装，这个包装对用户来说是完全透明的，用户根本感知不到。显然，第二种方法更适合程序员大展拳脚。所以，接下来，我就用第二种方法再次重构一下当前的程序。

# 包装对象池中的对象

首先，我打算定义一个接口，就定义为 Handle。请看下面的代码。

Java

复制代码

 `public interface Handle<T> {     //回收对象的方法        void recycle(T object); }`

接着是这个接口的默认实现类 DefaultHandle。

Java

复制代码

`/** * @Author: PP-jessica * @Description:接口的静态实现类,注意，这里定义成静态实现类，是因为该实现类也是Recycler的内部类 实际上，后面要引入的所有新的类，都是Recycler的内部类。在Netty源码中，和对象池有关的所有功能都在Recycler类中实现了 */ static final class DefaultHandle<T> implements Handle<T> {     //handle中是要持有stack的，这个很重要。因为handle要知道这个对象本身是从那个线程的对象池中获得的     private Stack<?> stack;     //这个属性就是要被池化的那个对象     private Object value;     //构造方法     DefaultHandle(Stack<?> stack) {        this.stack = stack;     }      /**       * @Author: PP-jessica       * @Description:回收对象的方法       */      @Override      public void recycle(Object object) {          //如果对象为null，直接抛出异常          if (object != value) {              throw new IllegalArgumentException("object does not belong to handle");          }             //得到对象所属的Stack         Stack<?> stack = this.stack;         //把对象回收到线程对应的stack对象池中         stack.push(this);            }      }`

在上面代码块的 recycle 方法中，大家可以看到，在归还对象的时候归还的并不是对象本身，而是把对象包装了一下的 DefaultHandle 对象。这其实就意味着，我现在构建的对象池缓存的就不能再是对象本身了，也要经过一番重构了。至少 Stack 中的数组容器存储的应该是 DefaultHandle 对象了。请看下面的代码块，重构的地方还是比较多的，每一行都可以看看，仔细对比一下和之前代码的差异。

Java

复制代码

`public abstract class Recycler<T> {     //这个属性就是staack最大的容量值,默认为4096     private static final int DEFAULT_MAX_CAPACITY_PER_THREAD = 4 * 1024;     /**      * @Author: PP-jessica      * @Description:stack默认的初始容量，为256个      */     private static final int INITIAL_CAPACITY = 256;     //抽象方法也重构了     protected abstract T newObject(Handle<T> handle);     //获取线程私有对象池的入口方法     private final FastThreadLocal<Stack<T>> threadLocal = new FastThreadLocal<Stack<T>>() {         //这个就是返回线程私有栈stack的方法，这个不用多讲了吧，这是fastthreadlocal的知识。         @Override         protected Stack<T> initialValue() {             return new Stack<T>(DEFAULT_MAX_CAPACITY_PER_THREAD);         }     };     public final T get() {         Stack<T> stack = threadLocal.get();         //从stack对象池中取出被缓存的DefaultHandle对象         DefaultHandle<T> handle = stack.pop();          //如果DefaultHandle为null，说明对象池中还没有缓存的对象         if (handle == null) {             //首先创建一个handle             handle = stack.newHandle();             //然后创建一个新的要被线程使用的对象交给handle             //这里调用了newObject方法，这个方法就是Recycler类中需要重写的一个抽象方法             //要把哪个类的对象设置成对象池模式，就在哪个类中创建Recycler对象，然后重写newObject方法。             handle.value = newObject(handle);         }         //返回对象         return (T) handle.value;     }     //内部接口      public interface Handle<T> {      //回收对象的方法         void recycle(T object);          }     //内部接口的静态实现类     static final class DefaultHandle<T> implements Handle<T> {             //handle中是要持有stack的，这个很重要。因为handle要知道这个对象本身是从那个线程的对象池中获得的             private Stack<?> stack;             //这个属性就是要被池化的那个对象             private Object value;             //构造方法             DefaultHandle(Stack<?> stack) {                this.stack = stack;             }                       /**               * @Author: PP-jessica               * @Description:回收对象的方法               */              @Override              public void recycle(Object object) {                  //如果对象为null，直接抛出异常                  if (object != value) {                      throw new IllegalArgumentException("object does not belong to handle");                  }                     //得到对象所属的Stack                 Stack<?> stack = this.stack;                 //把DefaultHandle对象回收到线程对应的stack对象池中                 stack.push(this);                        }              }     static final class Stack<T> {                  //当前stack数组中存储了多少个对象         private int size;         //stack中数组的最大容量         private final int maxCapacity;         //stack中存储对象的数组容器         private DefaultHandle<?>[] elements;         //构造方法         Stack(int maxCapacity) {             //这里INITIAL_CAPACITY是stack中数组的初始容量             elements = new DefaultHandle[INITIAL_CAPACITY];             //最大容量赋值             this.maxCapacity = maxCapacity;         }         //创建一个handle，用来包装要被缓存的对象         DefaultHandle<T> newHandle() {             return new DefaultHandle<T>(this);         }                  //这个就是从stack对象池获取缓存对象的方法，         DefaultHandle<T> pop() {             //得到数组中存储的对象的个数             int size = this.size;             if (size == 0) {                 //如果没有对象，直接返回null                  return null;             }             //要从stack中拿走一个对象，所以要减1             size --;             //存储对象的个数减1正好得到数组存储的最后一个对象的数组下标，取出该下标的对象             DefaultHandle object = elements[size];             //把数组原位置置为null             elements[size] = null;             //取走了一个对象，要重新给size赋值             this.size = size;             //返回该对象             return object;         }         //归还对象的方法          void push(DefaultHandle<?> object) {              //首先得到数组的存储数据的个数             int size = this.size;             //在这里判断一下stack存储的对象的个数是否超过了最大容量             if (size >= maxCapacity) {                 //超过最大容量就不能再回收了                 return;             }             //走到这里说明stack允许存放的对象的个数还未到最大值，但是数组容量不够了，就把数组扩容             if (size == elements.length) {                 //扩容一倍                 elements = Arrays.copyOf(elements, min(size << 1, maxCapacity));             }             //对象真正被回收到stack中了             elements[size] = item;             //增添了一个对象，所以size加1             this.size = size + 1;          }     }      }`

在 Recycler 终于重构完善之后，接下来，我再次使用刚才的 Book 为例子，为大家展示一下用重构好的 Recycler 为 Book 类创建对象池。请看下面的代码块。

Java

复制代码

`public class Book{     //该属性就是对象池暴露给对象的，当对象要回收到对象池的时候，就是通过这个属性进行回收的     //这也再次印证了我刚才的一些话，对象池技术并不能随随便便就暴露给用户使用     //一般来说，要为哪些对象创建对象池，是开发框架的程序员在程序内部定义好的     //这一切对用户来说都是透明的，用户直接使用该对象的对象池即可     private final Recycler.Handle<Wife> recyclerHandle;     //在这里创建Book自己的对象池,从静态属性可以看出来，该对象池只创建一次，只创建一个     private static final Recycler<Book> RECYCLER = new Recycler<Book>() {         @Override         protected Book newObject((Handle<Book> handle) {             return new Book(handle);         }     };     //构造方法     public Book(Recycler.Handle<Book> recyclerHandle) {         this.recyclerHandle = recyclerHandle;     }     //该方法就是从book的对象池中获得book对象的方法     static Book newInstance() {         //从对象池中获取对象         return  RECYCLER.get();     }     //回收对象的方法     public void recycle() {         recyclerHandle.recycle(this);     }      }`

现在，Book 的对象池也创建完成了，如果想使用 Book 的对象池，仍然是调用下面两行代码即可。请看下面的代码块。

Java

复制代码

`//从Book的对象池中获取对象 Book book = Book.newInstance(); //使用完对象后归还对象 book.recycle();`

# 梳理本章程序的执行流程

到此为止，我终于可以为大家梳理一下本章程序的执行流程了。当程序执行 Book.newInstance() 这行代码的时候，就会从已经创建好的 Book 的对象池，也就是线程私有的 Stack 中获取缓存的 Book 对象。如果是第一次从对象池中获取对象，这个时候肯定还没有缓存 Book 对象呢。因此，程序就会执行到下面这个代码块的第 8 行和第 12 行。

Java

复制代码

`public final T get() {     Stack<T> stack = threadLocal.get();     //从stack对象池中取出被缓存的DefaultHandle对象     DefaultHandle<T> handle = stack.pop();      //如果DefaultHandle为null，说明对象池中还没有缓存的对象     if (handle == null) {         //首先创建一个handle         handle = stack.newHandle();         //然后创建一个新的要被线程使用的对象交给handle         //这里调用了newObject方法，这个方法就是Recycler类中需要重写的一个抽象方法         //要把哪个类的对象设置成对象池模式，就在哪个类中创建Recycler对象，然后重写newObject方法。         handle.value = newObject(handle);     }     //返回对象     return (T) handle.value; }`

程序会先创建一个 DefaultHandle 对象，创建 DefaultHandle 对象的时候，会让该 DefaultHandle 对象持有其所属的 Stack 的引用，这样 DefaultHandle 对象就知道它究竟是属于哪个 Stack。然后再调用 newObject(handle) 方法创建一个 Book 对象，并且把该对象交给刚才创建好的 DefaultHandle 保管，接着返回该 Book 对象即可。如果不是第一次从对象池中获取 Book 对象，并且对象池中有缓存的 DefaultHandle 对象的话，那么就直接返回 DefaultHandle 对象中的 Book 对象即可。这就是从对象池中获取对象的整个流程。

当对象使用完毕，应该把对象归还给对象池的时候，调用的就是 Book 对象中的 recycle 方法。注意，这个方法是程序内部为 Book 对象定义好的。如果用户非要使用程序提供的对象池技术，那么就应该以上面那个 Book 类为模版，为想要创建对象池的类定义合适的构造方法，recycle 方法等等。一旦程序调用了 recycle 方法，就会来到 DefaultHandle 类中，执行该类的 recycle 方法。就是下面的代码块。

Java

复制代码

`@Override public void recycle(Object object) {     //如果对象为null，直接抛出异常     if (object != value) {         throw new IllegalArgumentException("object does not belong to handle");     }     //得到对象所属的Stack    Stack<?> stack = this.stack;    //把DefaultHandle对象回收到线程对应的stack对象池中    stack.push(this); }`

在上面的代码块中，程序又会进一步调用到 Stack 中的 push 方法，把 DefaultHandle 对象归还到 Stack 内部的数组容器中。因为 Book 对象的引用被 DefaultHandle 对象持有着，肯定不会被垃圾回收掉，所以 Book 对象也就相当于被缓存起来了。到此为止，我的对象池就终于重构完整了，这一章的内容也就可以圆满结束了。

# 分析当前程序的缺陷

但是，按照以往文章的写作风格，一旦出现但是两个字，就意味着本章还不能结束，非但不能结束，而且程序很可能出现很大的漏洞，解决起来十分棘手。没错，确实是这样的，容我解释一句，如果我们现在的程序永远不会遇到并发回收对象到对象池的情况，那么我现在搭建的这个对象池就会很完美了，这一章直接结束就可以了。但是，显然我们不可能避开并发回收对象到对象池的情况。当然，这里我要给大家解释一下，所谓的并发回收对象到对象池是什么意思。在解释之前，让我们先来分析这样一个小场景：现在有两个线程，分别是 1 号线程和 2 号线程。这两个线程执行了如下的操作，请看下面代码块。

在下面的代码块中，就把主线程当成 1 号线程，把新创建的线程当作 2 号线程即可。

Java

复制代码

`public class RecyclerTest {     public static void main(String[] args) throws Exception {         //主线程从对象池中获得了对象，这里请允许我稍微解释一下         //主线程结束之后，程序就退出了，回不回收对象也没有意义         //这个测试例子十分简陋，只是为了模拟可能出现的并发问题         //所以就请大家先不要在意什么主线程结束程序就退出的事了         Book book = Book.newInstance();         //但是这个对象马上就交给一个新的线程使用了，并且在新的线程中被归还给对象池         new Thread(() -> {             //新的线程把对象归还给对象池，这里请大家思考一下，将对象归还给对象池的时候             //是不是直接就把对象归还给1号线程的对象池了？             book.recycle();         }, "Thread-1").start();     } }`

现在我们都知道了，创建对象池其本质就是为每一个线程创建一个私有的 Stack。在 Netty 中，就是通过 FastThreadLocal 体系来完成这个功能的。只要线程要从对象池中获得对象，程序内部就会自动把这个线程私有的对象池创建出来，然后存储到线程私有的 Map 中。对象使用完之后，也是要让每个对象池所属的线程，把对象归还给对象池。这样的逻辑才称得上完美，程序运行也不会出现什么问题。但是，现实往往不如人意，就像大多数程序员在工作中所做的那样，可能两行代码就实现了相应的功能，但是不得不多写十几行代码防止用户给程序捣乱。就像上面代码块中展示的内容，一般来说，都是在线程自身内执行完任务或者某些方法，对象使用完毕后，直接就在本线程中归还给对象池了。可是有的用户可能偏偏就把对象交给另外的线程使用，然后在另外的线程中将对象归还给对象池。这就很烦人了，对吧？

大家还记得这篇文章前面第一次重构 Recycler 的时候，我并没有实现 recycle 方法。也不打算采取下面代码块中的逻辑实现该方法。请看下面的代码块。

Java

复制代码

 `//回收对象的方法     public void recycle(Object object) {         //得到了Stack         Stack<T> stack = threadLocal.get();         stack.push(object);     }`

如果按照上面代码块的逻辑回收对象到对象池，那么当目前的 2 号线程正在回收 1 号线程的对象时，就会直接把原本属于 1 号线程私有对象池的对象，回收到 2 号线程的私有对象池中了。因为 threadLocal.get() 这行代码得到的一定是执行 recycle 方法的线程自己的对象池。所以，这时候大家就应该明白我为什么不使用上面代码块的逻辑实现 recycle 方法了吧。

当然，话说回来，让 2 号线程帮助 1 号线程回收对象也不是不行。如果使用我最后重构好的 Recycler 类的功能来执行这个操作，显然程序就会执行到下面这个代码块中。

Java

复制代码

`@Override public void recycle(Object object) {     //如果对象为null，直接抛出异常     if (object != value) {         throw new IllegalArgumentException("object does not belong to handle");     }     //得到对象所属的Stack    Stack<?> stack = this.stack;    //把DefaultHandle对象回收到线程对应的stack对象池中    stack.push(this); }`

因为被回收到对象池的是 DefaultHandle 对象，而 DefaultHandle 对象内部持有者自己所属的 Stack 的引用。因此，在上面代码的第 8 行，就可以直接得到被回收的对象应该被回收到的那个 Stack，也就是对象池。这样一来，即便是 2 号线程帮助 1 号线程回收对象，也可以把对象精准地回收到 1 号线程私有的对象池中。这么来看确实一点问题也没有。但是，我想问问大家，如果现在使用程序的用户特别犯贱，就是喜欢故意找事，之前是创建了两个线程，2 号线程回收 1 号线程的对象到 1 号线程的对象池中。接下来，这个用户又创建了 10 个线程，然后又在 1 号线程中从对象池中获得了 10 个 Book 对象，然后把这 10 个 Book 对象分别交给新创建的 10 个线程，每个线程帮忙回收一个到 1 号线程的对象池中(能把程序玩成这样，你要说用户不是故意的，我都不信！)。这时候会发生什么呢？显然，并发问题导致的数据混乱会卷土重来。

很简单，线程的私有对象池，也就是 Stack 中真正缓存对象的是一个数组容器，当初为了提升对象池的性能，我去掉了程序中解决并发问题的同步锁，用空间换时间的思想，为每个线程都创建了一个对象池，巧妙解决了并发问题。但现在多个线程同时帮助一个线程回收多个对象，会把多个对象同时存放到那个线程的 Stack 的数组容器中。而那个数组容器增删数据时可是没有同步锁来保障并发安全的，所以并发问题就再次出现了。

讲到这里，大家应该也再次意识到了，其实程序中很多问题都是并发引起的，如果没有并发，换句话说，如果自始至终程序中只有一个线程在工作，那我们开发程序的效率就会大大提高。但也正是只有一个线程在工作，程序的工作效率可能就大大降低。因此才引入了并发编程，但是随着并发编程的引入，随之而来的就是并发问题。为了解决并发问题，往往会使用同步锁，但同步锁又会对程序的工作效率造成一定的影响。这就像是一个无法找到起点的圆，我们的程序总要在安全和性能中找到一个绝佳的平衡点。这一点想必大家已经深有体会了。

好了，说了这么多，上面出现的并发问题究竟该怎么解决呢？这一章肯定是讲不完了，就放到下一章讲解吧。但是我可以给大家一个小提示，从程序性能的角度考虑，当然会再次排除同步锁的方式。可不用同步锁该用什么呢？想想这一章使用的空间换时间的思想，为每一个线程创建私有对象池的编程思路，大家也许会有点启发。我可以负责任的告诉大家，在 Netty 的对象池这个模块，解决并发问题的思路都是一脉相承的。

好了，我们下一章见。

# 总结

这一章的内容非常多，但整体的脉络十分清晰。如果非要说点什么，那就请大家品味品味空间换时间的思想，以及无锁化解决并发问题的编程思想吧。