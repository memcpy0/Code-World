q()
mean(abs(rnorm(100)))
rnorm(10)
x <- c(1,2,4)
x
q <- c(1,2,3)
d <- c(q,q,q)
d
d[1]
d[1:5]
mean(d)
sd(d)
y <- mean(d)
y
# print out y
y
data()
mean(Nile)
sd(Nile)
hist(Nile)
q()
# counts the number of odd integers in x
oddcount <- function(x){}
oddcount <- function(x){}
oddcount <- function(x){ k <- 0 # assign 0 to k}
for (n in x) { if (n %% 2 == 1) k <- k+1 }
}
return(k)
oddcount <- function(x){                                                                                                                            }
addoddcount <- function{}
addoddcount <- function{
addoddcount <- function{
addoddcount <- function(x){}
addoddcount <- function(x){
for(n in x){}
oddcount <- function(x){}
oddcount <- function(x){
for(n in x){
if(n %% 2 == 1)
install.packages("fBasics")
install.packages("tidyverse")
library(tidyverse)
data()
?mtcats
?mtcars
local({pkg <- select.list(sort(.packages(all.available = TRUE)),graphics=TRUE)
if(nchar(pkg)) library(pkg, character.only=TRUE)})
utils:::menuInstallPkgs()
install.packages("devtools")
library(devtools)
install_github("hadlley/dplyr")
q()
library(tidyverse)
mpg
ggplot(data = mpg) +geom_point(mapping = aes(x = displ, y = hwy))
z <- c(1:5, NA) # 生成向量z
z
is.na(z)
is.character(z)
is.numeric(z)
is.complex(z)
is.double(z)
is.integer(z)
is.logicao(z)
is.logical(z)
x <- seq(0,1, by=0.2)
x
y <- seq(0, 1, by=0.2)
y
y[4]
x[3]
1 - x[3]
y[4] > 1 - x[3]
x <- c(1, 3, 5, 7, 9) # 用c() 构建向量
x
c(1, 3, 5, 7, 9) -> y
y
z <- c("Male", "Female", "Male", "Male")
z
u = c(TRUE, FALSE, TRUE, FALSE, FALSE)
U
u = c(TRUE, FALSE, TRUE, FALSE, FALSE)
u
v <- paste("x", z, seq="1")
v
v <- paste("x", z, sep ="1")
v
assign("w", c(1, 3, 5, 7, 9))
w
paste("Hello", "World", sep = " my ")
paste("A", 1:6, sep = "")
paste(letters[1:6], collapse = ", ")
paste("A", 1:6, sep = "", collapse = ", ")
paste(letters[1:4], sep=" _")
paste(letters[1:4], " _", sep = "")
paste(letters[1:4], seq="_")
paste(1:10, sep=",")
paste(1:10, 1, sep = ", ")
paste(1:10, collapse = ",")
paste(1:10, 1, collapse = "-")
paste(1:10, 1, sep = ",", collapse = "-")
paste(1:10, 1)
paste(1:10, 1, collapse=NULL)
x <- c(1,3,5,7,9)
x -> y
y
y[1] <- 0
y
x
c(1,3,5,7,9) -> y
x * y
x / y
x^2
y^x
y
c(1, 3, 5) + c(2,4,6,8,10)
c(1,3,5) + c(2,4,6,8,10)
(t <- 1:10)
t <- 1:1-
0
t
t <- 1:10
t
(r <- 5:1)
2*1:5
seq(1, 10, 2)
seq(1, 10)
seq(10, 1, -1)
seq(1, by=2, length=10)
rep(c(1,3), 4)
rep(c(1:3), each=4)
rep(1:3, rep(2, 3))
rep(1:3, 2)
rep(1:3, each=2)
x <- c(1, 3, 5, 7, 9)
length(x)
min(x)
max(x)
range(x)
median(x)
sum(x)
mean(x)
var(x)
sd(x)
sort(x)
rev(x)
sort(x)
rank(x)
append(x, 1)
replace(x[1], 0)
x <- c(1, 3, 5)
x[2]
(c(1,2,3)+4)[2]
(1:3+4)[2]
x[2]
1:6:2
x[2] <- 10
x
x[c(1, 3)] <- c(9, 11)
x
x <- c(1,3,5)
x < 4
x[x<4]
z <- c(-1, 1:3, NA)
z
z[is.na(z)] <- 0
z
z <- c(-1, 1:3, NA)
y <- z[!is.na(z)]
y
x <- c(-3, -2, -1, 0, 5, 7)
x
y <- numeric(length(x))
y
y[x<0] <- 1-x[x<0]
y
y[x>=0] <- 1+x[x>=0]
y
matrix(1:12, nrow=4, ncol=3)
matrix(1:12, nrow=4, ncol=3, byrow=T)
matrix(1:12, nrow=4, ncol=3, byrow=TRUE)
matrix(1:12, nrow=4, ncol=3, byrow=F)
matrix(1:12, nrow=4, ncol=3, byrow=FALSE)
(xx <- matrix(1:12, c(3,4), dimnames=list(c("a", "b", "c", "d"), c("a", "b", "c", "d")), byrow=T))
(xx <- matrix(1:12, c(3,4), dimnames=list(c("a", "b", "c"), c("a", "b", "c", "d")), byrow=T))
(A <- matrix(1:12, c(3,4)))
t(A)
A <- B <- matrix(1:12, nrow=3)
A + B
3*A
B <- t(A)
B
B
A
A%*%B
x <- c(-3, -2, -1, 0, 5, 7)
x[-1]
x[-2]
if(1 < 2) c("需要吗") else ("艾")
if(1 < 2) c("需要吗") else c("艾")
if(1 > 2) c("需要吗") else c("艾")
ifelse(1<2, c("艾"), c("需要吗"))
x <- 3
if(x>2)  y = 2*x else y=3*x
y
x <- 1.5
if(x>2) y=2*x else y=3*x
y
x <- 1
ifelse(x>2, y<-2*x, y<-3*x)
switch(1, 2*3, sd(1:5), runif(3))
switch(2, 2*3, sd(1:5), runif(3))
switch(3, 2*3, sd(1:5), runif*3))
switch(3, 2*3, sd(1:5), runif(3))
x <- "meat"
switch(x, meat="chicken", fruit="apple", vegetable="potato")
Fibonacci <- NULL # new a null vector
Fibonacci[1] <- Fibonacci <- 1
Fibonacci[1] <- Fibonacci[2] <- 1
n = 16
for (i in 3:n) Fibonacci[i] <- Fibonacci[i-2] + Fibonacci[i-1]
Fibonacci
Fibonacci[1] <- Fibonacci[2] <- 1
i <- 1
while (Fibonacci[i] + Fibonacci[i+1] < 1000)
Fibonacci[i+2] = Fibonacci[i+1] + Fibonacci[i]
while (Fibonacci[i] + Fibonacci[i+1] < 1000)
Fibonacci[i+2] = Fibonacci[i+1] + Fibonacci[i]
print(Fibonacci)
if (Fibonacci[i]+Fibonacci[i+1] >= 1000) break
if (Fibonacci[i]+Fibonacci[i+1] >= 1000) break
# while (Fibonacci[i]+Fibonacci[i+1]<1000) {  #用while执行循环语句
#  Fibonacci[i+2]<-Fibonacci[i]+Fibonacci[i+1]
#  i<-i+1
#}
repeat {
Fibonacci[i+2] <- Fibonacci[i+1] + Fibonacci[i]
i <- i+1
if (Fibonacci[i]+Fibonacci[i+1] >= 1000) break
}
if (Fibonacci[i]+Fibonacci[i+1]>=1000) print(Fibonacci) break
break
print(Fibonacci)
std = function(x) { sqrt(var(x = ))}
std = function(x) { sqrt(var(x = ))}
std = function(x) { sqrt(var(x))}
std(c(1, 3, 5, 7, 9))
std
std = function(x) { return(sqrt(var(x)))}
std(c(1, 3, 5, 7, 9))
std
welcome = function() print("welcome to use R")
welcome()
welcome.sb = function(names) print(paste("welcome", names, "to use R"))
welcome.sb("Mr fang")
welcome.sb = function(names="Mr fang") print(paste("welcome", names, "to use R"))
welcome.sb()
sim.t = function(n) {}
sim.t = function(n) { mu=10; sigma=5; x=rnorm(n, mu, sigma); (mean(x)-mu)/(sd(x)/sqrt(n))}
sim.t(5)
my.average = function(x) sum(x)/length(x)
my.arverage(c(1,2,3))
my.average(c(1,2,3))
a <- c(2,4, 43, 2, 42, 56)
sort(a)
rev(a)
rev(sort(a))
return(list(xbar=mean(xx), top5(xx)))
return(list(xbar=mean(xx), top5=xx))
vms(y)
print(vms(y))
return(list(xbar=mean(xx), top5=xx))
(vms(y))
vms(y)
vms=function(x){
xx=rev(sort(x)) #对x向量从小到大排序，然后用rev()转成从大到小排序
xx=xx[1:5] #提取前面5个元素
# mean(xx) #求均值
return(list(xbar=mean(xx),top5=xx)) #返回均值和最大的5个数
}
y = c(5,15,32,25,26,28,65,48,3,37,45,54,23,44)
vms(y)
(vms(y))
(vms(y))
else if (z[i]>0) print("GG")
print("GG")
z[i] <- x[i] - 90
print("GG")
for (i in 1:length(x)) {
if (z[i]<0)
print("GPa")
else if (z[i]>0)
print("GG")
}
x <- c(89, 90, 91, 92, 93)
z <- y <- NULL
for (i in 1:length(x)) z[i] <- x[i] - 90
for (i in 1:length(x)) {
if (z[i]<0)
print("GPa")
else if (z[i]>0)
print("GG")
}
Fibonacci[1] <- Fibonacci[2] <- 1 # Fibonacci向量的第1和2个元素赋值为1
i<-1
# while (Fibonacci[i]+Fibonacci[i+1]<1000) {  #用while执行循环语句
#  Fibonacci[i+2]<-Fibonacci[i]+Fibonacci[i+1]
#  i<-i+1
#}
repeat {    #用repeat执行循环语句
Fibonacci[i+2]<-Fibonacci[i]+Fibonacci[i+1]
i<-i+1
if (Fibonacci[i]+Fibonacci[i+1]>=1000) break
}
print(Fibonacci)
vms=function(x){
xx=rev(sort(x)) #对x向量从小到大排序，然后用rev()转成从大到小排序
xx=xx[1:5] #提取前面5个元素
# mean(xx) #求均值
return(list(xbar=mean(xx),top5=xx)) #返回均值和最大的5个数
}
y = c(5,15,32,25,26,28,65,48,3,37,45,54,23,44)
(vms(y))
vms=function(x){
xx=rev(sort(x)) #对x向量从小到大排序，然后用rev()转成从大到小排序
xx=xx[1:5] #提取前面5个元素
# mean(xx) #求均值
return(list(xbar=mean(xx),top5=xx)) #返回均值和最大的5个数
}
y = c(5,15,32,25,26,28,65,48,3,37,45,54,23,44)
(vms(y))
pi
pi^exp(1)
exp(1)^pi
(exp(pi))^exp(1)
exp(pi)
exp(pi)^exp(1)
(exp(pi))^exp(1)
pi^exp(1)-exp(pi)
x <- c(1, 3, 5)
y <- c(2, 4, 6)
e <- c(1, 1, 1)
z <- 3*x + y*y + e
z
x%*%y
crossprod(x, y)
tcrossprod(x, y)
x%o%y
x%o%y
outer(x, y)
A = matrix(c(35, 4, 12, 2, 14, 11, 9, 5, 11, 3, 38, 12, 1, 0, 4, 2), 4)
A
rep(1:5, 5) + rep(0:4, rep(5, 5))
N = 500
rep(1:5, 5) + rep(0:4, each=5)
sum(seq(1, N)^(-1)) > log(N)+0.6
N = 1000
sum(seq(1, N)^(-1)) > log(N)+0.6
N = 2000
sum(seq(1, N)^(-1)) > log(N)+0.6
N = 4000
sum(seq(1, N)^(-1)) > log(N)+0.6
N = 8000
sum(seq(1, N)^(-1)) > log(N)+0.6
det(solve(A))
det(A)
det(A%*%t(A))
det(t(A)%*%A)
det(crossprod(A, A))
det(tcrossprod(A, A))
det(solve(A)%*%A)
det(solve(A)%*%A-A%*%solve(A))
solve(A)%*%A-A%*%solve(A)
solve(A)%*%A
det(solve(A)%*%A)
det(A%*%solve(A))
setwd("D://R_Projects")
